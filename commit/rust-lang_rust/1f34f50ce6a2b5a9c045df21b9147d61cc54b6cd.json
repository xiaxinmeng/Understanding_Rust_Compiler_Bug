{"sha": "1f34f50ce6a2b5a9c045df21b9147d61cc54b6cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMzRmNTBjZTZhMmI1YTljMDQ1ZGYyMWI5MTQ3ZDYxY2M1NGI2Y2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-26T12:31:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-26T12:31:50Z"}, "message": "auto merge of #11127 : huonw/rust/vec-docs, r=alexcrichton", "tree": {"sha": "c5873f9c664fccabda4c293d74e1a2f0b6e46033", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5873f9c664fccabda4c293d74e1a2f0b6e46033"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f34f50ce6a2b5a9c045df21b9147d61cc54b6cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f34f50ce6a2b5a9c045df21b9147d61cc54b6cd", "html_url": "https://github.com/rust-lang/rust/commit/1f34f50ce6a2b5a9c045df21b9147d61cc54b6cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f34f50ce6a2b5a9c045df21b9147d61cc54b6cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "html_url": "https://github.com/rust-lang/rust/commit/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec"}, {"sha": "b29e5486331aa9d2610c818fcd10b4b63985f41f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b29e5486331aa9d2610c818fcd10b4b63985f41f", "html_url": "https://github.com/rust-lang/rust/commit/b29e5486331aa9d2610c818fcd10b4b63985f41f"}], "stats": {"total": 142, "additions": 115, "deletions": 27}, "files": [{"sha": "aa349ed81860a81bdee6b7caaec4e71ff5ecce73", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 115, "deletions": 27, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/1f34f50ce6a2b5a9c045df21b9147d61cc54b6cd/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34f50ce6a2b5a9c045df21b9147d61cc54b6cd/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1f34f50ce6a2b5a9c045df21b9147d61cc54b6cd", "patch": "@@ -2143,26 +2143,69 @@ pub trait MutableVector<'a, T> {\n      */\n     fn mut_pop_ref(&mut self) -> &'a mut T;\n \n-    /**\n-     * Swaps two elements in a vector\n-     *\n-     * # Arguments\n-     *\n-     * * a - The index of the first element\n-     * * b - The index of the second element\n-     */\n+    /// Swaps two elements in a vector.\n+    ///\n+    /// Fails if `a` or `b` are out of bounds.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert_eq!(v, [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n     fn swap(self, a: uint, b: uint);\n \n-    /**\n-     * Divides one `&mut` into two. The first will\n-     * contain all indices from `0..mid` (excluding the index `mid`\n-     * itself) and the second will contain all indices from\n-     * `mid..len` (excluding the index `len` itself).\n-     */\n+\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Fails if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.mut_split_at(0);\n+    ///    assert_eq!(left, &mut []);\n+    ///    assert_eq!(right, &mut [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(2);\n+    ///     assert_eq!(left, &mut [1, 2]);\n+    ///     assert_eq!(right, &mut [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(6);\n+    ///     assert_eq!(left, &mut [1, 2, 3, 4, 5, 6]);\n+    ///     assert_eq!(right, &mut []);\n+    /// }\n+    /// ```\n     fn mut_split_at(self, mid: uint) -> (&'a mut [T],\n                                       &'a mut [T]);\n \n-    /// Reverse the order of elements in a vector, in place\n+    /// Reverse the order of elements in a vector, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1, 2, 3];\n+    /// v.reverse();\n+    /// assert_eq!(v, [3, 2, 1]);\n+    /// ```\n     fn reverse(self);\n \n     /// Sort the vector, in place, using `compare` to compare\n@@ -2212,20 +2255,48 @@ pub trait MutableVector<'a, T> {\n     #[inline]\n     fn as_mut_ptr(self) -> *mut T;\n \n-    /// Unsafely sets the element in index to the value\n+    /// Unsafely sets the element in index to the value.\n+    ///\n+    /// This performs no bounds checks, and it is undefined behaviour\n+    /// if `index` is larger than the length of `self`. However, it\n+    /// does run the destructor at `index`. It is equivalent to\n+    /// `self[index] = val`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = ~[~\"foo\", ~\"bar\", ~\"baz\"];\n+    ///\n+    /// unsafe {\n+    ///     // `~\"baz\"` is deallocated.\n+    ///     v.unsafe_set(2, ~\"qux\");\n+    ///\n+    ///     // Out of bounds: could cause a crash, or overwriting\n+    ///     // other data, or something else.\n+    ///     // v.unsafe_set(10, ~\"oops\");\n+    /// }\n+    /// ```\n     unsafe fn unsafe_set(self, index: uint, val: T);\n \n-    /**\n-     * Unchecked vector index assignment.  Does not drop the\n-     * old value and hence is only suitable when the vector\n-     * is newly allocated.\n-     */\n+    /// Unchecked vector index assignment.  Does not drop the\n+    /// old value and hence is only suitable when the vector\n+    /// is newly allocated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [~\"foo\", ~\"bar\"];\n+    ///\n+    /// // memory leak! `~\"bar\"` is not deallocated.\n+    /// unsafe { v.init_elem(1, ~\"baz\"); }\n+    /// ```\n     unsafe fn init_elem(self, i: uint, val: T);\n \n-    /// Copies data from `src` to `self`.\n+    /// Copies raw bytes from `src` to `self`.\n     ///\n-    /// `self` and `src` must not overlap. Fails if `self` is\n-    /// shorter than `src`.\n+    /// This does not run destructors on the overwritten elements, and\n+    /// ignores move semantics. `self` and `src` must not\n+    /// overlap. Fails if `self` is shorter than `src`.\n     unsafe fn copy_memory(self, src: &[T]);\n }\n \n@@ -2370,8 +2441,25 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n /// Trait for &[T] where T is Cloneable\n pub trait MutableCloneableVector<T> {\n-    /// Copies as many elements from `src` as it can into `self`\n-    /// (the shorter of self.len() and src.len()). Returns the number of elements copied.\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::vec::MutableCloneableVector;\n+    ///\n+    /// let mut dst = [0, 0, 0];\n+    /// let src = [1, 2];\n+    ///\n+    /// assert_eq!(dst.copy_from(src), 2);\n+    /// assert_eq!(dst, [1, 2, 0]);\n+    ///\n+    /// let src2 = [3, 4, 5, 6];\n+    /// assert_eq!(dst.copy_from(src2), 3);\n+    /// assert_eq!(dst, [3, 4, 5]);\n+    /// ```\n     fn copy_from(self, &[T]) -> uint;\n }\n \n@@ -2390,7 +2478,7 @@ impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n pub trait MutableTotalOrdVector<T> {\n     /// Sort the vector, in place.\n     ///\n-    /// This is equivalent to `self.sort_by(std::vec::SortForward)`.\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n     ///\n     /// # Example\n     ///"}]}