{"sha": "09703e3843622430276d0b3c672fbc772ce0b862", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NzAzZTM4NDM2MjI0MzAyNzZkMGIzYzY3MmZiYzc3MmNlMGI4NjI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-15T22:42:58Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-19T09:01:49Z"}, "message": "Adjust other names after the `Mark` renaming", "tree": {"sha": "0dc50e1c9b48fa2d9112783d32d9b15380e9f070", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dc50e1c9b48fa2d9112783d32d9b15380e9f070"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09703e3843622430276d0b3c672fbc772ce0b862", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09703e3843622430276d0b3c672fbc772ce0b862", "html_url": "https://github.com/rust-lang/rust/commit/09703e3843622430276d0b3c672fbc772ce0b862", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09703e3843622430276d0b3c672fbc772ce0b862/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "url": "https://api.github.com/repos/rust-lang/rust/commits/31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "html_url": "https://github.com/rust-lang/rust/commit/31e10aec83d68df0f45cf6643cca4e90e9c1fb55"}], "stats": {"total": 388, "additions": 196, "deletions": 192}, "files": [{"sha": "d02aab54127a650694a5d9d1a7006e390602d80e", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -75,7 +75,7 @@ impl<'a> DefCollector<'a> {\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId) {\n-        self.definitions.set_invocation_parent(id.placeholder_to_mark(), self.parent_def);\n+        self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n }\n "}, {"sha": "8ee8c6d0e898368be2dc6974d39c5fadfb487b2d", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -450,7 +450,7 @@ impl Definitions {\n                                   parent: DefIndex,\n                                   node_id: ast::NodeId,\n                                   data: DefPathData,\n-                                  expansion: ExpnId,\n+                                  expn_id: ExpnId,\n                                   span: Span)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n@@ -498,8 +498,8 @@ impl Definitions {\n             self.node_to_def_index.insert(node_id, index);\n         }\n \n-        if expansion != ExpnId::root() {\n-            self.expansions_that_defined.insert(index, expansion);\n+        if expn_id != ExpnId::root() {\n+            self.expansions_that_defined.insert(index, expn_id);\n         }\n \n         // The span is added if it isn't dummy\n@@ -523,12 +523,12 @@ impl Definitions {\n         self.expansions_that_defined.get(&index).cloned().unwrap_or(ExpnId::root())\n     }\n \n-    pub fn parent_module_of_macro_def(&self, mark: ExpnId) -> DefId {\n-        self.parent_modules_of_macro_defs[&mark]\n+    pub fn parent_module_of_macro_def(&self, expn_id: ExpnId) -> DefId {\n+        self.parent_modules_of_macro_defs[&expn_id]\n     }\n \n-    pub fn add_parent_module_of_macro_def(&mut self, mark: ExpnId, module: DefId) {\n-        self.parent_modules_of_macro_defs.insert(mark, module);\n+    pub fn add_parent_module_of_macro_def(&mut self, expn_id: ExpnId, module: DefId) {\n+        self.parent_modules_of_macro_defs.insert(expn_id, module);\n     }\n \n     pub fn invocation_parent(&self, invoc_id: ExpnId) -> DefIndex {"}, {"sha": "77a6abd4b776c8d5f2fc05d6336781684654bf5c", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -588,7 +588,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n \n         let expn_info_tag = u8::decode(self)?;\n \n-        // FIXME(mw): This method does not restore `MarkData::parent` or\n+        // FIXME(mw): This method does not restore `InternalExpnData::parent` or\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n         // as long as incremental compilation does not kick in before that."}, {"sha": "47a741ca7141b66c7ff0c9174a012297a55b9504", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -572,7 +572,7 @@ pub fn lower_to_hir(\n \n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !sess.opts.debugging_opts.keep_hygiene_data {\n-        syntax::ext::hygiene::clear_markings();\n+        syntax::ext::hygiene::syntax_context_map();\n     }\n \n     Ok(hir_forest)"}, {"sha": "ee11228654b6fb4f8ad1065d09be3a7b7e318942", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -571,13 +571,13 @@ impl<'a> Resolver<'a> {\n                                        variant: &Variant,\n                                        parent: Module<'a>,\n                                        vis: ty::Visibility,\n-                                       expansion: ExpnId) {\n+                                       expn_id: ExpnId) {\n         let ident = variant.node.ident;\n \n         // Define a name in the type namespace.\n         let def_id = self.definitions.local_def_id(variant.node.id);\n         let res = Res::Def(DefKind::Variant, def_id);\n-        self.define(parent, ident, TypeNS, (res, vis, variant.span, expansion));\n+        self.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n@@ -596,11 +596,11 @@ impl<'a> Resolver<'a> {\n         let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n-        self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expansion));\n+        self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: ExpnId) {\n+    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expn_id: ExpnId) {\n         let (res, ns) = match item.node {\n             ForeignItemKind::Fn(..) => {\n                 (Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id)), ValueNS)\n@@ -615,16 +615,16 @@ impl<'a> Resolver<'a> {\n         };\n         let parent = self.current_module;\n         let vis = self.resolve_visibility(&item.vis);\n-        self.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n+        self.define(parent, item.ident, ns, (res, vis, item.span, expn_id));\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block, expansion: ExpnId) {\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, expn_id: ExpnId) {\n         let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n             let module = self.new_module(parent,\n                                          ModuleKind::Block(block.id),\n                                          parent.normal_ancestor_id,\n-                                         expansion,\n+                                         expn_id,\n                                          block.span);\n             self.block_map.insert(block.id, module);\n             self.current_module = module; // Descend into the block.\n@@ -741,8 +741,8 @@ impl<'a> Resolver<'a> {\n         module\n     }\n \n-    pub fn macro_def_scope(&mut self, expansion: ExpnId) -> Module<'a> {\n-        let def_id = match self.macro_defs.get(&expansion) {\n+    pub fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+        let def_id = match self.macro_defs.get(&expn_id) {\n             Some(def_id) => *def_id,\n             None => return self.graph_root,\n         };\n@@ -924,7 +924,7 @@ pub struct BuildReducedGraphVisitor<'a, 'b> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n-        let invoc_id = id.placeholder_to_mark();\n+        let invoc_id = id.placeholder_to_expn_id();\n \n         self.resolver.current_module.unresolved_invocations.borrow_mut().insert(invoc_id);\n "}, {"sha": "0dae558c213505cf94db3f48f09095e7453ed44b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -2095,10 +2095,10 @@ impl<'a> Resolver<'a> {\n         parent: Module<'a>,\n         kind: ModuleKind,\n         normal_ancestor_id: DefId,\n-        expansion: ExpnId,\n+        expn_id: ExpnId,\n         span: Span,\n     ) -> Module<'a> {\n-        let module = ModuleData::new(Some(parent), kind, normal_ancestor_id, expansion, span);\n+        let module = ModuleData::new(Some(parent), kind, normal_ancestor_id, expn_id, span);\n         self.arenas.alloc_module(module)\n     }\n "}, {"sha": "08db285b5439fdca433e3f5c4bb037f19a34a3b0", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -160,23 +160,23 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n-    fn visit_ast_fragment_with_placeholders(&mut self, mark: ExpnId, fragment: &AstFragment,\n+    fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n                                             derives: &[ExpnId]) {\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, mark));\n+        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expn_id));\n \n-        let invocation = self.invocations[&mark];\n+        let invocation = self.invocations[&expn_id];\n         self.current_module = invocation.module;\n-        self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n+        self.current_module.unresolved_invocations.borrow_mut().remove(&expn_id);\n         self.current_module.unresolved_invocations.borrow_mut().extend(derives);\n-        let parent_def = self.definitions.invocation_parent(mark);\n+        let parent_def = self.definitions.invocation_parent(expn_id);\n         for &derive_invoc_id in derives {\n             self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n         }\n         self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n             current_legacy_scope: invocation.parent_legacy_scope,\n-            expansion: mark,\n+            expansion: expn_id,\n         };\n         fragment.visit_with(&mut visitor);\n         invocation.output_legacy_scope.set(Some(visitor.current_legacy_scope));\n@@ -223,16 +223,16 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, &parent_scope, force)?;\n \n         let span = invoc.span();\n-        invoc.expansion_data.mark.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n+        invoc.expansion_data.id.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n \n         if let Res::Def(_, def_id) = res {\n             if after_derive {\n                 self.session.span_err(span, \"macro attributes must be placed before `#[derive]`\");\n             }\n-            self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n+            self.macro_defs.insert(invoc.expansion_data.id, def_id);\n             let normal_module_def_id =\n-                self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n-            self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n+                self.macro_def_scope(invoc.expansion_data.id).normal_ancestor_id;\n+            self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.id,\n                                                             normal_module_def_id);\n         }\n "}, {"sha": "b9b43c89346c7e372327ab8dd1a9ee346967251f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -251,11 +251,11 @@ mod node_id_inner {\n pub use node_id_inner::NodeId;\n \n impl NodeId {\n-    pub fn placeholder_from_mark(mark: ExpnId) -> Self {\n-        NodeId::from_u32(mark.as_u32())\n+    pub fn placeholder_from_expn_id(expn_id: ExpnId) -> Self {\n+        NodeId::from_u32(expn_id.as_u32())\n     }\n \n-    pub fn placeholder_to_mark(self) -> ExpnId {\n+    pub fn placeholder_to_expn_id(self) -> ExpnId {\n         ExpnId::from_u32(self.as_u32())\n     }\n }"}, {"sha": "926c9e88efe157eecf5cc6a3ef17a206588e7396", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -685,7 +685,7 @@ pub trait Resolver {\n     fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId;\n \n     fn resolve_dollar_crates(&mut self);\n-    fn visit_ast_fragment_with_placeholders(&mut self, mark: ExpnId, fragment: &AstFragment,\n+    fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n                                             derives: &[ExpnId]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n \n@@ -705,7 +705,7 @@ pub struct ModuleData {\n \n #[derive(Clone)]\n pub struct ExpansionData {\n-    pub mark: ExpnId,\n+    pub id: ExpnId,\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n     pub directory_ownership: DirectoryOwnership,\n@@ -735,7 +735,7 @@ impl<'a> ExtCtxt<'a> {\n             root_path: PathBuf::new(),\n             resolver,\n             current_expansion: ExpansionData {\n-                mark: ExpnId::root(),\n+                id: ExpnId::root(),\n                 depth: 0,\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },\n@@ -763,13 +763,13 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n-        match self.current_expansion.mark.expn_info() {\n+        match self.current_expansion.id.expn_info() {\n             Some(expn_info) => expn_info.call_site,\n             None => DUMMY_SP,\n         }\n     }\n     pub fn backtrace(&self) -> SyntaxContext {\n-        SyntaxContext::empty().apply_mark(self.current_expansion.mark)\n+        SyntaxContext::empty().apply_mark(self.current_expansion.id)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n@@ -877,7 +877,7 @@ impl<'a> ExtCtxt<'a> {\n         ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n-        let def_site = DUMMY_SP.apply_mark(self.current_expansion.mark);\n+        let def_site = DUMMY_SP.apply_mark(self.current_expansion.id);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n             .chain(components.iter().map(|&s| Ident::with_empty_ctxt(s)))\n             .collect()\n@@ -900,7 +900,7 @@ pub fn expr_to_spanned_string<'a>(\n     err_msg: &str,\n ) -> Result<Spanned<(Symbol, ast::StrStyle)>, Option<DiagnosticBuilder<'a>>> {\n     // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n-    expr.span = expr.span.apply_mark(cx.current_expansion.mark);\n+    expr.span = expr.span.apply_mark(cx.current_expansion.id);\n \n     // we want to be able to handle e.g., `concat!(\"foo\", \"bar\")`\n     cx.expander().visit_expr(&mut expr);"}, {"sha": "ff9ad46deecc078c0d3a7cf1683d2f08f502bb2d", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -54,7 +54,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n         names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n     }\n \n-    let span = span.fresh_expansion(cx.current_expansion.mark, ExpnInfo::allow_unstable(\n+    let span = span.fresh_expansion(cx.current_expansion.id, ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n         cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n     ));"}, {"sha": "ae72f1fd108ed99f87b76ef9c244992d42db887b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -319,7 +319,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             };\n \n             let scope =\n-                if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n+                if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n             let ext = match self.cx.resolver.resolve_macro_invocation(&invoc, scope, force) {\n                 Ok(ext) => ext,\n                 Err(Indeterminate) => {\n@@ -329,9 +329,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             };\n \n             progress = true;\n-            let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n+            let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n-            self.cx.current_expansion.mark = scope;\n+            self.cx.current_expansion.id = scope;\n \n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n@@ -362,13 +362,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n                 let mut item_with_markers = item.clone();\n                 add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n-                let derives = derives.entry(invoc.expansion_data.mark).or_default();\n+                let derives = derives.entry(invoc.expansion_data.id).or_default();\n \n                 derives.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n-                    let mark = ExpnId::fresh(self.cx.current_expansion.mark, None);\n-                    derives.push(mark);\n+                    let expn_id = ExpnId::fresh(self.cx.current_expansion.id, None);\n+                    derives.push(expn_id);\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive {\n                             path,\n@@ -377,7 +377,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         },\n                         fragment_kind: invoc.fragment_kind,\n                         expansion_data: ExpansionData {\n-                            mark,\n+                            id: expn_id,\n                             ..invoc.expansion_data.clone()\n                         },\n                     });\n@@ -392,7 +392,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             if expanded_fragments.len() < depth {\n                 expanded_fragments.push(Vec::new());\n             }\n-            expanded_fragments[depth - 1].push((mark, expanded_fragment));\n+            expanded_fragments[depth - 1].push((expn_id, expanded_fragment));\n             if !self.cx.ecfg.single_step {\n                 invocations.extend(new_invocations.into_iter().rev());\n             }\n@@ -405,7 +405,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         while let Some(expanded_fragments) = expanded_fragments.pop() {\n             for (mark, expanded_fragment) in expanded_fragments.into_iter().rev() {\n                 let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(NodeId::placeholder_from_mark(mark),\n+                placeholder_expander.add(NodeId::placeholder_from_expn_id(mark),\n                                          expanded_fragment, derives);\n             }\n         }\n@@ -444,7 +444,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         if self.monotonic {\n             self.cx.resolver.visit_ast_fragment_with_placeholders(\n-                self.cx.current_expansion.mark, &fragment, derives);\n+                self.cx.current_expansion.id, &fragment, derives);\n         }\n \n         (fragment, invocations)\n@@ -493,7 +493,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            let info = self.cx.current_expansion.mark.expn_info().unwrap();\n+            let info = self.cx.current_expansion.id.expn_info().unwrap();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n             let mut err = self.cx.struct_span_err(info.call_site,\n                 &format!(\"recursion limit reached while expanding the macro `{}`\",\n@@ -822,17 +822,17 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             )),\n             _ => None,\n         };\n-        let mark = ExpnId::fresh(self.cx.current_expansion.mark, expn_info);\n+        let expn_id = ExpnId::fresh(self.cx.current_expansion.id, expn_info);\n         self.invocations.push(Invocation {\n             kind,\n             fragment_kind,\n             expansion_data: ExpansionData {\n-                mark,\n+                id: expn_id,\n                 depth: self.cx.current_expansion.depth + 1,\n                 ..self.cx.current_expansion.clone()\n             },\n         });\n-        placeholder(fragment_kind, NodeId::placeholder_from_mark(mark))\n+        placeholder(fragment_kind, NodeId::placeholder_from_expn_id(expn_id))\n     }\n \n     fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: AstFragmentKind) -> AstFragment {"}, {"sha": "17d8bf3ab175ffe31b4b45f63e4899d929dc2961", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         fragment.mut_visit_with(self);\n         if let AstFragment::Items(mut items) = fragment {\n             for derive in derives {\n-                match self.remove(NodeId::placeholder_from_mark(derive)) {\n+                match self.remove(NodeId::placeholder_from_expn_id(derive)) {\n                     AstFragment::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }"}, {"sha": "845dac557e8216b61b1e8ed6af6b722c868b1fc4", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -219,7 +219,7 @@ pub fn transcribe(\n                         if let NtTT(ref tt) = **nt {\n                             result.push(tt.clone().into());\n                         } else {\n-                            sp = sp.apply_mark(cx.current_expansion.mark);\n+                            sp = sp.apply_mark(cx.current_expansion.id);\n                             let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n                         }\n@@ -234,8 +234,8 @@ pub fn transcribe(\n                     // If we aren't able to match the meta-var, we push it back into the result but\n                     // with modified syntax context. (I believe this supports nested macros).\n                     let ident =\n-                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.mark));\n-                    sp = sp.apply_mark(cx.current_expansion.mark);\n+                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.id));\n+                    sp = sp.apply_mark(cx.current_expansion.id);\n                     result.push(TokenTree::token(token::Dollar, sp).into());\n                     result.push(TokenTree::Token(Token::from_ast_ident(ident)).into());\n                 }\n@@ -247,15 +247,15 @@ pub fn transcribe(\n             // jump back out of the Delimited, pop the result_stack and add the new results back to\n             // the previous results (from outside the Delimited).\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n-                span = span.apply_mark(cx.current_expansion.mark);\n+                span = span.apply_mark(cx.current_expansion.id);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::take(&mut result));\n             }\n \n             // Nothing much to do here. Just push the token to the result, being careful to\n             // preserve syntax context.\n             quoted::TokenTree::Token(token) => {\n-                let mut marker = Marker(cx.current_expansion.mark);\n+                let mut marker = Marker(cx.current_expansion.id);\n                 let mut tt = TokenTree::Token(token);\n                 noop_visit_tt(&mut tt, &mut marker);\n                 result.push(tt.into());"}, {"sha": "d82cdce2ce92b1bce72a7550f26beb0e6072f50c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -232,7 +232,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n \n     let name = Ident::from_str(\"__test_reexports\").gensym();\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n-    cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n+    cx.ext_cx.current_expansion.id = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().flat_map_item(P(ast::Item {\n         ident: name,\n         attrs: Vec::new(),"}, {"sha": "88142344d79e02bf2b2a593aa802b1b6d71606c0", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -545,10 +545,10 @@ impl DelimSpan {\n         self.open.with_hi(self.close.hi())\n     }\n \n-    pub fn apply_mark(self, mark: ExpnId) -> Self {\n+    pub fn apply_mark(self, expn_id: ExpnId) -> Self {\n         DelimSpan {\n-            open: self.open.apply_mark(mark),\n-            close: self.close.apply_mark(mark),\n+            open: self.open.apply_mark(expn_id),\n+            close: self.close.apply_mark(expn_id),\n         }\n     }\n }"}, {"sha": "235565314f5e29e891bec55c74b17a8c7058d8f1", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -25,7 +25,7 @@ pub fn expand_assert<'cx>(\n         }\n     };\n \n-    let sp = sp.apply_mark(cx.current_expansion.mark);\n+    let sp = sp.apply_mark(cx.current_expansion.id);\n     let panic_call = Mac_ {\n         path: Path::from_ident(Ident::new(sym::panic, sp)),\n         tts: custom_message.unwrap_or_else(|| {"}, {"sha": "2b64f558be0a0223f2eff73723bfbf07ee42ed66", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -17,7 +17,7 @@ pub fn expand_cfg(\n     sp: Span,\n     tts: &[tokenstream::TokenTree],\n ) -> Box<dyn base::MacResult + 'static> {\n-    let sp = sp.apply_mark(cx.current_expansion.mark);\n+    let sp = sp.apply_mark(cx.current_expansion.id);\n \n     match parse_cfg(cx, sp, tts) {\n         Ok(cfg) => {"}, {"sha": "dbc985fd8599a679c4623805be55f80499a24b04", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -60,6 +60,6 @@ pub fn expand_syntax_ext(\n     } else if has_errors {\n         return base::DummyResult::expr(sp);\n     }\n-    let sp = sp.apply_mark(cx.current_expansion.mark);\n+    let sp = sp.apply_mark(cx.current_expansion.id);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))\n }"}, {"sha": "8184fc442676dc517464e4588288d97c2a4b4ced", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -39,7 +39,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         }\n     }\n \n-    let ident = ast::Ident::new(Symbol::intern(&res_str), sp.apply_mark(cx.current_expansion.mark));\n+    let ident = ast::Ident::new(Symbol::intern(&res_str), sp.apply_mark(cx.current_expansion.id));\n \n     struct ConcatIdentsResult { ident: ast::Ident }\n "}, {"sha": "fef1b4eebcf965d30691b9937b9dcfa6196a401e", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -85,7 +85,7 @@ impl<'a> Path<'a> {\n             PathKind::Global => cx.path_all(span, true, idents, params, Vec::new()),\n             PathKind::Local => cx.path_all(span, false, idents, params, Vec::new()),\n             PathKind::Std => {\n-                let def_site = DUMMY_SP.apply_mark(cx.current_expansion.mark);\n+                let def_site = DUMMY_SP.apply_mark(cx.current_expansion.id);\n                 idents.insert(0, Ident::new(kw::DollarCrate, def_site));\n                 cx.path_all(span, false, idents, params, Vec::new())\n             }"}, {"sha": "03c60e3f11f03b7d411b3276000a92cbec15b53d", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -21,7 +21,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         Some(v) => v,\n     };\n \n-    let sp = sp.apply_mark(cx.current_expansion.mark);\n+    let sp = sp.apply_mark(cx.current_expansion.id);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n             let lt = cx.lifetime(sp, Ident::with_empty_ctxt(kw::StaticLifetime));"}, {"sha": "2f0d995098510ea2319c13b6f98a07e7d854172c", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -575,7 +575,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         for (i, e) in self.args.into_iter().enumerate() {\n             let name = names_pos[i];\n             let span =\n-                DUMMY_SP.with_ctxt(e.span.ctxt().apply_mark(self.ecx.current_expansion.mark));\n+                DUMMY_SP.with_ctxt(e.span.ctxt().apply_mark(self.ecx.current_expansion.id));\n             pats.push(self.ecx.pat_ident(span, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n                 locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, name));\n@@ -652,7 +652,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   ty: &ArgumentType,\n                   arg: ast::Ident)\n                   -> P<ast::Expr> {\n-        sp = sp.apply_mark(ecx.current_expansion.mark);\n+        sp = sp.apply_mark(ecx.current_expansion.id);\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n@@ -691,7 +691,7 @@ fn expand_format_args_impl<'cx>(\n     tts: &[tokenstream::TokenTree],\n     nl: bool,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    sp = sp.apply_mark(ecx.current_expansion.mark);\n+    sp = sp.apply_mark(ecx.current_expansion.id);\n     match parse_args(ecx, sp, tts) {\n         Ok((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names, nl))\n@@ -734,7 +734,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n \n     let mut macsp = ecx.call_site();\n-    macsp = macsp.apply_mark(ecx.current_expansion.mark);\n+    macsp = macsp.apply_mark(ecx.current_expansion.id);\n \n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;"}, {"sha": "e94d79a140da889ff7fcace3fc8dd24bf9ebc849", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -364,11 +364,11 @@ pub(crate) struct Rustc<'a> {\n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n+        let location = cx.current_expansion.id.expn_info().unwrap().call_site;\n         let to_span = |transparency| {\n             location.with_ctxt(\n                 SyntaxContext::empty()\n-                    .apply_mark_with_transparency(cx.current_expansion.mark, transparency),\n+                    .apply_mark_with_transparency(cx.current_expansion.id, transparency),\n             )\n         };\n         Rustc {"}, {"sha": "f8755a1d1d791131dbf46354fa08db2875cfa4ca", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -59,7 +59,7 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let ctxt = SyntaxContext::empty().apply_mark(cx.current_expansion.mark);\n+    let ctxt = SyntaxContext::empty().apply_mark(cx.current_expansion.id);\n     let (sp, attr_sp) = (item.span.with_ctxt(ctxt), attr_sp.with_ctxt(ctxt));\n \n     // Gensym \"test\" so we can extern crate without conflicting with any local names"}, {"sha": "355f2428e0806d1d66e92e26ceab1680ee1019c7", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -25,7 +25,7 @@ pub fn expand(\n ) -> Vec<Annotatable> {\n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.mark));\n+    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);"}, {"sha": "bea7809e029f6401f60e5078c89f790151542b79", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 107, "deletions": 103, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -35,33 +35,34 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use std::fmt;\n \n-/// A SyntaxContext represents a chain of macro expansions (represented by marks).\n+/// A `SyntaxContext` represents a chain of pairs `(ExpnId, Transparency)` named \"marks\".\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(u32);\n \n #[derive(Debug)]\n struct SyntaxContextData {\n-    outer_mark: ExpnId,\n+    outer_expn: ExpnId,\n     transparency: Transparency,\n     prev_ctxt: SyntaxContext,\n-    /// This context, but with all transparent and semi-transparent marks filtered away.\n+    /// This context, but with all transparent and semi-transparent expansions filtered away.\n     opaque: SyntaxContext,\n-    /// This context, but with all transparent marks filtered away.\n+    /// This context, but with all transparent expansions filtered away.\n     opaque_and_semitransparent: SyntaxContext,\n     /// Name of the crate to which `$crate` with this context would resolve.\n     dollar_crate_name: Symbol,\n }\n \n-/// A mark is a unique ID associated with a macro expansion.\n+/// A unique ID associated with a macro invocation and expansion.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct ExpnId(u32);\n \n+// FIXME: Find a way to merge this with `ExpnInfo`.\n #[derive(Debug)]\n-struct MarkData {\n+struct InternalExpnData {\n     parent: ExpnId,\n-    /// Each mark should have an associated expansion info, but sometimes there's a delay between\n-    /// creation of a mark and obtaining its info (e.g. macros are collected first and then\n-    /// resolved later), so we use an `Option` here.\n+    /// Each expansion should have an associated expansion info, but sometimes there's a delay\n+    /// between creation of an expansion ID and obtaining its info (e.g. macros are collected\n+    /// first and then resolved later), so we use an `Option` here.\n     expn_info: Option<ExpnInfo>,\n }\n \n@@ -86,10 +87,10 @@ pub enum Transparency {\n \n impl ExpnId {\n     pub fn fresh(parent: ExpnId, expn_info: Option<ExpnInfo>) -> Self {\n-        HygieneData::with(|data| data.fresh_mark(parent, expn_info))\n+        HygieneData::with(|data| data.fresh_expn(parent, expn_info))\n     }\n \n-    /// The mark of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n     #[inline]\n     pub fn root() -> Self {\n         ExpnId(0)\n@@ -107,7 +108,7 @@ impl ExpnId {\n \n     #[inline]\n     pub fn parent(self) -> ExpnId {\n-        HygieneData::with(|data| data.marks[self.0 as usize].parent)\n+        HygieneData::with(|data| data.expn_data[self.0 as usize].parent)\n     }\n \n     #[inline]\n@@ -118,8 +119,8 @@ impl ExpnId {\n     #[inline]\n     pub fn set_expn_info(self, info: ExpnInfo) {\n         HygieneData::with(|data| {\n-            let old_info = &mut data.marks[self.0 as usize].expn_info;\n-            assert!(old_info.is_none(), \"expansion info is reset for a mark\");\n+            let old_info = &mut data.expn_data[self.0 as usize].expn_info;\n+            assert!(old_info.is_none(), \"expansion info is reset for an expansion ID\");\n             *old_info = Some(info);\n         })\n     }\n@@ -128,8 +129,8 @@ impl ExpnId {\n         HygieneData::with(|data| data.is_descendant_of(self, ancestor))\n     }\n \n-    /// `mark.outer_is_descendant_of(ctxt)` is equivalent to but faster than\n-    /// `mark.is_descendant_of(ctxt.outer())`.\n+    /// `expn_id.outer_is_descendant_of(ctxt)` is equivalent to but faster than\n+    /// `expn_id.is_descendant_of(ctxt.outer())`.\n     pub fn outer_is_descendant_of(self, ctxt: SyntaxContext) -> bool {\n         HygieneData::with(|data| data.is_descendant_of(self, data.outer(ctxt)))\n     }\n@@ -152,43 +153,43 @@ impl ExpnId {\n \n #[derive(Debug)]\n crate struct HygieneData {\n-    marks: Vec<MarkData>,\n-    syntax_contexts: Vec<SyntaxContextData>,\n-    markings: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n+    expn_data: Vec<InternalExpnData>,\n+    syntax_context_data: Vec<SyntaxContextData>,\n+    syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n }\n \n impl HygieneData {\n     crate fn new(edition: Edition) -> Self {\n         HygieneData {\n-            marks: vec![MarkData {\n+            expn_data: vec![InternalExpnData {\n                 parent: ExpnId::root(),\n                 expn_info: Some(ExpnInfo::default(ExpnKind::Root, DUMMY_SP, edition)),\n             }],\n-            syntax_contexts: vec![SyntaxContextData {\n-                outer_mark: ExpnId::root(),\n+            syntax_context_data: vec![SyntaxContextData {\n+                outer_expn: ExpnId::root(),\n                 transparency: Transparency::Opaque,\n                 prev_ctxt: SyntaxContext(0),\n                 opaque: SyntaxContext(0),\n                 opaque_and_semitransparent: SyntaxContext(0),\n                 dollar_crate_name: kw::DollarCrate,\n             }],\n-            markings: FxHashMap::default(),\n+            syntax_context_map: FxHashMap::default(),\n         }\n     }\n \n     fn with<T, F: FnOnce(&mut HygieneData) -> T>(f: F) -> T {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn fresh_mark(&mut self, parent: ExpnId, expn_info: Option<ExpnInfo>) -> ExpnId {\n-        self.marks.push(MarkData { parent, expn_info });\n-        ExpnId(self.marks.len() as u32 - 1)\n+    fn fresh_expn(&mut self, parent: ExpnId, expn_info: Option<ExpnInfo>) -> ExpnId {\n+        self.expn_data.push(InternalExpnData { parent, expn_info });\n+        ExpnId(self.expn_data.len() as u32 - 1)\n     }\n \n-    fn expn_info(&self, mark: ExpnId) -> Option<&ExpnInfo> {\n-        if mark != ExpnId::root() {\n-            Some(self.marks[mark.0 as usize].expn_info.as_ref()\n-                     .expect(\"no expansion info for a mark\"))\n+    fn expn_info(&self, expn_id: ExpnId) -> Option<&ExpnInfo> {\n+        if expn_id != ExpnId::root() {\n+            Some(self.expn_data[expn_id.0 as usize].expn_info.as_ref()\n+                     .expect(\"no expansion info for an expansion ID\"))\n         } else {\n             // FIXME: Some code relies on `expn_info().is_none()` meaning \"no expansion\".\n             // Introduce a method for checking for \"no expansion\" instead and always return\n@@ -197,55 +198,55 @@ impl HygieneData {\n         }\n     }\n \n-    fn is_descendant_of(&self, mut mark: ExpnId, ancestor: ExpnId) -> bool {\n-        while mark != ancestor {\n-            if mark == ExpnId::root() {\n+    fn is_descendant_of(&self, mut expn_id: ExpnId, ancestor: ExpnId) -> bool {\n+        while expn_id != ancestor {\n+            if expn_id == ExpnId::root() {\n                 return false;\n             }\n-            mark = self.marks[mark.0 as usize].parent;\n+            expn_id = self.expn_data[expn_id.0 as usize].parent;\n         }\n         true\n     }\n \n-    fn default_transparency(&self, mark: ExpnId) -> Transparency {\n-        self.expn_info(mark).map_or(\n+    fn default_transparency(&self, expn_id: ExpnId) -> Transparency {\n+        self.expn_info(expn_id).map_or(\n             Transparency::SemiTransparent, |einfo| einfo.default_transparency\n         )\n     }\n \n     fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n-        self.syntax_contexts[ctxt.0 as usize].opaque\n+        self.syntax_context_data[ctxt.0 as usize].opaque\n     }\n \n     fn modern_and_legacy(&self, ctxt: SyntaxContext) -> SyntaxContext {\n-        self.syntax_contexts[ctxt.0 as usize].opaque_and_semitransparent\n+        self.syntax_context_data[ctxt.0 as usize].opaque_and_semitransparent\n     }\n \n     fn outer(&self, ctxt: SyntaxContext) -> ExpnId {\n-        self.syntax_contexts[ctxt.0 as usize].outer_mark\n+        self.syntax_context_data[ctxt.0 as usize].outer_expn\n     }\n \n     fn transparency(&self, ctxt: SyntaxContext) -> Transparency {\n-        self.syntax_contexts[ctxt.0 as usize].transparency\n+        self.syntax_context_data[ctxt.0 as usize].transparency\n     }\n \n     fn prev_ctxt(&self, ctxt: SyntaxContext) -> SyntaxContext {\n-        self.syntax_contexts[ctxt.0 as usize].prev_ctxt\n+        self.syntax_context_data[ctxt.0 as usize].prev_ctxt\n     }\n \n     fn remove_mark(&self, ctxt: &mut SyntaxContext) -> ExpnId {\n-        let outer_mark = self.syntax_contexts[ctxt.0 as usize].outer_mark;\n+        let outer_expn = self.syntax_context_data[ctxt.0 as usize].outer_expn;\n         *ctxt = self.prev_ctxt(*ctxt);\n-        outer_mark\n+        outer_expn\n     }\n \n     fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(ExpnId, Transparency)> {\n         let mut marks = Vec::new();\n         while ctxt != SyntaxContext::empty() {\n-            let outer_mark = self.outer(ctxt);\n+            let outer_expn = self.outer(ctxt);\n             let transparency = self.transparency(ctxt);\n             let prev_ctxt = self.prev_ctxt(ctxt);\n-            marks.push((outer_mark, transparency));\n+            marks.push((outer_expn, transparency));\n             ctxt = prev_ctxt;\n         }\n         marks.reverse();\n@@ -263,39 +264,39 @@ impl HygieneData {\n         span\n     }\n \n-    fn adjust(&self, ctxt: &mut SyntaxContext, expansion: ExpnId) -> Option<ExpnId> {\n+    fn adjust(&self, ctxt: &mut SyntaxContext, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut scope = None;\n-        while !self.is_descendant_of(expansion, self.outer(*ctxt)) {\n+        while !self.is_descendant_of(expn_id, self.outer(*ctxt)) {\n             scope = Some(self.remove_mark(ctxt));\n         }\n         scope\n     }\n \n-    fn apply_mark(&mut self, ctxt: SyntaxContext, mark: ExpnId) -> SyntaxContext {\n-        assert_ne!(mark, ExpnId::root());\n-        self.apply_mark_with_transparency(ctxt, mark, self.default_transparency(mark))\n+    fn apply_mark(&mut self, ctxt: SyntaxContext, expn_id: ExpnId) -> SyntaxContext {\n+        assert_ne!(expn_id, ExpnId::root());\n+        self.apply_mark_with_transparency(ctxt, expn_id, self.default_transparency(expn_id))\n     }\n \n-    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, mark: ExpnId,\n+    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, expn_id: ExpnId,\n                                     transparency: Transparency) -> SyntaxContext {\n-        assert_ne!(mark, ExpnId::root());\n+        assert_ne!(expn_id, ExpnId::root());\n         if transparency == Transparency::Opaque {\n-            return self.apply_mark_internal(ctxt, mark, transparency);\n+            return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n         let call_site_ctxt =\n-            self.expn_info(mark).map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n+            self.expn_info(expn_id).map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             self.modern(call_site_ctxt)\n         } else {\n             self.modern_and_legacy(call_site_ctxt)\n         };\n \n         if call_site_ctxt == SyntaxContext::empty() {\n-            return self.apply_mark_internal(ctxt, mark, transparency);\n+            return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n-        // Otherwise, `mark` is a macros 1.0 definition and the call site is in a\n+        // Otherwise, `expn_id` is a macros 1.0 definition and the call site is in a\n         // macros 2.0 expansion, i.e., a macros 1.0 invocation is in a macros 2.0 definition.\n         //\n         // In this case, the tokens from the macros 1.0 definition inherit the hygiene\n@@ -304,25 +305,27 @@ impl HygieneData {\n         // so that the macros 2.0 definition remains hygienic.\n         //\n         // See the example at `test/run-pass/hygiene/legacy_interaction.rs`.\n-        for (mark, transparency) in self.marks(ctxt) {\n-            call_site_ctxt = self.apply_mark_internal(call_site_ctxt, mark, transparency);\n+        for (expn_id, transparency) in self.marks(ctxt) {\n+            call_site_ctxt = self.apply_mark_internal(call_site_ctxt, expn_id, transparency);\n         }\n-        self.apply_mark_internal(call_site_ctxt, mark, transparency)\n+        self.apply_mark_internal(call_site_ctxt, expn_id, transparency)\n     }\n \n-    fn apply_mark_internal(&mut self, ctxt: SyntaxContext, mark: ExpnId, transparency: Transparency)\n-                           -> SyntaxContext {\n-        let syntax_contexts = &mut self.syntax_contexts;\n-        let mut opaque = syntax_contexts[ctxt.0 as usize].opaque;\n+    fn apply_mark_internal(\n+        &mut self, ctxt: SyntaxContext, expn_id: ExpnId, transparency: Transparency\n+    ) -> SyntaxContext {\n+        let syntax_context_data = &mut self.syntax_context_data;\n+        let mut opaque = syntax_context_data[ctxt.0 as usize].opaque;\n         let mut opaque_and_semitransparent =\n-            syntax_contexts[ctxt.0 as usize].opaque_and_semitransparent;\n+            syntax_context_data[ctxt.0 as usize].opaque_and_semitransparent;\n \n         if transparency >= Transparency::Opaque {\n             let prev_ctxt = opaque;\n-            opaque = *self.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n-                let new_opaque = SyntaxContext(syntax_contexts.len() as u32);\n-                syntax_contexts.push(SyntaxContextData {\n-                    outer_mark: mark,\n+            opaque = *self.syntax_context_map.entry((prev_ctxt, expn_id, transparency))\n+                                             .or_insert_with(|| {\n+                let new_opaque = SyntaxContext(syntax_context_data.len() as u32);\n+                syntax_context_data.push(SyntaxContextData {\n+                    outer_expn: expn_id,\n                     transparency,\n                     prev_ctxt,\n                     opaque: new_opaque,\n@@ -336,11 +339,12 @@ impl HygieneData {\n         if transparency >= Transparency::SemiTransparent {\n             let prev_ctxt = opaque_and_semitransparent;\n             opaque_and_semitransparent =\n-                    *self.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n+                    *self.syntax_context_map.entry((prev_ctxt, expn_id, transparency))\n+                                            .or_insert_with(|| {\n                 let new_opaque_and_semitransparent =\n-                    SyntaxContext(syntax_contexts.len() as u32);\n-                syntax_contexts.push(SyntaxContextData {\n-                    outer_mark: mark,\n+                    SyntaxContext(syntax_context_data.len() as u32);\n+                syntax_context_data.push(SyntaxContextData {\n+                    outer_expn: expn_id,\n                     transparency,\n                     prev_ctxt,\n                     opaque,\n@@ -352,11 +356,11 @@ impl HygieneData {\n         }\n \n         let prev_ctxt = ctxt;\n-        *self.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n+        *self.syntax_context_map.entry((prev_ctxt, expn_id, transparency)).or_insert_with(|| {\n             let new_opaque_and_semitransparent_and_transparent =\n-                SyntaxContext(syntax_contexts.len() as u32);\n-            syntax_contexts.push(SyntaxContextData {\n-                outer_mark: mark,\n+                SyntaxContext(syntax_context_data.len() as u32);\n+            syntax_context_data.push(SyntaxContextData {\n+                outer_expn: expn_id,\n                 transparency,\n                 prev_ctxt,\n                 opaque,\n@@ -368,8 +372,8 @@ impl HygieneData {\n     }\n }\n \n-pub fn clear_markings() {\n-    HygieneData::with(|data| data.markings = FxHashMap::default());\n+pub fn syntax_context_map() {\n+    HygieneData::with(|data| data.syntax_context_map = FxHashMap::default());\n }\n \n pub fn walk_chain(span: Span, to: SyntaxContext) -> Span {\n@@ -379,8 +383,8 @@ pub fn walk_chain(span: Span, to: SyntaxContext) -> Span {\n pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symbol) {\n     // The new contexts that need updating are at the end of the list and have `$crate` as a name.\n     let (len, to_update) = HygieneData::with(|data| (\n-        data.syntax_contexts.len(),\n-        data.syntax_contexts.iter().rev()\n+        data.syntax_context_data.len(),\n+        data.syntax_context_data.iter().rev()\n             .take_while(|scdata| scdata.dollar_crate_name == kw::DollarCrate).count()\n     ));\n     // The callback must be called from outside of the `HygieneData` lock,\n@@ -389,7 +393,7 @@ pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symb\n     let names: Vec<_> =\n         range_to_update.clone().map(|idx| get_name(SyntaxContext::from_u32(idx as u32))).collect();\n     HygieneData::with(|data| range_to_update.zip(names.into_iter()).for_each(|(idx, name)| {\n-        data.syntax_contexts[idx].dollar_crate_name = name;\n+        data.syntax_context_data[idx].dollar_crate_name = name;\n     }))\n }\n \n@@ -409,15 +413,15 @@ impl SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n-    /// Extend a syntax context with a given mark and default transparency for that mark.\n-    pub fn apply_mark(self, mark: ExpnId) -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark(self, mark))\n+    /// Extend a syntax context with a given expansion and default transparency for that expansion.\n+    pub fn apply_mark(self, expn_id: ExpnId) -> SyntaxContext {\n+        HygieneData::with(|data| data.apply_mark(self, expn_id))\n     }\n \n-    /// Extend a syntax context with a given mark and transparency\n-    pub fn apply_mark_with_transparency(self, mark: ExpnId, transparency: Transparency)\n+    /// Extend a syntax context with a given expansion and transparency.\n+    pub fn apply_mark_with_transparency(self, expn_id: ExpnId, transparency: Transparency)\n                                         -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark_with_transparency(self, mark, transparency))\n+        HygieneData::with(|data| data.apply_mark_with_transparency(self, expn_id, transparency))\n     }\n \n     /// Pulls a single mark off of the syntax context. This effectively moves the\n@@ -468,15 +472,15 @@ impl SyntaxContext {\n     /// ```\n     /// This returns the expansion whose definition scope we use to privacy check the resolution,\n     /// or `None` if we privacy check as usual (i.e., not w.r.t. a macro definition scope).\n-    pub fn adjust(&mut self, expansion: ExpnId) -> Option<ExpnId> {\n-        HygieneData::with(|data| data.adjust(self, expansion))\n+    pub fn adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n+        HygieneData::with(|data| data.adjust(self, expn_id))\n     }\n \n     /// Like `SyntaxContext::adjust`, but also modernizes `self`.\n-    pub fn modernize_and_adjust(&mut self, expansion: ExpnId) -> Option<ExpnId> {\n+    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         HygieneData::with(|data| {\n             *self = data.modern(*self);\n-            data.adjust(self, expansion)\n+            data.adjust(self, expn_id)\n         })\n     }\n \n@@ -505,17 +509,17 @@ impl SyntaxContext {\n     /// ```\n     /// This returns `None` if the context cannot be glob-adjusted.\n     /// Otherwise, it returns the scope to use when privacy checking (see `adjust` for details).\n-    pub fn glob_adjust(&mut self, expansion: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n+    pub fn glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n         HygieneData::with(|data| {\n             let mut scope = None;\n             let mut glob_ctxt = data.modern(glob_span.ctxt());\n-            while !data.is_descendant_of(expansion, data.outer(glob_ctxt)) {\n+            while !data.is_descendant_of(expn_id, data.outer(glob_ctxt)) {\n                 scope = Some(data.remove_mark(&mut glob_ctxt));\n                 if data.remove_mark(self) != scope.unwrap() {\n                     return None;\n                 }\n             }\n-            if data.adjust(self, expansion).is_some() {\n+            if data.adjust(self, expn_id).is_some() {\n                 return None;\n             }\n             Some(scope)\n@@ -529,16 +533,16 @@ impl SyntaxContext {\n     ///     assert!(self.glob_adjust(expansion, glob_ctxt) == Some(privacy_checking_scope));\n     /// }\n     /// ```\n-    pub fn reverse_glob_adjust(&mut self, expansion: ExpnId, glob_span: Span)\n+    pub fn reverse_glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span)\n                                -> Option<Option<ExpnId>> {\n         HygieneData::with(|data| {\n-            if data.adjust(self, expansion).is_some() {\n+            if data.adjust(self, expn_id).is_some() {\n                 return None;\n             }\n \n             let mut glob_ctxt = data.modern(glob_span.ctxt());\n             let mut marks = Vec::new();\n-            while !data.is_descendant_of(expansion, data.outer(glob_ctxt)) {\n+            while !data.is_descendant_of(expn_id, data.outer(glob_ctxt)) {\n                 marks.push(data.remove_mark(&mut glob_ctxt));\n             }\n \n@@ -550,10 +554,10 @@ impl SyntaxContext {\n         })\n     }\n \n-    pub fn hygienic_eq(self, other: SyntaxContext, mark: ExpnId) -> bool {\n+    pub fn hygienic_eq(self, other: SyntaxContext, expn_id: ExpnId) -> bool {\n         HygieneData::with(|data| {\n             let mut self_modern = data.modern(self);\n-            data.adjust(&mut self_modern, mark);\n+            data.adjust(&mut self_modern, expn_id);\n             self_modern == data.modern(other)\n         })\n     }\n@@ -591,7 +595,7 @@ impl SyntaxContext {\n     }\n \n     pub fn dollar_crate_name(self) -> Symbol {\n-        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].dollar_crate_name)\n+        HygieneData::with(|data| data.syntax_context_data[self.0 as usize].dollar_crate_name)\n     }\n }\n \n@@ -609,8 +613,8 @@ impl Span {\n     /// but its location is inherited from the current span.\n     pub fn fresh_expansion(self, parent: ExpnId, expn_info: ExpnInfo) -> Span {\n         HygieneData::with(|data| {\n-            let mark = data.fresh_mark(parent, Some(expn_info));\n-            self.with_ctxt(data.apply_mark(SyntaxContext::empty(), mark))\n+            let expn_id = data.fresh_expn_id(parent, Some(expn_info));\n+            self.with_ctxt(data.apply_mark(SyntaxContext::empty(), expn_id))\n         })\n     }\n }\n@@ -638,7 +642,7 @@ pub struct ExpnInfo {\n     /// The span of the macro definition (possibly dummy).\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Span,\n-    /// Transparency used by `apply_mark` for mark with this expansion info by default.\n+    /// Transparency used by `apply_mark` for the expansion with this expansion info by default.\n     pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in"}, {"sha": "b9a062c0765f092aed056e881100b2fc3f1ee7fa", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09703e3843622430276d0b3c672fbc772ce0b862/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=09703e3843622430276d0b3c672fbc772ce0b862", "patch": "@@ -530,34 +530,34 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn adjust(&mut self, expansion: ExpnId) -> Option<ExpnId> {\n+    pub fn adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut span = self.data();\n-        let mark = span.ctxt.adjust(expansion);\n+        let mark = span.ctxt.adjust(expn_id);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn modernize_and_adjust(&mut self, expansion: ExpnId) -> Option<ExpnId> {\n+    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut span = self.data();\n-        let mark = span.ctxt.modernize_and_adjust(expansion);\n+        let mark = span.ctxt.modernize_and_adjust(expn_id);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn glob_adjust(&mut self, expansion: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n+    pub fn glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n         let mut span = self.data();\n-        let mark = span.ctxt.glob_adjust(expansion, glob_span);\n+        let mark = span.ctxt.glob_adjust(expn_id, glob_span);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn reverse_glob_adjust(&mut self, expansion: ExpnId, glob_span: Span)\n+    pub fn reverse_glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span)\n                                -> Option<Option<ExpnId>> {\n         let mut span = self.data();\n-        let mark = span.ctxt.reverse_glob_adjust(expansion, glob_span);\n+        let mark = span.ctxt.reverse_glob_adjust(expn_id, glob_span);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }"}]}