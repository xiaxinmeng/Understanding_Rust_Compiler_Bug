{"sha": "4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNGQ5ZjdhOTBkYzA2MDU5OTJjNGY3NzRhOGQ5YTEzMjNhZDZkMWU=", "commit": {"author": {"name": "krk", "email": "keremkat@gmail.com", "date": "2019-10-31T20:10:58Z"}, "committer": {"name": "krk", "email": "keremkat@gmail.com", "date": "2019-10-31T20:10:58Z"}, "message": "Handle IfLet in convert_to_guarded_return.", "tree": {"sha": "e18fbba37ec5270c6fc740c0fc382fa08968cfcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e18fbba37ec5270c6fc740c0fc382fa08968cfcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e", "html_url": "https://github.com/rust-lang/rust/commit/4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e/comments", "author": {"login": "krk", "id": 1447853, "node_id": "MDQ6VXNlcjE0NDc4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1447853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krk", "html_url": "https://github.com/krk", "followers_url": "https://api.github.com/users/krk/followers", "following_url": "https://api.github.com/users/krk/following{/other_user}", "gists_url": "https://api.github.com/users/krk/gists{/gist_id}", "starred_url": "https://api.github.com/users/krk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krk/subscriptions", "organizations_url": "https://api.github.com/users/krk/orgs", "repos_url": "https://api.github.com/users/krk/repos", "events_url": "https://api.github.com/users/krk/events{/privacy}", "received_events_url": "https://api.github.com/users/krk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "krk", "id": 1447853, "node_id": "MDQ6VXNlcjE0NDc4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1447853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krk", "html_url": "https://github.com/krk", "followers_url": "https://api.github.com/users/krk/followers", "following_url": "https://api.github.com/users/krk/following{/other_user}", "gists_url": "https://api.github.com/users/krk/gists{/gist_id}", "starred_url": "https://api.github.com/users/krk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krk/subscriptions", "organizations_url": "https://api.github.com/users/krk/orgs", "repos_url": "https://api.github.com/users/krk/repos", "events_url": "https://api.github.com/users/krk/events{/privacy}", "received_events_url": "https://api.github.com/users/krk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "998088876d91b7602068f8209a61918d4a8a8fe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/998088876d91b7602068f8209a61918d4a8a8fe7", "html_url": "https://github.com/rust-lang/rust/commit/998088876d91b7602068f8209a61918d4a8a8fe7"}], "stats": {"total": 199, "additions": 171, "deletions": 28}, "files": [{"sha": "827170f8f90aa0d6711f7d1043523b3151f4165c", "filename": "crates/ra_assists/src/assists/early_return.rs", "status": "modified", "additions": 155, "deletions": 28, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs?ref=4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e", "patch": "@@ -37,7 +37,9 @@ use crate::{\n // ```\n pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n-    let expr = if_expr.condition()?.expr()?;\n+    let cond = if_expr.condition()?;\n+    let pat = &cond.pat();\n+    let expr = cond.expr()?;\n     let then_block = if_expr.then_branch()?.block()?;\n     if if_expr.else_branch().is_some() {\n         return None;\n@@ -63,8 +65,8 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n     let parent_container = parent_block.syntax().parent()?.parent()?;\n \n     let early_expression = match parent_container.kind() {\n-        WHILE_EXPR | LOOP_EXPR => Some(\"continue;\"),\n-        FN_DEF => Some(\"return;\"),\n+        WHILE_EXPR | LOOP_EXPR => Some(\"continue\"),\n+        FN_DEF => Some(\"return\"),\n         _ => None,\n     }?;\n \n@@ -77,31 +79,67 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     ctx.add_assist(AssistId(\"convert_to_guarded_return\"), \"convert to guarded return\", |edit| {\n         let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-        let new_if_expr =\n-            if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n-        let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n-        let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n-        let end_of_then =\n-            if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n-                end_of_then.prev_sibling_or_token().unwrap()\n-            } else {\n-                end_of_then\n-            };\n-        let mut new_if_and_then_statements = new_if_expr.syntax().children_with_tokens().chain(\n-            then_block_items\n-                .syntax()\n-                .children_with_tokens()\n-                .skip(1)\n-                .take_while(|i| *i != end_of_then),\n-        );\n-        let new_block = replace_children(\n-            &parent_block.syntax(),\n-            RangeInclusive::new(\n-                if_expr.clone().syntax().clone().into(),\n-                if_expr.syntax().clone().into(),\n-            ),\n-            &mut new_if_and_then_statements,\n-        );\n+        let new_block = match pat {\n+            None => {\n+                // If.\n+                let early_expression = &(early_expression.to_owned() + \";\");\n+                let new_if_expr =\n+                    if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n+                let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n+                let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+                let end_of_then =\n+                    if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                        end_of_then.prev_sibling_or_token().unwrap()\n+                    } else {\n+                        end_of_then\n+                    };\n+                let mut new_if_and_then_statements =\n+                    new_if_expr.syntax().children_with_tokens().chain(\n+                        then_block_items\n+                            .syntax()\n+                            .children_with_tokens()\n+                            .skip(1)\n+                            .take_while(|i| *i != end_of_then),\n+                    );\n+                replace_children(\n+                    &parent_block.syntax(),\n+                    RangeInclusive::new(\n+                        if_expr.clone().syntax().clone().into(),\n+                        if_expr.syntax().clone().into(),\n+                    ),\n+                    &mut new_if_and_then_statements,\n+                )\n+            }\n+            _ => {\n+                // If-let.\n+                let new_match_expr =\n+                    if_indent_level.increase_indent(make::let_match_early(expr, early_expression));\n+                let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n+                let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+                let end_of_then =\n+                    if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                        end_of_then.prev_sibling_or_token().unwrap()\n+                    } else {\n+                        end_of_then\n+                    };\n+                let mut then_statements = new_match_expr.syntax().children_with_tokens().chain(\n+                    then_block_items\n+                        .syntax()\n+                        .children_with_tokens()\n+                        .skip(1)\n+                        .take_while(|i| *i != end_of_then),\n+                );\n+                let new_block = replace_children(\n+                    &parent_block.syntax(),\n+                    RangeInclusive::new(\n+                        if_expr.clone().syntax().clone().into(),\n+                        if_expr.syntax().clone().into(),\n+                    ),\n+                    &mut then_statements,\n+                );\n+                new_block\n+            }\n+        };\n         edit.target(if_expr.syntax().text_range());\n         edit.replace_ast(parent_block, ast::Block::cast(new_block).unwrap());\n         edit.set_cursor(cursor_position);\n@@ -143,6 +181,37 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_let_inside_fn() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                if<|> let Some(n) = n {\n+                    foo(n);\n+\n+                    //comment\n+                    bar();\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                le<|>t n = match n {\n+                    Some(it) => it,\n+                    None => return,\n+                };\n+                foo(n);\n+\n+                //comment\n+                bar();\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_inside_while() {\n         check_assist(\n@@ -171,6 +240,35 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_let_inside_while() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main() {\n+                while true {\n+                    if<|> let Some(n) = n {\n+                        foo(n);\n+                        bar();\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                while true {\n+                    le<|>t n = match n {\n+                        Some(it) => it,\n+                        None => continue,\n+                    };\n+                    foo(n);\n+                    bar();\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_inside_loop() {\n         check_assist(\n@@ -199,6 +297,35 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_let_inside_loop() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main() {\n+                loop {\n+                    if<|> let Some(n) = n {\n+                        foo(n);\n+                        bar();\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                loop {\n+                    le<|>t n = match n {\n+                        Some(it) => it,\n+                        None => continue,\n+                    };\n+                    foo(n);\n+                    bar();\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn ignore_already_converted_if() {\n         check_assist_not_applicable("}, {"sha": "979819d4b5db6f48e33df4ebbb8aea673e10ffe6", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=4a4d9f7a90dc0605992c4f774a8d9a1323ad6d1e", "patch": "@@ -110,6 +110,22 @@ pub fn match_arm_list(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchAr\n     }\n }\n \n+pub fn let_match_early(expr: ast::Expr, early_expression: &str) -> ast::LetStmt {\n+    return from_text(&format!(\n+        r#\"let {} = match {} {{\n+    Some(it) => it,\n+    None => {},\n+}};\"#,\n+        expr.syntax().text(),\n+        expr.syntax().text(),\n+        early_expression\n+    ));\n+\n+    fn from_text(text: &str) -> ast::LetStmt {\n+        ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n+    }\n+}\n+\n pub fn where_pred(path: ast::Path, bounds: impl Iterator<Item = ast::TypeBound>) -> ast::WherePred {\n     let bounds = bounds.map(|b| b.syntax().to_string()).join(\" + \");\n     return from_text(&format!(\"{}: {}\", path.syntax(), bounds));"}]}