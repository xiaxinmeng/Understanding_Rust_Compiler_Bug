{"sha": "76c466a18f78d230c09b424df84308b07025acf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YzQ2NmExOGY3OGQyMzBjMDliNDI0ZGY4NDMwOGIwNzAyNWFjZjU=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-09-26T18:46:44Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-20T13:13:57Z"}, "message": "BTreeMap: less sharing, more similarity between leaf and internal nodes", "tree": {"sha": "34e355a68906e2c7386a5fbec7d304d024ae5faf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34e355a68906e2c7386a5fbec7d304d024ae5faf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76c466a18f78d230c09b424df84308b07025acf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76c466a18f78d230c09b424df84308b07025acf5", "html_url": "https://github.com/rust-lang/rust/commit/76c466a18f78d230c09b424df84308b07025acf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76c466a18f78d230c09b424df84308b07025acf5/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7829e1889961cdcabfd327a2e71366a832fd2b0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7829e1889961cdcabfd327a2e71366a832fd2b0d", "html_url": "https://github.com/rust-lang/rust/commit/7829e1889961cdcabfd327a2e71366a832fd2b0d"}], "stats": {"total": 81, "additions": 36, "deletions": 45}, "files": [{"sha": "886d8abd030bfb4096f6ca5bff7a9d18934a85fd", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/76c466a18f78d230c09b424df84308b07025acf5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c466a18f78d230c09b424df84308b07025acf5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=76c466a18f78d230c09b424df84308b07025acf5", "patch": "@@ -611,7 +611,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n \n     /// Adds a key/value pair to the beginning of the node.\n     fn push_front(&mut self, key: K, val: V) {\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(self.len() < CAPACITY);\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -664,14 +664,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n             slice_insert(self.vals_mut(), 0, val);\n-            slice_insert(\n-                slice::from_raw_parts_mut(\n-                    MaybeUninit::slice_as_mut_ptr(&mut self.as_internal_mut().edges),\n-                    self.len() + 1,\n-                ),\n-                0,\n-                edge.node,\n-            );\n+            slice_insert(self.edges_mut(), 0, edge.node);\n         }\n \n         self.as_leaf_mut().len += 1;\n@@ -921,33 +914,22 @@ fn splitpoint(edge_idx: usize) -> (usize, InsertionPlace) {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n-    /// Helps implementations of `insert_fit` for a particular `NodeType`,\n-    /// by taking care of leaf data.\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n-    fn leafy_insert_fit(&mut self, key: K, val: V) {\n+    ///\n+    /// The returned pointer points to the inserted value.\n+    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         debug_assert!(self.node.len() < CAPACITY);\n \n         unsafe {\n             slice_insert(self.node.keys_mut(), self.idx, key);\n             slice_insert(self.node.vals_mut(), self.idx, val);\n-\n             self.node.as_leaf_mut().len += 1;\n-        }\n-    }\n-}\n \n-impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n-    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n-    /// this edge. This method assumes that there is enough space in the node for the new\n-    /// pair to fit.\n-    ///\n-    /// The returned pointer points to the inserted value.\n-    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n-        self.leafy_insert_fit(key, val);\n-        unsafe { self.node.val_mut_at(self.idx) }\n+            self.node.val_mut_at(self.idx)\n+        }\n     }\n }\n \n@@ -996,11 +978,14 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// between this edge and the key/value pair to the right of this edge. This method assumes\n     /// that there is enough space in the node for the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n+        debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n+            slice_insert(self.node.keys_mut(), self.idx, key);\n+            slice_insert(self.node.vals_mut(), self.idx, val);\n             slice_insert(self.node.edges_mut(), self.idx + 1, edge.node);\n-            self.leafy_insert_fit(key, val);\n+            self.node.as_leaf_mut().len += 1;\n \n             self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n@@ -1131,15 +1116,21 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n+    /// Helps implementations of `split` for a particular `NodeType`,\n+    /// by calculating the length of the new node.\n+    fn split_new_node_len(&self) -> usize {\n+        debug_assert!(self.idx < self.node.len());\n+        self.node.len() - self.idx - 1\n+    }\n+\n     /// Helps implementations of `split` for a particular `NodeType`,\n     /// by taking care of leaf data.\n-    fn leafy_split(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V, usize) {\n+    fn split_leaf_data(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V) {\n+        let new_len = self.split_new_node_len();\n         unsafe {\n             let k = ptr::read(self.node.key_at(self.idx));\n             let v = ptr::read(self.node.val_at(self.idx));\n \n-            let new_len = self.node.len() - self.idx - 1;\n-\n             ptr::copy_nonoverlapping(\n                 self.node.key_at(self.idx + 1),\n                 MaybeUninit::slice_as_mut_ptr(&mut new_node.keys),\n@@ -1153,15 +1144,15 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n \n             self.node.as_leaf_mut().len = self.idx as u16;\n             new_node.len = new_len as u16;\n-            (k, v, new_len)\n+            (k, v)\n         }\n     }\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n     /// Splits the underlying node into three parts:\n     ///\n-    /// - The node is truncated to only contain the key/value pairs to the right of\n+    /// - The node is truncated to only contain the key/value pairs to the left of\n     ///   this handle.\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the key/value pairs to the right of this handle are put into a newly\n@@ -1170,9 +1161,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n-            let (k, v, _) = self.leafy_split(&mut new_node);\n+            let (k, v) = self.split_leaf_data(&mut new_node);\n \n-            (self.node, k, v, Root { node: BoxedNode::from_leaf(new_node), height: 0 })\n+            let right = Root { node: BoxedNode::from_leaf(new_node), height: 0 };\n+            (self.node, k, v, right)\n         }\n     }\n \n@@ -1206,29 +1198,28 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// Splits the underlying node into three parts:\n     ///\n     /// - The node is truncated to only contain the edges and key/value pairs to the\n-    ///   right of this handle.\n+    ///   left of this handle.\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the edges and key/value pairs to the right of this handle are put into\n     ///   a newly allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n-\n-            let (k, v, new_len) = self.leafy_split(&mut new_node.data);\n-            let height = self.node.height;\n-            let old_node = &*self.node.as_internal_ptr();\n-\n+            // Move edges out before reducing length:\n+            let new_len = self.split_new_node_len();\n             ptr::copy_nonoverlapping(\n-                old_node.edges.as_ptr().add(self.idx + 1),\n-                new_node.edges.as_mut_ptr(),\n+                self.node.edge_at(self.idx + 1),\n+                MaybeUninit::slice_as_mut_ptr(&mut new_node.edges),\n                 new_len + 1,\n             );\n+            let (k, v) = self.split_leaf_data(&mut new_node.data);\n \n-            let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n+            let height = self.node.height;\n+            let mut right = Root { node: BoxedNode::from_internal(new_node), height };\n \n-            new_root.internal_node_as_mut().correct_childrens_parent_links(0..=new_len);\n+            right.internal_node_as_mut().correct_childrens_parent_links(0..=new_len);\n \n-            (self.node, k, v, new_root)\n+            (self.node, k, v, right)\n         }\n     }\n "}]}