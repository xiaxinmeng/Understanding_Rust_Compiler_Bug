{"sha": "662132560133a17cb598083f44de2fbf3d74f157", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MjEzMjU2MDEzM2ExN2NiNTk4MDgzZjQ0ZGUyZmJmM2Q3NGYxNTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T01:36:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T01:36:16Z"}, "message": "rollup merge of #20657: alexcrichton/stabilize-macros", "tree": {"sha": "57d34853ce7360561dd9c80c260ce3025b3bd951", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57d34853ce7360561dd9c80c260ce3025b3bd951"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/662132560133a17cb598083f44de2fbf3d74f157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/662132560133a17cb598083f44de2fbf3d74f157", "html_url": "https://github.com/rust-lang/rust/commit/662132560133a17cb598083f44de2fbf3d74f157", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/662132560133a17cb598083f44de2fbf3d74f157/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcebec508422e3dc88215a621f3b51beb88b0330", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcebec508422e3dc88215a621f3b51beb88b0330", "html_url": "https://github.com/rust-lang/rust/commit/bcebec508422e3dc88215a621f3b51beb88b0330"}, {"sha": "209c701bf9e95542aec69455bc12c7ca295109c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/209c701bf9e95542aec69455bc12c7ca295109c4", "html_url": "https://github.com/rust-lang/rust/commit/209c701bf9e95542aec69455bc12c7ca295109c4"}], "stats": {"total": 257, "additions": 33, "deletions": 224}, "files": [{"sha": "92c71d968ccc58895ad57c9f34ac06c33ba46f12", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=662132560133a17cb598083f44de2fbf3d74f157", "patch": "@@ -10,6 +10,7 @@\n \n /// Creates a `Vec` containing the arguments.\n #[macro_export]\n+#[stable]\n macro_rules! vec {\n     ($($x:expr),*) => ({\n         let xs: $crate::boxed::Box<[_]> = box [$($x),*];"}, {"sha": "316ea65af87357d4b0b479ba7535dd15bb3519c1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=662132560133a17cb598083f44de2fbf3d74f157", "patch": "@@ -120,8 +120,7 @@\n extern crate log;\n \n #[macro_use]\n-#[macro_reexport(assert, assert_eq, debug_assert, debug_assert_eq,\n-                 unreachable, unimplemented, write, writeln)]\n+#[macro_reexport(write, writeln)]\n extern crate core;\n \n #[macro_use]\n@@ -176,7 +175,7 @@ pub use unicode::char;\n /* Exported macros */\n \n #[macro_use]\n-pub mod macros;\n+mod macros;\n \n #[macro_use]\n pub mod bitflags;"}, {"sha": "0594b711ad62e418945f13edf95dc4ba9eb4890c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 30, "deletions": 46, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=662132560133a17cb598083f44de2fbf3d74f157", "patch": "@@ -36,23 +36,27 @@\n /// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! panic {\n     () => ({\n         panic!(\"explicit panic\")\n     });\n     ($msg:expr) => ({\n-        // static requires less code at runtime, more constant data\n-        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-        ::std::rt::begin_unwind($msg, &_FILE_LINE)\n+        $crate::rt::begin_unwind($msg, {\n+            // static requires less code at runtime, more constant data\n+            static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+            &_FILE_LINE\n+        })\n     });\n-    ($fmt:expr, $($arg:tt)*) => ({\n-        // The leading _'s are to avoid dead code warnings if this is\n-        // used inside a dead function. Just `#[allow(dead_code)]` is\n-        // insufficient, since the user may have\n-        // `#[forbid(dead_code)]` and which cannot be overridden.\n-        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-        ::std::rt::begin_unwind_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n-\n+    ($fmt:expr, $($arg:tt)+) => ({\n+        $crate::rt::begin_unwind_fmt(format_args!($fmt, $($arg)+), {\n+            // The leading _'s are to avoid dead code warnings if this is\n+            // used inside a dead function. Just `#[allow(dead_code)]` is\n+            // insufficient, since the user may have\n+            // `#[forbid(dead_code)]` and which cannot be overridden.\n+            static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+            &_FILE_LINE\n+        })\n     });\n }\n \n@@ -77,15 +81,16 @@ macro_rules! panic {\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n             panic!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n-    ($cond:expr, $($arg:expr),+) => (\n+    ($cond:expr, $($arg:tt)+) => (\n         if !$cond {\n-            panic!($($arg),+)\n+            panic!($($arg)+)\n         }\n     );\n }\n@@ -103,6 +108,7 @@ macro_rules! assert {\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! assert_eq {\n     ($left:expr , $right:expr) => ({\n         match (&($left), &($right)) {\n@@ -144,6 +150,7 @@ macro_rules! assert_eq {\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! debug_assert {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n }\n@@ -210,6 +217,7 @@ macro_rules! debug_assert_eq {\n /// }\n /// ```\n #[macro_export]\n+#[unstable = \"relationship with panic is unclear\"]\n macro_rules! unreachable {\n     () => ({\n         panic!(\"internal error: entered unreachable code\")\n@@ -225,6 +233,7 @@ macro_rules! unreachable {\n /// A standardised placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n #[macro_export]\n+#[unstable = \"relationship with panic is unclear\"]\n macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }\n@@ -242,15 +251,15 @@ macro_rules! unimplemented {\n #[macro_export]\n #[stable]\n macro_rules! format {\n-    ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n }\n \n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n #[stable]\n macro_rules! print {\n-    ($($arg:tt)*) => (::std::io::stdio::print_args(format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::io::stdio::print_args(format_args!($($arg)*)))\n }\n \n /// Macro for printing to a task's stdout handle.\n@@ -268,20 +277,19 @@ macro_rules! print {\n #[macro_export]\n #[stable]\n macro_rules! println {\n-    ($($arg:tt)*) => (::std::io::stdio::println_args(format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::io::stdio::println_args(format_args!($($arg)*)))\n }\n \n /// Helper macro for unwrapping `Result` values while returning early with an\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`.\n #[macro_export]\n+#[stable]\n macro_rules! try {\n-    ($expr:expr) => ({\n-        use $crate::result::Result::{Ok, Err};\n-\n-        match $expr {\n-            Ok(val) => val,\n-            Err(err) => return Err($crate::error::FromError::from_error(err)),\n+    ($expr:expr) => (match $expr {\n+        $crate::result::Result::Ok(val) => val,\n+        $crate::result::Result::Err(err) => {\n+            return $crate::result::Result::Err($crate::error::FromError::from_error(err))\n         }\n     })\n }\n@@ -412,26 +420,6 @@ pub mod builtin {\n     #[macro_export]\n     macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n \n-    /// Concatenate literals into a static byte slice.\n-    ///\n-    /// This macro takes any number of comma-separated literal expressions,\n-    /// yielding an expression of type `&'static [u8]` which is the\n-    /// concatenation (left to right) of all the literals in their byte format.\n-    ///\n-    /// This extension currently only supports string literals, character\n-    /// literals, and integers less than 256. The byte slice returned is the\n-    /// utf8-encoding of strings and characters.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let rust = bytes!(\"r\", 'u', \"st\", 255);\n-    /// assert_eq!(rust[1], b'u');\n-    /// assert_eq!(rust[4], 255);\n-    /// ```\n-    #[macro_export]\n-    macro_rules! bytes { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n-\n     /// Concatenate identifiers into one identifier.\n     ///\n     /// This macro takes any number of comma-separated identifiers, and\n@@ -565,10 +553,6 @@ pub mod builtin {\n     #[macro_export]\n     macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n \n-    /// Deprecated alias for `include_bytes!()`.\n-    #[macro_export]\n-    macro_rules! include_bin { ($file:expr) => ({ /* compiler built-in */}) }\n-\n     /// Expands to a string that represents the current module path.\n     ///\n     /// The current module path can be thought of as the hierarchy of modules"}, {"sha": "9b9d8a9ceb395bf7cf0024fe3ceb17030de165f7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=662132560133a17cb598083f44de2fbf3d74f157", "patch": "@@ -341,9 +341,6 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n \n     let mut syntax_expanders = SyntaxEnv::new();\n     syntax_expanders.insert(intern(\"macro_rules\"), MacroRulesTT);\n-    syntax_expanders.insert(intern(\"fmt\"),\n-                            builtin_normal_expander(\n-                                ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"format_args\"),\n                             builtin_normal_expander(\n                                 ext::format::expand_format_args));\n@@ -353,9 +350,6 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n     syntax_expanders.insert(intern(\"option_env\"),\n                             builtin_normal_expander(\n                                     ext::env::expand_option_env));\n-    syntax_expanders.insert(intern(\"bytes\"),\n-                            builtin_normal_expander(\n-                                    ext::bytes::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"concat_idents\"),\n                             builtin_normal_expander(\n                                     ext::concat_idents::expand_syntax_ext));\n@@ -367,8 +361,6 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n                                     ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"derive\"),\n                             Decorator(box ext::deriving::expand_meta_derive));\n-    syntax_expanders.insert(intern(\"deriving\"),\n-                            Decorator(box ext::deriving::expand_meta_deriving));\n \n     if ecfg.enable_quotes {\n         // Quasi-quoting expanders\n@@ -416,9 +408,6 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n     syntax_expanders.insert(intern(\"include_str\"),\n                             builtin_normal_expander(\n                                     ext::source_util::expand_include_str));\n-    syntax_expanders.insert(intern(\"include_bin\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include_bin));\n     syntax_expanders.insert(intern(\"include_bytes\"),\n                             builtin_normal_expander(\n                                     ext::source_util::expand_include_bytes));"}, {"sha": "9f225d55b444fe787bf7d8f73ce40798f4f8fd9e", "filename": "src/libsyntax/ext/bytes.rs", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bcebec508422e3dc88215a621f3b51beb88b0330/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcebec508422e3dc88215a621f3b51beb88b0330/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=bcebec508422e3dc88215a621f3b51beb88b0330", "patch": "@@ -1,117 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/* The compiler code necessary to support the bytes! extension. */\n-\n-use ast;\n-use codemap::Span;\n-use ext::base::*;\n-use ext::base;\n-use ext::build::AstBuilder;\n-use std::ascii::AsciiExt;\n-\n-pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n-                              sp: Span,\n-                              tts: &[ast::TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n-    cx.span_warn(sp, \"`bytes!` is deprecated, use `b\\\"foo\\\"` literals instead\");\n-    cx.parse_sess.span_diagnostic.span_help(sp,\n-        \"see http://doc.rust-lang.org/reference.html#byte-and-byte-string-literals \\\n-         for documentation\");\n-    cx.parse_sess.span_diagnostic.span_help(sp,\n-        \"see https://github.com/rust-lang/rust/blob/master/src/etc/2014-06-rewrite-bytes-macros.py \\\n-         for an automated migration\");\n-\n-    // Gather all argument expressions\n-    let exprs = match get_exprs_from_tts(cx, sp, tts) {\n-        None => return DummyResult::expr(sp),\n-        Some(e) => e,\n-    };\n-    let mut bytes = Vec::new();\n-    let mut err = false;\n-\n-    for expr in exprs.iter() {\n-        match expr.node {\n-            // expression is a literal\n-            ast::ExprLit(ref lit) => match lit.node {\n-                // string literal, push each byte to vector expression\n-                ast::LitStr(ref s, _) => {\n-                    for byte in s.get().bytes() {\n-                        bytes.push(cx.expr_u8(expr.span, byte));\n-                    }\n-                }\n-\n-                // u8 literal, push to vector expression\n-                ast::LitInt(v, ast::UnsignedIntLit(ast::TyU8)) => {\n-                    if v > 0xFF {\n-                        cx.span_err(expr.span, \"too large u8 literal in bytes!\");\n-                        err = true;\n-                    } else {\n-                        bytes.push(cx.expr_u8(expr.span, v as u8));\n-                    }\n-                }\n-\n-                // integer literal, push to vector expression\n-                ast::LitInt(_, ast::UnsuffixedIntLit(ast::Minus)) => {\n-                    cx.span_err(expr.span, \"negative integer literal in bytes!\");\n-                    err = true;\n-                }\n-                ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                    if v > 0xFF {\n-                        cx.span_err(expr.span, \"too large integer literal in bytes!\");\n-                        err = true;\n-                    } else {\n-                        bytes.push(cx.expr_u8(expr.span, v as u8));\n-                    }\n-                }\n-\n-                // char literal, push to vector expression\n-                ast::LitChar(v) => {\n-                    if v.is_ascii() {\n-                        bytes.push(cx.expr_u8(expr.span, v as u8));\n-                    } else {\n-                        cx.span_err(expr.span, \"non-ascii char literal in bytes!\");\n-                        err = true;\n-                    }\n-                }\n-\n-                _ => {\n-                    cx.span_err(expr.span, \"unsupported literal in bytes!\");\n-                    err = true;\n-                }\n-            },\n-\n-            _ => {\n-                cx.span_err(expr.span, \"non-literal in bytes!\");\n-                err = true;\n-            }\n-        }\n-    }\n-\n-    // For some reason using quote_expr!() here aborts if we threw an error.\n-    // I'm assuming that the end of the recursive parse tricks the compiler\n-    // into thinking this is a good time to stop. But we'd rather keep going.\n-    if err {\n-        // Since the compiler will stop after the macro expansion phase anyway, we\n-        // don't need type info, so we can just return a DummyResult\n-        return DummyResult::expr(sp);\n-    }\n-\n-    let len = bytes.len();\n-    let e = cx.expr_vec(sp, bytes);\n-    let ty = cx.ty(sp, ast::TyFixedLengthVec(cx.ty_ident(sp, cx.ident_of(\"u8\")),\n-                                             cx.expr_uint(sp, len)));\n-    let item = cx.item_static(sp, cx.ident_of(\"BYTES\"), ty, ast::MutImmutable, e);\n-    let ret = cx.expr_ident(sp, cx.ident_of(\"BYTES\"));\n-    let ret = cx.expr_addr_of(sp, ret);\n-    let e = cx.expr_block(cx.block(sp, vec![cx.stmt_item(sp, item)],\n-                                   Some(ret)));\n-    MacExpr::new(e)\n-}"}, {"sha": "603c44780071623200b34c1ed820e7f007e2d9c6", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=662132560133a17cb598083f44de2fbf3d74f157", "patch": "@@ -40,16 +40,6 @@ pub mod totalord;\n \n pub mod generic;\n \n-pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n-                            _span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: Box<FnMut(P<Item>)>) {\n-    cx.span_warn(mitem.span, \"`deriving` is deprecated; use `derive`\");\n-\n-    expand_meta_derive(cx, _span, mitem, item, push)\n-}\n-\n pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                           _span: Span,\n                           mitem: &MetaItem,"}, {"sha": "5352cfaf749b0904c7ac75d6bd218efa52e14f15", "filename": "src/libsyntax/ext/fmt.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bcebec508422e3dc88215a621f3b51beb88b0330/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcebec508422e3dc88215a621f3b51beb88b0330/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=bcebec508422e3dc88215a621f3b51beb88b0330", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Deprecated fmt! syntax extension\n-\n-use ast;\n-use codemap::Span;\n-use ext::base;\n-use ext::build::AstBuilder;\n-\n-\n-pub fn expand_syntax_ext(ecx: &mut base::ExtCtxt,\n-                         sp: Span,\n-                         _tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult+'static> {\n-    ecx.span_err(sp, \"`fmt!` is deprecated, use `format!` instead\");\n-    ecx.parse_sess.span_diagnostic.span_note(sp,\n-        \"see http://doc.rust-lang.org/std/fmt/ \\\n-         for documentation\");\n-\n-    base::MacExpr::new(ecx.expr_uint(sp, 2))\n-}"}, {"sha": "31a1a838b133db55bc1052022994cf86993efd5a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=662132560133a17cb598083f44de2fbf3d74f157", "patch": "@@ -161,12 +161,6 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     }\n }\n \n-pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                          -> Box<base::MacResult+'static> {\n-    cx.span_warn(sp, \"include_bin! is deprecated; use include_bytes! instead\");\n-    expand_include_bytes(cx, sp, tts)\n-}\n-\n pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                             -> Box<base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") {"}, {"sha": "1823700fbf4fe25a2ec7495a75e973e8f4fc538e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662132560133a17cb598083f44de2fbf3d74f157/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=662132560133a17cb598083f44de2fbf3d74f157", "patch": "@@ -82,15 +82,13 @@ pub mod ext {\n     pub mod asm;\n     pub mod base;\n     pub mod build;\n-    pub mod bytes;\n     pub mod cfg;\n     pub mod cfg_attr;\n     pub mod concat;\n     pub mod concat_idents;\n     pub mod deriving;\n     pub mod env;\n     pub mod expand;\n-    pub mod fmt;\n     pub mod format;\n     pub mod log_syntax;\n     pub mod mtwt;"}]}