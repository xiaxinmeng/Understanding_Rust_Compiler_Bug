{"sha": "8748cd92d06328af657934f6728183c10f92eefe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NDhjZDkyZDA2MzI4YWY2NTc5MzRmNjcyODE4M2MxMGY5MmVlZmU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T02:16:55Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T02:17:27Z"}, "message": "Rollup merge of #34316 - jseyfried:refactor_ast_stmt, r=eddyb\n\nRefactor away `ast::Decl`, refactor `ast::Stmt`, and rename `ast::ExprKind::Again` to `ast::ExprKind::Continue`.", "tree": {"sha": "560b5d24cb0a944210e292ed47dd754af0ed1828", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/560b5d24cb0a944210e292ed47dd754af0ed1828"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8748cd92d06328af657934f6728183c10f92eefe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8748cd92d06328af657934f6728183c10f92eefe", "html_url": "https://github.com/rust-lang/rust/commit/8748cd92d06328af657934f6728183c10f92eefe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8748cd92d06328af657934f6728183c10f92eefe/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33ea1e330ccdda85a1501078c0b997fd27ce1e72", "url": "https://api.github.com/repos/rust-lang/rust/commits/33ea1e330ccdda85a1501078c0b997fd27ce1e72", "html_url": "https://github.com/rust-lang/rust/commit/33ea1e330ccdda85a1501078c0b997fd27ce1e72"}, {"sha": "f6fe5b6a3e3daf4c10410aec3802576f08c6343f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6fe5b6a3e3daf4c10410aec3802576f08c6343f", "html_url": "https://github.com/rust-lang/rust/commit/f6fe5b6a3e3daf4c10410aec3802576f08c6343f"}], "stats": {"total": 738, "additions": 330, "deletions": 408}, "files": [{"sha": "37c437b19224cf7df2732267d5008302a80358ab", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -238,19 +238,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_decl(&mut self, d: &Decl) -> P<hir::Decl> {\n-        match d.node {\n-            DeclKind::Local(ref l) => P(Spanned {\n-                node: hir::DeclLocal(self.lower_local(l)),\n-                span: d.span,\n-            }),\n-            DeclKind::Item(ref it) => P(Spanned {\n-                node: hir::DeclItem(self.lower_item_id(it)),\n-                span: d.span,\n-            }),\n-        }\n-    }\n-\n     fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n         hir::TypeBinding {\n             id: b.id,\n@@ -1225,7 +1212,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprPath(hir_qself, self.lower_path(path))\n                 }\n                 ExprKind::Break(opt_ident) => hir::ExprBreak(self.lower_opt_sp_ident(opt_ident)),\n-                ExprKind::Again(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n+                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| self.lower_expr(x))),\n                 ExprKind::InlineAsm(InlineAsm {\n                         ref inputs,\n@@ -1581,21 +1568,29 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_stmt(&mut self, s: &Stmt) -> hir::Stmt {\n         match s.node {\n-            StmtKind::Decl(ref d, id) => {\n-                Spanned {\n-                    node: hir::StmtDecl(self.lower_decl(d), id),\n+            StmtKind::Local(ref l) => Spanned {\n+                node: hir::StmtDecl(P(Spanned {\n+                    node: hir::DeclLocal(self.lower_local(l)),\n                     span: s.span,\n-                }\n-            }\n-            StmtKind::Expr(ref e, id) => {\n+                }), s.id),\n+                span: s.span,\n+            },\n+            StmtKind::Item(ref it) => Spanned {\n+                node: hir::StmtDecl(P(Spanned {\n+                    node: hir::DeclItem(self.lower_item_id(it)),\n+                    span: s.span,\n+                }), s.id),\n+                span: s.span,\n+            },\n+            StmtKind::Expr(ref e) => {\n                 Spanned {\n-                    node: hir::StmtExpr(self.lower_expr(e), id),\n+                    node: hir::StmtExpr(self.lower_expr(e), s.id),\n                     span: s.span,\n                 }\n             }\n-            StmtKind::Semi(ref e, id) => {\n+            StmtKind::Semi(ref e) => {\n                 Spanned {\n-                    node: hir::StmtSemi(self.lower_expr(e), id),\n+                    node: hir::StmtSemi(self.lower_expr(e), s.id),\n                     span: s.span,\n                 }\n             }"}, {"sha": "11241977b826e006082f1f244e0f1f9dd40b758c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -1005,11 +1005,6 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n         ast_visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &ast::Decl) {\n-        run_lints!(self, check_decl, early_passes, d);\n-        ast_visit::walk_decl(self, d);\n-    }\n-\n     fn visit_expr_post(&mut self, e: &ast::Expr) {\n         run_lints!(self, check_expr_post, early_passes, e);\n     }"}, {"sha": "92aa446c265f9f791d3911d063357a0a1a0809ea", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -195,7 +195,6 @@ pub trait EarlyLintPass: LintPass {\n     fn check_stmt(&mut self, _: &EarlyContext, _: &ast::Stmt) { }\n     fn check_arm(&mut self, _: &EarlyContext, _: &ast::Arm) { }\n     fn check_pat(&mut self, _: &EarlyContext, _: &ast::Pat) { }\n-    fn check_decl(&mut self, _: &EarlyContext, _: &ast::Decl) { }\n     fn check_expr(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n     fn check_expr_post(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n     fn check_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }"}, {"sha": "b5b87718d2df7c352d5d36971aa39a9d47200fbf", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -365,12 +365,9 @@ impl EarlyLintPass for UnusedParens {\n \n     fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n         let (value, msg) = match s.node {\n-            ast::StmtKind::Decl(ref decl, _) => match decl.node {\n-                ast::DeclKind::Local(ref local) => match local.init {\n-                    Some(ref value) => (value, \"assigned value\"),\n-                    None => return\n-                },\n-                _ => return\n+            ast::StmtKind::Local(ref local) => match local.init {\n+                Some(ref value) => (value, \"assigned value\"),\n+                None => return\n             },\n             _ => return\n         };"}, {"sha": "a90b563515eae0e89b2159430200d7cbe03991b9", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -73,7 +73,7 @@ impl<'a> Visitor for AstValidator<'a> {\n         match expr.node {\n             ExprKind::While(_, _, Some(ident)) | ExprKind::Loop(_, Some(ident)) |\n             ExprKind::WhileLet(_, _, _, Some(ident)) | ExprKind::ForLoop(_, _, _, Some(ident)) |\n-            ExprKind::Break(Some(ident)) | ExprKind::Again(Some(ident)) => {\n+            ExprKind::Break(Some(ident)) | ExprKind::Continue(Some(ident)) => {\n                 self.check_label(ident.node, ident.span, expr.id);\n             }\n             _ => {}"}, {"sha": "5867e48c7ca27b64d5fbea039fffde6a34a6ec8f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -30,10 +30,10 @@ use syntax::ast::Name;\n use syntax::attr;\n use syntax::parse::token;\n \n-use syntax::ast::{Block, Crate, DeclKind};\n+use syntax::ast::{Block, Crate};\n use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, PathListItemKind};\n-use syntax::ast::{Stmt, StmtKind, TraitItemKind};\n+use syntax::ast::{StmtKind, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::visit::{self, Visitor};\n \n@@ -85,17 +85,11 @@ impl<'b> Resolver<'b> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        fn is_item(statement: &Stmt) -> bool {\n-            if let StmtKind::Decl(ref declaration, _) = statement.node {\n-                if let DeclKind::Item(_) = declaration.node {\n-                    return true;\n-                }\n-            }\n-            false\n-        }\n-\n         // If any statements are items, we need to create an anonymous module\n-        block.stmts.iter().any(is_item)\n+        block.stmts.iter().any(|statement| match statement.node {\n+            StmtKind::Item(_) => true,\n+            _ => false,\n+        })\n     }\n \n     /// Constructs the reduced graph for one item."}, {"sha": "8ffa95ec7e96f2c860aa98833c7c9811b01bc8cc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -2951,7 +2951,7 @@ impl<'a> Resolver<'a> {\n                 })\n             }\n \n-            ExprKind::Break(Some(label)) | ExprKind::Again(Some(label)) => {\n+            ExprKind::Break(Some(label)) | ExprKind::Continue(Some(label)) => {\n                 match self.search_label(mtwt::resolve(label.node)) {\n                     None => {\n                         self.record_def(expr.id, err_path_resolution());"}, {"sha": "c1960eeee46b8fb7eccede5f0fda8f5f911e96b4", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -1423,8 +1423,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n     }\n \n     fn visit_stmt(&mut self, s: &ast::Stmt) {\n-        let id = s.node.id();\n-        self.process_macro_use(s.span, id.unwrap());\n+        self.process_macro_use(s.span, s.id);\n         visit::walk_stmt(self, s)\n     }\n "}, {"sha": "51f42a678ceafd1d06adb712738232e255d04f79", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -27,7 +27,6 @@ use tokenstream::{TokenTree};\n \n use std::fmt;\n use std::rc::Rc;\n-use std::borrow::Cow;\n use std::hash::{Hash, Hasher};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -811,41 +810,35 @@ impl UnOp {\n }\n \n /// A statement\n-pub type Stmt = Spanned<StmtKind>;\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+pub struct Stmt {\n+    pub id: NodeId,\n+    pub node: StmtKind,\n+    pub span: Span,\n+}\n \n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"stmt({}: {})\",\n-               self.node.id()\n-                   .map_or(Cow::Borrowed(\"<macro>\"),|id|Cow::Owned(id.to_string())),\n-               pprust::stmt_to_string(self))\n+        write!(f, \"stmt({}: {})\", self.id.to_string(), pprust::stmt_to_string(self))\n     }\n }\n \n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub enum StmtKind {\n-    /// Could be an item or a local (let) binding:\n-    Decl(P<Decl>, NodeId),\n+    /// A local (let) binding.\n+    Local(P<Local>),\n \n-    /// Expr without trailing semi-colon (must have unit type):\n-    Expr(P<Expr>, NodeId),\n+    /// An item definition.\n+    Item(P<Item>),\n \n-    /// Expr with trailing semi-colon (may have any type):\n-    Semi(P<Expr>, NodeId),\n+    /// Expr without trailing semi-colon (must have unit type).\n+    Expr(P<Expr>),\n \n-    Mac(P<Mac>, MacStmtStyle, ThinAttributes),\n-}\n+    /// Expr with trailing semi-colon (may have any type).\n+    Semi(P<Expr>),\n \n-impl StmtKind {\n-    pub fn id(&self) -> Option<NodeId> {\n-        match *self {\n-            StmtKind::Decl(_, id) => Some(id),\n-            StmtKind::Expr(_, id) => Some(id),\n-            StmtKind::Semi(_, id) => Some(id),\n-            StmtKind::Mac(..) => None,\n-        }\n-    }\n+    Mac(P<(Mac, MacStmtStyle, ThinAttributes)>),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -875,16 +868,6 @@ pub struct Local {\n     pub attrs: ThinAttributes,\n }\n \n-pub type Decl = Spanned<DeclKind>;\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum DeclKind {\n-    /// A local (let) binding:\n-    Local(P<Local>),\n-    /// An item binding:\n-    Item(P<Item>),\n-}\n-\n /// An arm of a 'match'.\n ///\n /// E.g. `0...10 => { println!(\"match!\") }` as in\n@@ -1053,7 +1036,7 @@ pub enum ExprKind {\n     /// A `break`, with an optional label to break\n     Break(Option<SpannedIdent>),\n     /// A `continue`, with an optional label\n-    Again(Option<SpannedIdent>),\n+    Continue(Option<SpannedIdent>),\n     /// A `return`, with an optional value to be returned\n     Ret(Option<P<Expr>>),\n "}, {"sha": "34d07291bf4a96b023d323b5ebe0b9c8ed07d125", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -16,8 +16,7 @@ pub use self::IntType::*;\n \n use ast;\n use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaItemKind};\n-use ast::{Stmt, StmtKind, DeclKind};\n-use ast::{Expr, Item, Local, Decl};\n+use ast::{Expr, Item, Local, Stmt, StmtKind};\n use codemap::{spanned, dummy_spanned, Spanned};\n use syntax_pos::{Span, BytePos};\n use errors::Handler;\n@@ -909,38 +908,28 @@ impl<T: HasAttrs + 'static> HasAttrs for P<T> {\n     }\n }\n \n-impl HasAttrs for DeclKind {\n-    fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            DeclKind::Local(ref local) => local.attrs(),\n-            DeclKind::Item(ref item) => item.attrs(),\n-        }\n-    }\n-\n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n-        match self {\n-            DeclKind::Local(local) => DeclKind::Local(local.map_attrs(f)),\n-            DeclKind::Item(item) => DeclKind::Item(item.map_attrs(f)),\n-        }\n-    }\n-}\n-\n impl HasAttrs for StmtKind {\n     fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            StmtKind::Decl(ref decl, _) => decl.attrs(),\n-            StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => expr.attrs(),\n-            StmtKind::Mac(_, _, ref attrs) => attrs.attrs(),\n+            StmtKind::Local(ref local) => local.attrs(),\n+            StmtKind::Item(ref item) => item.attrs(),\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n+            StmtKind::Mac(ref mac) => {\n+                let (_, _, ref attrs) = **mac;\n+                attrs.attrs()\n+            }\n         }\n     }\n \n     fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n         match self {\n-            StmtKind::Decl(decl, id) => StmtKind::Decl(decl.map_attrs(f), id),\n-            StmtKind::Expr(expr, id) => StmtKind::Expr(expr.map_attrs(f), id),\n-            StmtKind::Semi(expr, id) => StmtKind::Semi(expr.map_attrs(f), id),\n-            StmtKind::Mac(mac, style, attrs) =>\n-                StmtKind::Mac(mac, style, attrs.map_attrs(f)),\n+            StmtKind::Local(local) => StmtKind::Local(local.map_attrs(f)),\n+            StmtKind::Item(item) => StmtKind::Item(item.map_attrs(f)),\n+            StmtKind::Expr(expr) => StmtKind::Expr(expr.map_attrs(f)),\n+            StmtKind::Semi(expr) => StmtKind::Semi(expr.map_attrs(f)),\n+            StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, style, attrs)| {\n+                (mac, style, attrs.map_attrs(f))\n+            })),\n         }\n     }\n }\n@@ -967,4 +956,4 @@ derive_has_attrs_from_field! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm\n }\n \n-derive_has_attrs_from_field! { Decl: .node, Stmt: .node, ast::Variant: .node.attrs }\n+derive_has_attrs_from_field! { Stmt: .node, ast::Variant: .node.attrs }"}, {"sha": "961763c6025fd8d84828165452961ac9488d8093", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -213,17 +213,10 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        let is_item = match stmt.node {\n-            ast::StmtKind::Decl(ref decl, _) => match decl.node {\n-                ast::DeclKind::Item(_) => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        };\n-\n         // avoid calling `visit_stmt_or_expr_attrs` on items\n-        if !is_item {\n-            self.visit_stmt_or_expr_attrs(stmt.attrs());\n+        match stmt.node {\n+            ast::StmtKind::Item(_) => {}\n+            _ => self.visit_stmt_or_expr_attrs(stmt.attrs()),\n         }\n \n         self.configure(stmt).map(|stmt| fold::noop_fold_stmt(stmt, self))"}, {"sha": "4a715aa1d5b4574b1ad4e49bbdd825b6a4ed51c9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -221,10 +221,11 @@ impl<F> IdentMacroExpander for F\n // Use a macro because forwarding to a simple function has type system issues\n macro_rules! make_stmts_default {\n     ($me:expr) => {\n-        $me.make_expr().map(|e| {\n-            SmallVector::one(codemap::respan(\n-                e.span, ast::StmtKind::Expr(e, ast::DUMMY_NODE_ID)))\n-        })\n+        $me.make_expr().map(|e| SmallVector::one(ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: e.span,\n+            node: ast::StmtKind::Expr(e),\n+        }))\n     }\n }\n \n@@ -436,10 +437,11 @@ impl MacResult for DummyResult {\n     }\n \n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<ast::Stmt>> {\n-        Some(SmallVector::one(\n-            codemap::respan(self.span,\n-                            ast::StmtKind::Expr(DummyResult::raw_expr(self.span),\n-                                                ast::DUMMY_NODE_ID))))\n+        Some(SmallVector::one(ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Expr(DummyResult::raw_expr(self.span)),\n+            span: self.span,\n+        }))\n     }\n }\n "}, {"sha": "17655cc125492acf1994a2b847b4daced437a804", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -509,7 +509,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n-        respan(expr.span, ast::StmtKind::Semi(expr, ast::DUMMY_NODE_ID))\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: expr.span,\n+            node: ast::StmtKind::Semi(expr),\n+        }\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n@@ -528,8 +532,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             span: sp,\n             attrs: None,\n         });\n-        let decl = respan(sp, ast::DeclKind::Local(local));\n-        respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: sp,\n+        }\n     }\n \n     fn stmt_let_typed(&self,\n@@ -553,8 +560,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             span: sp,\n             attrs: None,\n         });\n-        let decl = respan(sp, ast::DeclKind::Local(local));\n-        P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n+        P(ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: sp,\n+        })\n     }\n \n     fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n@@ -563,8 +573,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n-        let decl = respan(sp, ast::DeclKind::Item(item));\n-        respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Item(item),\n+            span: sp,\n+        }\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {"}, {"sha": "ff8d0f81bd01496f4e8c0ddd1c66dd15e625a776", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 52, "deletions": 72, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, DeclKind, PatKind};\n+use ast::{Block, Crate, PatKind};\n use ast::{Local, Ident, Mac_, Name, SpannedIdent};\n use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast;\n@@ -439,25 +439,25 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     };\n \n     let (mac, style, attrs) = match stmt.node {\n-        StmtKind::Mac(mac, style, attrs) => (mac, style, attrs),\n+        StmtKind::Mac(mac) => mac.unwrap(),\n         _ => return expand_non_macro_stmt(stmt, fld)\n     };\n \n     let mut fully_expanded: SmallVector<ast::Stmt> =\n-        expand_mac_invoc(mac.unwrap(), None, attrs.into_attr_vec(), stmt.span, fld);\n+        expand_mac_invoc(mac, None, attrs.into_attr_vec(), stmt.span, fld);\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n     if style == MacStmtStyle::Semicolon {\n         if let Some(stmt) = fully_expanded.pop() {\n-            let new_stmt = Spanned {\n+            fully_expanded.push(Stmt {\n+                id: stmt.id,\n                 node: match stmt.node {\n-                    StmtKind::Expr(e, stmt_id) => StmtKind::Semi(e, stmt_id),\n+                    StmtKind::Expr(expr) => StmtKind::Semi(expr),\n                     _ => stmt.node /* might already have a semi */\n                 },\n-                span: stmt.span\n-            };\n-            fully_expanded.push(new_stmt);\n+                span: stmt.span,\n+            });\n         }\n     }\n \n@@ -466,73 +466,53 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroExpander)\n+fn expand_non_macro_stmt(stmt: Stmt, fld: &mut MacroExpander)\n                          -> SmallVector<Stmt> {\n     // is it a let?\n-    match node {\n-        StmtKind::Decl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n-            DeclKind::Local(local) => {\n-                // take it apart:\n-                let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n-                    // expand the ty since TyKind::FixedLengthVec contains an Expr\n-                    // and thus may have a macro use\n-                    let expanded_ty = ty.map(|t| fld.fold_ty(t));\n-                    // expand the pat (it might contain macro uses):\n-                    let expanded_pat = fld.fold_pat(pat);\n-                    // find the PatIdents in the pattern:\n-                    // oh dear heaven... this is going to include the enum\n-                    // names, as well... but that should be okay, as long as\n-                    // the new names are gensyms for the old ones.\n-                    // generate fresh names, push them to a new pending list\n-                    let idents = pattern_bindings(&expanded_pat);\n-                    let mut new_pending_renames =\n-                        idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n-                    // rewrite the pattern using the new names (the old\n-                    // ones have already been applied):\n-                    let rewritten_pat = {\n-                        // nested binding to allow borrow to expire:\n-                        let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n-                        rename_fld.fold_pat(expanded_pat)\n-                    };\n-                    // add them to the existing pending renames:\n-                    fld.cx.syntax_env.info().pending_renames\n-                          .extend(new_pending_renames);\n-                    Local {\n-                        id: id,\n-                        ty: expanded_ty,\n-                        pat: rewritten_pat,\n-                        // also, don't forget to expand the init:\n-                        init: init.map(|e| fld.fold_expr(e)),\n-                        span: span,\n-                        attrs: fold::fold_thin_attrs(attrs, fld),\n-                    }\n-                });\n-                SmallVector::one(Spanned {\n-                    node: StmtKind::Decl(P(Spanned {\n-                            node: DeclKind::Local(rewritten_local),\n-                            span: span\n-                        }),\n-                        node_id),\n-                    span: stmt_span\n-                })\n-            }\n-            _ => {\n-                noop_fold_stmt(Spanned {\n-                    node: StmtKind::Decl(P(Spanned {\n-                            node: decl,\n-                            span: span\n-                        }),\n-                        node_id),\n-                    span: stmt_span\n-                }, fld)\n-            }\n-        }),\n-        _ => {\n-            noop_fold_stmt(Spanned {\n-                node: node,\n-                span: stmt_span\n-            }, fld)\n+    match stmt.node {\n+        StmtKind::Local(local) => {\n+            // take it apart:\n+            let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n+                // expand the ty since TyKind::FixedLengthVec contains an Expr\n+                // and thus may have a macro use\n+                let expanded_ty = ty.map(|t| fld.fold_ty(t));\n+                // expand the pat (it might contain macro uses):\n+                let expanded_pat = fld.fold_pat(pat);\n+                // find the PatIdents in the pattern:\n+                // oh dear heaven... this is going to include the enum\n+                // names, as well... but that should be okay, as long as\n+                // the new names are gensyms for the old ones.\n+                // generate fresh names, push them to a new pending list\n+                let idents = pattern_bindings(&expanded_pat);\n+                let mut new_pending_renames =\n+                    idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n+                // rewrite the pattern using the new names (the old\n+                // ones have already been applied):\n+                let rewritten_pat = {\n+                    // nested binding to allow borrow to expire:\n+                    let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n+                    rename_fld.fold_pat(expanded_pat)\n+                };\n+                // add them to the existing pending renames:\n+                fld.cx.syntax_env.info().pending_renames\n+                      .extend(new_pending_renames);\n+                Local {\n+                    id: id,\n+                    ty: expanded_ty,\n+                    pat: rewritten_pat,\n+                    // also, don't forget to expand the init:\n+                    init: init.map(|e| fld.fold_expr(e)),\n+                    span: span,\n+                    attrs: fold::fold_thin_attrs(attrs, fld),\n+                }\n+            });\n+            SmallVector::one(Stmt {\n+                id: stmt.id,\n+                node: StmtKind::Local(rewritten_local),\n+                span: stmt.span,\n+            })\n         }\n+        _ => noop_fold_stmt(stmt, fld),\n     }\n }\n "}, {"sha": "1dc7f45ddbe1151098ae01085ea7a2f2a063ff13", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 34, "deletions": 43, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -102,10 +102,6 @@ pub trait Folder : Sized {\n         noop_fold_pat(p, self)\n     }\n \n-    fn fold_decl(&mut self, d: P<Decl>) -> SmallVector<P<Decl>> {\n-        noop_fold_decl(d, self)\n-    }\n-\n     fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n         e.map(|e| noop_fold_expr(e, self))\n     }\n@@ -349,19 +345,6 @@ pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T\n     }\n }\n \n-pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>> {\n-    d.and_then(|Spanned {node, span}| match node {\n-        DeclKind::Local(l) => SmallVector::one(P(Spanned {\n-            node: DeclKind::Local(fld.fold_local(l)),\n-            span: fld.new_span(span)\n-        })),\n-        DeclKind::Item(it) => fld.fold_item(it).into_iter().map(|i| P(Spanned {\n-            node: DeclKind::Item(i),\n-            span: fld.new_span(span)\n-        })).collect()\n-    })\n-}\n-\n pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n     TypeBinding {\n         id: fld.new_id(b.id),\n@@ -1248,7 +1231,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))\n             ),\n-            ExprKind::Again(opt_ident) => ExprKind::Again(opt_ident.map(|label|\n+            ExprKind::Continue(opt_ident) => ExprKind::Continue(opt_ident.map(|label|\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))\n             ),\n@@ -1305,44 +1288,52 @@ pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Exp\n     es.move_flat_map(|e| folder.fold_opt_expr(e))\n }\n \n-pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n+pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T)\n                                  -> SmallVector<Stmt> {\n+    let id = folder.new_id(id);\n     let span = folder.new_span(span);\n+\n     match node {\n-        StmtKind::Decl(d, id) => {\n-            let id = folder.new_id(id);\n-            folder.fold_decl(d).into_iter().map(|d| Spanned {\n-                node: StmtKind::Decl(d, id),\n-                span: span\n-            }).collect()\n-        }\n-        StmtKind::Expr(e, id) => {\n-            let id = folder.new_id(id);\n-            if let Some(e) = folder.fold_opt_expr(e) {\n-                SmallVector::one(Spanned {\n-                    node: StmtKind::Expr(e, id),\n-                    span: span\n+        StmtKind::Local(local) => SmallVector::one(Stmt {\n+            id: id,\n+            node: StmtKind::Local(folder.fold_local(local)),\n+            span: span,\n+        }),\n+        StmtKind::Item(item) => folder.fold_item(item).into_iter().map(|item| Stmt {\n+            id: id,\n+            node: StmtKind::Item(item),\n+            span: span,\n+        }).collect(),\n+        StmtKind::Expr(expr) => {\n+            if let Some(expr) = folder.fold_opt_expr(expr) {\n+                SmallVector::one(Stmt {\n+                    id: id,\n+                    node: StmtKind::Expr(expr),\n+                    span: span,\n                 })\n             } else {\n                 SmallVector::zero()\n             }\n         }\n-        StmtKind::Semi(e, id) => {\n-            let id = folder.new_id(id);\n-            if let Some(e) = folder.fold_opt_expr(e) {\n-                SmallVector::one(Spanned {\n-                    node: StmtKind::Semi(e, id),\n-                    span: span\n+        StmtKind::Semi(expr) => {\n+            if let Some(expr) = folder.fold_opt_expr(expr) {\n+                SmallVector::one(Stmt {\n+                    id: id,\n+                    node: StmtKind::Semi(expr),\n+                    span: span,\n                 })\n             } else {\n                 SmallVector::zero()\n             }\n         }\n-        StmtKind::Mac(mac, semi, attrs) => SmallVector::one(Spanned {\n-            node: StmtKind::Mac(mac.map(|m| folder.fold_mac(m)),\n-                                semi,\n-                                attrs.map_thin_attrs(|v| fold_attrs(v, folder))),\n-            span: span\n+        StmtKind::Mac(mac) => SmallVector::one(Stmt {\n+            id: id,\n+            node: StmtKind::Mac(mac.map(|(mac, semi, attrs)| {\n+                let mac = folder.fold_mac(mac);\n+                let attrs = attrs.map_thin_attrs(|attrs| fold_attrs(attrs, folder));\n+                (mac, semi, attrs)\n+            })),\n+            span: span,\n         })\n     }\n }"}, {"sha": "4fe4ec7e4c0ed3f785fb498ded087152b4b67892", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -47,13 +47,9 @@ pub fn expr_is_simple_block(e: &ast::Expr) -> bool {\n /// seen the semicolon, and thus don't need another.\n pub fn stmt_ends_with_semi(stmt: &ast::StmtKind) -> bool {\n     match *stmt {\n-        ast::StmtKind::Decl(ref d, _) => {\n-            match d.node {\n-                ast::DeclKind::Local(_) => true,\n-                ast::DeclKind::Item(_) => false,\n-            }\n-        }\n-        ast::StmtKind::Expr(ref e, _) => expr_requires_semi_to_be_stmt(e),\n+        ast::StmtKind::Local(_) => true,\n+        ast::StmtKind::Item(_) => false,\n+        ast::StmtKind::Expr(ref e) => expr_requires_semi_to_be_stmt(e),\n         ast::StmtKind::Semi(..) => false,\n         ast::StmtKind::Mac(..) => false,\n     }"}, {"sha": "28555dc89bc1f8a37aa38a5e02395c6c09ef18a5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -844,7 +844,7 @@ mod tests {\n \n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n-                   Some(Spanned{\n+                   Some(ast::Stmt {\n                        node: ast::StmtKind::Expr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprKind::Path(None, ast::Path {\n@@ -858,8 +858,8 @@ mod tests {\n                                ),\n                             }),\n                            span: sp(0,1),\n-                           attrs: None}),\n-                                           ast::DUMMY_NODE_ID),\n+                           attrs: None})),\n+                       id: ast::DUMMY_NODE_ID,\n                        span: sp(0,1)}))\n \n     }\n@@ -935,7 +935,7 @@ mod tests {\n                                         }\n                                     },\n                                     P(ast::Block {\n-                                        stmts: vec!(Spanned{\n+                                        stmts: vec!(ast::Stmt {\n                                             node: ast::StmtKind::Semi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprKind::Path(None,\n@@ -953,8 +953,8 @@ mod tests {\n                                                         ),\n                                                       }),\n                                                 span: sp(17,18),\n-                                                attrs: None,}),\n-                                                ast::DUMMY_NODE_ID),\n+                                                attrs: None,})),\n+                                            id: ast::DUMMY_NODE_ID,\n                                             span: sp(17,19)}),\n                                         expr: None,\n                                         id: ast::DUMMY_NODE_ID,"}, {"sha": "c04d2c371570babc7d753d6944116c2169c66086", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 101, "deletions": 90, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -16,7 +16,7 @@ use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, Crate, CrateConfig};\n-use ast::{Decl, DeclKind, Defaultness};\n+use ast::Defaultness;\n use ast::EnumDef;\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n@@ -2312,14 +2312,14 @@ impl<'a> Parser<'a> {\n                 }\n                 if self.eat_keyword(keywords::Continue) {\n                     let ex = if self.token.is_lifetime() {\n-                        let ex = ExprKind::Again(Some(Spanned{\n+                        let ex = ExprKind::Continue(Some(Spanned{\n                             node: self.get_lifetime(),\n                             span: self.span\n                         }));\n                         self.bump();\n                         ex\n                     } else {\n-                        ExprKind::Again(None)\n+                        ExprKind::Continue(None)\n                     };\n                     let hi = self.last_span.hi;\n                     return Ok(self.mk_expr(lo, hi, ex, attrs));\n@@ -3826,13 +3826,6 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// Parse a \"let\" stmt\n-    fn parse_let(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Decl>> {\n-        let lo = self.span.lo;\n-        let local = self.parse_local(attrs)?;\n-        Ok(P(spanned(lo, self.last_span.hi, DeclKind::Local(local))))\n-    }\n-\n     /// Parse a structure field\n     fn parse_name_and_ty(&mut self, pr: Visibility,\n                          attrs: Vec<Attribute> ) -> PResult<'a, StructField> {\n@@ -3945,12 +3938,12 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n \n-        Ok(Some(if self.check_keyword(keywords::Let) {\n-            self.expect_keyword(keywords::Let)?;\n-            let decl = self.parse_let(attrs.into_thin_attrs())?;\n-            let hi = decl.span.hi;\n-            let stmt = StmtKind::Decl(decl, ast::DUMMY_NODE_ID);\n-            spanned(lo, hi, stmt)\n+        Ok(Some(if self.eat_keyword(keywords::Let) {\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                node: StmtKind::Local(self.parse_local(attrs.into_thin_attrs())?),\n+                span: mk_sp(lo, self.last_span.hi),\n+            }\n         } else if self.token.is_ident()\n             && !self.token.is_any_keyword()\n             && self.look_ahead(1, |t| *t == token::Not) {\n@@ -4001,9 +3994,12 @@ impl<'a> Parser<'a> {\n             };\n \n             if id.name == keywords::Invalid.name() {\n-                let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts }));\n-                let stmt = StmtKind::Mac(mac, style, attrs.into_thin_attrs());\n-                spanned(lo, hi, stmt)\n+                let mac = spanned(lo, hi, Mac_ { path: pth, tts: tts });\n+                Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Mac(P((mac, style, attrs.into_thin_attrs()))),\n+                    span: mk_sp(lo, hi),\n+                }\n             } else {\n                 // if it has a special ident, it's definitely an item\n                 //\n@@ -4017,25 +4013,28 @@ impl<'a> Parser<'a> {\n                                        followed by a semicolon\");\n                     }\n                 }\n-                spanned(lo, hi, StmtKind::Decl(\n-                    P(spanned(lo, hi, DeclKind::Item(\n+                Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: mk_sp(lo, hi),\n+                    node: StmtKind::Item({\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n-                            ItemKind::Mac(spanned(lo, hi,\n-                                            Mac_ { path: pth, tts: tts })),\n-                            Visibility::Inherited, attrs)))),\n-                    ast::DUMMY_NODE_ID))\n+                            ItemKind::Mac(spanned(lo, hi, Mac_ { path: pth, tts: tts })),\n+                            Visibility::Inherited,\n+                            attrs)\n+                    }),\n+                }\n             }\n         } else {\n             // FIXME: Bad copy of attrs\n             let restrictions = self.restrictions | Restrictions::NO_NONINLINE_MOD;\n             match self.with_res(restrictions,\n                                 |this| this.parse_item_(attrs.clone(), false, true))? {\n-                Some(i) => {\n-                    let hi = i.span.hi;\n-                    let decl = P(spanned(lo, hi, DeclKind::Item(i)));\n-                    spanned(lo, hi, StmtKind::Decl(decl, ast::DUMMY_NODE_ID))\n-                }\n+                Some(i) => Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: mk_sp(lo, i.span.hi),\n+                    node: StmtKind::Item(i),\n+                },\n                 None => {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n                         if attrs.len() > 0 {\n@@ -4059,9 +4058,11 @@ impl<'a> Parser<'a> {\n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(\n                         Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_thin_attrs()))?;\n-                    let hi = e.span.hi;\n-                    let stmt = StmtKind::Expr(e, ast::DUMMY_NODE_ID);\n-                    spanned(lo, hi, stmt)\n+                    Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: mk_sp(lo, e.span.hi),\n+                        node: StmtKind::Expr(e),\n+                    }\n                 }\n             }\n         }))\n@@ -4107,68 +4108,21 @@ impl<'a> Parser<'a> {\n         let mut expr = None;\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let Spanned {node, span} = if let Some(s) = self.parse_stmt_() {\n+            let Stmt {node, span, ..} = if let Some(s) = self.parse_stmt_() {\n                 s\n             } else if self.token == token::Eof {\n                 break;\n             } else {\n                 // Found only `;` or `}`.\n                 continue;\n             };\n+\n             match node {\n-                StmtKind::Expr(e, _) => {\n+                StmtKind::Expr(e) => {\n                     self.handle_expression_like_statement(e, span, &mut stmts, &mut expr)?;\n                 }\n-                StmtKind::Mac(mac, MacStmtStyle::NoBraces, attrs) => {\n-                    // statement macro without braces; might be an\n-                    // expr depending on whether a semicolon follows\n-                    match self.token {\n-                        token::Semi => {\n-                            stmts.push(Spanned {\n-                                node: StmtKind::Mac(mac, MacStmtStyle::Semicolon, attrs),\n-                                span: mk_sp(span.lo, self.span.hi),\n-                            });\n-                            self.bump();\n-                        }\n-                        _ => {\n-                            let e = self.mk_mac_expr(span.lo, span.hi,\n-                                                     mac.and_then(|m| m.node),\n-                                                     None);\n-                            let lo = e.span.lo;\n-                            let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-                            let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                            self.handle_expression_like_statement(\n-                                e,\n-                                span,\n-                                &mut stmts,\n-                                &mut expr)?;\n-                        }\n-                    }\n-                }\n-                StmtKind::Mac(m, style, attrs) => {\n-                    // statement macro; might be an expr\n-                    match self.token {\n-                        token::Semi => {\n-                            stmts.push(Spanned {\n-                                node: StmtKind::Mac(m, MacStmtStyle::Semicolon, attrs),\n-                                span: mk_sp(span.lo, self.span.hi),\n-                            });\n-                            self.bump();\n-                        }\n-                        token::CloseDelim(token::Brace) => {\n-                            // if a block ends in `m!(arg)` without\n-                            // a `;`, it must be an expr\n-                            expr = Some(self.mk_mac_expr(span.lo, span.hi,\n-                                                         m.and_then(|x| x.node),\n-                                                         attrs));\n-                        }\n-                        _ => {\n-                            stmts.push(Spanned {\n-                                node: StmtKind::Mac(m, style, attrs),\n-                                span: span\n-                            });\n-                        }\n-                    }\n+                StmtKind::Mac(mac) => {\n+                    self.handle_macro_in_block(mac.unwrap(), span, &mut stmts, &mut expr)?;\n                 }\n                 _ => { // all other kinds of statements:\n                     let mut hi = span.hi;\n@@ -4177,7 +4131,8 @@ impl<'a> Parser<'a> {\n                         hi = self.last_span.hi;\n                     }\n \n-                    stmts.push(Spanned {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n                         node: node,\n                         span: mk_sp(span.lo, hi)\n                     });\n@@ -4194,6 +4149,60 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n+    fn handle_macro_in_block(&mut self,\n+                             (mac, style, attrs): (ast::Mac, MacStmtStyle, ThinAttributes),\n+                             span: Span,\n+                             stmts: &mut Vec<Stmt>,\n+                             last_block_expr: &mut Option<P<Expr>>)\n+                             -> PResult<'a, ()> {\n+        if style == MacStmtStyle::NoBraces {\n+            // statement macro without braces; might be an\n+            // expr depending on whether a semicolon follows\n+            match self.token {\n+                token::Semi => {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n+                        span: mk_sp(span.lo, self.span.hi),\n+                    });\n+                    self.bump();\n+                }\n+                _ => {\n+                    let e = self.mk_mac_expr(span.lo, span.hi, mac.node, None);\n+                    let lo = e.span.lo;\n+                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n+                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                    self.handle_expression_like_statement(e, span, stmts, last_block_expr)?;\n+                }\n+            }\n+        } else {\n+            // statement macro; might be an expr\n+            match self.token {\n+                token::Semi => {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n+                        span: mk_sp(span.lo, self.span.hi),\n+                    });\n+                    self.bump();\n+                }\n+                token::CloseDelim(token::Brace) => {\n+                    // if a block ends in `m!(arg)` without\n+                    // a `;`, it must be an expr\n+                    *last_block_expr = Some(self.mk_mac_expr(span.lo, span.hi, mac.node, attrs));\n+                }\n+                _ => {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Mac(P((mac, style, attrs))),\n+                        span: span\n+                    });\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn handle_expression_like_statement(&mut self,\n                                         e: P<Expr>,\n                                         span: Span,\n@@ -4219,15 +4228,17 @@ impl<'a> Parser<'a> {\n                     hi: self.last_span.hi,\n                     expn_id: span.expn_id,\n                 };\n-                stmts.push(Spanned {\n-                    node: StmtKind::Semi(e, ast::DUMMY_NODE_ID),\n+                stmts.push(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Semi(e),\n                     span: span_with_semi,\n                 });\n             }\n             token::CloseDelim(token::Brace) => *last_block_expr = Some(e),\n             _ => {\n-                stmts.push(Spanned {\n-                    node: StmtKind::Expr(e, ast::DUMMY_NODE_ID),\n+                stmts.push(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Expr(e),\n                     span: span\n                 });\n             }"}, {"sha": "a268a6e96053bac0c15295fb6a61cac38b3d688b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -1606,19 +1606,34 @@ impl<'a> State<'a> {\n     pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n-            ast::StmtKind::Decl(ref decl, _) => {\n-                try!(self.print_decl(&decl));\n+            ast::StmtKind::Local(ref loc) => {\n+                try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n+                try!(self.space_if_not_bol());\n+                try!(self.ibox(INDENT_UNIT));\n+                try!(self.word_nbsp(\"let\"));\n+\n+                try!(self.ibox(INDENT_UNIT));\n+                try!(self.print_local_decl(&loc));\n+                try!(self.end());\n+                if let Some(ref init) = loc.init {\n+                    try!(self.nbsp());\n+                    try!(self.word_space(\"=\"));\n+                    try!(self.print_expr(&init));\n+                }\n+                self.end()?;\n             }\n-            ast::StmtKind::Expr(ref expr, _) => {\n+            ast::StmtKind::Item(ref item) => self.print_item(&item)?,\n+            ast::StmtKind::Expr(ref expr) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_expr_outer_attr_style(&expr, false));\n             }\n-            ast::StmtKind::Semi(ref expr, _) => {\n+            ast::StmtKind::Semi(ref expr) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_expr_outer_attr_style(&expr, false));\n                 try!(word(&mut self.s, \";\"));\n             }\n-            ast::StmtKind::Mac(ref mac, style, ref attrs) => {\n+            ast::StmtKind::Mac(ref mac) => {\n+                let (ref mac, style, ref attrs) = **mac;\n                 try!(self.space_if_not_bol());\n                 try!(self.print_outer_attributes(attrs.as_attr_slice()));\n                 let delim = match style {\n@@ -2183,7 +2198,7 @@ impl<'a> State<'a> {\n                     try!(space(&mut self.s));\n                 }\n             }\n-            ast::ExprKind::Again(opt_ident) => {\n+            ast::ExprKind::Continue(opt_ident) => {\n                 try!(word(&mut self.s, \"continue\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n@@ -2291,29 +2306,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_decl(&mut self, decl: &ast::Decl) -> io::Result<()> {\n-        try!(self.maybe_print_comment(decl.span.lo));\n-        match decl.node {\n-            ast::DeclKind::Local(ref loc) => {\n-                try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n-                try!(self.space_if_not_bol());\n-                try!(self.ibox(INDENT_UNIT));\n-                try!(self.word_nbsp(\"let\"));\n-\n-                try!(self.ibox(INDENT_UNIT));\n-                try!(self.print_local_decl(&loc));\n-                try!(self.end());\n-                if let Some(ref init) = loc.init {\n-                    try!(self.nbsp());\n-                    try!(self.word_space(\"=\"));\n-                    try!(self.print_expr(&init));\n-                }\n-                self.end()\n-            }\n-            ast::DeclKind::Item(ref item) => self.print_item(&item)\n-        }\n-    }\n-\n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n         try!(word(&mut self.s, &ident.name.as_str()));\n         self.ann.post(self, NodeIdent(&ident))"}, {"sha": "14244bbdddf28c05cf1ab6c04bbf5d29e54f1cb2", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -63,10 +63,6 @@ impl Visitor for NodeCounter {\n         self.count += 1;\n         walk_pat(self, p)\n     }\n-    fn visit_decl(&mut self, d: &Decl) {\n-        self.count += 1;\n-        walk_decl(self, d)\n-    }\n     fn visit_expr(&mut self, ex: &Expr) {\n         self.count += 1;\n         walk_expr(self, ex)"}, {"sha": "aca0c2bcf578596989371448749fd5595fc1c77d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -65,7 +65,6 @@ pub trait Visitor: Sized {\n     fn visit_stmt(&mut self, s: &Stmt) { walk_stmt(self, s) }\n     fn visit_arm(&mut self, a: &Arm) { walk_arm(self, a) }\n     fn visit_pat(&mut self, p: &Pat) { walk_pat(self, p) }\n-    fn visit_decl(&mut self, d: &Decl) { walk_decl(self, d) }\n     fn visit_expr(&mut self, ex: &Expr) { walk_expr(self, ex) }\n     fn visit_expr_post(&mut self, _ex: &Expr) { }\n     fn visit_ty(&mut self, t: &Ty) { walk_ty(self, t) }\n@@ -597,11 +596,13 @@ pub fn walk_block<V: Visitor>(visitor: &mut V, block: &Block) {\n \n pub fn walk_stmt<V: Visitor>(visitor: &mut V, statement: &Stmt) {\n     match statement.node {\n-        StmtKind::Decl(ref declaration, _) => visitor.visit_decl(declaration),\n-        StmtKind::Expr(ref expression, _) | StmtKind::Semi(ref expression, _) => {\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(ref item) => visitor.visit_item(item),\n+        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n             visitor.visit_expr(expression)\n         }\n-        StmtKind::Mac(ref mac, _, ref attrs) => {\n+        StmtKind::Mac(ref mac) => {\n+            let (ref mac, _, ref attrs) = **mac;\n             visitor.visit_mac(mac);\n             for attr in attrs.as_attr_slice() {\n                 visitor.visit_attribute(attr);\n@@ -610,13 +611,6 @@ pub fn walk_stmt<V: Visitor>(visitor: &mut V, statement: &Stmt) {\n     }\n }\n \n-pub fn walk_decl<V: Visitor>(visitor: &mut V, declaration: &Decl) {\n-    match declaration.node {\n-        DeclKind::Local(ref local) => visitor.visit_local(local),\n-        DeclKind::Item(ref item) => visitor.visit_item(item),\n-    }\n-}\n-\n pub fn walk_mac<V: Visitor>(_: &mut V, _: &Mac) {\n     // Empty!\n }\n@@ -745,7 +739,7 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_sp_ident) | ExprKind::Again(ref opt_sp_ident) => {\n+        ExprKind::Break(ref opt_sp_ident) | ExprKind::Continue(ref opt_sp_ident) => {\n             walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Ret(ref optional_expression) => {"}, {"sha": "527748149a7d9a2f12b518a94716b42b4fb4d9ae", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -13,7 +13,6 @@ use deriving::generic::ty::*;\n \n use syntax::ast;\n use syntax::ast::{MetaItem, Expr};\n-use syntax::codemap::respan;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n@@ -152,6 +151,9 @@ fn stmt_let_undescore(cx: &mut ExtCtxt,\n         span: sp,\n         attrs: None,\n     });\n-    let decl = respan(sp, ast::DeclKind::Local(local));\n-    respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n+    ast::Stmt {\n+        id: ast::DUMMY_NODE_ID,\n+        node: ast::StmtKind::Local(local),\n+        span: sp,\n+    }\n }"}, {"sha": "5be2bf7cdf92b7b374c976160cf0a987fc59ef69", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8748cd92d06328af657934f6728183c10f92eefe/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=8748cd92d06328af657934f6728183c10f92eefe", "patch": "@@ -14,7 +14,6 @@ use self::Position::*;\n use fmt_macros as parse;\n \n use syntax::ast;\n-use syntax::codemap::respan;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n@@ -443,12 +442,14 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         let name = ecx.ident_of(name);\n         let item = ecx.item(sp, name, vec![], st);\n-        let decl = respan(sp, ast::DeclKind::Item(item));\n+        let stmt = ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Item(item),\n+            span: sp,\n+        };\n \n         // Wrap the declaration in a block so that it forms a single expression.\n-        ecx.expr_block(ecx.block(sp,\n-            vec![respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))],\n-            Some(ecx.expr_ident(sp, name))))\n+        ecx.expr_block(ecx.block(sp, vec![stmt], Some(ecx.expr_ident(sp, name))))\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded"}]}