{"sha": "af54d584b29e6afd7069bfdad071c43c0aa135f5", "node_id": "C_kwDOAAsO6NoAKGFmNTRkNTg0YjI5ZTZhZmQ3MDY5YmZkYWQwNzFjNDNjMGFhMTM1ZjU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-30T18:47:50Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-08T16:30:05Z"}, "message": "More robust as_ref/as_deref suggestions", "tree": {"sha": "144ab1a99ce868ec48ca7d5b3e5990d12c28c3cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/144ab1a99ce868ec48ca7d5b3e5990d12c28c3cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af54d584b29e6afd7069bfdad071c43c0aa135f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af54d584b29e6afd7069bfdad071c43c0aa135f5", "html_url": "https://github.com/rust-lang/rust/commit/af54d584b29e6afd7069bfdad071c43c0aa135f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af54d584b29e6afd7069bfdad071c43c0aa135f5/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "522ae84e0344669ee64754595dd5f04eed9f0d1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/522ae84e0344669ee64754595dd5f04eed9f0d1c", "html_url": "https://github.com/rust-lang/rust/commit/522ae84e0344669ee64754595dd5f04eed9f0d1c"}], "stats": {"total": 359, "additions": 207, "deletions": 152}, "files": [{"sha": "4728edd837a6cf36b54795f5fe9e5a8d8714dde1", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -25,6 +25,8 @@ hir_typeck_const_select_must_be_fn = this argument must be a function item\n \n hir_typeck_convert_to_str = try converting the passed type into a `&str`\n \n+hir_typeck_convert_using_method = try using `{$sugg}` to convert `{$found}` to `{$expected}`\n+\n hir_typeck_ctor_is_private = tuple struct constructor `{$def}` is private\n \n hir_typeck_expected_default_return_type = expected `()` because of default return type"}, {"sha": "20116fde661c4e5bfc82e73fd8908343a1f4487d", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -327,3 +327,18 @@ pub struct CtorIsPrivate {\n     pub span: Span,\n     pub def: String,\n }\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    hir_typeck_convert_using_method,\n+    code = \"{sugg}\",\n+    applicability = \"machine-applicable\",\n+    style = \"verbose\"\n+)]\n+pub struct SuggestConvertViaMethod<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub sugg: &'static str,\n+    pub expected: Ty<'tcx>,\n+    pub found: Ty<'tcx>,\n+}"}, {"sha": "21a52d3eccc5ed522cae340dde21d19458125e2c", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 137, "deletions": 84, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -1,6 +1,8 @@\n use super::FnCtxt;\n \n-use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel, SuggestBoxing};\n+use crate::errors::{\n+    AddReturnTypeSuggestion, ExpectedReturnTypeLabel, SuggestBoxing, SuggestConvertViaMethod,\n+};\n use crate::fluent_generated as fluent;\n use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n@@ -275,6 +277,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         let expr = expr.peel_blocks();\n+        let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n+\n         if let Some((suggestion, msg, applicability, verbose, annotation)) =\n             self.suggest_deref_or_ref(expr, found, expected)\n         {\n@@ -325,9 +329,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             return true;\n-        } else if self.suggest_else_fn_with_closure(err, expr, found, expected) {\n+        }\n+\n+        if self.suggest_else_fn_with_closure(err, expr, found, expected) {\n             return true;\n-        } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n+        }\n+\n+        if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n             && let ty::FnDef(def_id, ..) = *found.kind()\n             && let Some(sp) = self.tcx.hir().span_if_local(def_id)\n         {\n@@ -343,97 +351,142 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.span_label(sp, format!(\"{descr} `{name}` defined here\"));\n             }\n             return true;\n-        } else if self.suggest_cast(err, expr, found, expected, expected_ty_expr) {\n+        }\n+\n+        if self.suggest_cast(err, expr, found, expected, expected_ty_expr) {\n             return true;\n-        } else {\n-            let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n-            if !methods.is_empty() {\n-                let mut suggestions = methods.iter()\n-                    .filter_map(|conversion_method| {\n-                        let receiver_method_ident = expr.method_ident();\n-                        if let Some(method_ident) = receiver_method_ident\n-                            && method_ident.name == conversion_method.name\n-                        {\n-                            return None // do not suggest code that is already there (#53348)\n-                        }\n+        }\n \n-                        let method_call_list = [sym::to_vec, sym::to_string];\n-                        let mut sugg = if let ExprKind::MethodCall(receiver_method, ..) = expr.kind\n-                            && receiver_method.ident.name == sym::clone\n-                            && method_call_list.contains(&conversion_method.name)\n-                            // If receiver is `.clone()` and found type has one of those methods,\n-                            // we guess that the user wants to convert from a slice type (`&[]` or `&str`)\n-                            // to an owned type (`Vec` or `String`). These conversions clone internally,\n-                            // so we remove the user's `clone` call.\n-                        {\n-                            vec![(\n-                                receiver_method.ident.span,\n-                                conversion_method.name.to_string()\n-                            )]\n-                        } else if expr.precedence().order()\n-                            < ExprPrecedence::MethodCall.order()\n-                        {\n-                            vec![\n-                                (expr.span.shrink_to_lo(), \"(\".to_string()),\n-                                (expr.span.shrink_to_hi(), format!(\").{}()\", conversion_method.name)),\n-                            ]\n-                        } else {\n-                            vec![(expr.span.shrink_to_hi(), format!(\".{}()\", conversion_method.name))]\n-                        };\n-                        let struct_pat_shorthand_field = self.maybe_get_struct_pattern_shorthand_field(expr);\n-                        if let Some(name) = struct_pat_shorthand_field {\n-                            sugg.insert(\n-                                0,\n-                                (expr.span.shrink_to_lo(), format!(\"{}: \", name)),\n-                            );\n-                        }\n-                        Some(sugg)\n-                    })\n-                    .peekable();\n-                if suggestions.peek().is_some() {\n-                    err.multipart_suggestions(\n-                        \"try using a conversion method\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    return true;\n-                }\n-            } else if let ty::Adt(found_adt, found_substs) = found.kind()\n-                && self.tcx.is_diagnostic_item(sym::Option, found_adt.did())\n-                && let ty::Adt(expected_adt, expected_substs) = expected.kind()\n-                && self.tcx.is_diagnostic_item(sym::Option, expected_adt.did())\n-                && let ty::Ref(_, inner_ty, _) = expected_substs.type_at(0).kind()\n-                && inner_ty.is_str()\n-            {\n-                let ty = found_substs.type_at(0);\n-                let mut peeled = ty;\n-                let mut ref_cnt = 0;\n-                while let ty::Ref(_, inner, _) = peeled.kind() {\n-                    peeled = *inner;\n-                    ref_cnt += 1;\n-                }\n-                if let ty::Adt(adt, _) = peeled.kind()\n-                    && Some(adt.did()) == self.tcx.lang_items().string()\n-                {\n-                    let sugg = if ref_cnt == 0 {\n-                        \".as_deref()\"\n+        if !methods.is_empty() {\n+            let mut suggestions = methods\n+                .iter()\n+                .filter_map(|conversion_method| {\n+                    let receiver_method_ident = expr.method_ident();\n+                    if let Some(method_ident) = receiver_method_ident\n+                        && method_ident.name == conversion_method.name\n+                    {\n+                        return None // do not suggest code that is already there (#53348)\n+                    }\n+\n+                    let method_call_list = [sym::to_vec, sym::to_string];\n+                    let mut sugg = if let ExprKind::MethodCall(receiver_method, ..) = expr.kind\n+                        && receiver_method.ident.name == sym::clone\n+                        && method_call_list.contains(&conversion_method.name)\n+                        // If receiver is `.clone()` and found type has one of those methods,\n+                        // we guess that the user wants to convert from a slice type (`&[]` or `&str`)\n+                        // to an owned type (`Vec` or `String`). These conversions clone internally,\n+                        // so we remove the user's `clone` call.\n+                    {\n+                        vec![(\n+                            receiver_method.ident.span,\n+                            conversion_method.name.to_string()\n+                        )]\n+                    } else if expr.precedence().order()\n+                        < ExprPrecedence::MethodCall.order()\n+                    {\n+                        vec![\n+                            (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                            (expr.span.shrink_to_hi(), format!(\").{}()\", conversion_method.name)),\n+                        ]\n                     } else {\n-                        \".map(|x| x.as_str())\"\n+                        vec![(expr.span.shrink_to_hi(), format!(\".{}()\", conversion_method.name))]\n                     };\n-                    err.span_suggestion_verbose(\n-                        expr.span.shrink_to_hi(),\n-                        fluent::hir_typeck_convert_to_str,\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                    return true;\n-                }\n+                    let struct_pat_shorthand_field =\n+                        self.maybe_get_struct_pattern_shorthand_field(expr);\n+                    if let Some(name) = struct_pat_shorthand_field {\n+                        sugg.insert(0, (expr.span.shrink_to_lo(), format!(\"{}: \", name)));\n+                    }\n+                    Some(sugg)\n+                })\n+                .peekable();\n+            if suggestions.peek().is_some() {\n+                err.multipart_suggestions(\n+                    \"try using a conversion method\",\n+                    suggestions,\n+                    Applicability::MaybeIncorrect,\n+                );\n+                return true;\n+            }\n+        }\n+\n+        if let Some((found_ty_inner, expected_ty_inner, error_tys)) =\n+            self.deconstruct_option_or_result(found, expected)\n+            && let ty::Ref(_, peeled, hir::Mutability::Not) = *expected_ty_inner.kind()\n+        {\n+            // Check that given `Result<_, E>`, our expected ty is `Result<_, &E>`\n+            let error_tys_equate_as_ref = error_tys.map_or(true, |(found, expected)| {\n+                self.can_eq(self.param_env, self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, found), expected)\n+            });\n+            // FIXME: This could/should be extended to suggest `as_mut` and `as_deref_mut`,\n+            // but those checks need to be a bit more delicate and the benefit is diminishing.\n+            if self.can_eq(self.param_env, found_ty_inner, peeled) && error_tys_equate_as_ref {\n+                err.subdiagnostic(SuggestConvertViaMethod {\n+                    span: expr.span.shrink_to_hi(),\n+                    sugg: \".as_ref()\",\n+                    expected,\n+                    found,\n+                });\n+                return true;\n+            } else if let Some((deref_ty, _)) =\n+                self.autoderef(expr.span, found_ty_inner).silence_errors().nth(1)\n+                && self.can_eq(self.param_env, deref_ty, peeled)\n+                && error_tys_equate_as_ref\n+            {\n+                err.subdiagnostic(SuggestConvertViaMethod {\n+                    span: expr.span.shrink_to_hi(),\n+                    sugg: \".as_deref()\",\n+                    expected,\n+                    found,\n+                });\n+                return true;\n+            } else if let ty::Adt(adt, _) = found_ty_inner.peel_refs().kind()\n+                && Some(adt.did()) == self.tcx.lang_items().string()\n+                && peeled.is_str()\n+                && error_tys.map_or(true, |(found, expected)| {\n+                    self.can_eq(self.param_env, found, expected)\n+                })\n+            {\n+                err.span_suggestion_verbose(\n+                    expr.span.shrink_to_hi(),\n+                    fluent::hir_typeck_convert_to_str,\n+                    \".map(|x| x.as_str())\",\n+                    Applicability::MachineApplicable,\n+                );\n+                return true;\n             }\n         }\n \n         false\n     }\n \n+    fn deconstruct_option_or_result(\n+        &self,\n+        found_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<(Ty<'tcx>, Ty<'tcx>, Option<(Ty<'tcx>, Ty<'tcx>)>)> {\n+        let ty::Adt(found_adt, found_substs) = found_ty.peel_refs().kind() else {\n+            return None;\n+        };\n+        let ty::Adt(expected_adt, expected_substs) = expected_ty.kind() else {\n+            return None;\n+        };\n+        if self.tcx.is_diagnostic_item(sym::Option, found_adt.did())\n+            && self.tcx.is_diagnostic_item(sym::Option, expected_adt.did())\n+        {\n+            Some((found_substs.type_at(0), expected_substs.type_at(0), None))\n+        } else if self.tcx.is_diagnostic_item(sym::Result, found_adt.did())\n+            && self.tcx.is_diagnostic_item(sym::Result, expected_adt.did())\n+        {\n+            Some((\n+                found_substs.type_at(0),\n+                expected_substs.type_at(0),\n+                Some((found_substs.type_at(1), expected_substs.type_at(1))),\n+            ))\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n     /// in the heap by calling `Box::new()`.\n     pub(in super::super) fn suggest_boxing_when_appropriate("}, {"sha": "4d0e7706367219253cd83aa716b37fc2935bb9f0", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -278,9 +278,6 @@ infer_ril_introduced_by = requirement introduced by this return type\n infer_ril_introduced_here = `'static` requirement introduced here\n infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type\n \n-infer_sarwa_option = you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`\n-infer_sarwa_result = you can convert from `&Result<T, E>` to `Result<&T, &E>` using `.as_ref()`\n-\n infer_sbfrit_box_return_expr = if you change the return type to expect trait objects, box the returned expressions\n \n infer_sbfrit_change_return_type = you could change the return type to be a boxed trait object"}, {"sha": "7e1fa08f23ae282b6b6e43a439e80a371b383480", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -1246,30 +1246,6 @@ pub struct FnConsiderCasting {\n     pub casting: String,\n }\n \n-#[derive(Subdiagnostic)]\n-pub enum SuggestAsRefWhereAppropriate<'a> {\n-    #[suggestion(\n-        infer_sarwa_option,\n-        code = \"{snippet}.as_ref()\",\n-        applicability = \"machine-applicable\"\n-    )]\n-    Option {\n-        #[primary_span]\n-        span: Span,\n-        snippet: &'a str,\n-    },\n-    #[suggestion(\n-        infer_sarwa_result,\n-        code = \"{snippet}.as_ref()\",\n-        applicability = \"machine-applicable\"\n-    )]\n-    Result {\n-        #[primary_span]\n-        span: Span,\n-        snippet: &'a str,\n-    },\n-}\n-\n #[derive(Subdiagnostic)]\n pub enum SuggestAccessingField<'a> {\n     #[suggestion("}, {"sha": "ce5b5882e3b26409537b60fe5a427a59a23cd1ac", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -1897,7 +1897,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n             if should_suggest_fixes {\n                 self.suggest_tuple_pattern(cause, &exp_found, diag);\n-                self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n                 self.suggest_accessing_field_where_appropriate(cause, &exp_found, diag);\n                 self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n                 self.suggest_function_pointers(cause, span, &exp_found, diag);"}, {"sha": "1422bdc9ea282c86f3a278bf1c6b5cd45c2cb977", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -13,9 +13,9 @@ use rustc_span::{sym, BytePos, Span};\n \n use crate::errors::{\n     ConsiderAddingAwait, FnConsiderCasting, FnItemsAreDistinct, FnUniqTypes,\n-    FunctionPointerSuggestion, SuggestAccessingField, SuggestAsRefWhereAppropriate,\n-    SuggestBoxingForReturnImplTrait, SuggestRemoveSemiOrReturnBinding, SuggestTuplePatternMany,\n-    SuggestTuplePatternOne, TypeErrorAdditionalDiags,\n+    FunctionPointerSuggestion, SuggestAccessingField, SuggestBoxingForReturnImplTrait,\n+    SuggestRemoveSemiOrReturnBinding, SuggestTuplePatternMany, SuggestTuplePatternOne,\n+    TypeErrorAdditionalDiags,\n };\n \n use super::TypeErrCtxt;\n@@ -289,27 +289,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n-    /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n-    /// suggests it.\n-    pub(super) fn suggest_as_ref_where_appropriate(\n-        &self,\n-        span: Span,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-            && let Some(msg) = self.should_suggest_as_ref_kind(exp_found.expected, exp_found.found)\n-        {\n-            // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-            let snippet = snippet.trim_start_matches('&');\n-            let subdiag = match msg {\n-                SuggestAsRefKind::Option => SuggestAsRefWhereAppropriate::Option { span, snippet },\n-                SuggestAsRefKind::Result => SuggestAsRefWhereAppropriate::Result { span, snippet },\n-            };\n-            diag.subdiagnostic(subdiag);\n-        }\n-    }\n-\n     pub(super) fn suggest_function_pointers(\n         &self,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "e4fc5cb367cfa46ea4cf8a00b40a6d4044fa90c4", "filename": "tests/ui/issues/issue-100605.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Fissues%2Fissue-100605.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Fissues%2Fissue-100605.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-100605.stderr?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -13,10 +13,6 @@ note: function defined here\n    |\n LL | fn takes_option(_arg: Option<&String>) {}\n    |    ^^^^^^^^^^^^ ---------------------\n-help: you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`\n-   |\n-LL |     takes_option(None.as_ref());\n-   |                  ~~~~~~~~~~~~~\n help: consider removing the borrow\n    |\n LL -     takes_option(&None);\n@@ -27,10 +23,8 @@ error[E0308]: mismatched types\n   --> $DIR/issue-100605.rs:8:18\n    |\n LL |     takes_option(&res);\n-   |     ------------ ^^^^\n-   |     |            |\n-   |     |            expected `Option<&String>`, found `&Option<String>`\n-   |     |            help: you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`: `res.as_ref()`\n+   |     ------------ ^^^^ expected `Option<&String>`, found `&Option<String>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note:   expected enum `Option<&String>`\n@@ -40,6 +34,10 @@ note: function defined here\n    |\n LL | fn takes_option(_arg: Option<&String>) {}\n    |    ^^^^^^^^^^^^ ---------------------\n+help: try using `.as_ref()` to convert `&Option<String>` to `Option<&String>`\n+   |\n+LL |     takes_option(&res.as_ref());\n+   |                      +++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7093b5fa9af35e748943f66068696fb8d712c4c9", "filename": "tests/ui/let-else/let-else-ref-bindings.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -6,6 +6,10 @@ LL |     let Some(ref a): Option<&[u8]> = some else { return };\n    |\n    = note: expected enum `Option<&[u8]>`\n               found enum `Option<Vec<u8>>`\n+help: try using `.as_deref()` to convert `Option<Vec<u8>>` to `Option<&[u8]>`\n+   |\n+LL |     let Some(ref a): Option<&[u8]> = some.as_deref() else { return };\n+   |                                          +++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:20:38\n@@ -15,6 +19,10 @@ LL |     let Some(ref a): Option<&[u8]> = &some else { return };\n    |\n    = note:   expected enum `Option<&[u8]>`\n            found reference `&Option<Vec<u8>>`\n+help: try using `.as_deref()` to convert `&Option<Vec<u8>>` to `Option<&[u8]>`\n+   |\n+LL |     let Some(ref a): Option<&[u8]> = &some.as_deref() else { return };\n+   |                                           +++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:24:34\n@@ -26,6 +34,10 @@ LL |     let Some(a): Option<&[u8]> = some else { return };\n    |\n    = note: expected enum `Option<&[u8]>`\n               found enum `Option<Vec<u8>>`\n+help: try using `.as_deref()` to convert `Option<Vec<u8>>` to `Option<&[u8]>`\n+   |\n+LL |     let Some(a): Option<&[u8]> = some.as_deref() else { return };\n+   |                                      +++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:27:34\n@@ -37,6 +49,10 @@ LL |     let Some(a): Option<&[u8]> = &some else { return };\n    |\n    = note:   expected enum `Option<&[u8]>`\n            found reference `&Option<Vec<u8>>`\n+help: try using `.as_deref()` to convert `&Option<Vec<u8>>` to `Option<&[u8]>`\n+   |\n+LL |     let Some(a): Option<&[u8]> = &some.as_deref() else { return };\n+   |                                       +++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:44:46"}, {"sha": "0d9790ac22974b7614750e42a0a936aea61a8e3f", "filename": "tests/ui/suggestions/as-ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Fsuggestions%2Fas-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Fsuggestions%2Fas-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fas-ref.rs?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -24,4 +24,6 @@ fn main() {\n     let multiple_ref_result = &&Ok(Foo);\n     multiple_ref_result.map(|arg| takes_ref(arg)); //~ ERROR mismatched types [E0308]\n     multiple_ref_result.and_then(|arg| Ok(takes_ref(arg))); //~ ERROR mismatched types [E0308]\n+\n+    let _: Result<&usize, _> = &Ok(42); //~ ERROR mismatched types [E0308]\n }"}, {"sha": "c5b2bb1260f354ef8b1bc18bc1e61a4a72afbc8f", "filename": "tests/ui/suggestions/as-ref.stderr", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Fsuggestions%2Fas-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Fsuggestions%2Fas-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fas-ref.stderr?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -74,14 +74,16 @@ error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:13:29\n    |\n LL |     let y: Option<&usize> = x;\n-   |            --------------   ^\n-   |            |                |\n-   |            |                expected `Option<&usize>`, found `&Option<usize>`\n-   |            |                help: you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`: `x.as_ref()`\n+   |            --------------   ^ expected `Option<&usize>`, found `&Option<usize>`\n+   |            |\n    |            expected due to this\n    |\n    = note:   expected enum `Option<&usize>`\n            found reference `&Option<usize>`\n+help: try using `.as_ref()` to convert `&Option<usize>` to `Option<&usize>`\n+   |\n+LL |     let y: Option<&usize> = x.as_ref();\n+   |                              +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:15:37\n@@ -93,10 +95,10 @@ LL |     let y: Result<&usize, &usize> = x;\n    |\n    = note:   expected enum `Result<&usize, &usize>`\n            found reference `&Result<usize, usize>`\n-help: you can convert from `&Result<T, E>` to `Result<&T, &E>` using `.as_ref()`\n+help: try using `.as_ref()` to convert `&Result<usize, usize>` to `Result<&usize, &usize>`\n    |\n LL |     let y: Result<&usize, &usize> = x.as_ref();\n-   |                                     ~~~~~~~~~~\n+   |                                      +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:19:36\n@@ -181,6 +183,22 @@ help: consider using `as_ref` instead\n LL |     multiple_ref_result.as_ref().and_then(|arg| Ok(takes_ref(arg)));\n    |                         +++++++++\n \n-error: aborting due to 11 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/as-ref.rs:28:32\n+   |\n+LL |     let _: Result<&usize, _> = &Ok(42);\n+   |            -----------------   ^^^^^^^ expected `Result<&usize, _>`, found `&Result<{integer}, _>`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note:   expected enum `Result<&usize, _>`\n+           found reference `&Result<{integer}, _>`\n+help: try using `.as_ref()` to convert `&Result<{integer}, _>` to `Result<&usize, _>`\n+   |\n+LL -     let _: Result<&usize, _> = &Ok(42);\n+LL +     let _: Result<&usize, _> = Ok(42).as_ref();\n+   |\n+\n+error: aborting due to 12 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "0db3e67ede0d4b0a441d7a4f1c308c35e81a947d", "filename": "tests/ui/typeck/issue-89856.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Ftypeck%2Fissue-89856.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af54d584b29e6afd7069bfdad071c43c0aa135f5/tests%2Fui%2Ftypeck%2Fissue-89856.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-89856.stderr?ref=af54d584b29e6afd7069bfdad071c43c0aa135f5", "patch": "@@ -13,7 +13,7 @@ note: function defined here\n    |\n LL | fn take_str_maybe(_: Option<&str>) { }\n    |    ^^^^^^^^^^^^^^ ---------------\n-help: try converting the passed type into a `&str`\n+help: try using `.as_deref()` to convert `Option<String>` to `Option<&str>`\n    |\n LL |     take_str_maybe(option.as_deref());\n    |                          +++++++++++"}]}