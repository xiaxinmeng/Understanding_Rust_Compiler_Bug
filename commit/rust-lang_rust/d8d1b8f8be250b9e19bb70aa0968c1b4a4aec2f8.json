{"sha": "d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZDFiOGY4YmUyNTBiOWUxOWJiNzBhYTA5NjhjMWI0YTRhZWMyZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-18T02:11:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-18T02:11:19Z"}, "message": "auto merge of #9896 : brson/rust/stdmem, r=alexcrichton\n\nThis is progress toward removing std::sys.", "tree": {"sha": "08dfaee59b6b2f3c02debee28c03917a6965e379", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08dfaee59b6b2f3c02debee28c03917a6965e379"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "html_url": "https://github.com/rust-lang/rust/commit/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51709fcedcc264056587ece3759b3b591c268d0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/51709fcedcc264056587ece3759b3b591c268d0e", "html_url": "https://github.com/rust-lang/rust/commit/51709fcedcc264056587ece3759b3b591c268d0e"}, {"sha": "34d376f3cf234dc714fcfab7639affd3967dc16d", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d376f3cf234dc714fcfab7639affd3967dc16d", "html_url": "https://github.com/rust-lang/rust/commit/34d376f3cf234dc714fcfab7639affd3967dc16d"}], "stats": {"total": 557, "additions": 288, "deletions": 269}, "files": [{"sha": "0313a3379b787b5cc8328aebad3d9dc5688b77c9", "filename": "doc/po/ja/rust.md.po", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Fpo%2Fja%2Frust.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Fpo%2Fja%2Frust.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Frust.md.po?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -1842,7 +1842,7 @@ msgid \"\"\n \"The type parameters can also be explicitly supplied in a trailing [path]\"\n \"(#paths) component after the function name. This might be necessary if there \"\n \"is not sufficient context to determine the type parameters. For example, \"\n-\"`sys::size_of::<u32>() == 4`.\"\n+\"`mem::size_of::<u32>() == 4`.\"\n msgstr \"\"\n \n #. type: Plain text"}, {"sha": "ff28357cabf13456d3be08917b623ffe29dda0c0", "filename": "doc/po/ja/tutorial-ffi.md.po", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -327,7 +327,7 @@ msgid \"\"\n \"impl<T: Send> Unique<T> {\\n\"\n \"    pub fn new(value: T) -> Unique<T> {\\n\"\n \"        unsafe {\\n\"\n-\"            let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\\n\"\n+\"            let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\\n\"\n \"            assert!(!ptr::is_null(ptr));\\n\"\n \"            // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\\n\"\n \"            intrinsics::move_val_init(&mut *ptr, value);\\n\""}, {"sha": "31056378a48dca4426c26f49c807fd411887f77d", "filename": "doc/po/rust.md.pot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Fpo%2Frust.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Fpo%2Frust.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Frust.md.pot?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -1842,7 +1842,7 @@ msgid \"\"\n \"The type parameters can also be explicitly supplied in a trailing [path]\"\n \"(#paths) component after the function name. This might be necessary if there \"\n \"is not sufficient context to determine the type parameters. For example, \"\n-\"`sys::size_of::<u32>() == 4`.\"\n+\"`mem::size_of::<u32>() == 4`.\"\n msgstr \"\"\n \n #. type: Plain text"}, {"sha": "c3116dea872749571c3e7ca66be705ee4bc6aa46", "filename": "doc/po/tutorial-ffi.md.pot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Fpo%2Ftutorial-ffi.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Fpo%2Ftutorial-ffi.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-ffi.md.pot?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -327,7 +327,7 @@ msgid \"\"\n \"impl<T: Send> Unique<T> {\\n\"\n \"    pub fn new(value: T) -> Unique<T> {\\n\"\n \"        unsafe {\\n\"\n-\"            let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\\n\"\n+\"            let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\\n\"\n \"            assert!(!ptr::is_null(ptr));\\n\"\n \"            // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\\n\"\n \"            intrinsics::move_val_init(&mut *ptr, value);\\n\""}, {"sha": "621bf927e39fe33ad7bd184dc088c224969247d5", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -975,7 +975,7 @@ with `int`, and require the closure parameter to have type\n The type parameters can also be explicitly supplied in a trailing\n [path](#paths) component after the function name. This might be necessary\n if there is not sufficient context to determine the type parameters. For\n-example, `sys::size_of::<u32>() == 4`.\n+example, `mem::size_of::<u32>() == 4`.\n \n Since a parameter type is opaque to the generic function, the set of\n operations that can be performed on it is limited. Values of parameter"}, {"sha": "57dc926dfa9c6e6bf95c8044f09a08484c8382de", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -300,7 +300,7 @@ impl<T: Send> Unique<T> {\n         #[inline(never)];\n \n         unsafe {\n-            let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\n+            let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\n             assert!(!ptr::is_null(ptr));\n             // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n             intrinsics::move_val_init(&mut *ptr, value);"}, {"sha": "6c4e86d958e25ad494233a5a4d32c94a3e13283a", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -42,7 +42,7 @@ use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n use std::num;\n use std::ptr;\n-use std::sys;\n+use std::mem;\n use std::uint;\n use std::vec;\n use std::unstable::intrinsics;\n@@ -123,7 +123,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n-        let after_tydesc = idx + sys::size_of::<*TyDesc>();\n+        let after_tydesc = idx + mem::size_of::<*TyDesc>();\n \n         let start = round_up_to(after_tydesc, align);\n \n@@ -134,7 +134,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         }\n \n         // Find where the next tydesc lives\n-        idx = round_up_to(start + size, sys::pref_align_of::<*TyDesc>());\n+        idx = round_up_to(start + size, mem::pref_align_of::<*TyDesc>());\n     }\n }\n \n@@ -220,7 +220,7 @@ impl Arena {\n                 let head = transmute_mut_region(&mut self.head);\n \n                 tydesc_start = head.fill;\n-                after_tydesc = head.fill + sys::size_of::<*TyDesc>();\n+                after_tydesc = head.fill + mem::size_of::<*TyDesc>();\n                 start = round_up_to(after_tydesc, align);\n                 end = start + n_bytes;\n             }\n@@ -230,7 +230,7 @@ impl Arena {\n             }\n \n             let head = transmute_mut_region(&mut self.head);\n-            head.fill = round_up_to(end, sys::pref_align_of::<*TyDesc>());\n+            head.fill = round_up_to(end, mem::pref_align_of::<*TyDesc>());\n \n             //debug2!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);"}, {"sha": "8607710edc396f5ccadba3c0b733027f79397dcc", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -14,7 +14,7 @@ use clone::Clone;\n use container::Container;\n use iter::Iterator;\n use option::{Option, Some, None};\n-use sys;\n+use mem;\n use unstable::raw::Repr;\n use vec::{ImmutableVector, OwnedVector};\n \n@@ -26,7 +26,7 @@ use vec::{ImmutableVector, OwnedVector};\n pub fn capacity<T>(v: @[T]) -> uint {\n     unsafe {\n         let box = v.repr();\n-        (*box).data.alloc / sys::size_of::<T>()\n+        (*box).data.alloc / mem::size_of::<T>()\n     }\n }\n \n@@ -160,7 +160,7 @@ pub mod raw {\n     use cast::{transmute, transmute_copy};\n     use libc;\n     use ptr;\n-    use sys;\n+    use mem;\n     use uint;\n     use unstable::intrinsics::{move_val_init, TyDesc};\n     use unstable::intrinsics;\n@@ -176,7 +176,7 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn set_len<T>(v: &mut @[T], new_len: uint) {\n         let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n-        (*repr).data.fill = new_len * sys::size_of::<T>();\n+        (*repr).data.fill = new_len * mem::size_of::<T>();\n     }\n \n     /**\n@@ -199,7 +199,7 @@ pub mod raw {\n     unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n         let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n         let amt = v.len();\n-        (*repr).data.fill += sys::size_of::<T>();\n+        (*repr).data.fill += mem::size_of::<T>();\n         let p = ptr::offset(&(*repr).data.data as *T, amt as int) as *mut T;\n         move_val_init(&mut(*p), initval);\n     }\n@@ -236,7 +236,7 @@ pub mod raw {\n         unsafe {\n             if n > (**ptr).data.alloc / (*ty).size {\n                 let alloc = n * (*ty).size;\n-                let total_size = alloc + sys::size_of::<Vec<()>>();\n+                let total_size = alloc + mem::size_of::<Vec<()>>();\n                 if alloc / (*ty).size != n || total_size < alloc {\n                     fail2!(\"vector size is too large: {}\", n);\n                 }"}, {"sha": "a4f2ee0d09c78501cf7bd9bb2fc4835a77816ec1", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -11,7 +11,7 @@\n //! Unsafe casting functions\n \n use ptr::RawPtr;\n-use sys;\n+use mem;\n use unstable::intrinsics;\n \n /// Casts the value at `src` to U. The two types must have the same length.\n@@ -21,7 +21,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = intrinsics::uninit();\n     let dest_ptr: *mut u8 = transmute(&mut dest);\n     let src_ptr: *u8 = transmute(src);\n-    intrinsics::memcpy32(dest_ptr, src_ptr, sys::size_of::<U>() as u32);\n+    intrinsics::memcpy32(dest_ptr, src_ptr, mem::size_of::<U>() as u32);\n     dest\n }\n \n@@ -32,7 +32,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = intrinsics::uninit();\n     let dest_ptr: *mut u8 = transmute(&mut dest);\n     let src_ptr: *u8 = transmute(src);\n-    intrinsics::memcpy64(dest_ptr, src_ptr, sys::size_of::<U>() as u64);\n+    intrinsics::memcpy64(dest_ptr, src_ptr, mem::size_of::<U>() as u64);\n     dest\n }\n "}, {"sha": "a8c4d9fdca3c20f1ff5091cb9eb9dae786045246", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -68,7 +68,7 @@ fn debug_mem() -> bool {\n /// Destroys all managed memory (i.e. @ boxes) held by the current task.\n pub unsafe fn annihilate() {\n     use rt::local_heap::local_free;\n-    use sys;\n+    use mem;\n     use managed;\n \n     let mut stats = AnnihilateStats {\n@@ -115,7 +115,7 @@ pub unsafe fn annihilate() {\n         if !uniq {\n             stats.n_bytes_freed +=\n                 (*((*box).type_desc)).size\n-                + sys::size_of::<raw::Box<()>>();\n+                + mem::size_of::<raw::Box<()>>();\n             local_free(box as *i8);\n         }\n         true"}, {"sha": "311bf5f6bc87c226a4532b18e39ba1b693d8caee", "filename": "src/libstd/mem.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmem.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -0,0 +1,158 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Functions relating to memory layout\n+\n+use unstable::intrinsics;\n+\n+/// Returns the size of a type\n+#[inline]\n+pub fn size_of<T>() -> uint {\n+    unsafe { intrinsics::size_of::<T>() }\n+}\n+\n+/// Returns the size of the type that `_val` points to\n+#[inline]\n+pub fn size_of_val<T>(_val: &T) -> uint {\n+    size_of::<T>()\n+}\n+\n+/**\n+ * Returns the size of a type, or 1 if the actual size is zero.\n+ *\n+ * Useful for building structures containing variable-length arrays.\n+ */\n+#[inline]\n+pub fn nonzero_size_of<T>() -> uint {\n+    let s = size_of::<T>();\n+    if s == 0 { 1 } else { s }\n+}\n+\n+/// Returns the size of the type of the value that `_val` points to\n+#[inline]\n+pub fn nonzero_size_of_val<T>(_val: &T) -> uint {\n+    nonzero_size_of::<T>()\n+}\n+\n+\n+/**\n+ * Returns the ABI-required minimum alignment of a type\n+ *\n+ * This is the alignment used for struct fields. It may be smaller\n+ * than the preferred alignment.\n+ */\n+#[inline]\n+pub fn min_align_of<T>() -> uint {\n+    unsafe { intrinsics::min_align_of::<T>() }\n+}\n+\n+/// Returns the ABI-required minimum alignment of the type of the value that\n+/// `_val` points to\n+#[inline]\n+pub fn min_align_of_val<T>(_val: &T) -> uint {\n+    min_align_of::<T>()\n+}\n+\n+/// Returns the preferred alignment of a type\n+#[inline]\n+pub fn pref_align_of<T>() -> uint {\n+    unsafe { intrinsics::pref_align_of::<T>() }\n+}\n+\n+/// Returns the preferred alignment of the type of the value that\n+/// `_val` points to\n+#[inline]\n+pub fn pref_align_of_val<T>(_val: &T) -> uint {\n+    pref_align_of::<T>()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use cast;\n+    use mem::*;\n+\n+    #[test]\n+    fn size_of_basic() {\n+        assert_eq!(size_of::<u8>(), 1u);\n+        assert_eq!(size_of::<u16>(), 2u);\n+        assert_eq!(size_of::<u32>(), 4u);\n+        assert_eq!(size_of::<u64>(), 8u);\n+    }\n+\n+    #[test]\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"arm\")]\n+    #[cfg(target_arch = \"mips\")]\n+    fn size_of_32() {\n+        assert_eq!(size_of::<uint>(), 4u);\n+        assert_eq!(size_of::<*uint>(), 4u);\n+    }\n+\n+    #[test]\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn size_of_64() {\n+        assert_eq!(size_of::<uint>(), 8u);\n+        assert_eq!(size_of::<*uint>(), 8u);\n+    }\n+\n+    #[test]\n+    fn size_of_val_basic() {\n+        assert_eq!(size_of_val(&1u8), 1);\n+        assert_eq!(size_of_val(&1u16), 2);\n+        assert_eq!(size_of_val(&1u32), 4);\n+        assert_eq!(size_of_val(&1u64), 8);\n+    }\n+\n+    #[test]\n+    fn nonzero_size_of_basic() {\n+        type Z = [i8, ..0];\n+        assert_eq!(size_of::<Z>(), 0u);\n+        assert_eq!(nonzero_size_of::<Z>(), 1u);\n+        assert_eq!(nonzero_size_of::<uint>(), size_of::<uint>());\n+    }\n+\n+    #[test]\n+    fn nonzero_size_of_val_basic() {\n+        let z = [0u8, ..0];\n+        assert_eq!(size_of_val(&z), 0u);\n+        assert_eq!(nonzero_size_of_val(&z), 1u);\n+        assert_eq!(nonzero_size_of_val(&1u), size_of_val(&1u));\n+    }\n+\n+    #[test]\n+    fn align_of_basic() {\n+        assert_eq!(pref_align_of::<u8>(), 1u);\n+        assert_eq!(pref_align_of::<u16>(), 2u);\n+        assert_eq!(pref_align_of::<u32>(), 4u);\n+    }\n+\n+    #[test]\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"arm\")]\n+    #[cfg(target_arch = \"mips\")]\n+    fn align_of_32() {\n+        assert_eq!(pref_align_of::<uint>(), 4u);\n+        assert_eq!(pref_align_of::<*uint>(), 4u);\n+    }\n+\n+    #[test]\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn align_of_64() {\n+        assert_eq!(pref_align_of::<uint>(), 8u);\n+        assert_eq!(pref_align_of::<*uint>(), 8u);\n+    }\n+\n+    #[test]\n+    fn align_of_val_basic() {\n+        assert_eq!(pref_align_of_val(&1u8), 1u);\n+        assert_eq!(pref_align_of_val(&1u16), 2u);\n+        assert_eq!(pref_align_of_val(&1u32), 4u);\n+    }\n+}"}, {"sha": "e99dcd6b2eb33b9e68231ea02d78f51bd055ebff", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -928,7 +928,7 @@ mod tests {\n \n     use num::*;\n     use num;\n-    use sys;\n+    use mem;\n \n     #[test]\n     fn test_num() {\n@@ -1198,8 +1198,8 @@ mod tests {\n     #[test]\n     fn test_primitive() {\n         let none: Option<f32> = None;\n-        assert_eq!(Primitive::bits(none), sys::size_of::<f32>() * 8);\n-        assert_eq!(Primitive::bytes(none), sys::size_of::<f32>());\n+        assert_eq!(Primitive::bits(none), mem::size_of::<f32>() * 8);\n+        assert_eq!(Primitive::bytes(none), mem::size_of::<f32>());\n     }\n \n     #[test]"}, {"sha": "f367de376d418fbf8d38a5cd1384ce88bf0c516d", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -976,7 +976,7 @@ mod tests {\n \n     use num::*;\n     use num;\n-    use sys;\n+    use mem;\n \n     #[test]\n     fn test_num() {\n@@ -1249,8 +1249,8 @@ mod tests {\n     #[test]\n     fn test_primitive() {\n         let none: Option<f64> = None;\n-        assert_eq!(Primitive::bits(none), sys::size_of::<f64>() * 8);\n-        assert_eq!(Primitive::bytes(none), sys::size_of::<f64>());\n+        assert_eq!(Primitive::bits(none), mem::size_of::<f64>() * 8);\n+        assert_eq!(Primitive::bytes(none), mem::size_of::<f64>());\n     }\n \n     #[test]"}, {"sha": "694e5e7f6bfee28153aa4631d292396a6dc8706a", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -456,7 +456,7 @@ mod tests {\n     use int;\n     use i32;\n     use num;\n-    use sys;\n+    use mem;\n \n     #[test]\n     fn test_num() {\n@@ -653,8 +653,8 @@ mod tests {\n     #[test]\n     fn test_primitive() {\n         let none: Option<$T> = None;\n-        assert_eq!(Primitive::bits(none), sys::size_of::<$T>() * 8);\n-        assert_eq!(Primitive::bytes(none), sys::size_of::<$T>());\n+        assert_eq!(Primitive::bits(none), mem::size_of::<$T>() * 8);\n+        assert_eq!(Primitive::bytes(none), mem::size_of::<$T>());\n     }\n \n     #[test]"}, {"sha": "2ecbb79407e1bef98f451cea4eafb0c72fdc6b67", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -14,7 +14,7 @@ use num;\n use num::{CheckedAdd, CheckedSub, CheckedMul};\n use option::{Option, Some, None};\n use unstable::intrinsics;\n-use sys;\n+use mem;\n \n pub use self::generated::*;\n \n@@ -97,7 +97,7 @@ impl num::Times for uint {\n /// Returns the smallest power of 2 greater than or equal to `n`\n #[inline]\n pub fn next_power_of_two(n: uint) -> uint {\n-    let halfbits: uint = sys::size_of::<uint>() * 4u;\n+    let halfbits: uint = mem::size_of::<uint>() * 4u;\n     let mut tmp: uint = n - 1u;\n     let mut shift: uint = 1u;\n     while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n@@ -107,7 +107,7 @@ pub fn next_power_of_two(n: uint) -> uint {\n /// Returns the smallest power of 2 greater than or equal to `n`\n #[inline]\n pub fn next_power_of_two_opt(n: uint) -> Option<uint> {\n-    let halfbits: uint = sys::size_of::<uint>() * 4u;\n+    let halfbits: uint = mem::size_of::<uint>() * 4u;\n     let mut tmp: uint = n - 1u;\n     let mut shift: uint = 1u;\n     while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }"}, {"sha": "2974b402d4a7675af4424aafc7158bc7b254311a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -337,7 +337,7 @@ mod tests {\n     use super::*;\n \n     use num;\n-    use sys;\n+    use mem;\n     use u16;\n \n     #[test]\n@@ -431,8 +431,8 @@ mod tests {\n     #[test]\n     fn test_primitive() {\n         let none: Option<$T> = None;\n-        assert_eq!(Primitive::bits(none), sys::size_of::<$T>() * 8);\n-        assert_eq!(Primitive::bytes(none), sys::size_of::<$T>());\n+        assert_eq!(Primitive::bits(none), mem::size_of::<$T>() * 8);\n+        assert_eq!(Primitive::bytes(none), mem::size_of::<$T>());\n     }\n \n     #[test]"}, {"sha": "954db42c89be1f7329d48323818f8cb13bc9371e", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -52,7 +52,7 @@ fn main () {\n  ```\n */\n \n-use sys::size_of;\n+use mem::size_of;\n use unstable::raw::Slice;\n use cast;\n use container::Container;\n@@ -952,7 +952,7 @@ mod test {\n mod bench {\n     use extra::test::BenchHarness;\n     use rand::*;\n-    use sys::size_of;\n+    use mem::size_of;\n \n     #[bench]\n     fn rand_xorshift(bh: &mut BenchHarness) {"}, {"sha": "1cd7672771678a7cae63cde8122a21ee301f6730", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -18,7 +18,7 @@ Runtime type reflection\n \n use unstable::intrinsics::{Opaque, TyDesc, TyVisitor};\n use libc::c_void;\n-use sys;\n+use mem;\n use unstable::raw;\n \n /**\n@@ -64,12 +64,12 @@ impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n \n     #[inline]\n     pub fn align_to<T>(&mut self) {\n-        self.align(sys::min_align_of::<T>());\n+        self.align(mem::min_align_of::<T>());\n     }\n \n     #[inline]\n     pub fn bump_past<T>(&mut self) {\n-        self.bump(sys::size_of::<T>());\n+        self.bump(mem::size_of::<T>());\n     }\n }\n "}, {"sha": "222f9a44b1745070dd13e49bf2c8530e230f0d1c", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -233,6 +233,6 @@ fn align_down(sp: *mut uint) -> *mut uint {\n // ptr::mut_offset is positive ints only\n #[inline]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n-    use std::sys::size_of;\n+    use mem::size_of;\n     (ptr as int + count * (size_of::<T>() as int)) as *mut T\n }"}, {"sha": "446efbd9047102268271fb97cfe5305fbea7168d", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -11,7 +11,7 @@\n use libc::{c_void, c_char, size_t, uintptr_t, free, malloc, realloc};\n use unstable::intrinsics::TyDesc;\n use unstable::raw;\n-use sys::size_of;\n+use mem::size_of;\n \n extern {\n     #[rust_stack]"}, {"sha": "57367beacd833c19dfd09ff8aa109f30928fb2e5", "filename": "src/libstd/rt/io/native/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -271,12 +271,12 @@ fn spawn_process_os(prog: &str, args: &[~str],\n     };\n     use libc::funcs::extra::msvcrt::get_osfhandle;\n \n-    use sys;\n+    use mem;\n \n     unsafe {\n \n         let mut si = zeroed_startupinfo();\n-        si.cb = sys::size_of::<STARTUPINFO>() as DWORD;\n+        si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n         si.dwFlags = STARTF_USESTDHANDLES;\n \n         let cur_proc = GetCurrentProcess();"}, {"sha": "7724f58153ed67f89ee19bb4d4e4e9b45e4210f4", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -857,7 +857,7 @@ fn new_sched_rng() -> XorShiftRng {\n #[fixed_stack_segment] #[inline(never)]\n fn new_sched_rng() -> XorShiftRng {\n     use libc;\n-    use sys;\n+    use mem;\n     use c_str::ToCStr;\n     use vec::MutableVector;\n     use iter::Iterator;\n@@ -871,7 +871,7 @@ fn new_sched_rng() -> XorShiftRng {\n     }\n \n     let mut seeds = [0u32, .. 4];\n-    let size = sys::size_of_val(&seeds);\n+    let size = mem::size_of_val(&seeds);\n     loop {\n         let nbytes = do seeds.as_mut_buf |buf, _| {\n             unsafe {"}, {"sha": "9f4e6558ac598a19178bb6c22138198f3184a559", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -103,7 +103,7 @@ mod darwin_fd_limit {\n         // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n         // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n         use ptr::{to_unsafe_ptr, to_mut_unsafe_ptr, mut_null};\n-        use sys::size_of_val;\n+        use mem::size_of_val;\n         use os::last_os_error;\n \n         // Fetch the kern.maxfilesperproc value"}, {"sha": "c446fe3d94f97658c1212135a58e5b51bdeac742", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -189,6 +189,7 @@ pub mod condition;\n pub mod logging;\n pub mod util;\n pub mod routine;\n+pub mod mem;\n \n /* Unsupported interfaces */\n "}, {"sha": "0299ca0b49a775348f440d93cfa746f5c3367f27", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -19,68 +19,6 @@ use libc;\n use repr;\n use rt::task;\n use str;\n-use unstable::intrinsics;\n-\n-/// Returns the size of a type\n-#[inline]\n-pub fn size_of<T>() -> uint {\n-    unsafe { intrinsics::size_of::<T>() }\n-}\n-\n-/// Returns the size of the type that `_val` points to\n-#[inline]\n-pub fn size_of_val<T>(_val: &T) -> uint {\n-    size_of::<T>()\n-}\n-\n-/**\n- * Returns the size of a type, or 1 if the actual size is zero.\n- *\n- * Useful for building structures containing variable-length arrays.\n- */\n-#[inline]\n-pub fn nonzero_size_of<T>() -> uint {\n-    let s = size_of::<T>();\n-    if s == 0 { 1 } else { s }\n-}\n-\n-/// Returns the size of the type of the value that `_val` points to\n-#[inline]\n-pub fn nonzero_size_of_val<T>(_val: &T) -> uint {\n-    nonzero_size_of::<T>()\n-}\n-\n-\n-/**\n- * Returns the ABI-required minimum alignment of a type\n- *\n- * This is the alignment used for struct fields. It may be smaller\n- * than the preferred alignment.\n- */\n-#[inline]\n-pub fn min_align_of<T>() -> uint {\n-    unsafe { intrinsics::min_align_of::<T>() }\n-}\n-\n-/// Returns the ABI-required minimum alignment of the type of the value that\n-/// `_val` points to\n-#[inline]\n-pub fn min_align_of_val<T>(_val: &T) -> uint {\n-    min_align_of::<T>()\n-}\n-\n-/// Returns the preferred alignment of a type\n-#[inline]\n-pub fn pref_align_of<T>() -> uint {\n-    unsafe { intrinsics::pref_align_of::<T>() }\n-}\n-\n-/// Returns the preferred alignment of the type of the value that\n-/// `_val` points to\n-#[inline]\n-pub fn pref_align_of_val<T>(_val: &T) -> uint {\n-    pref_align_of::<T>()\n-}\n \n /// Returns the refcount of a shared box (as just before calling this)\n #[inline]\n@@ -131,84 +69,6 @@ mod tests {\n     use cast;\n     use sys::*;\n \n-    #[test]\n-    fn size_of_basic() {\n-        assert_eq!(size_of::<u8>(), 1u);\n-        assert_eq!(size_of::<u16>(), 2u);\n-        assert_eq!(size_of::<u32>(), 4u);\n-        assert_eq!(size_of::<u64>(), 8u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n-    fn size_of_32() {\n-        assert_eq!(size_of::<uint>(), 4u);\n-        assert_eq!(size_of::<*uint>(), 4u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn size_of_64() {\n-        assert_eq!(size_of::<uint>(), 8u);\n-        assert_eq!(size_of::<*uint>(), 8u);\n-    }\n-\n-    #[test]\n-    fn size_of_val_basic() {\n-        assert_eq!(size_of_val(&1u8), 1);\n-        assert_eq!(size_of_val(&1u16), 2);\n-        assert_eq!(size_of_val(&1u32), 4);\n-        assert_eq!(size_of_val(&1u64), 8);\n-    }\n-\n-    #[test]\n-    fn nonzero_size_of_basic() {\n-        type Z = [i8, ..0];\n-        assert_eq!(size_of::<Z>(), 0u);\n-        assert_eq!(nonzero_size_of::<Z>(), 1u);\n-        assert_eq!(nonzero_size_of::<uint>(), size_of::<uint>());\n-    }\n-\n-    #[test]\n-    fn nonzero_size_of_val_basic() {\n-        let z = [0u8, ..0];\n-        assert_eq!(size_of_val(&z), 0u);\n-        assert_eq!(nonzero_size_of_val(&z), 1u);\n-        assert_eq!(nonzero_size_of_val(&1u), size_of_val(&1u));\n-    }\n-\n-    #[test]\n-    fn align_of_basic() {\n-        assert_eq!(pref_align_of::<u8>(), 1u);\n-        assert_eq!(pref_align_of::<u16>(), 2u);\n-        assert_eq!(pref_align_of::<u32>(), 4u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n-    fn align_of_32() {\n-        assert_eq!(pref_align_of::<uint>(), 4u);\n-        assert_eq!(pref_align_of::<*uint>(), 4u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn align_of_64() {\n-        assert_eq!(pref_align_of::<uint>(), 8u);\n-        assert_eq!(pref_align_of::<*uint>(), 8u);\n-    }\n-\n-    #[test]\n-    fn align_of_val_basic() {\n-        assert_eq!(pref_align_of_val(&1u8), 1u);\n-        assert_eq!(pref_align_of_val(&1u16), 2u);\n-        assert_eq!(pref_align_of_val(&1u32), 4u);\n-    }\n-\n     #[test]\n     fn synthesize_closure() {\n         use unstable::raw::Closure;"}, {"sha": "0b28497e640f3844ba12370c5a9fe8d80cc92cdb", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -425,7 +425,7 @@ mod tests {\n     use super::{Exclusive, UnsafeArc, atomically};\n     use task;\n     use util;\n-    use sys::size_of;\n+    use mem::size_of;\n \n     //#[unsafe_no_drop_flag] FIXME: #9758\n     #[ignore]"}, {"sha": "3e44a30e47b33adcbf9d16c2cf1d51a00f0ec6fe", "filename": "src/libstd/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -93,7 +93,7 @@ mod tests {\n     use ops::Drop;\n     use option::{None, Some};\n     use either::{Either, Left, Right};\n-    use sys::size_of;\n+    use mem::size_of;\n \n     #[test]\n     fn identity_crisis() {"}, {"sha": "d298507aa8cb6e27a467c7d1e1afaa30fef84c7c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -116,8 +116,8 @@ use ptr;\n use ptr::RawPtr;\n use rt::global_heap::malloc_raw;\n use rt::global_heap::realloc_raw;\n-use sys;\n-use sys::size_of;\n+use mem;\n+use mem::size_of;\n use uint;\n use unstable::finally::Finally;\n use unstable::intrinsics;\n@@ -185,8 +185,8 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n             vec.reserve(capacity);\n             vec\n         } else {\n-            let alloc = capacity * sys::nonzero_size_of::<T>();\n-            let ptr = malloc_raw(alloc + sys::size_of::<Vec<()>>()) as *mut Vec<()>;\n+            let alloc = capacity * mem::nonzero_size_of::<T>();\n+            let ptr = malloc_raw(alloc + mem::size_of::<Vec<()>>()) as *mut Vec<()>;\n             (*ptr).alloc = alloc;\n             (*ptr).fill = 0;\n             cast::transmute(ptr)\n@@ -1002,7 +1002,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn iter(self) -> VecIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_ptr(self);\n-            if sys::size_of::<T>() == 0 {\n+            if mem::size_of::<T>() == 0 {\n                 VecIterator{ptr: p,\n                             end: (p as uint + self.len()) as *T,\n                             lifetime: None}\n@@ -1406,9 +1406,9 @@ impl<T> OwnedVector<T> for ~[T] {\n                     ::at_vec::raw::reserve_raw(td, ptr, n);\n                 } else {\n                     let ptr: *mut *mut Vec<()> = cast::transmute(self);\n-                    let alloc = n * sys::nonzero_size_of::<T>();\n-                    let size = alloc + sys::size_of::<Vec<()>>();\n-                    if alloc / sys::nonzero_size_of::<T>() != n || size < alloc {\n+                    let alloc = n * mem::nonzero_size_of::<T>();\n+                    let size = alloc + mem::size_of::<Vec<()>>();\n+                    if alloc / mem::nonzero_size_of::<T>() != n || size < alloc {\n                         fail2!(\"vector size is too large: {}\", n);\n                     }\n                     *ptr = realloc_raw(*ptr as *mut c_void, size)\n@@ -1439,10 +1439,10 @@ impl<T> OwnedVector<T> for ~[T] {\n         unsafe {\n             if contains_managed::<T>() {\n                 let repr: **Box<Vec<()>> = cast::transmute(self);\n-                (**repr).data.alloc / sys::nonzero_size_of::<T>()\n+                (**repr).data.alloc / mem::nonzero_size_of::<T>()\n             } else {\n                 let repr: **Vec<()> = cast::transmute(self);\n-                (**repr).alloc / sys::nonzero_size_of::<T>()\n+                (**repr).alloc / mem::nonzero_size_of::<T>()\n             }\n         }\n     }\n@@ -1451,7 +1451,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         unsafe {\n             let ptr: *mut *mut Vec<()> = cast::transmute(self);\n             let alloc = (**ptr).fill;\n-            let size = alloc + sys::size_of::<Vec<()>>();\n+            let size = alloc + mem::size_of::<Vec<()>>();\n             *ptr = realloc_raw(*ptr as *mut c_void, size) as *mut Vec<()>;\n             (**ptr).alloc = alloc;\n         }\n@@ -1485,14 +1485,14 @@ impl<T> OwnedVector<T> for ~[T] {\n             if contains_managed::<T>() {\n                 let repr: **mut Box<Vec<u8>> = cast::transmute(this);\n                 let fill = (**repr).data.fill;\n-                (**repr).data.fill += sys::nonzero_size_of::<T>();\n+                (**repr).data.fill += mem::nonzero_size_of::<T>();\n                 let p = to_unsafe_ptr(&((**repr).data.data));\n                 let p = ptr::offset(p, fill as int) as *mut T;\n                 intrinsics::move_val_init(&mut(*p), t);\n             } else {\n                 let repr: **mut Vec<u8> = cast::transmute(this);\n                 let fill = (**repr).fill;\n-                (**repr).fill += sys::nonzero_size_of::<T>();\n+                (**repr).fill += mem::nonzero_size_of::<T>();\n                 let p = to_unsafe_ptr(&((**repr).data));\n                 let p = ptr::offset(p, fill as int) as *mut T;\n                 intrinsics::move_val_init(&mut(*p), t);\n@@ -1957,7 +1957,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     fn mut_iter(self) -> VecMutIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_mut_ptr(self);\n-            if sys::size_of::<T>() == 0 {\n+            if mem::size_of::<T>() == 0 {\n                 VecMutIterator{ptr: p,\n                                end: (p as uint + self.len()) as *mut T,\n                                lifetime: None}\n@@ -2054,7 +2054,7 @@ pub mod raw {\n     use clone::Clone;\n     use option::Some;\n     use ptr;\n-    use sys;\n+    use mem;\n     use unstable::intrinsics;\n     use vec::{with_capacity, ImmutableVector, MutableVector};\n     use unstable::intrinsics::contains_managed;\n@@ -2071,10 +2071,10 @@ pub mod raw {\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n         if contains_managed::<T>() {\n             let repr: **mut Box<Vec<()>> = cast::transmute(v);\n-            (**repr).data.fill = new_len * sys::nonzero_size_of::<T>();\n+            (**repr).data.fill = new_len * mem::nonzero_size_of::<T>();\n         } else {\n             let repr: **mut Vec<()> = cast::transmute(v);\n-            (**repr).fill = new_len * sys::nonzero_size_of::<T>();\n+            (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n         }\n     }\n \n@@ -2323,7 +2323,7 @@ macro_rules! iterator {\n                         None\n                     } else {\n                         let old = self.ptr;\n-                        self.ptr = if sys::size_of::<T>() == 0 {\n+                        self.ptr = if mem::size_of::<T>() == 0 {\n                             // purposefully don't use 'ptr.offset' because for\n                             // vectors with 0-size elements this would return the\n                             // same pointer.\n@@ -2340,7 +2340,7 @@ macro_rules! iterator {\n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 let diff = (self.end as uint) - (self.ptr as uint);\n-                let exact = diff / sys::nonzero_size_of::<T>();\n+                let exact = diff / mem::nonzero_size_of::<T>();\n                 (exact, Some(exact))\n             }\n         }\n@@ -2357,7 +2357,7 @@ macro_rules! double_ended_iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        self.end = if sys::size_of::<T>() == 0 {\n+                        self.end = if mem::size_of::<T>() == 0 {\n                             // See above for why 'ptr.offset' isn't used\n                             cast::transmute(self.end as uint - 1)\n                         } else {\n@@ -2497,7 +2497,7 @@ impl<A> Extendable<A> for ~[A] {\n #[cfg(test)]\n mod tests {\n     use option::{None, Option, Some};\n-    use sys;\n+    use mem;\n     use vec::*;\n     use cmp::*;\n     use prelude::*;\n@@ -2597,7 +2597,7 @@ mod tests {\n         let v0 : &[Z] = &[];\n         let v1 : &[Z] = &[[]];\n         let v2 : &[Z] = &[[], []];\n-        assert_eq!(sys::size_of::<Z>(), 0);\n+        assert_eq!(mem::size_of::<Z>(), 0);\n         assert_eq!(v0.len(), 0);\n         assert_eq!(v1.len(), 1);\n         assert_eq!(v2.len(), 2);"}, {"sha": "faced3531f582eb33550c38932546a4dded15868", "filename": "src/test/run-fail/bounds-check-no-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -11,7 +11,7 @@\n // error-pattern:index out of bounds: the len is 3 but the index is\n \n use std::uint::max_value;\n-use std::sys::size_of;\n+use std::mem::size_of;\n \n fn main() {\n     let xs = [1, 2, 3];"}, {"sha": "17b4c83788ca8362181a379d5089a2bbb78c22bb", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern:index out of bounds\n \n-use std::sys;\n+use std::mem;\n \n fn main() {\n \n@@ -23,12 +23,12 @@ fn main() {\n     let x = ~[1u,2u,3u];\n     do x.as_imm_buf |p, _len| {\n         let base = p as uint;\n-        let idx = base / sys::size_of::<uint>();\n+        let idx = base / mem::size_of::<uint>();\n         error2!(\"ov1 base = 0x{:x}\", base);\n         error2!(\"ov1 idx = 0x{:x}\", idx);\n-        error2!(\"ov1 sizeof::<uint>() = 0x{:x}\", sys::size_of::<uint>());\n+        error2!(\"ov1 sizeof::<uint>() = 0x{:x}\", mem::size_of::<uint>());\n         error2!(\"ov1 idx * sizeof::<uint>() = 0x{:x}\",\n-               idx * sys::size_of::<uint>());\n+               idx * mem::size_of::<uint>());\n \n         // This should fail.\n         error2!(\"ov1 0x{:x}\",  x[idx]);"}, {"sha": "48768a1c6fd27600f7c7707842d93a2bd3240162", "filename": "src/test/run-pass/attr-no-drop-flag-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::sys::size_of;\n+use std::mem::size_of;\n \n #[unsafe_no_drop_flag]\n struct Test<T> {"}, {"sha": "4c60cfb73281651f57c3d1007d45fb16ddada1ea", "filename": "src/test/run-pass/enum-alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-alignment.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -10,7 +10,7 @@\n \n use std::cast;\n use std::ptr;\n-use std::sys;\n+use std::mem;\n \n fn addr_of<T>(ptr: &T) -> uint {\n     let ptr = ptr::to_unsafe_ptr(ptr);\n@@ -20,7 +20,7 @@ fn addr_of<T>(ptr: &T) -> uint {\n fn is_aligned<T>(ptr: &T) -> bool {\n     unsafe {\n         let addr: uint = cast::transmute(ptr);\n-        (addr % sys::min_align_of::<T>()) == 0\n+        (addr % mem::min_align_of::<T>()) == 0\n     }\n }\n "}, {"sha": "65f93b1c3c2e0f4a92a7d4e0612e7386b913cc3a", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::sys;\n+use std::mem;\n \n pub fn main() {\n     enum E { V = 0x1717171717171717 }\n     static C: E = V;\n-    let expected: u64 = if sys::size_of::<uint>() < 8 {\n+    let expected: u64 = if mem::size_of::<uint>() < 8 {\n         0x17171717\n     } else {\n         0x1717171717171717"}, {"sha": "cdde98331e2d05859b27d3cf9511b89176ce3041", "filename": "src/test/run-pass/fn-bare-size.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Ffn-bare-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Ffn-bare-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-size.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::sys;\n+use std::mem;\n \n pub fn main() {\n     // Bare functions should just be a pointer\n-    assert_eq!(sys::size_of::<extern \"Rust\" fn()>(), sys::size_of::<int>());\n+    assert_eq!(mem::size_of::<extern \"Rust\" fn()>(), mem::size_of::<int>());\n }"}, {"sha": "1e1db3937801409a355fff44dd756f6f18415aa9", "filename": "src/test/run-pass/issue-2895.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fissue-2895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fissue-2895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2895.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::sys;\n+use std::mem;\n \n struct Cat {\n     x: int\n@@ -24,13 +24,13 @@ impl Drop for Kitty {\n \n #[cfg(target_arch = \"x86_64\")]\n pub fn main() {\n-    assert_eq!(sys::size_of::<Cat>(), 8 as uint);\n-    assert_eq!(sys::size_of::<Kitty>(), 16 as uint);\n+    assert_eq!(mem::size_of::<Cat>(), 8 as uint);\n+    assert_eq!(mem::size_of::<Kitty>(), 16 as uint);\n }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"arm\")]\n pub fn main() {\n-    assert_eq!(sys::size_of::<Cat>(), 4 as uint);\n-    assert_eq!(sys::size_of::<Kitty>(), 8 as uint);\n+    assert_eq!(mem::size_of::<Cat>(), 4 as uint);\n+    assert_eq!(mem::size_of::<Kitty>(), 8 as uint);\n }"}, {"sha": "228b91a4532cd939353cce92fd39632f43eebf84", "filename": "src/test/run-pass/nullable-pointer-size.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -10,7 +10,7 @@\n \n #[feature(macro_rules)];\n \n-use std::sys;\n+use std::mem;\n \n enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8, ..0]) }\n struct S<T>(int, T);\n@@ -19,13 +19,13 @@ struct S<T>(int, T);\n \n macro_rules! check_option {\n     ($T:ty) => {\n-        assert_eq!(sys::size_of::<Option<$T>>(), sys::size_of::<$T>());\n+        assert_eq!(mem::size_of::<Option<$T>>(), mem::size_of::<$T>());\n     }\n }\n \n macro_rules! check_fancy {\n     ($T:ty) => {\n-        assert_eq!(sys::size_of::<E<$T>>(), sys::size_of::<S<$T>>());\n+        assert_eq!(mem::size_of::<E<$T>>(), mem::size_of::<S<$T>>());\n     }\n }\n "}, {"sha": "1d3d8cf736f4d27c66c1a77b00896d2d27d8ad18", "filename": "src/test/run-pass/packed-struct-generic-size.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::sys;\n+use std::mem;\n \n #[packed]\n struct S<T, S> {\n@@ -18,10 +18,10 @@ struct S<T, S> {\n }\n \n pub fn main() {\n-    assert_eq!(sys::size_of::<S<u8, u8>>(), 3);\n+    assert_eq!(mem::size_of::<S<u8, u8>>(), 3);\n \n-    assert_eq!(sys::size_of::<S<u64, u16>>(), 11);\n+    assert_eq!(mem::size_of::<S<u64, u16>>(), 11);\n \n-    assert_eq!(sys::size_of::<S<~str, @mut [int]>>(),\n-               1 + sys::size_of::<~str>() + sys::size_of::<@mut [int]>());\n+    assert_eq!(mem::size_of::<S<~str, @mut [int]>>(),\n+               1 + mem::size_of::<~str>() + mem::size_of::<@mut [int]>());\n }"}, {"sha": "5b4426d314b5553481625a2d820b8ac1ae1f39a3", "filename": "src/test/run-pass/packed-struct-size-xc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -3,8 +3,8 @@\n \n extern mod packed;\n \n-use std::sys;\n+use std::mem;\n \n fn main() {\n-    assert_eq!(sys::size_of::<packed::S>(), 5);\n+    assert_eq!(mem::size_of::<packed::S>(), 5);\n }"}, {"sha": "cc4cb99e2f6610cb2d64c5b3a39bb3961d4d2dea", "filename": "src/test/run-pass/packed-struct-size.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::sys;\n+use std::mem;\n \n #[packed]\n struct S4 {\n@@ -57,9 +57,9 @@ static TEST_S3_Foo: S3_Foo = S3_Foo { a: 1, b: 2, c: Baz };\n \n \n pub fn main() {\n-    assert_eq!(sys::size_of::<S4>(), 4);\n-    assert_eq!(sys::size_of::<S5>(), 5);\n-    assert_eq!(sys::size_of::<S13_str>(), 13 + sys::size_of::<~str>());\n-    assert_eq!(sys::size_of::<S3_Foo>(), 3 + sys::size_of::<Foo>());\n-    assert_eq!(sys::size_of::<S7_Option>(), 7 + sys::size_of::<Option<@mut f64>>());\n+    assert_eq!(mem::size_of::<S4>(), 4);\n+    assert_eq!(mem::size_of::<S5>(), 5);\n+    assert_eq!(mem::size_of::<S13_str>(), 13 + mem::size_of::<~str>());\n+    assert_eq!(mem::size_of::<S3_Foo>(), 3 + mem::size_of::<Foo>());\n+    assert_eq!(mem::size_of::<S7_Option>(), 7 + mem::size_of::<Option<@mut f64>>());\n }"}, {"sha": "6007cc251c9d51afa52a36471bd15187346d6c66", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-android: FIXME(#9116) Bus error\n \n-use std::sys;\n+use std::mem;\n \n #[packed]\n #[deriving(Eq)]\n@@ -22,7 +22,7 @@ struct Foo {\n pub fn main() {\n     let foos = [Foo { bar: 1, baz: 2 }, .. 10];\n \n-    assert_eq!(sys::size_of::<[Foo, .. 10]>(), 90);\n+    assert_eq!(mem::size_of::<[Foo, .. 10]>(), 90);\n \n     for i in range(0u, 10) {\n         assert_eq!(foos[i], Foo { bar: 1, baz: 2});"}, {"sha": "76362ffeaaf17cc0f6da18c3b7a4d39987b3f991", "filename": "src/test/run-pass/packed-tuple-struct-size.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::sys;\n+use std::mem;\n \n #[packed]\n struct S4(u8,[u8, .. 3]);\n@@ -31,16 +31,16 @@ struct S3_Foo(u8, u16, Foo);\n struct S7_Option(f32, u8, u16, Option<@mut f64>);\n \n pub fn main() {\n-    assert_eq!(sys::size_of::<S4>(), 4);\n+    assert_eq!(mem::size_of::<S4>(), 4);\n \n-    assert_eq!(sys::size_of::<S5>(), 5);\n+    assert_eq!(mem::size_of::<S5>(), 5);\n \n-    assert_eq!(sys::size_of::<S13_str>(),\n-               13 + sys::size_of::<~str>());\n+    assert_eq!(mem::size_of::<S13_str>(),\n+               13 + mem::size_of::<~str>());\n \n-    assert_eq!(sys::size_of::<S3_Foo>(),\n-               3 + sys::size_of::<Foo>());\n+    assert_eq!(mem::size_of::<S3_Foo>(),\n+               3 + mem::size_of::<Foo>());\n \n-    assert_eq!(sys::size_of::<S7_Option>(),\n-              7 + sys::size_of::<Option<@mut f64>>());\n+    assert_eq!(mem::size_of::<S7_Option>(),\n+              7 + mem::size_of::<Option<@mut f64>>());\n }"}, {"sha": "43304b66176dcd8a194a7993b2e51b5f7ef6d26c", "filename": "src/test/run-pass/rec-align-u32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u32.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -12,7 +12,7 @@\n \n // Issue #2303\n \n-use std::sys;\n+use std::mem;\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n@@ -55,15 +55,15 @@ pub fn main() {\n         let y = format!(\"{:?}\", x);\n \n         info2!(\"align inner = {:?}\", rusti::min_align_of::<Inner>());\n-        info2!(\"size outer = {:?}\", sys::size_of::<Outer>());\n+        info2!(\"size outer = {:?}\", mem::size_of::<Outer>());\n         info2!(\"y = {}\", y);\n \n         // per clang/gcc the alignment of `inner` is 4 on x86.\n         assert_eq!(rusti::min_align_of::<Inner>(), m::align());\n \n         // per clang/gcc the size of `outer` should be 12\n         // because `inner`s alignment was 4.\n-        assert_eq!(sys::size_of::<Outer>(), m::size());\n+        assert_eq!(mem::size_of::<Outer>(), m::size());\n \n         assert_eq!(y, ~\"Outer{c8: 22u8, t: Inner{c64: 44u32}}\");\n     }"}, {"sha": "5adb8cf951050b096fed1a39e0d1a11c6666a7ae", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -12,7 +12,7 @@\n \n // Issue #2303\n \n-use std::sys;\n+use std::mem;\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n@@ -77,15 +77,15 @@ pub fn main() {\n         let y = format!(\"{:?}\", x);\n \n         info2!(\"align inner = {}\", rusti::min_align_of::<Inner>());\n-        info2!(\"size outer = {}\", sys::size_of::<Outer>());\n+        info2!(\"size outer = {}\", mem::size_of::<Outer>());\n         info2!(\"y = {}\", y);\n \n         // per clang/gcc the alignment of `Inner` is 4 on x86.\n         assert_eq!(rusti::min_align_of::<Inner>(), m::m::align());\n \n         // per clang/gcc the size of `Outer` should be 12\n         // because `Inner`s alignment was 4.\n-        assert_eq!(sys::size_of::<Outer>(), m::m::size());\n+        assert_eq!(mem::size_of::<Outer>(), m::m::size());\n \n         assert_eq!(y, ~\"Outer{c8: 22u8, t: Inner{c64: 44u64}}\");\n     }"}, {"sha": "5a2243b19408836f7647a4ad0602d16a9b34a41f", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -12,7 +12,7 @@\n \n use std::libc::c_void;\n use std::ptr;\n-use std::sys;\n+use std::mem;\n use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Opaque};\n use std::unstable::raw::Vec;\n \n@@ -49,12 +49,12 @@ impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n \n     #[inline(always)]\n     pub fn align_to<T>(&mut self) {\n-        self.align(sys::min_align_of::<T>());\n+        self.align(mem::min_align_of::<T>());\n     }\n \n     #[inline(always)]\n     pub fn bump_past<T>(&mut self) {\n-        self.bump(sys::size_of::<T>());\n+        self.bump(mem::size_of::<T>());\n     }\n \n }"}, {"sha": "e66a34b47bce044aa8faaba445120a485107ff5d", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -10,7 +10,7 @@\n \n use std::cast;\n use std::libc;\n-use std::sys;\n+use std::mem;\n \n struct arena(());\n \n@@ -30,7 +30,7 @@ struct Ccx {\n #[fixed_stack_segment] #[inline(never)]\n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n-        cast::transmute(libc::malloc(sys::size_of::<Bcx<'blk>>()\n+        cast::transmute(libc::malloc(mem::size_of::<Bcx<'blk>>()\n             as libc::size_t))\n     }\n }"}, {"sha": "2cdff23050db31ed859acc8e08ccc361df8c2c65", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=d8d1b8f8be250b9e19bb70aa0968c1b4a4aec2f8", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern mod std;\n-use std::sys::size_of;\n+use std::mem::size_of;\n \n struct t {a: u8, b: i8}\n struct u {a: u8, b: i8, c: u8}"}]}