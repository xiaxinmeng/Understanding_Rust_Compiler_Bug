{"sha": "c44267960f4642a1875de9e39ef7287961c56d3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NDI2Nzk2MGY0NjQyYTE4NzVkZTllMzllZjcyODc5NjFjNTZkM2E=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-28T16:13:58Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-30T08:46:09Z"}, "message": "ptr equality: only defined for ptrs in the same allocation and live ptrs", "tree": {"sha": "1055cf0ed6e0aef22578b078b9e28afb295883c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1055cf0ed6e0aef22578b078b9e28afb295883c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c44267960f4642a1875de9e39ef7287961c56d3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c44267960f4642a1875de9e39ef7287961c56d3a", "html_url": "https://github.com/rust-lang/rust/commit/c44267960f4642a1875de9e39ef7287961c56d3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c44267960f4642a1875de9e39ef7287961c56d3a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e239fcffc1a211ff3f2f7dce4d084615aaa73715", "url": "https://api.github.com/repos/rust-lang/rust/commits/e239fcffc1a211ff3f2f7dce4d084615aaa73715", "html_url": "https://github.com/rust-lang/rust/commit/e239fcffc1a211ff3f2f7dce4d084615aaa73715"}], "stats": {"total": 186, "additions": 87, "deletions": 99}, "files": [{"sha": "1b877256c31fac99ca777a6231d6a1935b27265b", "filename": "src/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c44267960f4642a1875de9e39ef7287961c56d3a/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44267960f4642a1875de9e39ef7287961c56d3a/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=c44267960f4642a1875de9e39ef7287961c56d3a", "patch": "@@ -116,11 +116,11 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n-                let expect_old = self.read_value(args[1])?; // read as value for the sake of `binary_op()`\n+                let expect_old = self.read_value(args[1])?; // read as value for the sake of `binary_op_val()`\n                 let new = self.read_scalar(args[2])?;\n-                let old = self.read_value(ptr.into())?; // read as value for the sake of `binary_op()`\n-                // binary_op will bail if either of them is not a scalar\n-                let (eq, _) = self.binary_op(mir::BinOp::Eq, old, expect_old)?;\n+                let old = self.read_value(ptr.into())?; // read as value for the sake of `binary_op_val()`\n+                // binary_op_val will bail if either of them is not a scalar\n+                let (eq, _) = self.binary_op_val(mir::BinOp::Eq, old, expect_old)?;\n                 let res = Value::ScalarPair(old.to_scalar_or_undef(), eq.into());\n                 self.write_value(res, dest)?; // old value is returned\n                 // update ptr depending on comparison\n@@ -167,8 +167,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     _ => bug!(),\n                 };\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = self.binary_op(op, old, rhs)?;\n-                self.write_scalar(val, ptr.into())?;\n+                self.binop_ignore_overflow(op, old, rhs, ptr.into())?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -255,8 +254,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     \"frem_fast\" => mir::BinOp::Rem,\n                     _ => bug!(),\n                 };\n-                let result = self.binary_op(op, a, b)?;\n-                self.write_scalar(result.0, dest)?;\n+                self.binop_ignore_overflow(op, a, b, dest)?;\n             }\n \n             \"exact_div\" => {\n@@ -265,11 +263,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let a = self.read_value(args[0])?;\n                 let b = self.read_value(args[1])?;\n                 // check x % y != 0\n-                if !self.binary_op(mir::BinOp::Rem, a, b)?.0.is_null() {\n+                if !self.binary_op_val(mir::BinOp::Rem, a, b)?.0.is_null() {\n                     return err!(ValidationFailure(format!(\"exact_div: {:?} cannot be divided by {:?}\", a, b)));\n                 }\n-                let result = self.binary_op(mir::BinOp::Div, a, b)?;\n-                self.write_scalar(result.0, dest)?;\n+                self.binop_ignore_overflow(mir::BinOp::Div, a, b, dest)?;\n             },\n \n             \"likely\" | \"unlikely\" | \"forget\" => {}"}, {"sha": "b8d3c18c01cba4a8b69856e427c29c9f5bed9d63", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c44267960f4642a1875de9e39ef7287961c56d3a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44267960f4642a1875de9e39ef7287961c56d3a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c44267960f4642a1875de9e39ef7287961c56d3a", "patch": "@@ -304,14 +304,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.call_intrinsic(instance, args, dest)\n     }\n \n-    fn try_ptr_op<'a>(\n+    fn ptr_op<'a>(\n         ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: Scalar,\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n         ecx.ptr_op(bin_op, left, left_layout, right, right_layout)\n     }\n "}, {"sha": "550e7014afa975d3c16d5e1d54aec859199ab296", "filename": "src/operator.rs", "status": "modified", "additions": 75, "deletions": 82, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c44267960f4642a1875de9e39ef7287961c56d3a/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44267960f4642a1875de9e39ef7287961c56d3a/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=c44267960f4642a1875de9e39ef7287961c56d3a", "patch": "@@ -1,5 +1,4 @@\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{TyLayout, Primitive};\n+use rustc::ty::{Ty, layout::TyLayout};\n use rustc::mir;\n \n use super::*;\n@@ -12,7 +11,7 @@ pub trait EvalContextExt<'tcx> {\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n+    ) -> EvalResult<'tcx, (Scalar, bool)>;\n \n     fn ptr_int_arithmetic(\n         &self,\n@@ -22,6 +21,13 @@ pub trait EvalContextExt<'tcx> {\n         signed: bool,\n     ) -> EvalResult<'tcx, (Scalar, bool)>;\n \n+    fn ptr_eq(\n+        &self,\n+        left: Scalar,\n+        right: Scalar,\n+        size: Size,\n+    ) -> EvalResult<'tcx, bool>;\n+\n     fn pointer_offset_inbounds(\n         &self,\n         ptr: Scalar,\n@@ -38,131 +44,118 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        use rustc::mir::BinOp::*;\n+\n         trace!(\"ptr_op: {:?} {:?} {:?}\", left, bin_op, right);\n+        debug_assert!(left.is_ptr() || right.is_ptr() || bin_op == Offset);\n \n-        use rustc::mir::BinOp::*;\n-        use rustc::ty::layout::Integer::*;\n-        let usize = Primitive::Int(match self.memory.pointer_size().bytes() {\n-            1 => I8,\n-            2 => I16,\n-            4 => I32,\n-            8 => I64,\n-            16 => I128,\n-            _ => unreachable!(),\n-        }, /*signed*/ false);\n-        let isize = Primitive::Int(match self.memory.pointer_size().bytes() {\n-            1 => I8,\n-            2 => I16,\n-            4 => I32,\n-            8 => I64,\n-            16 => I128,\n-            _ => unreachable!(),\n-        }, /*signed*/ true);\n-        let left_kind = match left_layout.abi {\n-            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => Err(EvalErrorKind::TypeNotPrimitive(left_layout.ty))?,\n-        };\n-        let right_kind = match right_layout.abi {\n-            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => Err(EvalErrorKind::TypeNotPrimitive(right_layout.ty))?,\n-        };\n         match bin_op {\n             Offset => {\n-                assert!(left_kind == Primitive::Pointer && right_kind == usize);\n                 let pointee_ty = left_layout.ty\n                     .builtin_deref(true)\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset_inbounds(\n                     left,\n                     pointee_ty,\n-                    right.to_bits(self.memory.pointer_size())? as i64,\n+                    right.to_isize(self)?,\n                 )?;\n-                Ok(Some((ptr, false)))\n+                Ok((ptr, false))\n             }\n             // These work on anything\n-            Eq if left_kind == right_kind => {\n-                let result = match (left, right) {\n-                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n-                        left.to_bits(left_layout.size)? == right.to_bits(right_layout.size)?\n-                    },\n-                    // FIXME: Test if both allocations are still live *or* if they are in the same allocation? (same for Ne below)\n-                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left == right,\n-                    // FIXME: We should probably error out when comparing anything but NULL with a pointer (same for Ne below)\n-                    _ => false,\n-                };\n-                Ok(Some((Scalar::from_bool(result), false)))\n-            }\n-            Ne if left_kind == right_kind => {\n-                let result = match (left, right) {\n-                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n-                        left.to_bits(left_layout.size)? != right.to_bits(right_layout.size)?\n-                    },\n-                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left != right,\n-                    _ => true,\n-                };\n-                Ok(Some((Scalar::from_bool(result), false)))\n-            }\n-            // These need both pointers to be in the same allocation\n-            Lt | Le | Gt | Ge | Sub\n-                if left_kind == right_kind &&\n-                       (left_kind == Primitive::Pointer || left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_ptr() => {\n-                let left = left.to_ptr()?;\n-                let right = right.to_ptr()?;\n+            Eq =>\n+                Ok((Scalar::from_bool(self.ptr_eq(left, right, left_layout.size)?), false)),\n+            Ne =>\n+                Ok((Scalar::from_bool(!self.ptr_eq(left, right, left_layout.size)?), false)),\n+            // These need both to be pointer, and fail if they are not in the same location\n+            Lt | Le | Gt | Ge | Sub if left.is_ptr() && right.is_ptr() => {\n+                let left = left.to_ptr().expect(\"we checked is_ptr\");\n+                let right = right.to_ptr().expect(\"we checked is_ptr\");\n                 if left.alloc_id == right.alloc_id {\n                     let res = match bin_op {\n                         Lt => left.offset < right.offset,\n                         Le => left.offset <= right.offset,\n                         Gt => left.offset > right.offset,\n                         Ge => left.offset >= right.offset,\n                         Sub => {\n+                            // subtract the offsets\n                             let left_offset = Scalar::from_uint(left.offset.bytes(), self.memory.pointer_size());\n                             let right_offset = Scalar::from_uint(right.offset.bytes(), self.memory.pointer_size());\n                             let layout = self.layout_of(self.tcx.types.usize)?;\n                             return self.binary_op(\n                                 Sub,\n-                                ValTy { value: Value::Scalar(left_offset.into()), layout },\n-                                ValTy { value: Value::Scalar(right_offset.into()), layout },\n-                            ).map(Some)\n+                                left_offset, layout,\n+                                right_offset, layout,\n+                            )\n                         }\n                         _ => bug!(\"We already established it has to be one of these operators.\"),\n                     };\n-                    Ok(Some((Scalar::from_bool(res), false)))\n+                    Ok((Scalar::from_bool(res), false))\n                 } else {\n                     // Both are pointers, but from different allocations.\n                     err!(InvalidPointerMath)\n                 }\n             }\n-            // These work if the left operand is a pointer, the right an integer\n-            Add | BitAnd | Sub | Rem\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_bits() => {\n+            // These work if the left operand is a pointer, and the right an integer\n+            Add | BitAnd | Sub | Rem if left.is_ptr() && right.is_bits() => {\n                 // Cast to i128 is fine as we checked the kind to be ptr-sized\n                 self.ptr_int_arithmetic(\n                     bin_op,\n-                    left.to_ptr()?,\n-                    right.to_bits(self.memory.pointer_size())?,\n-                    left_kind == isize,\n-                ).map(Some)\n+                    left.to_ptr().expect(\"we checked is_ptr\"),\n+                    right.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    right_layout.abi.is_signed(),\n+                )\n             }\n             // Commutative operators also work if the integer is on the left\n-            Add | BitAnd\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_bits() && right.is_ptr() => {\n+            Add | BitAnd if left.is_bits() && right.is_ptr() => {\n                 // This is a commutative operation, just swap the operands\n                 self.ptr_int_arithmetic(\n                     bin_op,\n-                    right.to_ptr()?,\n-                    left.to_bits(self.memory.pointer_size())?,\n-                    left_kind == isize,\n-                ).map(Some)\n+                    right.to_ptr().expect(\"we checked is_ptr\"),\n+                    left.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    left_layout.abi.is_signed(),\n+                )\n             }\n-            _ => Ok(None),\n+            // Nothing else works\n+            _ => err!(InvalidPointerMath),\n         }\n     }\n \n+    fn ptr_eq(\n+        &self,\n+        left: Scalar,\n+        right: Scalar,\n+        size: Size,\n+    ) -> EvalResult<'tcx, bool> {\n+        Ok(match (left, right) {\n+            (Scalar::Bits { .. }, Scalar::Bits { .. }) =>\n+                left.to_bits(size)? == right.to_bits(size)?,\n+            (Scalar::Ptr(left), Scalar::Ptr(right)) => {\n+                // Comparison illegal if one of them is out-of-bounds, *unless* they\n+                // are in the same allocation.\n+                if left.alloc_id == right.alloc_id {\n+                    left.offset == right.offset\n+                } else {\n+                    // This accepts one-past-the end.  So technically there is still\n+                    // some non-determinism that we do not fully rule out when two\n+                    // allocations sit right next to each other.  The C/C++ standards are\n+                    // somewhat fuzzy about this case, so I think for now this check is\n+                    // \"good enough\".\n+                    self.memory.check_bounds(left, false)?;\n+                    self.memory.check_bounds(right, false)?;\n+                    // Two live in-bounds pointers, we can compare across allocations\n+                    left == right\n+                }\n+            }\n+            // Comparing ptr and integer -- we only allow compating with NULL\n+            (Scalar::Ptr(_), Scalar::Bits { bits: 0, .. }) |\n+            (Scalar::Bits { bits: 0, .. }, Scalar::Ptr(_)) => false,\n+            // Nothing else is supported\n+            _ => return err!(InvalidPointerMath),\n+        })\n+    }\n+\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "b25f09d485fb39e2a1800e37c4d4593468258295", "filename": "tests/compile-fail/pointer_byte_read_1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c44267960f4642a1875de9e39ef7287961c56d3a/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44267960f4642a1875de9e39ef7287961c56d3a/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs?ref=c44267960f4642a1875de9e39ef7287961c56d3a", "patch": "@@ -3,6 +3,5 @@ fn main() {\n     let y = &x;\n     let z = &y as *const &i32 as *const usize;\n     let ptr_bytes = unsafe { *z }; // the actual deref is fine, because we read the entire pointer at once\n-    let _ = ptr_bytes / 432; //~ ERROR constant evaluation error\n-    //~^ NOTE tried to access part of a pointer value as raw bytes\n+    let _ = ptr_bytes / 432; //~ ERROR invalid arithmetic on pointers that would leak base addresses\n }"}, {"sha": "2706b0970d7d586212d8c1e6d1e97212ec61332f", "filename": "tests/compile-fail/ptr_bitops.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c44267960f4642a1875de9e39ef7287961c56d3a/tests%2Fcompile-fail%2Fptr_bitops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44267960f4642a1875de9e39ef7287961c56d3a/tests%2Fcompile-fail%2Fptr_bitops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops.rs?ref=c44267960f4642a1875de9e39ef7287961c56d3a", "patch": "@@ -2,7 +2,6 @@ fn main() {\n     let bytes = [0i8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let one = bytes.as_ptr().wrapping_offset(1);\n     let three = bytes.as_ptr().wrapping_offset(3);\n-    let res = (one as usize) | (three as usize); //~ ERROR constant evaluation error\n-    //~^ NOTE a raw memory access tried to access part of a pointer value as raw bytes\n+    let res = (one as usize) | (three as usize); //~ ERROR invalid arithmetic on pointers that would leak base addresses\n     println!(\"{}\", res);\n }"}]}