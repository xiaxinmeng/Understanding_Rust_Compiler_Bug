{"sha": "7426f5ccf7b362785a5abeb365674d3da3d4df2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MjZmNWNjZjdiMzYyNzg1YTVhYmViMzY1Njc0ZDNkYTNkNGRmMmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-24T07:14:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-24T07:14:21Z"}, "message": "Auto merge of #50971 - alexcrichton:no-stringify, r=petrochenkov\n\nrustc: Correctly pretty-print macro delimiters\n\nThis commit updates the `Mac_` AST structure to keep track of the delimiters\nthat it originally had for its invocation. This allows us to faithfully\npretty-print macro invocations not using parentheses (e.g. `vec![...]`). This in\nturn helps procedural macros due to #43081.\n\nCloses #50840", "tree": {"sha": "34352c2086a16c38dff8879a915d7d158f909b20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34352c2086a16c38dff8879a915d7d158f909b20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7426f5ccf7b362785a5abeb365674d3da3d4df2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7426f5ccf7b362785a5abeb365674d3da3d4df2e", "html_url": "https://github.com/rust-lang/rust/commit/7426f5ccf7b362785a5abeb365674d3da3d4df2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7426f5ccf7b362785a5abeb365674d3da3d4df2e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4463d788bfd30b622a87a0e6f8e9271b9102e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4463d788bfd30b622a87a0e6f8e9271b9102e50", "html_url": "https://github.com/rust-lang/rust/commit/b4463d788bfd30b622a87a0e6f8e9271b9102e50"}, {"sha": "a137d00ce52e9db78bb803d1384fdf3a4c4e63ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/a137d00ce52e9db78bb803d1384fdf3a4c4e63ea", "html_url": "https://github.com/rust-lang/rust/commit/a137d00ce52e9db78bb803d1384fdf3a4c4e63ea"}], "stats": {"total": 238, "additions": 156, "deletions": 82}, "files": [{"sha": "bd631379120eb253298fb9f6df932d603006ab13", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7426f5ccf7b362785a5abeb365674d3da3d4df2e", "patch": "@@ -1244,9 +1244,17 @@ pub type Mac = Spanned<Mac_>;\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mac_ {\n     pub path: Path,\n+    pub delim: MacDelimiter,\n     pub tts: ThinTokenStream,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum MacDelimiter {\n+    Parenthesis,\n+    Bracket,\n+    Brace,\n+}\n+\n impl Mac_ {\n     pub fn stream(&self) -> TokenStream {\n         self.tts.clone().into()"}, {"sha": "5c1c661fffd378cebd212feca0276f309b1e3135", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=7426f5ccf7b362785a5abeb365674d3da3d4df2e", "patch": "@@ -27,6 +27,7 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n         dummy_spanned(ast::Mac_ {\n             path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n             tts: TokenStream::empty().into(),\n+            delim: ast::MacDelimiter::Brace,\n         })\n     }\n "}, {"sha": "1e5c6a6866bd9a92c0aa3eb96714941d0a33e702", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7426f5ccf7b362785a5abeb365674d3da3d4df2e", "patch": "@@ -521,6 +521,7 @@ pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n         node: Mac_ {\n             tts: fld.fold_tts(node.stream()).into(),\n             path: fld.fold_path(node.path),\n+            delim: node.delim,\n         },\n         span: fld.new_span(span)\n     }"}, {"sha": "9b9fcfa74b16f698a918d81a7e96644b43a467e8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7426f5ccf7b362785a5abeb365674d3da3d4df2e", "patch": "@@ -26,7 +26,7 @@ use ast::{Ident, ImplItem, IsAuto, Item, ItemKind};\n use ast::{Label, Lifetime, LifetimeDef, Lit, LitKind, UintTy};\n use ast::Local;\n use ast::MacStmtStyle;\n-use ast::{Mac, Mac_};\n+use ast::{Mac, Mac_, MacDelimiter};\n use ast::{MutTy, Mutability};\n use ast::{Pat, PatKind, PathSegment};\n use ast::{PolyTraitRef, QSelf};\n@@ -1611,8 +1611,9 @@ impl<'a> Parser<'a> {\n             let path = self.parse_path(PathStyle::Type)?;\n             if self.eat(&token::Not) {\n                 // Macro invocation in type position\n-                let (_, tts) = self.expect_delimited_token_tree()?;\n-                TyKind::Mac(respan(lo.to(self.prev_span), Mac_ { path: path, tts: tts }))\n+                let (delim, tts) = self.expect_delimited_token_tree()?;\n+                let node = Mac_ { path, tts, delim };\n+                TyKind::Mac(respan(lo.to(self.prev_span), node))\n             } else {\n                 // Just a type path or bound list (trait object type) starting with a trait.\n                 //   `Type`\n@@ -2195,19 +2196,27 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn expect_delimited_token_tree(&mut self) -> PResult<'a, (token::DelimToken, ThinTokenStream)> {\n-        match self.token {\n-            token::OpenDelim(delim) => match self.parse_token_tree() {\n-                TokenTree::Delimited(_, delimited) => Ok((delim, delimited.stream().into())),\n-                _ => unreachable!(),\n-            },\n+    fn expect_delimited_token_tree(&mut self) -> PResult<'a, (MacDelimiter, ThinTokenStream)> {\n+        let delim = match self.token {\n+            token::OpenDelim(delim) => delim,\n             _ => {\n                 let msg = \"expected open delimiter\";\n                 let mut err = self.fatal(msg);\n                 err.span_label(self.span, msg);\n-                Err(err)\n+                return Err(err)\n             }\n-        }\n+        };\n+        let delimited = match self.parse_token_tree() {\n+            TokenTree::Delimited(_, delimited) => delimited,\n+            _ => unreachable!(),\n+        };\n+        let delim = match delim {\n+            token::Paren => MacDelimiter::Parenthesis,\n+            token::Bracket => MacDelimiter::Bracket,\n+            token::Brace => MacDelimiter::Brace,\n+            token::NoDelim => self.bug(\"unexpected no delimiter\"),\n+        };\n+        Ok((delim, delimited.stream().into()))\n     }\n \n     /// At the bottom (top?) of the precedence hierarchy,\n@@ -2420,9 +2429,10 @@ impl<'a> Parser<'a> {\n                     // `!`, as an operator, is prefix, so we know this isn't that\n                     if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n-                        let (_, tts) = self.expect_delimited_token_tree()?;\n+                        let (delim, tts) = self.expect_delimited_token_tree()?;\n                         let hi = self.prev_span;\n-                        return Ok(self.mk_mac_expr(lo.to(hi), Mac_ { path: pth, tts: tts }, attrs));\n+                        let node = Mac_ { path: pth, tts, delim };\n+                        return Ok(self.mk_mac_expr(lo.to(hi), node, attrs))\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n@@ -3895,8 +3905,8 @@ impl<'a> Parser<'a> {\n                     token::Not if qself.is_none() => {\n                         // Parse macro invocation\n                         self.bump();\n-                        let (_, tts) = self.expect_delimited_token_tree()?;\n-                        let mac = respan(lo.to(self.prev_span), Mac_ { path: path, tts: tts });\n+                        let (delim, tts) = self.expect_delimited_token_tree()?;\n+                        let mac = respan(lo.to(self.prev_span), Mac_ { path, tts, delim });\n                         pat = PatKind::Mac(mac);\n                     }\n                     token::DotDotDot | token::DotDotEq | token::DotDot => {\n@@ -4289,7 +4299,7 @@ impl<'a> Parser<'a> {\n \n                 let ident = self.parse_ident()?;\n                 let (delim, tokens) = self.expect_delimited_token_tree()?;\n-                if delim != token::Brace {\n+                if delim != MacDelimiter::Brace {\n                     if !self.eat(&token::Semi) {\n                         let msg = \"macros that expand to items must either \\\n                                    be surrounded with braces or followed by a semicolon\";\n@@ -4374,8 +4384,8 @@ impl<'a> Parser<'a> {\n             // check that we're pointing at delimiters (need to check\n             // again after the `if`, because of `parse_ident`\n             // consuming more tokens).\n-            let delim = match self.token {\n-                token::OpenDelim(delim) => delim,\n+            match self.token {\n+                token::OpenDelim(_) => {}\n                 _ => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n@@ -4391,20 +4401,20 @@ impl<'a> Parser<'a> {\n                     err.span_label(self.span, format!(\"expected {}`(` or `{{`\", ident_str));\n                     return Err(err)\n                 },\n-            };\n+            }\n \n-            let (_, tts) = self.expect_delimited_token_tree()?;\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n             let hi = self.prev_span;\n \n-            let style = if delim == token::Brace {\n+            let style = if delim == MacDelimiter::Brace {\n                 MacStmtStyle::Braces\n             } else {\n                 MacStmtStyle::NoBraces\n             };\n \n             if id.name == keywords::Invalid.name() {\n-                let mac = respan(lo.to(hi), Mac_ { path: pth, tts: tts });\n-                let node = if delim == token::Brace ||\n+                let mac = respan(lo.to(hi), Mac_ { path: pth, tts, delim });\n+                let node = if delim == MacDelimiter::Brace ||\n                               self.token == token::Semi || self.token == token::Eof {\n                     StmtKind::Mac(P((mac, style, attrs.into())))\n                 }\n@@ -4452,7 +4462,7 @@ impl<'a> Parser<'a> {\n                     node: StmtKind::Item({\n                         self.mk_item(\n                             span, id /*id is good here*/,\n-                            ItemKind::Mac(respan(span, Mac_ { path: pth, tts: tts })),\n+                            ItemKind::Mac(respan(span, Mac_ { path: pth, tts, delim })),\n                             respan(lo, VisibilityKind::Inherited),\n                             attrs)\n                     }),\n@@ -6894,7 +6904,7 @@ impl<'a> Parser<'a> {\n             };\n             // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != token::Brace {\n+            if delim != MacDelimiter::Brace {\n                 if !self.eat(&token::Semi) {\n                     self.span_err(self.prev_span,\n                                   \"macros that expand to items must either \\\n@@ -6904,7 +6914,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let hi = self.prev_span;\n-            let mac = respan(mac_lo.to(hi), Mac_ { path: pth, tts: tts });\n+            let mac = respan(mac_lo.to(hi), Mac_ { path: pth, tts, delim });\n             let item = self.mk_item(lo.to(hi), id, ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n         }\n@@ -6948,11 +6958,11 @@ impl<'a> Parser<'a> {\n \n             // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != token::Brace {\n+            if delim != MacDelimiter::Brace {\n                 self.expect(&token::Semi)?\n             }\n \n-            Ok(Some(respan(lo.to(self.prev_span), Mac_ { path: pth, tts: tts })))\n+            Ok(Some(respan(lo.to(self.prev_span), Mac_ { path: pth, tts, delim })))\n         } else {\n             Ok(None)\n         }"}, {"sha": "585d49d7076c48b297fba5c5afa4b4ed52ab606b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 50, "deletions": 54, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7426f5ccf7b362785a5abeb365674d3da3d4df2e", "patch": "@@ -13,7 +13,7 @@ pub use self::AnnNode::*;\n use rustc_target::spec::abi::{self, Abi};\n use ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::Attribute;\n+use ast::{Attribute, MacDelimiter};\n use util::parser::{self, AssocOp, Fixity};\n use attr;\n use codemap::{self, CodeMap};\n@@ -422,7 +422,7 @@ pub fn arg_to_string(arg: &ast::Arg) -> String {\n }\n \n pub fn mac_to_string(arg: &ast::Mac) -> String {\n-    to_string(|s| s.print_mac(arg, ::parse::token::Paren))\n+    to_string(|s| s.print_mac(arg))\n }\n \n pub fn foreign_item_to_string(arg: &ast::ForeignItem) -> String {\n@@ -1098,7 +1098,7 @@ impl<'a> State<'a> {\n                 self.s.word(\"Self\")?;\n             }\n             ast::TyKind::Mac(ref m) => {\n-                self.print_mac(m, token::Paren)?;\n+                self.print_mac(m)?;\n             }\n         }\n         self.end()\n@@ -1140,8 +1140,11 @@ impl<'a> State<'a> {\n                 self.end() // end the outer cbox\n             }\n             ast::ForeignItemKind::Macro(ref m) => {\n-                self.print_mac(m, token::Paren)?;\n-                self.s.word(\";\")\n+                self.print_mac(m)?;\n+                match m.node.delim {\n+                    MacDelimiter::Brace => Ok(()),\n+                    _ => self.s.word(\";\")\n+                }\n             }\n         }\n     }\n@@ -1394,16 +1397,24 @@ impl<'a> State<'a> {\n                 self.print_where_clause(&generics.where_clause)?;\n                 self.s.word(\";\")?;\n             }\n-            ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n-                self.print_path(&node.path, false, 0)?;\n-                self.s.word(\"! \")?;\n-                self.print_ident(item.ident)?;\n-                self.cbox(INDENT_UNIT)?;\n-                self.popen()?;\n-                self.print_tts(node.stream())?;\n-                self.pclose()?;\n-                self.s.word(\";\")?;\n-                self.end()?;\n+            ast::ItemKind::Mac(ref mac) => {\n+                if item.ident.name == keywords::Invalid.name() {\n+                    self.print_mac(mac)?;\n+                    match mac.node.delim {\n+                        MacDelimiter::Brace => {}\n+                        _ => self.s.word(\";\")?,\n+                    }\n+                } else {\n+                    self.print_path(&mac.node.path, false, 0)?;\n+                    self.s.word(\"! \")?;\n+                    self.print_ident(item.ident)?;\n+                    self.cbox(INDENT_UNIT)?;\n+                    self.popen()?;\n+                    self.print_tts(mac.node.stream())?;\n+                    self.pclose()?;\n+                    self.s.word(\";\")?;\n+                    self.end()?;\n+                }\n             }\n             ast::ItemKind::MacroDef(ref tts) => {\n                 self.s.word(\"macro_rules! \")?;\n@@ -1609,16 +1620,12 @@ impl<'a> State<'a> {\n                 self.print_associated_type(ti.ident, Some(bounds),\n                                            default.as_ref().map(|ty| &**ty))?;\n             }\n-            ast::TraitItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n-                // code copied from ItemKind::Mac:\n-                self.print_path(&node.path, false, 0)?;\n-                self.s.word(\"! \")?;\n-                self.cbox(INDENT_UNIT)?;\n-                self.popen()?;\n-                self.print_tts(node.stream())?;\n-                self.pclose()?;\n-                self.s.word(\";\")?;\n-                self.end()?\n+            ast::TraitItemKind::Macro(ref mac) => {\n+                self.print_mac(mac)?;\n+                match mac.node.delim {\n+                    MacDelimiter::Brace => {}\n+                    _ => self.s.word(\";\")?,\n+                }\n             }\n         }\n         self.ann.post(self, NodeSubItem(ti.id))\n@@ -1643,16 +1650,12 @@ impl<'a> State<'a> {\n             ast::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.ident, None, Some(ty))?;\n             }\n-            ast::ImplItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n-                // code copied from ItemKind::Mac:\n-                self.print_path(&node.path, false, 0)?;\n-                self.s.word(\"! \")?;\n-                self.cbox(INDENT_UNIT)?;\n-                self.popen()?;\n-                self.print_tts(node.stream())?;\n-                self.pclose()?;\n-                self.s.word(\";\")?;\n-                self.end()?\n+            ast::ImplItemKind::Macro(ref mac) => {\n+                self.print_mac(mac)?;\n+                match mac.node.delim {\n+                    MacDelimiter::Brace => {}\n+                    _ => self.s.word(\";\")?,\n+                }\n             }\n         }\n         self.ann.post(self, NodeSubItem(ii.id))\n@@ -1695,11 +1698,7 @@ impl<'a> State<'a> {\n                 let (ref mac, style, ref attrs) = **mac;\n                 self.space_if_not_bol()?;\n                 self.print_outer_attributes(attrs)?;\n-                let delim = match style {\n-                    ast::MacStmtStyle::Braces => token::Brace,\n-                    _ => token::Paren\n-                };\n-                self.print_mac(mac, delim)?;\n+                self.print_mac(mac)?;\n                 if style == ast::MacStmtStyle::Semicolon {\n                     self.s.word(\";\")?;\n                 }\n@@ -1829,25 +1828,22 @@ impl<'a> State<'a> {\n         self.print_else(elseopt)\n     }\n \n-    pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)\n-                     -> io::Result<()> {\n+    pub fn print_mac(&mut self, m: &ast::Mac) -> io::Result<()> {\n         self.print_path(&m.node.path, false, 0)?;\n         self.s.word(\"!\")?;\n-        match delim {\n-            token::Paren => self.popen()?,\n-            token::Bracket => self.s.word(\"[\")?,\n-            token::Brace => {\n+        match m.node.delim {\n+            MacDelimiter::Parenthesis => self.popen()?,\n+            MacDelimiter::Bracket => self.s.word(\"[\")?,\n+            MacDelimiter::Brace => {\n                 self.head(\"\")?;\n                 self.bopen()?;\n             }\n-            token::NoDelim => {}\n         }\n         self.print_tts(m.node.stream())?;\n-        match delim {\n-            token::Paren => self.pclose(),\n-            token::Bracket => self.s.word(\"]\"),\n-            token::Brace => self.bclose(m.span),\n-            token::NoDelim => Ok(()),\n+        match m.node.delim {\n+            MacDelimiter::Parenthesis => self.pclose(),\n+            MacDelimiter::Bracket => self.s.word(\"]\"),\n+            MacDelimiter::Brace => self.bclose(m.span),\n         }\n     }\n \n@@ -2333,7 +2329,7 @@ impl<'a> State<'a> {\n \n                 self.pclose()?;\n             }\n-            ast::ExprKind::Mac(ref m) => self.print_mac(m, token::Paren)?,\n+            ast::ExprKind::Mac(ref m) => self.print_mac(m)?,\n             ast::ExprKind::Paren(ref e) => {\n                 self.popen()?;\n                 self.print_inner_attributes_inline(attrs)?;\n@@ -2660,7 +2656,7 @@ impl<'a> State<'a> {\n                 self.print_pat(inner)?;\n                 self.pclose()?;\n             }\n-            PatKind::Mac(ref m) => self.print_mac(m, token::Paren)?,\n+            PatKind::Mac(ref m) => self.print_mac(m)?,\n         }\n         self.ann.post(self, NodePat(pat))\n     }"}, {"sha": "fe4d599d8242633a34ffd173f04adcf331ab4214", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=7426f5ccf7b362785a5abeb365674d3da3d4df2e", "patch": "@@ -53,6 +53,7 @@ pub fn expand_assert<'cx>(\n                 ),\n             )).into()\n         },\n+        delim: MacDelimiter::Parenthesis,\n     };\n     let if_expr = cx.expr_if(\n         sp,"}, {"sha": "ab1cfe1dbd67bdc1b5fa45df01ecc75f3a9cc78b", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/macro-brackets.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fmacro-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fmacro-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fmacro-brackets.rs?ref=7426f5ccf7b362785a5abeb365674d3da3d4df2e", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_attribute]\n+pub fn doit(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input.into_iter().collect()\n+}"}, {"sha": "cb734e2d10b7fecdfe28faf1d6d20991af39280f", "filename": "src/test/ui-fulldeps/proc-macro/macro-brackets.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-brackets.rs?ref=7426f5ccf7b362785a5abeb365674d3da3d4df2e", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro-brackets.rs\n+\n+#![feature(proc_macro)]\n+\n+extern crate macro_brackets as bar;\n+use bar::doit;\n+\n+macro_rules! id {\n+    ($($t:tt)*) => ($($t)*)\n+}\n+\n+#[doit]\n+id![static X: u32 = 'a';]; //~ ERROR: mismatched types\n+\n+\n+fn main() {}"}, {"sha": "1f31a03491311e0868b640c32de6a6c2608976f0", "filename": "src/test/ui-fulldeps/proc-macro/macro-brackets.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-brackets.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7426f5ccf7b362785a5abeb365674d3da3d4df2e/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-brackets.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-brackets.stderr?ref=7426f5ccf7b362785a5abeb365674d3da3d4df2e", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/macro-brackets.rs:23:21\n+   |\n+LL | id![static X: u32 = 'a';]; //~ ERROR: mismatched types\n+   |                     ^^^ expected u32, found char\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}