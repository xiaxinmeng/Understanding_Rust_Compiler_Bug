{"sha": "0af19985fcf9ac94079025ab116c804eff959d67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZjE5OTg1ZmNmOWFjOTQwNzkwMjVhYjExNmM4MDRlZmY5NTlkNjc=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-11T08:52:13Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-11T08:52:13Z"}, "message": "Generalize combine_attr_and_expr", "tree": {"sha": "da2568799aea865c0f177531d9738885a73f9b47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da2568799aea865c0f177531d9738885a73f9b47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0af19985fcf9ac94079025ab116c804eff959d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0af19985fcf9ac94079025ab116c804eff959d67", "html_url": "https://github.com/rust-lang/rust/commit/0af19985fcf9ac94079025ab116c804eff959d67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0af19985fcf9ac94079025ab116c804eff959d67/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ee76bec0f6a76b7b26eebdbd5700e9c727a96b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee76bec0f6a76b7b26eebdbd5700e9c727a96b3", "html_url": "https://github.com/rust-lang/rust/commit/0ee76bec0f6a76b7b26eebdbd5700e9c727a96b3"}], "stats": {"total": 165, "additions": 107, "deletions": 58}, "files": [{"sha": "0a716aa308c17adff41acb33da32efb3749dea4d", "filename": "src/comment.rs", "status": "modified", "additions": 88, "deletions": 1, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0af19985fcf9ac94079025ab116c804eff959d67/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af19985fcf9ac94079025ab116c804eff959d67/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=0af19985fcf9ac94079025ab116c804eff959d67", "patch": "@@ -18,7 +18,7 @@ use {Indent, Shape};\n use config::Config;\n use rewrite::RewriteContext;\n use string::{rewrite_string, StringFormat};\n-use utils::wrap_str;\n+use utils::{first_line_width, last_line_width, wrap_str};\n \n fn is_custom_comment(comment: &str) -> bool {\n     if !comment.starts_with(\"//\") {\n@@ -136,6 +136,93 @@ fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle {\n     }\n }\n \n+pub fn combine_strs_with_missing_comments(\n+    context: &RewriteContext,\n+    prev_str: &str,\n+    next_str: &str,\n+    span: Span,\n+    shape: Shape,\n+    allow_extend: bool,\n+) -> Option<String> {\n+    let mut allow_one_line = !prev_str.contains('\\n') && !next_str.contains('\\n');\n+    let first_sep = if prev_str.is_empty() || next_str.is_empty() {\n+        \"\"\n+    } else {\n+        \" \"\n+    };\n+    let mut one_line_width =\n+        last_line_width(prev_str) + first_line_width(next_str) + first_sep.len();\n+\n+    let original_snippet = context.snippet(span);\n+    let trimmed_snippet = original_snippet.trim();\n+    let indent_str = shape.indent.to_string(context.config);\n+\n+    if trimmed_snippet.is_empty() {\n+        if allow_extend && prev_str.len() + first_sep.len() + next_str.len() <= shape.width {\n+            return Some(format!(\"{}{}{}\", prev_str, first_sep, next_str));\n+        } else {\n+            let sep = if prev_str.is_empty() {\n+                String::new()\n+            } else {\n+                String::from(\"\\n\") + &indent_str\n+            };\n+            return Some(format!(\"{}{}{}\", prev_str, sep, next_str));\n+        }\n+    }\n+\n+    // We have a missing comment between the first expression and the second expression.\n+\n+    // Peek the the original source code and find out whether there is a newline between the first\n+    // expression and the second expression or the missing comment. We will preserve the orginal\n+    // layout whenever possible.\n+    let prefer_same_line = if let Some(pos) = original_snippet.chars().position(|c| c == '/') {\n+        !original_snippet[..pos].contains('\\n')\n+    } else {\n+        !original_snippet.contains('\\n')\n+    };\n+\n+    let missing_comment = try_opt!(rewrite_comment(\n+        trimmed_snippet,\n+        false,\n+        shape,\n+        context.config\n+    ));\n+    one_line_width -= first_sep.len();\n+    let first_sep = if prev_str.is_empty() || missing_comment.is_empty() {\n+        String::new()\n+    } else {\n+        let one_line_width = last_line_width(prev_str) + first_line_width(&missing_comment) + 1;\n+        if prefer_same_line && one_line_width <= shape.width {\n+            String::from(\" \")\n+        } else {\n+            format!(\"\\n{}\", indent_str)\n+        }\n+    };\n+    let second_sep = if missing_comment.is_empty() || next_str.is_empty() {\n+        String::new()\n+    } else {\n+        if missing_comment.starts_with(\"//\") {\n+            format!(\"\\n{}\", indent_str)\n+        } else {\n+            one_line_width += missing_comment.len() + first_sep.len() + 1;\n+            allow_one_line &= !missing_comment.starts_with(\"//\") && !missing_comment.contains('\\n');\n+            if prefer_same_line && allow_one_line && one_line_width <= shape.width {\n+                String::from(\" \")\n+            } else {\n+                format!(\"\\n{}\", indent_str)\n+            }\n+        }\n+    };\n+    Some(format!(\n+        \"{}{}{}{}{}\",\n+        prev_str,\n+        first_sep,\n+        missing_comment,\n+        second_sep,\n+        next_str,\n+    ))\n+}\n+\n pub fn rewrite_comment(\n     orig: &str,\n     block_style: bool,"}, {"sha": "c785f4883c4e895e6d54eca5c816efc432618d58", "filename": "src/expr.rs", "status": "modified", "additions": 9, "deletions": 57, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0af19985fcf9ac94079025ab116c804eff959d67/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af19985fcf9ac94079025ab116c804eff959d67/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=0af19985fcf9ac94079025ab116c804eff959d67", "patch": "@@ -19,7 +19,8 @@ use syntax::parse::classify;\n use {Indent, Shape, Spanned};\n use chains::rewrite_chain;\n use codemap::{LineRangeUtils, SpanUtils};\n-use comment::{contains_comment, recover_comment_removed, rewrite_comment, FindUncommented};\n+use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n+              rewrite_comment, FindUncommented};\n use config::{Config, ControlBraceStyle, IndentStyle, MultilineStyle, Style};\n use items::{span_hi_for_arg, span_lo_for_arg};\n use lists::{definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting,\n@@ -49,61 +50,6 @@ pub enum ExprType {\n     SubExpression,\n }\n \n-fn combine_attr_and_expr(\n-    context: &RewriteContext,\n-    shape: Shape,\n-    expr: &ast::Expr,\n-    expr_str: &str,\n-) -> Option<String> {\n-    let attrs = outer_attributes(&expr.attrs);\n-    let attr_str = try_opt!(attrs.rewrite(context, shape));\n-    let separator = if attr_str.is_empty() {\n-        String::new()\n-    } else {\n-        // Try to recover comments between the attributes and the expression if available.\n-        let missing_snippet = context.snippet(mk_sp(attrs[attrs.len() - 1].span.hi, expr.span.lo));\n-        let comment_opening_pos = missing_snippet.chars().position(|c| c == '/');\n-        let prefer_same_line = if let Some(pos) = comment_opening_pos {\n-            !missing_snippet[..pos].contains('\\n')\n-        } else {\n-            !missing_snippet.contains('\\n')\n-        };\n-\n-        let trimmed = missing_snippet.trim();\n-        let missing_comment = if trimmed.is_empty() {\n-            String::new()\n-        } else {\n-            try_opt!(rewrite_comment(&trimmed, false, shape, context.config))\n-        };\n-\n-        // 2 = ` ` + ` `\n-        let one_line_width =\n-            attr_str.len() + missing_comment.len() + 2 + first_line_width(expr_str);\n-        let attr_expr_separator = if prefer_same_line && !missing_comment.starts_with(\"//\") &&\n-            one_line_width <= shape.width\n-        {\n-            String::from(\" \")\n-        } else {\n-            format!(\"\\n{}\", shape.indent.to_string(context.config))\n-        };\n-\n-        if missing_comment.is_empty() {\n-            attr_expr_separator\n-        } else {\n-            // 1 = ` `\n-            let one_line_width =\n-                last_line_width(&attr_str) + 1 + first_line_width(&missing_comment);\n-            let attr_comment_separator = if prefer_same_line && one_line_width <= shape.width {\n-                String::from(\" \")\n-            } else {\n-                format!(\"\\n{}\", shape.indent.to_string(context.config))\n-            };\n-            attr_comment_separator + &missing_comment + &attr_expr_separator\n-        }\n-    };\n-    Some(format!(\"{}{}{}\", attr_str, separator, expr_str))\n-}\n-\n pub fn format_expr(\n     expr: &ast::Expr,\n     expr_type: ExprType,\n@@ -355,7 +301,13 @@ pub fn format_expr(\n             recover_comment_removed(expr_str, expr.span, context, shape)\n         })\n         .and_then(|expr_str| {\n-            combine_attr_and_expr(context, shape, expr, &expr_str)\n+            let attrs = outer_attributes(&expr.attrs);\n+            let attrs_str = try_opt!(attrs.rewrite(context, shape));\n+            let span = mk_sp(\n+                attrs.last().map_or(expr.span.lo, |attr| attr.span.hi),\n+                expr.span.lo,\n+            );\n+            combine_strs_with_missing_comments(context, &attrs_str, &expr_str, span, shape, false)\n         })\n }\n "}, {"sha": "9a31289e8eb209729abd5987a6160abadb0928bb", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0af19985fcf9ac94079025ab116c804eff959d67/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af19985fcf9ac94079025ab116c804eff959d67/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=0af19985fcf9ac94079025ab116c804eff959d67", "patch": "@@ -116,6 +116,16 @@ pub fn outer_attributes(attrs: &[ast::Attribute]) -> Vec<ast::Attribute> {\n     filter_attributes(attrs, ast::AttrStyle::Outer)\n }\n \n+#[inline]\n+pub fn last_line_contains_single_line_comment(s: &str) -> bool {\n+    s.lines().last().map_or(false, |l| l.contains(\"//\"))\n+}\n+\n+#[inline]\n+pub fn is_attributes_extendable(attrs_str: &str) -> bool {\n+    !attrs_str.contains('\\n') && !last_line_contains_single_line_comment(&attrs_str)\n+}\n+\n // The width of the first line in s.\n #[inline]\n pub fn first_line_width(s: &str) -> usize {"}]}