{"sha": "a45e117733b866302fa99390553d1c548508dcca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NWUxMTc3MzNiODY2MzAyZmE5OTM5MDU1M2QxYzU0ODUwOGRjY2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-28T11:01:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-28T11:01:36Z"}, "message": "Auto merge of #21019 - nikomatsakis:issue-20871-ret-as-assoc-type, r=nrc\n\nFixes https://github.com/rust-lang/rust/issues/20871\r\n\r\nr? @aturon (at least until we decide definitively if this is a good idea)", "tree": {"sha": "9b835a771ce0743423e8a4553430246cca9daebc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b835a771ce0743423e8a4553430246cca9daebc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a45e117733b866302fa99390553d1c548508dcca", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a45e117733b866302fa99390553d1c548508dcca", "html_url": "https://github.com/rust-lang/rust/commit/a45e117733b866302fa99390553d1c548508dcca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a45e117733b866302fa99390553d1c548508dcca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06410ef9fb03f640769d37b10bad1a71ded08b4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/06410ef9fb03f640769d37b10bad1a71ded08b4c", "html_url": "https://github.com/rust-lang/rust/commit/06410ef9fb03f640769d37b10bad1a71ded08b4c"}, {"sha": "05ffdc58248f7d5f2626a31d7272ad608d3984ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/05ffdc58248f7d5f2626a31d7272ad608d3984ec", "html_url": "https://github.com/rust-lang/rust/commit/05ffdc58248f7d5f2626a31d7272ad608d3984ec"}], "stats": {"total": 1580, "additions": 1098, "deletions": 482}, "files": [{"sha": "a090e4f24ce1d35ba16d7827e1f270fb8e6c2f0d", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -758,7 +758,9 @@ mod test {\n         expected: &'b [int],\n     }\n \n-    impl<'a, 'b, 'c> FnMut(&'c int) -> bool for Counter<'a, 'b> {\n+    impl<'a, 'b, 'c> FnMut<(&'c int,)> for Counter<'a, 'b> {\n+        type Output = bool;\n+\n         extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c int,)) -> bool {\n             assert_eq!(x, self.expected[*self.i]);\n             *self.i += 1;"}, {"sha": "0e99a2c9c3e1b2e8fc20683ade769707d79ccbd9", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -1117,29 +1117,33 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n-pub trait Fn<Args,Result> {\n+#[cfg(stage0)]\n+pub trait Fn<Args,Output> {\n     /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call(&self, args: Args) -> Result;\n+    extern \"rust-call\" fn call(&self, args: Args) -> Output;\n }\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n-pub trait FnMut<Args,Result> {\n+#[cfg(stage0)]\n+pub trait FnMut<Args,Output> {\n     /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Result;\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Output;\n }\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n-pub trait FnOnce<Args,Result> {\n+#[cfg(stage0)]\n+pub trait FnOnce<Args,Output> {\n     /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Result;\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Output;\n }\n \n+#[cfg(stage0)]\n impl<F: ?Sized, A, R> FnMut<A, R> for F\n     where F : Fn<A, R>\n {\n@@ -1148,10 +1152,69 @@ impl<F: ?Sized, A, R> FnMut<A, R> for F\n     }\n }\n \n+#[cfg(stage0)]\n impl<F,A,R> FnOnce<A,R> for F\n     where F : FnMut<A,R>\n {\n     extern \"rust-call\" fn call_once(mut self, args: A) -> R {\n         self.call_mut(args)\n     }\n }\n+\n+/// A version of the call operator that takes an immutable receiver.\n+#[lang=\"fn\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(not(stage0))]\n+pub trait Fn<Args> {\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a mutable receiver.\n+#[lang=\"fn_mut\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(not(stage0))]\n+pub trait FnMut<Args> {\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a by-value receiver.\n+#[lang=\"fn_once\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(not(stage0))]\n+pub trait FnOnce<Args> {\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[cfg(not(stage0))]\n+impl<F: ?Sized, A> FnMut<A> for F\n+    where F : Fn<A>\n+{\n+    type Output = <F as Fn<A>>::Output;\n+\n+    extern \"rust-call\" fn call_mut(&mut self, args: A) -> <F as Fn<A>>::Output {\n+        self.call(args)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<F,A> FnOnce<A> for F\n+    where F : FnMut<A>\n+{\n+    type Output = <F as FnMut<A>>::Output;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: A) -> <F as FnMut<A>>::Output {\n+        self.call_mut(args)\n+    }\n+}"}, {"sha": "101d349c3517084896bf207c22c8df28e055a539", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -461,13 +461,24 @@ delegate_iter!{exact u8 : Bytes<'a>}\n #[derive(Copy, Clone)]\n struct BytesDeref;\n \n+#[cfg(stage0)]\n impl<'a> Fn(&'a u8) -> u8 for BytesDeref {\n     #[inline]\n     extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n         *ptr\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a> Fn<(&'a u8,)> for BytesDeref {\n+    type Output = u8;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n+        *ptr\n+    }\n+}\n+\n /// An iterator over the substrings of a string, separated by `sep`.\n #[derive(Clone)]\n struct CharSplits<'a, Sep> {"}, {"sha": "af41844b2df1220f2cf2208e23ec295b4431a59c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -904,8 +904,8 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(o.method_num)\n                             }));\n-                            try!(this.emit_struct_field(\"real_index\", 0, |this| {\n-                                this.emit_uint(o.real_index)\n+                            try!(this.emit_struct_field(\"vtable_index\", 0, |this| {\n+                                this.emit_uint(o.vtable_index)\n                             }));\n                             Ok(())\n                         })\n@@ -1492,8 +1492,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                             this.read_uint()\n                                         }).unwrap()\n                                     },\n-                                    real_index: {\n-                                        this.read_struct_field(\"real_index\", 3, |this| {\n+                                    vtable_index: {\n+                                        this.read_struct_field(\"vtable_index\", 3, |this| {\n                                             this.read_uint()\n                                         }).unwrap()\n                                     },"}, {"sha": "5e7168b67358eaf32ad19ec55527888a9cf7776d", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -408,7 +408,7 @@ fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n             span_note!(tcx.sess, cause_span,\n-                      \"the requirement `{}` appears on the impl method\\\n+                      \"the requirement `{}` appears on the impl method \\\n                       but not on the corresponding trait method\",\n                       predicate.user_string(infcx.tcx));\n         }"}, {"sha": "82a4a60cebbf7ea0c921dc6225d5315b90629464", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -18,7 +18,7 @@ pub use self::ObligationCauseCode::*;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty::{self, Ty};\n-use middle::infer::InferCtxt;\n+use middle::infer::{self, InferCtxt};\n use std::slice::Iter;\n use std::rc::Rc;\n use syntax::ast;\n@@ -392,6 +392,65 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     }\n }\n \n+pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvironment<'a,'tcx>,\n+                                             cause: ObligationCause<'tcx>)\n+                                             -> ty::ParameterEnvironment<'a,'tcx>\n+{\n+    match normalize_param_env(&unnormalized_env, cause) {\n+        Ok(p) => p,\n+        Err(errors) => {\n+            // I'm not wild about reporting errors here; I'd prefer to\n+            // have the errors get reported at a defined place (e.g.,\n+            // during typeck). Instead I have all parameter\n+            // environments, in effect, going through this function\n+            // and hence potentially reporting errors. This ensurse of\n+            // course that we never forget to normalize (the\n+            // alternative seemed like it would involve a lot of\n+            // manual invocations of this fn -- and then we'd have to\n+            // deal with the errors at each of those sites).\n+            //\n+            // In any case, in practice, typeck constructs all the\n+            // parameter environments once for every fn as it goes,\n+            // and errors will get reported then; so after typeck we\n+            // can be sure that no errors should occur.\n+            let infcx = infer::new_infer_ctxt(unnormalized_env.tcx);\n+            report_fulfillment_errors(&infcx, &errors);\n+\n+            // Normalized failed? use what they gave us, it's better than nothing.\n+            unnormalized_env\n+        }\n+    }\n+}\n+\n+pub fn normalize_param_env<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n+                                    cause: ObligationCause<'tcx>)\n+                                    -> Result<ty::ParameterEnvironment<'a,'tcx>,\n+                                              Vec<FulfillmentError<'tcx>>>\n+{\n+    let tcx = param_env.tcx;\n+\n+    debug!(\"normalize_param_env(param_env={})\",\n+           param_env.repr(tcx));\n+\n+    let predicates: Vec<ty::Predicate<'tcx>> = {\n+        let infcx = infer::new_infer_ctxt(tcx);\n+        let mut selcx = &mut SelectionContext::new(&infcx, param_env);\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let Normalized { value: predicates, obligations } =\n+            project::normalize(selcx, cause, &param_env.caller_bounds);\n+        for obligation in obligations.into_iter() {\n+            fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n+        }\n+        try!(fulfill_cx.select_all_or_error(selcx.infcx(), param_env));\n+        predicates.iter().map(|p| infcx.resolve_type_vars_if_possible(p)).collect()\n+    };\n+\n+    debug!(\"normalize_param_env: predicates={}\",\n+           predicates.repr(tcx));\n+\n+    Ok(param_env.with_caller_bounds(predicates))\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)"}, {"sha": "56c1419502fd0db868149db69a452c5161f2b102", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -122,17 +122,15 @@ fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               trait_def_id: ast::DefId)\n                               -> bool\n {\n-    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-    let param_env = ty::construct_parameter_environment(tcx,\n-                                                        &trait_def.generics,\n-                                                        ast::DUMMY_NODE_ID);\n-    let predicates = param_env.caller_bounds.predicates.as_slice().to_vec();\n     let sized_def_id = match tcx.lang_items.sized_trait() {\n         Some(def_id) => def_id,\n         None => { return false; /* No Sized trait, can't require it! */ }\n     };\n \n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let free_substs = ty::construct_free_substs(tcx, &trait_def.generics, ast::DUMMY_NODE_ID);\n+    let predicates = trait_def.generics.to_bounds(tcx, &free_substs).predicates.into_vec();\n     elaborate_predicates(tcx, predicates)\n         .any(|predicate| {\n             match predicate {"}, {"sha": "d1dd086a5a342b0adface7779e15ca9f60ff452f", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 195, "deletions": 72, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -18,13 +18,17 @@ use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableImplData;\n+use super::util;\n \n use middle::infer;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, Substs};\n use middle::ty::{self, AsPredicate, ReferencesError, RegionEscape,\n                  HasProjectionTypes, ToPolyTraitRef, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use std::rc::Rc;\n+use syntax::ast;\n+use syntax::parse::token;\n+use util::common::FN_OUTPUT_NAME;\n use util::ppaux::Repr;\n \n pub type PolyProjectionObligation<'tcx> =\n@@ -53,13 +57,20 @@ pub struct MismatchedProjectionTypes<'tcx> {\n enum ProjectionTyCandidate<'tcx> {\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n+    Closure(ast::DefId, Substs<'tcx>),\n+    FnPointer(Ty<'tcx>),\n }\n \n struct ProjectionTyCandidateSet<'tcx> {\n     vec: Vec<ProjectionTyCandidate<'tcx>>,\n     ambiguous: bool\n }\n \n+/// Evaluates constraints of the form:\n+///\n+///     for<...> <T as Trait>::U == V\n+///\n+/// If successful, this may result in additional obligations.\n pub fn poly_project_and_unify_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>)\n@@ -102,8 +113,11 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n-/// Compute result of projecting an associated type and unify it with\n-/// `obligation.predicate.ty` (if we can).\n+/// Evaluates constraints of the form:\n+///\n+///     <T as Trait>::U == V\n+///\n+/// If successful, this may result in additional obligations.\n fn project_and_unify_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionObligation<'tcx>)\n@@ -133,6 +147,10 @@ fn project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n+/// Normalizes any associated type projections in `value`, replacing\n+/// them with a fully resolved type where possible. The return value\n+/// combines the normalized result and any additional obligations that\n+/// were incurred as result.\n pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n@@ -142,6 +160,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n     normalize_with_depth(selcx, cause, 0, value)\n }\n \n+/// As `normalize`, but with a custom depth.\n pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                           cause: ObligationCause<'tcx>,\n                                           depth: uint,\n@@ -251,6 +270,12 @@ impl<'tcx,T> Normalized<'tcx,T> {\n     }\n }\n \n+/// The guts of `normalize`: normalize a specific projection like `<T\n+/// as Trait>::Item`. The result is always a type (and possibly\n+/// additional obligations). If ambiguity arises, which implies that\n+/// there are unresolved type variables in the projection, we will\n+/// substitute a fresh type variable `$X` and generate a new\n+/// obligation `<T as Trait>::Item == $X` for later.\n pub fn normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n@@ -277,6 +302,10 @@ pub fn normalize_projection_type<'a,'b,'tcx>(\n         })\n }\n \n+/// The guts of `normalize`: normalize a specific projection like `<T\n+/// as Trait>::Item`. The result is always a type (and possibly\n+/// additional obligations). Returns `None` in the case of ambiguity,\n+/// which indicates that there are unbound type variables.\n fn opt_normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n@@ -440,8 +469,7 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n     obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n-    let env_predicates = selcx.param_env().caller_bounds.predicates.clone();\n-    let env_predicates = env_predicates.iter().cloned().collect();\n+    let env_predicates = selcx.param_env().caller_bounds.clone();\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n                                         candidate_set, env_predicates);\n }\n@@ -464,20 +492,22 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n \n                 let is_match = same_name && infcx.probe(|_| {\n                     let origin = infer::Misc(obligation.cause.span);\n-                    let obligation_poly_trait_ref =\n-                        obligation_trait_ref.to_poly_trait_ref();\n                     let data_poly_trait_ref =\n                         data.to_poly_trait_ref();\n+                    let obligation_poly_trait_ref =\n+                        obligation_trait_ref.to_poly_trait_ref();\n                     infcx.sub_poly_trait_refs(false,\n                                               origin,\n-                                              obligation_poly_trait_ref,\n-                                              data_poly_trait_ref).is_ok()\n+                                              data_poly_trait_ref,\n+                                              obligation_poly_trait_ref).is_ok()\n                 });\n \n-                if is_match {\n-                    debug!(\"assemble_candidates_from_predicates: candidate {}\",\n-                           data.repr(selcx.tcx()));\n+                debug!(\"assemble_candidates_from_predicates: candidate {} is_match {} same_name {}\",\n+                       data.repr(selcx.tcx()),\n+                       is_match,\n+                       same_name);\n \n+                if is_match {\n                     candidate_set.vec.push(\n                         ProjectionTyCandidate::ParamEnv(data.clone()));\n                 }\n@@ -551,6 +581,14 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n                 selcx, obligation, obligation_trait_ref, candidate_set,\n                 data.object_ty);\n         }\n+        super::VtableClosure(closure_def_id, substs) => {\n+            candidate_set.vec.push(\n+                ProjectionTyCandidate::Closure(closure_def_id, substs));\n+        }\n+        super::VtableFnPointer(fn_type) => {\n+            candidate_set.vec.push(\n+                ProjectionTyCandidate::FnPointer(fn_type));\n+        }\n         super::VtableParam(..) => {\n             // This case tell us nothing about the value of an\n             // associated type. Consider:\n@@ -578,9 +616,7 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // projection. And the projection where clause is handled\n             // in `assemble_candidates_from_param_env`.\n         }\n-        super::VtableBuiltin(..) |\n-        super::VtableClosure(..) |\n-        super::VtableFnPointer(..) => {\n+        super::VtableBuiltin(..) => {\n             // These traits have no associated types.\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n@@ -606,67 +642,150 @@ fn confirm_candidate<'cx,'tcx>(\n \n     match candidate {\n         ProjectionTyCandidate::ParamEnv(poly_projection) => {\n-            let projection =\n-                infcx.replace_late_bound_regions_with_fresh_var(\n-                    obligation.cause.span,\n-                    infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    &poly_projection).0;\n-\n-            assert_eq!(projection.projection_ty.item_name,\n-                       obligation.predicate.item_name);\n-\n-            let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n-            match infcx.sub_trait_refs(false,\n-                                       origin,\n-                                       obligation.predicate.trait_ref.clone(),\n-                                       projection.projection_ty.trait_ref.clone()) {\n-                Ok(()) => { }\n-                Err(e) => {\n-                    selcx.tcx().sess.span_bug(\n-                        obligation.cause.span,\n-                        format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n-                                obligation.repr(selcx.tcx()),\n-                                projection.repr(selcx.tcx()),\n-                                ty::type_err_to_str(selcx.tcx(), &e)).as_slice());\n-                }\n-            }\n-\n-            (projection.ty, vec!())\n+            confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n \n         ProjectionTyCandidate::Impl(impl_vtable) => {\n-            // there don't seem to be nicer accessors to these:\n-            let impl_items_map = selcx.tcx().impl_items.borrow();\n-            let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n-\n-            let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n-            let mut impl_ty = None;\n-            for impl_item in impl_items.iter() {\n-                let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n-                    ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n-                    ty::MethodTraitItem(..) => { continue; }\n-                };\n-\n-                if assoc_type.name != obligation.predicate.item_name {\n-                    continue;\n-                }\n+            confirm_impl_candidate(selcx, obligation, impl_vtable)\n+        }\n \n-                let impl_poly_ty = ty::lookup_item_type(selcx.tcx(), assoc_type.def_id);\n-                impl_ty = Some(impl_poly_ty.ty.subst(selcx.tcx(), &impl_vtable.substs));\n-                break;\n-            }\n+        ProjectionTyCandidate::Closure(def_id, substs) => {\n+            confirm_closure_candidate(selcx, obligation, def_id, &substs)\n+        }\n \n-            match impl_ty {\n-                Some(ty) => (ty, impl_vtable.nested.into_vec()),\n-                None => {\n-                    // This means that the impl is missing a\n-                    // definition for the associated type. This error\n-                    // ought to be reported by the type checker method\n-                    // `check_impl_items_against_trait`, so here we\n-                    // just return ty_err.\n-                    (selcx.tcx().types.err, vec!())\n-                }\n-            }\n+        ProjectionTyCandidate::FnPointer(fn_type) => {\n+            confirm_fn_pointer_candidate(selcx, obligation, fn_type)\n+        }\n+    }\n+}\n+\n+fn confirm_fn_pointer_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    fn_type: Ty<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let fn_type = selcx.infcx().shallow_resolve(fn_type);\n+    let sig = ty::ty_fn_sig(fn_type);\n+    confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n+}\n+\n+fn confirm_closure_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: &Substs<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let closure_typer = selcx.closure_typer();\n+    let closure_type = closure_typer.closure_type(closure_def_id, substs);\n+    confirm_callable_candidate(selcx, obligation, &closure_type.sig, util::TupleArgumentsFlag::No)\n+}\n+\n+fn confirm_callable_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    fn_sig: &ty::PolyFnSig<'tcx>,\n+    flag: util::TupleArgumentsFlag)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let tcx = selcx.tcx();\n+\n+    debug!(\"confirm_closure_candidate({},{})\",\n+           obligation.repr(tcx),\n+           fn_sig.repr(tcx));\n+\n+    // Note: we unwrap the binder here but re-create it below (1)\n+    let ty::Binder((trait_ref, ret_type)) =\n+        util::closure_trait_ref_and_return_type(tcx,\n+                                                obligation.predicate.trait_ref.def_id,\n+                                                obligation.predicate.trait_ref.self_ty(),\n+                                                fn_sig,\n+                                                flag);\n+\n+    let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n+        projection_ty: ty::ProjectionTy {\n+            trait_ref: trait_ref,\n+            item_name: token::intern(FN_OUTPUT_NAME),\n+        },\n+        ty: ret_type\n+    });\n+\n+    confirm_param_env_candidate(selcx, obligation, predicate)\n+}\n+\n+fn confirm_param_env_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    poly_projection: ty::PolyProjectionPredicate<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let infcx = selcx.infcx();\n+\n+    let projection =\n+        infcx.replace_late_bound_regions_with_fresh_var(\n+            obligation.cause.span,\n+            infer::LateBoundRegionConversionTime::HigherRankedType,\n+            &poly_projection).0;\n+\n+    assert_eq!(projection.projection_ty.item_name,\n+               obligation.predicate.item_name);\n+\n+    let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+    match infcx.sub_trait_refs(false,\n+                               origin,\n+                               obligation.predicate.trait_ref.clone(),\n+                               projection.projection_ty.trait_ref.clone()) {\n+        Ok(()) => { }\n+        Err(e) => {\n+            selcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n+                        obligation.repr(selcx.tcx()),\n+                        projection.repr(selcx.tcx()),\n+                        ty::type_err_to_str(selcx.tcx(), &e)).as_slice());\n+        }\n+    }\n+\n+    (projection.ty, vec!())\n+}\n+\n+fn confirm_impl_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    // there don't seem to be nicer accessors to these:\n+    let impl_items_map = selcx.tcx().impl_items.borrow();\n+    let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n+\n+    let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n+    let mut impl_ty = None;\n+    for impl_item in impl_items.iter() {\n+        let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n+            ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n+            ty::MethodTraitItem(..) => { continue; }\n+        };\n+\n+        if assoc_type.name != obligation.predicate.item_name {\n+            continue;\n+        }\n+\n+        let impl_poly_ty = ty::lookup_item_type(selcx.tcx(), assoc_type.def_id);\n+        impl_ty = Some(impl_poly_ty.ty.subst(selcx.tcx(), &impl_vtable.substs));\n+        break;\n+    }\n+\n+    match impl_ty {\n+        Some(ty) => (ty, impl_vtable.nested.into_vec()),\n+        None => {\n+            // This means that the impl is missing a\n+            // definition for the associated type. This error\n+            // ought to be reported by the type checker method\n+            // `check_impl_items_against_trait`, so here we\n+            // just return ty_err.\n+            (selcx.tcx().types.err, vec!())\n         }\n     }\n }\n@@ -688,7 +807,11 @@ impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n             ProjectionTyCandidate::ParamEnv(ref data) =>\n                 format!(\"ParamEnv({})\", data.repr(tcx)),\n             ProjectionTyCandidate::Impl(ref data) =>\n-                format!(\"Impl({})\", data.repr(tcx))\n+                format!(\"Impl({})\", data.repr(tcx)),\n+            ProjectionTyCandidate::Closure(ref a, ref b) =>\n+                format!(\"Closure(({},{}))\", a.repr(tcx), b.repr(tcx)),\n+            ProjectionTyCandidate::FnPointer(a) =>\n+                format!(\"FnPointer(({}))\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "4d5f3d925b09abfeb764b6d123dc8ac0de9eaf37", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -214,6 +214,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.closure_typer.param_env()\n     }\n \n+    pub fn closure_typer(&self) -> &'cx (ty::ClosureTyper<'tcx>+'cx) {\n+        self.closure_typer\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -951,7 +955,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                stack.obligation.repr(self.tcx()));\n \n         let caller_trait_refs: Vec<_> =\n-            self.param_env().caller_bounds.predicates.iter()\n+            self.param_env().caller_bounds.iter()\n             .filter_map(|o| o.to_opt_poly_trait_ref())\n             .collect();\n \n@@ -1913,33 +1917,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()));\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        let sig = match self_ty.sty {\n-            ty::ty_bare_fn(_, &ty::BareFnTy {\n-                unsafety: ast::Unsafety::Normal,\n-                abi: abi::Rust,\n-                ref sig\n-            }) => {\n-                sig\n-            }\n-            _ => {\n-                self.tcx().sess.span_bug(\n-                    obligation.cause.span,\n-                    &format!(\"Fn pointer candidate for inappropriate self type: {}\",\n-                            self_ty.repr(self.tcx()))[]);\n-            }\n-        };\n-\n-        let arguments_tuple = ty::mk_tup(self.tcx(), sig.0.inputs.to_vec());\n-        let output_type = sig.0.output.unwrap();\n-        let substs =\n-            Substs::new_trait(\n-                vec![arguments_tuple, output_type],\n-                vec![],\n-                self_ty);\n-        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n-            def_id: obligation.predicate.def_id(),\n-            substs: self.tcx().mk_substs(substs),\n-        }));\n+        let sig = ty::ty_fn_sig(self_ty);\n+        let ty::Binder((trait_ref, _)) =\n+            util::closure_trait_ref_and_return_type(self.tcx(),\n+                                                    obligation.predicate.def_id(),\n+                                                    self_ty,\n+                                                    sig,\n+                                                    util::TupleArgumentsFlag::Yes);\n+        let trait_ref = ty::Binder(trait_ref);\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n@@ -1958,23 +1943,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n-\n-        debug!(\"confirm_closure_candidate: closure_def_id={} closure_type={}\",\n-               closure_def_id.repr(self.tcx()),\n-               closure_type.repr(self.tcx()));\n-\n-        let closure_sig = &closure_type.sig;\n-        let arguments_tuple = closure_sig.0.inputs[0];\n-        let trait_substs =\n-            Substs::new_trait(\n-                vec![arguments_tuple, closure_sig.0.output.unwrap()],\n-                vec![],\n-                obligation.self_ty());\n-        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n-            def_id: obligation.predicate.def_id(),\n-            substs: self.tcx().mk_substs(trait_substs),\n-        }));\n+        let trait_ref = self.closure_trait_ref(obligation,\n+                                               closure_def_id,\n+                                               substs);\n \n         debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={})\",\n                closure_def_id.repr(self.tcx()),\n@@ -2157,16 +2128,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n-        let where_clause_trait_ref =\n-            project::normalize_with_depth(self,\n-                                          obligation.cause.clone(),\n-                                          obligation.recursion_depth+1,\n-                                          &where_clause_trait_ref);\n-\n         let () =\n-            try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref.value.clone()));\n+            try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref));\n \n-        Ok(where_clause_trait_ref.obligations)\n+        Ok(Vec::new())\n     }\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n@@ -2286,6 +2251,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn closure_trait_ref(&self,\n+                         obligation: &TraitObligation<'tcx>,\n+                         closure_def_id: ast::DefId,\n+                         substs: &Substs<'tcx>)\n+                         -> ty::PolyTraitRef<'tcx>\n+    {\n+        let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n+        let ty::Binder((trait_ref, _)) =\n+            util::closure_trait_ref_and_return_type(self.tcx(),\n+                                                    obligation.predicate.def_id(),\n+                                                    obligation.predicate.0.self_ty(), // (1)\n+                                                    &closure_type.sig,\n+                                                    util::TupleArgumentsFlag::No);\n+\n+        // (1) Feels icky to skip the binder here, but OTOH we know\n+        // that the self-type is an unboxed closure type and hence is\n+        // in fact unparameterized (or at least does not reference any\n+        // regions bound in the obligation). Still probably some\n+        // refactoring could make this nicer.\n+\n+        ty::Binder(trait_ref)\n+    }\n+\n     fn impl_obligations(&mut self,\n                         cause: ObligationCause<'tcx>,\n                         recursion_depth: uint,"}, {"sha": "edeca83d5697f6dadba1300840e019f50d61d01c", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -329,28 +329,67 @@ pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                object_trait_ref: ty::PolyTraitRef<'tcx>,\n                                                trait_def_id: ast::DefId,\n-                                               method_index_in_trait: uint) -> uint {\n+                                               method_offset_in_trait: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n     // iterating down the supertraits of the object's trait until\n     // we find the trait the method came from, counting up the\n     // methods from them.\n     let mut method_count = 0;\n-    ty::each_bound_trait_and_supertraits(tcx, &[object_trait_ref], |bound_ref| {\n+\n+    for bound_ref in transitive_bounds(tcx, &[object_trait_ref]) {\n         if bound_ref.def_id() == trait_def_id {\n-            false\n-        } else {\n-            let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n-            for trait_item in trait_items.iter() {\n-                match *trait_item {\n-                    ty::MethodTraitItem(_) => method_count += 1,\n-                    ty::TypeTraitItem(_) => {}\n-                }\n+            break;\n+        }\n+\n+        let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n+        for trait_item in trait_items.iter() {\n+            match *trait_item {\n+                ty::MethodTraitItem(_) => method_count += 1,\n+                ty::TypeTraitItem(_) => {}\n             }\n-            true\n         }\n+    }\n+\n+    // count number of methods preceding the one we are selecting and\n+    // add them to the total offset; skip over associated types.\n+    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    for trait_item in trait_items.iter().take(method_offset_in_trait) {\n+        match *trait_item {\n+            ty::MethodTraitItem(_) => method_count += 1,\n+            ty::TypeTraitItem(_) => {}\n+        }\n+    }\n+\n+    // the item at the offset we were given really ought to be a method\n+    assert!(match trait_items[method_offset_in_trait] {\n+        ty::MethodTraitItem(_) => true,\n+        ty::TypeTraitItem(_) => false\n+    });\n+\n+    method_count\n+}\n+\n+pub enum TupleArgumentsFlag { Yes, No }\n+\n+pub fn closure_trait_ref_and_return_type<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    fn_trait_def_id: ast::DefId,\n+    self_ty: Ty<'tcx>,\n+    sig: &ty::PolyFnSig<'tcx>,\n+    tuple_arguments: TupleArgumentsFlag)\n+    -> ty::Binder<(Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)>\n+{\n+    let arguments_tuple = match tuple_arguments {\n+        TupleArgumentsFlag::No => sig.0.inputs[0],\n+        TupleArgumentsFlag::Yes => ty::mk_tup(tcx, sig.0.inputs.to_vec()),\n+    };\n+    let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n+    let trait_ref = Rc::new(ty::TraitRef {\n+        def_id: fn_trait_def_id,\n+        substs: tcx.mk_substs(trait_substs),\n     });\n-    method_count + method_index_in_trait\n+    ty::Binder((trait_ref, sig.0.output.unwrap()))\n }\n \n impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {"}, {"sha": "062ddd23d9de936ee5d93fadd080ef9d6c8ae919", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 94, "deletions": 48, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -452,7 +452,10 @@ pub struct MethodParam<'tcx> {\n     // never contains bound regions; those regions should have been\n     // instantiated with fresh variables at this point.\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n-    // index of uint in the list of methods for the trait\n+\n+    // index of uint in the list of trait items. Note that this is NOT\n+    // the index into the vtable, because the list of trait items\n+    // includes associated types.\n     pub method_num: uint,\n \n     /// The impl for the trait from which the method comes. This\n@@ -471,14 +474,14 @@ pub struct MethodObject<'tcx> {\n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n \n-    // index of the method to be invoked amongst the trait's methods\n+    // index of the method to be invoked amongst the trait's items\n     pub method_num: uint,\n \n     // index into the actual runtime vtable.\n     // the vtable is formed by concatenating together the method lists of\n-    // the base object trait and all supertraits;  this is the index into\n+    // the base object trait and all supertraits; this is the index into\n     // that vtable\n-    pub real_index: uint,\n+    pub vtable_index: uint,\n }\n \n #[derive(Clone)]\n@@ -2084,11 +2087,7 @@ impl<'tcx> TraitRef<'tcx> {\n pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     pub tcx: &'a ctxt<'tcx>,\n \n-    /// A substitution that can be applied to move from\n-    /// the \"outer\" view of a type or method to the \"inner\" view.\n-    /// In general, this means converting from bound parameters to\n-    /// free parameters. Since we currently represent bound/free type\n-    /// parameters in the same way, this only has an effect on regions.\n+    /// See `construct_free_substs` for details.\n     pub free_substs: Substs<'tcx>,\n \n     /// Each type parameter has an implicit region bound that\n@@ -2100,14 +2099,27 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations.\n-    pub caller_bounds: ty::GenericBounds<'tcx>,\n+    pub caller_bounds: Vec<ty::Predicate<'tcx>>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n+    pub fn with_caller_bounds(&self,\n+                              caller_bounds: Vec<ty::Predicate<'tcx>>)\n+                              -> ParameterEnvironment<'a,'tcx>\n+    {\n+        ParameterEnvironment {\n+            tcx: self.tcx,\n+            free_substs: self.free_substs.clone(),\n+            implicit_region_bound: self.implicit_region_bound,\n+            caller_bounds: caller_bounds,\n+            selection_cache: traits::SelectionCache::new(),\n+        }\n+    }\n+\n     pub fn for_item(cx: &'a ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n@@ -2119,6 +2131,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -2153,6 +2166,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -2179,6 +2193,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n \n                         construct_parameter_environment(cx,\n+                                                        item.span,\n                                                         &fn_pty.generics,\n                                                         body.id)\n                     }\n@@ -2189,7 +2204,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n                         let pty = ty::lookup_item_type(cx, def_id);\n-                        construct_parameter_environment(cx, &pty.generics, id)\n+                        construct_parameter_environment(cx, item.span, &pty.generics, id)\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -6258,23 +6273,22 @@ impl Variance {\n pub fn empty_parameter_environment<'a,'tcx>(cx: &'a ctxt<'tcx>) -> ParameterEnvironment<'a,'tcx> {\n     ty::ParameterEnvironment { tcx: cx,\n                                free_substs: Substs::empty(),\n-                               caller_bounds: GenericBounds::empty(),\n+                               caller_bounds: Vec::new(),\n                                implicit_region_bound: ty::ReEmpty,\n                                selection_cache: traits::SelectionCache::new(), }\n }\n \n-/// See `ParameterEnvironment` struct def'n for details\n-pub fn construct_parameter_environment<'a,'tcx>(\n+/// Constructs and returns a substitution that can be applied to move from\n+/// the \"outer\" view of a type or method to the \"inner\" view.\n+/// In general, this means converting from bound parameters to\n+/// free parameters. Since we currently represent bound/free type\n+/// parameters in the same way, this only has an effect on regions.\n+pub fn construct_free_substs<'a,'tcx>(\n     tcx: &'a ctxt<'tcx>,\n     generics: &ty::Generics<'tcx>,\n     free_id: ast::NodeId)\n-    -> ParameterEnvironment<'a, 'tcx>\n+    -> Substs<'tcx>\n {\n-\n-    //\n-    // Construct the free substs.\n-    //\n-\n     // map T => T\n     let mut types = VecPerParamSpace::empty();\n     push_types_from_defs(tcx, &mut types, generics.types.as_slice());\n@@ -6283,11 +6297,45 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     let mut regions = VecPerParamSpace::empty();\n     push_region_params(&mut regions, free_id, generics.regions.as_slice());\n \n-    let free_substs = Substs {\n+    return Substs {\n         types: types,\n         regions: subst::NonerasedRegions(regions)\n     };\n \n+    fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n+                          free_id: ast::NodeId,\n+                          region_params: &[RegionParameterDef])\n+    {\n+        for r in region_params.iter() {\n+            regions.push(r.space, ty::free_region_from_def(free_id, r));\n+        }\n+    }\n+\n+    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  types: &mut VecPerParamSpace<Ty<'tcx>>,\n+                                  defs: &[TypeParameterDef<'tcx>]) {\n+        for def in defs.iter() {\n+            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n+                   def.repr(tcx));\n+            let ty = ty::mk_param_from_def(tcx, def);\n+            types.push(def.space, ty);\n+       }\n+    }\n+}\n+\n+/// See `ParameterEnvironment` struct def'n for details\n+pub fn construct_parameter_environment<'a,'tcx>(\n+    tcx: &'a ctxt<'tcx>,\n+    span: Span,\n+    generics: &ty::Generics<'tcx>,\n+    free_id: ast::NodeId)\n+    -> ParameterEnvironment<'a, 'tcx>\n+{\n+    //\n+    // Construct the free substs.\n+    //\n+\n+    let free_substs = construct_free_substs(tcx, generics, free_id);\n     let free_id_scope = region::CodeExtent::from_node_id(free_id);\n \n     //\n@@ -6296,52 +6344,50 @@ pub fn construct_parameter_environment<'a,'tcx>(\n \n     let bounds = generics.to_bounds(tcx, &free_substs);\n     let bounds = liberate_late_bound_regions(tcx, free_id_scope, &ty::Binder(bounds));\n+    let predicates = bounds.predicates.into_vec();\n \n     //\n     // Compute region bounds. For now, these relations are stored in a\n     // global table on the tcx, so just enter them there. I'm not\n     // crazy about this scheme, but it's convenient, at least.\n     //\n \n-    record_region_bounds(tcx, &bounds);\n+    record_region_bounds(tcx, &*predicates);\n \n-    debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} bounds={:?}\",\n+    debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} predicates={:?}\",\n            free_id,\n            free_substs.repr(tcx),\n-           bounds.repr(tcx));\n+           predicates.repr(tcx));\n+\n+    //\n+    // Finally, we have to normalize the bounds in the environment, in\n+    // case they contain any associated type projections. This process\n+    // can yield errors if the put in illegal associated types, like\n+    // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n+    // report these errors right here; this doesn't actually feel\n+    // right to me, because constructing the environment feels like a\n+    // kind of a \"idempotent\" action, but I'm not sure where would be\n+    // a better place. In practice, we construct environments for\n+    // every fn once during type checking, and we'll abort if there\n+    // are any errors at that point, so after type checking you can be\n+    // sure that this will succeed without errors anyway.\n+    //\n \n-    return ty::ParameterEnvironment {\n+    let unnormalized_env = ty::ParameterEnvironment {\n         tcx: tcx,\n         free_substs: free_substs,\n         implicit_region_bound: ty::ReScope(free_id_scope),\n-        caller_bounds: bounds,\n+        caller_bounds: predicates,\n         selection_cache: traits::SelectionCache::new(),\n     };\n \n-    fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n-                          free_id: ast::NodeId,\n-                          region_params: &[RegionParameterDef])\n-    {\n-        for r in region_params.iter() {\n-            regions.push(r.space, ty::free_region_from_def(free_id, r));\n-        }\n-    }\n-\n-    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                  types: &mut VecPerParamSpace<Ty<'tcx>>,\n-                                  defs: &[TypeParameterDef<'tcx>]) {\n-        for def in defs.iter() {\n-            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n-                   def.repr(tcx));\n-            let ty = ty::mk_param_from_def(tcx, def);\n-            types.push(def.space, ty);\n-       }\n-    }\n+    let cause = traits::ObligationCause::misc(span, free_id);\n+    return traits::normalize_param_env_or_error(unnormalized_env, cause);\n \n-    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, bounds: &GenericBounds<'tcx>) {\n-        debug!(\"record_region_bounds(bounds={:?})\", bounds.repr(tcx));\n+    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, predicates: &[ty::Predicate<'tcx>]) {\n+        debug!(\"record_region_bounds(predicates={:?})\", predicates.repr(tcx));\n \n-        for predicate in bounds.predicates.iter() {\n+        for predicate in predicates.iter() {\n             match *predicate {\n                 Predicate::Projection(..) |\n                 Predicate::Trait(..) |"}, {"sha": "69d32c3f5fc33b4a8333dd5bd436c4f13b279a37", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -71,7 +71,7 @@ pub trait TypeFolder<'tcx> : Sized {\n     fn exit_region_binder(&mut self) { }\n \n     fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n     {\n         // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n         super_fold_binder(self, t)\n@@ -186,7 +186,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n     }\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>+Clone> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.fold_binder(self)\n     }\n@@ -319,7 +319,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n                     trait_ref: object.trait_ref.fold_with(folder),\n                     object_trait_id: object.object_trait_id,\n                     method_num: object.method_num,\n-                    real_index: object.real_index\n+                    vtable_index: object.vtable_index,\n                 })\n             }\n         }"}, {"sha": "bdb6ea22f8b457fa2c779ac945bef9804e64407b", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -22,6 +22,9 @@ use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+// The name of the associated type for `Fn` return types\n+pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n+\n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n #[derive(Clone, Copy, Show)]"}, {"sha": "1be99a8e569f3f55bb8b536b19b790c0998eee01", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 96, "deletions": 45, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -298,17 +298,9 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n \n     fn closure_to_string<'tcx>(cx: &ctxt<'tcx>, cty: &ty::ClosureTy<'tcx>) -> String {\n         let mut s = String::new();\n-\n-        match cty.unsafety {\n-            ast::Unsafety::Normal => {}\n-            ast::Unsafety::Unsafe => {\n-                s.push_str(cty.unsafety.to_string().as_slice());\n-                s.push(' ');\n-            }\n-        };\n-\n-        push_sig_to_string(cx, &mut s, '|', '|', &cty.sig);\n-\n+        s.push_str(\"[closure\");\n+        push_sig_to_string(cx, &mut s, '(', ')', &cty.sig);\n+        s.push(']');\n         s\n     }\n \n@@ -399,18 +391,10 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         ty_enum(did, substs) | ty_struct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n-            parameterized(cx, base.as_slice(), substs, &generics, did)\n+            parameterized(cx, base.as_slice(), substs, &generics, did, &[])\n         }\n-        ty_trait(box ty::TyTrait {\n-            ref principal, ref bounds\n-        }) => {\n-            let principal = principal.user_string(cx);\n-            let bound_str = bounds.user_string(cx);\n-            let bound_sep = if bound_str.is_empty() { \"\" } else { \" + \" };\n-            format!(\"{}{}{}\",\n-                    principal,\n-                    bound_sep,\n-                    bound_str)\n+        ty_trait(ref data) => {\n+            data.user_string(cx)\n         }\n         ty::ty_projection(ref data) => {\n             format!(\"<{} as {}>::{}\",\n@@ -420,14 +404,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_str => \"str\".to_string(),\n         ty_closure(ref did, _, substs) => {\n-            cx.closures.borrow().get(did).map(|cl| {\n+            let closures = cx.closures.borrow();\n+            closures.get(did).map(|cl| {\n                 closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n             }).unwrap_or_else(|| {\n                 if did.krate == ast::LOCAL_CRATE {\n                     let span = cx.map.span(did.node);\n-                    format!(\"closure[{}]\", span.repr(cx))\n+                    format!(\"[closure {}]\", span.repr(cx))\n                 } else {\n-                    format!(\"closure\")\n+                    format!(\"[closure]\")\n                 }\n             })\n         }\n@@ -458,7 +443,8 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n                            base: &str,\n                            substs: &subst::Substs<'tcx>,\n                            generics: &ty::Generics<'tcx>,\n-                           did: ast::DefId)\n+                           did: ast::DefId,\n+                           projections: &[ty::ProjectionPredicate<'tcx>])\n                            -> String\n {\n     if cx.sess.verbose() {\n@@ -511,7 +497,20 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         strs.push(ty_to_string(cx, *t))\n     }\n \n-    if cx.lang_items.fn_trait_kind(did).is_some() {\n+    for projection in projections.iter() {\n+        strs.push(format!(\"{}={}\",\n+                          projection.projection_ty.item_name.user_string(cx),\n+                          projection.ty.user_string(cx)));\n+    }\n+\n+    if cx.lang_items.fn_trait_kind(did).is_some() && projections.len() == 1 {\n+        let projection_ty = projections[0].ty;\n+        let tail =\n+            if ty::type_is_nil(projection_ty) {\n+                format!(\"\")\n+            } else {\n+                format!(\" -> {}\", projection_ty.user_string(cx))\n+            };\n         format!(\"{}({}){}\",\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n@@ -521,7 +520,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n                 } else {\n                     &strs[0][]\n                 },\n-                if &*strs[1] == \"()\" { String::new() } else { format!(\" -> {}\", strs[1]) })\n+                tail)\n     } else if strs.len() > 0 {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n@@ -623,6 +622,65 @@ impl<'tcx> Repr<'tcx> for def::Def {\n     }\n }\n \n+/// This curious type is here to help pretty-print trait objects. In\n+/// a trait object, the projections are stored separately from the\n+/// main trait bound, but in fact we want to package them together\n+/// when printing out; they also have separate binders, but we want\n+/// them to share a binder when we print them out. (And the binder\n+/// pretty-printing logic is kind of clever and we don't want to\n+/// reproduce it.) So we just repackage up the structure somewhat.\n+///\n+/// Right now there is only one trait in an object that can have\n+/// projection bounds, so we just stuff them altogether. But in\n+/// reality we should eventually sort things out better.\n+type TraitAndProjections<'tcx> =\n+    (Rc<ty::TraitRef<'tcx>>, Vec<ty::ProjectionPredicate<'tcx>>);\n+\n+impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        let &(ref trait_ref, ref projection_bounds) = self;\n+        let base = ty::item_path_str(tcx, trait_ref.def_id);\n+        let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n+        parameterized(tcx,\n+                      base.as_slice(),\n+                      trait_ref.substs,\n+                      &trait_def.generics,\n+                      trait_ref.def_id,\n+                      &projection_bounds[])\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::TyTrait<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        let &ty::TyTrait { ref principal, ref bounds } = self;\n+\n+        let mut components = vec![];\n+\n+        let tap: ty::Binder<TraitAndProjections<'tcx>> =\n+            ty::Binder((principal.0.clone(),\n+                        bounds.projection_bounds.iter().map(|x| x.0.clone()).collect()));\n+\n+        // Generate the main trait ref, including associated types.\n+        components.push(tap.user_string(tcx));\n+\n+        // Builtin bounds.\n+        for bound in bounds.builtin_bounds.iter() {\n+            components.push(bound.user_string(tcx));\n+        }\n+\n+        // Region, if not obviously implied by builtin bounds.\n+        if bounds.region_bound != ty::ReStatic ||\n+            !bounds.builtin_bounds.contains(&ty::BoundSend)\n+        { // Region bound is implied by builtin bounds:\n+            components.push(bounds.region_bound.user_string(tcx));\n+        }\n+\n+        components.retain(|s| !s.is_empty());\n+\n+        components.connect(\" + \")\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"TypeParameterDef({:?}, {}, {:?}/{})\",\n@@ -701,12 +759,6 @@ impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        self.user_string(tcx)\n-    }\n-}\n-\n impl<'tcx> Repr<'tcx> for ty::ParamBounds<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n@@ -727,7 +779,8 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"TraitRef({}, {})\",\n                 self.substs.self_ty().repr(tcx),\n-                parameterized(tcx, base.as_slice(), self.substs, &trait_def.generics, self.def_id))\n+                parameterized(tcx, base.as_slice(), self.substs,\n+                              &trait_def.generics, self.def_id, &[]))\n     }\n }\n \n@@ -1062,7 +1115,7 @@ impl<'tcx> Repr<'tcx> for ty::MethodObject<'tcx> {\n         format!(\"MethodObject({},{},{})\",\n                 self.trait_ref.repr(tcx),\n                 self.method_num,\n-                self.real_index)\n+                self.vtable_index)\n     }\n }\n \n@@ -1110,14 +1163,8 @@ impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        if self.builtin_bounds.contains(&ty::BoundSend) &&\n-            self.region_bound == ty::ReStatic\n-        { // Region bound is implied by builtin bounds:\n-            return self.builtin_bounds.repr(tcx);\n-        }\n-\n+impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n \n         let region_str = self.region_bound.user_string(tcx);\n@@ -1129,6 +1176,10 @@ impl<'tcx> UserString<'tcx> for ty::ExistentialBounds<'tcx> {\n             res.push(bound.user_string(tcx));\n         }\n \n+        for projection_bound in self.projection_bounds.iter() {\n+            res.push(projection_bound.user_string(tcx));\n+        }\n+\n         res.connect(\"+\")\n     }\n }\n@@ -1184,7 +1235,7 @@ impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n         let path_str = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         parameterized(tcx, path_str.as_slice(), self.substs,\n-                      &trait_def.generics, self.def_id)\n+                      &trait_def.generics, self.def_id, &[])\n     }\n }\n "}, {"sha": "c4240fa9ebae7230c5e973cede7c674a8acd1bee", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -13,7 +13,7 @@ use back::abi;\n use back::link;\n use llvm::{self, ValueRef, get_param};\n use metadata::csearch;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::Substs;\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -29,6 +29,7 @@ use trans::expr::{SaveIn, Ignore};\n use trans::expr;\n use trans::glue;\n use trans::machine;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n use middle::ty::{self, Ty};\n@@ -162,7 +163,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             trans_trait_callee(bcx,\n                                monomorphize_type(bcx, method_ty),\n-                               mt.real_index,\n+                               mt.vtable_index,\n                                self_expr,\n                                arg_cleanup_scope)\n         }\n@@ -439,7 +440,7 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// extract the self data and vtable out of the pair.\n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   method_ty: Ty<'tcx>,\n-                                  n_method: uint,\n+                                  vtable_index: uint,\n                                   self_expr: &ast::Expr,\n                                   arg_cleanup_scope: cleanup::ScopeId)\n                                   -> Callee<'blk, 'tcx> {\n@@ -469,28 +470,28 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         self_datum.val\n     };\n \n-    trans_trait_callee_from_llval(bcx, method_ty, n_method, llval)\n+    trans_trait_callee_from_llval(bcx, method_ty, vtable_index, llval)\n }\n \n /// Same as `trans_trait_callee()` above, except that it is given a by-ref pointer to the object\n /// pair.\n pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                  callee_ty: Ty<'tcx>,\n-                                                 n_method: uint,\n+                                                 vtable_index: uint,\n                                                  llpair: ValueRef)\n                                                  -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_trait_callee\");\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug!(\"(translating trait callee) loading second index from pair\");\n+    debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llpair={})\",\n+           callee_ty.repr(ccx.tcx()),\n+           vtable_index,\n+           bcx.val_to_string(llpair));\n     let llboxptr = GEPi(bcx, llpair, &[0u, abi::FAT_PTR_ADDR]);\n     let llbox = Load(bcx, llboxptr);\n     let llself = PointerCast(bcx, llbox, Type::i8p(ccx));\n \n-    // Load the function from the vtable and cast it to the expected type.\n-    debug!(\"(translating trait callee) loading method\");\n-\n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match callee_ty.sty {\n         ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n@@ -500,10 +501,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     output: f.sig.0.output,\n                     variadic: f.sig.0.variadic,\n                 });\n-            type_of_rust_fn(ccx,\n-                            Some(Type::i8p(ccx)),\n-                            &fake_sig,\n-                            f.abi)\n+            type_of_rust_fn(ccx, Some(Type::i8p(ccx)), &fake_sig, f.abi)\n         }\n         _ => {\n             ccx.sess().bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n@@ -514,7 +512,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     GEPi(bcx, llpair,\n                                          &[0u, abi::FAT_PTR_EXTRA]),\n                                     Type::vtable(ccx).ptr_to().ptr_to()));\n-    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0u, n_method + VTABLE_OFFSET]));\n+    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0u, vtable_index + VTABLE_OFFSET]));\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n@@ -558,7 +556,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_object_shim(object_ty={}, trait_id={}, n_method={})\",\n+    debug!(\"trans_object_shim(object_ty={}, trait_id={}, method_offset_in_trait={})\",\n            object_ty.repr(tcx),\n            trait_id.repr(tcx),\n            method_offset_in_trait);\n@@ -587,7 +585,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n             tcx.sess.bug(\"can't create a method shim for an associated type\")\n         }\n     };\n-    let fty = method_ty.fty.subst(tcx, &object_substs);\n+    let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n     let fty = tcx.mk_bare_fn(fty);\n     debug!(\"trans_object_shim: fty={}\", fty.repr(tcx));\n "}, {"sha": "6b6ca600a88310bed56931b48a376d359f3ef1ce", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -103,6 +103,10 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  abi: abi::Abi)\n                                  -> Type\n {\n+    debug!(\"type_of_rust_fn(sig={},abi={:?})\",\n+           sig.repr(cx.tcx()),\n+           abi);\n+\n     let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n     assert!(!sig.variadic); // rust fns are never variadic\n "}, {"sha": "6e8dd6b0ae7551740ba5410cd594cce8dd1a960e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -57,7 +57,7 @@ use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, SpecificRscope,\n              ShiftedRscope, BindingRscope};\n use TypeAndSubsts;\n-use util::common::ErrorReported;\n+use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::DefIdMap;\n use util::ppaux::{self, Repr, UserString};\n \n@@ -268,7 +268,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n         ast::ParenthesizedParameters(ref data) => {\n             span_err!(tcx.sess, path.span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n-            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n+            convert_parenthesized_parameters(this, data)\n         }\n     };\n \n@@ -479,7 +479,9 @@ fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n \n fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n                                           data: &ast::ParenthesizedParameterData)\n-                                          -> Vec<Ty<'tcx>>\n+                                          -> (Vec<ty::Region>,\n+                                              Vec<Ty<'tcx>>,\n+                                              Vec<ConvertedBinding<'tcx>>)\n {\n     let binding_rscope = BindingRscope::new();\n     let inputs = data.inputs.iter()\n@@ -492,15 +494,26 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n \n     let input_ty = ty::mk_tup(this.tcx(), inputs);\n \n-    let output = match data.output {\n-        Some(ref output_ty) => convert_ty_with_lifetime_elision(this,\n-                                                                implied_output_region,\n-                                                                params_lifetimes,\n-                                                                &**output_ty),\n-        None => ty::mk_nil(this.tcx()),\n+    let (output, output_span) = match data.output {\n+        Some(ref output_ty) => {\n+            (convert_ty_with_lifetime_elision(this,\n+                                              implied_output_region,\n+                                              params_lifetimes,\n+                                              &**output_ty),\n+             output_ty.span)\n+        }\n+        None => {\n+            (ty::mk_nil(this.tcx()), data.span)\n+        }\n+    };\n+\n+    let output_binding = ConvertedBinding {\n+        item_name: token::intern(FN_OUTPUT_NAME),\n+        ty: output,\n+        span: output_span\n     };\n \n-    vec![input_ty, output]\n+    (vec![], vec![input_ty], vec![output_binding])\n }\n \n pub fn instantiate_poly_trait_ref<'tcx>(\n@@ -630,7 +643,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                             the crate attributes to enable\");\n             }\n \n-            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n+            convert_parenthesized_parameters(this, data)\n         }\n     };\n "}, {"sha": "bdae34e7878504e5709d59f1288cbef36455b131", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -34,7 +34,7 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            expected.repr(fcx.tcx()));\n \n     let expected_sig_and_kind = expected.to_option(fcx).and_then(|ty| {\n-        deduce_closure_expectations_from_expected_type(fcx, ty)\n+        deduce_expectations_from_expected_type(fcx, ty)\n     });\n \n     match opt_kind {\n@@ -137,36 +137,73 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     fcx.inh.closures.borrow_mut().insert(expr_def_id, closure);\n }\n \n-fn deduce_closure_expectations_from_expected_type<'a,'tcx>(\n+fn deduce_expectations_from_expected_type<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_ty: Ty<'tcx>)\n     -> Option<(ty::FnSig<'tcx>,ty::ClosureKind)>\n {\n     match expected_ty.sty {\n         ty::ty_trait(ref object_type) => {\n-            let trait_ref =\n-                object_type.principal_trait_ref_with_self_ty(fcx.tcx(),\n-                                                             fcx.tcx().types.err);\n-            deduce_closure_expectations_from_trait_ref(fcx, &trait_ref)\n+            let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n+                                                                         fcx.tcx().types.err);\n+            proj_bounds.iter()\n+                       .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n+                       .next()\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n-            deduce_closure_expectations_from_obligations(fcx, vid)\n+            deduce_expectations_from_obligations(fcx, vid)\n         }\n         _ => {\n             None\n         }\n     }\n }\n \n-fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n+fn deduce_expectations_from_obligations<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n-    trait_ref: &ty::PolyTraitRef<'tcx>)\n+    expected_vid: ty::TyVid)\n+    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n+{\n+    let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n+    // Here `expected_ty` is known to be a type inference variable.\n+\n+    fulfillment_cx.pending_obligations()\n+                  .iter()\n+                  .filter_map(|obligation| {\n+                      match obligation.predicate {\n+                          ty::Predicate::Projection(ref proj_predicate) => {\n+                              let trait_ref = proj_predicate.to_poly_trait_ref();\n+                              let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n+                              match self_ty.sty {\n+                                  ty::ty_infer(ty::TyVar(v)) if expected_vid == v => {\n+                                      deduce_expectations_from_projection(fcx, proj_predicate)\n+                                  }\n+                                  _ => {\n+                                      None\n+                                  }\n+                              }\n+                          }\n+                          _ => {\n+                              None\n+                          }\n+                      }\n+                  })\n+                  .next()\n+}\n+\n+/// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n+/// everything we need to know about a closure.\n+fn deduce_expectations_from_projection<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    projection: &ty::PolyProjectionPredicate<'tcx>)\n     -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_closure_expectations_from_object_type({})\",\n-           trait_ref.repr(tcx));\n+    debug!(\"deduce_expectations_from_projection({})\",\n+           projection.repr(tcx));\n+\n+    let trait_ref = projection.to_poly_trait_ref();\n \n     let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n         Some(k) => k,\n@@ -185,7 +222,7 @@ fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n     };\n     debug!(\"input_tys {}\", input_tys.repr(tcx));\n \n-    let ret_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 1);\n+    let ret_param_ty = projection.0.ty;\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n     debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n \n@@ -199,30 +236,3 @@ fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n     return Some((fn_sig, kind));\n }\n \n-fn deduce_closure_expectations_from_obligations<'a,'tcx>(\n-    fcx: &FnCtxt<'a,'tcx>,\n-    expected_vid: ty::TyVid)\n-    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n-{\n-    // Here `expected_ty` is known to be a type inference variable.\n-    for obligation in fcx.inh.fulfillment_cx.borrow().pending_obligations().iter() {\n-        match obligation.predicate {\n-            ty::Predicate::Trait(ref trait_predicate) => {\n-                let trait_ref = trait_predicate.to_poly_trait_ref();\n-                let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n-                match self_ty.sty {\n-                    ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n-                    _ => { continue; }\n-                }\n-\n-                match deduce_closure_expectations_from_trait_ref(fcx, &trait_ref) {\n-                    Some(e) => { return Some(e); }\n-                    None => { }\n-                }\n-            }\n-            _ => { }\n-        }\n-    }\n-\n-    None\n-}"}, {"sha": "31b14ea3f3dec8aba90473b559b4bed584afcd98", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -215,14 +215,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_bounds={}\",\n            impl_bounds.repr(tcx));\n \n-    // // Normalize the associated types in the impl_bounds.\n-    // let traits::Normalized { value: impl_bounds, .. } =\n-    //     traits::normalize(&mut selcx, normalize_cause.clone(), &impl_bounds);\n-\n     // Normalize the associated types in the trait_bounds.\n     let trait_bounds = trait_m.generics.to_bounds(tcx, &trait_to_skol_substs);\n-    // let traits::Normalized { value: trait_bounds, .. } =\n-    //     traits::normalize(&mut selcx, normalize_cause, &trait_bounds);\n \n     // Obtain the predicate split predicate sets for each.\n     let trait_pred = trait_bounds.predicates.split();\n@@ -242,19 +236,18 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     );\n \n     // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n-    let mut trait_param_env = impl_param_env.clone();\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n-    trait_param_env.caller_bounds.predicates = hybrid_preds;\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n+    let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.into_vec());\n+    let trait_param_env = traits::normalize_param_env_or_error(trait_param_env,\n+                                                               normalize_cause.clone());\n \n     debug!(\"compare_impl_method: trait_bounds={}\",\n         trait_param_env.caller_bounds.repr(tcx));\n \n     let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n \n-    let normalize_cause =\n-        traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n-\n     for predicate in impl_pred.fns.into_iter() {\n         let traits::Normalized { value: predicate, .. } =\n             traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);"}, {"sha": "67b055ac946cc0cf56c61ddaa55ca8ea920acd8d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -206,7 +206,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 (impl_polytype.substs, MethodStatic(pick.method_ty.def_id))\n             }\n \n-            probe::ObjectPick(trait_def_id, method_num, real_index) => {\n+            probe::ObjectPick(trait_def_id, method_num, vtable_index) => {\n                 self.extract_trait_ref(self_ty, |this, object_ty, data| {\n                     // The object data has no entry for the Self\n                     // Type. For the purposes of this method call, we\n@@ -233,7 +233,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         trait_ref: upcast_trait_ref,\n                         object_trait_id: trait_def_id,\n                         method_num: method_num,\n-                        real_index: real_index,\n+                        vtable_index: vtable_index,\n                     });\n                     (substs, origin)\n                 })"}, {"sha": "6a3554314e215ac3e85c3910c130a982f62dc373", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -59,7 +59,7 @@ struct Candidate<'tcx> {\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n-    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n+    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* vtable index */ uint),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n@@ -318,7 +318,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n-        self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, m, method_num| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n             let vtable_index =\n@@ -343,7 +343,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n         let bounds: Vec<_> =\n-            self.fcx.inh.param_env.caller_bounds.predicates\n+            self.fcx.inh.param_env.caller_bounds\n             .iter()\n             .filter_map(|predicate| {\n                 match *predicate {\n@@ -365,7 +365,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(bounds.as_slice(), true, |this, poly_trait_ref, m, method_num| {\n+        self.elaborate_bounds(bounds.as_slice(), |this, poly_trait_ref, m, method_num| {\n             let trait_ref =\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n@@ -405,7 +405,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn elaborate_bounds<F>(\n         &mut self,\n         bounds: &[ty::PolyTraitRef<'tcx>],\n-        num_includes_types: bool,\n         mut mk_cand: F,\n     ) where\n         F: for<'b> FnMut(\n@@ -427,8 +426,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             let (pos, method) = match trait_method(tcx,\n                                                    bound_trait_ref.def_id(),\n-                                                   self.method_name,\n-                                                   num_includes_types) {\n+                                                   self.method_name) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n@@ -697,8 +695,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n \n-        let caller_predicates =\n-            self.fcx.inh.param_env.caller_bounds.predicates.as_slice().to_vec();\n+        let caller_predicates = self.fcx.inh.param_env.caller_bounds.clone();\n         for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n                           .filter_map(|p| p.to_opt_poly_trait_ref())\n                           .filter(|b| b.def_id() == trait_def_id)\n@@ -1140,19 +1137,13 @@ fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// index (or `None`, if no such method).\n fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       trait_def_id: ast::DefId,\n-                      method_name: ast::Name,\n-                      num_includes_types: bool)\n+                      method_name: ast::Name)\n                       -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n     trait_items\n         .iter()\n-        .filter(|item|\n-            num_includes_types || match *item {\n-                &ty::MethodTraitItem(_) => true,\n-                &ty::TypeTraitItem(_) => false\n-            })\n         .enumerate()\n         .find(|&(_, ref item)| item.name() == method_name)\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))"}, {"sha": "fe3d9157be48b1aa806699d2677bfef3dda66e8e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -467,7 +467,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            body: &ast::Block,\n                            id: ast::NodeId,\n                            raw_fty: Ty<'tcx>,\n-                           param_env: ty::ParameterEnvironment<'a, 'tcx>) {\n+                           param_env: ty::ParameterEnvironment<'a, 'tcx>)\n+{\n     match raw_fty.sty {\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);"}, {"sha": "b039f3ab8e44de2b069a7a1fd08d2e0c2fb4ea0f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -1482,7 +1482,7 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let mut param_bounds =\n         ty::required_region_bounds(rcx.tcx(),\n                                    generic.to_ty(rcx.tcx()),\n-                                   param_env.caller_bounds.predicates.as_slice().to_vec());\n+                                   param_env.caller_bounds.clone());\n \n     // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n     match *generic {"}, {"sha": "db226295cd970f26538ddf93ee0ca89f4556402b", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -127,6 +127,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         reject_non_type_param_bounds(ccx.tcx, item.span, &type_scheme.generics);\n         let param_env =\n             ty::construct_parameter_environment(ccx.tcx,\n+                                                item.span,\n                                                 &type_scheme.generics,\n                                                 item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);"}, {"sha": "63ad47ff31f6115c5e7add1e0422a46b0e0508c4", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -818,6 +818,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     trait_def.generics.regions.get_slice(subst::TypeSpace),\n                     trait_ref.substs(),\n                     variance);\n+\n+                let projections = data.projection_bounds_with_self_ty(self.tcx(),\n+                                                                      self.tcx().types.err);\n+                for projection in projections.iter() {\n+                    self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n+                }\n             }\n \n             ty::ty_param(ref data) => {"}, {"sha": "d2080419469510ebec759567e5208d3b365fee22", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -536,7 +536,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n     match (trait_did, cx.tcx_opt()) {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n         (Some(did), Some(ref tcx)) if tcx.lang_items.fn_trait_kind(did).is_some() => {\n-            assert_eq!(types.len(), 2);\n+            assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n                 sty::ty_tup(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n                 _ => {\n@@ -547,10 +547,12 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n                     }\n                 }\n             };\n-            let output = match types[1].sty {\n-                sty::ty_tup(ref v) if v.is_empty() => None, // -> ()\n-                _ => Some(types[1].clean(cx))\n-            };\n+            let output = None;\n+            // FIXME(#20299) return type comes from a projection now\n+            // match types[1].sty {\n+            //     sty::ty_tup(ref v) if v.is_empty() => None, // -> ()\n+            //     _ => Some(types[1].clean(cx))\n+            // };\n             PathParameters::Parenthesized {\n                 inputs: inputs,\n                 output: output"}, {"sha": "4dada5bc81ec23f96fb65529c23d9652236c63c8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -347,6 +347,9 @@ impl AngleBracketedParameterData {\n /// A path like `Foo(A,B) -> C`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct ParenthesizedParameterData {\n+    /// Overall span\n+    pub span: Span,\n+\n     /// `(A,B)`\n     pub inputs: Vec<P<Ty>>,\n "}, {"sha": "a1362f5382c979b4f3864039181f5e7e2fd5e434", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -536,9 +536,10 @@ pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedPara\n                                                          fld: &mut T)\n                                                          -> ParenthesizedParameterData\n {\n-    let ParenthesizedParameterData { inputs, output } = data;\n+    let ParenthesizedParameterData { inputs, output, span } = data;\n     ParenthesizedParameterData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n-                                 output: output.map(|ty| fld.fold_ty(ty)) }\n+                                 output: output.map(|ty| fld.fold_ty(ty)),\n+                                 span: fld.new_span(span) }\n }\n \n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {"}, {"sha": "4c1ae532d13cdb151064ff0eabfe4400fb92f8e8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -1796,6 +1796,8 @@ impl<'a> Parser<'a> {\n                     bindings: OwnedSlice::from_vec(bindings),\n                 })\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n+                let lo = self.last_span.lo;\n+\n                 let inputs = self.parse_seq_to_end(\n                     &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n@@ -1807,9 +1809,12 @@ impl<'a> Parser<'a> {\n                     None\n                 };\n \n+                let hi = self.last_span.hi;\n+\n                 ast::ParenthesizedParameters(ast::ParenthesizedParameterData {\n+                    span: mk_sp(lo, hi),\n                     inputs: inputs,\n-                    output: output_ty\n+                    output: output_ty,\n                 })\n             } else {\n                 ast::PathParameters::none()"}, {"sha": "04d73cc36f04cb2fd1d23945973a45c0a0aebd1c", "filename": "src/test/compile-fail/borrowck-overloaded-call.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -17,7 +17,9 @@ struct SFn {\n     y: isize,\n }\n \n-impl Fn<(isize,),isize> for SFn {\n+impl Fn<(isize,)> for SFn {\n+    type Output = isize;\n+\n     extern \"rust-call\" fn call(&self, (z,): (isize,)) -> isize {\n         self.x * self.y * z\n     }\n@@ -28,7 +30,9 @@ struct SFnMut {\n     y: isize,\n }\n \n-impl FnMut<(isize,),isize> for SFnMut {\n+impl FnMut<(isize,)> for SFnMut {\n+    type Output = isize;\n+\n     extern \"rust-call\" fn call_mut(&mut self, (z,): (isize,)) -> isize {\n         self.x * self.y * z\n     }\n@@ -38,7 +42,9 @@ struct SFnOnce {\n     x: String,\n }\n \n-impl FnOnce<(String,),usize> for SFnOnce {\n+impl FnOnce<(String,)> for SFnOnce {\n+    type Output = usize;\n+\n     extern \"rust-call\" fn call_once(self, (z,): (String,)) -> usize {\n         self.x.len() + z.len()\n     }"}, {"sha": "db3373ea02772285a8300795963091b2e992609b", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -16,5 +16,7 @@ fn is_fn<F>(_: F) where F: Fn() {}\n fn main() {\n     // extern functions are extern \"C\" fn\n     let _x: extern \"C\" fn() = f; // OK\n-    is_fn(f); //~ ERROR the trait `core::ops::Fn()` is not implemented for the type `extern \"C\" fn()\n+    is_fn(f);\n+    //~^ ERROR the trait `core::ops::Fn<()>` is not implemented for the type `extern \"C\" fn()\n+    //~| ERROR the trait `core::ops::Fn<()>` is not implemented for the type `extern \"C\" fn()\n }"}, {"sha": "e5e5ddadafccf8014d09b675f53a1b093c896e4c", "filename": "src/test/compile-fail/feature-gate-unboxed-closures-manual-impls.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -8,18 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that manual impls of the `Fn` traits are not possible without\n+// a feature gate. In fact, the specialized check for these cases\n+// never triggers (yet), because they encounter other problems around\n+// angle bracket vs parentheses notation.\n+\n #![allow(dead_code)]\n \n struct Foo;\n-impl Fn() for Foo { //~ ERROR manual implementations of `Fn` are experimental\n+impl Fn<()> for Foo {\n+    //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n+    type Output = ();\n+\n+    extern \"rust-call\" fn call(&self, args: ()) -> () {}\n+}\n+struct Foo1;\n+impl Fn() for Foo1 {\n+    //~^ ERROR associated type bindings are not allowed here\n+\n     extern \"rust-call\" fn call(&self, args: ()) -> () {}\n }\n struct Bar;\n-impl FnMut() for Bar { //~ ERROR manual implementations of `FnMut` are experimental\n+impl FnMut<()> for Bar {\n+    //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n+    type Output = ();\n+\n     extern \"rust-call\" fn call_mut(&self, args: ()) -> () {}\n }\n struct Baz;\n-impl FnOnce() for Baz { //~ ERROR manual implementations of `FnOnce` are experimental\n+impl FnOnce<()> for Baz {\n+    //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n+    type Output = ();\n+\n     extern \"rust-call\" fn call_once(&self, args: ()) -> () {}\n }\n "}, {"sha": "460e05c8438cde27612d43a109ee762b1026e1c7", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -34,5 +34,7 @@ fn main() {\n     //~| expected ()\n     //~| found box\n \n-    needs_fn(1is); //~ ERROR `core::ops::Fn(isize) -> isize`\n+    needs_fn(1is);\n+    //~^ ERROR `core::ops::Fn<(isize,)>`\n+    //~| ERROR `core::ops::Fn<(isize,)>`\n }"}, {"sha": "977586483b031568c4f2ef08230daa3975b35aad", "filename": "src/test/compile-fail/issue-15094.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -16,7 +16,9 @@ struct Debuger<T> {\n     x: T\n }\n \n-impl<T: fmt::Debug> ops::Fn<(), ()> for Debuger<T> {\n+impl<T: fmt::Debug> ops::Fn<(),> for Debuger<T> {\n+    type Output = ();\n+\n     fn call(&self, _args: ()) {\n //~^ ERROR `call` has an incompatible type for trait: expected \"rust-call\" fn, found \"Rust\" fn\n         println!(\"{:?}\", self.x);"}, {"sha": "84800218efc9402065b41f21860d6fa1fb5a854c", "filename": "src/test/compile-fail/issue-17545.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fissue-17545.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fissue-17545.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17545.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unboxed_closures)]\n \n-pub fn foo<'a, F: Fn<(&'a (),), ()>>(bar: F) {\n+pub fn foo<'a, F: Fn(&'a ())>(bar: F) {\n     bar.call((\n         &(), //~ ERROR borrowed value does not live long enough\n     ));"}, {"sha": "61752e62abdefe90e80100478f48b9f6c5246bba", "filename": "src/test/compile-fail/overloaded-calls-bad.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -17,7 +17,9 @@ struct S {\n     y: isize,\n }\n \n-impl FnMut<(isize,),isize> for S {\n+impl FnMut<(isize,)> for S {\n+    type Output = isize;\n+\n     extern \"rust-call\" fn call_mut(&mut self, (z,): (isize,)) -> isize {\n         self.x * self.y * z\n     }"}, {"sha": "41ecf7146138dbb8d7ba1503a4d02ce0fe608977", "filename": "src/test/compile-fail/overloaded-calls-nontuple.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -17,7 +17,8 @@ struct S {\n     y: isize,\n }\n \n-impl FnMut<isize,isize> for S {\n+impl FnMut<isize> for S {\n+    type Output = isize;\n     extern \"rust-call\" fn call_mut(&mut self, z: isize) -> isize {\n         self.x + self.y + z\n     }"}, {"sha": "2a246124f6f9d5163eadf2b3d0960baa3ec266c2", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-4.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n \n-struct invariant<'a> {\n+struct Invariant<'a> {\n     f: Box<for<'b> FnOnce() -> &'b mut &'a isize + 'static>,\n }\n \n-fn to_same_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'r> = bi;\n+fn to_same_lifetime<'r>(bi: Invariant<'r>) {\n+    let bj: Invariant<'r> = bi;\n }\n \n-fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n+fn to_longer_lifetime<'r>(bi: Invariant<'r>) -> Invariant<'static> {\n     bi //~ ERROR mismatched types\n }\n "}, {"sha": "3536244f011654d482dc5f8544e5f01fa7e1a796", "filename": "src/test/compile-fail/unboxed-closure-feature-gate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -11,7 +11,8 @@\n // Check that parenthetical notation is feature-gated except with the\n // `Fn` traits.\n \n-trait Foo<A,R> {\n+trait Foo<A> {\n+    type Output;\n }\n \n fn main() {"}, {"sha": "870377bc1add760e811680f0e3e4740bbe549d6d", "filename": "src/test/compile-fail/unboxed-closure-sugar-default.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -14,8 +14,9 @@\n #![feature(unboxed_closures)]\n #![allow(dead_code)]\n \n-trait Foo<T,U,V=T> {\n-    fn dummy(&self, t: T, u: U, v: V);\n+trait Foo<T,V=T> {\n+    type Output;\n+    fn dummy(&self, t: T, v: V);\n }\n \n trait Eq<X: ?Sized> { }\n@@ -24,14 +25,14 @@ fn eq<A: ?Sized,B: ?Sized>() where A : Eq<B> { }\n \n fn test<'a,'b>() {\n     // Parens are equivalent to omitting default in angle.\n-    eq::< Foo<(isize,),()>,               Foo(isize)                      >();\n+    eq::< Foo<(isize,),Output=()>,                   Foo(isize)                      >();\n \n     // In angle version, we supply something other than the default\n-    eq::< Foo<(isize,),(),isize>,           Foo(isize)                      >();\n+    eq::< Foo<(isize,),isize,Output=()>,      Foo(isize)                      >();\n     //~^ ERROR not implemented\n \n     // Supply default explicitly.\n-    eq::< Foo<(isize,),(),(isize,)>,        Foo(isize)                      >();\n+    eq::< Foo<(isize,),(isize,),Output=()>,   Foo(isize)                      >();\n }\n \n fn main() { }"}, {"sha": "dc5576aee650a56ed814b9bbcd9abc09d5f24723", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -16,8 +16,9 @@\n #![feature(unboxed_closures)]\n #![allow(dead_code)]\n \n-trait Foo<T,U> {\n-    fn dummy(&self, t: T, u: U);\n+trait Foo<T> {\n+    type Output;\n+    fn dummy(&self, t: T, u: Self::Output);\n }\n \n trait Eq<X: ?Sized> { }\n@@ -26,31 +27,32 @@ fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n \n fn test<'a,'b>() {\n     // No errors expected:\n-    eq::< Foo<(),()>,                   Foo()                         >();\n-    eq::< Foo<(isize,),()>,               Foo(isize)                      >();\n-    eq::< Foo<(isize,usize),()>,           Foo(isize,usize)                 >();\n-    eq::< Foo<(isize,usize),usize>,         Foo(isize,usize) -> usize         >();\n-    eq::< Foo<(&'a isize,&'b usize),usize>, Foo(&'a isize,&'b usize) -> usize >();\n+    eq::< Foo<(),Output=()>,                       Foo()                         >();\n+    eq::< Foo<(isize,),Output=()>,                 Foo(isize)                      >();\n+    eq::< Foo<(isize,usize),Output=()>,            Foo(isize,usize)                 >();\n+    eq::< Foo<(isize,usize),Output=usize>,         Foo(isize,usize) -> usize         >();\n+    eq::< Foo<(&'a isize,&'b usize),Output=usize>, Foo(&'a isize,&'b usize) -> usize >();\n \n     // Test that anonymous regions in `()` form are equivalent\n     // to fresh bound regions, and that we can intermingle\n     // named and anonymous as we choose:\n-    eq::< for<'x,'y> Foo<(&'x isize,&'y usize),usize>,\n+    eq::< for<'x,'y> Foo<(&'x isize,&'y usize),Output=usize>,\n           for<'x,'y> Foo(&'x isize,&'y usize) -> usize            >();\n-    eq::< for<'x,'y> Foo<(&'x isize,&'y usize),usize>,\n+    eq::< for<'x,'y> Foo<(&'x isize,&'y usize),Output=usize>,\n           for<'x> Foo(&'x isize,&usize) -> usize                  >();\n-    eq::< for<'x,'y> Foo<(&'x isize,&'y usize),usize>,\n+    eq::< for<'x,'y> Foo<(&'x isize,&'y usize),Output=usize>,\n           for<'y> Foo(&isize,&'y usize) -> usize                  >();\n-    eq::< for<'x,'y> Foo<(&'x isize,&'y usize),usize>,\n+    eq::< for<'x,'y> Foo<(&'x isize,&'y usize),Output=usize>,\n           Foo(&isize,&usize) -> usize                             >();\n \n     // lifetime elision\n-    eq::< for<'x> Foo<(&'x isize,), &'x isize>,\n+    eq::< for<'x> Foo<(&'x isize,), Output=&'x isize>,\n           Foo(&isize) -> &isize                                   >();\n \n     // Errors expected:\n-    eq::< Foo<(),()>,                   Foo(char)                     >();\n-    //~^ ERROR not implemented\n+    eq::< Foo<(),Output=()>,\n+          Foo(char)                                               >();\n+    //~^^ ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "d2f781bba11eaa3d30d8c5121d05480a90540425", "filename": "src/test/compile-fail/unboxed-closure-sugar-lifetime-elision.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -16,18 +16,19 @@\n #![feature(unboxed_closures)]\n #![allow(dead_code)]\n \n-trait Foo<T,U> {\n-    fn dummy(&self, t: T, u: U);\n+trait Foo<T> {\n+    type Output;\n+    fn dummy(&self, t: T);\n }\n \n trait Eq<X: ?Sized> { }\n impl<X: ?Sized> Eq<X> for X { }\n fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n \n fn main() {\n-    eq::< for<'a> Foo<(&'a isize,), &'a isize>,\n+    eq::< for<'a> Foo<(&'a isize,), Output=&'a isize>,\n           Foo(&isize) -> &isize                                   >();\n-    eq::< for<'a> Foo<(&'a isize,), (&'a isize, &'a isize)>,\n+    eq::< for<'a> Foo<(&'a isize,), Output=(&'a isize, &'a isize)>,\n           Foo(&isize) -> (&isize, &isize)                           >();\n \n     let _: Foo(&isize, &usize) -> &usize; //~ ERROR missing lifetime specifier"}, {"sha": "1f0d5aae36db5abaefa64597eff7537312522474", "filename": "src/test/compile-fail/unboxed-closure-sugar-not-used-on-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -11,11 +11,11 @@\n \n // Test that the `Fn` traits require `()` form without a feature gate.\n \n-fn bar1(x: &Fn<(),()>) {\n+fn bar1(x: &Fn<()>) {\n     //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family\n }\n \n-fn bar2<T>(x: &T) where T: Fn<(),()> {\n+fn bar2<T>(x: &T) where T: Fn<()> {\n     //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family\n }\n "}, {"sha": "75688e44e80761c2758012316a6cb6e655602c8f", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -17,8 +17,9 @@\n \n use std::marker;\n \n-trait Foo<'a,T,U> {\n-    fn dummy(&'a self) -> &'a (T,U);\n+trait Foo<'a,T> {\n+    type Output;\n+    fn dummy(&'a self) -> &'a (T,Self::Output);\n }\n \n trait Eq<X: ?Sized> { }\n@@ -29,16 +30,17 @@ fn same_type<A,B:Eq<A>>(a: A, b: B) { }\n \n fn test<'a,'b>() {\n     // Parens are equivalent to omitting default in angle.\n-    eq::< Foo<(isize,),()>,               Foo(isize)                      >();\n+    eq::< Foo<(isize,),Output=()>,               Foo(isize)                      >();\n \n     // Here we specify 'static explicitly in angle-bracket version.\n     // Parenthesized winds up getting inferred.\n-    eq::< Foo<'static, (isize,),()>,      Foo(isize)                      >();\n+    eq::< Foo<'static, (isize,),Output=()>,      Foo(isize)                      >();\n }\n \n-fn test2(x: &Foo<(isize,),()>, y: &Foo(isize)) {\n+fn test2(x: &Foo<(isize,),Output=()>, y: &Foo(isize)) {\n     // Here, the omitted lifetimes are expanded to distinct things.\n     same_type(x, y) //~ ERROR cannot infer\n+                    //~^ ERROR cannot infer\n }\n \n fn main() { }"}, {"sha": "a3991a87b78f8a1caa47891adc7c43c2c5d3f4ee", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct-1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -11,13 +11,14 @@\n \n // Test that parentheses form doesn't work with struct types appearing in local variables.\n \n-struct Bar<A,R> {\n-    f: A, r: R\n+struct Bar<A> {\n+    f: A\n }\n \n fn bar() {\n     let x: Box<Bar()> = panic!();\n     //~^ ERROR parenthesized parameters may only be used with a trait\n+    //~^^ ERROR associated type bindings are not allowed here\n }\n \n fn main() { }"}, {"sha": "ad85cdcaa03a15246be7261f407f6ab69ce5b4d9", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -10,12 +10,13 @@\n \n // Test that parentheses form doesn't work with struct types appearing in argument types.\n \n-struct Bar<A,R> {\n-    f: A, r: R\n+struct Bar<A> {\n+    f: A\n }\n \n fn foo(b: Box<Bar()>) {\n     //~^ ERROR parenthesized parameters may only be used with a trait\n+    //~^^ ERROR associated type bindings are not allowed here\n }\n \n fn main() { }"}, {"sha": "c9837da58e75a1d4a86801075a806d1c873199bf", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -12,7 +12,7 @@\n \n trait One<A> { fn foo(&self) -> A; }\n \n-fn foo(_: &One()) //~ ERROR wrong number of type arguments\n+fn foo(_: &One()) //~ ERROR no associated type `Output` defined in `One<()>`\n {}\n \n fn main() { }"}, {"sha": "e63f510b890d7902d248e491a2cb43097f291404", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -13,7 +13,7 @@\n trait Trait {}\n \n fn f<F:Trait(isize) -> isize>(x: F) {}\n-//~^ ERROR wrong number of type arguments: expected 0, found 2\n+//~^ ERROR wrong number of type arguments: expected 0, found 1\n \n fn main() {}\n "}, {"sha": "bbafd5109edff0b25cbdf00b3ecfae7dd42b280d", "filename": "src/test/compile-fail/unboxed-closures-fnmut-as-fn.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -18,7 +18,9 @@ use std::ops::{Fn,FnMut,FnOnce};\n \n struct S;\n \n-impl FnMut<(isize,),isize> for S {\n+impl FnMut<(isize,)> for S {\n+    type Output = isize;\n+\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (isize,)) -> isize {\n         x * x\n     }\n@@ -29,6 +31,8 @@ fn call_it<F:Fn(isize)->isize>(f: &F, x: isize) -> isize {\n }\n \n fn main() {\n-    let x = call_it(&S, 22); //~ ERROR not implemented\n+    let x = call_it(&S, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n "}, {"sha": "23f7ee2b0101d78cca2d2db9fcaa4702ac8e33bd", "filename": "src/test/compile-fail/unboxed-closures-unsafe-extern-fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -21,7 +21,9 @@ fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n \n fn a() {\n-    let x = call_it(&square, 22); //~ ERROR not implemented\n+    let x = call_it(&square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn b() {"}, {"sha": "305dd33e5a05a950b03280e36cc29675ff027a6b", "filename": "src/test/compile-fail/unboxed-closures-vtable-mismatch.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -12,13 +12,15 @@\n \n use std::ops::FnMut;\n \n-fn call_it<F:FnMut<(isize,isize),isize>>(y: isize, mut f: F) -> isize {\n+fn call_it<F:FnMut(isize,isize)->isize>(y: isize, mut f: F) -> isize {\n     f(2, y)\n }\n \n pub fn main() {\n     let f = |&mut: x: usize, y: isize| -> isize { (x as isize) + y };\n-    let z = call_it(3, f);  //~ ERROR type mismatch\n+    let z = call_it(3, f);\n+    //~^ ERROR type mismatch\n+    //~| ERROR type mismatch\n     println!(\"{}\", z);\n }\n "}, {"sha": "96619bef36fd5fb400deeec4c343351183b7e74a", "filename": "src/test/compile-fail/unboxed-closures-wrong-abi.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -21,7 +21,9 @@ fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n \n fn a() {\n-    let x = call_it(&square, 22); //~ ERROR not implemented\n+    let x = call_it(&square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn b() {"}, {"sha": "ebcbdbbc006df83585ba4d02dad8817285a1109d", "filename": "src/test/compile-fail/unboxed-closures-wrong-arg-type-extern-fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -22,7 +22,9 @@ fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n \n fn a() {\n-    let x = call_it(&square, 22); //~ ERROR not implemented\n+    let x = call_it(&square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn b() {"}, {"sha": "2ada0dd22e75f4a160cdbc28aa8972a451b6cac5", "filename": "src/test/compile-fail/unboxed-closures-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -18,5 +18,6 @@ fn main() {\n     let z: isize = 7;\n     assert_eq!(c(|&mut: x: isize, y| x + y + z), 10);\n     //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n "}, {"sha": "972ec96f5f27ba0dece011768f6358d95b8bb02a", "filename": "src/test/compile-fail/variance-object-types.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that Cell is considered invariant with respect to its\n+// type.\n+\n+use std::cell::Cell;\n+\n+// For better or worse, associated types are invariant, and hence we\n+// get an invariant result for `'a`.\n+#[rustc_variance]\n+struct Foo<'a> { //~ ERROR regions=[[o];[];[]]\n+    x: Box<Fn(i32) -> &'a i32 + 'static>\n+}\n+\n+fn main() {\n+}"}, {"sha": "ced44250e4d3907a75fd9ce6e60147eae1825508", "filename": "src/test/run-pass/associated-types-issue-21212.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fassociated-types-issue-21212.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fassociated-types-issue-21212.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-issue-21212.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #21212: an overflow occurred during trait\n+// checking where normalizing `Self::Input` led to normalizing the\n+// where clauses in the environment which in turn required normalizing\n+// `Self::Input`.\n+\n+pub trait Parser {\n+    type Input;\n+\n+    fn parse(input: <Self as Parser>::Input) {\n+        panic!()\n+    }\n+}\n+impl <P> Parser for P  {\n+    type Input = ();\n+}\n+\n+fn main() {\n+}"}, {"sha": "dd5814f875b0886e5490fed3a64bf567dc80a10e", "filename": "src/test/run-pass/associated-types-normalize-in-bounds-binding.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we normalize associated types that appear in a bound that\n+// contains a binding. Issue #21664.\n+\n+#![allow(dead_code)]\n+\n+pub trait Integral {\n+    type Opposite;\n+}\n+\n+impl Integral for i32 {\n+    type Opposite = u32;\n+}\n+\n+impl Integral for u32 {\n+    type Opposite = i32;\n+}\n+\n+pub trait FnLike<A> {\n+    type R;\n+}\n+\n+fn foo<T>()\n+    where T : FnLike<<i32 as Integral>::Opposite, R=bool>\n+{\n+    bar::<T>();\n+}\n+\n+fn bar<T>()\n+    where T : FnLike<u32, R=bool>\n+{}\n+\n+fn main() { }"}, {"sha": "fae83d4aa6563632eca12028ad420553141ded4e", "filename": "src/test/run-pass/bare-fn-implements-fn-mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -12,15 +12,15 @@\n \n use std::ops::FnMut;\n \n-fn call_f<F:FnMut<(),()>>(mut f: F) {\n+fn call_f<F:FnMut()>(mut f: F) {\n     f();\n }\n \n fn f() {\n     println!(\"hello\");\n }\n \n-fn call_g<G:FnMut<(String,String),String>>(mut g: G, x: String, y: String)\n+fn call_g<G:FnMut(String,String) -> String>(mut g: G, x: String, y: String)\n           -> String {\n     g(x, y)\n }"}, {"sha": "d5307c09103a1351c01d24a2e5a71bd3658c9a7f", "filename": "src/test/run-pass/hrtb-parse.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -22,23 +22,23 @@ trait Get<A,R> {\n // Parse HRTB with explicit `for` in a where-clause:\n \n fn foo00<T>(t: T)\n-    where T : for<'a> Get<&'a int, &'a int>\n+    where T : for<'a> Get<&'a i32, &'a i32>\n {\n }\n \n-fn foo01<T: for<'a> Get<&'a int, &'a int>>(t: T)\n+fn foo01<T: for<'a> Get<&'a i32, &'a i32>>(t: T)\n {\n }\n \n // Parse HRTB with explicit `for` in various sorts of types:\n \n-fn foo10(t: Box<for<'a> Get<int, int>>) { }\n-fn foo11(t: Box<for<'a> Get(int) -> int>) { }\n+fn foo10(t: Box<for<'a> Get<i32, i32>>) { }\n+fn foo11(t: Box<for<'a> Fn(i32) -> i32>) { }\n \n-fn foo20(t: for<'a> fn(int) -> int) { }\n-fn foo21(t: for<'a> unsafe fn(int) -> int) { }\n-fn foo22(t: for<'a> extern \"C\" fn(int) -> int) { }\n-fn foo23(t: for<'a> unsafe extern \"C\" fn(int) -> int) { }\n+fn foo20(t: for<'a> fn(i32) -> i32) { }\n+fn foo21(t: for<'a> unsafe fn(i32) -> i32) { }\n+fn foo22(t: for<'a> extern \"C\" fn(i32) -> i32) { }\n+fn foo23(t: for<'a> unsafe extern \"C\" fn(i32) -> i32) { }\n \n fn main() {\n }"}, {"sha": "1b62a8e809c89dd2b4842ab4a96372f6a6ddbe5d", "filename": "src/test/run-pass/hrtb-trait-object-paren-notation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fhrtb-trait-object-paren-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fhrtb-trait-object-paren-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-trait-object-paren-notation.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -16,7 +16,7 @@ trait FnLike<A,R> {\n     fn call(&self, arg: A) -> R;\n }\n \n-type FnObject<'b> = for<'a> FnLike(&'a int) -> (&'a int) + 'b;\n+type FnObject<'b> = for<'a> FnLike<(&'a i32,), &'a i32> + 'b;\n \n struct Identity;\n "}, {"sha": "81a8b29461c78a6a82abfa9ea8ec0a032ea79ac2", "filename": "src/test/run-pass/issue-13655.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-13655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-13655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13655.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -13,7 +13,8 @@ use std::ops::Fn;\n \n struct Foo<T>(T);\n \n-impl<T: Copy> Fn<(), T> for Foo<T> {\n+impl<T: Copy> Fn<()> for Foo<T> {\n+    type Output = T;\n     extern \"rust-call\" fn call(&self, _: ()) -> T {\n       match *self {\n         Foo(t) => t"}, {"sha": "814a743648d3f6b0534f5af80551a326816ae6b3", "filename": "src/test/run-pass/issue-14958.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14958.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -14,7 +14,8 @@ trait Foo {}\n \n struct Bar;\n \n-impl<'a> std::ops::Fn<(&'a (Foo+'a),), ()> for Bar {\n+impl<'a> std::ops::Fn<(&'a (Foo+'a),)> for Bar {\n+    type Output = ();\n     extern \"rust-call\" fn call(&self, _: (&'a Foo,)) {}\n }\n "}, {"sha": "33281d7d78ffb178b8bebb99ecf60ccab0eaaf24", "filename": "src/test/run-pass/issue-14959.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14959.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -33,7 +33,9 @@ impl Alloy {\n     }\n }\n \n-impl<'a, 'b> Fn<(&'b mut (Response+'b),),()> for SendFile<'a> {\n+impl<'a, 'b> Fn<(&'b mut (Response+'b),)> for SendFile<'a> {\n+    type Output = ();\n+\n     extern \"rust-call\" fn call(&self, (_res,): (&'b mut (Response+'b),)) {}\n }\n "}, {"sha": "e82add61aa3bb51aa1532b02379316915ade8925", "filename": "src/test/run-pass/issue-16668.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-16668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-16668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16668.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -15,7 +15,7 @@\n #![feature(unboxed_closures)]\n \n struct Parser<'a, I, O> {\n-    parse: Box<FnMut<(I,), Result<O, String>> + 'a>\n+    parse: Box<FnMut(I) -> Result<O, String> + 'a>\n }\n \n impl<'a, I, O: 'a> Parser<'a, I, O> {"}, {"sha": "389baecafd14402eaa5776c593746d897035f428", "filename": "src/test/run-pass/issue-16739.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16739.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -15,27 +15,30 @@\n // Test that unboxing shim for calling rust-call ABI methods through a\n // trait box works and does not cause an ICE.\n \n-struct Foo { foo: uint }\n+struct Foo { foo: u32 }\n \n-impl FnMut<(), uint> for Foo {\n-    extern \"rust-call\" fn call_mut(&mut self, _: ()) -> uint { self.foo }\n+impl FnMut<()> for Foo {\n+    type Output = u32;\n+    extern \"rust-call\" fn call_mut(&mut self, _: ()) -> u32 { self.foo }\n }\n \n-impl FnMut<(uint,), uint> for Foo {\n-    extern \"rust-call\" fn call_mut(&mut self, (x,): (uint,)) -> uint { self.foo + x }\n+impl FnMut<(u32,)> for Foo {\n+    type Output = u32;\n+    extern \"rust-call\" fn call_mut(&mut self, (x,): (u32,)) -> u32 { self.foo + x }\n }\n \n-impl FnMut<(uint, uint), uint> for Foo {\n-    extern \"rust-call\" fn call_mut(&mut self, (x, y): (uint, uint)) -> uint { self.foo + x + y }\n+impl FnMut<(u32,u32)> for Foo {\n+    type Output = u32;\n+    extern \"rust-call\" fn call_mut(&mut self, (x, y): (u32, u32)) -> u32 { self.foo + x + y }\n }\n \n fn main() {\n-    let mut f = box Foo { foo: 42 } as Box<FnMut<(), uint>>;\n+    let mut f = box Foo { foo: 42 } as Box<FnMut() -> u32>;\n     assert_eq!(f.call_mut(()), 42);\n \n-    let mut f = box Foo { foo: 40 } as Box<FnMut<(uint,), uint>>;\n+    let mut f = box Foo { foo: 40 } as Box<FnMut(u32) -> u32>;\n     assert_eq!(f.call_mut((2,)), 42);\n \n-    let mut f = box Foo { foo: 40 } as Box<FnMut<(uint, uint), uint>>;\n+    let mut f = box Foo { foo: 40 } as Box<FnMut(u32, u32) -> u32>;\n     assert_eq!(f.call_mut((1, 1)), 42);\n }"}, {"sha": "8da753acb966ef292e0d982d86273cb5eaf93701", "filename": "src/test/run-pass/object-method-numbering.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fobject-method-numbering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Fobject-method-numbering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-method-numbering.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for using an object with an associated type binding as the\n+// instantiation for a generic type with a bound.\n+\n+trait SomeTrait {\n+    type SomeType;\n+\n+    fn get(&self) -> Self::SomeType;\n+}\n+\n+fn get_int<T:SomeTrait<SomeType=i32>+?Sized>(x: &T) -> i32 {\n+    x.get()\n+}\n+\n+impl SomeTrait for i32 {\n+    type SomeType = i32;\n+    fn get(&self) -> i32 {\n+        *self\n+    }\n+}\n+\n+fn main() {\n+    let x = 22_i32;\n+    let x1: &SomeTrait<SomeType=i32> = &x;\n+    let y = get_int(x1);\n+    assert_eq!(x, y);\n+}"}, {"sha": "2838909c1be625b16f102c1963932bd5f2257845", "filename": "src/test/run-pass/overloaded-calls-param-vtables.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -17,13 +17,15 @@ use std::ops::Add;\n \n struct G<A>;\n \n-impl<'a, A: Add<int, Output=int>> Fn<(A,), int> for G<A> {\n-    extern \"rust-call\" fn call(&self, (arg,): (A,)) -> int {\n+impl<'a, A: Add<i32, Output=i32>> Fn<(A,)> for G<A> {\n+    type Output = i32;\n+\n+    extern \"rust-call\" fn call(&self, (arg,): (A,)) -> i32 {\n         arg.add(1)\n     }\n }\n \n fn main() {\n     // ICE trigger\n-    G(1i);\n+    G(1_i32);\n }"}, {"sha": "f9e838d9b3d342cd9618a26b2b690eeb17b0d273", "filename": "src/test/run-pass/overloaded-calls-simple.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -13,34 +13,37 @@\n use std::ops::{Fn, FnMut, FnOnce};\n \n struct S1 {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-impl FnMut<(int,),int> for S1 {\n-    extern \"rust-call\" fn call_mut(&mut self, (z,): (int,)) -> int {\n+impl FnMut<(i32,)> for S1 {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_mut(&mut self, (z,): (i32,)) -> i32 {\n         self.x * self.y * z\n     }\n }\n \n struct S2 {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-impl Fn<(int,),int> for S2 {\n-    extern \"rust-call\" fn call(&self, (z,): (int,)) -> int {\n+impl Fn<(i32,)> for S2 {\n+    type Output = i32;\n+    extern \"rust-call\" fn call(&self, (z,): (i32,)) -> i32 {\n         self.x * self.y * z\n     }\n }\n \n struct S3 {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-impl FnOnce<(int,int),int> for S3 {\n-    extern \"rust-call\" fn call_once(self, (z,zz): (int,int)) -> int {\n+impl FnOnce<(i32,i32)> for S3 {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(self, (z,zz): (i32,i32)) -> i32 {\n         self.x * self.y * z * zz\n     }\n }"}, {"sha": "ce7395673b390a7c8ddd2199b59fe3ae675d21ad", "filename": "src/test/run-pass/overloaded-calls-zero-args.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -13,12 +13,13 @@\n use std::ops::{FnMut};\n \n struct S {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-impl FnMut<(),int> for S {\n-    extern \"rust-call\" fn call_mut(&mut self, (): ()) -> int {\n+impl FnMut<()> for S {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_mut(&mut self, (): ()) -> i32 {\n         self.x * self.y\n     }\n }"}, {"sha": "27528ca5d5663671c3a2fdfd4114385d6479b752", "filename": "src/test/run-pass/unboxed-closures-boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-boxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-boxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-boxed.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -14,9 +14,9 @@\n \n use std::ops::FnMut;\n \n- fn make_adder(x: int) -> Box<FnMut<(int,),int>+'static> {\n-    (box move |&mut: y: int| -> int { x + y }) as\n-        Box<FnMut<(int,),int>+'static>\n+ fn make_adder(x: i32) -> Box<FnMut(i32)->i32+'static> {\n+    (box move |&mut: y: i32| -> i32 { x + y }) as\n+        Box<FnMut(i32)->i32+'static>\n }\n \n pub fn main() {"}, {"sha": "5d6029e703b82bca13ea7affc4cd0cd50da7e06c", "filename": "src/test/run-pass/unboxed-closures-fn-as-fnmut-and-fnonce.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -18,21 +18,22 @@ use std::ops::{Fn,FnMut,FnOnce};\n \n struct S;\n \n-impl Fn<(int,),int> for S {\n-    extern \"rust-call\" fn call(&self, (x,): (int,)) -> int {\n+impl Fn<(i32,)> for S {\n+    type Output = i32;\n+    extern \"rust-call\" fn call(&self, (x,): (i32,)) -> i32 {\n         x * x\n     }\n }\n \n-fn call_it<F:Fn(int)->int>(f: &F, x: int) -> int {\n+fn call_it<F:Fn(i32)->i32>(f: &F, x: i32) -> i32 {\n     f(x)\n }\n \n-fn call_it_mut<F:FnMut(int)->int>(f: &mut F, x: int) -> int {\n+fn call_it_mut<F:FnMut(i32)->i32>(f: &mut F, x: i32) -> i32 {\n     f(x)\n }\n \n-fn call_it_once<F:FnOnce(int)->int>(f: F, x: int) -> int {\n+fn call_it_once<F:FnOnce(i32)->i32>(f: F, x: i32) -> i32 {\n     f(x)\n }\n "}, {"sha": "95dae41c6840e301240643dde94f97eb06e87797", "filename": "src/test/run-pass/unboxed-closures-fnmut-as-fnonce.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -18,17 +18,19 @@ use std::ops::{FnMut,FnOnce};\n \n struct S;\n \n-impl FnMut<(int,),int> for S {\n-    extern \"rust-call\" fn call_mut(&mut self, (x,): (int,)) -> int {\n+impl FnMut<(i32,)> for S {\n+    type Output = i32;\n+\n+    extern \"rust-call\" fn call_mut(&mut self, (x,): (i32,)) -> i32 {\n         x * x\n     }\n }\n \n-fn call_it_mut<F:FnMut(int)->int>(f: &mut F, x: int) -> int {\n+fn call_it_mut<F:FnMut(i32)->i32>(f: &mut F, x: i32) -> i32 {\n     f(x)\n }\n \n-fn call_it_once<F:FnOnce(int)->int>(f: F, x: int) -> int {\n+fn call_it_once<F:FnOnce(i32)->i32>(f: F, x: i32) -> i32 {\n     f(x)\n }\n "}, {"sha": "04c124946c9a1edb28697a81b62d3205e871ba22", "filename": "src/test/run-pass/unboxed-closures-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-generic.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -12,12 +12,12 @@\n \n use std::ops::FnMut;\n \n-fn call_it<F:FnMut<(int,int),int>>(y: int, mut f: F) -> int {\n+fn call_it<F:FnMut(i32,i32)->i32>(y: i32, mut f: F) -> i32 {\n     f(2, y)\n }\n \n pub fn main() {\n-    let f = |&mut: x: int, y: int| -> int { x + y };\n+    let f = |&mut: x: i32, y: i32| -> i32 { x + y };\n     let z = call_it(3, f);\n     println!(\"{}\", z);\n     assert_eq!(z, 5);"}, {"sha": "37075de0405ad884e303e244abad07db5fe83f98", "filename": "src/test/run-pass/unboxed-closures-manual-impl.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -15,17 +15,19 @@ use std::ops::FnMut;\n \n struct S;\n \n-impl FnMut<(int,),int> for S {\n-    extern \"rust-call\" fn call_mut(&mut self, (x,): (int,)) -> int {\n+impl FnMut<(i32,)> for S {\n+    type Output = i32;\n+\n+    extern \"rust-call\" fn call_mut(&mut self, (x,): (i32,)) -> i32 {\n         x * x\n     }\n }\n \n-fn call_it<F:FnMut(int)->int>(mut f: F, x: int) -> int {\n+fn call_it<F:FnMut(i32)->i32>(mut f: F, x: i32) -> i32 {\n     f(x) + 3\n }\n \n-fn call_box(f: &mut FnMut(int) -> int, x: int) -> int {\n+fn call_box(f: &mut FnMut(i32) -> i32, x: i32) -> i32 {\n     f(x) + 3\n }\n "}, {"sha": "6dfa4c124e24e91bea2629397fdbf5591eed62fc", "filename": "src/test/run-pass/unboxed-closures-monomorphization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -16,17 +16,17 @@\n #![feature(unboxed_closures)]\n \n fn main(){\n-    fn bar<'a, T:Clone+'a> (t: T) -> Box<FnMut<(),T> + 'a> {\n+    fn bar<'a, T:Clone+'a> (t: T) -> Box<FnMut()->T + 'a> {\n         box move |&mut:| t.clone()\n     }\n \n-    let mut f = bar(42u);\n+    let mut f = bar(42_u32);\n     assert_eq!(f.call_mut(()), 42);\n \n     let mut f = bar(\"forty-two\");\n     assert_eq!(f.call_mut(()), \"forty-two\");\n \n-    let x = 42u;\n+    let x = 42_u32;\n     let mut f = bar(&x);\n     assert_eq!(f.call_mut(()), &x);\n "}, {"sha": "fff841a2f052d6511b77e04b1364ab609b1e72d6", "filename": "src/test/run-pass/unboxed-closures-sugar-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -29,7 +29,7 @@ impl<X> Getter<X,X> for Identity {\n }\n \n fn main() {\n-    let x: &Getter(int) -> (int,) = &Identity;\n+    let x: &Getter<(i32,), (i32,)> = &Identity;\n     let (y,) = x.get((22,));\n     assert_eq!(y, 22);\n }"}]}