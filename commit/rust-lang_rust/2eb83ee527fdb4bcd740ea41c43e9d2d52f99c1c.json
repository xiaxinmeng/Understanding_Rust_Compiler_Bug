{"sha": "2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYjgzZWU1MjdmZGI0YmNkNzQwZWE0MWM0M2U5ZDJkNTJmOTljMWM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-18T18:53:54Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-20T09:22:24Z"}, "message": "data_structures: Add a reference wrapper for pointer-indexed maps/sets\n\nUse `ptr::eq` for comparing pointers", "tree": {"sha": "e59b2ae0351abd6ded413a4b51dffaf350bc5150", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e59b2ae0351abd6ded413a4b51dffaf350bc5150"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "html_url": "https://github.com/rust-lang/rust/commit/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "414a86e7598b339f8b2681d0aa090d9fb4b6f0e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/414a86e7598b339f8b2681d0aa090d9fb4b6f0e1", "html_url": "https://github.com/rust-lang/rust/commit/414a86e7598b339f8b2681d0aa090d9fb4b6f0e1"}], "stats": {"total": 106, "additions": 76, "deletions": 30}, "files": [{"sha": "0ae45b3123259a2b7dbb4c7286d3207757f3f3b4", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "patch": "@@ -103,7 +103,7 @@ impl<K, V> LeafNode<K, V> {\n     }\n \n     fn is_shared_root(&self) -> bool {\n-        self as *const _ == &EMPTY_ROOT_NODE as *const _ as *const LeafNode<K, V>\n+        ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n     }\n }\n "}, {"sha": "dc1c9f7c1084423c74f5cb3d922caa3db127bd5a", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "patch": "@@ -39,7 +39,7 @@ use hir::intravisit;\n use hir;\n use lint::builtin::BuiltinLintDiagnostics;\n use session::{Session, DiagnosticMessageId};\n-use std::hash;\n+use std::{hash, ptr};\n use syntax::ast;\n use syntax::codemap::MultiSpan;\n use syntax::edition::Edition;\n@@ -354,7 +354,7 @@ pub struct LintId {\n \n impl PartialEq for LintId {\n     fn eq(&self, other: &LintId) -> bool {\n-        (self.lint as *const Lint) == (other.lint as *const Lint)\n+        ptr::eq(self.lint, other.lint)\n     }\n }\n "}, {"sha": "bd24b93f0293f63353adda235e86d9b54a72974c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "patch": "@@ -47,7 +47,7 @@ use std::ops::Deref;\n use rustc_data_structures::sync::{self, Lrc, ParallelIterator, par_iter};\n use std::slice;\n use std::vec::IntoIter;\n-use std::mem;\n+use std::{mem, ptr};\n use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n@@ -527,8 +527,7 @@ impl<'tcx> PartialOrd for TyS<'tcx> {\n impl<'tcx> PartialEq for TyS<'tcx> {\n     #[inline]\n     fn eq(&self, other: &TyS<'tcx>) -> bool {\n-        // (self as *const _) == (other as *const _)\n-        (self as *const TyS<'tcx>) == (other as *const TyS<'tcx>)\n+        ptr::eq(self, other)\n     }\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n@@ -678,7 +677,7 @@ impl<T> PartialOrd for Slice<T> where T: PartialOrd {\n impl<T: PartialEq> PartialEq for Slice<T> {\n     #[inline]\n     fn eq(&self, other: &Slice<T>) -> bool {\n-        (self as *const _) == (other as *const _)\n+        ptr::eq(self, other)\n     }\n }\n impl<T: Eq> Eq for Slice<T> {}\n@@ -1730,7 +1729,7 @@ impl Ord for AdtDef {\n impl PartialEq for AdtDef {\n     // AdtDef are always interned and this is part of TyS equality\n     #[inline]\n-    fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n+    fn eq(&self, other: &Self) -> bool { ptr::eq(self, other) }\n }\n \n impl Eq for AdtDef {}"}, {"sha": "6cc71642c42ae2c76d45592302bc15ae3975205e", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "patch": "@@ -11,6 +11,7 @@\n #![allow(warnings)]\n \n use std::mem;\n+use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::{Lock, LockGuard, Lrc, Weak};\n use rustc_data_structures::OnDrop;\n use syntax_pos::Span;\n@@ -20,7 +21,7 @@ use ty::query::plumbing::CycleError;\n use ty::context::TyCtxt;\n use errors::Diagnostic;\n use std::process;\n-use std::fmt;\n+use std::{fmt, ptr};\n use std::collections::HashSet;\n #[cfg(parallel_queries)]\n use {\n@@ -124,7 +125,7 @@ impl<'tcx> QueryJob<'tcx> {\n         while let Some(job) = current_job {\n             cycle.insert(0, job.info.clone());\n \n-            if &*job as *const _ == self as *const _ {\n+            if ptr::eq(&*job, self) {\n                 // This is the end of the cycle\n                 // The span entry we included was for the usage\n                 // of the cycle itself, and not part of the cycle\n@@ -282,7 +283,7 @@ where\n fn cycle_check<'tcx>(query: Lrc<QueryJob<'tcx>>,\n                      span: Span,\n                      stack: &mut Vec<(Span, Lrc<QueryJob<'tcx>>)>,\n-                     visited: &mut HashSet<*const QueryJob<'tcx>>\n+                     visited: &mut HashSet<PtrKey<'tcx, QueryJob<'tcx>>>\n ) -> Option<Option<Waiter<'tcx>>> {\n     if visited.contains(&query.as_ptr()) {\n         return if let Some(p) = stack.iter().position(|q| q.1.as_ptr() == query.as_ptr()) {\n@@ -321,7 +322,7 @@ fn cycle_check<'tcx>(query: Lrc<QueryJob<'tcx>>,\n #[cfg(parallel_queries)]\n fn connected_to_root<'tcx>(\n     query: Lrc<QueryJob<'tcx>>,\n-    visited: &mut HashSet<*const QueryJob<'tcx>>\n+    visited: &mut HashSet<PtrKey<'tcx, QueryJob<'tcx>>>\n ) -> bool {\n     // We already visited this or we're deliberately ignoring it\n     if visited.contains(&query.as_ptr()) {"}, {"sha": "ef0d57c7b7ce7a6bc7b6a8b82232892a84ee0b3c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "patch": "@@ -56,29 +56,30 @@ extern crate rustc_cratesio_shim;\n \n pub use rustc_serialize::hex::ToHex;\n \n-pub mod array_vec;\n pub mod accumulate_vec;\n-pub mod small_vec;\n+pub mod array_vec;\n pub mod base_n;\n pub mod bitslice;\n pub mod bitvec;\n+pub mod flock;\n+pub mod fx;\n+pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;\n+pub mod owning_ref;\n+pub mod ptr_key;\n pub mod sip128;\n+pub mod small_vec;\n pub mod snapshot_map;\n pub use ena::snapshot_vec;\n+pub mod sorted_map;\n pub mod stable_hasher;\n-pub mod transitive_relation;\n-pub use ena::unify;\n-pub mod fx;\n-pub mod tuple_slice;\n-pub mod graph;\n-pub mod flock;\n pub mod sync;\n-pub mod owning_ref;\n pub mod tiny_list;\n-pub mod sorted_map;\n+pub mod transitive_relation;\n+pub mod tuple_slice;\n+pub use ena::unify;\n pub mod work_queue;\n \n pub struct OnDrop<F: Fn()>(pub F);"}, {"sha": "6835dab38df0a3159a63ceb28d55fd12815accb5", "filename": "src/librustc_data_structures/ptr_key.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc_data_structures%2Fptr_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc_data_structures%2Fptr_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fptr_key.rs?ref=2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{hash, ptr};\n+use std::ops::Deref;\n+\n+/// A wrapper around reference that compares and hashes like a pointer.\n+/// Can be used as a key in sets/maps indexed by pointers to avoid `unsafe`.\n+#[derive(Debug)]\n+pub struct PtrKey<'a, T: 'a>(pub &'a T);\n+\n+impl<'a, T> Clone for PtrKey<'a, T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+impl<'a, T> Copy for PtrKey<'a, T> {}\n+\n+impl<'a, T> PartialEq for PtrKey<'a, T> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        ptr::eq(self.0, rhs.0)\n+    }\n+}\n+\n+impl<'a, T> Eq for PtrKey<'a, T> {}\n+\n+impl<'a, T> hash::Hash for PtrKey<'a, T> {\n+    fn hash<H: hash::Hasher>(&self, hasher: &mut H) {\n+        (self.0 as *const T).hash(hasher)\n+    }\n+}\n+\n+impl<'a, T> Deref for PtrKey<'a, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}"}, {"sha": "97b9a38528770c8795937dea8cceba1ce8f9836c", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2eb83ee527fdb4bcd740ea41c43e9d2d52f99c1c", "patch": "@@ -17,6 +17,7 @@ use Resolver;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n+use rustc_data_structures::ptr_key::PtrKey;\n use rustc::ty;\n use rustc::lint::builtin::BuiltinLintDiagnostics;\n use rustc::lint::builtin::{DUPLICATE_MACRO_EXPORTS, PUB_USE_OF_PRIVATE_EXTERN_CRATE};\n@@ -33,7 +34,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n-use std::mem;\n+use std::{mem, ptr};\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n@@ -105,8 +106,8 @@ impl<'a> ImportDirective<'a> {\n /// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n-    /// Import directives are arena-allocated, so it's ok to use pointers as keys, they are stable.\n-    single_imports: FxHashSet<*const ImportDirective<'a>>,\n+    /// Import directives are arena-allocated, so it's ok to use pointers as keys.\n+    single_imports: FxHashSet<PtrKey<'a, ImportDirective<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     shadowed_glob: Option<&'a NameBinding<'a>>,\n@@ -192,7 +193,6 @@ impl<'a> Resolver<'a> {\n         // Check if one of single imports can still define the name,\n         // if it can then our result is not determined and can be invalidated.\n         for single_import in &resolution.single_imports {\n-            let single_import = unsafe { &**single_import };\n             if !self.is_accessible(single_import.vis.get()) {\n                 continue;\n             }\n@@ -291,7 +291,7 @@ impl<'a> Resolver<'a> {\n             SingleImport { target, type_ns_only, .. } => {\n                 self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n                     let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n-                    resolution.single_imports.insert(directive);\n+                    resolution.single_imports.insert(PtrKey(directive));\n                 });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n@@ -398,7 +398,7 @@ impl<'a> Resolver<'a> {\n                 _ if old_binding.is_some() => return t,\n                 None => return t,\n                 Some(binding) => match old_binding {\n-                    Some(old_binding) if old_binding as *const _ == binding as *const _ => return t,\n+                    Some(old_binding) if ptr::eq(old_binding, binding) => return t,\n                     _ => (binding, t),\n                 }\n             }\n@@ -583,7 +583,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n                     this.update_resolution(parent, target, ns, |_, resolution| {\n-                        resolution.single_imports.remove(&(directive as *const _));\n+                        resolution.single_imports.remove(&PtrKey(directive));\n                     });\n                 }\n                 Ok(binding) if !binding.is_importable() => {\n@@ -916,7 +916,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n         let mut exported_macro_names = FxHashMap();\n-        if module as *const _ == self.graph_root as *const _ {\n+        if ptr::eq(module, self.graph_root) {\n             let macro_exports = mem::replace(&mut self.macro_exports, Vec::new());\n             for export in macro_exports.into_iter().rev() {\n                 if let Some(later_span) = exported_macro_names.insert(export.ident.modern(),"}]}