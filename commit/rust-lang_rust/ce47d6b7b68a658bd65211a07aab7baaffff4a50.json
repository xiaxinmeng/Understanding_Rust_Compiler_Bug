{"sha": "ce47d6b7b68a658bd65211a07aab7baaffff4a50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNDdkNmI3YjY4YTY1OGJkNjUyMTFhMDdhYWI3YmFhZmZmZjRhNTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-20T17:31:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-21T08:27:01Z"}, "message": "reach fixed-point for rust-analyzer spelling", "tree": {"sha": "8194d092c302a5e0ded959a916dc5b3548bd7d17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8194d092c302a5e0ded959a916dc5b3548bd7d17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce47d6b7b68a658bd65211a07aab7baaffff4a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce47d6b7b68a658bd65211a07aab7baaffff4a50", "html_url": "https://github.com/rust-lang/rust/commit/ce47d6b7b68a658bd65211a07aab7baaffff4a50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce47d6b7b68a658bd65211a07aab7baaffff4a50/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "743384204055fcf20ec8957e056215b4d9fb36f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/743384204055fcf20ec8957e056215b4d9fb36f2", "html_url": "https://github.com/rust-lang/rust/commit/743384204055fcf20ec8957e056215b4d9fb36f2"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "cbdbff6d02f879c2097640fbb5f71cdc62c74811", "filename": "guide.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce47d6b7b68a658bd65211a07aab7baaffff4a50/guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/ce47d6b7b68a658bd65211a07aab7baaffff4a50/guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/guide.md?ref=ce47d6b7b68a658bd65211a07aab7baaffff4a50", "patch": "@@ -2,7 +2,7 @@\n \n ## About the guide\n \n-This guide describes the current state of `rust-analyzer` as of 2019-01-20\n+This guide describes the current state of rust-analyzer as of 2019-01-20\n (git tag [guide-2019-01]). Its purpose is to document various problems and\n architectural solutions related to the problem of building IDE-first compiler\n for Rust.\n@@ -11,7 +11,7 @@ for Rust.\n \n ## The big picture\n \n-On the highest possible level, rust analyzer is a stateful component. A client may\n+On the highest possible level, rust-analyzer is a stateful component. A client may\n apply changes to the analyzer (new contents of `foo.rs` file is \"fn main() {}\")\n and it may ask semantic questions about the current state (what is the\n definition of the identifier with offset 92 in file `bar.rs`?). Two important\n@@ -117,7 +117,7 @@ Yet another problem is that we really-really want to avoid doing IO, but with\n Rust the set of \"input\" files is not necessary known up-front. In theory, you\n can have `#[path=\"/dev/random\"] mod foo;`.\n \n-To solve (or explicitly refuse to solve) these problems rust analyzer uses the\n+To solve (or explicitly refuse to solve) these problems rust-analyzer uses the\n concept of source root. Roughly speaking, source roots is a contents of a\n directory on a file systems, like `/home/matklad/projects/rustraytracer/**.rs`.\n \n@@ -282,11 +282,11 @@ The first step of building the model is parsing the source code.\n \n An important property of the Rust language is that each file can be parsed in\n isolation. Unlike, say, `C++`, an `include` can't change the meaning of the\n-syntax. For this reason, Rust analyzer can build a syntax tree for each \"source\n+syntax. For this reason, rust-analyzer can build a syntax tree for each \"source\n file\", which could then be reused by several semantic models if this file\n happens to be a part of several crates.\n \n-Rust analyzer uses a similar representation of syntax trees to that of `Roslyn`\n+Rust-analyzer uses a similar representation of syntax trees to that of `Roslyn`\n and Swift's new [libsyntax]. Swift's docs give an excellent overview of the\n approach, so I skip this part here and instead outline the main characteristics\n of the syntax trees:\n@@ -333,7 +333,7 @@ declarations and recursively process child modules. This is handled by the\n \n [`module_tree_query`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/module_tree.rs#L116-L123\n \n-First, rust analyzer builds a module tree for all crates in a source root\n+First, rust-analyzer builds a module tree for all crates in a source root\n simultaneously. The main reason for this is historical (`module_tree` predates\n `CrateGraph`), but this approach also enables accounting for files which are not\n part of any crate. That is, if you create a file but do not include it as a\n@@ -493,7 +493,7 @@ Naturally, name resolution [uses] this stable projection query.\n \n ## Type inference\n \n-First of all, implementation of type inference in rust analyzer was spearheaded\n+First of all, implementation of type inference in rust-analyzer was spearheaded\n by [@flodiebold]. [#327] was an awesome Christmas present, thank you, Florian!\n \n Type inference runs on per-function granularity and uses the patterns we've\n@@ -518,7 +518,7 @@ construct a mapping from `ExprId`s to types.\n \n ## Tying it all together: completion\n \n-To conclude the overview of the rust analyzer, let's trace the request for\n+To conclude the overview of the rust-analyzer, let's trace the request for\n (type-inference powered!) code completion!\n \n We start by [receiving a message] from the language client. We decode the"}]}