{"sha": "6aa656a910d0396c86e19fb4d850033786fce516", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYTY1NmE5MTBkMDM5NmM4NmUxOWZiNGQ4NTAwMzM3ODZmY2U1MTY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-11T14:20:19Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-11T14:20:19Z"}, "message": "Merge pull request #492 from Manishearth/wiki\n\nadded wiki comments + wiki-generating python script", "tree": {"sha": "5da7ca8ff131b8baa48abc9039c950c68713d5be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5da7ca8ff131b8baa48abc9039c950c68713d5be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aa656a910d0396c86e19fb4d850033786fce516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aa656a910d0396c86e19fb4d850033786fce516", "html_url": "https://github.com/rust-lang/rust/commit/6aa656a910d0396c86e19fb4d850033786fce516", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aa656a910d0396c86e19fb4d850033786fce516/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e7677ff319a3b2989c29bc57d258e7b8f39fed6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7677ff319a3b2989c29bc57d258e7b8f39fed6", "html_url": "https://github.com/rust-lang/rust/commit/3e7677ff319a3b2989c29bc57d258e7b8f39fed6"}, {"sha": "5bbc1427fde4152d42e6159d5a3ca3eec167b02f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bbc1427fde4152d42e6159d5a3ca3eec167b02f", "html_url": "https://github.com/rust-lang/rust/commit/5bbc1427fde4152d42e6159d5a3ca3eec167b02f"}], "stats": {"total": 668, "additions": 668, "deletions": 0}, "files": [{"sha": "05829838903f2023bfdaa6fdec2223e2f4de8847", "filename": "src/approx_const.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -6,6 +6,13 @@ use syntax::ast::Lit_::*;\n use syntax::ast::Lit;\n use syntax::ast::FloatTy::*;\n \n+/// **What it does:** This lint checks for floating point literals that approximate constants which are defined in [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants) or [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants), respectively, suggesting to use the predefined constant. This lint is `Warn` by default.\n+///\n+/// **Why is this bad?** Usually, the definition in the standard library is more precise than what people come up with. If you find that your definition is actually more precise, please [file a Rust issue](https://github.com/rust-lang/rust/issues).\n+///\n+/// **Known problems:** If you happen to have a value that is within 1/8192 of a known constant, but is not *and should not* be the same, this lint will report your value anyway. We have not yet noticed any false positives in code we tested clippy with (this includes servo), but YMMV.\n+///\n+/// **Example:** `let x = 3.14;`\n declare_lint! {\n     pub APPROX_CONSTANT,\n     Warn,"}, {"sha": "10db4a551f9597bb48115e4a8298892f49aee85f", "filename": "src/attrs.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -8,6 +8,19 @@ use syntax::attr::*;\n use syntax::ast::{Attribute, MetaList, MetaWord};\n use utils::{in_macro, match_path, span_lint};\n \n+/// **What it does:** This lint warns on items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.\n+///\n+/// **Why is this bad?** While there are valid uses of this annotation (and once you know when to use it, by all means `allow` this lint), it's a common newbie-mistake to pepper one's code with it.\n+///\n+/// As a rule of thumb, before slapping `#[inline(always)]` on a function, measure if that additional function call really affects your runtime profile sufficiently to make up for the increase in compile time.\n+///\n+/// **Known problems:** False positives, big time. This lint is meant to be deactivated by everyone doing serious performance work. This means having done the measurement.\n+///\n+/// **Example:**\n+/// ```\n+/// #[inline(always)]\n+/// fn not_quite_hot_code(..) { ... }\n+/// ```\n declare_lint! { pub INLINE_ALWAYS, Warn,\n     \"`#[inline(always)]` is a bad idea in most cases\" }\n "}, {"sha": "3d428aa0da768a48ef61c9fac07c3846b2b1eb3a", "filename": "src/bit_mask.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -8,13 +8,48 @@ use syntax::ast::Lit_::*;\n \n use utils::span_lint;\n \n+/// **What it does:** This lint checks for incompatible bit masks in comparisons. It is `Warn` by default.\n+///\n+/// The formula for detecting if an expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>`\n+/// is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following table:\n+///\n+/// |Comparison  |Bit-Op|Example     |is always|Formula               |\n+/// |------------|------|------------|---------|----------------------|\n+/// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n+/// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n+/// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n+/// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n+/// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n+/// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n+///\n+/// **Why is this bad?** If the bits that the comparison cares about are always set to zero or one by the bit mask, the comparison is constant `true` or `false` (depending on mask, compared value, and operators).\n+///\n+/// So the code is actively misleading, and the only reason someone would write this intentionally is to win an underhanded Rust contest or create a test-case for this lint.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `x & 1 == 2` (also see table above)\n declare_lint! {\n     pub BAD_BIT_MASK,\n     Warn,\n     \"expressions of the form `_ & mask == select` that will only ever return `true` or `false` \\\n      (because in the example `select` containing bits that `mask` doesn't have)\"\n }\n \n+/// **What it does:** This lint checks for bit masks in comparisons which can be removed without changing the outcome. The basic structure can be seen in the following table:\n+///\n+/// |Comparison|Bit-Op   |Example    |equals |\n+/// |----------|---------|-----------|-------|\n+/// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n+/// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|\n+///\n+/// This lint is `Warn` by default.\n+///\n+/// **Why is this bad?** Not equally evil as [`bad_bit_mask`](#bad_bit_mask), but still a bit misleading, because the bit mask is ineffective.\n+///\n+/// **Known problems:** False negatives: This lint will only match instances where we have figured out the math (which is for a power-of-two compared value). This means things like `x | 1 >= 7` (which would be better written as `x >= 6`) will not be reported (but bit masks like this are fairly uncommon).\n+///\n+/// **Example:** `x | 1 > 3` (also see table above)\n declare_lint! {\n     pub INEFFECTIVE_BIT_MASK,\n     Warn,"}, {"sha": "775e9ec95fc93cce6792de927effd0df547b2d1b", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -18,6 +18,13 @@ use syntax::codemap::Spanned;\n \n use utils::{in_macro, span_help_and_lint, snippet, snippet_block};\n \n+/// **What it does:** This lint checks for nested `if`-statements which can be collapsed by `&&`-combining their conditions. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Each `if`-statement adds one level of nesting, which makes code look more complex than it really is.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `if x { if y { .. } }`\n declare_lint! {\n     pub COLLAPSIBLE_IF,\n     Warn,"}, {"sha": "4865596b6302786eccf1acc8a4478adf8e6aa76e", "filename": "src/eq_op.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -6,6 +6,13 @@ use syntax::ptr::P;\n use consts::constant;\n use utils::span_lint;\n \n+/// **What it does:** This lint checks for equal operands to comparisons and bitwise binary operators (`&`, `|` and `^`). It is `Warn` by default.\n+///\n+/// **Why is this bad?** This is usually just a typo.\n+///\n+/// **Known problems:** False negatives: We had some false positives regarding calls (notably [racer](https://github.com/phildawes/racer) had one instance of `x.pop() && x.pop()`), so we removed matching any function or method calls. We may introduce a whitelist of known pure functions in the future.\n+///\n+/// **Example:** `x + 1 == x + 1`\n declare_lint! {\n     pub EQ_OP,\n     Warn,"}, {"sha": "c25228793e69a9fff16d85c628e5cb78620ea80c", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -9,6 +9,13 @@ use utils::{snippet_opt, span_lint_and_then, is_adjusted};\n pub struct EtaPass;\n \n \n+/// **What it does:** This lint checks for closures which just call another function where the function can be called directly. `unsafe` functions or calls where types get adjusted are ignored. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Needlessly creating a closure just costs heap space and adds code for no benefit.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `xs.map(|x| foo(x))` where `foo(_)` is a plain function that takes the exact argument type of `x`.\n declare_lint!(pub REDUNDANT_CLOSURE, Warn,\n               \"using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\");\n "}, {"sha": "88a03e050be087564114cc00b75084aad31ffc95", "filename": "src/identity_op.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -6,6 +6,13 @@ use consts::{constant_simple, is_negative};\n use consts::Constant::ConstantInt;\n use utils::{span_lint, snippet, in_macro};\n \n+/// **What it does:** This lint checks for identity operations, e.g. `x + 0`. It is `Warn` by default.\n+///\n+/// **Why is this bad?** This code can be removed without changing the meaning. So it just obscures what's going on. Delete it mercilessly.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `x / 1 + 0 * 1 - 0 | 0`\n declare_lint! { pub IDENTITY_OP, Warn,\n                 \"using identity operations, e.g. `x + 0` or `y / 1`\" }\n "}, {"sha": "589b4f6ebb13eb63e21748e8ad49bec251b28289", "filename": "src/len_zero.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -11,10 +11,29 @@ use syntax::ast::Lit;\n \n use utils::{get_item_name, snippet, span_lint, walk_ptrs_ty};\n \n+/// **What it does:** This lint checks for getting the length of something via `.len()` just to compare to zero, and suggests using `.is_empty()` where applicable. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Some structures can answer `.is_empty()` much faster than calculating their length. So it is good to get into the habit of using `.is_empty()`, and having it is cheap. Besides, it makes the intent clearer than a comparison.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `if x.len() == 0 { .. }`\n declare_lint!(pub LEN_ZERO, Warn,\n               \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` \\\n                could be used instead\");\n \n+/// **What it does:** This lint checks for items that implement `.len()` but not `.is_empty()`. It is `Warn` by default.\n+///\n+/// **Why is this bad?** It is good custom to have both methods, because for some data structures, asking about the length will be a costly operation, whereas `.is_empty()` can usually answer in constant time. Also it used to lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that lint will ignore such entities.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```\n+/// impl X {\n+///     fn len(&self) -> usize { .. }\n+/// }\n+/// ```\n declare_lint!(pub LEN_WITHOUT_IS_EMPTY, Warn,\n               \"traits and impls that have `.len()` but not `.is_empty()`\");\n "}, {"sha": "743dc366e44b5508864e288e4aac8bca5c02b4a5", "filename": "src/lifetimes.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -8,6 +8,13 @@ use std::collections::{HashSet, HashMap};\n \n use utils::{in_external_macro, span_lint};\n \n+/// **What it does:** This lint checks for lifetime annotations which can be removed by relying on lifetime elision. It is `Warn` by default.\n+///\n+/// **Why is this bad?** The additional lifetimes make the code look more complicated, while there is nothing out of the ordinary going on. Removing them leads to more readable code.\n+///\n+/// **Known problems:** Potential false negatives: we bail out if the function has a `where` clause where lifetimes are mentioned.\n+///\n+/// **Example:** `fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 { x }`\n declare_lint!(pub NEEDLESS_LIFETIMES, Warn,\n               \"using explicit lifetimes for references in function arguments when elision rules \\\n                would allow omitting them\");"}, {"sha": "3c4e023b98e80444e9d7ec876fffb83c46830983", "filename": "src/loops.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -15,28 +15,103 @@ use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type,\n             get_enclosing_block};\n use utils::{VEC_PATH, LL_PATH};\n \n+/// **What it does:** This lint checks for looping over the range of `0..len` of some collection just to get the values by index. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Just iterating the collection itself makes the intent more clear and is probably faster.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```\n+/// for i in 0..vec.len() {\n+///     println!(\"{}\", vec[i]);\n+/// }\n+/// ```\n declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n                \"for-looping over a range of indices where an iterator over items would do\" }\n \n+/// **What it does:** This lint checks for loops on `x.iter()` where `&x` will do, and suggest the latter. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Readability.\n+///\n+/// **Known problems:** False negatives. We currently only warn on some known types.\n+///\n+/// **Example:** `for x in y.iter() { .. }` (where y is a `Vec` or slice)\n declare_lint!{ pub EXPLICIT_ITER_LOOP, Warn,\n                \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\" }\n \n+/// **What it does:** This lint checks for loops on `x.next()`. It is `Warn` by default.\n+///\n+/// **Why is this bad?** `next()` returns either `Some(value)` if there was a value, or `None` otherwise. The insidious thing is that `Option<_>` implements `IntoIterator`, so that possibly one value will be iterated, leading to some hard to find bugs. No one will want to write such code [except to win an Underhanded Rust Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `for x in y.next() { .. }`\n declare_lint!{ pub ITER_NEXT_LOOP, Warn,\n                \"for-looping over `_.next()` which is probably not intended\" }\n \n+/// **What it does:** This lint detects `loop + match` combinations that are easier written as a `while let` loop.\n+///\n+/// **Why is this bad?** The `while let` loop is usually shorter and more readable\n+///\n+/// **Known problems:** Sometimes the wrong binding is displayed (#383)\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// loop {\n+///     let x = match y {\n+///         Some(x) => x,\n+///         None => break,\n+///     }\n+///     // .. do something with x\n+/// }\n+/// // is easier written as\n+/// while let Some(x) = y {\n+///     // .. do something with x\n+/// }\n+/// ```\n declare_lint!{ pub WHILE_LET_LOOP, Warn,\n                \"`loop { if let { ... } else break }` can be written as a `while let` loop\" }\n \n+/// **What it does:** This lint checks for using `collect()` on an iterator without using the result. It is `Warn` by default.\n+///\n+/// **Why is this bad?** It is more idiomatic to use a `for` loop over the iterator instead.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `vec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();`\n declare_lint!{ pub UNUSED_COLLECT, Warn,\n                \"`collect()`ing an iterator without using the result; this is usually better \\\n                 written as a for loop\" }\n \n+/// **What it does:** This lint checks for loops over ranges `x..y` where both `x` and `y` are constant and `x` is greater or equal to `y`, unless the range is reversed or has a negative `.step_by(_)`.\n+///\n+/// **Why is it bad?** Such loops will either be skipped or loop until wrap-around (in debug code, this may `panic!()`). Both options are probably not intended.\n+///\n+/// **Known problems:** The lint cannot catch loops over dynamically defined ranges. Doing this would require simulating all possible inputs and code paths through the program, which would be complex and error-prone.\n+///\n+/// **Examples**: `for x in 5..10-5 { .. }` (oops, stray `-`)\n declare_lint!{ pub REVERSE_RANGE_LOOP, Warn,\n                \"Iterating over an empty range, such as `10..0` or `5..5`\" }\n \n+/// **What it does:** This lint checks `for` loops over slices with an explicit counter and suggests the use of `.enumerate()`. It is `Warn` by default.\n+///\n+/// **Why is it bad?** Not only is the version using `.enumerate()` more readable, the compiler is able to remove bounds checks which can lead to faster code in some instances.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `for i in 0..v.len() { foo(v[i]); }` or `for i in 0..v.len() { bar(i, v[i]); }`\n declare_lint!{ pub EXPLICIT_COUNTER_LOOP, Warn,\n                \"for-looping with an explicit counter when `_.enumerate()` would do\" }\n \n+/// **What it does:** This lint checks for empty `loop` expressions. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Those busy loops burn CPU cycles without doing anything. Think of the environment and either block on something or at least make the thread sleep for some microseconds.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `loop {}`\n declare_lint!{ pub EMPTY_LOOP, Warn, \"empty `loop {}` detected\" }\n \n declare_lint!{ pub WHILE_LET_ON_ITERATOR, Warn, \"using a while-let loop instead of a for loop on an iterator\" }"}, {"sha": "39459bafba70e5c5d9b8dfc572d715e83cffa52c", "filename": "src/matches.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -6,12 +6,55 @@ use syntax::codemap::Span;\n \n use utils::{snippet, span_lint, span_help_and_lint, in_external_macro, expr_block};\n \n+/// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```\n+/// match x {\n+///     Some(ref foo) -> bar(foo),\n+///     _ => ()\n+/// }\n+/// ```\n declare_lint!(pub SINGLE_MATCH, Warn,\n               \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n                is `_ => {}`) is used; recommends `if let` instead\");\n+/// **What it does:** This lint checks for matches where all arms match a reference, suggesting to remove the reference and deref the matched expression instead. It is `Warn` by default.\n+///\n+/// **Why is this bad?** It just makes the code less readable. That reference destructuring adds nothing to the code.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// match x {\n+///     &A(ref y) => foo(y),\n+///     &B => bar(),\n+///     _ => frob(&x),\n+/// }\n+/// ```\n declare_lint!(pub MATCH_REF_PATS, Warn,\n               \"a match has all arms prefixed with `&`; the match expression can be \\\n                dereferenced instead\");\n+/// **What it does:** This lint checks for matches where match expression is a `bool`. It suggests to replace the expression with an `if...else` block. It is `Warn` by default.\n+///\n+/// **Why is this bad?** It makes the code less readable.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// let condition: bool = true;\n+/// match condition {\n+///     true => foo(),\n+///     false => bar(),\n+/// }\n+/// ```\n declare_lint!(pub MATCH_BOOL, Warn,\n               \"a match on boolean expression; recommends `if..else` block instead\");\n "}, {"sha": "6c629f29c41d91b5fc9bf8298eedd3019200fefd", "filename": "src/methods.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -15,19 +15,95 @@ use self::OutType::*;\n #[derive(Clone)]\n pub struct MethodsPass;\n \n+/// **What it does:** This lint checks for `.unwrap()` calls on `Option`s. It is `Allow` by default.\n+///\n+/// **Why is this bad?** Usually it is better to handle the `None` case, or to at least call `.expect(_)` with a more helpful message. Still, for a lot of quick-and-dirty code, `unwrap` is a good choice, which is why this lint is `Allow` by default.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `x.unwrap()`\n declare_lint!(pub OPTION_UNWRAP_USED, Allow,\n               \"using `Option.unwrap()`, which should at least get a better message using `expect()`\");\n+/// **What it does:** This lint checks for `.unwrap()` calls on `Result`s. It is `Allow` by default.\n+///\n+/// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err` values. Normally, you want to implement more sophisticated error handling, and propagate errors upwards with `try!`.\n+///\n+/// Even if you want to panic on errors, not all `Error`s implement good messages on display. Therefore it may be beneficial to look at the places where they may get displayed. Activate this lint to do just that.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `x.unwrap()`\n declare_lint!(pub RESULT_UNWRAP_USED, Allow,\n               \"using `Result.unwrap()`, which might be better handled\");\n+/// **What it does:** This lint checks for `.to_string()` method calls on values of type `&str`. It is `Warn` by default.\n+///\n+/// **Why is this bad?** This uses the whole formatting machinery just to clone a string. Using `.to_owned()` is lighter on resources. You can also consider using a [`Cow<'a, str>`](http://doc.rust-lang.org/std/borrow/enum.Cow.html) instead in some cases.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `s.to_string()` where `s: &str`\n declare_lint!(pub STR_TO_STRING, Warn,\n               \"using `to_string()` on a str, which should be `to_owned()`\");\n+/// **What it does:** This lint checks for `.to_string()` method calls on values of type `String`. It is `Warn` by default.\n+///\n+/// **Why is this bad?** As our string is already owned, this whole operation is basically a no-op, but still creates a clone of the string (which, if really wanted, should be done with `.clone()`).\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `s.to_string()` where `s: String`\n declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n+/// **What it does:** This lint checks for methods that should live in a trait implementation of a `std` trait (see [llogiq's blog post](http://llogiq.github.io/2015/07/30/traits.html) for further information) instead of an inherent implementation. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Implementing the traits improve ergonomics for users of the code, often with very little cost. Also people seeing a `mul(..)` method may expect `*` to work equally, so you should have good reason to disappoint them.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```\n+/// struct X;\n+/// impl X {\n+///    fn add(&self, other: &X) -> X { .. }\n+/// }\n+/// ```\n declare_lint!(pub SHOULD_IMPLEMENT_TRAIT, Warn,\n               \"defining a method that should be implementing a std trait\");\n+/// **What it does:** This lint checks for methods with certain name prefixes and `Warn`s (by default) if the prefix doesn't match how self is taken. The actual rules are:\n+///\n+/// |Prefix |`self` taken        |\n+/// |-------|--------------------|\n+/// |`as_`  |`&self` or &mut self|\n+/// |`from_`| none               |\n+/// |`into_`|`self`              |\n+/// |`is_`  |`&self` or none     |\n+/// |`to_`  |`&self`             |\n+///\n+/// **Why is this bad?** Consistency breeds readability. If you follow the conventions, your users won't be surprised that they e.g. need to supply a mutable reference to a `as_`.. function.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example**\n+///\n+/// ```\n+/// impl X {\n+///     fn as_str(self) -> &str { .. }\n+/// }\n+/// ```\n declare_lint!(pub WRONG_SELF_CONVENTION, Warn,\n               \"defining a method named with an established prefix (like \\\"into_\\\") that takes \\\n                `self` with the wrong convention\");\n+/// **What it does:** This is the same as [`wrong_self_convention`](#wrong_self_convention), but for public items. This lint is `Allow` by default.\n+///\n+/// **Why is this bad?** See [`wrong_self_convention`](#wrong_self_convention).\n+///\n+/// **Known problems:** Actually *renaming* the function may break clients if the function is part of the public interface. In that case, be mindful of the stability guarantees you've given your users.\n+///\n+/// **Example:**\n+/// ```\n+/// impl X {\n+///     pub fn as_str(self) -> &str { .. }\n+/// }\n+/// ```\n declare_lint!(pub WRONG_PUB_SELF_CONVENTION, Allow,\n               \"defining a public method named with an established prefix (like \\\"into_\\\") that takes \\\n                `self` with the wrong convention\");"}, {"sha": "ac8d6f05272070e5e785d18a4a335afa5b7e8d69", "filename": "src/minmax.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -8,6 +8,13 @@ use consts::{Constant, constant_simple};\n use utils::{match_def_path, span_lint};\n use self::MinMax::{Min, Max};\n \n+/// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to clamp values, but switched so that the result is constant.\n+///\n+/// **Why is this bad?** This is in all probability not the intended outcome. At the least it hurts readability of the code.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `min(0, max(100, x))` will always be equal to `0`. Probably the author meant to clamp the value between 0 and 100, but has erroneously swapped `min` and `max`.\n declare_lint!(pub MIN_MAX, Warn,\n     \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result \\\n     to a constant\");"}, {"sha": "b5c3d0c514f109a3e680f8a31a5dee35cee2014b", "filename": "src/misc.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -13,6 +13,15 @@ use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n use utils::{get_item_name, match_path, snippet, span_lint, walk_ptrs_ty, is_integer_literal};\n use utils::span_help_and_lint;\n \n+/// **What it does:** This lint checks for function arguments and let bindings denoted as `ref`. It is `Warn` by default.\n+///\n+/// **Why is this bad?** The `ref` declaration makes the function take an owned value, but turns the argument into a reference (which means that the value is destroyed when exiting the function). This adds not much value: either take a reference type, or take an owned value and create references in the body.\n+///\n+/// For let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The type of `x` is more obvious with the former.\n+///\n+/// **Known problems:** If the argument is dereferenced within the function, removing the `ref` will lead to errors. This can be fixed by removing the dereferences, e.g. changing `*x` to `x` within the function.\n+///\n+/// **Example:** `fn foo(ref x: u8) -> bool { .. }`\n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n               \"An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), \\\n                or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take \\\n@@ -68,6 +77,13 @@ impl LateLintPass for TopLevelRefPass {\n     }\n }\n \n+/// **What it does:** This lint checks for comparisons to NAN. It is `Deny` by default.\n+///\n+/// **Why is this bad?** NAN does not compare meaningfully to anything \u2013 not even itself \u2013 so those comparisons are simply wrong.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `x == NAN`\n declare_lint!(pub CMP_NAN, Deny,\n               \"comparisons to NAN (which will always return false, which is probably not intended)\");\n \n@@ -102,6 +118,13 @@ fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n     });\n }\n \n+/// **What it does:** This lint checks for (in-)equality comparisons on floating-point values (apart from zero), except in functions called `*eq*` (which probably implement equality for a type involving floats). It is `Warn` by default.\n+///\n+/// **Why is this bad?** Floating point calculations are usually imprecise, so asking if two values are *exactly* equal is asking for trouble. For a good guide on what to do, see [the floating point guide](http://www.floating-point-gui.de/errors/comparison).\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `y == 1.23f64`\n declare_lint!(pub FLOAT_CMP, Warn,\n               \"using `==` or `!=` on float values (as floating-point operations \\\n                usually involve rounding errors, it is always better to check for approximate \\\n@@ -155,6 +178,13 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n     }\n }\n \n+/// **What it does:** This lint checks for conversions to owned values just for the sake of a comparison. It is `Warn` by default.\n+///\n+/// **Why is this bad?** The comparison can operate on a reference, so creating an owned value effectively throws it away directly afterwards, which is needlessly consuming code and heap space.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `x.to_owned() == y`\n declare_lint!(pub CMP_OWNED, Warn,\n               \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\");\n \n@@ -221,6 +251,13 @@ fn is_str_arg(cx: &LateContext, args: &[P<Expr>]) -> bool {\n         walk_ptrs_ty(cx.tcx.expr_ty(&args[0])).sty { true } else { false }\n }\n \n+/// **What it does:** This lint checks for getting the remainder of a division by one. It is `Warn` by default.\n+///\n+/// **Why is this bad?** The result can only ever be zero. No one will write such code deliberately, unless trying to win an Underhanded Rust Contest. Even for that contest, it's probably a bad idea. Use something more underhanded.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `x % 1`\n declare_lint!(pub MODULO_ONE, Warn, \"taking a number modulo 1, which always returns 0\");\n \n #[derive(Copy,Clone)]\n@@ -244,6 +281,19 @@ impl LateLintPass for ModuloOne {\n     }\n }\n \n+/// **What it does:** This lint checks for patterns in the form `name @ _`.\n+///\n+/// **Why is this bad?** It's almost always more readable to just use direct bindings.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example**:\n+/// ```\n+/// match v {\n+///     Some(x) => (),\n+///     y @ _   => (), // easier written as `y`,\n+/// }\n+/// ```\n declare_lint!(pub REDUNDANT_PATTERN, Warn, \"using `name @ _` in a pattern\");\n \n #[derive(Copy,Clone)]"}, {"sha": "ade688d377ff9f7bc3f3c8567c69b2040be1f9e8", "filename": "src/mut_mut.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -4,6 +4,13 @@ use rustc::middle::ty::{TypeAndMut, TyRef};\n \n use utils::{in_external_macro, span_lint};\n \n+/// **What it does:** This lint checks for instances of `mut mut` references. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Multiple `mut`s don't add anything meaningful to the source.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `let x = &mut &mut y;`\n declare_lint!(pub MUT_MUT, Allow,\n               \"usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, \\\n                or shows a fundamental misunderstanding of references)\");"}, {"sha": "9ba9782336a277ed842a62c9a582d99156fc53c1", "filename": "src/mut_reference.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -4,6 +4,13 @@ use utils::span_lint;\n use rustc::middle::ty::{TypeAndMut, TypeVariants, MethodCall, TyS};\n use syntax::ptr::P;\n \n+/// **What it does:** This lint detects giving a mutable reference to a function that only requires an immutable reference.\n+///\n+/// **Why is this bad?** The immutable reference rules out all other references to the value. Also the code misleads about the intent of the call site.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example** `my_vec.push(&mut value)`\n declare_lint! {\n     pub UNNECESSARY_MUT_PASSED,\n     Warn,"}, {"sha": "bd2e4116fd01d27596252355be54ba78b5903a74", "filename": "src/needless_bool.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -9,6 +9,13 @@ use syntax::ast::Lit_::*;\n \n use utils::{span_lint, snippet};\n \n+/// **What it does:** This lint checks for expressions of the form `if c { true } else { false }` (or vice versa) and suggest using the condition directly. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Redundant code.\n+///\n+/// **Known problems:** Maybe false positives: Sometimes, the two branches are painstakingly documented (which we of course do not detect), so they *may* have some value. Even then, the documentation can be rewritten to match the shorter code.\n+///\n+/// **Example:** `if x { false } else { true }`\n declare_lint! {\n     pub NEEDLESS_BOOL,\n     Warn,"}, {"sha": "31ca0d729395f4a5a3497ede7db8176545e23d15", "filename": "src/open_options.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fopen_options.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -4,6 +4,13 @@ use utils::{walk_ptrs_ty_depth, match_type, span_lint, OPEN_OPTIONS_PATH};\n use syntax::codemap::{Span, Spanned};\n use syntax::ast::Lit_::LitBool;\n \n+/// **What it does:** This lint checks for duplicate open options as well as combinations that make no sense. It is `Warn` by default.\n+///\n+/// **Why is this bad?** In the best case, the code will be harder to read than necessary. I don't know the worst case.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `OpenOptions::new().read(true).truncate(true)`\n declare_lint! {\n     pub NONSENSICAL_OPEN_OPTIONS,\n     Warn,"}, {"sha": "be5f44c823a71245d38df0e4b1cc57e7ac897b38", "filename": "src/precedence.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -5,6 +5,17 @@ use syntax::ast_util::binop_to_string;\n \n use utils::{span_lint, snippet};\n \n+/// **What it does:** This lint checks for operations where precedence may be unclear and `Warn`'s about them by default, suggesting to add parentheses. Currently it catches the following:\n+/// * mixed usage of arithmetic and bit shifting/combining operators without parentheses\n+/// * a \"negative\" numeric literal (which is really a unary `-` followed by a numeric literal) followed by a method call\n+///\n+/// **Why is this bad?** Because not everyone knows the precedence of those operators by heart, so expressions like these may trip others trying to reason about the code.\n+///\n+/// **Known problems:** None\n+///\n+/// **Examples:**\n+/// * `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n+/// * `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1\n declare_lint!(pub PRECEDENCE, Warn,\n               \"catches operations where precedence may be unclear. See the wiki for a \\\n                list of cases caught\");"}, {"sha": "f748dbd9cfa2efe20f0506f8e4b4d12993c153a2", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -10,6 +10,13 @@ use rustc::front::map::Node;\n use utils::{span_lint, match_type};\n use utils::{STRING_PATH, VEC_PATH};\n \n+/// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless the references are mutable. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Requiring the argument to be of the specific size makes the function less useful for no benefit; slices in the form of `&[T]` or `&str` usually suffice and can be obtained from other types, too.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `fn foo(&Vec<u32>) { .. }`\n declare_lint! {\n     pub PTR_ARG,\n     Warn,"}, {"sha": "48bbba734ffa61d47ab5bb7727be7aeafb2fd1f0", "filename": "src/ranges.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -3,10 +3,24 @@ use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n use utils::{is_integer_literal, match_type, snippet};\n \n+/// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates. It is `Warn` by default.\n+///\n+/// **Why is this bad?** This very much looks like an oversight, since with `loop { .. }` there is an obvious better way to endlessly loop.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `for x in (5..5).step_by(0) { .. }`\n declare_lint! {\n     pub RANGE_STEP_BY_ZERO, Warn,\n     \"using Range::step_by(0), which produces an infinite iterator\"\n }\n+/// **What it does:** This lint checks for zipping a collection with the range of `0.._.len()`. It is `Warn` by default.\n+///\n+/// **Why is this bad?** The code is better expressed with `.enumerate()`.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `x.iter().zip(0..x.len())`\n declare_lint! {\n     pub RANGE_ZIP_WITH_LEN, Warn,\n     \"zipping iterator with a range when enumerate() would do\""}, {"sha": "cf27b117ac4da0d3a261df83abd4c352d31883a0", "filename": "src/returns.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -6,8 +6,22 @@ use syntax::visit::FnKind;\n \n use utils::{span_lint, snippet, match_path_ast, in_external_macro};\n \n+/// **What it does:** This lint checks for return statements at the end of a block. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Removing the `return` and semicolon will make the code more rusty.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `fn foo(x: usize) { return x; }`\n declare_lint!(pub NEEDLESS_RETURN, Warn,\n               \"using a return statement like `return expr;` where an expression would suffice\");\n+/// **What it does:** This lint checks for `let`-bindings, which are subsequently returned. It is `Warn` by default.\n+///\n+/// **Why is this bad?** It is just extraneous code. Remove it to make your code more rusty.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `{ let x = ..; x }`\n declare_lint!(pub LET_AND_RETURN, Warn,\n               \"creating a let-binding and then immediately returning it like `let x = expr; x` at \\\n                the end of a block\");"}, {"sha": "27bed50c26331bc8353f42630a8a218ff636a47d", "filename": "src/shadow.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -9,11 +9,32 @@ use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n use utils::{is_from_for_desugar, in_external_macro, snippet, span_lint, span_note_and_lint};\n \n+/// **What it does:** This lint checks for bindings that shadow other bindings already in scope, while just changing reference level or mutability. It is `Allow` by default.\n+///\n+/// **Why is this bad?** Not much, in fact it's a very common pattern in Rust code. Still, some may opt to avoid it in their code base, they can set this lint to `Warn`.\n+///\n+/// **Known problems:** This lint, as the other shadowing related lints, currently only catches very simple patterns.\n+///\n+/// **Example:** `let x = &x;`\n declare_lint!(pub SHADOW_SAME, Allow,\n     \"rebinding a name to itself, e.g. `let mut x = &mut x`\");\n+/// **What it does:** This lint checks for bindings that shadow other bindings already in scope, while reusing the original value. It is `Allow` by default.\n+///\n+/// **Why is this bad?** Not too much, in fact it's a common pattern in Rust code. Still, some argue that name shadowing like this hurts readability, because a value may be bound to different things depending on position in the code.\n+///\n+/// **Known problems:** This lint, as the other shadowing related lints, currently only catches very simple patterns.\n+///\n+/// **Example:** `let x = x + 1;`\n declare_lint!(pub SHADOW_REUSE, Allow,\n     \"rebinding a name to an expression that re-uses the original value, e.g. \\\n     `let x = x + 1`\");\n+/// **What it does:** This lint checks for bindings that shadow other bindings already in scope, either without a initialization or with one that does not even use the original value. This lint is `Warn` by default.\n+///\n+/// **Why is this bad?** Name shadowing can hurt readability, especially in large code bases, because it is easy to lose track of the active binding at any place in the code. This can be alleviated by either giving more specific names to bindings ore introducing more scopes to contain the bindings.\n+///\n+/// **Known problems:** This lint, as the other shadowing related lints, currently only catches very simple patterns.\n+///\n+/// **Example:** `let x = y; let x = z; // shadows the earlier binding`\n declare_lint!(pub SHADOW_UNRELATED, Allow,\n     \"The name is re-bound without even using the original value\");\n "}, {"sha": "b567d949330846eff971cf7516de9dc1568679d3", "filename": "src/strings.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -11,12 +11,38 @@ use eq_op::is_exp_equal;\n use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n use utils::STRING_PATH;\n \n+/// **What it does:** This lint matches code of the form `x = x + y` (without `let`!)\n+///\n+/// **Why is this bad?** Because this expression needs another copy as opposed to `x.push_str(y)` (in practice LLVM will usually elide it, though). Despite [llogiq](https://github.com/llogiq)'s reservations, this lint also is `allow` by default, as some people opine that it's more readable.\n+///\n+/// **Known problems:** None. Well apart from the lint being `allow` by default. :smile:\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// let mut x = \"Hello\".to_owned();\n+/// x = x + \", World\";\n+/// ```\n declare_lint! {\n     pub STRING_ADD_ASSIGN,\n     Allow,\n     \"using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\"\n }\n \n+/// **What it does:** The `string_add` lint matches all instances of `x + _` where `x` is of type `String`, but only if [`string_add_assign`](#string_add_assign) does *not* match.  It is `Allow` by default.\n+///\n+/// **Why is this bad?** It's not bad in and of itself. However, this particular `Add` implementation is asymmetric (the other operand need not be `String`, but `x` does), while addition as mathematically defined is symmetric, also the `String::push_str(_)` function is a perfectly good replacement. Therefore some dislike it and wish not to have it in their code.\n+///\n+/// That said, other people think that String addition, having a long tradition in other languages is actually fine, which is why we decided to make this particular lint `allow` by default.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// let x = \"Hello\".to_owned();\n+/// x + \", World\"\n+/// ```\n declare_lint! {\n     pub STRING_ADD,\n     Allow,"}, {"sha": "c505b612a8c18129f4c233125adabb0b8e80cb40", "filename": "src/types.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -17,8 +17,26 @@ use utils::{LL_PATH, VEC_PATH};\n #[allow(missing_copy_implementations)]\n pub struct TypePass;\n \n+/// **What it does:** This lint checks for use of `Box<Vec<_>>` anywhere in the code.\n+///\n+/// **Why is this bad?** `Vec` already keeps its contents in a separate area on the heap. So if you `Box` it, you just add another level of indirection without any benefit whatsoever.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `struct X { values: Box<Vec<Foo>> }`\n declare_lint!(pub BOX_VEC, Warn,\n               \"usage of `Box<Vec<T>>`, vector elements are already on the heap\");\n+/// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or `RingBuf`.\n+///\n+/// **Why is this bad?** Gankro says:\n+///\n+/// >The TL;DR of `LinkedList` is that it's built on a massive amount of pointers and indirection. It wastes memory, it has terrible cache locality, and is all-around slow. `RingBuf`, while \"only\" amortized for push/pop, should be faster in the general case for almost every possible workload, and isn't even amortized at all if you can predict the capacity you need.\n+/// >\n+/// > `LinkedList`s are only really good if you're doing a lot of merging or splitting of lists. This is because they can just mangle some pointers instead of actually copying the data. Even if you're doing a lot of insertion in the middle of the list, `RingBuf` can still be better because of how expensive it is to seek to the middle of a `LinkedList`.\n+///\n+/// **Known problems:** False positives \u2013 the instances where using a `LinkedList` makes sense are few and far between, but they can still happen.\n+///\n+/// **Example:** `let x = LinkedList::new();`\n declare_lint!(pub LINKEDLIST, Warn,\n               \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n                structure like a VecDeque\");\n@@ -53,6 +71,13 @@ impl LateLintPass for TypePass {\n #[allow(missing_copy_implementations)]\n pub struct LetPass;\n \n+/// **What it does:** This lint checks for binding a unit value. It is `Warn` by default.\n+///\n+/// **Why is this bad?** A unit value cannot usefully be used anywhere. So binding one is kind of pointless.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `let x = { 1; };`\n declare_lint!(pub LET_UNIT_VALUE, Warn,\n               \"creating a let binding to a value of unit type, which usually can't be used afterwards\");\n \n@@ -82,6 +107,13 @@ impl LateLintPass for LetPass {\n     }\n }\n \n+/// **What it does:** This lint checks for comparisons to unit. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Unit is always equal to itself, and thus is just a clumsily written constant. Mostly this happens when someone accidentally adds semicolons at the end of the operands.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `if { foo(); } == { bar(); } { baz(); }` is equal to `{ foo(); bar(); baz(); }`\n declare_lint!(pub UNIT_CMP, Warn,\n               \"comparing unit values (which is always `true` or `false`, respectively)\");\n \n@@ -115,12 +147,42 @@ impl LateLintPass for UnitCmp {\n \n pub struct CastPass;\n \n+/// **What it does:** This lint checks for casts from any numerical to a float type where the receiving type cannot store all values from the original type without rounding errors. This possible rounding is to be expected, so this lint is `Allow` by default.\n+///\n+/// Basically, this warns on casting any integer with 32 or more bits to `f32` or any 64-bit integer to `f64`.\n+///\n+/// **Why is this bad?** It's not bad at all. But in some applications it can be helpful to know where precision loss can take place. This lint can help find those places in the code.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `let x = u64::MAX; x as f64`\n declare_lint!(pub CAST_PRECISION_LOSS, Allow,\n               \"casts that cause loss of precision, e.g `x as f32` where `x: u64`\");\n+/// **What it does:** This lint checks for casts from a signed to an unsigned numerical type. In this case, negative values wrap around to large positive values, which can be quite surprising in practice. However, as the cast works as defined, this lint is `Allow` by default.\n+///\n+/// **Why is this bad?** Possibly surprising results. You can activate this lint as a one-time check to see where numerical wrapping can arise.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `let y : i8 = -1; y as u64` will return 18446744073709551615\n declare_lint!(pub CAST_SIGN_LOSS, Allow,\n               \"casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\");\n+/// **What it does:** This lint checks for on casts between numerical types that may truncate large values. This is expected behavior, so the cast is `Allow` by default.\n+///\n+/// **Why is this bad?** In some problem domains, it is good practice to avoid truncation. This lint can be activated to help assess where additional checks could be beneficial.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `fn as_u8(x: u64) -> u8 { x as u8 }`\n declare_lint!(pub CAST_POSSIBLE_TRUNCATION, Allow,\n               \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\");\n+/// **What it does:** This lint checks for casts from an unsigned type to a signed type of the same size. Performing such a cast is a 'no-op' for the compiler, i.e. nothing is changed at the bit level, and the binary representation of the value is reinterpreted. This can cause wrapping if the value is too big for the target signed type. However, the cast works as defined, so this lint is `Allow` by default.\n+///\n+/// **Why is this bad?** While such a cast is not bad in itself, the results can be surprising when this is not the intended behavior, as demonstrated by the example below.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `u32::MAX as i32` will yield a value of `-1`.\n declare_lint!(pub CAST_POSSIBLE_WRAP, Allow,\n               \"casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\");\n \n@@ -262,6 +324,13 @@ impl LateLintPass for CastPass {\n     }\n }\n \n+/// **What it does:** This lint checks for types used in structs, parameters and `let` declarations above a certain complexity threshold. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Too complex types make the code less readable. Consider using a `type` definition to simplify them.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `struct Foo { inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>> }`\n declare_lint!(pub TYPE_COMPLEXITY, Warn,\n               \"usage of very complex types; recommends factoring out parts into `type` definitions\");\n "}, {"sha": "a5b03087604d50c3139338510c39b1ec583ff497", "filename": "src/unicode.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -8,11 +8,32 @@ use unicode_normalization::UnicodeNormalization;\n \n use utils::{snippet, span_help_and_lint};\n \n+/// **What it does:** This lint checks for the unicode zero-width space in the code. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Having an invisible character in the code makes for all sorts of April fools, but otherwise is very much frowned upon.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** You don't see it, but there may be a zero-width space somewhere in this text.\n declare_lint!{ pub ZERO_WIDTH_SPACE, Deny,\n                \"using a zero-width space in a string literal, which is confusing\" }\n+/// **What it does:** This lint checks for non-ascii characters in string literals. It is `Allow` by default.\n+///\n+/// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset back. Even so, there still are editors and other programs out there that don't work well with unicode. So if the code is meant to be used internationally, on multiple operating systems, or has other portability requirements, activating this lint could be useful.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `let x = \"H\u00e4?\"`\n declare_lint!{ pub NON_ASCII_LITERAL, Allow,\n                \"using any literal non-ASCII chars in a string literal; suggests \\\n                 using the \\\\u escape instead\" }\n+/// **What it does:** This lint checks for string literals that contain unicode in a form that is not equal to its [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms). This lint is `Allow` by default.\n+///\n+/// **Why is this bad?** If such a string is compared to another, the results may be surprising.\n+///\n+/// **Known problems** None\n+///\n+/// **Example:** You may not see it, but \"a\u0300\" and \"\u00e0\" aren't the same string. The former when escaped is actually \"a\\u{300}\" while the latter is \"\\u{e0}\".\n declare_lint!{ pub UNICODE_NOT_NFC, Allow,\n                \"using a unicode literal not in NFC normal form (see \\\n                http://www.unicode.org/reports/tr15/ for further information)\" }"}, {"sha": "c4d7cf4a58924cb7e720fc26c535a7e022f605b0", "filename": "src/zero_div_zero.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/src%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fzero_div_zero.rs?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -9,6 +9,13 @@ use consts::{Constant, constant_simple, FloatWidth};\n /// 0.0/0.0 with std::f32::NaN or std::f64::NaN, depending on the precision.\n pub struct ZeroDivZeroPass;\n \n+/// **What it does:** This lint checks for `0.0 / 0.0`\n+///\n+/// **Why is this bad?** It's less readable than `std::f32::NAN` or `std::f64::NAN`\n+///\n+/// **Known problems:** None\n+///\n+/// **Example** `0.0f32 / 0.0`\n declare_lint!(pub ZERO_DIVIDED_BY_ZERO, Warn,\n               \"usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\");\n "}, {"sha": "96333c1e4b3a128b64a2125ca114979305520b56", "filename": "util/update_wiki.py", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6aa656a910d0396c86e19fb4d850033786fce516/util%2Fupdate_wiki.py", "raw_url": "https://github.com/rust-lang/rust/raw/6aa656a910d0396c86e19fb4d850033786fce516/util%2Fupdate_wiki.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_wiki.py?ref=6aa656a910d0396c86e19fb4d850033786fce516", "patch": "@@ -0,0 +1,90 @@\n+#!/usr/bin/env python\n+# Generate the wiki Home.md page from the contained doc comments\n+# requires the checked out wiki in ../rust-clippy.wiki/\n+# with -c option, print a warning and set exit status 1 if the file would be changed.\n+import os, re, sys\n+\n+def parse_path(p=\"src\"):\n+    d = {}\n+    for f in os.listdir(p):\n+        if f.endswith(\".rs\"):\n+            parse_file(d, os.path.join(p, f))\n+    return d\n+\n+START = 0\n+LINT = 1\n+\n+def parse_file(d, f):\n+    last_comment = []\n+    comment = True\n+    lint = None\n+\n+    with open(f) as rs:\n+        for line in rs:\n+            if comment:\n+                if line.startswith(\"///\"):\n+                    if line.startswith(\"/// \"):\n+                        last_comment.append(line[4:])\n+                    else:\n+                        last_comment.append(line[3:])\n+                elif line.startswith(\"declare_lint!\"):\n+                    comment = False\n+                else:\n+                    last_comment = []\n+            if not comment:\n+                l = line.strip()\n+                m = re.search(r\"pub\\s+([A-Z_]+)\", l)\n+                if m:\n+                    print \"found %s in %s\" % (m.group(1).lower(), f)\n+                    d[m.group(1).lower()] = last_comment\n+                    last_comment = []\n+                    comment = True\n+                if \"}\" in l:\n+                    print \"Warning: Missing Lint-Name in\", f\n+                    comment = True\n+\n+PREFIX = \"\"\"Welcome to the rust-clippy wiki!\n+\n+Here we aim to collect further explanations on the lints clippy provides. So without further ado:\n+\n+\"\"\"\n+\n+WARNING = \"\"\"\n+# A word of warning\n+\n+Clippy works as a *plugin* to the compiler, which means using an unstable internal API. We have gotten quite good at keeping pace with the API evolution, but the consequence is that clippy absolutely needs to be compiled with the version of `rustc` it will run on, otherwise you will get strange errors of missing symbols.\"\"\"\n+\n+def write_wiki_page(d, f):\n+    keys = d.keys()\n+    keys.sort()\n+    with open(f, \"w\") as w:\n+        w.write(PREFIX)\n+        for k in keys:\n+            w.write(\"[`%s`](#%s)\\n\" % (k, k))\n+        w.write(WARNING)\n+        for k in keys:\n+            w.write(\"\\n# `%s`\\n\\n%s\" % (k, \"\".join(d[k])))\n+\n+def check_wiki_page(d, f):\n+    errors = []\n+    with open(f) as w:\n+        for line in w:\n+            m = re.match(\"# `([a-z_]+)`\", line)\n+            if m:\n+                v = d.pop(m.group(1), \"()\")\n+                if v == \"()\":\n+                    errors.append(\"Missing wiki entry: \" + m.group(1))\n+    keys = d.keys()\n+    keys.sort()\n+    for k in keys:\n+        errors.append(\"Spurious wiki entry: \" + k)\n+    if errors:\n+        print \"\\n\".join(errors)\n+        sys.exit(1)\n+\n+if __name__ == \"__main__\":\n+    d = parse_path()\n+    if \"-c\" in sys.argv:\n+        check_wiki_page(d, \"../rust-clippy.wiki/Home.md\")\n+    else:\n+        write_wiki_page(d, \"../rust-clippy.wiki/Home.md\")"}]}