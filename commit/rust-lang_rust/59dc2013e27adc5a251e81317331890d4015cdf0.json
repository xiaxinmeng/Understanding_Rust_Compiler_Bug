{"sha": "59dc2013e27adc5a251e81317331890d4015cdf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZGMyMDEzZTI3YWRjNWEyNTFlODEzMTczMzE4OTBkNDAxNWNkZjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-11-23T15:21:54Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-09-17T16:47:48Z"}, "message": "optimization: use a single DepthFirstSearch instead of hashsets\n\nExtend the `DepthFirstSearch` iterator so that it can be re-used and\nextended with add'l start nodes. Then replace the FxHashSets of nodes\nwe were using in the fallback analysis with a single iterator. This\nway we won't re-walk portions of the graph that are reached more than\nonce, and we also do less allocation etc.", "tree": {"sha": "772112a556eed71525d29d801c16cb8e6d9be11b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/772112a556eed71525d29d801c16cb8e6d9be11b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59dc2013e27adc5a251e81317331890d4015cdf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59dc2013e27adc5a251e81317331890d4015cdf0", "html_url": "https://github.com/rust-lang/rust/commit/59dc2013e27adc5a251e81317331890d4015cdf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59dc2013e27adc5a251e81317331890d4015cdf0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc2ece2a8d14b1ec6f2e92b316e1a7c4fd216c9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc2ece2a8d14b1ec6f2e92b316e1a7c4fd216c9a", "html_url": "https://github.com/rust-lang/rust/commit/bc2ece2a8d14b1ec6f2e92b316e1a7c4fd216c9a"}], "stats": {"total": 23, "additions": 16, "deletions": 7}, "files": [{"sha": "508cea2845a62a6cc526fcdfcd5db16fe646298e", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59dc2013e27adc5a251e81317331890d4015cdf0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59dc2013e27adc5a251e81317331890d4015cdf0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=59dc2013e27adc5a251e81317331890d4015cdf0", "patch": "@@ -1,6 +1,9 @@\n use crate::check::FnCtxt;\n use rustc_data_structures::{\n-    fx::FxHashMap, graph::vec_graph::VecGraph, graph::WithSuccessors, stable_set::FxHashSet,\n+    fx::FxHashMap,\n+    graph::WithSuccessors,\n+    graph::{iterate::DepthFirstSearch, vec_graph::VecGraph},\n+    stable_set::FxHashSet,\n };\n use rustc_middle::ty::{self, Ty};\n \n@@ -280,7 +283,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // type variable. These will typically default to `!`, unless\n         // we find later that they are *also* reachable from some\n         // other type variable outside this set.\n-        let mut roots_reachable_from_diverging = FxHashSet::default();\n+        let mut roots_reachable_from_diverging = DepthFirstSearch::new(&coercion_graph);\n         let mut diverging_vids = vec![];\n         let mut non_diverging_vids = vec![];\n         for unsolved_vid in unsolved_vids {\n@@ -293,16 +296,21 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             );\n             if diverging_roots.contains(&root_vid) {\n                 diverging_vids.push(unsolved_vid);\n+                roots_reachable_from_diverging.push_start_node(root_vid);\n+\n                 debug!(\n                     \"calculate_diverging_fallback: root_vid={:?} reaches {:?}\",\n                     root_vid,\n                     coercion_graph.depth_first_search(root_vid).collect::<Vec<_>>()\n                 );\n-                roots_reachable_from_diverging.extend(coercion_graph.depth_first_search(root_vid));\n+\n+                // drain the iterator to visit all nodes reachable from this node\n+                roots_reachable_from_diverging.complete_search();\n             } else {\n                 non_diverging_vids.push(unsolved_vid);\n             }\n         }\n+\n         debug!(\n             \"calculate_diverging_fallback: roots_reachable_from_diverging={:?}\",\n             roots_reachable_from_diverging,\n@@ -312,13 +320,14 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // diverging variable, and then compute the set reachable from\n         // N0, which we call N. These are the *non-diverging* type\n         // variables. (Note that this set consists of \"root variables\".)\n-        let mut roots_reachable_from_non_diverging = FxHashSet::default();\n+        let mut roots_reachable_from_non_diverging = DepthFirstSearch::new(&coercion_graph);\n         for &non_diverging_vid in &non_diverging_vids {\n             let root_vid = self.infcx.root_var(non_diverging_vid);\n-            if roots_reachable_from_diverging.contains(&root_vid) {\n+            if roots_reachable_from_diverging.visited(root_vid) {\n                 continue;\n             }\n-            roots_reachable_from_non_diverging.extend(coercion_graph.depth_first_search(root_vid));\n+            roots_reachable_from_non_diverging.push_start_node(root_vid);\n+            roots_reachable_from_non_diverging.complete_search();\n         }\n         debug!(\n             \"calculate_diverging_fallback: roots_reachable_from_non_diverging={:?}\",\n@@ -334,7 +343,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             let root_vid = self.infcx.root_var(diverging_vid);\n             let can_reach_non_diverging = coercion_graph\n                 .depth_first_search(root_vid)\n-                .any(|n| roots_reachable_from_non_diverging.contains(&n));\n+                .any(|n| roots_reachable_from_non_diverging.visited(n));\n             if can_reach_non_diverging {\n                 debug!(\"fallback to (): {:?}\", diverging_vid);\n                 diverging_fallback.insert(diverging_ty, self.tcx.types.unit);"}]}