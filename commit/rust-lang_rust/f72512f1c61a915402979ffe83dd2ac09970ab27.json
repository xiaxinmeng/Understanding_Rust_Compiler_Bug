{"sha": "f72512f1c61a915402979ffe83dd2ac09970ab27", "node_id": "C_kwDOAAsO6NoAKGY3MjUxMmYxYzYxYTkxNTQwMjk3OWZmZTgzZGQyYWMwOTk3MGFiMjc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-17T19:51:15Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-17T20:02:33Z"}, "message": "Simplify", "tree": {"sha": "31d7f6f05c2f0333a97674288f8208f92dd6e591", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31d7f6f05c2f0333a97674288f8208f92dd6e591"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f72512f1c61a915402979ffe83dd2ac09970ab27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f72512f1c61a915402979ffe83dd2ac09970ab27", "html_url": "https://github.com/rust-lang/rust/commit/f72512f1c61a915402979ffe83dd2ac09970ab27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f72512f1c61a915402979ffe83dd2ac09970ab27/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91bbc55eedbc0f6947b69a0158a7b6c81264024e", "url": "https://api.github.com/repos/rust-lang/rust/commits/91bbc55eedbc0f6947b69a0158a7b6c81264024e", "html_url": "https://github.com/rust-lang/rust/commit/91bbc55eedbc0f6947b69a0158a7b6c81264024e"}], "stats": {"total": 118, "additions": 35, "deletions": 83}, "files": [{"sha": "b68ede40039138f02ea71e51ecfb18dd0415fbcd", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f72512f1c61a915402979ffe83dd2ac09970ab27/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72512f1c61a915402979ffe83dd2ac09970ab27/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=f72512f1c61a915402979ffe83dd2ac09970ab27", "patch": "@@ -776,13 +776,10 @@ fn attr_macro_as_call_id(\n     macro_attr: &Attr,\n     db: &dyn db::DefDatabase,\n     krate: CrateId,\n-    resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+    def: Option<MacroDefId>,\n ) -> Result<MacroCallId, UnresolvedMacro> {\n     let attr_path = &item_attr.path;\n-\n-    let def = resolver(attr_path.clone())\n-        .filter(MacroDefId::is_attribute)\n-        .ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n+    let def = def.ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n     let last_segment =\n         attr_path.segments().last().ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n     let mut arg = match macro_attr.input.as_deref() {"}, {"sha": "bafba0672fceab9db07481acde1d4ec47689189e", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 32, "deletions": 77, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f72512f1c61a915402979ffe83dd2ac09970ab27/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72512f1c61a915402979ffe83dd2ac09970ab27/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=f72512f1c61a915402979ffe83dd2ac09970ab27", "patch": "@@ -1054,14 +1054,15 @@ impl DefCollector<'_> {\n \n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n-                    match macro_call_as_call_id(\n+                    let call_id = macro_call_as_call_id(\n                         ast_id,\n                         *expand_to,\n                         self.db,\n                         self.def_map.krate,\n                         &resolver,\n                         &mut |_err| (),\n-                    ) {\n+                    );\n+                    match call_id {\n                         Ok(Ok(call_id)) => {\n                             resolved.push((directive.module_id, call_id, directive.depth));\n                             res = ReachedFixedPoint::No;\n@@ -1071,13 +1072,14 @@ impl DefCollector<'_> {\n                     }\n                 }\n                 MacroDirectiveKind::Derive { ast_id, derive_attr } => {\n-                    match derive_macro_as_call_id(\n+                    let call_id = derive_macro_as_call_id(\n                         ast_id,\n                         *derive_attr,\n                         self.db,\n                         self.def_map.krate,\n                         &resolver,\n-                    ) {\n+                    );\n+                    match call_id {\n                         Ok(call_id) => {\n                             self.def_map.modules[directive.module_id].scope.add_derive_macro_invoc(\n                                 ast_id.ast_id,\n@@ -1089,34 +1091,36 @@ impl DefCollector<'_> {\n                             res = ReachedFixedPoint::No;\n                             return false;\n                         }\n-                        Err(UnresolvedMacro { .. }) => (),\n+                        Err(UnresolvedMacro { .. }) => {}\n                     }\n                 }\n                 MacroDirectiveKind::Attr { ast_id, mod_item, attr } => {\n+                    let file_id = ast_id.ast_id.file_id;\n+                    let mut recollect_without = |collector: &mut Self, item_tree| {\n+                        // Remove the original directive since we resolved it.\n+                        let mod_dir = collector.mod_dirs[&directive.module_id].clone();\n+                        collector.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n+                        ModCollector {\n+                            def_collector: collector,\n+                            macro_depth: directive.depth,\n+                            module_id: directive.module_id,\n+                            tree_id: TreeId::new(file_id, None),\n+                            item_tree,\n+                            mod_dir,\n+                        }\n+                        .collect(&[*mod_item]);\n+                        res = ReachedFixedPoint::No;\n+                        false\n+                    };\n+\n                     if let Some(ident) = ast_id.path.as_ident() {\n                         if let Some(helpers) = self.derive_helpers_in_scope.get(&ast_id.ast_id) {\n                             if helpers.contains(ident) {\n                                 cov_mark::hit!(resolved_derive_helper);\n-\n                                 // Resolved to derive helper. Collect the item's attributes again,\n                                 // starting after the derive helper.\n-                                let file_id = ast_id.ast_id.file_id;\n                                 let item_tree = self.db.file_item_tree(file_id);\n-                                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n-                                self.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n-                                ModCollector {\n-                                    def_collector: self,\n-                                    macro_depth: directive.depth,\n-                                    module_id: directive.module_id,\n-                                    tree_id: TreeId::new(file_id, None),\n-                                    item_tree: &item_tree,\n-                                    mod_dir,\n-                                }\n-                                .collect(&[*mod_item]);\n-\n-                                // Remove the original directive since we resolved it.\n-                                res = ReachedFixedPoint::No;\n-                                return false;\n+                                return recollect_without(self, &item_tree);\n                             }\n                         }\n                     }\n@@ -1127,7 +1131,7 @@ impl DefCollector<'_> {\n                         Some(MacroDefId {  kind:MacroDefKind::BuiltInAttr(expander, _),.. })\n                         if expander.is_derive()\n                     ) {\n-                        // Resolved to derive\n+                        // Resolved to `#[derive]`\n                         let file_id = ast_id.ast_id.file_id;\n                         let item_tree = self.db.file_item_tree(file_id);\n \n@@ -1163,35 +1167,15 @@ impl DefCollector<'_> {\n                             }\n                         }\n \n-                        let mod_dir = self.mod_dirs[&directive.module_id].clone();\n-                        self.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n-                        ModCollector {\n-                            def_collector: &mut *self,\n-                            macro_depth: directive.depth,\n-                            module_id: directive.module_id,\n-                            tree_id: TreeId::new(file_id, None),\n-                            item_tree: &item_tree,\n-                            mod_dir,\n-                        }\n-                        .collect(&[*mod_item]);\n-\n-                        // Remove the original directive since we resolved it.\n-                        res = ReachedFixedPoint::No;\n-                        return false;\n+                        return recollect_without(self, &item_tree);\n                     }\n \n                     if !self.db.enable_proc_attr_macros() {\n                         return true;\n                     }\n \n-                    // Not resolved to a derive helper, so try to resolve as a macro.\n-                    match attr_macro_as_call_id(\n-                        ast_id,\n-                        attr,\n-                        self.db,\n-                        self.def_map.krate,\n-                        &resolver,\n-                    ) {\n+                    // Not resolved to a derive helper or the derive attribute, so try to resolve as a normal attribute.\n+                    match attr_macro_as_call_id(ast_id, attr, self.db, self.def_map.krate, def) {\n                         Ok(call_id) => {\n                             let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n \n@@ -1202,23 +1186,8 @@ impl DefCollector<'_> {\n                                 MacroDefKind::BuiltInAttr(expander, _)\n                                 if expander.is_test() || expander.is_bench()\n                             ) {\n-                                let file_id = ast_id.ast_id.file_id;\n                                 let item_tree = self.db.file_item_tree(file_id);\n-                                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n-                                self.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n-                                ModCollector {\n-                                    def_collector: &mut *self,\n-                                    macro_depth: directive.depth,\n-                                    module_id: directive.module_id,\n-                                    tree_id: TreeId::new(file_id, None),\n-                                    item_tree: &item_tree,\n-                                    mod_dir,\n-                                }\n-                                .collect(&[*mod_item]);\n-\n-                                // Remove the original directive since we resolved it.\n-                                res = ReachedFixedPoint::No;\n-                                return false;\n+                                return recollect_without(self, &item_tree);\n                             }\n \n                             if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n@@ -1234,21 +1203,7 @@ impl DefCollector<'_> {\n \n                                     let file_id = ast_id.ast_id.file_id;\n                                     let item_tree = self.db.file_item_tree(file_id);\n-                                    let mod_dir = self.mod_dirs[&directive.module_id].clone();\n-                                    self.skip_attrs\n-                                        .insert(InFile::new(file_id, *mod_item), attr.id);\n-                                    ModCollector {\n-                                        def_collector: &mut *self,\n-                                        macro_depth: directive.depth,\n-                                        module_id: directive.module_id,\n-                                        tree_id: TreeId::new(file_id, None),\n-                                        item_tree: &item_tree,\n-                                        mod_dir,\n-                                    }\n-                                    .collect(&[*mod_item]);\n-\n-                                    // Remove the macro directive.\n-                                    return false;\n+                                    return recollect_without(self, &item_tree);\n                                 }\n                             }\n "}, {"sha": "9e555dc49e62415f554bb94dcb80bd30d6ca4ac9", "filename": "crates/rust-analyzer/tests/slow-tests/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f72512f1c61a915402979ffe83dd2ac09970ab27/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72512f1c61a915402979ffe83dd2ac09970ab27/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs?ref=f72512f1c61a915402979ffe83dd2ac09970ab27", "patch": "@@ -878,7 +878,7 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n     let res = server.send_request::<HoverRequest>(HoverParams {\n         text_document_position_params: TextDocumentPositionParams::new(\n             server.doc_id(\"foo/src/main.rs\"),\n-            Position::new(7, 9),\n+            Position::new(10, 9),\n         ),\n         work_done_progress_params: Default::default(),\n     });"}]}