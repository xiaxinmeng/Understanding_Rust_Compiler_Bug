{"sha": "f4a775639ca846f29abeed16a7b4e8e1c8819626", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YTc3NTYzOWNhODQ2ZjI5YWJlZWQxNmE3YjRlOGUxYzg4MTk2MjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-26T17:44:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-27T00:49:46Z"}, "message": "rollup merge of #19298: nikomatsakis/unboxed-closure-parse-the-plus\n\nImplements RFC 438.\n\nFixes #19092.\n\nThis is a [breaking-change]: change types like `&Foo+Send` or `&'a mut Foo+'a` to `&(Foo+Send)` and `&'a mut (Foo+'a)`, respectively.\n\nr? @brson", "tree": {"sha": "ad6c9a0c61140ae68169fca89e8641af83c92e33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad6c9a0c61140ae68169fca89e8641af83c92e33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4a775639ca846f29abeed16a7b4e8e1c8819626", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4a775639ca846f29abeed16a7b4e8e1c8819626", "html_url": "https://github.com/rust-lang/rust/commit/f4a775639ca846f29abeed16a7b4e8e1c8819626", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4a775639ca846f29abeed16a7b4e8e1c8819626/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "702127f6f1b099f8a34804ddb71f821444b7b64e", "url": "https://api.github.com/repos/rust-lang/rust/commits/702127f6f1b099f8a34804ddb71f821444b7b64e", "html_url": "https://github.com/rust-lang/rust/commit/702127f6f1b099f8a34804ddb71f821444b7b64e"}, {"sha": "21d5d139fc6e04781b7f9d9eeab0f8f0255ac06b", "url": "https://api.github.com/repos/rust-lang/rust/commits/21d5d139fc6e04781b7f9d9eeab0f8f0255ac06b", "html_url": "https://github.com/rust-lang/rust/commit/21d5d139fc6e04781b7f9d9eeab0f8f0255ac06b"}], "stats": {"total": 850, "additions": 478, "deletions": 372}, "files": [{"sha": "1d6906c13a8fa028e036c63f9fc83ae9928caaf2", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -85,7 +85,7 @@ pub struct Formatter<'a> {\n     width: Option<uint>,\n     precision: Option<uint>,\n \n-    buf: &'a mut FormatWriter+'a,\n+    buf: &'a mut (FormatWriter+'a),\n     curarg: slice::Items<'a, Argument<'a>>,\n     args: &'a [Argument<'a>],\n }\n@@ -565,7 +565,7 @@ impl<'a, Sized? T: Show> Show for &'a T {\n impl<'a, Sized? T: Show> Show for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n-impl<'a> Show for &'a Show+'a {\n+impl<'a> Show for &'a (Show+'a) {\n     fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n }\n \n@@ -724,7 +724,7 @@ macro_rules! tuple (\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl<'a> Show for &'a any::Any+'a {\n+impl<'a> Show for &'a (any::Any+'a) {\n     fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n }\n "}, {"sha": "1873213fadf1da05fdbb28fe3038e17d60463280", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -146,5 +146,6 @@ register_diagnostics!(\n     E0167,\n     E0168,\n     E0169,\n-    E0170\n+    E0170,\n+    E0171\n )"}, {"sha": "1dbd170a0d997f9242bf02bf7b8131b127fad100", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -421,7 +421,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n         match ty.node {\n-            ast::TyPath(_, _, id) => self.check_def(ty.span, ty.id, id),\n+            ast::TyPath(_, id) => self.check_def(ty.span, ty.id, id),\n             _ => (),\n         }\n         visit::walk_ty(self, ty);"}, {"sha": "8c21e559ec1f80a1418bdc5d15a15c6e2ce0fccb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -1230,10 +1230,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, item.attrs.as_slice());\n         match ty.node {\n-            ast::TyPath(ref path, ref bounds, _) if path.segments\n+            ast::TyPath(ref path, _) if path.segments\n                                                         .len() == 1 => {\n                 let ident = path.segments.last().unwrap().identifier;\n-                assert!(bounds.is_none());\n                 encode_impl_type_basename(rbml_w, ident);\n             }\n             _ => {}"}, {"sha": "5ab3978b8a8f7e07e58c15680112f12523b87e68", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -295,7 +295,7 @@ impl OverloadedCallType {\n pub struct ExprUseVisitor<'d,'t,'tcx,TYPER:'t> {\n     typer: &'t TYPER,\n     mc: mc::MemCategorizationContext<'t,TYPER>,\n-    delegate: &'d mut Delegate<'tcx>+'d,\n+    delegate: &'d mut (Delegate<'tcx>+'d),\n }\n \n // If the TYPER results in an error, it's because the type check"}, {"sha": "ec939d19b72409a96faf3a4435de89f90105a8db", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -243,7 +243,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // * Private trait impls for private types can be completely ignored\n             ast::ItemImpl(_, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n-                    ast::TyPath(_, _, id) => {\n+                    ast::TyPath(_, id) => {\n                         match self.tcx.def_map.borrow()[id].clone() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n@@ -311,7 +311,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n             ast::ItemTy(ref ty, _) if public_first => {\n                 match ty.node {\n-                    ast::TyPath(_, _, id) => {\n+                    ast::TyPath(_, id) => {\n                         match self.tcx.def_map.borrow()[id].clone() {\n                             def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                             def => {\n@@ -616,7 +616,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                     // was private.\n                     ast::ItemImpl(_, _, ref ty, _) => {\n                         let id = match ty.node {\n-                            ast::TyPath(_, _, id) => id,\n+                            ast::TyPath(_, id) => id,\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n                         let def = self.tcx.def_map.borrow()[id].clone();\n@@ -1292,7 +1292,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n         match ty.node {\n-            ast::TyPath(_, _, path_id) => {\n+            ast::TyPath(_, path_id) => {\n                 if self.inner.path_is_private_type(path_id) {\n                     self.contains_private = true;\n                     // found what we're looking for so let's stop\n@@ -1493,7 +1493,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n-            ast::TyPath(ref p, _, path_id) => {\n+            ast::TyPath(ref p, path_id) => {\n                 if !self.tcx.sess.features.borrow().visible_private_types &&\n                         self.path_is_private_type(path_id) {\n                     self.tcx.sess.span_err(p.span,"}, {"sha": "ae32a10f3140b0d5c180b40a479df3e40df7299a", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 64, "deletions": 46, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -63,7 +63,7 @@ use syntax::ast::{PolyTraitRef, PrimTy, Public, SelfExplicit, SelfStatic};\n use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n use syntax::ast::{StructVariantKind, TraitRef, TraitTyParamBound};\n use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n-use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt};\n+use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt, TyObjectSum};\n use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyPolyTraitRef, TyProc, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem, UnnamedField};\n@@ -1392,29 +1392,53 @@ impl<'a> Resolver<'a> {\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n \n-                // Create the module and add all methods.\n-                match ty.node {\n-                    TyPath(ref path, _, _) if path.segments.len() == 1 => {\n+                let mod_name = match ty.node {\n+                    TyPath(ref path, _) if path.segments.len() == 1 => {\n                         // FIXME(18446) we should distinguish between the name of\n                         // a trait and the name of an impl of that trait.\n-                        let mod_name = path.segments.last().unwrap().identifier.name;\n+                        Some(path.segments.last().unwrap().identifier.name)\n+                    }\n+                    TyObjectSum(ref lhs_ty, _) => {\n+                        match lhs_ty.node {\n+                            TyPath(ref path, _) if path.segments.len() == 1 => {\n+                                Some(path.segments.last().unwrap().identifier.name)\n+                            }\n+                            _ => {\n+                                None\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        None\n+                    }\n+                };\n \n+                match mod_name {\n+                    None => {\n+                        self.resolve_error(ty.span,\n+                                           \"inherent implementations may \\\n+                                            only be implemented in the same \\\n+                                            module as the type they are \\\n+                                            implemented for\")\n+                    }\n+                    Some(mod_name) => {\n+                        // Create the module and add all methods.\n                         let parent_opt = parent.module().children.borrow()\n-                                               .get(&mod_name).cloned();\n+                            .get(&mod_name).cloned();\n                         let new_parent = match parent_opt {\n                             // It already exists\n                             Some(ref child) if child.get_module_if_available()\n-                                                .is_some() &&\n-                                           (child.get_module().kind.get() == ImplModuleKind ||\n-                                            child.get_module().kind.get() == TraitModuleKind) => {\n-                                ModuleReducedGraphParent(child.get_module())\n-                            }\n+                                .is_some() &&\n+                                (child.get_module().kind.get() == ImplModuleKind ||\n+                                 child.get_module().kind.get() == TraitModuleKind) => {\n+                                    ModuleReducedGraphParent(child.get_module())\n+                                }\n                             Some(ref child) if child.get_module_if_available()\n-                                                .is_some() &&\n-                                           child.get_module().kind.get() ==\n-                                                EnumModuleKind => {\n-                                ModuleReducedGraphParent(child.get_module())\n-                            }\n+                                .is_some() &&\n+                                child.get_module().kind.get() ==\n+                                EnumModuleKind => {\n+                                    ModuleReducedGraphParent(child.get_module())\n+                                }\n                             // Create the module\n                             _ => {\n                                 let name_bindings =\n@@ -1429,7 +1453,7 @@ impl<'a> Resolver<'a> {\n                                 let ns = TypeNS;\n                                 let is_public =\n                                     !name_bindings.defined_in_namespace(ns) ||\n-                                     name_bindings.defined_in_public_namespace(ns);\n+                                    name_bindings.defined_in_public_namespace(ns);\n \n                                 name_bindings.define_module(parent_link,\n                                                             Some(def_id),\n@@ -1455,21 +1479,21 @@ impl<'a> Resolver<'a> {\n                                                        ForbidDuplicateValues,\n                                                        method.span);\n                                     let def = match method.pe_explicit_self()\n-                                                          .node {\n-                                        SelfStatic => {\n-                                            // Static methods become\n-                                            // `DefStaticMethod`s.\n-                                            DefStaticMethod(local_def(method.id),\n-                                                            FromImpl(local_def(item.id)))\n-                                        }\n-                                        _ => {\n-                                            // Non-static methods become\n-                                            // `DefMethod`s.\n-                                            DefMethod(local_def(method.id),\n-                                                      None,\n-                                                      FromImpl(local_def(item.id)))\n-                                        }\n-                                    };\n+                                        .node {\n+                                            SelfStatic => {\n+                                                // Static methods become\n+                                                // `DefStaticMethod`s.\n+                                                DefStaticMethod(local_def(method.id),\n+                                                                FromImpl(local_def(item.id)))\n+                                            }\n+                                            _ => {\n+                                                // Non-static methods become\n+                                                // `DefMethod`s.\n+                                                DefMethod(local_def(method.id),\n+                                                          None,\n+                                                          FromImpl(local_def(item.id)))\n+                                            }\n+                                        };\n \n                                     // NB: not IMPORTABLE\n                                     let modifiers = if method.pe_vis() == ast::Public {\n@@ -1492,7 +1516,7 @@ impl<'a> Resolver<'a> {\n                                             ForbidDuplicateTypesAndModules,\n                                             typedef.span);\n                                     let def = DefAssociatedTy(local_def(\n-                                            typedef.id));\n+                                        typedef.id));\n                                     // NB: not IMPORTABLE\n                                     let modifiers = if typedef.vis == ast::Public {\n                                         PUBLIC\n@@ -1507,13 +1531,6 @@ impl<'a> Resolver<'a> {\n                             }\n                         }\n                     }\n-                    _ => {\n-                        self.resolve_error(ty.span,\n-                                           \"inherent implementations may \\\n-                                            only be implemented in the same \\\n-                                            module as the type they are \\\n-                                            implemented for\")\n-                    }\n                 }\n \n                 parent\n@@ -4721,7 +4738,7 @@ impl<'a> Resolver<'a> {\n                 // type, the result will be that the type name resolves to a module but not\n                 // a type (shadowing any imported modules or types with this name), leading\n                 // to weird user-visible bugs. So we ward this off here. See #15060.\n-                TyPath(ref path, _, path_id) => {\n+                TyPath(ref path, path_id) => {\n                     match self.def_map.borrow().get(&path_id) {\n                         // FIXME: should we catch other options and give more precise errors?\n                         Some(&DefMod(_)) => {\n@@ -4887,7 +4904,7 @@ impl<'a> Resolver<'a> {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n \n-            TyPath(ref path, ref bounds, path_id) => {\n+            TyPath(ref path, path_id) => {\n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n                 let mut result_def = None;\n@@ -4957,11 +4974,12 @@ impl<'a> Resolver<'a> {\n                         self.resolve_error(ty.span, msg.as_slice());\n                     }\n                 }\n+            }\n \n-                bounds.as_ref().map(|bound_vec| {\n-                    self.resolve_type_parameter_bounds(ty.id, bound_vec,\n+            TyObjectSum(ref ty, ref bound_vec) => {\n+                self.resolve_type(&**ty);\n+                self.resolve_type_parameter_bounds(ty.id, bound_vec,\n                                                        TraitBoundingTypeParameter);\n-                });\n             }\n \n             TyQPath(ref qpath) => {\n@@ -5598,7 +5616,7 @@ impl<'a> Resolver<'a> {\n         fn extract_path_and_node_id(t: &Ty, allow: FallbackChecks)\n                                                     -> Option<(Path, NodeId, FallbackChecks)> {\n             match t.node {\n-                TyPath(ref path, _, node_id) => Some((path.clone(), node_id, allow)),\n+                TyPath(ref path, node_id) => Some((path.clone(), node_id, allow)),\n                 TyPtr(ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n                 TyRptr(_, ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n                 // This doesn't handle the remaining `Ty` variants as they are not"}, {"sha": "02e353d6b1fddbc14209f746334f6d6aae12c596", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -162,21 +162,14 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     visit::walk_ty(this, ty);\n                 });\n             }\n-            ast::TyPath(ref path, ref opt_bounds, id) => {\n+            ast::TyPath(ref path, id) => {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.borrow().get(&id) {\n                     Some(&def::DefTrait(..)) => {\n                         self.with(LateScope(&Vec::new(), self.scope), |this| {\n                             this.visit_path(path, id);\n                         });\n-\n-                        match *opt_bounds {\n-                            Some(ref bounds) => {\n-                                visit::walk_ty_param_bounds_helper(self, bounds);\n-                            }\n-                            None => { }\n-                        }\n                     }\n                     _ => {\n                         visit::walk_ty(self, ty);"}, {"sha": "436ab919ddb100160a44957870200d9cba5a0404", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -43,7 +43,7 @@ use util::ppaux::Repr;\n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     param_env: &'cx ty::ParameterEnvironment<'tcx>,\n-    typer: &'cx Typer<'tcx>+'cx,\n+    typer: &'cx (Typer<'tcx>+'cx),\n \n     /// Skolemizer used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack"}, {"sha": "8f1e2d115d3f139f831d71c920262afc7996dc0e", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 98, "deletions": 77, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -59,8 +59,9 @@ use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope,\n                              ShiftedRscope, BindingRscope};\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n+use util::common::ErrorReported;\n use util::nodemap::DefIdMap;\n-use util::ppaux::{Repr, UserString};\n+use util::ppaux::{mod, Repr, UserString};\n \n use std::rc::Rc;\n use std::iter::AdditiveIterator;\n@@ -585,7 +586,7 @@ fn check_path_args(tcx: &ty::ctxt,\n pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                                -> Option<Ty<'tcx>> {\n     match ast_ty.node {\n-        ast::TyPath(ref path, _, id) => {\n+        ast::TyPath(ref path, id) => {\n             let a_def = match tcx.def_map.borrow().get(&id) {\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n@@ -642,7 +643,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n \n     match ast_ty.node {\n-        ast::TyPath(ref path, _, id) => {\n+        ast::TyPath(ref path, id) => {\n             let a_def = match this.tcx().def_map.borrow().get(&id) {\n                 None => {\n                     this.tcx()\n@@ -682,64 +683,92 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n }\n \n-// Handle `~`, `Box`, and `&` being able to mean strs and vecs.\n-// If a_seq_ty is a str or a vec, make it a str/vec.\n-// Also handle first-class trait types.\n-fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC,\n-        rscope: &RS,\n-        a_seq_mutbl: ast::Mutability,\n-        a_seq_ty: &ast::Ty,\n-        region: ty::Region,\n-        constr: |Ty<'tcx>| -> Ty<'tcx>)\n-        -> Ty<'tcx>\n+fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n+                                   rscope: &RS,\n+                                   ty: &ast::Ty,\n+                                   bounds: &[ast::TyParamBound])\n+                                   -> Result<ty::TraitRef<'tcx>, ErrorReported>\n+    where AC : AstConv<'tcx>, RS : RegionScope\n {\n-    let tcx = this.tcx();\n-\n-    debug!(\"mk_pointer(region={}, a_seq_ty={})\",\n-           region,\n-           a_seq_ty.repr(tcx));\n+    /*!\n+     * In a type like `Foo + Send`, we want to wait to collect the\n+     * full set of bounds before we make the object type, because we\n+     * need them to infer a region bound.  (For example, if we tried\n+     * made a type from just `Foo`, then it wouldn't be enough to\n+     * infer a 'static bound, and hence the user would get an error.)\n+     * So this function is used when we're dealing with a sum type to\n+     * convert the LHS. It only accepts a type that refers to a trait\n+     * name, and reports an error otherwise.\n+     */\n \n-    match a_seq_ty.node {\n-        ast::TyVec(ref ty) => {\n-            let ty = ast_ty_to_ty(this, rscope, &**ty);\n-            return constr(ty::mk_vec(tcx, ty, None));\n+    match ty.node {\n+        ast::TyPath(ref path, id) => {\n+            match this.tcx().def_map.borrow().get(&id) {\n+                Some(&def::DefTrait(trait_def_id)) => {\n+                    return Ok(ast_path_to_trait_ref(this,\n+                                                    rscope,\n+                                                    trait_def_id,\n+                                                    None,\n+                                                    path));\n+                }\n+                _ => {\n+                    span_err!(this.tcx().sess, ty.span, E0170, \"expected a reference to a trait\");\n+                    Err(ErrorReported)\n+                }\n+            }\n         }\n-        ast::TyPath(ref path, ref opt_bounds, id) => {\n-            // Note that the \"bounds must be empty if path is not a trait\"\n-            // restriction is enforced in the below case for ty_path, which\n-            // will run after this as long as the path isn't a trait.\n-            match tcx.def_map.borrow().get(&id) {\n-                Some(&def::DefPrimTy(ast::TyStr)) => {\n-                    check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                    return ty::mk_str_slice(tcx, region, a_seq_mutbl);\n+        _ => {\n+            span_err!(this.tcx().sess, ty.span, E0171,\n+                      \"expected a path on the left-hand side of `+`, not `{}`\",\n+                      pprust::ty_to_string(ty));\n+            match ty.node {\n+                ast::TyRptr(None, ref mut_ty) => {\n+                    span_note!(this.tcx().sess, ty.span,\n+                               \"perhaps you meant `&{}({} +{})`? (per RFC 248)\",\n+                               ppaux::mutability_to_string(mut_ty.mutbl),\n+                               pprust::ty_to_string(&*mut_ty.ty),\n+                               pprust::bounds_to_string(bounds));\n                 }\n-                Some(&def::DefTrait(trait_def_id)) => {\n-                    let result = ast_path_to_trait_ref(this,\n-                                                       rscope,\n-                                                       trait_def_id,\n-                                                       None,\n-                                                       path);\n-                    let empty_vec = [];\n-                    let bounds = match *opt_bounds { None => empty_vec.as_slice(),\n-                                                     Some(ref bounds) => bounds.as_slice() };\n-                    let existential_bounds = conv_existential_bounds(this,\n-                                                                     rscope,\n-                                                                     path.span,\n-                                                                     &[Rc::new(result.clone())],\n-                                                                     bounds);\n-                    let tr = ty::mk_trait(tcx,\n-                                          result,\n-                                          existential_bounds);\n-                    return ty::mk_rptr(tcx, region, ty::mt{mutbl: a_seq_mutbl, ty: tr});\n+\n+                ast::TyRptr(Some(ref lt), ref mut_ty) => {\n+                    span_note!(this.tcx().sess, ty.span,\n+                               \"perhaps you meant `&{} {}({} +{})`? (per RFC 248)\",\n+                               pprust::lifetime_to_string(lt),\n+                               ppaux::mutability_to_string(mut_ty.mutbl),\n+                               pprust::ty_to_string(&*mut_ty.ty),\n+                               pprust::bounds_to_string(bounds));\n+                }\n+\n+                _ => {\n+                    span_note!(this.tcx().sess, ty.span,\n+                               \"perhaps you forget parentheses? (per RFC 248)\");\n                 }\n-                _ => {}\n             }\n+            Err(ErrorReported)\n         }\n-        _ => {}\n     }\n \n-    constr(ast_ty_to_ty(this, rscope, a_seq_ty))\n+}\n+\n+fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n+                                        rscope: &RS,\n+                                        span: Span,\n+                                        trait_ref: ty::TraitRef<'tcx>,\n+                                        bounds: &[ast::TyParamBound])\n+                                        -> Ty<'tcx>\n+    where AC : AstConv<'tcx>, RS : RegionScope\n+{\n+    let existential_bounds = conv_existential_bounds(this,\n+                                                     rscope,\n+                                                     span,\n+                                                     &[Rc::new(trait_ref.clone())],\n+                                                     bounds);\n+\n+    let result = ty::mk_trait(this.tcx(), trait_ref, existential_bounds);\n+    debug!(\"trait_ref_to_object_type: result={}\",\n+           result.repr(this.tcx()));\n+\n+    result\n }\n \n fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n@@ -806,6 +835,17 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyVec(ref ty) => {\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n+            ast::TyObjectSum(ref ty, ref bounds) => {\n+                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds.as_slice()) {\n+                    Ok(trait_ref) => {\n+                        trait_ref_to_object_type(this, rscope, ast_ty.span,\n+                                                 trait_ref, bounds.as_slice())\n+                    }\n+                    Err(ErrorReported) => {\n+                        ty::mk_err()\n+                    }\n+                }\n+            }\n             ast::TyPtr(ref mt) => {\n                 ty::mk_ptr(tcx, ty::mt {\n                     ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n@@ -815,8 +855,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, mt.mutbl, &*mt.ty, r,\n-                           |ty| ty::mk_rptr(tcx, r, ty::mt {ty: ty, mutbl: mt.mutbl}))\n+                let t = ast_ty_to_ty(this, rscope, &*mt.ty);\n+                ty::mk_rptr(tcx, r, ty::mt {ty: t, mutbl: mt.mutbl})\n             }\n             ast::TyTup(ref fields) => {\n                 let flds = fields.iter()\n@@ -874,7 +914,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyPolyTraitRef(ref bounds) => {\n                 conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds.as_slice())\n             }\n-            ast::TyPath(ref path, ref bounds, id) => {\n+            ast::TyPath(ref path, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n                         tcx.sess\n@@ -884,35 +924,16 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     }\n                     Some(&d) => d\n                 };\n-                // Kind bounds on path types are only supported for traits.\n-                match a_def {\n-                    // But don't emit the error if the user meant to do a trait anyway.\n-                    def::DefTrait(..) => { },\n-                    _ if bounds.is_some() =>\n-                        tcx.sess.span_err(ast_ty.span,\n-                                          \"kind bounds can only be used on trait types\"),\n-                    _ => { },\n-                }\n                 match a_def {\n                     def::DefTrait(trait_def_id) => {\n+                        // N.B. this case overlaps somewhat with\n+                        // TyObjectSum, see that fn for details\n                         let result = ast_path_to_trait_ref(this,\n                                                            rscope,\n                                                            trait_def_id,\n                                                            None,\n                                                            path);\n-                        let empty_bounds: &[ast::TyParamBound] = &[];\n-                        let ast_bounds = match *bounds {\n-                            Some(ref b) => b.as_slice(),\n-                            None => empty_bounds\n-                        };\n-                        let bounds = conv_existential_bounds(this,\n-                                                             rscope,\n-                                                             ast_ty.span,\n-                                                             &[Rc::new(result.clone())],\n-                                                             ast_bounds);\n-                        let result_ty = ty::mk_trait(tcx, result, bounds);\n-                        debug!(\"ast_ty_to_ty: result_ty={}\", result_ty.repr(this.tcx()));\n-                        result_ty\n+                        trait_ref_to_object_type(this, rscope, path.span, result, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty"}, {"sha": "a78977d9fc7f6084c2077c706ee4ce4b54ac06ca", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -1249,7 +1249,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                     ty_queue.push(&*mut_ty.ty);\n                 }\n-                ast::TyPath(ref path, ref bounds, id) => {\n+                ast::TyPath(ref path, id) => {\n                     let a_def = match self.tcx.def_map.borrow().get(&id) {\n                         None => {\n                             self.tcx\n@@ -1296,7 +1296,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             let new_path = self.rebuild_path(rebuild_info, lifetime);\n                             let to = ast::Ty {\n                                 id: cur_ty.id,\n-                                node: ast::TyPath(new_path, bounds.clone(), id),\n+                                node: ast::TyPath(new_path, id),\n                                 span: cur_ty.span\n                             };\n                             new_ty = self.rebuild_ty(new_ty, P(to));"}, {"sha": "3bca24f479f704d487eae5cab9944d8dd2bd609e", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -139,11 +139,11 @@ impl RegionScope for BindingRscope {\n /// A scope which simply shifts the Debruijn index of other scopes\n /// to account for binding levels.\n pub struct ShiftedRscope<'r> {\n-    base_scope: &'r RegionScope+'r\n+    base_scope: &'r (RegionScope+'r)\n }\n \n impl<'r> ShiftedRscope<'r> {\n-    pub fn new(base_scope: &'r RegionScope+'r) -> ShiftedRscope<'r> {\n+    pub fn new(base_scope: &'r (RegionScope+'r)) -> ShiftedRscope<'r> {\n         ShiftedRscope { base_scope: base_scope }\n     }\n }"}, {"sha": "f5c732d9adcf1e4e4b7db27de4a76c99af6abb0a", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -651,7 +651,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     typ: &ast::Ty,\n                     impl_items: &Vec<ast::ImplItem>) {\n         match typ.node {\n-            ast::TyPath(ref path, _, id) => {\n+            ast::TyPath(ref path, id) => {\n                 match self.lookup_type_ref(id) {\n                     Some(id) => {\n                         let sub_span = self.span.sub_span_for_type_name(path.span);\n@@ -1256,7 +1256,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match t.node {\n-            ast::TyPath(ref path, _, id) => {\n+            ast::TyPath(ref path, id) => {\n                 match self.lookup_type_ref(id) {\n                     Some(id) => {\n                         let sub_span = self.span.sub_span_for_type_name(t.span);"}, {"sha": "8270c8f3a20924c13d072a98c831368cc54b9a6e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -992,7 +992,7 @@ impl Clean<Item> for doctree::Trait {\n \n impl Clean<Type> for ast::TraitRef {\n     fn clean(&self, cx: &DocContext) -> Type {\n-        resolve_type(cx, self.path.clean(cx), None, self.ref_id)\n+        resolve_type(cx, self.path.clean(cx), self.ref_id)\n     }\n }\n \n@@ -1278,8 +1278,19 @@ impl Clean<Type> for ast::Ty {\n             TyFixedLengthVec(ref ty, ref e) => FixedVector(box ty.clean(cx),\n                                                            e.span.to_src(cx)),\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n-            TyPath(ref p, ref tpbs, id) => {\n-                resolve_type(cx, p.clean(cx), tpbs.clean(cx), id)\n+            TyPath(ref p, id) => {\n+                resolve_type(cx, p.clean(cx), id)\n+            }\n+            TyObjectSum(ref lhs, ref bounds) => {\n+                let lhs_ty = lhs.clean(cx);\n+                match lhs_ty {\n+                    ResolvedPath { path, typarams: None, did } => {\n+                        ResolvedPath { path: path, typarams: Some(bounds.clean(cx)), did: did}\n+                    }\n+                    _ => {\n+                        lhs_ty // shouldn't happen\n+                    }\n+                }\n             }\n             TyClosure(ref c) => Closure(box c.clean(cx)),\n             TyProc(ref c) => Proc(box c.clean(cx)),\n@@ -2130,8 +2141,8 @@ fn name_from_pat(p: &ast::Pat) -> String {\n }\n \n /// Given a Type, resolve it using the def_map\n-fn resolve_type(cx: &DocContext, path: Path,\n-                tpbs: Option<Vec<TyParamBound>>,\n+fn resolve_type(cx: &DocContext,\n+                path: Path,\n                 id: ast::NodeId) -> Type {\n     let tcx = match cx.tcx_opt() {\n         Some(tcx) => tcx,\n@@ -2168,7 +2179,7 @@ fn resolve_type(cx: &DocContext, path: Path,\n         _ => {}\n     };\n     let did = register_def(&*cx, def);\n-    ResolvedPath { path: path, typarams: tpbs, did: did }\n+    ResolvedPath { path: path, typarams: None, did: did }\n }\n \n fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {"}, {"sha": "697ee95df4c0f0f757820f4287093eecd2bd3a8b", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -86,7 +86,7 @@ struct Exception {\n     cause: Option<Box<Any + Send>>,\n }\n \n-pub type Callback = fn(msg: &Any + Send, file: &'static str, line: uint);\n+pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n \n // Variables used for invoking callbacks when a task starts to unwind.\n //"}, {"sha": "15c554be5d9367a88537b13ed8dc2277888ef090", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -397,7 +397,7 @@ fn fmt_number_or_null(v: f64) -> string::String {\n \n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n-    writer: &'a mut io::Writer+'a,\n+    writer: &'a mut (io::Writer+'a),\n }\n \n impl<'a> Encoder<'a> {\n@@ -601,7 +601,7 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n pub struct PrettyEncoder<'a> {\n-    writer: &'a mut io::Writer+'a,\n+    writer: &'a mut (io::Writer+'a),\n     curr_indent: uint,\n     indent: uint,\n }"}, {"sha": "3191519815ae46ed6801162eb76260dfb96cfbde", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -84,7 +84,7 @@ pub struct Handle<'rx, T:'rx> {\n     next: *mut Handle<'static, ()>,\n     prev: *mut Handle<'static, ()>,\n     added: bool,\n-    packet: &'rx Packet+'rx,\n+    packet: &'rx (Packet+'rx),\n \n     // due to our fun transmutes, we be sure to place this at the end. (nothing\n     // previous relies on T)"}, {"sha": "d839c1484e56216492131f57df96eb384dfb9876", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -40,7 +40,7 @@ impl Writer for Stdio {\n     }\n }\n \n-pub fn on_fail(obj: &Any + Send, file: &'static str, line: uint) {\n+pub fn on_fail(obj: &(Any+Send), file: &'static str, line: uint) {\n     let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n         None => match obj.downcast_ref::<String>() {"}, {"sha": "3b272c3fe5d4e7a146143416272b1c9feb62db38", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -910,7 +910,7 @@ impl<'a> Reader for Box<Reader+'a> {\n     }\n }\n \n-impl<'a> Reader for &'a mut Reader+'a {\n+impl<'a> Reader for &'a mut (Reader+'a) {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { (*self).read(buf) }\n }\n \n@@ -1278,7 +1278,7 @@ impl<'a> Writer for Box<Writer+'a> {\n     }\n }\n \n-impl<'a> Writer for &'a mut Writer+'a {\n+impl<'a> Writer for &'a mut (Writer+'a) {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { (**self).write(buf) }\n "}, {"sha": "d375ddcc94b66a7e695cf05e116042414feb6204", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -288,7 +288,7 @@ mod imp {\n \n         struct Context<'a> {\n             idx: int,\n-            writer: &'a mut Writer+'a,\n+            writer: &'a mut (Writer+'a),\n             last_error: Option<IoError>,\n         }\n "}, {"sha": "14f164ff23b825143ceb9cedb2aa057be4b389d7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -1151,7 +1151,9 @@ pub enum Ty_ {\n     /// A path (`module::module::...::Type`) or primitive\n     ///\n     /// Type parameters are stored in the Path itself\n-    TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n+    TyPath(Path, NodeId),\n+    /// Something like `A+B`. Note that `B` must always be a path.\n+    TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`\n     TyPolyTraitRef(TyParamBounds),\n     /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`"}, {"sha": "4d6ac4f343096aba6ea849900067c95f5055fa34", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -454,7 +454,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n     fn visit_ty(&mut self, typ: &Ty) {\n         self.operation.visit_id(typ.id);\n         match typ.node {\n-            TyPath(_, _, id) => self.operation.visit_id(id),\n+            TyPath(_, id) => self.operation.visit_id(id),\n             _ => {}\n         }\n         visit::walk_ty(self, typ)"}, {"sha": "bd01e5e643020315703951e5a97f888badfeffea", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -44,7 +44,8 @@ pub trait AstBuilder {\n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n \n     fn ty(&self, span: Span, ty: ast::Ty_) -> P<ast::Ty>;\n-    fn ty_path(&self, ast::Path, Option<OwnedSlice<ast::TyParamBound>>) -> P<ast::Ty>;\n+    fn ty_path(&self, ast::Path) -> P<ast::Ty>;\n+    fn ty_sum(&self, ast::Path, OwnedSlice<ast::TyParamBound>) -> P<ast::Ty>;\n     fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n \n     fn ty_rptr(&self, span: Span,\n@@ -344,17 +345,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn ty_path(&self, path: ast::Path, bounds: Option<OwnedSlice<ast::TyParamBound>>)\n-              -> P<ast::Ty> {\n+    fn ty_path(&self, path: ast::Path) -> P<ast::Ty> {\n+        self.ty(path.span, ast::TyPath(path, ast::DUMMY_NODE_ID))\n+    }\n+\n+    fn ty_sum(&self, path: ast::Path, bounds: OwnedSlice<ast::TyParamBound>) -> P<ast::Ty> {\n         self.ty(path.span,\n-                ast::TyPath(path, bounds, ast::DUMMY_NODE_ID))\n+                ast::TyObjectSum(self.ty_path(path),\n+                                 bounds))\n     }\n \n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n     fn ty_ident(&self, span: Span, ident: ast::Ident)\n         -> P<ast::Ty> {\n-        self.ty_path(self.path_ident(span, ident), None)\n+        self.ty_path(self.path_ident(span, ident))\n     }\n \n     fn ty_rptr(&self,\n@@ -386,7 +391,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               self.ident_of(\"Option\")\n                           ),\n                           Vec::new(),\n-                          vec!( ty )), None)\n+                          vec!( ty )))\n     }\n \n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField {\n@@ -425,8 +430,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> {\n-        ty_params.iter().map(|p| self.ty_path(\n-                self.path_global(DUMMY_SP, vec!(p.ident)), None)).collect()\n+        ty_params\n+            .iter()\n+            .map(|p| self.ty_path(self.path_global(DUMMY_SP, vec!(p.ident))))\n+            .collect()\n     }\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef {"}, {"sha": "d5f472bd827101db62d38149a374b17ff1b7ef87", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -444,7 +444,7 @@ impl<'a> TraitDef<'a> {\n         // Create the type of `self`.\n         let self_type = cx.ty_path(\n             cx.path_all(self.span, false, vec!( type_ident ), self_lifetimes,\n-                        self_ty_params.into_vec()), None);\n+                        self_ty_params.into_vec()));\n \n         let attr = cx.attribute(\n             self.span,"}, {"sha": "6614ab50f1e45a0d351df20a25c31b49acaf52cd", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -70,7 +70,7 @@ impl<'a> Path<'a> {\n                  self_ty: Ident,\n                  self_generics: &Generics)\n                  -> P<ast::Ty> {\n-        cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n+        cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n     }\n     pub fn to_path(&self,\n                    cx: &ExtCtxt,\n@@ -152,7 +152,7 @@ impl<'a> Ty<'a> {\n             }\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n             Self  => {\n-                cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n+                cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n             }\n             Tuple(ref fields) => {\n                 let ty = ast::TyTup(fields.iter()"}, {"sha": "d7d6c636849a66a27fdae1ebeae2c77b9a266340", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -531,7 +531,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     true, Context::rtpath(self.ecx, \"Argument\"),\n                     vec![static_lifetime],\n                     vec![]\n-                ), None);\n+                ));\n             lets.push(Context::item_static_array(self.ecx,\n                                                  static_args_name,\n                                                  piece_ty,"}, {"sha": "4785fe37293c0bf3a9a365a5f53e8ba6d38fe4d8", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -514,7 +514,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n       \"stmt\" => token::NtStmt(p.parse_stmt(Vec::new())),\n       \"pat\" => token::NtPat(p.parse_pat()),\n       \"expr\" => token::NtExpr(p.parse_expr()),\n-      \"ty\" => token::NtTy(p.parse_ty(false /* no need to disambiguate*/)),\n+      \"ty\" => token::NtTy(p.parse_ty()),\n       // this could be handled like a token, since it is one\n       \"ident\" => match p.token {\n         token::Ident(sn,b) => { p.bump(); token::NtIdent(box sn,b) }\n@@ -525,7 +525,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         }\n       },\n       \"path\" => {\n-        token::NtPath(box p.parse_path(LifetimeAndTypesWithoutColons).path)\n+        token::NtPath(box p.parse_path(LifetimeAndTypesWithoutColons))\n       }\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       \"tt\" => {"}, {"sha": "122f99cabb3f6a1c67f5afa41ff8c6268babd635", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -433,11 +433,13 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             }\n             TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyParen(ty) => TyParen(fld.fold_ty(ty)),\n-            TyPath(path, bounds, id) => {\n+            TyPath(path, id) => {\n                 let id = fld.new_id(id);\n-                TyPath(fld.fold_path(path),\n-                        fld.fold_opt_bounds(bounds),\n-                        id)\n+                TyPath(fld.fold_path(path), id)\n+            }\n+            TyObjectSum(ty, bounds) => {\n+                TyObjectSum(fld.fold_ty(ty),\n+                            fld.fold_bounds(bounds))\n             }\n             TyQPath(qpath) => {\n                 TyQPath(fld.fold_qpath(qpath))"}, {"sha": "b46f7cdfe22ad1b43e3d9d6633781eca3db6cf4a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -1029,7 +1029,7 @@ mod test {\n                                                 parameters: ast::PathParameters::none(),\n                                             }\n                                         ),\n-                                        }, None, ast::DUMMY_NODE_ID),\n+                                        }, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n                                     }),\n                                     pat: P(ast::Pat {"}, {"sha": "35187ebb5221065a5e0482ae59ae0f8b599cdb4f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 85, "deletions": 107, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -111,16 +111,6 @@ pub enum PathParsingMode {\n     /// A path with a lifetime and type parameters with double colons before\n     /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n     LifetimeAndTypesWithColons,\n-    /// A path with a lifetime and type parameters with bounds before the last\n-    /// set of type parameters only; e.g. `foo::bar<'a>::Baz+X+Y<T>` This\n-    /// form does not use extra double colons.\n-    LifetimeAndTypesAndBounds,\n-}\n-\n-/// A path paired with optional type bounds.\n-pub struct PathAndBounds {\n-    pub path: ast::Path,\n-    pub bounds: Option<ast::TyParamBounds>,\n }\n \n enum ItemOrViewItem {\n@@ -1053,17 +1043,9 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_ty_path(&mut self, plus_allowed: bool) -> Ty_ {\n-        let mode = if plus_allowed {\n-            LifetimeAndTypesAndBounds\n-        } else {\n-            LifetimeAndTypesWithoutColons\n-        };\n-        let PathAndBounds {\n-            path,\n-            bounds\n-        } = self.parse_path(mode);\n-        TyPath(path, bounds, ast::DUMMY_NODE_ID)\n+    pub fn parse_ty_path(&mut self) -> Ty_ {\n+        let path = self.parse_path(LifetimeAndTypesWithoutColons);\n+        TyPath(path, ast::DUMMY_NODE_ID)\n     }\n \n     /// parse a TyBareFn type:\n@@ -1286,7 +1268,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         self.expect(&token::Eq);\n-        let typ = self.parse_ty(true);\n+        let typ = self.parse_ty_sum();\n         let hi = self.span.hi;\n         self.expect(&token::Semi);\n         Typedef {\n@@ -1385,7 +1367,7 @@ impl<'a> Parser<'a> {\n     /// Parse a possibly mutable type\n     pub fn parse_mt(&mut self) -> MutTy {\n         let mutbl = self.parse_mutability();\n-        let t = self.parse_ty(true);\n+        let t = self.parse_ty();\n         MutTy { ty: t, mutbl: mutbl }\n     }\n \n@@ -1396,7 +1378,7 @@ impl<'a> Parser<'a> {\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n         self.expect(&token::Colon);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         let hi = ty.span.hi;\n         ast::TypeField {\n             ident: id,\n@@ -1411,7 +1393,19 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::Not) {\n                 NoReturn(self.span)\n             } else {\n-                Return(self.parse_ty(true))\n+                let t = self.parse_ty();\n+\n+                // We used to allow `fn foo() -> &T + U`, but don't\n+                // anymore. If we see it, report a useful error.  This\n+                // only makes sense because `parse_ret_ty` is only\n+                // used in fn *declarations*, not fn types or where\n+                // clauses (i.e., not when parsing something like\n+                // `FnMut() -> T + Send`, where the `+` is legal).\n+                if self.token == token::BinOp(token::Plus) {\n+                    self.warn(\"deprecated syntax: `()` are required, see RFC 248 for details\");\n+                }\n+\n+                Return(t)\n             }\n         } else {\n             let pos = self.span.lo;\n@@ -1423,11 +1417,36 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse a type in a context where `T1+T2` is allowed.\n+    pub fn parse_ty_sum(&mut self) -> P<Ty> {\n+        let lo = self.span.lo;\n+        let lhs = self.parse_ty();\n+\n+        if !self.eat(&token::BinOp(token::Plus)) {\n+            return lhs;\n+        }\n+\n+        let bounds = self.parse_ty_param_bounds();\n+\n+        // In type grammar, `+` is treated like a binary operator,\n+        // and hence both L and R side are required.\n+        if bounds.len() == 0 {\n+            let last_span = self.last_span;\n+            self.span_err(last_span,\n+                          \"at least one type parameter bound \\\n+                          must be specified\");\n+        }\n+\n+        let sp = mk_sp(lo, self.last_span.hi);\n+        let sum = ast::TyObjectSum(lhs, bounds);\n+        P(Ty {id: ast::DUMMY_NODE_ID, node: sum, span: sp})\n+    }\n+\n     /// Parse a type.\n     ///\n     /// The second parameter specifies whether the `+` binary operator is\n     /// allowed in the type grammar.\n-    pub fn parse_ty(&mut self, plus_allowed: bool) -> P<Ty> {\n+    pub fn parse_ty(&mut self) -> P<Ty> {\n         maybe_whole!(no_clone self, NtTy);\n \n         let lo = self.span.lo;\n@@ -1441,7 +1460,7 @@ impl<'a> Parser<'a> {\n             let mut ts = vec![];\n             let mut last_comma = false;\n             while self.token != token::CloseDelim(token::Paren) {\n-                ts.push(self.parse_ty(true));\n+                ts.push(self.parse_ty_sum());\n                 if self.token == token::Comma {\n                     last_comma = true;\n                     self.bump();\n@@ -1465,15 +1484,15 @@ impl<'a> Parser<'a> {\n                 token::OpenDelim(token::Bracket) => self.obsolete(last_span, ObsoleteOwnedVector),\n                 _ => self.obsolete(last_span, ObsoleteOwnedType)\n             }\n-            TyTup(vec![self.parse_ty(false)])\n+            TyTup(vec![self.parse_ty()])\n         } else if self.token == token::BinOp(token::Star) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n             TyPtr(self.parse_ptr())\n         } else if self.token == token::OpenDelim(token::Bracket) {\n             // VECTOR\n             self.expect(&token::OpenDelim(token::Bracket));\n-            let t = self.parse_ty(true);\n+            let t = self.parse_ty_sum();\n \n             // Parse the `, ..e` in `[ int, ..e ]`\n             // where `e` is a const expression\n@@ -1514,7 +1533,7 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::Lt {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             self.bump();\n-            let self_type = self.parse_ty(true);\n+            let self_type = self.parse_ty_sum();\n             self.expect_keyword(keywords::As);\n             let trait_ref = self.parse_trait_ref();\n             self.expect(&token::Gt);\n@@ -1529,7 +1548,7 @@ impl<'a> Parser<'a> {\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n             // NAMED TYPE\n-            self.parse_ty_path(plus_allowed)\n+            self.parse_ty_path()\n         } else if self.eat(&token::Underscore) {\n             // TYPE TO BE INFERRED\n             TyInfer\n@@ -1563,7 +1582,7 @@ impl<'a> Parser<'a> {\n                            known as `*const T`\");\n             MutImmutable\n         };\n-        let t = self.parse_ty(true);\n+        let t = self.parse_ty();\n         MutTy { ty: t, mutbl: mutbl }\n     }\n \n@@ -1603,7 +1622,7 @@ impl<'a> Parser<'a> {\n                                    special_idents::invalid)\n         };\n \n-        let t = self.parse_ty(true);\n+        let t = self.parse_ty_sum();\n \n         Arg {\n             ty: t,\n@@ -1621,7 +1640,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_fn_block_arg(&mut self) -> Arg {\n         let pat = self.parse_pat();\n         let t = if self.eat(&token::Colon) {\n-            self.parse_ty(true)\n+            self.parse_ty_sum()\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -1739,18 +1758,15 @@ impl<'a> Parser<'a> {\n     /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n-    pub fn parse_path(&mut self, mode: PathParsingMode) -> PathAndBounds {\n+    pub fn parse_path(&mut self, mode: PathParsingMode) -> ast::Path {\n         // Check for a whole path...\n         let found = match self.token {\n             token::Interpolated(token::NtPath(_)) => Some(self.bump_and_get()),\n             _ => None,\n         };\n         match found {\n             Some(token::Interpolated(token::NtPath(box path))) => {\n-                return PathAndBounds {\n-                    path: path,\n-                    bounds: None\n-                }\n+                return path;\n             }\n             _ => {}\n         }\n@@ -1762,8 +1778,7 @@ impl<'a> Parser<'a> {\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n         let segments = match mode {\n-            LifetimeAndTypesWithoutColons |\n-            LifetimeAndTypesAndBounds => {\n+            LifetimeAndTypesWithoutColons => {\n                 self.parse_path_segments_without_colons()\n             }\n             LifetimeAndTypesWithColons => {\n@@ -1774,44 +1789,14 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        // Next, parse a plus and bounded type parameters, if\n-        // applicable. We need to remember whether the separate was\n-        // present for later, because in some contexts it's a parse\n-        // error.\n-        let opt_bounds = {\n-            if mode == LifetimeAndTypesAndBounds &&\n-                self.eat(&token::BinOp(token::Plus))\n-            {\n-                let bounds = self.parse_ty_param_bounds();\n-\n-                // For some reason that I do not fully understand, we\n-                // do not permit an empty list in the case where it is\n-                // introduced by a `+`, but we do for `:` and other\n-                // separators. -nmatsakis\n-                if bounds.len() == 0 {\n-                    let last_span = self.last_span;\n-                    self.span_err(last_span,\n-                                  \"at least one type parameter bound \\\n-                                   must be specified\");\n-                }\n-\n-                Some(bounds)\n-            } else {\n-                None\n-            }\n-        };\n-\n         // Assemble the span.\n         let span = mk_sp(lo, self.last_span.hi);\n \n         // Assemble the result.\n-        PathAndBounds {\n-            path: ast::Path {\n-                span: span,\n-                global: is_global,\n-                segments: segments,\n-            },\n-            bounds: opt_bounds,\n+        ast::Path {\n+            span: span,\n+            global: is_global,\n+            segments: segments,\n         }\n     }\n \n@@ -1837,10 +1822,10 @@ impl<'a> Parser<'a> {\n                 let inputs = self.parse_seq_to_end(\n                     &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n-                    |p| p.parse_ty(true));\n+                    |p| p.parse_ty_sum());\n \n                 let output_ty = if self.eat(&token::RArrow) {\n-                    Some(self.parse_ty(true))\n+                    Some(self.parse_ty())\n                 } else {\n                     None\n                 };\n@@ -2327,7 +2312,7 @@ impl<'a> Parser<'a> {\n                         !self.token.is_keyword(keywords::True) &&\n                         !self.token.is_keyword(keywords::False) {\n                     let pth =\n-                        self.parse_path(LifetimeAndTypesWithColons).path;\n+                        self.parse_path(LifetimeAndTypesWithColons);\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n                     if self.token == token::Not {\n@@ -2898,7 +2883,7 @@ impl<'a> Parser<'a> {\n             }\n             None => {\n                 if as_prec > min_prec && self.eat_keyword(keywords::As) {\n-                    let rhs = self.parse_ty(false);\n+                    let rhs = self.parse_ty();\n                     let _as = self.mk_expr(lhs.span.lo,\n                                            rhs.span.hi,\n                                            ExprCast(lhs, rhs));\n@@ -3362,8 +3347,7 @@ impl<'a> Parser<'a> {\n                     }) {\n                 self.bump();\n                 let end = if self.token.is_ident() || self.token.is_path() {\n-                    let path = self.parse_path(LifetimeAndTypesWithColons)\n-                                   .path;\n+                    let path = self.parse_path(LifetimeAndTypesWithColons);\n                     let hi = self.span.hi;\n                     self.mk_expr(lo, hi, ExprPath(path))\n                 } else {\n@@ -3433,8 +3417,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // parse an enum pat\n-                let enum_path = self.parse_path(LifetimeAndTypesWithColons)\n-                                    .path;\n+                let enum_path = self.parse_path(LifetimeAndTypesWithColons);\n                 match self.token {\n                     token::OpenDelim(token::Brace) => {\n                         self.bump();\n@@ -3548,7 +3531,7 @@ impl<'a> Parser<'a> {\n             span: mk_sp(lo, lo),\n         });\n         if self.eat(&token::Colon) {\n-            ty = self.parse_ty(true);\n+            ty = self.parse_ty_sum();\n         }\n         let init = self.parse_initializer();\n         P(ast::Local {\n@@ -3577,7 +3560,7 @@ impl<'a> Parser<'a> {\n         }\n         let name = self.parse_ident();\n         self.expect(&token::Colon);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         spanned(lo, self.last_span.hi, ast::StructField_ {\n             kind: NamedField(name, pr),\n             id: ast::DUMMY_NODE_ID,\n@@ -3624,7 +3607,7 @@ impl<'a> Parser<'a> {\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n-            let pth = self.parse_path(NoTypesAllowed).path;\n+            let pth = self.parse_path(NoTypesAllowed);\n             self.bump();\n \n             let id = match self.token {\n@@ -3976,7 +3959,7 @@ impl<'a> Parser<'a> {\n \n         let default = if self.token == token::Eq {\n             self.bump();\n-            Some(self.parse_ty(true))\n+            Some(self.parse_ty_sum())\n         }\n         else { None };\n \n@@ -4032,7 +4015,7 @@ impl<'a> Parser<'a> {\n             Some(token::Comma),\n             |p| {\n                 p.forbid_lifetime();\n-                p.parse_ty(true)\n+                p.parse_ty_sum()\n             }\n         );\n         (lifetimes, result.into_vec())\n@@ -4265,7 +4248,7 @@ impl<'a> Parser<'a> {\n                     // Determine whether this is the fully explicit form, `self:\n                     // TYPE`.\n                     if self.eat(&token::Colon) {\n-                        SelfExplicit(self.parse_ty(false), self_ident)\n+                        SelfExplicit(self.parse_ty_sum(), self_ident)\n                     } else {\n                         SelfValue(self_ident)\n                     }\n@@ -4277,7 +4260,7 @@ impl<'a> Parser<'a> {\n                     // Determine whether this is the fully explicit form,\n                     // `self: TYPE`.\n                     if self.eat(&token::Colon) {\n-                        SelfExplicit(self.parse_ty(false), self_ident)\n+                        SelfExplicit(self.parse_ty_sum(), self_ident)\n                     } else {\n                         SelfValue(self_ident)\n                     }\n@@ -4466,7 +4449,7 @@ impl<'a> Parser<'a> {\n                 && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n                 // method macro.\n-                let pth = self.parse_path(NoTypesAllowed).path;\n+                let pth = self.parse_path(NoTypesAllowed);\n                 self.expect(&token::Not);\n \n                 // eat a matched-delimiter token tree:\n@@ -4564,30 +4547,25 @@ impl<'a> Parser<'a> {\n         let could_be_trait = self.token != token::OpenDelim(token::Paren);\n \n         // Parse the trait.\n-        let mut ty = self.parse_ty(true);\n+        let mut ty = self.parse_ty_sum();\n \n         // Parse traits, if necessary.\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n-                TyPath(ref path, None, node_id) => {\n+                TyPath(ref path, node_id) => {\n                     Some(TraitRef {\n                         path: (*path).clone(),\n                         ref_id: node_id,\n                     })\n                 }\n-                TyPath(_, Some(_), _) => {\n-                    self.span_err(ty.span,\n-                                  \"bounded traits are only valid in type position\");\n-                    None\n-                }\n                 _ => {\n                     self.span_err(ty.span, \"not a trait\");\n                     None\n                 }\n             };\n \n-            ty = self.parse_ty(true);\n+            ty = self.parse_ty_sum();\n             opt_trait_ref\n         } else {\n             None\n@@ -4606,7 +4584,7 @@ impl<'a> Parser<'a> {\n     /// Parse a::B<String,int>\n     fn parse_trait_ref(&mut self) -> TraitRef {\n         ast::TraitRef {\n-            path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n+            path: self.parse_path(LifetimeAndTypesWithoutColons),\n             ref_id: ast::DUMMY_NODE_ID,\n         }\n     }\n@@ -4638,7 +4616,7 @@ impl<'a> Parser<'a> {\n         let mut generics = self.parse_generics();\n \n         if self.eat(&token::Colon) {\n-            let ty = self.parse_ty(true);\n+            let ty = self.parse_ty_sum();\n             self.span_err(ty.span, \"`virtual` structs have been removed from the language\");\n         }\n \n@@ -4673,7 +4651,7 @@ impl<'a> Parser<'a> {\n                 let struct_field_ = ast::StructField_ {\n                     kind: UnnamedField(p.parse_visibility()),\n                     id: ast::DUMMY_NODE_ID,\n-                    ty: p.parse_ty(true),\n+                    ty: p.parse_ty_sum(),\n                     attrs: attrs,\n                 };\n                 spanned(lo, p.span.hi, struct_field_)\n@@ -4830,7 +4808,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_const(&mut self, m: Option<Mutability>) -> ItemInfo {\n         let id = self.parse_ident();\n         self.expect(&token::Colon);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         self.expect(&token::Eq);\n         let e = self.parse_expr();\n         self.commit_expr_expecting(&*e, token::Semi);\n@@ -5023,7 +5001,7 @@ impl<'a> Parser<'a> {\n \n         let ident = self.parse_ident();\n         self.expect(&token::Colon);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         let hi = self.span.hi;\n         self.expect(&token::Semi);\n         P(ForeignItem {\n@@ -5181,7 +5159,7 @@ impl<'a> Parser<'a> {\n         let mut tps = self.parse_generics();\n         self.parse_where_clause(&mut tps);\n         self.expect(&token::Eq);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         self.expect(&token::Semi);\n         (ident, ItemTy(ty, tps), None)\n     }\n@@ -5235,7 +5213,7 @@ impl<'a> Parser<'a> {\n                     &token::OpenDelim(token::Paren),\n                     &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n-                    |p| p.parse_ty(true)\n+                    |p| p.parse_ty_sum()\n                 );\n                 for ty in arg_tys.into_iter() {\n                     args.push(ast::VariantArg {\n@@ -5593,7 +5571,7 @@ impl<'a> Parser<'a> {\n             // MACRO INVOCATION ITEM\n \n             // item macro.\n-            let pth = self.parse_path(NoTypesAllowed).path;\n+            let pth = self.parse_path(NoTypesAllowed);\n             self.expect(&token::Not);\n \n             // a 'special' identifier (like what `macro_rules!` uses)"}, {"sha": "ab78d5ecbfdce6e1f0d8c6fc058b8edf38100264", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -61,7 +61,7 @@ pub struct State<'a> {\n     literals: Option<Vec<comments::Literal> >,\n     cur_cmnt_and_lit: CurrentCommentAndLiteral,\n     boxes: Vec<pp::Breaks>,\n-    ann: &'a PpAnn+'a,\n+    ann: &'a (PpAnn+'a),\n     encode_idents_with_hygiene: bool,\n }\n \n@@ -293,6 +293,10 @@ pub fn ty_to_string(ty: &ast::Ty) -> String {\n     $to_string(|s| s.print_type(ty))\n }\n \n+pub fn bounds_to_string(bounds: &[ast::TyParamBound]) -> String {\n+    $to_string(|s| s.print_bounds(\"\", bounds))\n+}\n+\n pub fn pat_to_string(pat: &ast::Pat) -> String {\n     $to_string(|s| s.print_pat(pat))\n }\n@@ -739,11 +743,15 @@ impl<'a> State<'a> {\n                                       Some(&generics),\n                                       None));\n             }\n-            ast::TyPath(ref path, ref bounds, _) => {\n-                try!(self.print_bounded_path(path, bounds));\n+            ast::TyPath(ref path, _) => {\n+                try!(self.print_path(path, false));\n+            }\n+            ast::TyObjectSum(ref ty, ref bounds) => {\n+                try!(self.print_type(&**ty));\n+                try!(self.print_bounds(\"+\", bounds.as_slice()));\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                try!(self.print_bounds(\"\", bounds));\n+                try!(self.print_bounds(\"\", bounds.as_slice()));\n             }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));\n@@ -970,7 +978,7 @@ impl<'a> State<'a> {\n                     }\n                     _ => {}\n                 }\n-                try!(self.print_bounds(\":\", bounds));\n+                try!(self.print_bounds(\":\", bounds.as_slice()));\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n@@ -1908,11 +1916,11 @@ impl<'a> State<'a> {\n         self.print_expr(coll)\n     }\n \n-    fn print_path_(&mut self,\n-                   path: &ast::Path,\n-                   colons_before_params: bool,\n-                   opt_bounds: &Option<OwnedSlice<ast::TyParamBound>>)\n-        -> IoResult<()> {\n+    fn print_path(&mut self,\n+                  path: &ast::Path,\n+                  colons_before_params: bool)\n+                  -> IoResult<()>\n+    {\n         try!(self.maybe_print_comment(path.span.lo));\n         if path.global {\n             try!(word(&mut self.s, \"::\"));\n@@ -1931,10 +1939,7 @@ impl<'a> State<'a> {\n             try!(self.print_path_parameters(&segment.parameters, colons_before_params));\n         }\n \n-        match *opt_bounds {\n-            None => Ok(()),\n-            Some(ref bounds) => self.print_bounds(\"+\", bounds)\n-        }\n+        Ok(())\n     }\n \n     fn print_path_parameters(&mut self,\n@@ -1997,17 +2002,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_path(&mut self, path: &ast::Path,\n-                  colons_before_params: bool) -> IoResult<()> {\n-        self.print_path_(path, colons_before_params, &None)\n-    }\n-\n-    fn print_bounded_path(&mut self, path: &ast::Path,\n-                          bounds: &Option<OwnedSlice<ast::TyParamBound>>)\n-        -> IoResult<()> {\n-        self.print_path_(path, false, bounds)\n-    }\n-\n     pub fn print_pat(&mut self, pat: &ast::Pat) -> IoResult<()> {\n         try!(self.maybe_print_comment(pat.span.lo));\n         try!(self.ann.pre(self, NodePat(pat)));\n@@ -2329,7 +2323,7 @@ impl<'a> State<'a> {\n \n     pub fn print_bounds(&mut self,\n                         prefix: &str,\n-                        bounds: &OwnedSlice<ast::TyParamBound>)\n+                        bounds: &[ast::TyParamBound])\n                         -> IoResult<()> {\n         if !bounds.is_empty() {\n             try!(word(&mut self.s, prefix));\n@@ -2418,7 +2412,7 @@ impl<'a> State<'a> {\n             _ => {}\n         }\n         try!(self.print_ident(param.ident));\n-        try!(self.print_bounds(\":\", &param.bounds));\n+        try!(self.print_bounds(\":\", param.bounds.as_slice()));\n         match param.default {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n@@ -2447,7 +2441,7 @@ impl<'a> State<'a> {\n             }\n \n             try!(self.print_ident(predicate.ident));\n-            try!(self.print_bounds(\":\", &predicate.bounds));\n+            try!(self.print_bounds(\":\", predicate.bounds.as_slice()));\n         }\n \n         Ok(())\n@@ -2664,7 +2658,7 @@ impl<'a> State<'a> {\n             try!(self.pclose());\n         }\n \n-        try!(self.print_bounds(\":\", bounds));\n+        try!(self.print_bounds(\":\", bounds.as_slice()));\n \n         try!(self.print_fn_output(decl));\n "}, {"sha": "05828fc05f8c60358bb05ae27e83c2e520605094", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -482,8 +482,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     let ecx = &cx.ext_cx;\n     let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n                                                     ecx.ident_of(\"test\"),\n-                                                    ecx.ident_of(\"TestDescAndFn\")]),\n-                                  None);\n+                                                    ecx.ident_of(\"TestDescAndFn\")]));\n     let static_lt = ecx.lifetime(sp, token::special_idents::static_lifetime.name);\n     // &'static [self::test::TestDescAndFn]\n     let static_type = ecx.ty_rptr(sp,"}, {"sha": "95679bc6bf0d1ea3f89146c53c06e1c637f9e5ae", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -404,14 +404,12 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n             walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n         }\n-        TyPath(ref path, ref opt_bounds, id) => {\n+        TyPath(ref path, id) => {\n             visitor.visit_path(path, id);\n-            match *opt_bounds {\n-                Some(ref bounds) => {\n-                    walk_ty_param_bounds_helper(visitor, bounds);\n-                }\n-                None => { }\n-            }\n+        }\n+        TyObjectSum(ref ty, ref bounds) => {\n+            visitor.visit_ty(&**ty);\n+            walk_ty_param_bounds_helper(visitor, bounds);\n         }\n         TyQPath(ref qpath) => {\n             visitor.visit_ty(&*qpath.self_type);"}, {"sha": "611c10ea71a09ea3db4782926d6eda630b3cc210", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -115,7 +115,7 @@ pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n #[cfg(not(windows))]\n /// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n /// opened.\n-pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send> + Send> {\n+pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     TerminfoTerminal::new(WriterWrapper {\n         wrapped: box std::io::stderr() as Box<Writer + Send>,\n     })"}, {"sha": "f6511d68662eea478baea35e26ee5baf6f036f06", "filename": "src/test/compile-fail/dst-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-index.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -25,7 +25,7 @@ impl Index<uint, str> for S {\n struct T;\n \n impl Index<uint, Show + 'static> for T {\n-    fn index<'a>(&'a self, idx: &uint) -> &'a Show + 'static {\n+    fn index<'a>(&'a self, idx: &uint) -> &'a (Show + 'static) {\n         static x: uint = 42;\n         &x\n     }"}, {"sha": "a0d81b831f69c71c45f7af70eae02136dbbd7e88", "filename": "src/test/compile-fail/hrtb-precedence-of-plus-error-message.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fhrtb-precedence-of-plus-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fhrtb-precedence-of-plus-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-precedence-of-plus-error-message.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// Test that we suggest the correct parentheses\n+\n+trait Bar {\n+    fn dummy(&self) { }\n+}\n+\n+struct Foo<'a> {\n+    a: &'a Bar+'a,\n+        //~^ ERROR E0171\n+        //~^^ NOTE perhaps you meant `&'a (Bar + 'a)`?\n+\n+    b: &'a mut Bar+'a,\n+        //~^ ERROR E0171\n+        //~^^ NOTE perhaps you meant `&'a mut (Bar + 'a)`?\n+\n+    c: Box<Bar+'a>, // OK, no paren needed in this context\n+\n+    d: fn() -> Bar+'a,\n+        //~^ ERROR E0171\n+        //~^^ NOTE perhaps you forgot parentheses\n+}\n+\n+fn main() { }"}, {"sha": "0202d538cf650941785177cee728144c00e99c16", "filename": "src/test/compile-fail/issue-12470.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fissue-12470.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fissue-12470.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12470.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -24,7 +24,7 @@ impl X for B {\n }\n \n struct A<'a> {\n-    p: &'a X+'a\n+    p: &'a (X+'a)\n }\n \n fn make_a<'a>(p: &'a X) -> A<'a> {"}, {"sha": "cbf4412a81df286d23ef2da9f2bb817e797adc63", "filename": "src/test/compile-fail/issue-14285.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fissue-14285.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fissue-14285.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14285.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -14,7 +14,7 @@ struct A;\n \n impl Foo for A {}\n \n-struct B<'a>(&'a Foo+'a);\n+struct B<'a>(&'a (Foo+'a));\n \n fn foo<'a>(a: &Foo) -> B<'a> {\n     B(a)    //~ ERROR cannot infer an appropriate lifetime"}, {"sha": "202529c30b3e6b3d4691ccdbbae4fac1bcf87b49", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -44,15 +44,15 @@ fn test<'a,T,U:Copy>(_: &'a int) {\n \n     // borrowed object types are generally ok\n     assert_copy::<&'a Dummy>();\n-    assert_copy::<&'a Dummy+Copy>();\n-    assert_copy::<&'static Dummy+Copy>();\n+    assert_copy::<&'a (Dummy+Copy)>();\n+    assert_copy::<&'static (Dummy+Copy)>();\n \n     // owned object types are not ok\n     assert_copy::<Box<Dummy>>(); //~ ERROR `core::kinds::Copy` is not implemented\n     assert_copy::<Box<Dummy+Copy>>(); //~ ERROR `core::kinds::Copy` is not implemented\n \n     // mutable object types are not ok\n-    assert_copy::<&'a mut Dummy+Copy>();  //~ ERROR `core::kinds::Copy` is not implemented\n+    assert_copy::<&'a mut (Dummy+Copy)>();  //~ ERROR `core::kinds::Copy` is not implemented\n \n     // closures are like an `&mut` object\n     assert_copy::<||>(); //~ ERROR `core::kinds::Copy` is not implemented"}, {"sha": "4fbb3eab8c416234b10de8ef08ff6c2fc036cf35", "filename": "src/test/compile-fail/kindck-send-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -19,7 +19,7 @@ trait Message : Send { }\n // careful with object types, who knows what they close over...\n \n fn object_ref_with_static_bound_not_ok() {\n-    assert_send::<&'static Dummy+'static>();\n+    assert_send::<&'static (Dummy+'static)>();\n     //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n@@ -36,7 +36,7 @@ fn closure_with_no_bound_not_ok<'a>() {\n }\n \n fn object_with_send_bound_ok() {\n-    assert_send::<&'static Dummy+Send>();\n+    assert_send::<&'static (Dummy+Send)>();\n     assert_send::<Box<Dummy+Send>>();\n     assert_send::<proc():Send>;\n     assert_send::<||:Send>;"}, {"sha": "a551975364329f7f7bbcf453674ff5ece9e7f5fb", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -21,13 +21,13 @@ fn test51<'a>() {\n     //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n fn test52<'a>() {\n-    assert_send::<&'a Dummy+Send>();\n+    assert_send::<&'a (Dummy+Send)>();\n     //~^ ERROR does not fulfill the required lifetime\n }\n \n // ...unless they are properly bounded\n fn test60() {\n-    assert_send::<&'static Dummy+Send>();\n+    assert_send::<&'static (Dummy+Send)>();\n }\n fn test61() {\n     assert_send::<Box<Dummy+Send>>();"}, {"sha": "ea8c262830633b20e1ff7c8b143dc0707106c6e6", "filename": "src/test/compile-fail/kindck-send-object2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -23,7 +23,7 @@ fn test53() {\n \n // ...unless they are properly bounded\n fn test60() {\n-    assert_send::<&'static Dummy+Send>();\n+    assert_send::<&'static (Dummy+Send)>();\n }\n fn test61() {\n     assert_send::<Box<Dummy+Send>>();"}, {"sha": "4758ce71ffff5a4c77d94e8c25254a8a952e998a", "filename": "src/test/compile-fail/region-object-lifetime-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -28,14 +28,14 @@ fn borrowed_receiver_different_lifetimes<'a,'b>(x: &'a Foo) -> &'b () {\n \n // Borrowed receiver with two distinct lifetimes, but we know that\n // 'b:'a, hence &'a () is permitted.\n-fn borrowed_receiver_related_lifetimes<'a,'b>(x: &'a Foo+'b) -> &'a () {\n+fn borrowed_receiver_related_lifetimes<'a,'b>(x: &'a (Foo+'b)) -> &'a () {\n     x.borrowed()\n }\n \n // Here we have two distinct lifetimes, but we try to return a pointer\n // with the longer lifetime when (from the signature) we only know\n // that it lives as long as the shorter lifetime. Therefore, error.\n-fn borrowed_receiver_related_lifetimes2<'a,'b>(x: &'a Foo+'b) -> &'b () {\n+fn borrowed_receiver_related_lifetimes2<'a,'b>(x: &'a (Foo+'b)) -> &'b () {\n     x.borrowed() //~ ERROR cannot infer\n }\n "}, {"sha": "660a9be4f63c5cd2cbfce201bb83ccb6ebebcfe2", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -57,12 +57,12 @@ fn box_with_region_not_ok<'a>() {\n // objects with insufficient bounds no ok\n \n fn object_with_random_bound_not_ok<'a>() {\n-    assert_send::<&'a Dummy+'a>();\n+    assert_send::<&'a (Dummy+'a)>();\n     //~^ ERROR not implemented\n }\n \n fn object_with_send_bound_not_ok<'a>() {\n-    assert_send::<&'a Dummy+Send>();\n+    assert_send::<&'a (Dummy+Send)>();\n     //~^ ERROR does not fulfill\n }\n "}, {"sha": "48945868bd35539f49f1ba584e888f4852b8df7d", "filename": "src/test/compile-fail/regions-close-object-into-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -10,7 +10,7 @@\n \n \n trait A<T> {}\n-struct B<'a, T>(&'a A<T>+'a);\n+struct B<'a, T>(&'a (A<T>+'a));\n \n trait X {}\n impl<'a, T> X for B<'a, T> {}"}, {"sha": "4e31a41c4e07489687bfbbf59b35f65f2823aa4d", "filename": "src/test/compile-fail/regions-trait-variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fregions-trait-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Fregions-trait-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-variance.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -31,7 +31,7 @@ impl Drop for B {\n }\n \n struct A<'r> {\n-    p: &'r X+'r\n+    p: &'r (X+'r)\n }\n \n fn make_a(p:&X) -> A {"}, {"sha": "a034352c4a69457e8f6cf49c31f13ac20819f90a", "filename": "src/test/compile-fail/trait-bounds-not-on-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-impl.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -13,7 +13,7 @@ trait Foo {\n \n struct Bar;\n \n-impl Foo + Owned for Bar { //~ ERROR bounded traits are only valid in type position\n+impl Foo + Owned for Bar { //~ ERROR not a trait\n }\n \n fn main() { }"}, {"sha": "081efa429c3e43c1d233de5f61ebd53fd5209be3", "filename": "src/test/compile-fail/trait-bounds-not-on-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -11,6 +11,6 @@\n \n struct Foo;\n \n-fn foo(_x: Box<Foo + Send>) { } //~ ERROR kind bounds can only be used on trait types\n+fn foo(_x: Box<Foo + Send>) { } //~ ERROR expected a reference to a trait\n \n fn main() { }"}, {"sha": "4da496621d1c942f2a4da163e051755398517976", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -16,14 +16,14 @@ trait Foo {}\n fn a(_x: Box<Foo+Send>) {\n }\n \n-fn b(_x: &'static Foo+'static) {\n+fn b(_x: &'static (Foo+'static)) {\n }\n \n fn c(x: Box<Foo+Sync>) {\n     a(x); //~ ERROR mismatched types\n }\n \n-fn d(x: &'static Foo+Sync) {\n+fn d(x: &'static (Foo+Sync)) {\n     b(x); //~ ERROR cannot infer\n     //~^ ERROR mismatched types\n }"}, {"sha": "bbb049eb9603315577e73789545a5954b7bb17da", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -18,7 +18,7 @@ use std::fmt;\n use std::fmt::FormatWriter;\n \n struct Foo<'a> {\n-    writer: &'a mut Writer+'a,\n+    writer: &'a mut (Writer+'a),\n     other: &'a str,\n }\n "}, {"sha": "eaf7131e1d878a36261f57ec9c8f354b7c4e5273", "filename": "src/test/run-pass/dst-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-index.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -25,7 +25,7 @@ impl Index<uint, str> for S {\n struct T;\n \n impl Index<uint, Show + 'static> for T {\n-    fn index<'a>(&'a self, idx: &uint) -> &'a Show + 'static {\n+    fn index<'a>(&'a self, idx: &uint) -> &'a (Show + 'static) {\n         static x: uint = 42;\n         &x\n     }"}, {"sha": "86ce49f56cb57cd33b4da42e397ae3cd1dc549c6", "filename": "src/test/run-pass/hrtb-precedence-of-plus-where-clause.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fhrtb-precedence-of-plus-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fhrtb-precedence-of-plus-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-precedence-of-plus-where-clause.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// Test that `F : Fn(int) -> int + Send` is interpreted as two\n+// distinct bounds on `F`.\n+\n+fn foo<F>(f: F)\n+    where F : FnOnce(int) -> int + Send\n+{\n+    bar(f);\n+    baz(f);\n+}\n+\n+fn bar<F:Send>(f: F) { }\n+\n+fn baz<F:FnOnce(int) -> int>(f: F) { }\n+\n+fn main() {}"}, {"sha": "9a43b5b711eb5e0a346544dc28a89bfd3335d8bf", "filename": "src/test/run-pass/hrtb-precedence-of-plus.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fhrtb-precedence-of-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fhrtb-precedence-of-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-precedence-of-plus.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// Test that `Fn(int) -> int + 'static` parses as `(Fn(int) -> int) +\n+// 'static` and not `Fn(int) -> (int + 'static)`. The latter would\n+// cause a compilation error. Issue #18772.\n+\n+fn adder(y: int) -> Box<Fn(int) -> int + 'static> {\n+    box move |&: x| y + x\n+}\n+\n+fn main() {}"}, {"sha": "324a1701b2febdb4f4bb38d2fa360f06a22f5403", "filename": "src/test/run-pass/issue-10902.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-10902.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-10902.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10902.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -10,15 +10,15 @@\n \n pub mod two_tuple {\n     pub trait T {}\n-    pub struct P<'a>(&'a T + 'a, &'a T + 'a);\n+    pub struct P<'a>(&'a (T + 'a), &'a (T + 'a));\n     pub fn f<'a>(car: &'a T, cdr: &'a T) -> P<'a> {\n         P(car, cdr)\n     }\n }\n \n pub mod two_fields {\n     pub trait T {}\n-    pub struct P<'a> { car: &'a T + 'a, cdr: &'a T + 'a }\n+    pub struct P<'a> { car: &'a (T + 'a), cdr: &'a (T + 'a) }\n     pub fn f<'a>(car: &'a T, cdr: &'a T) -> P<'a> {\n         P{ car: car, cdr: cdr }\n     }"}, {"sha": "ea138311f19b3bb25a4696a8844dc97d51bbfe41", "filename": "src/test/run-pass/issue-11205.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11205.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -49,7 +49,7 @@ fn main() {\n     foog(x, &[box 1i]);\n \n     struct T<'a> {\n-        t: [&'a Foo+'a, ..2]\n+        t: [&'a (Foo+'a), ..2]\n     }\n     let _n = T {\n         t: [&1i, &2i]\n@@ -64,7 +64,7 @@ fn main() {\n     };\n \n     struct F<'b> {\n-        t: &'b [&'b Foo+'b]\n+        t: &'b [&'b (Foo+'b)]\n     }\n     let _n = F {\n         t: &[&1i, &2i]"}, {"sha": "e41754fd1b9983b19a88171b9a6c1ef109818f79", "filename": "src/test/run-pass/issue-14901.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-14901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-14901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14901.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -11,7 +11,7 @@\n use std::io::Reader;\n \n enum Wrapper<'a> {\n-    WrapReader(&'a Reader + 'a)\n+    WrapReader(&'a (Reader + 'a))\n }\n \n trait Wrap<'a> {"}, {"sha": "1ffd349a653853274f98c8809f857218f7cc58a0", "filename": "src/test/run-pass/issue-14958.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14958.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -14,7 +14,7 @@ trait Foo {}\n \n struct Bar;\n \n-impl<'a> std::ops::Fn<(&'a Foo+'a,), ()> for Bar {\n+impl<'a> std::ops::Fn<(&'a (Foo+'a),), ()> for Bar {\n     extern \"rust-call\" fn call(&self, _: (&'a Foo,)) {}\n }\n "}, {"sha": "99472bb3610f80c203da9648e8a061b3e27ee8e6", "filename": "src/test/run-pass/issue-14959.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14959.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -33,8 +33,8 @@ impl Alloy {\n     }\n }\n \n-impl<'a, 'b> Fn<(&'b mut Response+'b,),()> for SendFile<'a> {\n-    extern \"rust-call\" fn call(&self, (_res,): (&'b mut Response+'b,)) {}\n+impl<'a, 'b> Fn<(&'b mut (Response+'b),),()> for SendFile<'a> {\n+    extern \"rust-call\" fn call(&self, (_res,): (&'b mut (Response+'b),)) {}\n }\n \n impl<Rq: Request, Rs: Response> Ingot<Rq, Rs> for HelloWorld {"}, {"sha": "61ae273aef50bdf9cd029c088a1f60c8f0363eee", "filename": "src/test/run-pass/issue-5708.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5708.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -29,7 +29,7 @@ impl Inner for int {\n }\n \n struct Outer<'a> {\n-    inner: &'a Inner+'a\n+    inner: &'a (Inner+'a)\n }\n \n impl<'a> Outer<'a> {\n@@ -51,7 +51,7 @@ pub fn main() {\n pub trait MyTrait<T> { }\n \n pub struct MyContainer<'a, T> {\n-    foos: Vec<&'a MyTrait<T>+'a> ,\n+    foos: Vec<&'a (MyTrait<T>+'a)> ,\n }\n \n impl<'a, T> MyContainer<'a, T> {"}, {"sha": "44f07def531bced6272ef9157c3f544e4f6cdb0d", "filename": "src/test/run-pass/issue-8249.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-8249.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-8249.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8249.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -13,7 +13,7 @@ struct B;\n impl A for B {}\n \n struct C<'a> {\n-    foo: &'a mut A+'a,\n+    foo: &'a mut (A+'a),\n }\n \n fn foo(a: &mut A) {"}, {"sha": "4c6b9a3aaa0e4f98ce112ec2174254b340643e30", "filename": "src/test/run-pass/issue-9719.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-9719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fissue-9719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9719.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -16,15 +16,15 @@ mod a {\n     pub trait X {}\n     impl X for int {}\n \n-    pub struct Z<'a>(Enum<&'a X+'a>);\n+    pub struct Z<'a>(Enum<&'a (X+'a)>);\n     fn foo() { let x = 42i; let z = Z(Enum::A(&x as &X)); let _ = z; }\n }\n \n mod b {\n     trait X {}\n     impl X for int {}\n     struct Y<'a>{\n-        x:Option<&'a X+'a>,\n+        x:Option<&'a (X+'a)>,\n     }\n \n     fn bar() {\n@@ -36,7 +36,7 @@ mod b {\n mod c {\n     pub trait X { fn f(&self); }\n     impl X for int { fn f(&self) {} }\n-    pub struct Z<'a>(Option<&'a X+'a>);\n+    pub struct Z<'a>(Option<&'a (X+'a)>);\n     fn main() { let x = 42i; let z = Z(Some(&x as &X)); let _ = z; }\n }\n "}, {"sha": "840e58848a742f59b31af183bcb70508365a05de", "filename": "src/test/run-pass/parameterized-trait-with-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fparameterized-trait-with-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fparameterized-trait-with-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fparameterized-trait-with-bounds.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -19,7 +19,7 @@ mod foo {\n     pub trait D<'a, T> {}\n }\n \n-fn foo1<T>(_: &A<T> + Send) {}\n+fn foo1<T>(_: &(A<T> + Send)) {}\n fn foo2<T>(_: Box<A<T> + Send + Sync>) {}\n fn foo3<T>(_: Box<B<int, uint> + 'static>) {}\n fn foo4<'a, T>(_: Box<C<'a, T> + 'static + Send>) {}"}, {"sha": "907f610ff25dbdcfeb098fa190b3f3ab846d8960", "filename": "src/test/run-pass/regions-early-bound-trait-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a775639ca846f29abeed16a7b4e8e1c8819626/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs?ref=f4a775639ca846f29abeed16a7b4e8e1c8819626", "patch": "@@ -30,7 +30,7 @@ fn object_invoke1<'d>(x: &'d Trait<'d>) -> (int, int) {\n }\n \n struct Struct1<'e> {\n-    f: &'e Trait<'e>+'e\n+    f: &'e (Trait<'e>+'e)\n }\n \n fn field_invoke1<'f, 'g>(x: &'g Struct1<'f>) -> (int,int) {\n@@ -40,7 +40,7 @@ fn field_invoke1<'f, 'g>(x: &'g Struct1<'f>) -> (int,int) {\n }\n \n struct Struct2<'h, 'i> {\n-    f: &'h Trait<'i>+'h\n+    f: &'h (Trait<'i>+'h)\n }\n \n fn object_invoke2<'j, 'k>(x: &'k Trait<'j>) -> int {"}]}