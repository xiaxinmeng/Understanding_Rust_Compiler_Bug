{"sha": "0454a41bec547b28526cdb511f05372c80cb7277", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NTRhNDFiZWM1NDdiMjg1MjZjZGI1MTFmMDUzNzJjODBjYjcyNzc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-04T10:35:56Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-04T10:35:56Z"}, "message": "incr.comp.: Address review comments.", "tree": {"sha": "bb5f68cfe87022b5c72debd234b0f9f5e12b18d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb5f68cfe87022b5c72debd234b0f9f5e12b18d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0454a41bec547b28526cdb511f05372c80cb7277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0454a41bec547b28526cdb511f05372c80cb7277", "html_url": "https://github.com/rust-lang/rust/commit/0454a41bec547b28526cdb511f05372c80cb7277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0454a41bec547b28526cdb511f05372c80cb7277/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c96d0bff949ef6faed3bc5ab26b4530c2c27cc42", "url": "https://api.github.com/repos/rust-lang/rust/commits/c96d0bff949ef6faed3bc5ab26b4530c2c27cc42", "html_url": "https://github.com/rust-lang/rust/commit/c96d0bff949ef6faed3bc5ab26b4530c2c27cc42"}], "stats": {"total": 102, "additions": 71, "deletions": 31}, "files": [{"sha": "2d2558fd815c4f08f0de89503ce8f3fb7822b9c9", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 54, "deletions": 25, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0454a41bec547b28526cdb511f05372c80cb7277/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0454a41bec547b28526cdb511f05372c80cb7277/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=0454a41bec547b28526cdb511f05372c80cb7277", "patch": "@@ -52,7 +52,7 @@ pub struct DepNodeIndex {\n \n impl Idx for DepNodeIndex {\n     fn new(idx: usize) -> Self {\n-        assert!((idx & 0xFFFF_FFFF) == idx);\n+        debug_assert!((idx & 0xFFFF_FFFF) == idx);\n         DepNodeIndex { index: idx as u32 }\n     }\n     fn index(self) -> usize {\n@@ -228,20 +228,31 @@ impl DepGraph {\n \n             let current_fingerprint = stable_hasher.finish();\n \n-            assert!(self.fingerprints\n-                        .borrow_mut()\n-                        .insert(key, current_fingerprint)\n-                        .is_none());\n+            // Store the current fingerprint\n+            {\n+                let old_value = self.fingerprints\n+                                    .borrow_mut()\n+                                    .insert(key, current_fingerprint);\n+                debug_assert!(old_value.is_none(),\n+                              \"DepGraph::with_task() - Duplicate fingerprint \\\n+                               insertion for {:?}\", key);\n+            }\n \n-            let prev_fingerprint = data.previous.fingerprint_of(&key);\n+            // Determine the color of the new DepNode.\n+            {\n+                let prev_fingerprint = data.previous.fingerprint_of(&key);\n \n-            let color = if Some(current_fingerprint) == prev_fingerprint {\n-                DepNodeColor::Green(dep_node_index)\n-            } else {\n-                DepNodeColor::Red\n-            };\n+                let color = if Some(current_fingerprint) == prev_fingerprint {\n+                    DepNodeColor::Green(dep_node_index)\n+                } else {\n+                    DepNodeColor::Red\n+                };\n \n-            assert!(data.colors.borrow_mut().insert(key, color).is_none());\n+                let old_value = data.colors.borrow_mut().insert(key, color);\n+                debug_assert!(old_value.is_none(),\n+                              \"DepGraph::with_task() - Duplicate DepNodeColor \\\n+                               insertion for {:?}\", key);\n+            }\n \n             (result, dep_node_index)\n         } else {\n@@ -250,10 +261,12 @@ impl DepGraph {\n                 let result = task(cx, arg);\n                 let mut stable_hasher = StableHasher::new();\n                 result.hash_stable(&mut hcx, &mut stable_hasher);\n-                assert!(self.fingerprints\n-                            .borrow_mut()\n-                            .insert(key, stable_hasher.finish())\n-                            .is_none());\n+                let old_value = self.fingerprints\n+                                    .borrow_mut()\n+                                    .insert(key, stable_hasher.finish());\n+                debug_assert!(old_value.is_none(),\n+                              \"DepGraph::with_task() - Duplicate fingerprint \\\n+                               insertion for {:?}\", key);\n                 (result, DepNodeIndex::INVALID)\n             } else {\n                 (task(cx, arg), DepNodeIndex::INVALID)\n@@ -549,16 +562,20 @@ impl DepGraph {\n         // ... copying the fingerprint from the previous graph too, so we don't\n         // have to recompute it ...\n         let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n-        assert!(self.fingerprints\n-                    .borrow_mut()\n-                    .insert(*dep_node, fingerprint)\n-                    .is_none());\n+        let old_fingerprint = self.fingerprints\n+                                  .borrow_mut()\n+                                  .insert(*dep_node, fingerprint);\n+        debug_assert!(old_fingerprint.is_none(),\n+                      \"DepGraph::try_mark_green() - Duplicate fingerprint \\\n+                      insertion for {:?}\", dep_node);\n \n         // ... and finally storing a \"Green\" entry in the color map.\n-        assert!(data.colors\n-                    .borrow_mut()\n-                    .insert(*dep_node, DepNodeColor::Green(dep_node_index))\n-                    .is_none());\n+        let old_color = data.colors\n+                            .borrow_mut()\n+                            .insert(*dep_node, DepNodeColor::Green(dep_node_index));\n+        debug_assert!(old_color.is_none(),\n+                      \"DepGraph::try_mark_green() - Duplicate DepNodeColor \\\n+                      insertion for {:?}\", dep_node);\n \n         debug!(\"try_mark_green({:?}) - END - successfully marked as green\", dep_node.kind);\n         Some(dep_node_index)\n@@ -637,9 +654,21 @@ pub(super) struct CurrentDepGraph {\n     nodes: IndexVec<DepNodeIndex, DepNode>,\n     edges: IndexVec<DepNodeIndex, Vec<DepNodeIndex>>,\n     node_to_node_index: FxHashMap<DepNode, DepNodeIndex>,\n-    anon_id_seed: Fingerprint,\n     task_stack: Vec<OpenTask>,\n     forbidden_edge: Option<EdgeFilter>,\n+\n+    // Anonymous DepNodes are nodes the ID of which we compute from the list of\n+    // their edges. This has the beneficial side-effect that multiple anonymous\n+    // nodes can be coalesced into one without changing the semantics of the\n+    // dependency graph. However, the merging of nodes can lead to a subtle\n+    // problem during red-green marking: The color of an anonymous node from\n+    // the current session might \"shadow\" the color of the node with the same\n+    // ID from the previous session. In order to side-step this problem, we make\n+    // sure that anon-node IDs allocated in different sessions don't overlap.\n+    // This is implemented by mixing a session-key into the ID fingerprint of\n+    // each anon node. The session-key is just a random number generated when\n+    // the DepGraph is created.\n+    anon_id_seed: Fingerprint,\n }\n \n impl CurrentDepGraph {"}, {"sha": "88b619558d90b8bf394e721d8ee5a07aa9768b03", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0454a41bec547b28526cdb511f05372c80cb7277/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0454a41bec547b28526cdb511f05372c80cb7277/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=0454a41bec547b28526cdb511f05372c80cb7277", "patch": "@@ -609,10 +609,19 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n     use ty::maps::keys::Key;\n     use hir::def_id::LOCAL_CRATE;\n \n-    // We should never get into the situation of having to force this from the DepNode.\n-    // Since we cannot reconstruct the query key, we would always end up having to evaluate\n-    // the first caller of this query that *is* reconstructible. This might very well be\n-    // compile_codegen_unit() in which case we'd lose all re-use.\n+    // We must avoid ever having to call force_from_dep_node() for a\n+    // DepNode::CodegenUnit:\n+    // Since we cannot reconstruct the query key of a DepNode::CodegenUnit, we\n+    // would always end up having to evaluate the first caller of the\n+    // `codegen_unit` query that *is* reconstructible. This might very well be\n+    // the `compile_codegen_unit` query, thus re-translating the whole CGU just\n+    // to re-trigger calling the `codegen_unit` query with the right key. At\n+    // that point we would already have re-done all the work we are trying to\n+    // avoid doing in the first place.\n+    // The solution is simple: Just explicitly call the `codegen_unit` query for\n+    // each CGU, right after partitioning. This way `try_mark_green` will always\n+    // hit the cache instead of having to go through `force_from_dep_node`.\n+    // This assertion makes sure, we actually keep applying the solution above.\n     debug_assert!(dep_node.kind != DepKind::CodegenUnit,\n                   \"calling force_from_dep_node() on DepKind::CodegenUnit\");\n \n@@ -666,6 +675,8 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         }\n     };\n \n+    // FIXME(#45015): We should try move this boilerplate code into a macro\n+    //                somehow.\n     match dep_node.kind {\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already\n@@ -695,13 +706,13 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::CodegenUnit |\n         DepKind::CompileCodegenUnit |\n \n-        // This one is just odd\n+        // These are just odd\n         DepKind::Null |\n         DepKind::WorkProduct => {\n             bug!(\"force_from_dep_node() - Encountered {:?}\", dep_node.kind)\n         }\n \n-        // These is not a queries\n+        // These are not queries\n         DepKind::CoherenceCheckTrait |\n         DepKind::ItemVarianceConstraints => {\n             return false"}]}