{"sha": "be0e381ab46528f9b2886f15f6d713f5ebcee6f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMGUzODFhYjQ2NTI4ZjliMjg4NmYxNWY2ZDcxM2Y1ZWJjZWU2ZjA=", "commit": {"author": {"name": "n-salim", "email": "53019816+n-salim@users.noreply.github.com", "date": "2019-10-31T16:10:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-31T16:10:42Z"}, "message": "Merge pull request #42 from Wind-River/master_003\n\nvxWorks: remove all code related to UNIX socket as it is not supporte\u2026", "tree": {"sha": "d3a19d17fe91369abd6c7d47a4f22fd29362003e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3a19d17fe91369abd6c7d47a4f22fd29362003e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be0e381ab46528f9b2886f15f6d713f5ebcee6f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJduweCCRBK7hj4Ov3rIwAAdHIIAJsaPRHFkRB5GnHuIEdt4zsi\np+P7H/WsoKKfk8uoJUeJL6VLV5afdwNS7apMXENm7z/TiUqxQiuddnZDUQOKGaoa\ni0WjGpqneXXSP7zBMoIUIYy6UMF2bnuo27+RBZ2Rn88BePZmeQM+27o2CecHqXuj\nUmZO5kq/3BUzTGKKa3m9s8yxwjDXK1uxDzVQ0JI12hypNlB1dt6KQ20wvp03aJuV\nb/rznzThMTVU4Sl5/on2aRb2yyQrwPQveoHHqpkyGkfM9h2fdvIpbGNxHfDsgT1a\nKblnBvKuskvnMLxkFsJDTFn6Cf1IRW48MXhcN+f8awZOdv0Ie3Id3ndsHPI8cNs=\n=Ybls\n-----END PGP SIGNATURE-----\n", "payload": "tree d3a19d17fe91369abd6c7d47a4f22fd29362003e\nparent caa1f8d7b3b021c86a70ff62d23a07d97acff4c4\nparent 8995974e7031ccb14facd2aa8986619db2405912\nauthor n-salim <53019816+n-salim@users.noreply.github.com> 1572538242 -0700\ncommitter GitHub <noreply@github.com> 1572538242 -0700\n\nMerge pull request #42 from Wind-River/master_003\n\nvxWorks: remove all code related to UNIX socket as it is not supporte\u2026"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be0e381ab46528f9b2886f15f6d713f5ebcee6f0", "html_url": "https://github.com/rust-lang/rust/commit/be0e381ab46528f9b2886f15f6d713f5ebcee6f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be0e381ab46528f9b2886f15f6d713f5ebcee6f0/comments", "author": {"login": "n-salim", "id": 53019816, "node_id": "MDQ6VXNlcjUzMDE5ODE2", "avatar_url": "https://avatars.githubusercontent.com/u/53019816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/n-salim", "html_url": "https://github.com/n-salim", "followers_url": "https://api.github.com/users/n-salim/followers", "following_url": "https://api.github.com/users/n-salim/following{/other_user}", "gists_url": "https://api.github.com/users/n-salim/gists{/gist_id}", "starred_url": "https://api.github.com/users/n-salim/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/n-salim/subscriptions", "organizations_url": "https://api.github.com/users/n-salim/orgs", "repos_url": "https://api.github.com/users/n-salim/repos", "events_url": "https://api.github.com/users/n-salim/events{/privacy}", "received_events_url": "https://api.github.com/users/n-salim/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caa1f8d7b3b021c86a70ff62d23a07d97acff4c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/caa1f8d7b3b021c86a70ff62d23a07d97acff4c4", "html_url": "https://github.com/rust-lang/rust/commit/caa1f8d7b3b021c86a70ff62d23a07d97acff4c4"}, {"sha": "8995974e7031ccb14facd2aa8986619db2405912", "url": "https://api.github.com/repos/rust-lang/rust/commits/8995974e7031ccb14facd2aa8986619db2405912", "html_url": "https://github.com/rust-lang/rust/commit/8995974e7031ccb14facd2aa8986619db2405912"}], "stats": {"total": 1888, "additions": 60, "deletions": 1828}, "files": [{"sha": "df6255a3e9e03306cedd55ff9d636e663b4d76e7", "filename": "src/libstd/sys/vxworks/ext/io.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/be0e381ab46528f9b2886f15f6d713f5ebcee6f0/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0e381ab46528f9b2886f15f6d713f5ebcee6f0/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs?ref=be0e381ab46528f9b2886f15f6d713f5ebcee6f0", "patch": "@@ -6,7 +6,8 @@ use crate::fs;\n use crate::os::raw;\n use crate::sys;\n use crate::io;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+use crate::net;\n \n /// Raw file descriptors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -110,3 +111,61 @@ impl<'a> AsRawFd for io::StdoutLock<'a> {\n impl<'a> AsRawFd for io::StderrLock<'a> {\n     fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::UdpSocket {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::UdpSocket {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}"}, {"sha": "d0f467b303ff93615a0dfecf78fd816093e7bb69", "filename": "src/libstd/sys/vxworks/ext/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0e381ab46528f9b2886f15f6d713f5ebcee6f0/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0e381ab46528f9b2886f15f6d713f5ebcee6f0/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs?ref=be0e381ab46528f9b2886f15f6d713f5ebcee6f0", "patch": "@@ -1,4 +1,3 @@\n-// Uhhh\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n@@ -7,7 +6,6 @@ pub mod ffi;\n pub mod fs;\n pub mod raw;\n pub mod process;\n-pub mod net;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {"}, {"sha": "3f0a7e9e843199d9999bab826edce6e00a2da9a1", "filename": "src/libstd/sys/vxworks/ext/net.rs", "status": "removed", "additions": 0, "deletions": 1825, "changes": 1825, "blob_url": "https://github.com/rust-lang/rust/blob/caa1f8d7b3b021c86a70ff62d23a07d97acff4c4/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa1f8d7b3b021c86a70ff62d23a07d97acff4c4/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs?ref=caa1f8d7b3b021c86a70ff62d23a07d97acff4c4", "patch": "@@ -1,1825 +0,0 @@\n-#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-\n-//! Unix-specific networking functionality\n-\n-#[cfg(unix)]\n-use libc;\n-\n-use crate::ascii;\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n-use crate::mem;\n-use crate::net::{self, Shutdown};\n-use crate::os::unix::ffi::OsStrExt;\n-use crate::os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-use crate::path::Path;\n-use crate::time::Duration;\n-use crate::sys::{self, cvt};\n-use crate::sys::net::Socket;\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n-\n-const MSG_NOSIGNAL: libc::c_int = 0x0;\n-\n-fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n-    // Work with an actual instance of the type since using a null pointer is UB\n-    let base = addr as *const _ as usize;\n-    let path = &addr.sun_path as *const _ as usize;\n-    path - base\n-}\n-\n-unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n-    let mut addr: libc::sockaddr_un = mem::zeroed();\n-    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-\n-    let bytes = path.as_os_str().as_bytes();\n-\n-    if bytes.contains(&0) {\n-        return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                  \"paths may not contain interior null bytes\"));\n-    }\n-\n-    if bytes.len() >= addr.sun_path.len() {\n-        return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                  \"path must be shorter than SUN_LEN\"));\n-    }\n-    for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n-        *dst = *src as libc::c_char;\n-    }\n-    // null byte for pathname addresses is already there because we zeroed the\n-    // struct\n-\n-    let mut len = sun_path_offset(&addr) + bytes.len();\n-    match bytes.get(0) {\n-        Some(&0) | None => {}\n-        Some(_) => len += 1,\n-    }\n-    Ok((addr, len as libc::socklen_t))\n-}\n-\n-enum AddressKind<'a> {\n-    Unnamed,\n-    Pathname(&'a Path),\n-    Abstract(&'a [u8]),\n-}\n-\n-/// An address associated with a Unix socket.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::os::unix::net::UnixListener;\n-///\n-/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n-///     Ok(sock) => sock,\n-///     Err(e) => {\n-///         println!(\"Couldn't bind: {:?}\", e);\n-///         return\n-///     }\n-/// };\n-/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct SocketAddr {\n-    addr: libc::sockaddr_un,\n-    len: libc::socklen_t,\n-}\n-\n-impl SocketAddr {\n-    fn new<F>(f: F) -> io::Result<SocketAddr>\n-        where F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int\n-    {\n-        unsafe {\n-            let mut addr: libc::sockaddr_un = mem::zeroed();\n-            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n-            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n-            SocketAddr::from_parts(addr, len)\n-        }\n-    }\n-\n-    fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t) -> io::Result<SocketAddr> {\n-        if len == 0 {\n-            // When there is a datagram from unnamed unix socket\n-            // linux returns zero bytes of address\n-            len = sun_path_offset(&addr) as libc::socklen_t;  // i.e., zero-length address\n-        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"file descriptor did not correspond to a Unix socket\"));\n-        }\n-\n-        Ok(SocketAddr {\n-            addr,\n-            len,\n-        })\n-    }\n-\n-    /// Returns `true` if the address is unnamed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// A named address:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), false);\n-    /// ```\n-    ///\n-    /// An unnamed address:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), true);\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn is_unnamed(&self) -> bool {\n-        if let AddressKind::Unnamed = self.address() {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Returns the contents of this address if it is a `pathname` address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// With a pathname:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    /// use std::path::Path;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n-    /// ```\n-    ///\n-    /// Without a pathname:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), None);\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        if let AddressKind::Pathname(path) = self.address() {\n-            Some(path)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn address<'a>(&'a self) -> AddressKind<'a> {\n-        let len = self.len as usize - sun_path_offset(&self.addr);\n-        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n-\n-        if self.addr.sun_path[0] == 0 {\n-            AddressKind::Abstract(&path[1..len])\n-        } else {\n-            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.address() {\n-            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n-            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n-            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n-        }\n-    }\n-}\n-\n-struct AsciiEscaped<'a>(&'a [u8]);\n-\n-impl<'a> fmt::Display for AsciiEscaped<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"\\\"\")?;\n-        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n-            write!(fmt, \"{}\", byte as char)?;\n-        }\n-        write!(fmt, \"\\\"\")\n-    }\n-}\n-\n-/// A Unix stream socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixStream;\n-/// use std::io::prelude::*;\n-///\n-/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n-/// stream.write_all(b\"hello world\").unwrap();\n-/// let mut response = String::new();\n-/// stream.read_to_string(&mut response).unwrap();\n-/// println!(\"{}\", response);\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixStream(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixStream\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixStream {\n-    /// Connects to the socket named by `path`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-        fn inner(path: &Path) -> io::Result<UnixStream> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n-                Ok(UnixStream(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixStream`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let (sock1, sock2) = match UnixStream::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-        Ok((UnixStream(i1), UnixStream(i2)))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixStream` is a reference to the same stream that this\n-    /// object references. Both handles will read and write the same stream of\n-    /// data, and options set on one stream will be propagated to the other\n-    /// stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.duplicate().map(UnixStream)\n-    }\n-\n-    /// Returns the socket address of the local half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Returns the socket address of the remote half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n-    /// passed to this method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::net::UdpSocket;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n-    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// if let Ok(Some(err)) = socket.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shuts down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Read for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        io::Read::read(&mut &*self, buf)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        io::Read::read_vectored(&mut &*self, bufs)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Write for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        io::Write::write(&mut &*self, buf)\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        io::Write::write_vectored(&mut &*self, bufs)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        io::Write::flush(&mut &*self)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::UdpSocket {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::UdpSocket {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-\n-/// A structure representing a Unix domain socket server.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// // accept connections and process them, spawning a new thread for each one\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             /* connection succeeded */\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             /* connection failed */\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixListener(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixListener\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixListener {\n-    /// Creates a new `UnixListener` bound to the specified socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n-        fn inner(path: &Path) -> io::Result<UnixListener> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n-                cvt(libc::listen(*inner.as_inner(), 128))?;\n-\n-                Ok(UnixListener(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Accepts a new incoming connection to this listener.\n-    ///\n-    /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corresponding [`UnixStream`] and\n-    /// the remote peer's address will be returned.\n-    ///\n-    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// match listener.accept() {\n-    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n-    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n-        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n-        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n-        let addr = SocketAddr::from_parts(storage, len)?;\n-        Ok((UnixStream(sock), addr))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.duplicate().map(UnixListener)\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    ///\n-    /// if let Ok(Some(err)) = listener.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Returns an iterator over incoming connections.\n-    ///\n-    /// The iterator will never return [`None`] and will also not yield the\n-    /// peer's [`SocketAddr`] structure.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`SocketAddr`]: struct.SocketAddr.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::thread;\n-    /// use std::os::unix::net::{UnixStream, UnixListener};\n-    ///\n-    /// fn handle_client(stream: UnixStream) {\n-    ///     // ...\n-    /// }\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// for stream in listener.incoming() {\n-    ///     match stream {\n-    ///         Ok(stream) => {\n-    ///             thread::spawn(|| handle_client(stream));\n-    ///         }\n-    ///         Err(err) => {\n-    ///             break;\n-    ///         }\n-    ///     }\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n-        Incoming { listener: self }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> IntoIterator for &'a UnixListener {\n-    type Item = io::Result<UnixStream>;\n-    type IntoIter = Incoming<'a>;\n-\n-    fn into_iter(self) -> Incoming<'a> {\n-        self.incoming()\n-    }\n-}\n-\n-/// An iterator over incoming connections to a [`UnixListener`].\n-///\n-/// It will never return [`None`].\n-///\n-/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-/// [`UnixListener`]: struct.UnixListener.html\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct Incoming<'a> {\n-    listener: &'a UnixListener,\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> Iterator for Incoming<'a> {\n-    type Item = io::Result<UnixStream>;\n-\n-    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n-        Some(self.listener.accept().map(|s| s.0))\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::max_value(), None)\n-    }\n-}\n-\n-/// A Unix datagram socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixDatagram;\n-///\n-/// let socket = UnixDatagram::bind(\"/path/to/my/socket\").unwrap();\n-/// socket.send_to(b\"hello world\", \"/path/to/other/socket\").unwrap();\n-/// let mut buf = [0; 100];\n-/// let (count, address) = socket.recv_from(&mut buf).unwrap();\n-/// println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixDatagram(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixDatagram {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixDatagram\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixDatagram {\n-    /// Creates a Unix datagram socket bound to the given path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't bind: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n-        fn inner(path: &Path) -> io::Result<UnixDatagram> {\n-            unsafe {\n-                let socket = UnixDatagram::unbound()?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len as _))?;\n-\n-                Ok(socket)\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Creates a Unix Datagram socket which is not bound to any address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = match UnixDatagram::unbound() {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't unbound: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn unbound() -> io::Result<UnixDatagram> {\n-        let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n-        Ok(UnixDatagram(inner))\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixDatagrams`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let (sock1, sock2) = match UnixDatagram::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't unbound: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n-        Ok((UnixDatagram(i1), UnixDatagram(i2)))\n-    }\n-\n-    /// Connects the socket to the specified address.\n-    ///\n-    /// The [`send`] method may be used to send data to the specified address.\n-    /// [`recv`] and [`recv_from`] will only receive data from that address.\n-    ///\n-    /// [`send`]: #method.send\n-    /// [`recv`]: #method.recv\n-    /// [`recv_from`]: #method.recv_from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// match sock.connect(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n-        fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n-            unsafe {\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::connect(*d.0.as_inner(), &addr as *const _ as *const _, len))?;\n-\n-                Ok(())\n-            }\n-        }\n-        inner(self, path.as_ref())\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixDatagram` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one side will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n-        self.0.duplicate().map(UnixDatagram)\n-    }\n-\n-    /// Returns the address of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = sock.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Returns the address of this socket's peer.\n-    ///\n-    /// The [`connect`] method will connect the socket to a peer.\n-    ///\n-    /// [`connect`]: #method.connect\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.connect(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Receives data from the socket.\n-    ///\n-    /// On success, returns the number of bytes read and the address from\n-    /// whence the data came.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// let mut buf = vec![0; 10];\n-    /// match sock.recv_from(buf.as_mut_slice()) {\n-    ///     Ok((size, sender)) => println!(\"received {} bytes from {:?}\", size, sender),\n-    ///     Err(e) => println!(\"recv_from function failed: {:?}\", e),\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        let mut count = 0;\n-        let addr = SocketAddr::new(|addr, len| {\n-            unsafe {\n-                count = libc::recvfrom(*self.0.as_inner(),\n-                                       buf.as_mut_ptr() as *mut _,\n-                                       buf.len(),\n-                                       0,\n-                                       addr,\n-                                       len);\n-                if count > 0 {\n-                    1\n-                } else if count == 0 {\n-                    0\n-                } else {\n-                    -1\n-                }\n-            }\n-        })?;\n-\n-        Ok((count as usize, addr))\n-    }\n-\n-    /// Receives data from the socket.\n-    ///\n-    /// On success, returns the number of bytes read.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n-    /// let mut buf = vec![0; 10];\n-    /// sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    /// Sends data on the socket to the specified address.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n-        fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n-            unsafe {\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                let count = cvt(libc::sendto(*d.0.as_inner(),\n-                                             buf.as_ptr() as *const _,\n-                                             buf.len(),\n-                                             MSG_NOSIGNAL,\n-                                             &addr as *const _ as *const _,\n-                                             len))?;\n-                Ok(count as usize)\n-            }\n-        }\n-        inner(self, buf, path.as_ref())\n-    }\n-\n-    /// Sends data on the socket to the socket's peer.\n-    ///\n-    /// The peer address may be set by the `connect` method, and this method\n-    /// will return an error if the socket has not already been connected.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n-    /// sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will\n-    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]\n-    /// is passed to this method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`recv`]: #method.recv\n-    /// [`recv_from`]: #method.recv_from\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will\n-    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`send`]: #method.send\n-    /// [`send_to`]: #method.send_to\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///     .expect(\"set_write_timeout function failed\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n-    /// assert_eq!(sock.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///     .expect(\"set_write_timeout function failed\");\n-    /// assert_eq!(sock.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// if let Ok(Some(err)) = sock.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shut down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixDatagram {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixDatagram {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n-        UnixDatagram(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixDatagram {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod test {\n-    use crate::thread;\n-    use crate::io::{self, ErrorKind};\n-    use crate::io::prelude::*;\n-    use crate::time::Duration;\n-    use crate::sys_common::io::test::tmpdir;\n-\n-    use super::*;\n-\n-    macro_rules! or_panic {\n-        ($e:expr) => {\n-            match $e {\n-                Ok(e) => e,\n-                Err(e) => panic!(\"{}\", e),\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn basic() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-        let msg1 = b\"hello\";\n-        let msg2 = b\"world!\";\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-        let thread = thread::spawn(move || {\n-            let mut stream = or_panic!(listener.accept()).0;\n-            let mut buf = [0; 5];\n-            or_panic!(stream.read(&mut buf));\n-            assert_eq!(&msg1[..], &buf[..]);\n-            or_panic!(stream.write_all(msg2));\n-        });\n-\n-        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-        assert_eq!(Some(&*socket_path),\n-                   stream.peer_addr().unwrap().as_pathname());\n-        or_panic!(stream.write_all(msg1));\n-        let mut buf = vec![];\n-        or_panic!(stream.read_to_end(&mut buf));\n-        assert_eq!(&msg2[..], &buf[..]);\n-        drop(stream);\n-\n-        thread.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn vectored() {\n-        let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n-\n-        let len = or_panic!(s1.write_vectored(\n-            &[IoSlice::new(b\"hello\"), IoSlice::new(b\" \"), IoSlice::new(b\"world!\")],\n-        ));\n-        assert_eq!(len, 12);\n-\n-        let mut buf1 = [0; 6];\n-        let mut buf2 = [0; 7];\n-        let len = or_panic!(s2.read_vectored(\n-            &mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],\n-        ));\n-        assert_eq!(len, 12);\n-        assert_eq!(&buf1, b\"hello \");\n-        assert_eq!(&buf2, b\"world!\\0\");\n-    }\n-\n-    #[test]\n-    fn pair() {\n-        let msg1 = b\"hello\";\n-        let msg2 = b\"world!\";\n-\n-        let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n-        let thread = thread::spawn(move || {\n-            // s1 must be moved in or the test will hang!\n-            let mut buf = [0; 5];\n-            or_panic!(s1.read(&mut buf));\n-            assert_eq!(&msg1[..], &buf[..]);\n-            or_panic!(s1.write_all(msg2));\n-        });\n-\n-        or_panic!(s2.write_all(msg1));\n-        let mut buf = vec![];\n-        or_panic!(s2.read_to_end(&mut buf));\n-        assert_eq!(&msg2[..], &buf[..]);\n-        drop(s2);\n-\n-        thread.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn try_clone() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-        let msg1 = b\"hello\";\n-        let msg2 = b\"world\";\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-        let thread = thread::spawn(move || {\n-            let mut stream = or_panic!(listener.accept()).0;\n-            or_panic!(stream.write_all(msg1));\n-            or_panic!(stream.write_all(msg2));\n-        });\n-\n-        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-        let mut stream2 = or_panic!(stream.try_clone());\n-\n-        let mut buf = [0; 5];\n-        or_panic!(stream.read(&mut buf));\n-        assert_eq!(&msg1[..], &buf[..]);\n-        or_panic!(stream2.read(&mut buf));\n-        assert_eq!(&msg2[..], &buf[..]);\n-\n-        thread.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn iter() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-        let thread = thread::spawn(move || {\n-            for stream in listener.incoming().take(2) {\n-                let mut stream = or_panic!(stream);\n-                let mut buf = [0];\n-                or_panic!(stream.read(&mut buf));\n-            }\n-        });\n-\n-        for _ in 0..2 {\n-            let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-            or_panic!(stream.write_all(&[0]));\n-        }\n-\n-        thread.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn long_path() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path()\n-                             .join(\"asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfa\\\n-                                    sasdfasdfasdasdfasdfasdfadfasdfasdfasdfasdfasdf\");\n-        match UnixStream::connect(&socket_path) {\n-            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n-            Err(e) => panic!(\"unexpected error {}\", e),\n-            Ok(_) => panic!(\"unexpected success\"),\n-        }\n-\n-        match UnixListener::bind(&socket_path) {\n-            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n-            Err(e) => panic!(\"unexpected error {}\", e),\n-            Ok(_) => panic!(\"unexpected success\"),\n-        }\n-\n-        match UnixDatagram::bind(&socket_path) {\n-            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n-            Err(e) => panic!(\"unexpected error {}\", e),\n-            Ok(_) => panic!(\"unexpected success\"),\n-        }\n-    }\n-\n-    #[test]\n-    fn timeouts() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let _listener = or_panic!(UnixListener::bind(&socket_path));\n-\n-        let stream = or_panic!(UnixStream::connect(&socket_path));\n-        let dur = Duration::new(15410, 0);\n-\n-        assert_eq!(None, or_panic!(stream.read_timeout()));\n-\n-        or_panic!(stream.set_read_timeout(Some(dur)));\n-        assert_eq!(Some(dur), or_panic!(stream.read_timeout()));\n-\n-        assert_eq!(None, or_panic!(stream.write_timeout()));\n-\n-        or_panic!(stream.set_write_timeout(Some(dur)));\n-        assert_eq!(Some(dur), or_panic!(stream.write_timeout()));\n-\n-        or_panic!(stream.set_read_timeout(None));\n-        assert_eq!(None, or_panic!(stream.read_timeout()));\n-\n-        or_panic!(stream.set_write_timeout(None));\n-        assert_eq!(None, or_panic!(stream.write_timeout()));\n-    }\n-\n-    #[test]\n-    fn test_read_timeout() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let _listener = or_panic!(UnixListener::bind(&socket_path));\n-\n-        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-        or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-        let mut buf = [0; 10];\n-        let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                \"unexpected_error: {:?}\", kind);\n-    }\n-\n-    #[test]\n-    fn test_read_with_timeout() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-\n-        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-        or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-        let mut other_end = or_panic!(listener.accept()).0;\n-        or_panic!(other_end.write_all(b\"hello world\"));\n-\n-        let mut buf = [0; 11];\n-        or_panic!(stream.read(&mut buf));\n-        assert_eq!(b\"hello world\", &buf[..]);\n-\n-        let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                \"unexpected_error: {:?}\", kind);\n-    }\n-\n-    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n-    // when passed zero Durations\n-    #[test]\n-    fn test_unix_stream_timeout_zero_duration() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-        let stream = or_panic!(UnixStream::connect(&socket_path));\n-\n-        let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-        let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-        drop(listener);\n-    }\n-\n-    #[test]\n-    fn test_unix_datagram() {\n-        let dir = tmpdir();\n-        let path1 = dir.path().join(\"sock1\");\n-        let path2 = dir.path().join(\"sock2\");\n-\n-        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-        let sock2 = or_panic!(UnixDatagram::bind(&path2));\n-\n-        let msg = b\"hello world\";\n-        or_panic!(sock1.send_to(msg, &path2));\n-        let mut buf = [0; 11];\n-        or_panic!(sock2.recv_from(&mut buf));\n-        assert_eq!(msg, &buf[..]);\n-    }\n-\n-    #[test]\n-    fn test_unnamed_unix_datagram() {\n-        let dir = tmpdir();\n-        let path1 = dir.path().join(\"sock1\");\n-\n-        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-        let sock2 = or_panic!(UnixDatagram::unbound());\n-\n-        let msg = b\"hello world\";\n-        or_panic!(sock2.send_to(msg, &path1));\n-        let mut buf = [0; 11];\n-        let (usize, addr) = or_panic!(sock1.recv_from(&mut buf));\n-        assert_eq!(usize, 11);\n-        assert!(addr.is_unnamed());\n-        assert_eq!(msg, &buf[..]);\n-    }\n-\n-    #[test]\n-    fn test_connect_unix_datagram() {\n-        let dir = tmpdir();\n-        let path1 = dir.path().join(\"sock1\");\n-        let path2 = dir.path().join(\"sock2\");\n-\n-        let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n-        let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n-        let sock = or_panic!(UnixDatagram::unbound());\n-        or_panic!(sock.connect(&path1));\n-\n-        // Check send()\n-        let msg = b\"hello there\";\n-        or_panic!(sock.send(msg));\n-        let mut buf = [0; 11];\n-        let (usize, addr) = or_panic!(bsock1.recv_from(&mut buf));\n-        assert_eq!(usize, 11);\n-        assert!(addr.is_unnamed());\n-        assert_eq!(msg, &buf[..]);\n-\n-        // Changing default socket works too\n-        or_panic!(sock.connect(&path2));\n-        or_panic!(sock.send(msg));\n-        or_panic!(bsock2.recv_from(&mut buf));\n-    }\n-\n-    #[test]\n-    fn test_unix_datagram_recv() {\n-        let dir = tmpdir();\n-        let path1 = dir.path().join(\"sock1\");\n-\n-        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-        let sock2 = or_panic!(UnixDatagram::unbound());\n-        or_panic!(sock2.connect(&path1));\n-\n-        let msg = b\"hello world\";\n-        or_panic!(sock2.send(msg));\n-        let mut buf = [0; 11];\n-        let size = or_panic!(sock1.recv(&mut buf));\n-        assert_eq!(size, 11);\n-        assert_eq!(msg, &buf[..]);\n-    }\n-\n-    #[test]\n-    fn datagram_pair() {\n-        let msg1 = b\"hello\";\n-        let msg2 = b\"world!\";\n-\n-        let (s1, s2) = or_panic!(UnixDatagram::pair());\n-        let thread = thread::spawn(move || {\n-            // s1 must be moved in or the test will hang!\n-            let mut buf = [0; 5];\n-            or_panic!(s1.recv(&mut buf));\n-            assert_eq!(&msg1[..], &buf[..]);\n-            or_panic!(s1.send(msg2));\n-        });\n-\n-        or_panic!(s2.send(msg1));\n-        let mut buf = [0; 6];\n-        or_panic!(s2.recv(&mut buf));\n-        assert_eq!(&msg2[..], &buf[..]);\n-        drop(s2);\n-\n-        thread.join().unwrap();\n-    }\n-\n-    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n-    // when passed zero Durations\n-    #[test]\n-    fn test_unix_datagram_timeout_zero_duration() {\n-        let dir = tmpdir();\n-        let path = dir.path().join(\"sock\");\n-\n-        let datagram = or_panic!(UnixDatagram::bind(&path));\n-\n-        let result = datagram.set_write_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-        let result = datagram.set_read_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-    }\n-\n-    #[test]\n-    fn abstract_namespace_not_allowed() {\n-        assert!(UnixStream::connect(\"\\0asdf\").is_err());\n-    }\n-}"}]}