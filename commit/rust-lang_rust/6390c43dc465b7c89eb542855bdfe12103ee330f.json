{"sha": "6390c43dc465b7c89eb542855bdfe12103ee330f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzOTBjNDNkYzQ2NWI3Yzg5ZWI1NDI4NTViZGZlMTIxMDNlZTMzMGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-13T01:42:58Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-13T01:42:58Z"}, "message": "Revert \"rustc: Remove exterior vectors from resolve\"\n\nThis reverts commit 0ffe8c81c31f00e7a032d88d5397930fefbfc97f.", "tree": {"sha": "e7b6bb3cd136a776a8015de1151c5dde402bf840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7b6bb3cd136a776a8015de1151c5dde402bf840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6390c43dc465b7c89eb542855bdfe12103ee330f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6390c43dc465b7c89eb542855bdfe12103ee330f", "html_url": "https://github.com/rust-lang/rust/commit/6390c43dc465b7c89eb542855bdfe12103ee330f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6390c43dc465b7c89eb542855bdfe12103ee330f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79ee267ef4c6ecca3dd52a294cc8555a99751c11", "url": "https://api.github.com/repos/rust-lang/rust/commits/79ee267ef4c6ecca3dd52a294cc8555a99751c11", "html_url": "https://github.com/rust-lang/rust/commit/79ee267ef4c6ecca3dd52a294cc8555a99751c11"}], "stats": {"total": 55, "additions": 29, "deletions": 26}, "files": [{"sha": "080d9270f6adaf0877110e8d8d59c9a56c657526", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6390c43dc465b7c89eb542855bdfe12103ee330f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6390c43dc465b7c89eb542855bdfe12103ee330f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=6390c43dc465b7c89eb542855bdfe12103ee330f", "patch": "@@ -28,6 +28,7 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import std::str;\n+import std::vec;\n \n export resolve_crate;\n export def_map;\n@@ -97,7 +98,7 @@ type glob_imp_def = tup(def, @ast::view_item);\n type indexed_mod =\n     rec(option::t[ast::_mod] m,\n         mod_index index,\n-        mutable glob_imp_def[] glob_imports,\n+        mutable vec[glob_imp_def] glob_imports,\n         hashmap[str, import_state] glob_imported_names);\n \n \n@@ -113,7 +114,7 @@ type env =\n         ast_map::map ast_map,\n         hashmap[ast::node_id, import_state] imports,\n         hashmap[ast::node_id, @indexed_mod] mod_map,\n-        hashmap[def_id, ident[]] ext_map,\n+        hashmap[def_id, vec[ident]] ext_map,\n         ext_hash ext_cache,\n         session sess);\n \n@@ -133,7 +134,7 @@ fn resolve_crate(session sess, &ast_map::map amap, @ast::crate crate) ->\n              ast_map=amap,\n              imports=new_int_hash[import_state](),\n              mod_map=new_int_hash[@indexed_mod](),\n-             ext_map=new_def_hash[ident[]](),\n+             ext_map=new_def_hash[vec[ident]](),\n              ext_cache=new_ext_hash(),\n              sess=sess);\n     map_crate(e, crate);\n@@ -160,7 +161,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n     e.mod_map.insert(-1,\n                      @rec(m=some(c.node.module),\n                           index=index_mod(c.node.module),\n-                          mutable glob_imports=~[],\n+                          mutable glob_imports=[],\n                           glob_imported_names=new_str_hash[import_state]()));\n     fn index_vi(@env e, &@ast::view_item i, &scopes sc, &vt[scopes] v) {\n         alt (i.node) {\n@@ -178,15 +179,15 @@ fn map_crate(&@env e, &@ast::crate c) {\n                 e.mod_map.insert(i.id,\n                                  @rec(m=some(md),\n                                       index=index_mod(md),\n-                                      mutable glob_imports=~[],\n+                                      mutable glob_imports=[],\n                                       glob_imported_names=s));\n             }\n             case (ast::item_native_mod(?nmd)) {\n                 auto s = new_str_hash[import_state]();\n                 e.mod_map.insert(i.id,\n                                  @rec(m=none[ast::_mod],\n                                       index=index_nmod(nmd),\n-                                      mutable glob_imports=~[],\n+                                      mutable glob_imports=[],\n                                       glob_imported_names=s));\n             }\n             case (_) { }\n@@ -223,7 +224,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n                 auto imp = follow_import(*e, sc, path, vi.span);\n                 if (option::is_some(imp)) {\n                     find_mod(e, sc).glob_imports +=\n-                        ~[tup(option::get(imp), vi)];\n+                        [tup(option::get(imp), vi)];\n                 }\n             }\n             case (_) { }\n@@ -398,8 +399,14 @@ fn resolve_constr(@env e, node_id id, &@ast::constr c, &scopes sc,\n     if (option::is_some(new_def)) {\n         alt (option::get(new_def)) {\n             case (ast::def_fn(?pred_id, ast::pure_fn)) {\n+                // FIXME: Remove this vec->ivec conversion.\n+                let (@ast::constr_arg_general[uint])[] cag_ivec = ~[];\n+                for (@ast::constr_arg_general[uint] cag in c.node.args) {\n+                    cag_ivec += ~[cag];\n+                }\n+\n                 let ty::constr_general[uint] c_ =\n-                    rec(path=c.node.path, args=c.node.args, id=pred_id);\n+                    rec(path=c.node.path, args=cag_ivec, id=pred_id);\n                 let ty::constr_def new_constr = respan(c.span, c_);\n                 add_constr(e, id, new_constr);\n             }\n@@ -877,7 +884,7 @@ fn lookup_in_mod(&env e, &def m, &span sp, &ident name, namespace ns,\n \n         auto cached = e.ext_cache.find(tup(defid, name, ns));\n         if (!option::is_none(cached)) { ret cached; }\n-        auto path = ~[name];\n+        auto path = [name];\n         if (defid._1 != -1) { path = e.ext_map.get(defid) + path; }\n         auto fnd = lookup_external(e, defid._0, path, ns);\n         if (!option::is_none(fnd)) {\n@@ -986,11 +993,11 @@ fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id,\n         }\n \n         auto matches =\n-            ivec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n-                             { info.glob_imports });\n-        if (ivec::len(matches) == 0u) {\n+            vec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n+                            { info.glob_imports });\n+        if (vec::len(matches) == 0u) {\n             ret none[def];\n-        } else if (ivec::len(matches) == 1u) {\n+        } else if (vec::len(matches) == 1u) {\n             ret some[def](matches.(0)._0);\n         } else {\n             for (glob_imp_def match in matches) {\n@@ -1152,13 +1159,9 @@ fn ns_for_def(def d) -> namespace {\n         };\n }\n \n-fn lookup_external(&env e, int cnum, &ident[] ids, namespace ns) ->\n+fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns) ->\n    option::t[def] {\n-    // FIXME: Remove this ivec->vec conversion.\n-    auto ids_vec = [];\n-    for (ident i in ids) { ids_vec += [i]; }\n-\n-    for (def d in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids_vec)) {\n+    for (def d in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids)) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n         if (ns == ns_for_def(d)) { ret some(d); }\n     }\n@@ -1278,13 +1281,13 @@ fn check_arm(@env e, &ast::arm a, &() x, &vt[()] v) {\n         walk_pat(ch, a.pats.(i));\n         // Ensure the bindings introduced in this pattern are the same as in\n         // the first pattern.\n-        if (ivec::len(ch.seen) != ivec::len(seen0)) {\n+        if (vec::len(ch.seen) != vec::len(seen0)) {\n             e.sess.span_err(a.pats.(i).span,\n                             \"inconsistent number of bindings\");\n         } else {\n             for (ident name in ch.seen) {\n-                if (option::is_none(ivec::find(bind str::eq(name, _),\n-                                               seen0))) {\n+                if (option::is_none(vec::find(bind str::eq(name, _),\n+                                              seen0))) {\n                     // Fight the alias checker\n                     auto name_ = name;\n                     e.sess.span_err\n@@ -1345,10 +1348,10 @@ fn check_fn(&env e, &span sp, &ast::_fn f) {\n     ensure_unique_ivec(e, sp, f.decl.inputs, arg_name, \"argument\");\n }\n \n-type checker = @rec(mutable ident[] seen, str kind, session sess);\n+type checker = @rec(mutable vec[ident] seen, str kind, session sess);\n \n fn checker(&env e, str kind) -> checker {\n-    let ident[] seen = ~[];\n+    let vec[ident] seen = [];\n     ret @rec(mutable seen=seen, kind=kind, sess=e.sess);\n }\n \n@@ -1358,12 +1361,12 @@ fn add_name(&checker ch, &span sp, &ident name) {\n             ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + name);\n         }\n     }\n-    ch.seen += ~[name];\n+    vec::push(ch.seen, name);\n }\n \n fn ident_id(&ident i) -> ident { ret i; }\n \n-fn ensure_unique[T](&env e, &span sp, &T[] elts, fn(&T) -> ident  id,\n+fn ensure_unique[T](&env e, &span sp, &vec[T] elts, fn(&T) -> ident  id,\n                     &str kind) {\n     auto ch = checker(e, kind);\n     for (T elt in elts) { add_name(ch, sp, id(elt)); }"}]}