{"sha": "9e7b0ff2e11fba83c5d87cf871e6531d94edb2e5", "node_id": "C_kwDOAAsO6NoAKDllN2IwZmYyZTExZmJhODNjNWQ4N2NmODcxZTY1MzFkOTRlZGIyZTU", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-05-05T15:05:08Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-05-18T09:42:43Z"}, "message": "Add tests for FilePathMapping::to_embeddable_absolute_path().", "tree": {"sha": "174bfa4a53d0cf338d0f9fb956d48ac449ba8a79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/174bfa4a53d0cf338d0f9fb956d48ac449ba8a79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e7b0ff2e11fba83c5d87cf871e6531d94edb2e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e7b0ff2e11fba83c5d87cf871e6531d94edb2e5", "html_url": "https://github.com/rust-lang/rust/commit/9e7b0ff2e11fba83c5d87cf871e6531d94edb2e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e7b0ff2e11fba83c5d87cf871e6531d94edb2e5/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "583880b0ff3a04712e66426d63b7474dc74c2165", "url": "https://api.github.com/repos/rust-lang/rust/commits/583880b0ff3a04712e66426d63b7474dc74c2165", "html_url": "https://github.com/rust-lang/rust/commit/583880b0ff3a04712e66426d63b7474dc74c2165"}], "stats": {"total": 169, "additions": 128, "deletions": 41}, "files": [{"sha": "be827cea8744b6f90f8ce9ffb487160a9d08f391", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 128, "deletions": 41, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b0ff2e11fba83c5d87cf871e6531d94edb2e5/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b0ff2e11fba83c5d87cf871e6531d94edb2e5/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=9e7b0ff2e11fba83c5d87cf871e6531d94edb2e5", "patch": "@@ -313,82 +313,169 @@ impl SourceMapExtension for SourceMap {\n     }\n }\n \n-fn map_path_prefix(mapping: &FilePathMapping, path: &str) -> String {\n+// Takes a unix-style path and returns a platform specific path.\n+fn path(p: &str) -> PathBuf {\n+    path_str(p).into()\n+}\n+\n+// Takes a unix-style path and returns a platform specific path.\n+fn path_str(p: &str) -> String {\n+    #[cfg(not(windows))]\n+    {\n+        return p.into();\n+    }\n+\n+    #[cfg(windows)]\n+    {\n+        let mut path = p.replace('/', \"\\\\\");\n+        if let Some(rest) = path.strip_prefix('\\\\') {\n+            path = [\"X:\\\\\", rest].concat();\n+        }\n+\n+        path\n+    }\n+}\n+\n+fn map_path_prefix(mapping: &FilePathMapping, p: &str) -> String {\n     // It's important that we convert to a string here because that's what\n     // later stages do too (e.g. in the backend), and comparing `Path` values\n     // won't catch some differences at the string level, e.g. \"abc\" and \"abc/\"\n     // compare as equal.\n-    mapping.map_prefix(path.into()).0.to_string_lossy().to_string()\n+    mapping.map_prefix(path(p)).0.to_string_lossy().to_string()\n }\n \n-#[cfg(unix)]\n #[test]\n fn path_prefix_remapping() {\n     // Relative to relative\n     {\n-        let mapping = &FilePathMapping::new(vec![(\"abc/def\".into(), \"foo\".into())]);\n+        let mapping = &FilePathMapping::new(vec![(path(\"abc/def\"), path(\"foo\"))]);\n \n-        assert_eq!(map_path_prefix(mapping, \"abc/def/src/main.rs\"), \"foo/src/main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"abc/def\"), \"foo\");\n+        assert_eq!(map_path_prefix(mapping, \"abc/def/src/main.rs\"), path_str(\"foo/src/main.rs\"));\n+        assert_eq!(map_path_prefix(mapping, \"abc/def\"), path_str(\"foo\"));\n     }\n \n     // Relative to absolute\n     {\n-        let mapping = &FilePathMapping::new(vec![(\"abc/def\".into(), \"/foo\".into())]);\n+        let mapping = &FilePathMapping::new(vec![(path(\"abc/def\"), path(\"/foo\"))]);\n \n-        assert_eq!(map_path_prefix(mapping, \"abc/def/src/main.rs\"), \"/foo/src/main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"abc/def\"), \"/foo\");\n+        assert_eq!(map_path_prefix(mapping, \"abc/def/src/main.rs\"), path_str(\"/foo/src/main.rs\"));\n+        assert_eq!(map_path_prefix(mapping, \"abc/def\"), path_str(\"/foo\"));\n     }\n \n     // Absolute to relative\n     {\n-        let mapping = &FilePathMapping::new(vec![(\"/abc/def\".into(), \"foo\".into())]);\n+        let mapping = &FilePathMapping::new(vec![(path(\"/abc/def\"), path(\"foo\"))]);\n \n-        assert_eq!(map_path_prefix(mapping, \"/abc/def/src/main.rs\"), \"foo/src/main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"/abc/def\"), \"foo\");\n+        assert_eq!(map_path_prefix(mapping, \"/abc/def/src/main.rs\"), path_str(\"foo/src/main.rs\"));\n+        assert_eq!(map_path_prefix(mapping, \"/abc/def\"), path_str(\"foo\"));\n     }\n \n     // Absolute to absolute\n     {\n-        let mapping = &FilePathMapping::new(vec![(\"/abc/def\".into(), \"/foo\".into())]);\n+        let mapping = &FilePathMapping::new(vec![(path(\"/abc/def\"), path(\"/foo\"))]);\n \n-        assert_eq!(map_path_prefix(mapping, \"/abc/def/src/main.rs\"), \"/foo/src/main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"/abc/def\"), \"/foo\");\n+        assert_eq!(map_path_prefix(mapping, \"/abc/def/src/main.rs\"), path_str(\"/foo/src/main.rs\"));\n+        assert_eq!(map_path_prefix(mapping, \"/abc/def\"), path_str(\"/foo\"));\n     }\n }\n \n-#[cfg(windows)]\n #[test]\n-fn path_prefix_remapping_from_relative2() {\n-    // Relative to relative\n-    {\n-        let mapping = &FilePathMapping::new(vec![(\"abc\\\\def\".into(), \"foo\".into())]);\n+fn path_prefix_remapping_expand_to_absolute() {\n+    // \"virtual\" working directory is relative path\n+    let mapping =\n+        &FilePathMapping::new(vec![(path(\"/foo\"), path(\"FOO\")), (path(\"/bar\"), path(\"BAR\"))]);\n+    let working_directory = path(\"/foo\");\n+    let working_directory = RealFileName::Remapped {\n+        local_path: Some(working_directory.clone()),\n+        virtual_name: mapping.map_prefix(working_directory).0,\n+    };\n+\n+    assert_eq!(working_directory.remapped_path_if_available(), path(\"FOO\"));\n+\n+    // Unmapped absolute path\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"/foo/src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"FOO/src/main.rs\") }\n+    );\n \n-        assert_eq!(map_path_prefix(mapping, \"abc\\\\def\\\\src\\\\main.rs\"), \"foo\\\\src\\\\main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"abc\\\\def\"), \"foo\");\n-    }\n+    // Unmapped absolute path with unrelated working directory\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"/bar/src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"BAR/src/main.rs\") }\n+    );\n \n-    // Relative to absolute\n-    {\n-        let mapping = &FilePathMapping::new(vec![(\"abc\\\\def\".into(), \"X:\\\\foo\".into())]);\n+    // Unmapped absolute path that does not match any prefix\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"/quux/src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::LocalPath(path(\"/quux/src/main.rs\")),\n+    );\n \n-        assert_eq!(map_path_prefix(mapping, \"abc\\\\def\\\\src\\\\main.rs\"), \"X:\\\\foo\\\\src\\\\main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"abc\\\\def\"), \"X:\\\\foo\");\n-    }\n+    // Unmapped relative path\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"FOO/src/main.rs\") }\n+    );\n \n-    // Absolute to relative\n-    {\n-        let mapping = &FilePathMapping::new(vec![(\"X:\\\\abc\\\\def\".into(), \"foo\".into())]);\n+    // Unmapped relative path with `./`\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"./src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"FOO/src/main.rs\") }\n+    );\n \n-        assert_eq!(map_path_prefix(mapping, \"X:\\\\abc\\\\def\\\\src\\\\main.rs\"), \"foo\\\\src\\\\main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"X:\\\\abc\\\\def\"), \"foo\");\n-    }\n+    // Unmapped relative path that does not match any prefix\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"quux/src/main.rs\")),\n+            &RealFileName::LocalPath(path(\"/abc\")),\n+        ),\n+        RealFileName::LocalPath(path(\"/abc/quux/src/main.rs\")),\n+    );\n \n-    // Absolute to absolute\n-    {\n-        let mapping = &FilePathMapping::new(vec![(\"X:\\\\abc\\\\def\".into(), \"X:\\\\foo\".into())]);\n+    // Already remapped absolute path\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::Remapped {\n+                local_path: Some(path(\"/foo/src/main.rs\")),\n+                virtual_name: path(\"FOO/src/main.rs\"),\n+            },\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"FOO/src/main.rs\") }\n+    );\n \n-        assert_eq!(map_path_prefix(mapping, \"X:\\\\abc\\\\def\\\\src\\\\main.rs\"), \"X:\\\\foo\\\\src\\\\main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"X:\\\\abc\\\\def\"), \"X:\\\\foo\");\n-    }\n+    // Already remapped absolute path, with unrelated working directory\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::Remapped {\n+                local_path: Some(path(\"/bar/src/main.rs\")),\n+                virtual_name: path(\"BAR/src/main.rs\"),\n+            },\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"BAR/src/main.rs\") }\n+    );\n+\n+    // Already remapped relative path\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::Remapped { local_path: None, virtual_name: path(\"XYZ/src/main.rs\") },\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"XYZ/src/main.rs\") }\n+    );\n }"}]}