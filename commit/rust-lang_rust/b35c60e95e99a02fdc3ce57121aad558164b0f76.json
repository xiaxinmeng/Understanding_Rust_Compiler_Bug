{"sha": "b35c60e95e99a02fdc3ce57121aad558164b0f76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNWM2MGU5NWU5OWEwMmZkYzNjZTU3MTIxYWFkNTU4MTY0YjBmNzY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-06-04T00:18:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-04T00:18:03Z"}, "message": "Rollup merge of #51299 - faern:const-int-ops, r=oli-obk\n\nconst fn integer operations\n\nA follow up to #51171\nFixes #51267\n\nMakes a lot of the integer methods (`swap_bytes`, `count_ones` etc) `const fn`s. See #51267 for a discussion about why this is wanted and the solution used.", "tree": {"sha": "1b0849d28039a5fb9b2a62c50261030c9a8a6253", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b0849d28039a5fb9b2a62c50261030c9a8a6253"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b35c60e95e99a02fdc3ce57121aad558164b0f76", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbFIU7CRBK7hj4Ov3rIwAAdHIIADYYy9U+Inn46Jqozlhfk8h0\nxv3nz07XbgilH4pETENK8Q/usqAIZ/f9+hzaGIpVSinz6+uhDY7Sw8ClQ9NF7Yi1\nW5jyfU1uKT8NBzMYBl7GOB1xE2kvmR5iVYE7vJqHjVPvNIyzKsTbW6aUNXC+1l/o\n88GkSUUT/AF0iLNvq2jkQFxyxhJsHEYUwWcgAYkJv7ANaXxBopV+NN0VB7e0pYAJ\nqOIFUra65DZvyMyBuykoD7QEaOMh7kBRkU+f2E53JSLkLaonJmoCLZmXMDpbGkap\nbMrfOyqOWYtE7ISeNTXnlz0tBEpP6+xG7IlQ/LWC6A2lZCvwrYTVDRd+FaFvnMk=\n=wxBM\n-----END PGP SIGNATURE-----\n", "payload": "tree 1b0849d28039a5fb9b2a62c50261030c9a8a6253\nparent df137907560e43b21bb598116ccd1adb073b2b4c\nparent 8b5f962762b500a1428e9d6937d964922a233fa1\nauthor Mark Simulacrum <mark.simulacrum@gmail.com> 1528071483 -0600\ncommitter GitHub <noreply@github.com> 1528071483 -0600\n\nRollup merge of #51299 - faern:const-int-ops, r=oli-obk\n\nconst fn integer operations\n\nA follow up to #51171\nFixes #51267\n\nMakes a lot of the integer methods (`swap_bytes`, `count_ones` etc) `const fn`s. See #51267 for a discussion about why this is wanted and the solution used.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b35c60e95e99a02fdc3ce57121aad558164b0f76", "html_url": "https://github.com/rust-lang/rust/commit/b35c60e95e99a02fdc3ce57121aad558164b0f76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b35c60e95e99a02fdc3ce57121aad558164b0f76/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df137907560e43b21bb598116ccd1adb073b2b4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/df137907560e43b21bb598116ccd1adb073b2b4c", "html_url": "https://github.com/rust-lang/rust/commit/df137907560e43b21bb598116ccd1adb073b2b4c"}, {"sha": "8b5f962762b500a1428e9d6937d964922a233fa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b5f962762b500a1428e9d6937d964922a233fa1", "html_url": "https://github.com/rust-lang/rust/commit/8b5f962762b500a1428e9d6937d964922a233fa1"}], "stats": {"total": 327, "additions": 313, "deletions": 14}, "files": [{"sha": "b27552651a08743cc7e8d12aea8c530d038bec4c", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b35c60e95e99a02fdc3ce57121aad558164b0f76/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35c60e95e99a02fdc3ce57121aad558164b0f76/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b35c60e95e99a02fdc3ce57121aad558164b0f76", "patch": "@@ -81,6 +81,7 @@\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n+#![feature(const_int_ops)]\n #![feature(core_float)]\n #![feature(custom_attribute)]\n #![feature(doc_cfg)]"}, {"sha": "26dd08b10b9b8778cb64b810a33022589eef60d9", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 280, "deletions": 14, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/b35c60e95e99a02fdc3ce57121aad558164b0f76/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35c60e95e99a02fdc3ce57121aad558164b0f76/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b35c60e95e99a02fdc3ce57121aad558164b0f76", "patch": "@@ -267,6 +267,16 @@ $EndFeature, \"\n ```\n \"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n         }\n@@ -282,6 +292,18 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentatio\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n@@ -302,6 +324,18 @@ assert_eq!(n.leading_zeros(), 0);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn leading_zeros(self) -> u32 {\n+                (self as $UnsignedT).leading_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn leading_zeros(self) -> u32 {\n                 (self as $UnsignedT).leading_zeros()\n@@ -322,6 +356,18 @@ assert_eq!(n.trailing_zeros(), 2);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn trailing_zeros(self) -> u32 {\n+                (self as $UnsignedT).trailing_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn trailing_zeros(self) -> u32 {\n                 (self as $UnsignedT).trailing_zeros()\n@@ -396,6 +442,16 @@ $EndFeature, \"\n         /// assert_eq!(m, 21760);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(not(stage0))]\n+        #[rustc_const_unstable(feature = \"const_int_ops\")]\n+        #[inline]\n+        pub const fn swap_bytes(self) -> Self {\n+            (self as $UnsignedT).swap_bytes() as Self\n+        }\n+\n+        /// Dummy docs. See !stage0 documentation.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         #[inline]\n         pub fn swap_bytes(self) -> Self {\n             (self as $UnsignedT).swap_bytes() as Self\n@@ -447,6 +503,25 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn from_be(x: Self) -> Self {\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn from_be(x: Self) -> Self {\n                 if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -473,6 +548,25 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn from_le(x: Self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn from_le(x: Self) -> Self {\n                 if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -499,6 +593,25 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn to_be(self) -> Self { // or not to be?\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn to_be(self) -> Self { // or not to be?\n                 if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -525,6 +638,25 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn to_le(self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn to_le(self) -> Self {\n                 if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n@@ -1943,6 +2075,19 @@ impl isize {\n     int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\" }\n }\n \n+// Emits the correct `cttz` call, depending on the size of the type.\n+macro_rules! uint_cttz_call {\n+    // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n+    // emits two conditional moves on x86_64. By promoting the value to\n+    // u16 and setting bit 8, we get better code without any conditional\n+    // operations.\n+    // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n+    // pending, remove this workaround once LLVM generates better code\n+    // for cttz8.\n+    ($value:expr, 8) => { intrinsics::cttz($value as u16 | 0x100) };\n+    ($value:expr, $_BITS:expr) => { intrinsics::cttz($value) }\n+}\n+\n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr) => {\n@@ -2020,6 +2165,18 @@ Basic usage:\n assert_eq!(n.count_ones(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn count_ones(self) -> u32 {\n+                unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn count_ones(self) -> u32 {\n                 unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n@@ -2037,6 +2194,18 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n@@ -2056,6 +2225,18 @@ Basic usage:\n assert_eq!(n.leading_zeros(), 2);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn leading_zeros(self) -> u32 {\n+                unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn leading_zeros(self) -> u32 {\n                 unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n@@ -2076,22 +2257,21 @@ Basic usage:\n assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn trailing_zeros(self) -> u32 {\n+                unsafe { uint_cttz_call!(self, $BITS) as u32 }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn trailing_zeros(self) -> u32 {\n-                // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n-                // emits two conditional moves on x86_64. By promoting the value to\n-                // u16 and setting bit 8, we get better code without any conditional\n-                // operations.\n-                // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n-                // pending, remove this workaround once LLVM generates better code\n-                // for cttz8.\n-                unsafe {\n-                    if $BITS == 8 {\n-                        intrinsics::cttz(self as u16 | 0x100) as u32\n-                    } else {\n-                        intrinsics::cttz(self) as u32\n-                    }\n-                }\n+                unsafe { uint_cttz_call!(self, $BITS) as u32 }\n             }\n         }\n \n@@ -2167,6 +2347,16 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n         /// assert_eq!(m, 21760);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(not(stage0))]\n+        #[rustc_const_unstable(feature = \"const_int_ops\")]\n+        #[inline]\n+        pub const fn swap_bytes(self) -> Self {\n+            unsafe { intrinsics::bswap(self as $ActualT) as Self }\n+        }\n+\n+        /// Dummy docs. See !stage0 documentation.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         #[inline]\n         pub fn swap_bytes(self) -> Self {\n             unsafe { intrinsics::bswap(self as $ActualT) as Self }\n@@ -2218,6 +2408,25 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn from_be(x: Self) -> Self {\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn from_be(x: Self) -> Self {\n                 if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -2244,6 +2453,25 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn from_le(x: Self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn from_le(x: Self) -> Self {\n                 if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -2270,6 +2498,25 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn to_be(self) -> Self { // or not to be?\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn to_be(self) -> Self { // or not to be?\n                 if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -2296,6 +2543,25 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn to_le(self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn to_le(self) -> Self {\n                 if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }"}, {"sha": "fa34b49210a6a5b90341da4a932df66a92341bea", "filename": "src/test/run-pass/const-endianess.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b35c60e95e99a02fdc3ce57121aad558164b0f76/src%2Ftest%2Frun-pass%2Fconst-endianess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35c60e95e99a02fdc3ce57121aad558164b0f76/src%2Ftest%2Frun-pass%2Fconst-endianess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-endianess.rs?ref=b35c60e95e99a02fdc3ce57121aad558164b0f76", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_int_ops)]\n+#![feature(test)]\n+\n+extern crate test;\n+use test::black_box as b;\n+\n+const BE_U32: u32 = 55u32.to_be();\n+const LE_U32: u32 = 55u32.to_le();\n+\n+\n+fn main() {\n+    assert_eq!(BE_U32, b(55u32).to_be());\n+    assert_eq!(LE_U32, b(55u32).to_le());\n+\n+    #[cfg(not(target_arch = \"asmjs\"))]\n+    {\n+        const BE_U128: u128 = 999999u128.to_be();\n+        const LE_I128: i128 = -999999i128.to_le();\n+        assert_eq!(BE_U128, b(999999u128).to_be());\n+        assert_eq!(LE_I128, b(-999999i128).to_le());\n+    }\n+}"}]}