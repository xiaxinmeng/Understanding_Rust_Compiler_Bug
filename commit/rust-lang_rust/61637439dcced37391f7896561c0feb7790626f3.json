{"sha": "61637439dcced37391f7896561c0feb7790626f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNjM3NDM5ZGNjZWQzNzM5MWY3ODk2NTYxYzBmZWI3NzkwNjI2ZjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-30T23:32:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-01T17:31:33Z"}, "message": "Add a type_id intrinsic\n\nCloses #9913", "tree": {"sha": "b72d3643a491b6b9b41bf43a6f991a7a1a8cbe07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b72d3643a491b6b9b41bf43a6f991a7a1a8cbe07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61637439dcced37391f7896561c0feb7790626f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61637439dcced37391f7896561c0feb7790626f3", "html_url": "https://github.com/rust-lang/rust/commit/61637439dcced37391f7896561c0feb7790626f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61637439dcced37391f7896561c0feb7790626f3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a15482b9c602d162c6c26c36ab608eb1bef953d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a15482b9c602d162c6c26c36ab608eb1bef953d", "html_url": "https://github.com/rust-lang/rust/commit/3a15482b9c602d162c6c26c36ab608eb1bef953d"}], "stats": {"total": 347, "additions": 326, "deletions": 21}, "files": [{"sha": "0b5e43b99b45c609ef3c07aab70adf4ab5df848e", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61637439dcced37391f7896561c0feb7790626f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61637439dcced37391f7896561c0feb7790626f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=61637439dcced37391f7896561c0feb7790626f3", "patch": "@@ -274,6 +274,11 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n             Ret(bcx, td);\n         }\n+        \"type_id\" => {\n+            let hash = ty::hash_crate_independent(ccx.tcx, substs.tys[0],\n+                                                  ccx.link_meta.extras_hash);\n+            Ret(bcx, C_i64(hash as i64))\n+        }\n         \"init\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);"}, {"sha": "341747a0d09b8423483c39a1ff8db92c02af1e93", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/61637439dcced37391f7896561c0feb7790626f3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61637439dcced37391f7896561c0feb7790626f3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=61637439dcced37391f7896561c0feb7790626f3", "patch": "@@ -4724,3 +4724,154 @@ pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n \n     result\n }\n+\n+/// Creates a hash of the type `t` which will be the same no matter what crate\n+/// context it's calculated within. This is used by the `type_id` intrinsic.\n+pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n+    use std::hash::{SipState, Streaming};\n+    use metadata::cstore;\n+\n+    let mut hash = SipState::new(0, 0);\n+    let region = |_hash: &mut SipState, r: Region| {\n+        match r {\n+            re_static => {}\n+\n+            re_empty | re_bound(*) | re_free(*) | re_scope(*) | re_infer(*) =>\n+                tcx.sess.bug(\"non-static region found when hashing a type\")\n+        }\n+    };\n+    let vstore = |hash: &mut SipState, v: vstore| {\n+        match v {\n+            vstore_fixed(_) => hash.input([0]),\n+            vstore_uniq => hash.input([1]),\n+            vstore_box => hash.input([2]),\n+            vstore_slice(r) => {\n+                hash.input([3]);\n+                region(hash, r);\n+            }\n+        }\n+    };\n+    let did = |hash: &mut SipState, did: DefId| {\n+        let h = if ast_util::is_local(did) {\n+            local_hash\n+        } else {\n+            cstore::get_crate_hash(tcx.sess.cstore, did.crate)\n+        };\n+        hash.input(h.as_bytes());\n+        iter(hash, &did.node);\n+    };\n+    let mt = |hash: &mut SipState, mt: mt| {\n+        iter(hash, &mt.mutbl);\n+    };\n+    fn iter<T: IterBytes>(hash: &mut SipState, t: &T) {\n+        do t.iter_bytes(true) |bytes| { hash.input(bytes); true };\n+    }\n+    do ty::walk_ty(t) |t| {\n+        match ty::get(t).sty {\n+            ty_nil => hash.input([0]),\n+            ty_bot => hash.input([1]),\n+            ty_bool => hash.input([2]),\n+            ty_char => hash.input([3]),\n+            ty_int(i) => {\n+                hash.input([4]);\n+                iter(&mut hash, &i);\n+            }\n+            ty_uint(u) => {\n+                hash.input([5]);\n+                iter(&mut hash, &u);\n+            }\n+            ty_float(f) => {\n+                hash.input([6]);\n+                iter(&mut hash, &f);\n+            }\n+            ty_estr(v) => {\n+                hash.input([7]);\n+                vstore(&mut hash, v);\n+            }\n+            ty_enum(d, _) => {\n+                hash.input([8]);\n+                did(&mut hash, d);\n+            }\n+            ty_box(m) => {\n+                hash.input([9]);\n+                mt(&mut hash, m);\n+            }\n+            ty_uniq(m) => {\n+                hash.input([10]);\n+                mt(&mut hash, m);\n+            }\n+            ty_evec(m, v) => {\n+                hash.input([11]);\n+                mt(&mut hash, m);\n+                vstore(&mut hash, v);\n+            }\n+            ty_ptr(m) => {\n+                hash.input([12]);\n+                mt(&mut hash, m);\n+            }\n+            ty_rptr(r, m) => {\n+                hash.input([13]);\n+                region(&mut hash, r);\n+                mt(&mut hash, m);\n+            }\n+            ty_bare_fn(ref b) => {\n+                hash.input([14]);\n+                iter(&mut hash, &b.purity);\n+                iter(&mut hash, &b.abis);\n+            }\n+            ty_closure(ref c) => {\n+                hash.input([15]);\n+                iter(&mut hash, &c.purity);\n+                iter(&mut hash, &c.sigil);\n+                iter(&mut hash, &c.onceness);\n+                iter(&mut hash, &c.bounds);\n+                region(&mut hash, c.region);\n+            }\n+            ty_trait(d, _, store, m, bounds) => {\n+                hash.input([17]);\n+                did(&mut hash, d);\n+                match store {\n+                    BoxTraitStore => hash.input([0]),\n+                    UniqTraitStore => hash.input([1]),\n+                    RegionTraitStore(r) => {\n+                        hash.input([2]);\n+                        region(&mut hash, r);\n+                    }\n+                }\n+                iter(&mut hash, &m);\n+                iter(&mut hash, &bounds);\n+            }\n+            ty_struct(d, _) => {\n+                hash.input([18]);\n+                did(&mut hash, d);\n+            }\n+            ty_tup(ref inner) => {\n+                hash.input([19]);\n+                iter(&mut hash, &inner.len());\n+            }\n+            ty_param(p) => {\n+                hash.input([20]);\n+                iter(&mut hash, &p.idx);\n+                did(&mut hash, p.def_id);\n+            }\n+            ty_self(d) => {\n+                hash.input([21]);\n+                did(&mut hash, d);\n+            }\n+            ty_infer(_) => unreachable!(),\n+            ty_err => hash.input([23]),\n+            ty_type => hash.input([24]),\n+            ty_opaque_box => hash.input([25]),\n+            ty_opaque_closure_ptr(s) => {\n+                hash.input([26]);\n+                iter(&mut hash, &s);\n+            }\n+            ty_unboxed_vec(m) => {\n+                hash.input([27]);\n+                mt(&mut hash, m);\n+            }\n+        }\n+    }\n+\n+    hash.result_u64()\n+}"}, {"sha": "205439e016bf3af6ce17e2f7379799e068255674", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61637439dcced37391f7896561c0feb7790626f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61637439dcced37391f7896561c0feb7790626f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=61637439dcced37391f7896561c0feb7790626f3", "patch": "@@ -3700,6 +3700,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n               });\n               (1u, ~[], td_ptr)\n             }\n+            \"type_id\" => (1u, ~[], ty::mk_u64()),\n             \"visit_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,"}, {"sha": "84ccf574ba72ac9b44c69fe347e3ff5934489d25", "filename": "src/libstd/any.rs", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/61637439dcced37391f7896561c0feb7790626f3/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61637439dcced37391f7896561c0feb7790626f3/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=61637439dcced37391f7896561c0feb7790626f3", "patch": "@@ -15,7 +15,7 @@ use cast::transmute;\n use cmp::Eq;\n use option::{Option, Some, None};\n use to_str::ToStr;\n-use unstable::intrinsics::{TyDesc, get_tydesc, forget};\n+use unstable::intrinsics;\n use util::Void;\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -24,15 +24,30 @@ use util::Void;\n ///////////////////////////////////////////////////////////////////////////////\n \n /// `TypeId` represents a globally unique identifier for a type\n+#[cfg(stage0)]\n pub struct TypeId {\n-    priv t: *TyDesc\n+    priv t: *intrinsics::TyDesc,\n+}\n+\n+/// `TypeId` represents a globally unique identifier for a type\n+#[cfg(not(stage0))]\n+pub struct TypeId {\n+    priv t: u64,\n }\n \n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been instantiated with\n     #[inline]\n-    pub fn of<T>() -> TypeId {\n-        TypeId{ t: unsafe { get_tydesc::<T>() } }\n+    #[cfg(stage0)]\n+    pub fn of<T: 'static>() -> TypeId {\n+        TypeId{ t: unsafe { intrinsics::get_tydesc::<T>() } }\n+    }\n+\n+    /// Returns the `TypeId` of the type this generic function has been instantiated with\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn of<T: 'static>() -> TypeId {\n+        TypeId{ t: unsafe { intrinsics::type_id::<T>() } }\n     }\n }\n \n@@ -50,22 +65,32 @@ impl Eq for TypeId {\n /// The `Any` trait is implemented by all types, and can be used as a trait object\n /// for dynamic typing\n pub trait Any {\n+    /// Get the `TypeId` of `self`\n+    fn get_type_id(&self) -> TypeId;\n+\n+    /// Get a void pointer to `self`\n+    fn as_void_ptr(&self) -> *Void;\n+\n+    /// Get a mutable void pointer to `self`\n+    fn as_mut_void_ptr(&mut self) -> *mut Void;\n+}\n+\n+impl<T: 'static> Any for T {\n     /// Get the `TypeId` of `self`\n     fn get_type_id(&self) -> TypeId {\n-        TypeId::of::<Self>()\n+        TypeId::of::<T>()\n     }\n \n     /// Get a void pointer to `self`\n     fn as_void_ptr(&self) -> *Void {\n-        self as *Self as *Void\n+        self as *T as *Void\n     }\n \n     /// Get a mutable void pointer to `self`\n     fn as_mut_void_ptr(&mut self) -> *mut Void {\n-        self as *mut Self as *mut Void\n+        self as *mut T as *mut Void\n     }\n }\n-impl<T> Any for T {}\n \n ///////////////////////////////////////////////////////////////////////////////\n // Extension methods for Any trait objects.\n@@ -75,16 +100,16 @@ impl<T> Any for T {}\n /// Extension methods for a referenced `Any` trait object\n pub trait AnyRefExt<'self> {\n     /// Returns true if the boxed type is the same as `T`\n-    fn is<T>(self) -> bool;\n+    fn is<T: 'static>(self) -> bool;\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn as_ref<T>(self) -> Option<&'self T>;\n+    fn as_ref<T: 'static>(self) -> Option<&'self T>;\n }\n \n impl<'self> AnyRefExt<'self> for &'self Any {\n     #[inline]\n-    fn is<T>(self) -> bool {\n+    fn is<T: 'static>(self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n         let t = TypeId::of::<T>();\n \n@@ -96,7 +121,7 @@ impl<'self> AnyRefExt<'self> for &'self Any {\n     }\n \n     #[inline]\n-    fn as_ref<T>(self) -> Option<&'self T> {\n+    fn as_ref<T: 'static>(self) -> Option<&'self T> {\n         if self.is::<T>() {\n             Some(unsafe { transmute(self.as_void_ptr()) })\n         } else {\n@@ -109,12 +134,12 @@ impl<'self> AnyRefExt<'self> for &'self Any {\n pub trait AnyMutRefExt<'self> {\n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn as_mut<T>(self) -> Option<&'self mut T>;\n+    fn as_mut<T: 'static>(self) -> Option<&'self mut T>;\n }\n \n impl<'self> AnyMutRefExt<'self> for &'self mut Any {\n     #[inline]\n-    fn as_mut<T>(self) -> Option<&'self mut T> {\n+    fn as_mut<T: 'static>(self) -> Option<&'self mut T> {\n         if self.is::<T>() {\n             Some(unsafe { transmute(self.as_mut_void_ptr()) })\n         } else {\n@@ -127,19 +152,19 @@ impl<'self> AnyMutRefExt<'self> for &'self mut Any {\n pub trait AnyOwnExt {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn move<T>(self) -> Option<~T>;\n+    fn move<T: 'static>(self) -> Option<~T>;\n }\n \n impl AnyOwnExt for ~Any {\n     #[inline]\n-    fn move<T>(self) -> Option<~T> {\n+    fn move<T: 'static>(self) -> Option<~T> {\n         if self.is::<T>() {\n             unsafe {\n                 // Extract the pointer to the boxed value, temporary alias with self\n                 let ptr: ~T = transmute(self.as_void_ptr());\n \n                 // Prevent destructor on self being run\n-                forget(self);\n+                intrinsics::forget(self);\n \n                 Some(ptr)\n             }"}, {"sha": "4d28b0d194eb6de85f4583a115f10bf28c500163", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61637439dcced37391f7896561c0feb7790626f3/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61637439dcced37391f7896561c0feb7790626f3/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=61637439dcced37391f7896561c0feb7790626f3", "patch": "@@ -49,23 +49,23 @@ pub struct TyDesc {\n     align: uint,\n \n     // Called on a copy of a value of type `T` *after* memcpy\n-    priv take_glue: GlueFn,\n+    take_glue: GlueFn,\n \n     // Called when a value of type `T` is no longer needed\n     drop_glue: GlueFn,\n \n     // Called by drop glue when a value of type `T` can be freed\n-    priv free_glue: GlueFn,\n+    free_glue: GlueFn,\n \n     // Called by reflection visitor to visit a value of type `T`\n-    priv visit_glue: GlueFn,\n+    visit_glue: GlueFn,\n \n     // If T represents a box pointer (`@U` or `~U`), then\n     // `borrow_offset` is the amount that the pointer must be adjusted\n     // to find the payload.  This is always derivable from the type\n     // `U`, but in the case of `@Trait` or `~Trait` objects, the type\n     // `U` is unknown.\n-    priv borrow_offset: uint,\n+    borrow_offset: uint,\n \n     // Name corresponding to the type\n     name: &'static str\n@@ -310,6 +310,12 @@ extern \"rust-intrinsic\" {\n     /// Get a static pointer to a type descriptor.\n     pub fn get_tydesc<T>() -> *TyDesc;\n \n+    /// Gets an identifier which is globally unique to the specified type. This\n+    /// function will return the same value for a type regardless of whichever\n+    /// crate it is invoked in.\n+    #[cfg(not(stage0))]\n+    pub fn type_id<T: 'static>() -> u64;\n+\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,"}, {"sha": "768b0d19da3d1695b1812eddbeb351d9754094b7", "filename": "src/test/auxiliary/typeid-intrinsic.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/61637439dcced37391f7896561c0feb7790626f3/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61637439dcced37391f7896561c0feb7790626f3/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs?ref=61637439dcced37391f7896561c0feb7790626f3", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::unstable::intrinsics;\n+\n+pub struct A;\n+pub struct B(Option<A>);\n+pub struct C(Option<int>);\n+pub struct D(Option<&'static str>);\n+pub struct E(Result<&'static str, int>);\n+\n+pub type F = Option<int>;\n+pub type G = uint;\n+pub type H = &'static str;\n+\n+pub unsafe fn id_A() -> u64 { intrinsics::type_id::<A>() }\n+pub unsafe fn id_B() -> u64 { intrinsics::type_id::<B>() }\n+pub unsafe fn id_C() -> u64 { intrinsics::type_id::<C>() }\n+pub unsafe fn id_D() -> u64 { intrinsics::type_id::<D>() }\n+pub unsafe fn id_E() -> u64 { intrinsics::type_id::<E>() }\n+pub unsafe fn id_F() -> u64 { intrinsics::type_id::<F>() }\n+pub unsafe fn id_G() -> u64 { intrinsics::type_id::<G>() }\n+pub unsafe fn id_H() -> u64 { intrinsics::type_id::<H>() }\n+\n+pub unsafe fn foo<T: 'static>() -> u64 { intrinsics::type_id::<T>() }"}, {"sha": "768b0d19da3d1695b1812eddbeb351d9754094b7", "filename": "src/test/auxiliary/typeid-intrinsic2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/61637439dcced37391f7896561c0feb7790626f3/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61637439dcced37391f7896561c0feb7790626f3/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs?ref=61637439dcced37391f7896561c0feb7790626f3", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::unstable::intrinsics;\n+\n+pub struct A;\n+pub struct B(Option<A>);\n+pub struct C(Option<int>);\n+pub struct D(Option<&'static str>);\n+pub struct E(Result<&'static str, int>);\n+\n+pub type F = Option<int>;\n+pub type G = uint;\n+pub type H = &'static str;\n+\n+pub unsafe fn id_A() -> u64 { intrinsics::type_id::<A>() }\n+pub unsafe fn id_B() -> u64 { intrinsics::type_id::<B>() }\n+pub unsafe fn id_C() -> u64 { intrinsics::type_id::<C>() }\n+pub unsafe fn id_D() -> u64 { intrinsics::type_id::<D>() }\n+pub unsafe fn id_E() -> u64 { intrinsics::type_id::<E>() }\n+pub unsafe fn id_F() -> u64 { intrinsics::type_id::<F>() }\n+pub unsafe fn id_G() -> u64 { intrinsics::type_id::<G>() }\n+pub unsafe fn id_H() -> u64 { intrinsics::type_id::<H>() }\n+\n+pub unsafe fn foo<T: 'static>() -> u64 { intrinsics::type_id::<T>() }"}, {"sha": "b9ad9b09d4992966f58748e877bc4deeae31bd2a", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/61637439dcced37391f7896561c0feb7790626f3/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61637439dcced37391f7896561c0feb7790626f3/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=61637439dcced37391f7896561c0feb7790626f3", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast windows doesn't like aux-build\n+// aux-build:typeid-intrinsic.rs\n+// aux-build:typeid-intrinsic2.rs\n+\n+extern mod other1(name = \"typeid-intrinsic\");\n+extern mod other2(name = \"typeid-intrinsic2\");\n+\n+use std::unstable::intrinsics;\n+\n+struct A;\n+\n+fn main() {\n+    unsafe {\n+        assert_eq!(intrinsics::type_id::<other1::A>(), other1::id_A());\n+        assert_eq!(intrinsics::type_id::<other1::B>(), other1::id_B());\n+        assert_eq!(intrinsics::type_id::<other1::C>(), other1::id_C());\n+        assert_eq!(intrinsics::type_id::<other1::D>(), other1::id_D());\n+        assert_eq!(intrinsics::type_id::<other1::E>(), other1::id_E());\n+        assert_eq!(intrinsics::type_id::<other1::F>(), other1::id_F());\n+        assert_eq!(intrinsics::type_id::<other1::G>(), other1::id_G());\n+        assert_eq!(intrinsics::type_id::<other1::H>(), other1::id_H());\n+\n+        assert_eq!(intrinsics::type_id::<other2::A>(), other2::id_A());\n+        assert_eq!(intrinsics::type_id::<other2::B>(), other2::id_B());\n+        assert_eq!(intrinsics::type_id::<other2::C>(), other2::id_C());\n+        assert_eq!(intrinsics::type_id::<other2::D>(), other2::id_D());\n+        assert_eq!(intrinsics::type_id::<other2::E>(), other2::id_E());\n+        assert_eq!(intrinsics::type_id::<other2::F>(), other2::id_F());\n+        assert_eq!(intrinsics::type_id::<other2::G>(), other2::id_G());\n+        assert_eq!(intrinsics::type_id::<other2::H>(), other2::id_H());\n+\n+        assert_eq!(other1::id_F(), other2::id_F());\n+        assert_eq!(other1::id_G(), other2::id_G());\n+        assert_eq!(other1::id_H(), other2::id_H());\n+\n+        assert_eq!(intrinsics::type_id::<int>(), other2::foo::<int>());\n+        assert_eq!(intrinsics::type_id::<int>(), other1::foo::<int>());\n+        assert_eq!(other2::foo::<int>(), other1::foo::<int>());\n+        assert_eq!(intrinsics::type_id::<A>(), other2::foo::<A>());\n+        assert_eq!(intrinsics::type_id::<A>(), other1::foo::<A>());\n+        assert_eq!(other2::foo::<A>(), other1::foo::<A>());\n+    }\n+}"}]}