{"sha": "7452822843cf461b56742f0fc648af35889a3070", "node_id": "C_kwDOAAsO6NoAKDc0NTI4MjI4NDNjZjQ2MWI1Njc0MmYwZmM2NDhhZjM1ODg5YTMwNzA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-05T10:42:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-05T10:42:05Z"}, "message": "Auto merge of #107583 - EsmeYi:aix_xcoff_metadata, r=bjorn3\n\nSupport the rustc metadata for AIX\n\nSupport the rustc metadata for rlibs and dylibs on AIX.\nXCOFF is the object file format on AIX.", "tree": {"sha": "db82a6a71e49b2482bca6454a50f1e6abe561e3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db82a6a71e49b2482bca6454a50f1e6abe561e3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7452822843cf461b56742f0fc648af35889a3070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7452822843cf461b56742f0fc648af35889a3070", "html_url": "https://github.com/rust-lang/rust/commit/7452822843cf461b56742f0fc648af35889a3070", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7452822843cf461b56742f0fc648af35889a3070/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42f28f9eb41adb7a197697e5e2d6535d00fd0f4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/42f28f9eb41adb7a197697e5e2d6535d00fd0f4a", "html_url": "https://github.com/rust-lang/rust/commit/42f28f9eb41adb7a197697e5e2d6535d00fd0f4a"}, {"sha": "e31661cb9e5effdae3be7eec55143e2e8ece9e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/e31661cb9e5effdae3be7eec55143e2e8ece9e14", "html_url": "https://github.com/rust-lang/rust/commit/e31661cb9e5effdae3be7eec55143e2e8ece9e14"}], "stats": {"total": 153, "additions": 141, "deletions": 12}, "files": [{"sha": "984efa21044469bc932fdba929161e0a49bc6b19", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7452822843cf461b56742f0fc648af35889a3070/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7452822843cf461b56742f0fc648af35889a3070/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=7452822843cf461b56742f0fc648af35889a3070", "patch": "@@ -48,7 +48,7 @@ libc = \"0.2.50\"\n [dependencies.object]\n version = \"0.31.1\"\n default-features = false\n-features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\", \"write\"]\n+features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"xcoff\", \"unaligned\", \"archive\", \"write\"]\n \n [target.'cfg(windows)'.dependencies.windows]\n version = \"0.48.0\""}, {"sha": "b198e35e0c18a4d5e06cf70c644ad9e30f3f7d8e", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 140, "deletions": 11, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/7452822843cf461b56742f0fc648af35889a3070/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7452822843cf461b56742f0fc648af35889a3070/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=7452822843cf461b56742f0fc648af35889a3070", "patch": "@@ -6,8 +6,8 @@ use std::path::Path;\n \n use object::write::{self, StandardSegment, Symbol, SymbolSection};\n use object::{\n-    elf, pe, Architecture, BinaryFormat, Endianness, FileFlags, Object, ObjectSection,\n-    SectionFlags, SectionKind, SymbolFlags, SymbolKind, SymbolScope,\n+    elf, pe, xcoff, Architecture, BinaryFormat, Endianness, FileFlags, Object, ObjectSection,\n+    ObjectSymbol, SectionFlags, SectionKind, SymbolFlags, SymbolKind, SymbolScope,\n };\n \n use snap::write::FrameEncoder;\n@@ -35,6 +35,8 @@ use rustc_target::spec::{RelocModel, Target};\n #[derive(Debug)]\n pub struct DefaultMetadataLoader;\n \n+static AIX_METADATA_SYMBOL_NAME: &'static str = \"__aix_rust_metadata\";\n+\n fn load_metadata_with(\n     path: &Path,\n     f: impl for<'a> FnOnce(&'a [u8]) -> Result<&'a [u8], String>,\n@@ -48,7 +50,7 @@ fn load_metadata_with(\n }\n \n impl MetadataLoader for DefaultMetadataLoader {\n-    fn get_rlib_metadata(&self, _target: &Target, path: &Path) -> Result<OwnedSlice, String> {\n+    fn get_rlib_metadata(&self, target: &Target, path: &Path) -> Result<OwnedSlice, String> {\n         load_metadata_with(path, |data| {\n             let archive = object::read::archive::ArchiveFile::parse(&*data)\n                 .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n@@ -60,16 +62,24 @@ impl MetadataLoader for DefaultMetadataLoader {\n                     let data = entry\n                         .data(data)\n                         .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n-                    return search_for_section(path, data, \".rmeta\");\n+                    if target.is_like_aix {\n+                        return get_metadata_xcoff(path, data);\n+                    } else {\n+                        return search_for_section(path, data, \".rmeta\");\n+                    }\n                 }\n             }\n \n             Err(format!(\"metadata not found in rlib '{}'\", path.display()))\n         })\n     }\n \n-    fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<OwnedSlice, String> {\n-        load_metadata_with(path, |data| search_for_section(path, data, \".rustc\"))\n+    fn get_dylib_metadata(&self, target: &Target, path: &Path) -> Result<OwnedSlice, String> {\n+        if target.is_like_aix {\n+            load_metadata_with(path, |data| get_metadata_xcoff(path, data))\n+        } else {\n+            load_metadata_with(path, |data| search_for_section(path, data, \".rustc\"))\n+        }\n     }\n }\n \n@@ -141,6 +151,33 @@ fn add_gnu_property_note(\n     file.append_section_data(section, &data, 8);\n }\n \n+pub(super) fn get_metadata_xcoff<'a>(path: &Path, data: &'a [u8]) -> Result<&'a [u8], String> {\n+    let Ok(file) = object::File::parse(data) else {\n+        return Ok(data);\n+    };\n+    let info_data = search_for_section(path, data, \".info\")?;\n+    if let Some(metadata_symbol) =\n+        file.symbols().find(|sym| sym.name() == Ok(AIX_METADATA_SYMBOL_NAME))\n+    {\n+        let offset = metadata_symbol.address() as usize;\n+        if offset < 4 {\n+            return Err(format!(\"Invalid metadata symbol offset: {}\", offset));\n+        }\n+        // The offset specifies the location of rustc metadata in the comment section.\n+        // The metadata is preceded by a 4-byte length field.\n+        let len = u32::from_be_bytes(info_data[(offset - 4)..offset].try_into().unwrap()) as usize;\n+        if offset + len > (info_data.len() as usize) {\n+            return Err(format!(\n+                \"Metadata at offset {} with size {} is beyond .info section\",\n+                offset, len\n+            ));\n+        }\n+        return Ok(&info_data[offset..(offset + len)]);\n+    } else {\n+        return Err(format!(\"Unable to find symbol {}\", AIX_METADATA_SYMBOL_NAME));\n+    };\n+}\n+\n pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static>> {\n     let endianness = match sess.target.options.endian {\n         Endian::Little => Endianness::Little,\n@@ -183,6 +220,8 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n         BinaryFormat::MachO\n     } else if sess.target.is_like_windows {\n         BinaryFormat::Coff\n+    } else if sess.target.is_like_aix {\n+        BinaryFormat::Xcoff\n     } else {\n         BinaryFormat::Elf\n     };\n@@ -351,11 +390,15 @@ pub fn create_wrapper_file(\n         // to add a case above.\n         return (data.to_vec(), MetadataPosition::Last);\n     };\n-    let section = file.add_section(\n-        file.segment_name(StandardSegment::Debug).to_vec(),\n-        section_name,\n-        SectionKind::Debug,\n-    );\n+    let section = if file.format() == BinaryFormat::Xcoff {\n+        file.add_section(Vec::new(), b\".info\".to_vec(), SectionKind::Debug)\n+    } else {\n+        file.add_section(\n+            file.segment_name(StandardSegment::Debug).to_vec(),\n+            section_name,\n+            SectionKind::Debug,\n+        )\n+    };\n     match file.format() {\n         BinaryFormat::Coff => {\n             file.section_mut(section).flags =\n@@ -365,6 +408,31 @@ pub fn create_wrapper_file(\n             file.section_mut(section).flags =\n                 SectionFlags::Elf { sh_flags: elf::SHF_EXCLUDE as u64 };\n         }\n+        BinaryFormat::Xcoff => {\n+            // AIX system linker may aborts if it meets a valid XCOFF file in archive with no .text, no .data and no .bss.\n+            file.add_section(Vec::new(), b\".text\".to_vec(), SectionKind::Text);\n+            file.section_mut(section).flags =\n+                SectionFlags::Xcoff { s_flags: xcoff::STYP_INFO as u32 };\n+\n+            let len = data.len() as u32;\n+            let offset = file.append_section_data(section, &len.to_be_bytes(), 1);\n+            // Add a symbol referring to the data in .info section.\n+            file.add_symbol(Symbol {\n+                name: AIX_METADATA_SYMBOL_NAME.into(),\n+                value: offset + 4,\n+                size: 0,\n+                kind: SymbolKind::Unknown,\n+                scope: SymbolScope::Compilation,\n+                weak: false,\n+                section: SymbolSection::Section(section),\n+                flags: SymbolFlags::Xcoff {\n+                    n_sclass: xcoff::C_INFO,\n+                    x_smtyp: xcoff::C_HIDEXT,\n+                    x_smclas: xcoff::C_HIDEXT,\n+                    containing_csect: None,\n+                },\n+            });\n+        }\n         _ => {}\n     };\n     file.append_section_data(section, data, 1);\n@@ -401,6 +469,9 @@ pub fn create_compressed_metadata_file(\n     let Some(mut file) = create_object_file(sess) else {\n         return compressed.to_vec();\n     };\n+    if file.format() == BinaryFormat::Xcoff {\n+        return create_compressed_metadata_file_for_xcoff(file, &compressed, symbol_name);\n+    }\n     let section = file.add_section(\n         file.segment_name(StandardSegment::Data).to_vec(),\n         b\".rustc\".to_vec(),\n@@ -430,3 +501,61 @@ pub fn create_compressed_metadata_file(\n \n     file.write().unwrap()\n }\n+\n+/// * Xcoff - On AIX, custom sections are merged into predefined sections,\n+///   so custom .rustc section is not preserved during linking.\n+///   For this reason, we store metadata in predefined .info section, and\n+///   define a symbol to reference the metadata. To preserve metadata during\n+///   linking on AIX, we have to\n+///   1. Create an empty .text section, a empty .data section.\n+///   2. Define an empty symbol named `symbol_name` inside .data section.\n+///   3. Define an symbol named `AIX_METADATA_SYMBOL_NAME` referencing\n+///      data inside .info section.\n+///   From XCOFF's view, (2) creates a csect entry in the symbol table, the\n+///   symbol created by (3) is a info symbol for the preceding csect. Thus\n+///   two symbols are preserved during linking and we can use the second symbol\n+///   to reference the metadata.\n+pub fn create_compressed_metadata_file_for_xcoff(\n+    mut file: write::Object<'_>,\n+    data: &[u8],\n+    symbol_name: &str,\n+) -> Vec<u8> {\n+    assert!(file.format() == BinaryFormat::Xcoff);\n+    // AIX system linker may aborts if it meets a valid XCOFF file in archive with no .text, no .data and no .bss.\n+    file.add_section(Vec::new(), b\".text\".to_vec(), SectionKind::Text);\n+    let data_section = file.add_section(Vec::new(), b\".data\".to_vec(), SectionKind::Data);\n+    let section = file.add_section(Vec::new(), b\".info\".to_vec(), SectionKind::Debug);\n+    file.add_file_symbol(\"lib.rmeta\".into());\n+    file.section_mut(section).flags = SectionFlags::Xcoff { s_flags: xcoff::STYP_INFO as u32 };\n+    // Add a global symbol to data_section.\n+    file.add_symbol(Symbol {\n+        name: symbol_name.as_bytes().into(),\n+        value: 0,\n+        size: 0,\n+        kind: SymbolKind::Data,\n+        scope: SymbolScope::Dynamic,\n+        weak: true,\n+        section: SymbolSection::Section(data_section),\n+        flags: SymbolFlags::None,\n+    });\n+    let len = data.len() as u32;\n+    let offset = file.append_section_data(section, &len.to_be_bytes(), 1);\n+    // Add a symbol referring to the rustc metadata.\n+    file.add_symbol(Symbol {\n+        name: AIX_METADATA_SYMBOL_NAME.into(),\n+        value: offset + 4, // The metadata is preceded by a 4-byte length field.\n+        size: 0,\n+        kind: SymbolKind::Unknown,\n+        scope: SymbolScope::Dynamic,\n+        weak: false,\n+        section: SymbolSection::Section(section),\n+        flags: SymbolFlags::Xcoff {\n+            n_sclass: xcoff::C_INFO,\n+            x_smtyp: xcoff::C_HIDEXT,\n+            x_smclas: xcoff::C_HIDEXT,\n+            containing_csect: None,\n+        },\n+    });\n+    file.append_section_data(section, data, 1);\n+    file.write().unwrap()\n+}"}]}