{"sha": "489a6c95bf747059b28472efc17d39795c6adcad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4OWE2Yzk1YmY3NDcwNTliMjg0NzJlZmMxN2QzOTc5NWM2YWRjYWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-20T18:49:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-02T15:49:23Z"}, "message": "replace fileline_{help,note} with {help,note}\n\nThe extra filename and line was mainly there to keep the indentation\nrelative to the main snippet; now that this doesn't include\nfilename/line-number as a prefix, it is distracted.", "tree": {"sha": "8291d94bde59caa3b22d2ab3366af46dc5519751", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8291d94bde59caa3b22d2ab3366af46dc5519751"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/489a6c95bf747059b28472efc17d39795c6adcad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/489a6c95bf747059b28472efc17d39795c6adcad", "html_url": "https://github.com/rust-lang/rust/commit/489a6c95bf747059b28472efc17d39795c6adcad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/489a6c95bf747059b28472efc17d39795c6adcad/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff1887cc9537cf45c2bc405ce0b026ef9a2246a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff1887cc9537cf45c2bc405ce0b026ef9a2246a", "html_url": "https://github.com/rust-lang/rust/commit/1ff1887cc9537cf45c2bc405ce0b026ef9a2246a"}], "stats": {"total": 432, "additions": 172, "deletions": 260}, "files": [{"sha": "11d92f8585489e868e457ac214a80c683e43f9ab", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -682,10 +682,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                                E0309,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n-                err.fileline_help(origin.span(),\n-                                  &format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n-                                           bound_kind,\n-                                           sub));\n+                err.help(&format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n+                         bound_kind,\n+                         sub));\n                 err\n             }\n \n@@ -696,10 +695,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                                E0310,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n-                err.fileline_help(origin.span(),\n-                                  &format!(\"consider adding an explicit lifetime \\\n-                                            bound `{}: 'static`...\",\n-                                           bound_kind));\n+                err.help(&format!(\"consider adding an explicit lifetime \\\n+                                   bound `{}: 'static`...\",\n+                                  bound_kind));\n                 err\n             }\n \n@@ -710,9 +708,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                                E0311,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n-                err.fileline_help(origin.span(),\n-                                  &format!(\"consider adding an explicit lifetime bound for `{}`\",\n-                                           bound_kind));\n+                err.help(&format!(\"consider adding an explicit lifetime bound for `{}`\",\n+                                  bound_kind));\n                 self.tcx.note_and_explain_region(\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),"}, {"sha": "4ea6845b3c4f4009fa977018085c1e43d9f0de4e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -456,17 +456,13 @@ pub fn raw_struct_lint<'a>(sess: &'a Session,\n                                    it will become a hard error in a future release!\");\n         let citation = format!(\"for more information, see {}\",\n                                future_incompatible.reference);\n-        if let Some(sp) = span {\n-            err.fileline_warn(sp, &explanation);\n-            err.fileline_note(sp, &citation);\n-        } else {\n-            err.warn(&explanation);\n-            err.note(&citation);\n-        }\n+        err.warn(&explanation);\n+        err.note(&citation);\n     }\n \n     if let Some(span) = def {\n-        err.span_note(span, \"lint level defined here\");\n+        let explanation = \"lint level defined here\";\n+        err = err.span_label(span, &explanation);\n     }\n \n     err\n@@ -542,7 +538,7 @@ pub trait LintContext: Sized {\n         let mut err = self.lookup(lint, Some(span), msg);\n         if self.current_level(lint) != Level::Allow {\n             if note_span == span {\n-                err.fileline_note(note_span, note);\n+                err.note(note);\n             } else {\n                 err.span_note(note_span, note);\n             }"}, {"sha": "531a4fbf8beba07aa009ffa2dc04930a08c20647", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 56, "deletions": 109, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -206,18 +206,17 @@ fn find_similar_impl_candidates<'a, 'tcx>(\n     impl_candidates\n }\n \n-fn report_similar_impl_candidates(span: Span,\n-                                  err: &mut DiagnosticBuilder,\n+fn report_similar_impl_candidates(err: &mut DiagnosticBuilder,\n                                   impl_candidates: &[ty::TraitRef])\n {\n-    err.fileline_help(span, &format!(\"the following implementations were found:\"));\n+    err.help(&format!(\"the following implementations were found:\"));\n \n     let end = cmp::min(4, impl_candidates.len());\n     for candidate in &impl_candidates[0..end] {\n-        err.fileline_help(span, &format!(\"  {:?}\", candidate));\n+        err.help(&format!(\"  {:?}\", candidate));\n     }\n     if impl_candidates.len() > 4 {\n-        err.fileline_help(span, &format!(\"and {} others\", impl_candidates.len()-4));\n+        err.help(&format!(\"and {} others\", impl_candidates.len()-4));\n     }\n }\n \n@@ -240,7 +239,7 @@ pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                    predicate);\n \n     if suggest_increasing_limit {\n-        suggest_new_overflow_limit(infcx.tcx, &mut err, obligation.cause.span);\n+        suggest_new_overflow_limit(infcx.tcx, &mut err);\n     }\n \n     note_obligation_cause(infcx, &mut err, obligation);\n@@ -353,19 +352,15 @@ pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n     let mut err = recursive_type_with_infinite_size_error(tcx, main_def_id);\n     let len = struct_enum_tys.len();\n     if len > 2 {\n-        let span = tcx.map.span_if_local(main_def_id).unwrap();\n-        err.fileline_note(span,\n-                          &format!(\"type `{}` is embedded within `{}`...\",\n-                                   struct_enum_tys[0],\n-                                   struct_enum_tys[1]));\n+        err.note(&format!(\"type `{}` is embedded within `{}`...\",\n+                 struct_enum_tys[0],\n+                 struct_enum_tys[1]));\n         for &next_ty in &struct_enum_tys[1..len-1] {\n-            err.fileline_note(span,\n-                              &format!(\"...which in turn is embedded within `{}`...\", next_ty));\n+            err.note(&format!(\"...which in turn is embedded within `{}`...\", next_ty));\n         }\n-        err.fileline_note(span,\n-                          &format!(\"...which in turn is embedded within `{}`, \\\n-                                    completing the cycle.\",\n-                                   struct_enum_tys[len-1]));\n+        err.note(&format!(\"...which in turn is embedded within `{}`, \\\n+                           completing the cycle.\",\n+                          struct_enum_tys[len-1]));\n     }\n     err.emit();\n     infcx.tcx.sess.abort_if_errors();\n@@ -380,9 +375,9 @@ pub fn recursive_type_with_infinite_size_error<'tcx>(tcx: &TyCtxt<'tcx>,\n     let span = tcx.map.span_if_local(type_def_id).unwrap();\n     let mut err = struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\",\n                                    tcx.item_path_str(type_def_id));\n-    err.fileline_help(span, &format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                                      at some point to make `{}` representable\",\n-                                     tcx.item_path_str(type_def_id)));\n+    err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                       at some point to make `{}` representable\",\n+                      tcx.item_path_str(type_def_id)));\n     err\n }\n \n@@ -423,24 +418,22 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 // these notes will often be of the form\n                                 //     \"the type `T` can't be frobnicated\"\n                                 // which is somewhat confusing.\n-                                err.fileline_help(obligation.cause.span, &format!(\n-                                    \"consider adding a `where {}` bound\",\n+                                err.help(&format!(\"consider adding a `where {}` bound\",\n                                     trait_ref.to_predicate()\n                                     ));\n                             } else if let Some(s) = on_unimplemented_note(infcx, trait_ref,\n                                                                           obligation.cause.span) {\n                                 // Otherwise, if there is an on-unimplemented note,\n                                 // display it.\n-                                err.fileline_note(obligation.cause.span, &s);\n+                                err.note(&s);\n                             } else {\n                                 // If we can't show anything useful, try to find\n                                 // similar impls.\n \n                                 let impl_candidates =\n                                     find_similar_impl_candidates(infcx, trait_ref);\n                                 if impl_candidates.len() > 0 {\n-                                    report_similar_impl_candidates(obligation.cause.span,\n-                                                                   &mut err, &impl_candidates);\n+                                    report_similar_impl_candidates(&mut err, &impl_candidates);\n                                 }\n                             }\n                             note_obligation_cause(infcx, &mut err, obligation);\n@@ -499,7 +492,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         let found_kind = infcx.closure_kind(closure_def_id).unwrap();\n                         let closure_span = infcx.tcx.map.span_if_local(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n-                            infcx.tcx.sess, closure_span, E0524,\n+                            infcx.tcx.sess, closure_span, E0525,\n                             \"expected a closure that implements the `{}` trait, but this closure \\\n                              only implements `{}`\",\n                             kind,\n@@ -570,41 +563,31 @@ pub fn report_object_safety_error<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n         match violation {\n             ObjectSafetyViolation::SizedSelf => {\n-                err.fileline_note(\n-                    span,\n-                    \"the trait cannot require that `Self : Sized`\");\n+                err.note(\"the trait cannot require that `Self : Sized`\");\n             }\n \n             ObjectSafetyViolation::SupertraitSelf => {\n-                err.fileline_note(\n-                    span,\n-                    \"the trait cannot use `Self` as a type parameter \\\n-                     in the supertrait listing\");\n+                err.note(\"the trait cannot use `Self` as a type parameter \\\n+                          in the supertrait listing\");\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::StaticMethod) => {\n-                err.fileline_note(\n-                    span,\n-                    &format!(\"method `{}` has no receiver\",\n-                             method.name));\n+                err.note(&format!(\"method `{}` has no receiver\",\n+                         method.name));\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::ReferencesSelf) => {\n-                err.fileline_note(\n-                    span,\n-                    &format!(\"method `{}` references the `Self` type \\\n-                              in its arguments or return type\",\n-                             method.name));\n+                err.note(&format!(\"method `{}` references the `Self` type \\\n+                                   in its arguments or return type\",\n+                                  method.name));\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::Generic) => {\n-                err.fileline_note(\n-                    span,\n-                    &format!(\"method `{}` has generic type parameters\",\n-                             method.name));\n+                err.note(&format!(\"method `{}` has generic type parameters\",\n+                                  method.name));\n             }\n         }\n     }\n@@ -766,142 +749,106 @@ fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     note_obligation_cause_code(infcx,\n                                err,\n                                &obligation.predicate,\n-                               obligation.cause.span,\n                                &obligation.cause.code);\n }\n \n fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                            err: &mut DiagnosticBuilder,\n                                            predicate: &T,\n-                                           cause_span: Span,\n                                            cause_code: &ObligationCauseCode<'tcx>)\n     where T: fmt::Display\n {\n     let tcx = infcx.tcx;\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n         ObligationCauseCode::SliceOrArrayElem => {\n-            err.fileline_note(\n-                cause_span,\n-                \"slice and array elements must have `Sized` type\");\n+            err.note(\"slice and array elements must have `Sized` type\");\n         }\n         ObligationCauseCode::ProjectionWf(data) => {\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\"required so that the projection `{}` is well-formed\",\n-                         data));\n+            err.note(&format!(\"required so that the projection `{}` is well-formed\",\n+                              data));\n         }\n         ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\"required so that reference `{}` does not outlive its referent\",\n-                         ref_ty));\n+            err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n+                              ref_ty));\n         }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n             let item_name = tcx.item_path_str(item_def_id);\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\"required by `{}`\", item_name));\n+            err.note(&format!(\"required by `{}`\", item_name));\n         }\n         ObligationCauseCode::ObjectCastObligation(object_ty) => {\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\n-                    \"required for the cast to the object type `{}`\",\n-                    infcx.ty_to_string(object_ty)));\n+            err.note(&format!(\"required for the cast to the object type `{}`\",\n+                              infcx.ty_to_string(object_ty)));\n         }\n         ObligationCauseCode::RepeatVec => {\n-            err.fileline_note(\n-                cause_span,\n-                \"the `Copy` trait is required because the \\\n-                 repeated element will be copied\");\n+            err.note(\"the `Copy` trait is required because the \\\n+                      repeated element will be copied\");\n         }\n         ObligationCauseCode::VariableType(_) => {\n-            err.fileline_note(\n-                cause_span,\n-                \"all local variables must have a statically known size\");\n+            err.note(\"all local variables must have a statically known size\");\n         }\n         ObligationCauseCode::ReturnType => {\n-            err.fileline_note(\n-                cause_span,\n-                \"the return type of a function must have a \\\n-                 statically known size\");\n+            err.note(\"the return type of a function must have a \\\n+                      statically known size\");\n         }\n         ObligationCauseCode::AssignmentLhsSized => {\n-            err.fileline_note(\n-                cause_span,\n-                \"the left-hand-side of an assignment must have a statically known size\");\n+            err.note(\"the left-hand-side of an assignment must have a statically known size\");\n         }\n         ObligationCauseCode::StructInitializerSized => {\n-            err.fileline_note(\n-                cause_span,\n-                \"structs must have a statically known size to be initialized\");\n+            err.note(\"structs must have a statically known size to be initialized\");\n         }\n         ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n             let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n             let trait_name = tcx.item_path_str(def_id);\n             let name = tcx.local_var_name_str(var_id);\n-            err.fileline_note(\n-                cause_span,\n+            err.note(\n                 &format!(\"the closure that captures `{}` requires that all captured variables \\\n                           implement the trait `{}`\",\n                          name,\n                          trait_name));\n         }\n         ObligationCauseCode::FieldSized => {\n-            err.fileline_note(\n-                cause_span,\n-                \"only the last field of a struct or enum variant \\\n-                 may have a dynamically sized type\");\n+            err.note(\"only the last field of a struct or enum variant \\\n+                      may have a dynamically sized type\");\n         }\n         ObligationCauseCode::SharedStatic => {\n-            err.fileline_note(\n-                cause_span,\n-                \"shared static variables must have a type that implements `Sync`\");\n+            err.note(\"shared static variables must have a type that implements `Sync`\");\n         }\n         ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\"required because it appears within the type `{}`\",\n-                         parent_trait_ref.0.self_ty()));\n+            err.note(&format!(\"required because it appears within the type `{}`\",\n+                              parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n             note_obligation_cause_code(infcx,\n                                        err,\n                                        &parent_predicate,\n-                                       cause_span,\n                                        &data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            err.fileline_note(\n-                cause_span,\n+            err.note(\n                 &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n                          parent_trait_ref,\n                          parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n             note_obligation_cause_code(infcx,\n                                        err,\n                                        &parent_predicate,\n-                                       cause_span,\n                                        &data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n-            err.fileline_note(\n-                cause_span,\n+            err.note(\n                 &format!(\"the requirement `{}` appears on the impl method \\\n                           but not on the corresponding trait method\",\n                          predicate));\n         }\n     }\n }\n \n-fn suggest_new_overflow_limit(tcx: &TyCtxt, err:&mut DiagnosticBuilder, span: Span) {\n+fn suggest_new_overflow_limit(tcx: &TyCtxt, err:&mut DiagnosticBuilder) {\n     let current_limit = tcx.sess.recursion_limit.get();\n     let suggested_limit = current_limit * 2;\n-    err.fileline_note(\n-        span,\n-        &format!(\n-            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-            suggested_limit));\n+    err.note(&format!(\n+                      \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                      suggested_limit));\n }"}, {"sha": "5768a441c51b7af62b65cc8b2b7cfb32f0460faa", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -167,8 +167,7 @@ fn note_move_destination(err: &mut DiagnosticBuilder,\n         err.span_note(\n             move_to_span,\n             \"attempting to move value to here\");\n-        err.fileline_help(\n-            move_to_span,\n+        err.help(\n             &format!(\"to prevent the move, \\\n                       use `ref {0}` or `ref mut {0}` to capture value by \\\n                       reference\","}, {"sha": "f65e694939bfc62ffae4f56541e65f709b961443", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -912,8 +912,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         };\n \n         if is_closure {\n-            err.fileline_help(span,\n-                              \"closures behind references must be called via `&mut`\");\n+            err.help(\"closures behind references must be called via `&mut`\");\n         }\n         err.emit();\n     }"}, {"sha": "ead6ab099a88ba5d33037204b39b12065c5cb700", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -255,7 +255,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n                                 ident.node, ty_path);\n-                            fileline_help!(err, p.span,\n+                            help!(err,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n                                 ty_path, ident.node);"}, {"sha": "4bdd926869a5a55f2d655031a713c8037367e884", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -764,8 +764,8 @@ impl LateLintPass for UnconditionalRecursion {\n                 for call in &self_call_spans {\n                     db.span_note(*call, \"recursive call site\");\n                 }\n-                db.fileline_help(sp, \"a `loop` may express intention \\\n-                                      better if this is on purpose\");\n+                db.help(\"a `loop` may express intention \\\n+                         better if this is on purpose\");\n             }\n             db.emit();\n         }"}, {"sha": "de0de219db2f13f45dec8b1c82a1cfeb56754368", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -241,8 +241,8 @@ impl<'a> CrateReader<'a> {\n                                               crate_rustc_version\n                                               .as_ref().map(|s| &**s)\n                                               .unwrap_or(\"an old version of rustc\"));\n-            err.fileline_help(span, \"consider removing the compiled binaries and recompiling \\\n-                                     with your current version of rustc\");\n+            err.help(\"consider removing the compiled binaries and recompiling \\\n+                      with your current version of rustc\");\n             err.emit();\n         }\n     }"}, {"sha": "2316a67d9d3e3c752b02d89dd55ae582ddeb4411", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -346,39 +346,33 @@ impl<'a> Context<'a> {\n         if !self.rejected_via_triple.is_empty() {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n-                err.fileline_note(self.span,\n-                    &format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display()));\n+                err.note(&format!(\"crate `{}`, path #{}, triple {}: {}\",\n+                                  self.ident, i+1, got, path.display()));\n             }\n         }\n         if !self.rejected_via_hash.is_empty() {\n-            err.span_note(self.span, \"perhaps this crate needs \\\n-                                            to be recompiled?\");\n+            err.note(\"perhaps this crate needs to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n-                err.fileline_note(self.span,\n-                    &format!(\"crate `{}` path #{}: {}\",\n-                            self.ident, i+1, path.display()));\n+                err.note(&format!(\"crate `{}` path #{}: {}\",\n+                                  self.ident, i+1, path.display()));\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n-                        err.fileline_note(self.span,\n-                            &format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display()));\n+                        err.note(&format!(\"crate `{}` path #{}: {}\",\n+                                          r.ident, i+1, path.display()));\n                     }\n                 }\n             }\n         }\n         if !self.rejected_via_kind.is_empty() {\n-            err.fileline_help(self.span, \"please recompile this crate using \\\n-                                          --crate-type lib\");\n+            err.help(\"please recompile this crate using --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n             for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n-                err.fileline_note(self.span,\n-                                  &format!(\"crate `{}` path #{}: {}\",\n-                                           self.ident, i+1, path.display()));\n+                err.note(&format!(\"crate `{}` path #{}: {}\",\n+                                  self.ident, i+1, path.display()));\n             }\n         }\n "}, {"sha": "dede4d2a42a53f2349f8e2ec62b4f9658e32bceb", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -198,9 +198,8 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                 let mut err = self.tcx.sess.struct_span_err(\n                     expr.span,\n                     \"const fns are an unstable feature\");\n-                fileline_help!(\n+                help!(\n                     &mut err,\n-                    expr.span,\n                     \"in Nightly builds, add `#![feature(const_fn)]` to the crate \\\n                      attributes to enable\");\n                 err.emit();"}, {"sha": "1bb99eb1a5e0e5fff3ffd1cbeb5547f07cf90c77", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -244,7 +244,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                            E0405,\n                                            \"trait `{}` is not in scope\",\n                                            name);\n-            show_candidates(&mut err, span, &candidates);\n+            show_candidates(&mut err, &candidates);\n             err\n         }\n         ResolutionError::UndeclaredAssociatedType => {\n@@ -312,7 +312,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                            \"{} `{}` is undefined or not in scope\",\n                                            kind,\n                                            name);\n-            show_candidates(&mut err, span, &candidates);\n+            show_candidates(&mut err, &candidates);\n             err\n         }\n         ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(name) => {\n@@ -420,7 +420,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n             match context {\n                 UnresolvedNameContext::Other => { } // no help available\n                 UnresolvedNameContext::PathIsMod(parent) => {\n-                    err.fileline_help(span, &match parent.map(|parent| &parent.node) {\n+                    err.help(&match parent.map(|parent| &parent.node) {\n                         Some(&ExprField(_, ident)) => {\n                             format!(\"To reference an item from the `{module}` module, \\\n                                      use `{module}::{ident}`\",\n@@ -1784,8 +1784,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 // If it's a typedef, give a note\n                 if let Def::TyAlias(..) = path_res.base_def {\n-                    err.fileline_note(trait_path.span,\n-                                  \"`type` aliases cannot be used for traits\");\n+                    err.note(trait_path.span,\n+                             \"`type` aliases cannot be used for traits\");\n \n                     let definition_site = {\n                         let segments = &trait_path.segments;\n@@ -2880,7 +2880,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n                         if self.emit_errors {\n-                            err.fileline_help(expr.span, &msg);\n+                            err.help(&msg);\n                         } else {\n                             err.span_help(expr.span, &msg);\n                         }\n@@ -2922,7 +2922,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                           path_name);\n \n                         if self.emit_errors {\n-                            err.fileline_help(expr.span, &msg);\n+                            err.help(&msg);\n                         } else {\n                             err.span_help(expr.span, &msg);\n                         }\n@@ -3420,7 +3420,6 @@ fn path_names_to_string(path: &Path, depth: usize) -> String {\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n fn show_candidates(session: &mut DiagnosticBuilder,\n-                   span: syntax::codemap::Span,\n                    candidates: &SuggestedCandidates) {\n \n     let paths = &candidates.candidates;\n@@ -3440,26 +3439,23 @@ fn show_candidates(session: &mut DiagnosticBuilder,\n         // behave differently based on how many candidates we have:\n         if !paths.is_empty() {\n             if paths.len() == 1 {\n-                session.fileline_help(\n-                    span,\n+                session.help(\n                     &format!(\"you can import it into scope: `use {};`.\",\n                         &path_strings[0]),\n                 );\n             } else {\n-                session.fileline_help(span, \"you can import several candidates \\\n+                session.help(\"you can import several candidates \\\n                     into scope (`use ...;`):\");\n                 let count = path_strings.len() as isize - MAX_CANDIDATES as isize + 1;\n \n                 for (idx, path_string) in path_strings.iter().enumerate() {\n                     if idx == MAX_CANDIDATES - 1 && count > 1 {\n-                        session.fileline_help(\n-                            span,\n+                        session.help(\n                             &format!(\"  and {} other candidates\", count).to_string(),\n                         );\n                         break;\n                     } else {\n-                        session.fileline_help(\n-                            span,\n+                        session.help(\n                             &format!(\"  `{}`\", path_string).to_string(),\n                         );\n                     }\n@@ -3468,8 +3464,7 @@ fn show_candidates(session: &mut DiagnosticBuilder,\n         }\n     } else {\n         // nothing found:\n-        session.fileline_help(\n-            span,\n+        session.help(\n             &format!(\"no candidates by the name of `{}` found in your \\\n             project; maybe you misspelled the name or forgot to import \\\n             an external crate?\", candidates.name.to_string()),"}, {"sha": "ac7745985e6af4f2e40069dd6275d034d3cf86e9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -206,7 +206,6 @@ pub fn ast_region_to_region(tcx: &TyCtxt, lifetime: &hir::Lifetime)\n \n fn report_elision_failure(\n     db: &mut DiagnosticBuilder,\n-    default_span: Span,\n     params: Vec<ElisionFailureInfo>)\n {\n     let mut m = String::new();\n@@ -243,29 +242,29 @@ fn report_elision_failure(\n     }\n \n     if len == 0 {\n-        fileline_help!(db, default_span,\n-                       \"this function's return type contains a borrowed value, but \\\n-                        there is no value for it to be borrowed from\");\n-        fileline_help!(db, default_span,\n-                       \"consider giving it a 'static lifetime\");\n+        help!(db,\n+                   \"this function's return type contains a borrowed value, but \\\n+                    there is no value for it to be borrowed from\");\n+        help!(db,\n+                   \"consider giving it a 'static lifetime\");\n     } else if !any_lifetimes {\n-        fileline_help!(db, default_span,\n-                       \"this function's return type contains a borrowed value with \\\n-                        an elided lifetime, but the lifetime cannot be derived from \\\n-                        the arguments\");\n-        fileline_help!(db, default_span,\n-                       \"consider giving it an explicit bounded or 'static \\\n-                        lifetime\");\n+        help!(db,\n+                   \"this function's return type contains a borrowed value with \\\n+                    an elided lifetime, but the lifetime cannot be derived from \\\n+                    the arguments\");\n+        help!(db,\n+                   \"consider giving it an explicit bounded or 'static \\\n+                    lifetime\");\n     } else if len == 1 {\n-        fileline_help!(db, default_span,\n-                       \"this function's return type contains a borrowed value, but \\\n-                        the signature does not say which {} it is borrowed from\",\n-                       m);\n+        help!(db,\n+                   \"this function's return type contains a borrowed value, but \\\n+                    the signature does not say which {} it is borrowed from\",\n+                   m);\n     } else {\n-        fileline_help!(db, default_span,\n-                       \"this function's return type contains a borrowed value, but \\\n-                        the signature does not say whether it is borrowed from {}\",\n-                       m);\n+        help!(db,\n+                   \"this function's return type contains a borrowed value, but \\\n+                    the signature does not say whether it is borrowed from {}\",\n+                   m);\n     }\n }\n \n@@ -286,7 +285,7 @@ pub fn opt_ast_region_to_region<'tcx>(\n                 let mut err = struct_span_err!(this.tcx().sess, default_span, E0106,\n                                                \"missing lifetime specifier\");\n                 if let Some(params) = params {\n-                    report_elision_failure(&mut err, default_span, params);\n+                    report_elision_failure(&mut err, params);\n                 }\n                 err.emit();\n                 ty::ReStatic\n@@ -1087,7 +1086,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                 }\n \n                 _ => {\n-                    fileline_help!(&mut err, ty.span,\n+                    help!(&mut err,\n                                \"perhaps you forgot parentheses? (per RFC 438)\");\n                 }\n             }"}, {"sha": "a96b739ebcf9963647ded9a328938a07ebfc9d7f", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -64,8 +64,8 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n         struct_span_err!(tcx.sess, span, E0174,\n                          \"explicit use of unboxed closure method `{}` is experimental\",\n                          method)\n-            .fileline_help(span, \"add `#![feature(unboxed_closures)]` to the crate \\\n-                                  attributes to enable\")\n+            .help(\"add `#![feature(unboxed_closures)]` to the crate \\\n+                  attributes to enable\")\n             .emit();\n     }\n }"}, {"sha": "249ab27ec5956e889f7523b7b522cdf8edcfcabc", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -155,8 +155,7 @@ impl<'tcx> CastCheck<'tcx> {\n                             actual,\n                             fcx.infcx().ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None)\n-                    .fileline_help(self.span,\n-                        &format!(\"cast through {} first\", match e {\n+                    .help(&format!(\"cast through {} first\", match e {\n                             CastError::NeedViaPtr => \"a raw pointer\",\n                             CastError::NeedViaThinPtr => \"a thin pointer\",\n                             CastError::NeedViaInt => \"an integer\",\n@@ -167,7 +166,7 @@ impl<'tcx> CastCheck<'tcx> {\n             }\n             CastError::CastToBool => {\n                 struct_span_err!(fcx.tcx().sess, self.span, E0054, \"cannot cast as `bool`\")\n-                    .fileline_help(self.span, \"compare with zero instead\")\n+                    .help(\"compare with zero instead\")\n                     .emit();\n             }\n             CastError::CastToChar => {\n@@ -202,7 +201,7 @@ impl<'tcx> CastCheck<'tcx> {\n                             actual,\n                             fcx.infcx().ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None)\n-                    .fileline_note(self.span, \"vtable kinds may not match\")\n+                    .note(\"vtable kinds may not match\")\n                     .emit();\n             }\n         }"}, {"sha": "b541ca151c85630633ff40a504d6c01ec8f23607", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -148,9 +148,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if is_fn_ty(&rcvr_ty, &fcx, span) {\n                 macro_rules! report_function {\n                     ($span:expr, $name:expr) => {\n-                        err.fileline_note(\n-                            $span,\n-                            &format!(\"{} is a function, perhaps you wish to call it\",\n+                        err.note(&format!(\"{} is a function, perhaps you wish to call it\",\n                                      $name));\n                     }\n                 }\n@@ -172,8 +170,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n \n             if !static_sources.is_empty() {\n-                err.fileline_note(\n-                    span,\n+                err.note(\n                     \"found the following associated functions; to be used as \\\n                      methods, functions must have a `self` parameter\");\n \n@@ -187,8 +184,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      p))\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n-                err.fileline_note(\n-                    span,\n+                err.note(\n                     &format!(\"the method `{}` exists but the \\\n                              following trait bounds were not satisfied: {}\",\n                              item_name,\n@@ -306,13 +302,12 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"});\n \n-        err.fileline_help(span, &msg[..]);\n+        err.help(&msg[..]);\n \n         for (i, trait_did) in candidates.iter().enumerate() {\n-            err.fileline_help(span,\n-                              &format!(\"candidate #{}: `use {}`\",\n-                                        i + 1,\n-                                        fcx.tcx().item_path_str(*trait_did)));\n+            err.help(&format!(\"candidate #{}: `use {}`\",\n+                              i + 1,\n+                              fcx.tcx().item_path_str(*trait_did)));\n         }\n         return\n     }\n@@ -351,13 +346,12 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n             name = item_name);\n \n-        err.fileline_help(span, &msg[..]);\n+        err.help(&msg[..]);\n \n         for (i, trait_info) in candidates.iter().enumerate() {\n-            err.fileline_help(span,\n-                              &format!(\"candidate #{}: `{}`\",\n-                                        i + 1,\n-                                        fcx.tcx().item_path_str(trait_info.def_id)));\n+            err.help(&format!(\"candidate #{}: `{}`\",\n+                              i + 1,\n+                              fcx.tcx().item_path_str(trait_info.def_id)));\n         }\n     }\n }"}, {"sha": "385f04b8564f5c9883ec3c5002b801fb034a5409", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -2955,9 +2955,9 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                `{}`\", field.node, actual)\n                                    },\n                                    expr_t, None)\n-                .fileline_help(field.span,\n-                               \"maybe a `()` to call it is missing? \\\n-                               If not, try an anonymous function\")\n+                .help(\n+                       \"maybe a `()` to call it is missing? \\\n+                       If not, try an anonymous function\")\n                 .emit();\n             fcx.write_error(expr.id);\n         } else {"}, {"sha": "25a37b6810e4434ec652bab5deb25dfe19d93196", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -501,8 +501,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n-                err.fileline_help(\n-                    span,\n+                err.help(\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n                              param_name,\n                              self.tcx().item_path_str(def_id)));"}, {"sha": "bfb371be663b5af054e70e01c545e87eaef7146d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -510,8 +510,7 @@ fn enforce_trait_manually_implementable(tcx: &TyCtxt, sp: Span, trait_def_id: De\n                                    E0183,\n                                    \"manual implementations of `{}` are experimental\",\n                                    trait_name);\n-    fileline_help!(&mut err, sp,\n-                   \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n+    help!(&mut err, \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n     err.emit();\n }\n "}, {"sha": "c10488a03ef68a977e08b768f2e4b70f35e5d9a2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -1258,9 +1258,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             it.span,\n             \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n              which traits can use parenthetical notation\");\n-        fileline_help!(&mut err, it.span,\n-                   \"add `#![feature(unboxed_closures)]` to \\\n-                    the crate attributes to use it\");\n+        help!(&mut err,\n+            \"add `#![feature(unboxed_closures)]` to \\\n+             the crate attributes to use it\");\n         err.emit();\n     }\n \n@@ -2196,8 +2196,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n                                        pprust::ty_to_string(ast_ty)))\n-                    .fileline_help(ast_ty.span,\n-                                   \"add #![feature(simd_ffi)] to the crate attributes to enable\")\n+                    .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n                     .emit();\n             }\n         };"}, {"sha": "25e0428248df4f7a9a6d03ad9ff75babb52582f5", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -101,9 +101,9 @@ macro_rules! span_help {\n }\n \n #[macro_export]\n-macro_rules! fileline_help {\n-    ($err:expr, $span:expr, $($message:tt)*) => ({\n-        ($err).fileline_help($span, &format!($($message)*));\n+macro_rules! help {\n+    ($err:expr, $($message:tt)*) => ({\n+        ($err).help(&format!($($message)*));\n     })\n }\n "}, {"sha": "303187aeba87dda35452dd5491d01e4abf334c4c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -764,15 +764,14 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn suggest_macro_name(&mut self,\n                               name: &str,\n-                              span: Span,\n                               err: &mut DiagnosticBuilder<'a>) {\n         let names = &self.syntax_env.names;\n         if let Some(suggestion) = find_best_match_for_name(names.iter(), name, None) {\n             if suggestion != name {\n-                err.fileline_help(span, &format!(\"did you mean `{}!`?\", suggestion));\n+                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n             } else {\n-                err.fileline_help(span, &format!(\"have you added the `#[macro_use]` on the \\\n-                                                  module/import?\"));\n+                err.help(&format!(\"have you added the `#[macro_use]` on the \\\n+                                   module/import?\"));\n             }\n         }\n     }"}, {"sha": "e269475d1e2c53688b0709fee8a9c3cb967bfb80", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -770,9 +770,9 @@ pub fn emit_feature_err(diag: &Handler, feature: &str, span: Span, issue: GateIs\n         err.emit();\n         return;\n     }\n-    err.fileline_help(span, &format!(\"add #![feature({})] to the \\\n-                                      crate attributes to enable\",\n-                                     feature));\n+    err.help(&format!(\"add #![feature({})] to the \\\n+                       crate attributes to enable\",\n+                      feature));\n     err.emit();\n }\n "}, {"sha": "3aac12d76ffdf46fa7958dc46c5e94cc082a1fd2", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -69,9 +69,8 @@ impl<'a> Parser<'a> {\n                         self.diagnostic()\n                             .struct_span_err(span,\n                                              \"an inner attribute is not permitted in this context\")\n-                            .fileline_help(span,\n-                                           \"place inner attribute at the top of the module or \\\n-                                            block\")\n+                            .help(\"place inner attribute at the top of the module or \\\n+                                   block\")\n                             .emit()\n                     }\n                     ast::AttrStyle::Inner"}, {"sha": "2a9bcfd658c18a8925e1c6b1308602968549e7fe", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -445,11 +445,11 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n                 sd.struct_span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]))\n-                 .fileline_help(sp, \"valid widths are 32 and 64\")\n+                 .help(\"valid widths are 32 and 64\")\n                  .emit();\n             } else {\n                 sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for float literal\", suf))\n-                  .fileline_help(sp, \"valid suffixes are `f32` and `f64`\")\n+                  .help(\"valid suffixes are `f32` and `f64`\")\n                   .emit();\n             }\n \n@@ -621,12 +621,12 @@ pub fn integer_lit(s: &str,\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n                     sd.struct_span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n                                              &suf[1..]))\n-                      .fileline_help(sp, \"valid widths are 8, 16, 32 and 64\")\n+                      .help(\"valid widths are 8, 16, 32 and 64\")\n                       .emit();\n                 } else {\n                     sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf))\n-                      .fileline_help(sp, \"the suffix must be one of the integral types \\\n-                                      (`u32`, `isize`, etc)\")\n+                      .help(\"the suffix must be one of the integral types \\\n+                             (`u32`, `isize`, etc)\")\n                       .emit();\n                 }\n "}, {"sha": "b9188f5101d3fd71502b0a76c4cd9f3632c0d640", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489a6c95bf747059b28472efc17d39795c6adcad/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=489a6c95bf747059b28472efc17d39795c6adcad", "patch": "@@ -583,7 +583,7 @@ impl<'a> Parser<'a> {\n                 let mut err = self.fatal(&format!(\"expected identifier, found `{}`\",\n                                                   self.this_token_to_string()));\n                 if self.token == token::Underscore {\n-                    err.fileline_note(self.span, \"`_` is a wildcard pattern, not an identifier\");\n+                    err.note(\"`_` is a wildcard pattern, not an identifier\");\n                 }\n                 Err(err)\n             }\n@@ -1082,7 +1082,7 @@ impl<'a> Parser<'a> {\n     }\n     pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> DiagnosticBuilder<'a> {\n         let mut err = self.sess.span_diagnostic.struct_span_fatal(sp, m);\n-        err.fileline_help(sp, help);\n+        err.help(help);\n         err\n     }\n     pub fn bug(&self, m: &str) -> ! {\n@@ -2622,10 +2622,9 @@ impl<'a> Parser<'a> {\n                             Some(f) => f,\n                             None => continue,\n                         };\n-                        err.fileline_help(last_span,\n-                            &format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n-                                    float.trunc() as usize,\n-                                    format!(\".{}\", fstr.splitn(2, \".\").last().unwrap())));\n+                        err.help(&format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n+                                 float.trunc() as usize,\n+                                 format!(\".{}\", fstr.splitn(2, \".\").last().unwrap())));\n                     }\n                     return Err(err);\n \n@@ -3134,7 +3133,7 @@ impl<'a> Parser<'a> {\n                 let mut err = self.diagnostic().struct_span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n                 if op.node == BinOpKind::Lt && *outer_op == AssocOp::Greater {\n-                    err.fileline_help(op_span,\n+                    err.help(\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n                 }\n                 err.emit();\n@@ -4951,13 +4950,13 @@ impl<'a> Parser<'a> {\n                 if is_macro_rules {\n                     self.diagnostic().struct_span_err(span, \"can't qualify macro_rules \\\n                                                              invocation with `pub`\")\n-                                     .fileline_help(span, \"did you mean #[macro_export]?\")\n+                                     .help(\"did you mean #[macro_export]?\")\n                                      .emit();\n                 } else {\n                     self.diagnostic().struct_span_err(span, \"can't qualify macro \\\n                                                              invocation with `pub`\")\n-                                     .fileline_help(span, \"try adjusting the macro to put `pub` \\\n-                                                           inside the invocation\")\n+                                     .help(\"try adjusting the macro to put `pub` \\\n+                                            inside the invocation\")\n                                      .emit();\n                 }\n             }\n@@ -5857,7 +5856,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(keywords::Mut) {\n                 let last_span = self.last_span;\n                 self.diagnostic().struct_span_err(last_span, \"const globals cannot be mutable\")\n-                                 .fileline_help(last_span, \"did you mean to declare a static?\")\n+                                 .help(\"did you mean to declare a static?\")\n                                  .emit();\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;"}]}