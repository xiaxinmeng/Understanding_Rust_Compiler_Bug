{"sha": "48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZmVkY2IzNmZmZGI0MjQ4YzIzOGExYmZhN2E4NDZlNmUyN2NiNjg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-19T05:53:02Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-20T01:38:46Z"}, "message": "extra: remove sort in favour of the std method.\n\nFixes #9676.", "tree": {"sha": "1c5efc1bd2871cbbb038bf2f2999d5192bf28dd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c5efc1bd2871cbbb038bf2f2999d5192bf28dd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "html_url": "https://github.com/rust-lang/rust/commit/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "721609e4ae50142e631e4c9d190a6065fd3f63f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/721609e4ae50142e631e4c9d190a6065fd3f63f7", "html_url": "https://github.com/rust-lang/rust/commit/721609e4ae50142e631e4c9d190a6065fd3f63f7"}], "stats": {"total": 1294, "additions": 47, "deletions": 1247}, "files": [{"sha": "75795d13991592122338393328e9c3595bf19d8d", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -28,8 +28,6 @@ use std::io;\n use std::io::fs;\n use std::path::is_sep;\n \n-use sort;\n-\n /**\n  * An iterator that yields Paths from the filesystem that match a particular\n  * pattern - see the `glob` function for more details.\n@@ -149,9 +147,8 @@ impl Iterator<Path> for GlobIterator {\n \n fn list_dir_sorted(path: &Path) -> ~[Path] {\n     match io::result(|| fs::readdir(path)) {\n-        Ok(children) => {\n-            let mut children = children;\n-            sort::quick_sort(children, |p1, p2| p2.filename() <= p1.filename());\n+        Ok(mut children) => {\n+            children.sort(|p1, p2| p2.filename() <= p1.filename());\n             children\n         }\n         Err(..) => ~[]\n@@ -771,4 +768,3 @@ mod test {\n         assert!(Pattern::new(\"a/b\").matches_path(&Path::new(\"a/b\")));\n     }\n }\n-"}, {"sha": "51e105d23f78297f5766073e6f3a54db47b622bd", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -61,8 +61,6 @@ pub mod ringbuf;\n pub mod priority_queue;\n pub mod smallintmap;\n \n-pub mod sort;\n-\n pub mod dlist;\n pub mod treemap;\n pub mod btree;"}, {"sha": "d2cace5e6f4c6c0f7a679a40ac9d05a2e8c278dd", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -213,7 +213,6 @@ impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n \n #[cfg(test)]\n mod tests {\n-    use sort::merge_sort;\n     use priority_queue::PriorityQueue;\n \n     #[test]\n@@ -231,7 +230,8 @@ mod tests {\n     #[test]\n     fn test_top_and_pop() {\n         let data = ~[2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n-        let mut sorted = merge_sort(data, |x, y| x.le(y));\n+        let mut sorted = data.clone();\n+        sorted.sort(|x, y| x.le(y));\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n             assert_eq!(heap.top(), sorted.last());\n@@ -311,11 +311,14 @@ mod tests {\n         assert_eq!(heap.len(), 5);\n     }\n \n-    fn check_to_vec(data: ~[int]) {\n+    fn check_to_vec(mut data: ~[int]) {\n         let heap = PriorityQueue::from_vec(data.clone());\n-        assert_eq!(merge_sort(heap.clone().to_vec(), |x, y| x.le(y)),\n-                   merge_sort(data, |x, y| x.le(y)));\n-        assert_eq!(heap.to_sorted_vec(), merge_sort(data, |x, y| x.le(y)));\n+        let mut v = heap.clone().to_vec();\n+        v.sort(|x, y| x.le(y));\n+        data.sort(|x, y| x.le(y));\n+\n+        assert_eq!(v, data);\n+        assert_eq!(heap.to_sorted_vec(), data);\n     }\n \n     #[test]"}, {"sha": "bba26a16d4dadc4dc9d1dc63a41040889b20b10d", "filename": "src/libextra/sort.rs", "status": "removed", "additions": 0, "deletions": 1181, "changes": 1181, "blob_url": "https://github.com/rust-lang/rust/blob/721609e4ae50142e631e4c9d190a6065fd3f63f7/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721609e4ae50142e631e4c9d190a6065fd3f63f7/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=721609e4ae50142e631e4c9d190a6065fd3f63f7", "patch": "@@ -1,1181 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Sorting methods\n-\n-\n-use std::cmp::{Eq, Ord};\n-use std::util::swap;\n-use std::vec;\n-\n-type Le<'a, T> = 'a |v1: &T, v2: &T| -> bool;\n-\n-/**\n- * Merge sort. Returns a new vector containing the sorted list.\n- *\n- * Has worst case O(n log n) performance, best case O(n), but\n- * is not space efficient. This is a stable sort.\n- */\n-pub fn merge_sort<T:Clone>(v: &[T], le: Le<T>) -> ~[T] {\n-    type Slice = (uint, uint);\n-\n-    return merge_sort_(v, (0u, v.len()), le);\n-\n-    fn merge_sort_<T:Clone>(v: &[T], slice: Slice, le: Le<T>) -> ~[T] {\n-        let begin = slice.first();\n-        let end = slice.second();\n-\n-        let v_len = end - begin;\n-        if v_len == 0 { return ~[]; }\n-        if v_len == 1 { return ~[v[begin].clone()]; }\n-\n-        let mid = v_len / 2 + begin;\n-        let a = (begin, mid);\n-        let b = (mid, end);\n-        return merge(|x,y| le(x,y), merge_sort_(v, a, |x,y| le(x,y)),\n-                                    merge_sort_(v, b, |x,y| le(x,y)));\n-    }\n-\n-    fn merge<T:Clone>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n-        let mut rs = vec::with_capacity(a.len() + b.len());\n-        let a_len = a.len();\n-        let mut a_ix = 0;\n-        let b_len = b.len();\n-        let mut b_ix = 0;\n-        while a_ix < a_len && b_ix < b_len {\n-            if le(&a[a_ix], &b[b_ix]) {\n-                rs.push(a[a_ix].clone());\n-                a_ix += 1;\n-            } else {\n-                rs.push(b[b_ix].clone());\n-                b_ix += 1;\n-            }\n-        }\n-        rs.push_all(a.slice(a_ix, a_len));\n-        rs.push_all(b.slice(b_ix, b_len));\n-        rs\n-    }\n-}\n-\n-fn part<T>(arr: &mut [T], left: uint,\n-           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    arr.swap(pivot, right);\n-    let mut storage_index: uint = left;\n-    let mut i: uint = left;\n-    while i < right {\n-        if compare_func(&arr[i], &arr[right]) {\n-            arr.swap(i, storage_index);\n-            storage_index += 1;\n-        }\n-        i += 1;\n-    }\n-    arr.swap(storage_index, right);\n-    return storage_index;\n-}\n-\n-fn qsort<T>(arr: &mut [T], left: uint,\n-            right: uint, compare_func: Le<T>) {\n-    if right > left {\n-        let pivot = (left + right) / 2u;\n-        let new_pivot = part::<T>(arr, left, right, pivot, |x,y| compare_func(x,y));\n-        if new_pivot != 0u {\n-            // Need to do this check before recursing due to overflow\n-            qsort::<T>(arr, left, new_pivot - 1u, |x,y| compare_func(x,y));\n-        }\n-        qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n-    }\n-}\n-\n-/**\n- * Quicksort. Sorts a mut vector in place.\n- *\n- * Has worst case O(n^2) performance, average case O(n log n).\n- * This is an unstable sort.\n- */\n-pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n-    let len = arr.len();\n-    if len == 0u { return; }\n-    qsort::<T>(arr, 0u, len - 1u, compare_func);\n-}\n-\n-fn qsort3<T:Clone + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n-    if right <= left { return; }\n-    let v: T = arr[right].clone();\n-    let mut i: int = left - 1;\n-    let mut j: int = right;\n-    let mut p: int = i;\n-    let mut q: int = j;\n-    loop {\n-        i += 1;\n-        while arr[i] < v { i += 1; }\n-        j -= 1;\n-        while v < arr[j] {\n-            if j == left { break; }\n-            j -= 1;\n-        }\n-        if i >= j { break; }\n-        arr.swap(i as uint, j as uint);\n-        if arr[i] == v {\n-            p += 1;\n-            arr.swap(p as uint, i as uint);\n-        }\n-        if v == arr[j] {\n-            q -= 1;\n-            arr.swap(j as uint, q as uint);\n-        }\n-    }\n-    arr.swap(i as uint, right as uint);\n-    j = i - 1;\n-    i += 1;\n-    let mut k: int = left;\n-    while k < p {\n-        arr.swap(k as uint, j as uint);\n-        k += 1;\n-        j -= 1;\n-        if k == arr.len() as int { break; }\n-    }\n-    k = right - 1;\n-    while k > q {\n-        arr.swap(i as uint, k as uint);\n-        k -= 1;\n-        i += 1;\n-        if k == 0 { break; }\n-    }\n-    qsort3::<T>(arr, left, j);\n-    qsort3::<T>(arr, i, right);\n-}\n-\n-/**\n- * Fancy quicksort. Sorts a mut vector in place.\n- *\n- * Based on algorithm presented by ~[Sedgewick and Bentley]\n- * (http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n- * According to these slides this is the algorithm of choice for\n- * 'randomly ordered keys, abstract compare' & 'small number of key values'.\n- *\n- * This is an unstable sort.\n- */\n-pub fn quick_sort3<T:Clone + Ord + Eq>(arr: &mut [T]) {\n-    if arr.len() <= 1 { return; }\n-    let len = arr.len(); // FIXME(#5074) nested calls\n-    qsort3(arr, 0, (len - 1) as int);\n-}\n-\n-#[allow(missing_doc)]\n-pub trait Sort {\n-    fn qsort(self);\n-}\n-\n-impl<'a, T:Clone + Ord + Eq> Sort for &'a mut [T] {\n-    fn qsort(self) { quick_sort3(self); }\n-}\n-\n-static MIN_MERGE: uint = 64;\n-static MIN_GALLOP: uint = 7;\n-\n-#[allow(missing_doc)]\n-pub fn tim_sort<T:Clone + Ord>(array: &mut [T]) {\n-    let size = array.len();\n-    if size < 2 {\n-        return;\n-    }\n-\n-    if size < MIN_MERGE {\n-        let init_run_len = count_run_ascending(array);\n-        binarysort(array, init_run_len);\n-        return;\n-    }\n-\n-    let mut ms = MergeState();\n-    let min_run = min_run_length(size);\n-\n-    let mut idx = 0;\n-    let mut remaining = size;\n-    loop {\n-        let run_len: uint = {\n-            // This scope contains the slice `arr` here:\n-            let arr = array.mut_slice(idx, size);\n-            let mut run_len: uint = count_run_ascending(arr);\n-\n-            if run_len < min_run {\n-                let force = if remaining <= min_run {remaining} else {min_run};\n-                let slice = arr.mut_slice(0, force);\n-                binarysort(slice, run_len);\n-                run_len = force;\n-            }\n-\n-            run_len\n-        };\n-\n-        ms.push_run(idx, run_len);\n-        ms.merge_collapse(array);\n-\n-        idx += run_len;\n-        remaining -= run_len;\n-        if remaining == 0 { break; }\n-    }\n-\n-    ms.merge_force_collapse(array);\n-}\n-\n-fn binarysort<T:Clone + Ord>(array: &mut [T], start: uint) {\n-    let size = array.len();\n-    let mut start = start;\n-    assert!(start <= size);\n-\n-    if start == 0 { start += 1; }\n-\n-    while start < size {\n-        let pivot = array[start].clone();\n-        let mut left = 0;\n-        let mut right = start;\n-        assert!(left <= right);\n-\n-        while left < right {\n-            let mid = (left + right) >> 1;\n-            if pivot < array[mid] {\n-                right = mid;\n-            } else {\n-                left = mid+1;\n-            }\n-        }\n-        assert_eq!(left, right);\n-        let n = start-left;\n-\n-        shift_vec(array, left+1, left, n);\n-        array[left] = pivot;\n-        start += 1;\n-    }\n-}\n-\n-// Reverse the order of elements in a slice, in place\n-fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n-    let mut i = start;\n-    while i < end / 2 {\n-        v.swap(i, end - i - 1);\n-        i += 1;\n-    }\n-}\n-\n-fn min_run_length(n: uint) -> uint {\n-    let mut n = n;\n-    let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n-\n-    while n >= MIN_MERGE {\n-        r |= n & 1;\n-        n >>= 1;\n-    }\n-    return n + r;\n-}\n-\n-fn count_run_ascending<T:Clone + Ord>(array: &mut [T]) -> uint {\n-    let size = array.len();\n-    assert!(size > 0);\n-    if size == 1 { return 1; }\n-\n-    let mut run = 2;\n-    if array[1] < array[0] {\n-        while run < size && array[run] < array[run-1] {\n-            run += 1;\n-        }\n-        reverse_slice(array, 0, run);\n-    } else {\n-        while run < size && array[run] >= array[run-1] {\n-            run += 1;\n-        }\n-    }\n-\n-    return run;\n-}\n-\n-fn gallop_left<T:Clone + Ord>(key: &T,\n-                             array: &[T],\n-                             hint: uint)\n-                          -> uint {\n-    let size = array.len();\n-    assert!(size != 0 && hint < size);\n-\n-    let mut last_ofs = 0;\n-    let mut ofs = 1;\n-\n-    if *key > array[hint] {\n-        // Gallop right until array[hint+last_ofs] < key <= array[hint+ofs]\n-        let max_ofs = size - hint;\n-        while ofs < max_ofs && *key > array[hint+ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n-        }\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        last_ofs += hint;\n-        ofs += hint;\n-    } else {\n-        let max_ofs = hint + 1;\n-        while ofs < max_ofs && *key <= array[hint-ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n-        }\n-\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        let tmp = last_ofs;\n-        last_ofs = hint - ofs;\n-        ofs = hint - tmp;\n-    }\n-    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n-\n-    last_ofs += 1;\n-    while last_ofs < ofs {\n-        let m = last_ofs + ((ofs - last_ofs) >> 1);\n-        if *key > array[m] {\n-            last_ofs = m+1;\n-        } else {\n-            ofs = m;\n-        }\n-    }\n-    assert_eq!(last_ofs, ofs);\n-    return ofs;\n-}\n-\n-fn gallop_right<T:Clone + Ord>(key: &T,\n-                              array: &[T],\n-                              hint: uint)\n-                           -> uint {\n-    let size = array.len();\n-    assert!(size != 0 && hint < size);\n-\n-    let mut last_ofs = 0;\n-    let mut ofs = 1;\n-\n-    if *key >= array[hint] {\n-        // Gallop right until array[hint+last_ofs] <= key < array[hint+ofs]\n-        let max_ofs = size - hint;\n-        while ofs < max_ofs && *key >= array[hint+ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; }\n-        }\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        last_ofs += hint;\n-        ofs += hint;\n-    } else {\n-        // Gallop left until array[hint-ofs] <= key < array[hint-last_ofs]\n-        let max_ofs = hint + 1;\n-        while ofs < max_ofs && *key < array[hint-ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; }\n-        }\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        let tmp = last_ofs;\n-        last_ofs = hint - ofs;\n-        ofs = hint - tmp;\n-    }\n-\n-    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n-\n-    last_ofs += 1;\n-    while last_ofs < ofs {\n-        let m = last_ofs + ((ofs - last_ofs) >> 1);\n-\n-        if *key >= array[m] {\n-            last_ofs = m + 1;\n-        } else {\n-            ofs = m;\n-        }\n-    }\n-    assert_eq!(last_ofs, ofs);\n-    return ofs;\n-}\n-\n-struct RunState {\n-    base: uint,\n-    len: uint,\n-}\n-\n-struct MergeState<T> {\n-    min_gallop: uint,\n-    runs: ~[RunState],\n-}\n-\n-// Fixme (#3853) Move into MergeState\n-fn MergeState<T>() -> MergeState<T> {\n-    MergeState {\n-        min_gallop: MIN_GALLOP,\n-        runs: ~[],\n-    }\n-}\n-\n-impl<T:Clone + Ord> MergeState<T> {\n-    fn push_run(&mut self, run_base: uint, run_len: uint) {\n-        let tmp = RunState{base: run_base, len: run_len};\n-        self.runs.push(tmp);\n-    }\n-\n-    fn merge_at(&mut self, n: uint, array: &mut [T]) {\n-        let size = self.runs.len();\n-        assert!(size >= 2);\n-        assert!(n == size-2 || n == size-3);\n-\n-        let mut b1 = self.runs[n].base;\n-        let mut l1 = self.runs[n].len;\n-        let b2 = self.runs[n+1].base;\n-        let l2 = self.runs[n+1].len;\n-\n-        assert!(l1 > 0 && l2 > 0);\n-        assert_eq!(b1 + l1, b2);\n-\n-        self.runs[n].len = l1 + l2;\n-        if n == size-3 {\n-            self.runs[n+1].base = self.runs[n+2].base;\n-            self.runs[n+1].len = self.runs[n+2].len;\n-        }\n-\n-        let k = { // constrain lifetime of slice below\n-            let slice = array.slice(b1, b1+l1);\n-            gallop_right(&array[b2], slice, 0)\n-        };\n-        b1 += k;\n-        l1 -= k;\n-        if l1 != 0 {\n-            let l2 = { // constrain lifetime of slice below\n-                let slice = array.slice(b2, b2+l2);\n-                gallop_left(&array[b1+l1-1],slice,l2-1)\n-            };\n-            if l2 > 0 {\n-                if l1 <= l2 {\n-                    self.merge_lo(array, b1, l1, b2, l2);\n-                } else {\n-                    self.merge_hi(array, b1, l1, b2, l2);\n-                }\n-            }\n-        }\n-        self.runs.pop();\n-    }\n-\n-    fn merge_lo(&mut self, array: &mut [T], base1: uint, len1: uint,\n-                base2: uint, len2: uint) {\n-        assert!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n-\n-        let mut tmp = array.slice(base1, base1 + len1).to_owned();\n-\n-        let mut c1 = 0;\n-        let mut c2 = base2;\n-        let mut dest = base1;\n-        let mut len1 = len1;\n-        let mut len2 = len2;\n-\n-        array.swap(dest, c2);\n-        dest += 1; c2 += 1; len2 -= 1;\n-\n-        if len2 == 0 {\n-            copy_vec(array, dest, tmp.slice(0, len1));\n-            return;\n-        }\n-        if len1 == 1 {\n-            shift_vec(array, dest, c2, len2);\n-            swap(&mut tmp[c1], &mut array[dest+len2]);\n-            return;\n-        }\n-\n-        let mut min_gallop = self.min_gallop;\n-        loop {\n-            let mut count1 = 0;\n-            let mut count2 = 0;\n-            let mut break_outer = false;\n-\n-            loop {\n-                assert!(len1 > 1 && len2 != 0);\n-                if array[c2] < tmp[c1] {\n-                    array.swap(dest, c2);\n-                    dest += 1; c2 += 1; len2 -= 1;\n-                    count2 += 1; count1 = 0;\n-                    if len2 == 0 {\n-                        break_outer = true;\n-                    }\n-                } else {\n-                    swap(&mut array[dest], &mut tmp[c1]);\n-                    dest += 1; c1 += 1; len1 -= 1;\n-                    count1 += 1; count2 = 0;\n-                    if len1 == 1 {\n-                        break_outer = true;\n-                    }\n-                }\n-                if break_outer || ((count1 | count2) >= min_gallop) {\n-                    break;\n-                }\n-            }\n-            if break_outer { break; }\n-\n-            // Start to gallop\n-            loop {\n-                assert!(len1 > 1 && len2 != 0);\n-\n-                count1 = {\n-                    let tmp_view = tmp.slice(c1, c1+len1);\n-                    gallop_right(&array[c2], tmp_view, 0)\n-                };\n-                if count1 != 0 {\n-                    copy_vec(array, dest, tmp.slice(c1, c1+count1));\n-                    dest += count1; c1 += count1; len1 -= count1;\n-                    if len1 <= 1 { break_outer = true; break; }\n-                }\n-                array.swap(dest, c2);\n-                dest += 1; c2 += 1; len2 -= 1;\n-                if len2 == 0 { break_outer = true; break; }\n-\n-                count2 = {\n-                    let tmp_view = array.slice(c2, c2+len2);\n-                    gallop_left(&tmp[c1], tmp_view, 0)\n-                };\n-                if count2 != 0 {\n-                    shift_vec(array, dest, c2, count2);\n-                    dest += count2; c2 += count2; len2 -= count2;\n-                    if len2 == 0 { break_outer = true; break; }\n-                }\n-                swap(&mut array[dest], &mut tmp[c1]);\n-                dest += 1; c1 += 1; len1 -= 1;\n-                if len1 == 1 { break_outer = true; break; }\n-                min_gallop -= 1;\n-                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n-                    break;\n-                }\n-            }\n-            if break_outer { break; }\n-            if min_gallop < 0 { min_gallop = 0; }\n-            min_gallop += 2; // Penalize for leaving gallop\n-        }\n-        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n-\n-        if len1 == 1 {\n-            assert!(len2 > 0);\n-            shift_vec(array, dest, c2, len2);\n-            swap(&mut array[dest+len2], &mut tmp[c1]);\n-        } else if len1 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n-        } else {\n-            assert_eq!(len2, 0);\n-            assert!(len1 > 1);\n-            copy_vec(array, dest, tmp.slice(c1, c1+len1));\n-        }\n-    }\n-\n-    fn merge_hi(&mut self, array: &mut [T], base1: uint, len1: uint,\n-                base2: uint, len2: uint) {\n-        assert!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n-\n-        let mut tmp = array.slice(base2, base2 + len2).to_owned();\n-\n-        let mut c1 = base1 + len1 - 1;\n-        let mut c2 = len2 - 1;\n-        let mut dest = base2 + len2 - 1;\n-        let mut len1 = len1;\n-        let mut len2 = len2;\n-\n-        array.swap(dest, c1);\n-        dest -= 1; c1 -= 1; len1 -= 1;\n-\n-        if len1 == 0 {\n-            copy_vec(array, dest-(len2-1), tmp.slice(0, len2));\n-            return;\n-        }\n-        if len2 == 1 {\n-            dest -= len1;\n-            c1 -= len1;\n-            shift_vec(array, dest+1, c1+1, len1);\n-            swap(&mut array[dest], &mut tmp[c2]);\n-            return;\n-        }\n-\n-        let mut min_gallop = self.min_gallop;\n-        loop {\n-            let mut count1 = 0;\n-            let mut count2 = 0;\n-            let mut break_outer = false;\n-\n-            loop {\n-                assert!(len1 != 0 && len2 > 1);\n-                if tmp[c2] < array[c1] {\n-                    array.swap(dest, c1);\n-                    dest -= 1; c1 -= 1; len1 -= 1;\n-                    count1 += 1; count2 = 0;\n-                    if len1 == 0 {\n-                        break_outer = true;\n-                    }\n-                } else {\n-                    swap(&mut array[dest], &mut tmp[c2]);\n-                    dest -= 1; c2 -= 1; len2 -= 1;\n-                    count2 += 1; count1 = 0;\n-                    if len2 == 1 {\n-                        break_outer = true;\n-                    }\n-                }\n-                if break_outer || ((count1 | count2) >= min_gallop) {\n-                    break;\n-                }\n-            }\n-            if break_outer { break; }\n-\n-            // Start to gallop\n-            loop {\n-                assert!(len2 > 1 && len1 != 0);\n-\n-                { // constrain scope of tmp_view:\n-                    let tmp_view = array.mut_slice(base1, base1+len1);\n-                    count1 = len1 - gallop_right(\n-                        &tmp[c2], tmp_view, len1-1);\n-                }\n-\n-                if count1 != 0 {\n-                    dest -= count1; c1 -= count1; len1 -= count1;\n-                    shift_vec(array, dest+1, c1+1, count1);\n-                    if len1 == 0 { break_outer = true; break; }\n-                }\n-\n-                swap(&mut array[dest], &mut tmp[c2]);\n-                dest -= 1; c2 -= 1; len2 -= 1;\n-                if len2 == 1 { break_outer = true; break; }\n-\n-                let count2;\n-                { // constrain scope of tmp_view\n-                    let tmp_view = tmp.mut_slice(0, len2);\n-                    count2 = len2 - gallop_left(&array[c1],\n-                                                tmp_view,\n-                                                len2-1);\n-                }\n-\n-                if count2 != 0 {\n-                    dest -= count2; c2 -= count2; len2 -= count2;\n-                    copy_vec(array, dest+1, tmp.slice(c2+1, c2+1+count2));\n-                    if len2 <= 1 { break_outer = true; break; }\n-                }\n-                array.swap(dest, c1);\n-                dest -= 1; c1 -= 1; len1 -= 1;\n-                if len1 == 0 { break_outer = true; break; }\n-                min_gallop -= 1;\n-                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n-                    break;\n-                }\n-            }\n-\n-            if break_outer { break; }\n-            if min_gallop < 0 { min_gallop = 0; }\n-            min_gallop += 2; // Penalize for leaving gallop\n-        }\n-        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n-\n-        if len2 == 1 {\n-            assert!(len1 > 0);\n-            dest -= len1;\n-            c1 -= len1;\n-            shift_vec(array, dest+1, c1+1, len1);\n-            swap(&mut array[dest], &mut tmp[c2]);\n-        } else if len2 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n-        } else {\n-            assert_eq!(len1, 0);\n-            assert!(len2 != 0);\n-            copy_vec(array, dest-(len2-1), tmp.slice(0, len2));\n-        }\n-    }\n-\n-    fn merge_collapse(&mut self, array: &mut [T]) {\n-        while self.runs.len() > 1 {\n-            let mut n = self.runs.len()-2;\n-            if n > 0 &&\n-                self.runs[n-1].len <= self.runs[n].len + self.runs[n+1].len\n-            {\n-                if self.runs[n-1].len < self.runs[n+1].len { n -= 1; }\n-            } else if self.runs[n].len <= self.runs[n+1].len {\n-                /* keep going */\n-            } else {\n-                break;\n-            }\n-            self.merge_at(n, array);\n-        }\n-    }\n-\n-    fn merge_force_collapse(&mut self, array: &mut [T]) {\n-        while self.runs.len() > 1 {\n-            let mut n = self.runs.len()-2;\n-            if n > 0 {\n-                if self.runs[n-1].len < self.runs[n+1].len {\n-                    n -= 1;\n-                }\n-            }\n-            self.merge_at(n, array);\n-        }\n-    }\n-}\n-\n-#[inline]\n-fn copy_vec<T:Clone>(dest: &mut [T],\n-                    s1: uint,\n-                    from: &[T]) {\n-    assert!(s1+from.len() <= dest.len());\n-\n-    for (i, v) in from.iter().enumerate() {\n-        dest[s1+i] = (*v).clone();\n-    }\n-}\n-\n-#[inline]\n-fn shift_vec<T:Clone>(dest: &mut [T], s1: uint, s2: uint, len: uint) {\n-    assert!(s1+len <= dest.len());\n-\n-    let tmp = dest.slice(s2, s2+len).to_owned();\n-    copy_vec(dest, s1, tmp);\n-}\n-\n-#[cfg(test)]\n-mod test_qsort3 {\n-    use sort::*;\n-\n-\n-    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = v1.len();\n-        quick_sort3::<int>(v1);\n-        let mut i = 0;\n-        while i < len {\n-            assert_eq!(v2[i], v1[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1 = ~[1, 1, 1];\n-            let mut v2 = ~[1, 1, 1];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1: ~[int] = ~[];\n-            let mut v2: ~[int] = ~[];\n-            check_sort(v1, v2);\n-        }\n-        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let mut v1 = ~[9, 3, 3, 3, 9];\n-            let mut v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_qsort {\n-    use sort::*;\n-\n-    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = v1.len();\n-        fn leual(a: &int, b: &int) -> bool { *a <= *b }\n-        quick_sort::<int>(v1, leual);\n-        let mut i = 0u;\n-        while i < len {\n-            // debug!(v2[i]);\n-            assert_eq!(v2[i], v1[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1 = ~[1, 1, 1];\n-            let mut v2 = ~[1, 1, 1];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1: ~[int] = ~[];\n-            let mut v2: ~[int] = ~[];\n-            check_sort(v1, v2);\n-        }\n-        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let mut v1 = ~[9, 3, 3, 3, 9];\n-            let mut v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-\n-    // Regression test for #750\n-    #[test]\n-    fn test_simple() {\n-        let mut names = ~[2, 1, 3];\n-\n-        let expected = ~[1, 2, 3];\n-\n-        quick_sort(names, |x, y| *x < *y);\n-\n-        let immut_names = names;\n-\n-        for (&a, &b) in expected.iter().zip(immut_names.iter()) {\n-            debug!(\"{} {}\", a, b);\n-            assert_eq!(a, b);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    use sort::*;\n-\n-    fn check_sort(v1: &[int], v2: &[int]) {\n-        let len = v1.len();\n-        fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let f = le;\n-        let v3 = merge_sort::<int>(v1, f);\n-        let mut i = 0u;\n-        while i < len {\n-            debug!(\"{:?}\", v3[i]);\n-            assert_eq!(v3[i], v2[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        { let v1 = ~[1, 1, 1]; let v2 = ~[1, 1, 1]; check_sort(v1, v2); }\n-        { let v1:~[int] = ~[]; let v2:~[int] = ~[]; check_sort(v1, v2); }\n-        { let v1 = ~[9]; let v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let v1 = ~[9, 3, 3, 3, 9];\n-            let v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_merge_sort_mutable() {\n-        fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let v1 = ~[3, 2, 1];\n-        let v2 = merge_sort(v1, le);\n-        assert_eq!(v2, ~[1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_merge_sort_stability() {\n-        // tjc: funny that we have to use parens\n-        fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n-        {\n-            let x = x.to_ascii().to_lower().into_str();\n-            let y = y.to_ascii().to_lower().into_str();\n-            x <= y\n-        }\n-\n-        let names1 = ~[\"joe bob\", \"Joe Bob\", \"Jack Brown\", \"JOE Bob\",\n-                       \"Sally Mae\", \"JOE BOB\", \"Alex Andy\"];\n-        let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n-                       \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n-        let names3 = merge_sort(names1, ile);\n-        assert_eq!(names3, names2);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_tim_sort {\n-\n-    use sort::tim_sort;\n-    use std::rand::Rng;\n-    use std::rand;\n-    use std::vec;\n-\n-    #[deriving(Clone)]\n-    struct CVal {\n-        val: f64,\n-    }\n-\n-    impl Ord for CVal {\n-        fn lt(&self, other: &CVal) -> bool {\n-            let mut rng = rand::rng();\n-            if rng.gen::<f64>() > 0.995 {\n-                fail!(\"It's happening!!!\");\n-            }\n-            (*self).val < other.val\n-        }\n-        fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n-        fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n-        fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n-    }\n-\n-    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = v1.len();\n-        tim_sort::<int>(v1);\n-        let mut i = 0u;\n-        while i < len {\n-            // debug!(v2[i]);\n-            assert_eq!(v2[i], v1[i]);\n-            i += 1u;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1 = ~[1, 1, 1];\n-            let mut v2 = ~[1, 1, 1];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1: ~[int] = ~[];\n-            let mut v2: ~[int] = ~[];\n-            check_sort(v1, v2);\n-        }\n-        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let mut v1 = ~[9, 3, 3, 3, 9];\n-            let mut v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[cfg(unix)]\n-    fn crash_test() {\n-        let mut rng = rand::rng();\n-        let mut arr = vec::from_fn(1000, |_i| {\n-            CVal { val: rng.gen() }\n-        });\n-\n-        tim_sort(arr);\n-        fail!(\"Guarantee the fail\");\n-    }\n-\n-    #[deriving(Clone)]\n-    struct DVal {\n-        val: uint,\n-    }\n-\n-    impl Ord for DVal {\n-        fn lt(&self, _x: &DVal) -> bool { true }\n-        fn le(&self, _x: &DVal) -> bool { true }\n-        fn gt(&self, _x: &DVal) -> bool { true }\n-        fn ge(&self, _x: &DVal) -> bool { true }\n-    }\n-\n-    #[test]\n-    fn test_bad_Ord_impl() {\n-        let mut rng = rand::rng();\n-        let mut arr = vec::from_fn(500, |_i| {\n-            DVal { val: rng.gen() }\n-        });\n-\n-        tim_sort(arr);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod big_tests {\n-\n-    use sort::*;\n-\n-    use std::rand::Rng;\n-    use std::rand;\n-    use std::vec;\n-\n-    #[test]\n-    fn test_unique() {\n-        let low = 5;\n-        let high = 10;\n-        tabulate_unique(low, high);\n-    }\n-\n-    #[test]\n-    fn test_managed() {\n-        let low = 5;\n-        let high = 10;\n-        tabulate_managed(low, high);\n-    }\n-\n-    fn multiplyVec<T:Clone>(arr: &[T], num: uint) -> ~[T] {\n-        let size = arr.len();\n-        let res = vec::from_fn(num, |i| {\n-            arr[i % size].clone()\n-        });\n-        res\n-    }\n-\n-    fn makeRange(n: uint) -> ~[uint] {\n-        let one = vec::from_fn(n, |i| i);\n-        let mut two = one.clone();\n-        two.reverse();\n-        vec::append(two, one)\n-    }\n-\n-    fn tabulate_unique(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &[T]) {\n-            for i in range(0u, arr.len() - 1) {\n-                if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n-                }\n-            }\n-        }\n-\n-        let mut rng = rand::rng();\n-\n-        for i in range(lo, hi) {\n-            let n = 1 << i;\n-            let mut arr: ~[f64] = vec::from_fn(n, |_i| {\n-                rng.gen()\n-            });\n-\n-            tim_sort(arr); // *sort\n-            isSorted(arr);\n-\n-            arr.reverse();\n-            tim_sort(arr); // \\sort\n-            isSorted(arr);\n-\n-            tim_sort(arr); // /sort\n-            isSorted(arr);\n-\n-            3.times(|| {\n-                let i1 = rng.gen_range(0u, n);\n-                let i2 = rng.gen_range(0u, n);\n-                arr.swap(i1, i2);\n-            });\n-            tim_sort(arr); // 3sort\n-            isSorted(arr);\n-\n-            if n >= 10 {\n-                let size = arr.len();\n-                let mut idx = 1;\n-                while idx <= 10 {\n-                    arr[size-idx] = rng.gen();\n-                    idx += 1;\n-                }\n-            }\n-            tim_sort(arr); // +sort\n-            isSorted(arr);\n-\n-            (n/100).times(|| {\n-                let idx = rng.gen_range(0u, n);\n-                arr[idx] = rng.gen();\n-            });\n-            tim_sort(arr);\n-            isSorted(arr);\n-\n-            let mut arr = if n > 4 {\n-                let part = arr.slice(0, 4);\n-                multiplyVec(part, n)\n-            } else { arr };\n-            tim_sort(arr); // ~sort\n-            isSorted(arr);\n-\n-            let mut arr = vec::from_elem(n, -0.5);\n-            tim_sort(arr); // =sort\n-            isSorted(arr);\n-\n-            let half = n / 2;\n-            let mut arr = makeRange(half).map(|i| *i as f64);\n-            tim_sort(arr); // !sort\n-            isSorted(arr);\n-        }\n-    }\n-\n-    fn tabulate_managed(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &[@T]) {\n-            for i in range(0u, arr.len() - 1) {\n-                if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n-                }\n-            }\n-        }\n-\n-        let mut rng = rand::rng();\n-\n-        for i in range(lo, hi) {\n-            let n = 1 << i;\n-            let arr: ~[@f64] = vec::from_fn(n, |_i| {\n-                @rng.gen()\n-            });\n-            let mut arr = arr;\n-\n-            tim_sort(arr); // *sort\n-            isSorted(arr);\n-\n-            arr.reverse();\n-            tim_sort(arr); // \\sort\n-            isSorted(arr);\n-\n-            tim_sort(arr); // /sort\n-            isSorted(arr);\n-\n-            3.times(|| {\n-                let i1 = rng.gen_range(0u, n);\n-                let i2 = rng.gen_range(0u, n);\n-                arr.swap(i1, i2);\n-            });\n-            tim_sort(arr); // 3sort\n-            isSorted(arr);\n-\n-            if n >= 10 {\n-                let size = arr.len();\n-                let mut idx = 1;\n-                while idx <= 10 {\n-                    arr[size-idx] = @rng.gen();\n-                    idx += 1;\n-                }\n-            }\n-            tim_sort(arr); // +sort\n-            isSorted(arr);\n-\n-            (n/100).times(|| {\n-                let idx = rng.gen_range(0u, n);\n-                arr[idx] = @rng.gen();\n-            });\n-            tim_sort(arr);\n-            isSorted(arr);\n-\n-            let mut arr = if n > 4 {\n-                let part = arr.slice(0, 4);\n-                multiplyVec(part, n)\n-            } else { arr };\n-            tim_sort(arr); // ~sort\n-            isSorted(arr);\n-\n-            let mut arr = vec::from_elem(n, @(-0.5));\n-            tim_sort(arr); // =sort\n-            isSorted(arr);\n-\n-            let half = n / 2;\n-            let mut arr = makeRange(half).map(|i| @(*i as f64));\n-            tim_sort(arr); // !sort\n-            isSorted(arr);\n-        }\n-    }\n-}"}, {"sha": "e4ef5723dd3940dc8f5a614db2b292a1e3c25aa6", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -10,7 +10,6 @@\n \n #[allow(missing_doc)];\n \n-use sort;\n use std::cmp;\n use std::hashmap;\n use std::io;\n@@ -240,13 +239,13 @@ impl<'a> Stats for &'a [f64] {\n \n     fn percentile(self, pct: f64) -> f64 {\n         let mut tmp = self.to_owned();\n-        sort::tim_sort(tmp);\n+        tmp.sort(|a,b| a <= b);\n         percentile_of_sorted(tmp, pct)\n     }\n \n     fn quartiles(self) -> (f64,f64,f64) {\n         let mut tmp = self.to_owned();\n-        sort::tim_sort(tmp);\n+        tmp.sort(|a,b| a <= b);\n         let a = percentile_of_sorted(tmp, 25.0);\n         let b = percentile_of_sorted(tmp, 50.0);\n         let c = percentile_of_sorted(tmp, 75.0);\n@@ -291,7 +290,7 @@ fn percentile_of_sorted(sorted_samples: &[f64],\n /// See: http://en.wikipedia.org/wiki/Winsorising\n pub fn winsorize(samples: &mut [f64], pct: f64) {\n     let mut tmp = samples.to_owned();\n-    sort::tim_sort(tmp);\n+    tmp.sort(|a,b| a <= b);\n     let lo = percentile_of_sorted(tmp, pct);\n     let hi = percentile_of_sorted(tmp, 100.0-pct);\n     for samp in samples.mut_iter() {"}, {"sha": "af22aad7b5e48192f4523711497498ddfebc55a3", "filename": "src/libextra/test.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -21,7 +21,6 @@ use getopts::groups;\n use json::ToJson;\n use json;\n use serialize::Decodable;\n-use sort;\n use stats::Stats;\n use stats;\n use term;\n@@ -488,7 +487,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         for f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n-        sort::tim_sort(failures);\n+        failures.sort(|a,b| a <= b);\n         for name in failures.iter() {\n             self.write_plain(format!(\"    {}\\n\", name.to_str()));\n         }\n@@ -840,9 +839,9 @@ pub fn filter_tests(\n \n     // Sort the tests alphabetically\n     fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n-        t1.desc.name.to_str() < t2.desc.name.to_str()\n+        t1.desc.name.to_str() <= t2.desc.name.to_str()\n     }\n-    sort::quick_sort(filtered, lteq);\n+    filtered.sort(lteq);\n \n     // Shard the remaining tests, if sharding requested.\n     match opts.test_shard {"}, {"sha": "6647866cd48c5ae8555feddf921e6b67d25d94a3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -150,7 +150,6 @@ Additional help:\n }\n \n pub fn describe_warnings() {\n-    use extra::sort::Sort;\n     println(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n@@ -163,7 +162,7 @@ Available lint options:\n     let mut lint_dict = lint_dict.move_iter()\n                                  .map(|(k, v)| (v, k))\n                                  .collect::<~[(lint::LintSpec, &'static str)]>();\n-    lint_dict.qsort();\n+    lint_dict.sort(|a,b| a <= b);\n \n     let mut max_key = 0;\n     for &(_, name) in lint_dict.iter() {"}, {"sha": "9f0f5af6c4ef99963e45fd0177be69dd9b706c60", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -17,7 +17,6 @@ use metadata::cstore;\n use metadata::decoder;\n \n use std::hashmap::HashMap;\n-use extra;\n use syntax::ast;\n use syntax::parse::token::ident_interner;\n \n@@ -192,14 +191,12 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         });\n     }\n \n-    let sorted = extra::sort::merge_sort(result, |a, b| {\n-        (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash)\n-    });\n+    result.sort(|a, b| (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash));\n \n     debug!(\"sorted:\");\n-    for x in sorted.iter() {\n+    for x in result.iter() {\n         debug!(\"  hash[{}]: {}\", x.name, x.hash);\n     }\n \n-    sorted.map(|ch| ch.hash)\n+    result.map(|ch| ch.hash)\n }"}, {"sha": "8f64df0956976e70d282a26a268f4d3c70e09f6f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -30,7 +30,6 @@ use std::util;\n use std::vec;\n \n use extra::serialize::Encodable;\n-use extra;\n \n use syntax::abi::AbiSet;\n use syntax::ast::*;\n@@ -1532,7 +1531,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n         });\n \n         // Sort by cnum\n-        extra::sort::quick_sort(deps, |kv1, kv2| kv1.cnum <= kv2.cnum);\n+        deps.sort(|kv1, kv2| kv1.cnum <= kv2.cnum);\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;"}, {"sha": "47549986f447df2b36dd35ea438bfb71cde3c282", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -21,7 +21,6 @@ use util::ppaux::ty_to_str;\n use std::iter;\n use std::num;\n use std::vec;\n-use extra::sort;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n use syntax::codemap::{Span, dummy_sp, Spanned};\n@@ -454,7 +453,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n \n         // Find the lengths and slices of all vector patterns.\n-        let vec_pat_lens = m.iter().filter_map(|r| {\n+        let mut vec_pat_lens = m.iter().filter_map(|r| {\n             match r[0].node {\n                 PatVec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n@@ -465,21 +464,19 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first.\n-        let mut sorted_vec_lens = sort::merge_sort(vec_pat_lens,\n-            |&(len1, slice1), &(len2, slice2)| {\n-                if len1 == len2 {\n-                    slice1 > slice2\n-                } else {\n-                    len1 <= len2\n-                }\n-            }\n-        );\n-        sorted_vec_lens.dedup();\n+        vec_pat_lens.sort(|&(len1, slice1), &(len2, slice2)| {\n+                    if len1 == len2 {\n+                        slice1 > slice2\n+                    } else {\n+                        len1 <= len2\n+                    }\n+                });\n+        vec_pat_lens.dedup();\n \n         let mut found_slice = false;\n         let mut next = 0;\n         let mut missing = None;\n-        for &(length, slice) in sorted_vec_lens.iter() {\n+        for &(length, slice) in vec_pat_lens.iter() {\n             if length != next {\n                 missing = Some(next);\n                 break;"}, {"sha": "3c8e64672047cce45a7af9b0ef2f33a758ff727d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -73,7 +73,6 @@ use std::libc::c_uint;\n use std::vec;\n use std::local_data;\n use extra::time;\n-use extra::sort;\n use syntax::ast::Name;\n use syntax::ast_map::{path, path_elt_to_str, path_name, path_pretty_name};\n use syntax::ast_util::{local_def, is_local};\n@@ -3163,10 +3162,9 @@ pub fn trans_crate(sess: session::Session,\n         println!(\"n_inlines: {}\", ccx.stats.n_inlines);\n         println!(\"n_closures: {}\", ccx.stats.n_closures);\n         println(\"fn stats:\");\n-        sort::quick_sort(ccx.stats.fn_stats,\n-                         |&(_, _, insns_a), &(_, _, insns_b)| {\n-            insns_a > insns_b\n-        });\n+\n+        ccx.stats.fn_stats.sort(|&(_, _, insns_a), &(_, _, insns_b)| insns_a >= insns_b);\n+\n         for tuple in ccx.stats.fn_stats.iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {"}, {"sha": "441661c793b4697bcd5568f8241e2740468de39a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -45,8 +45,6 @@ use std::vec;\n \n use extra::arc::Arc;\n use extra::json::ToJson;\n-use extra::sort;\n-\n use syntax::ast;\n use syntax::attr;\n \n@@ -900,16 +898,16 @@ fn item_module(w: &mut Writer, cx: &Context,\n     debug!(\"{:?}\", items);\n     let mut indices = vec::from_fn(items.len(), |i| i);\n \n-    fn lt(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> bool {\n+    fn le(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> bool {\n         if shortty(i1) == shortty(i2) {\n-            return i1.name < i2.name;\n+            return i1.name <= i2.name;\n         }\n         match (&i1.inner, &i2.inner) {\n             (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n                 match (&a.inner, &b.inner) {\n                     (&clean::ExternMod(..), _) => true,\n                     (_, &clean::ExternMod(..)) => false,\n-                    _ => idx1 < idx2,\n+                    _ => idx1 <= idx2,\n                 }\n             }\n             (&clean::ViewItemItem(..), _) => true,\n@@ -932,12 +930,12 @@ fn item_module(w: &mut Writer, cx: &Context,\n             (_, &clean::FunctionItem(..)) => false,\n             (&clean::TypedefItem(..), _) => true,\n             (_, &clean::TypedefItem(..)) => false,\n-            _ => idx1 < idx2,\n+            _ => idx1 <= idx2,\n         }\n     }\n \n     debug!(\"{:?}\", indices);\n-    sort::quick_sort(indices, |&i1, &i2| lt(&items[i1], &items[i2], i1, i2));\n+    indices.sort(|&i1, &i2| le(&items[i1], &items[i2], i1, i2));\n \n     debug!(\"{:?}\", indices);\n     let mut curty = \"\";\n@@ -1532,7 +1530,7 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n     }\n \n     for (_, items) in map.mut_iter() {\n-        sort::quick_sort(*items, |i1, i2| i1 < i2);\n+        items.sort(|i1, i2| i1 <= i2);\n     }\n     return map;\n }"}, {"sha": "9b616781d4f596711ba9787c4ab5992d6ddd23cb", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -10,8 +10,6 @@\n \n // Functions dealing with attributes and meta items\n \n-use extra;\n-\n use ast;\n use ast::{Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n@@ -205,7 +203,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n         .map(|&mi| (mi.name(), mi))\n         .collect::<~[(@str, @MetaItem)]>();\n \n-    extra::sort::quick_sort(v, |&(a, _), &(b, _)| a <= b);\n+    v.sort(|&(a, _), &(b, _)| a <= b);\n \n     // There doesn't seem to be a more optimal way to do this\n     v.move_iter().map(|(_, m)| {"}, {"sha": "f430817025e386e51403e18548d5f98b7598a399", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -15,7 +15,6 @@\n \n extern mod extra;\n \n-use extra::sort;\n use std::cmp::Ord;\n use std::comm;\n use std::hashmap::HashMap;\n@@ -54,8 +53,10 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    }\n \n    // sort by key, then by value\n-   fn sortKV<TT:Clone + Ord, UU:Clone + Ord>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n-      return sort::merge_sort(sort::merge_sort(orig, le_by_key), le_by_val);\n+   fn sortKV<TT:Clone + Ord, UU:Clone + Ord>(mut orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n+        orig.sort(le_by_key);\n+        orig.sort(le_by_val);\n+        origin\n    }\n \n    let mut pairs = ~[];"}, {"sha": "71da98677f12258b94000c6443eb8ec2598b7dcf", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "patch": "@@ -9,7 +9,6 @@ use std::libc::{stat, strlen};\n use std::ptr::null;\n use std::unstable::intrinsics::init;\n use std::vec::{reverse};\n-use extra::sort::quick_sort3;\n \n static LINE_LEN: uint = 80;\n static TABLE: [u8, ..4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n@@ -267,7 +266,7 @@ fn print_frequencies(frequencies: &Table, frame: i32) {\n     for frequencies.each |entry| {\n         vector.push((entry.code, entry.count));\n     }\n-    quick_sort3(vector);\n+    vector.sort(|a,b| a <= b);\n \n     let mut total_count = 0;\n     for vector.each |&(_, count)| {"}]}