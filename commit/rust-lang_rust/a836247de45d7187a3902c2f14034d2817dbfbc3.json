{"sha": "a836247de45d7187a3902c2f14034d2817dbfbc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MzYyNDdkZTQ1ZDcxODdhMzkwMmMyZjE0MDM0ZDI4MTdkYmZiYzM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-09T15:04:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-09T15:04:20Z"}, "message": "Merge #3069\n\n3069: Simplify Assists interface r=matklad a=matklad\n\nInstead of building a physical tree structure, just tag related\nassists with the same group\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "bb0bf39dee21d5720e5f1070b09805dfbc120cd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb0bf39dee21d5720e5f1070b09805dfbc120cd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a836247de45d7187a3902c2f14034d2817dbfbc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a836247de45d7187a3902c2f14034d2817dbfbc3", "html_url": "https://github.com/rust-lang/rust/commit/a836247de45d7187a3902c2f14034d2817dbfbc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a836247de45d7187a3902c2f14034d2817dbfbc3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa5f80aed1464881575fe635557c3965313a7ecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa5f80aed1464881575fe635557c3965313a7ecf", "html_url": "https://github.com/rust-lang/rust/commit/aa5f80aed1464881575fe635557c3965313a7ecf"}, {"sha": "9769c5140c9c406a4cc880e698593a6c4bcc6826", "url": "https://api.github.com/repos/rust-lang/rust/commits/9769c5140c9c406a4cc880e698593a6c4bcc6826", "html_url": "https://github.com/rust-lang/rust/commit/9769c5140c9c406a4cc880e698593a6c4bcc6826"}], "stats": {"total": 308, "additions": 152, "deletions": 156}, "files": [{"sha": "5aab5fb8b673dd71f007a4f62ad6c6cf62ec2561", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 68, "deletions": 41, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=a836247de45d7187a3902c2f14034d2817dbfbc3", "patch": "@@ -1,5 +1,4 @@\n //! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n-use either::Either;\n use hir::{InFile, SourceAnalyzer, SourceBinder};\n use ra_db::{FileRange, SourceDatabase};\n use ra_fmt::{leading_indent, reindent};\n@@ -11,12 +10,36 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEditBuilder;\n \n-use crate::{AssistAction, AssistId, AssistLabel, ResolvedAssist};\n+use crate::{AssistAction, AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n \n #[derive(Clone, Debug)]\n-pub(crate) enum Assist {\n-    Unresolved { label: AssistLabel },\n-    Resolved { assist: ResolvedAssist },\n+pub(crate) struct Assist(pub(crate) Vec<AssistInfo>);\n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct AssistInfo {\n+    pub(crate) label: AssistLabel,\n+    pub(crate) group_label: Option<GroupLabel>,\n+    pub(crate) action: Option<AssistAction>,\n+}\n+\n+impl AssistInfo {\n+    fn new(label: AssistLabel) -> AssistInfo {\n+        AssistInfo { label, group_label: None, action: None }\n+    }\n+\n+    fn resolved(self, action: AssistAction) -> AssistInfo {\n+        AssistInfo { action: Some(action), ..self }\n+    }\n+\n+    fn with_group(self, group_label: GroupLabel) -> AssistInfo {\n+        AssistInfo { group_label: Some(group_label), ..self }\n+    }\n+\n+    pub(crate) fn into_resolved(self) -> Option<ResolvedAssist> {\n+        let label = self.label;\n+        let group_label = self.group_label;\n+        self.action.map(|action| ResolvedAssist { label, group_label, action })\n+    }\n }\n \n pub(crate) type AssistHandler = fn(AssistCtx) -> Option<Assist>;\n@@ -84,44 +107,21 @@ impl<'a> AssistCtx<'a> {\n     ) -> Option<Assist> {\n         let label = AssistLabel::new(label.into(), id);\n \n-        let assist = if self.should_compute_edit {\n+        let mut info = AssistInfo::new(label);\n+        if self.should_compute_edit {\n             let action = {\n                 let mut edit = ActionBuilder::default();\n                 f(&mut edit);\n                 edit.build()\n             };\n-            Assist::Resolved { assist: ResolvedAssist { label, action_data: Either::Left(action) } }\n-        } else {\n-            Assist::Unresolved { label }\n+            info = info.resolved(action)\n         };\n \n-        Some(assist)\n+        Some(Assist(vec![info]))\n     }\n \n-    pub(crate) fn add_assist_group(\n-        self,\n-        id: AssistId,\n-        label: impl Into<String>,\n-        f: impl FnOnce() -> Vec<ActionBuilder>,\n-    ) -> Option<Assist> {\n-        let label = AssistLabel::new(label.into(), id);\n-        let assist = if self.should_compute_edit {\n-            let actions = f();\n-            assert!(!actions.is_empty(), \"Assist cannot have no\");\n-\n-            Assist::Resolved {\n-                assist: ResolvedAssist {\n-                    label,\n-                    action_data: Either::Right(\n-                        actions.into_iter().map(ActionBuilder::build).collect(),\n-                    ),\n-                },\n-            }\n-        } else {\n-            Assist::Unresolved { label }\n-        };\n-\n-        Some(assist)\n+    pub(crate) fn add_assist_group(self, group_name: impl Into<String>) -> AssistGroup<'a> {\n+        AssistGroup { ctx: self, group_name: group_name.into(), assists: Vec::new() }\n     }\n \n     pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n@@ -155,20 +155,48 @@ impl<'a> AssistCtx<'a> {\n     }\n }\n \n+pub(crate) struct AssistGroup<'a> {\n+    ctx: AssistCtx<'a>,\n+    group_name: String,\n+    assists: Vec<AssistInfo>,\n+}\n+\n+impl<'a> AssistGroup<'a> {\n+    pub(crate) fn add_assist(\n+        &mut self,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        f: impl FnOnce(&mut ActionBuilder),\n+    ) {\n+        let label = AssistLabel::new(label.into(), id);\n+\n+        let mut info = AssistInfo::new(label).with_group(GroupLabel(self.group_name.clone()));\n+        if self.ctx.should_compute_edit {\n+            let action = {\n+                let mut edit = ActionBuilder::default();\n+                f(&mut edit);\n+                edit.build()\n+            };\n+            info = info.resolved(action)\n+        };\n+\n+        self.assists.push(info)\n+    }\n+\n+    pub(crate) fn finish(self) -> Option<Assist> {\n+        assert!(!self.assists.is_empty());\n+        Some(Assist(self.assists))\n+    }\n+}\n+\n #[derive(Default)]\n pub(crate) struct ActionBuilder {\n     edit: TextEditBuilder,\n     cursor_position: Option<TextUnit>,\n     target: Option<TextRange>,\n-    label: Option<String>,\n }\n \n impl ActionBuilder {\n-    /// Adds a custom label to the action, if it needs to be different from the assist label\n-    pub(crate) fn label(&mut self, label: impl Into<String>) {\n-        self.label = Some(label.into())\n-    }\n-\n     /// Replaces specified `range` of text with a given string.\n     pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n         self.edit.replace(range, replace_with.into())\n@@ -227,7 +255,6 @@ impl ActionBuilder {\n             edit: self.edit.finish(),\n             cursor_position: self.cursor_position,\n             target: self.target,\n-            label: self.label,\n         }\n     }\n }"}, {"sha": "c0f9bc1fbe75e25bf04dbc0a44c23f326cef52cc", "filename": "crates/ra_assists/src/doc_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs?ref=a836247de45d7187a3902c2f14034d2817dbfbc3", "patch": "@@ -30,6 +30,6 @@ fn check(assist_id: &str, before: &str, after: &str) {\n             )\n         });\n \n-    let actual = assist.get_first_action().edit.apply(&before);\n+    let actual = assist.action.edit.apply(&before);\n     assert_eq_text!(after, &actual);\n }"}, {"sha": "d13332f377b7092f8c3b5d7b47d636a419faea98", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=a836247de45d7187a3902c2f14034d2817dbfbc3", "patch": "@@ -1,12 +1,8 @@\n-use hir::ModPath;\n use ra_ide_db::imports_locator::ImportsLocator;\n-use ra_syntax::{\n-    ast::{self, AstNode},\n-    SyntaxNode,\n-};\n+use ra_syntax::ast::{self, AstNode};\n \n use crate::{\n-    assist_ctx::{ActionBuilder, Assist, AssistCtx},\n+    assist_ctx::{Assist, AssistCtx},\n     insert_use_statement, AssistId,\n };\n use std::collections::BTreeSet;\n@@ -67,19 +63,18 @@ pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist_group(AssistId(\"auto_import\"), format!(\"Import {}\", name_to_import), || {\n-        proposed_imports\n-            .into_iter()\n-            .map(|import| import_to_action(import, &position, &path_to_import_syntax))\n-            .collect()\n-    })\n-}\n-\n-fn import_to_action(import: ModPath, position: &SyntaxNode, anchor: &SyntaxNode) -> ActionBuilder {\n-    let mut action_builder = ActionBuilder::default();\n-    action_builder.label(format!(\"Import `{}`\", &import));\n-    insert_use_statement(position, anchor, &import, action_builder.text_edit_builder());\n-    action_builder\n+    let mut group = ctx.add_assist_group(format!(\"Import {}\", name_to_import));\n+    for import in proposed_imports {\n+        group.add_assist(AssistId(\"auto_import\"), format!(\"Import `{}`\", &import), |edit| {\n+            insert_use_statement(\n+                &position,\n+                path_to_import_syntax,\n+                &import,\n+                edit.text_edit_builder(),\n+            );\n+        });\n+    }\n+    group.finish()\n }\n \n #[cfg(test)]"}, {"sha": "828a8e9e827cbe3496670f51564162057ec13749", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 15, "deletions": 49, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=a836247de45d7187a3902c2f14034d2817dbfbc3", "patch": "@@ -12,9 +12,6 @@ mod doc_tests;\n mod utils;\n pub mod ast_transform;\n \n-use std::cmp::Ordering;\n-\n-use either::Either;\n use ra_db::FileRange;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{TextRange, TextUnit};\n@@ -35,6 +32,9 @@ pub struct AssistLabel {\n     pub id: AssistId,\n }\n \n+#[derive(Clone, Debug)]\n+pub struct GroupLabel(pub String);\n+\n impl AssistLabel {\n     pub(crate) fn new(label: String, id: AssistId) -> AssistLabel {\n         // FIXME: make fields private, so that this invariant can't be broken\n@@ -45,7 +45,6 @@ impl AssistLabel {\n \n #[derive(Debug, Clone)]\n pub struct AssistAction {\n-    pub label: Option<String>,\n     pub edit: TextEdit,\n     pub cursor_position: Option<TextUnit>,\n     // FIXME: This belongs to `AssistLabel`\n@@ -55,16 +54,8 @@ pub struct AssistAction {\n #[derive(Debug, Clone)]\n pub struct ResolvedAssist {\n     pub label: AssistLabel,\n-    pub action_data: Either<AssistAction, Vec<AssistAction>>,\n-}\n-\n-impl ResolvedAssist {\n-    pub fn get_first_action(&self) -> AssistAction {\n-        match &self.action_data {\n-            Either::Left(action) => action.clone(),\n-            Either::Right(actions) => actions[0].clone(),\n-        }\n-    }\n+    pub group_label: Option<GroupLabel>,\n+    pub action: AssistAction,\n }\n \n /// Return all the assists applicable at the given position.\n@@ -76,10 +67,8 @@ pub fn unresolved_assists(db: &RootDatabase, range: FileRange) -> Vec<AssistLabe\n     handlers::all()\n         .iter()\n         .filter_map(|f| f(ctx.clone()))\n-        .map(|a| match a {\n-            Assist::Unresolved { label } => label,\n-            Assist::Resolved { .. } => unreachable!(),\n-        })\n+        .flat_map(|it| it.0)\n+        .map(|a| a.label)\n         .collect()\n }\n \n@@ -92,24 +81,13 @@ pub fn resolved_assists(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssi\n     let mut a = handlers::all()\n         .iter()\n         .filter_map(|f| f(ctx.clone()))\n-        .map(|a| match a {\n-            Assist::Resolved { assist } => assist,\n-            Assist::Unresolved { .. } => unreachable!(),\n-        })\n+        .flat_map(|it| it.0)\n+        .map(|it| it.into_resolved().unwrap())\n         .collect::<Vec<_>>();\n-    sort_assists(&mut a);\n+    a.sort_by_key(|it| it.action.target.map_or(TextUnit::from(!0u32), |it| it.len()));\n     a\n }\n \n-fn sort_assists(assists: &mut [ResolvedAssist]) {\n-    assists.sort_by(|a, b| match (a.get_first_action().target, b.get_first_action().target) {\n-        (Some(a), Some(b)) => a.len().cmp(&b.len()),\n-        (Some(_), None) => Ordering::Less,\n-        (None, Some(_)) => Ordering::Greater,\n-        (None, None) => Ordering::Equal,\n-    });\n-}\n-\n mod handlers {\n     use crate::AssistHandler;\n \n@@ -184,7 +162,7 @@ mod helpers {\n     use ra_syntax::TextRange;\n     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n-    use crate::{Assist, AssistCtx, AssistHandler};\n+    use crate::{AssistCtx, AssistHandler};\n \n     pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n         let (mut db, file_id) = RootDatabase::with_single_file(text);\n@@ -202,10 +180,7 @@ mod helpers {\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n             assist(AssistCtx::new(&db, frange, true)).expect(\"code action is not applicable\");\n-        let action = match assist {\n-            Assist::Unresolved { .. } => unreachable!(),\n-            Assist::Resolved { assist } => assist.get_first_action(),\n-        };\n+        let action = assist.0[0].action.clone().unwrap();\n \n         let actual = action.edit.apply(&before);\n         let actual_cursor_pos = match action.cursor_position {\n@@ -225,10 +200,7 @@ mod helpers {\n         let frange = FileRange { file_id, range };\n         let assist =\n             assist(AssistCtx::new(&db, frange, true)).expect(\"code action is not applicable\");\n-        let action = match assist {\n-            Assist::Unresolved { .. } => unreachable!(),\n-            Assist::Resolved { assist } => assist.get_first_action(),\n-        };\n+        let action = assist.0[0].action.clone().unwrap();\n \n         let mut actual = action.edit.apply(&before);\n         if let Some(pos) = action.cursor_position {\n@@ -244,10 +216,7 @@ mod helpers {\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n             assist(AssistCtx::new(&db, frange, true)).expect(\"code action is not applicable\");\n-        let action = match assist {\n-            Assist::Unresolved { .. } => unreachable!(),\n-            Assist::Resolved { assist } => assist.get_first_action(),\n-        };\n+        let action = assist.0[0].action.clone().unwrap();\n \n         let range = action.target.expect(\"expected target on action\");\n         assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);\n@@ -259,10 +228,7 @@ mod helpers {\n         let frange = FileRange { file_id, range };\n         let assist =\n             assist(AssistCtx::new(&db, frange, true)).expect(\"code action is not applicable\");\n-        let action = match assist {\n-            Assist::Unresolved { .. } => unreachable!(),\n-            Assist::Resolved { assist } => assist.get_first_action(),\n-        };\n+        let action = assist.0[0].action.clone().unwrap();\n \n         let range = action.target.expect(\"expected target on action\");\n         assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);"}, {"sha": "40d56a4f7b5382e6c0ccbe86a98a728552493918", "filename": "crates/ra_ide/src/assists.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_ide%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_ide%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fassists.rs?ref=a836247de45d7187a3902c2f14034d2817dbfbc3", "patch": "@@ -1,6 +1,5 @@\n //! FIXME: write short doc here\n \n-use either::Either;\n use ra_assists::{resolved_assists, AssistAction, AssistLabel};\n use ra_db::{FilePosition, FileRange};\n use ra_ide_db::RootDatabase;\n@@ -13,7 +12,8 @@ pub use ra_assists::AssistId;\n pub struct Assist {\n     pub id: AssistId,\n     pub label: String,\n-    pub change_data: Either<SourceChange, Vec<SourceChange>>,\n+    pub group_label: Option<String>,\n+    pub source_change: SourceChange,\n }\n \n pub(crate) fn assists(db: &RootDatabase, frange: FileRange) -> Vec<Assist> {\n@@ -25,17 +25,8 @@ pub(crate) fn assists(db: &RootDatabase, frange: FileRange) -> Vec<Assist> {\n             Assist {\n                 id: assist_label.id,\n                 label: assist_label.label.clone(),\n-                change_data: match assist.action_data {\n-                    Either::Left(action) => {\n-                        Either::Left(action_to_edit(action, file_id, assist_label))\n-                    }\n-                    Either::Right(actions) => Either::Right(\n-                        actions\n-                            .into_iter()\n-                            .map(|action| action_to_edit(action, file_id, assist_label))\n-                            .collect(),\n-                    ),\n-                },\n+                group_label: assist.group_label.map(|it| it.0),\n+                source_change: action_to_edit(assist.action, file_id, assist_label),\n             }\n         })\n         .collect()\n@@ -47,9 +38,6 @@ fn action_to_edit(\n     assist_label: &AssistLabel,\n ) -> SourceChange {\n     let file_edit = SourceFileEdit { file_id, edit: action.edit };\n-    SourceChange::source_file_edit(\n-        action.label.unwrap_or_else(|| assist_label.label.clone()),\n-        file_edit,\n-    )\n-    .with_cursor_opt(action.cursor_position.map(|offset| FilePosition { offset, file_id }))\n+    SourceChange::source_file_edit(assist_label.label.clone(), file_edit)\n+        .with_cursor_opt(action.cursor_position.map(|offset| FilePosition { offset, file_id }))\n }"}, {"sha": "65e8bc856dfd35a6196ca9ceccb5f32cf429bda8", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a836247de45d7187a3902c2f14034d2817dbfbc3/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=a836247de45d7187a3902c2f14034d2817dbfbc3", "patch": "@@ -2,20 +2,21 @@\n //! The majority of requests are fulfilled by calling into the `ra_ide` crate.\n \n use std::{\n+    collections::hash_map::Entry,\n     fmt::Write as _,\n     io::Write as _,\n     process::{self, Stdio},\n };\n \n-use either::Either;\n use lsp_server::ErrorCode;\n use lsp_types::{\n     CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem,\n     CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams,\n-    CodeAction, CodeActionResponse, CodeLens, Command, CompletionItem, Diagnostic,\n-    DocumentFormattingParams, DocumentHighlight, DocumentSymbol, FoldingRange, FoldingRangeParams,\n-    Hover, HoverContents, Location, MarkupContent, MarkupKind, Position, PrepareRenameResponse,\n-    Range, RenameParams, SymbolInformation, TextDocumentIdentifier, TextEdit, WorkspaceEdit,\n+    CodeAction, CodeActionOrCommand, CodeActionResponse, CodeLens, Command, CompletionItem,\n+    Diagnostic, DocumentFormattingParams, DocumentHighlight, DocumentSymbol, FoldingRange,\n+    FoldingRangeParams, Hover, HoverContents, Location, MarkupContent, MarkupKind, Position,\n+    PrepareRenameResponse, Range, RenameParams, SymbolInformation, TextDocumentIdentifier,\n+    TextEdit, WorkspaceEdit,\n };\n use ra_ide::{\n     AssistId, FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind,\n@@ -685,34 +686,53 @@ pub fn handle_code_action(\n         res.push(fix.action.clone());\n     }\n \n+    let mut groups = FxHashMap::default();\n     for assist in world.analysis().assists(FileRange { file_id, range })?.into_iter() {\n-        let title = assist.label.clone();\n+        let arg = to_value(assist.source_change.try_conv_with(&world)?)?;\n+\n+        let (command, title, arg) = match assist.group_label {\n+            None => (\"rust-analyzer.applySourceChange\", assist.label.clone(), arg),\n+\n+            // Group all assists with the same `group_label` into a single CodeAction.\n+            Some(group_label) => {\n+                match groups.entry(group_label.clone()) {\n+                    Entry::Occupied(entry) => {\n+                        let idx: usize = *entry.get();\n+                        match &mut res[idx] {\n+                            CodeActionOrCommand::CodeAction(CodeAction {\n+                                command: Some(Command { arguments: Some(arguments), .. }),\n+                                ..\n+                            }) => match arguments.as_mut_slice() {\n+                                [serde_json::Value::Array(arguments)] => arguments.push(arg),\n+                                _ => panic!(\"invalid group\"),\n+                            },\n+                            _ => panic!(\"invalid group\"),\n+                        }\n+                        continue;\n+                    }\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(res.len());\n+                    }\n+                }\n+                (\"rust-analyzer.selectAndApplySourceChange\", group_label, to_value(vec![arg])?)\n+            }\n+        };\n \n-        let command = match assist.change_data {\n-            Either::Left(change) => Command {\n-                title,\n-                command: \"rust-analyzer.applySourceChange\".to_string(),\n-                arguments: Some(vec![to_value(change.try_conv_with(&world)?)?]),\n-            },\n-            Either::Right(changes) => Command {\n-                title,\n-                command: \"rust-analyzer.selectAndApplySourceChange\".to_string(),\n-                arguments: Some(vec![to_value(\n-                    changes\n-                        .into_iter()\n-                        .map(|change| change.try_conv_with(&world))\n-                        .collect::<Result<Vec<_>>>()?,\n-                )?]),\n-            },\n+        let command = Command {\n+            title: assist.label.clone(),\n+            command: command.to_string(),\n+            arguments: Some(vec![arg]),\n+        };\n+\n+        let kind = match assist.id {\n+            AssistId(\"introduce_variable\") => Some(\"refactor.extract.variable\".to_string()),\n+            AssistId(\"add_custom_impl\") => Some(\"refactor.rewrite.add_custom_impl\".to_string()),\n+            _ => None,\n         };\n \n         let action = CodeAction {\n-            title: command.title.clone(),\n-            kind: match assist.id {\n-                AssistId(\"introduce_variable\") => Some(\"refactor.extract.variable\".to_string()),\n-                AssistId(\"add_custom_impl\") => Some(\"refactor.rewrite.add_custom_impl\".to_string()),\n-                _ => None,\n-            },\n+            title,\n+            kind,\n             diagnostics: None,\n             edit: None,\n             command: Some(command),"}]}