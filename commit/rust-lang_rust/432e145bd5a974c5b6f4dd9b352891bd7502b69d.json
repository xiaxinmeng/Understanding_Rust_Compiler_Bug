{"sha": "432e145bd5a974c5b6f4dd9b352891bd7502b69d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMmUxNDViZDVhOTc0YzViNmY0ZGQ5YjM1Mjg5MWJkNzUwMmI2OWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-10T19:01:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-10T19:01:41Z"}, "message": "Auto merge of #86873 - nikic:opaque-ptrs, r=nagisa\n\nImprove opaque pointers support\n\nOpaque pointers are coming, and rustc is not ready.\n\nThis adds partial support by passing an explicit load type to LLVM. Two issues I've encountered:\n * The necessary type was not available at the point where non-temporal copies were generated. I've pushed the code for that upwards out of the memcpy implementation and moved the position of a cast to make do with the types we have available. (I'm not sure that cast is needed at all, but have retained it in the interest of conservativeness.)\n * The `PlaceRef::project_deref()` function used during debuginfo generation seems to be buggy in some way -- though I haven't figured out specifically what it does wrong. Replacing it with `load_operand().deref()` did the trick, but I don't really know what I'm doing here.", "tree": {"sha": "d183ea94a9b3b6687739e2d5280ee0eae1d25d42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d183ea94a9b3b6687739e2d5280ee0eae1d25d42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/432e145bd5a974c5b6f4dd9b352891bd7502b69d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/432e145bd5a974c5b6f4dd9b352891bd7502b69d", "html_url": "https://github.com/rust-lang/rust/commit/432e145bd5a974c5b6f4dd9b352891bd7502b69d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/432e145bd5a974c5b6f4dd9b352891bd7502b69d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a31431fce770ff90a347fd6114ac294e4568cbd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a31431fce770ff90a347fd6114ac294e4568cbd8", "html_url": "https://github.com/rust-lang/rust/commit/a31431fce770ff90a347fd6114ac294e4568cbd8"}, {"sha": "2ce1addeba5030eaa5d5dbdf2cc2a9c53a107c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ce1addeba5030eaa5d5dbdf2cc2a9c53a107c06", "html_url": "https://github.com/rust-lang/rust/commit/2ce1addeba5030eaa5d5dbdf2cc2a9c53a107c06"}], "stats": {"total": 155, "additions": 81, "deletions": 74}, "files": [{"sha": "2bb0ce68b171e57540b2c1958c71b414ee674903", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -410,31 +410,33 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn load(&mut self, ty: &'ll Type, ptr: &'ll Value, align: Align) -> &'ll Value {\n         unsafe {\n-            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n+            let load = llvm::LLVMBuildLoad2(self.llbuilder, ty, ptr, UNNAMED);\n             llvm::LLVMSetAlignment(load, align.bytes() as c_uint);\n             load\n         }\n     }\n \n-    fn volatile_load(&mut self, ptr: &'ll Value) -> &'ll Value {\n+    fn volatile_load(&mut self, ty: &'ll Type, ptr: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n+            let load = llvm::LLVMBuildLoad2(self.llbuilder, ty, ptr, UNNAMED);\n             llvm::LLVMSetVolatile(load, llvm::True);\n             load\n         }\n     }\n \n     fn atomic_load(\n         &mut self,\n+        ty: &'ll Type,\n         ptr: &'ll Value,\n         order: rustc_codegen_ssa::common::AtomicOrdering,\n         size: Size,\n     ) -> &'ll Value {\n         unsafe {\n             let load = llvm::LLVMRustBuildAtomicLoad(\n                 self.llbuilder,\n+                ty,\n                 ptr,\n                 UNNAMED,\n                 AtomicOrdering::from_generic(order),\n@@ -486,7 +488,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n             let llval = const_llval.unwrap_or_else(|| {\n-                let load = self.load(place.llval, place.align);\n+                let load = self.load(place.layout.llvm_type(self), place.llval, place.align);\n                 if let abi::Abi::Scalar(ref scalar) = place.layout.abi {\n                     scalar_load_metadata(self, load, scalar);\n                 }\n@@ -498,7 +500,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n             let mut load = |i, scalar: &abi::Scalar, align| {\n                 let llptr = self.struct_gep(place.llval, i as u64);\n-                let load = self.load(llptr, align);\n+                let llty = place.layout.scalar_pair_element_llvm_type(self, i, false);\n+                let load = self.load(llty, llptr, align);\n                 scalar_load_metadata(self, load, scalar);\n                 self.to_immediate_scalar(load, scalar)\n             };\n@@ -815,13 +818,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         size: &'ll Value,\n         flags: MemFlags,\n     ) {\n-        if flags.contains(MemFlags::NONTEMPORAL) {\n-            // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n-            let val = self.load(src, src_align);\n-            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n-            self.store_with_flags(val, ptr, dst_align, flags);\n-            return;\n-        }\n+        assert!(!flags.contains(MemFlags::NONTEMPORAL), \"non-temporal memcpy not supported\");\n         let size = self.intcast(size, self.type_isize(), false);\n         let is_volatile = flags.contains(MemFlags::VOLATILE);\n         let dst = self.pointercast(dst, self.type_i8p());\n@@ -848,13 +845,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         size: &'ll Value,\n         flags: MemFlags,\n     ) {\n-        if flags.contains(MemFlags::NONTEMPORAL) {\n-            // HACK(nox): This is inefficient but there is no nontemporal memmove.\n-            let val = self.load(src, src_align);\n-            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n-            self.store_with_flags(val, ptr, dst_align, flags);\n-            return;\n-        }\n+        assert!(!flags.contains(MemFlags::NONTEMPORAL), \"non-temporal memmove not supported\");\n         let size = self.intcast(size, self.type_isize(), false);\n         let is_volatile = flags.contains(MemFlags::VOLATILE);\n         let dst = self.pointercast(dst, self.type_i8p());"}, {"sha": "de3f719b8163c7ab0486ead4761cd579a06c078d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -20,7 +20,7 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &mut Builder<'_,\n         // LLVM to keep around the reference to the global.\n         let indices = [bx.const_i32(0), bx.const_i32(0)];\n         let element = bx.inbounds_gep(gdb_debug_scripts_section, &indices);\n-        let volative_load_instruction = bx.volatile_load(element);\n+        let volative_load_instruction = bx.volatile_load(bx.type_i8(), element);\n         unsafe {\n             llvm::LLVMSetAlignment(volative_load_instruction, 1);\n         }"}, {"sha": "a48a694b630f001cd5c17b34d82de0234a3a0d5d", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -162,11 +162,14 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n             sym::volatile_load | sym::unaligned_volatile_load => {\n                 let tp_ty = substs.type_at(0);\n-                let mut ptr = args[0].immediate();\n-                if let PassMode::Cast(ty) = fn_abi.ret.mode {\n-                    ptr = self.pointercast(ptr, self.type_ptr_to(ty.llvm_type(self)));\n-                }\n-                let load = self.volatile_load(ptr);\n+                let ptr = args[0].immediate();\n+                let load = if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                    let llty = ty.llvm_type(self);\n+                    let ptr = self.pointercast(ptr, self.type_ptr_to(llty));\n+                    self.volatile_load(llty, ptr)\n+                } else {\n+                    self.volatile_load(self.layout_of(tp_ty).llvm_type(self), ptr)\n+                };\n                 let align = if name == sym::unaligned_volatile_load {\n                     1\n                 } else {\n@@ -319,9 +322,9 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     let integer_ty = self.type_ix(layout.size.bits());\n                     let ptr_ty = self.type_ptr_to(integer_ty);\n                     let a_ptr = self.bitcast(a, ptr_ty);\n-                    let a_val = self.load(a_ptr, layout.align.abi);\n+                    let a_val = self.load(integer_ty, a_ptr, layout.align.abi);\n                     let b_ptr = self.bitcast(b, ptr_ty);\n-                    let b_val = self.load(b_ptr, layout.align.abi);\n+                    let b_val = self.load(integer_ty, b_ptr, layout.align.abi);\n                     self.icmp(IntPredicate::IntEQ, a_val, b_val)\n                 } else {\n                     let i8p_ty = self.type_i8p();\n@@ -540,7 +543,7 @@ fn codegen_msvc_try(\n         // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n         let flags = bx.const_i32(8);\n         let funclet = catchpad_rust.catch_pad(cs, &[tydesc, flags, slot]);\n-        let ptr = catchpad_rust.load(slot, ptr_align);\n+        let ptr = catchpad_rust.load(bx.type_i8p(), slot, ptr_align);\n         catchpad_rust.call(catch_func, &[data, ptr], Some(&funclet));\n         catchpad_rust.catch_ret(&funclet, caught.llbb());\n "}, {"sha": "2ade66ac41eda9cce77b737db651a6fe949bf712", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -1385,7 +1385,12 @@ extern \"C\" {\n         Val: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildLoad(B: &Builder<'a>, PointerVal: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildLoad2(\n+        B: &Builder<'a>,\n+        Ty: &'a Type,\n+        PointerVal: &'a Value,\n+        Name: *const c_char,\n+    ) -> &'a Value;\n \n     pub fn LLVMBuildStore(B: &Builder<'a>, Val: &'a Value, Ptr: &'a Value) -> &'a Value;\n \n@@ -1631,6 +1636,7 @@ extern \"C\" {\n     // Atomic Operations\n     pub fn LLVMRustBuildAtomicLoad(\n         B: &Builder<'a>,\n+        ElementType: &'a Type,\n         PointerVal: &'a Value,\n         Name: *const c_char,\n         Order: AtomicOrdering,"}, {"sha": "9df1bd7d1d9bb20897aa3022a92bfd6aab9d629f", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -32,14 +32,15 @@ fn emit_direct_ptr_va_arg(\n     slot_size: Align,\n     allow_higher_align: bool,\n ) -> (&'ll Value, Align) {\n-    let va_list_ptr_ty = bx.cx().type_ptr_to(bx.cx.type_i8p());\n+    let va_list_ty = bx.type_i8p();\n+    let va_list_ptr_ty = bx.type_ptr_to(va_list_ty);\n     let va_list_addr = if list.layout.llvm_type(bx.cx) != va_list_ptr_ty {\n         bx.bitcast(list.immediate(), va_list_ptr_ty)\n     } else {\n         list.immediate()\n     };\n \n-    let ptr = bx.load(va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n+    let ptr = bx.load(va_list_ty, va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n \n     let (addr, addr_align) = if allow_higher_align && align > slot_size {\n         (round_pointer_up_to_alignment(bx, ptr, align, bx.cx().type_i8p()), align)\n@@ -82,10 +83,10 @@ fn emit_ptr_va_arg(\n     let (addr, addr_align) =\n         emit_direct_ptr_va_arg(bx, list, llty, size, align.abi, slot_size, allow_higher_align);\n     if indirect {\n-        let tmp_ret = bx.load(addr, addr_align);\n-        bx.load(tmp_ret, align.abi)\n+        let tmp_ret = bx.load(llty, addr, addr_align);\n+        bx.load(bx.cx.layout_of(target_ty).llvm_type(bx.cx), tmp_ret, align.abi)\n     } else {\n-        bx.load(addr, addr_align)\n+        bx.load(llty, addr, addr_align)\n     }\n }\n \n@@ -118,7 +119,7 @@ fn emit_aapcs_va_arg(\n     };\n \n     // if the offset >= 0 then the value will be on the stack\n-    let mut reg_off_v = bx.load(reg_off, offset_align);\n+    let mut reg_off_v = bx.load(bx.type_i32(), reg_off, offset_align);\n     let use_stack = bx.icmp(IntPredicate::IntSGE, reg_off_v, zero);\n     bx.cond_br(use_stack, &on_stack.llbb(), &maybe_reg.llbb());\n \n@@ -139,8 +140,9 @@ fn emit_aapcs_va_arg(\n     let use_stack = maybe_reg.icmp(IntPredicate::IntSGT, new_reg_off_v, zero);\n     maybe_reg.cond_br(use_stack, &on_stack.llbb(), &in_reg.llbb());\n \n+    let top_type = bx.type_i8p();\n     let top = in_reg.struct_gep(va_list_addr, reg_top_index);\n-    let top = in_reg.load(top, bx.tcx().data_layout.pointer_align.abi);\n+    let top = in_reg.load(top_type, top, bx.tcx().data_layout.pointer_align.abi);\n \n     // reg_value = *(@top + reg_off_v);\n     let mut reg_addr = in_reg.gep(top, &[reg_off_v]);\n@@ -149,8 +151,9 @@ fn emit_aapcs_va_arg(\n         let offset = bx.const_i32((slot_size - layout.size.bytes()) as i32);\n         reg_addr = in_reg.gep(reg_addr, &[offset]);\n     }\n-    let reg_addr = in_reg.bitcast(reg_addr, bx.cx.type_ptr_to(layout.llvm_type(bx)));\n-    let reg_value = in_reg.load(reg_addr, layout.align.abi);\n+    let reg_type = layout.llvm_type(bx);\n+    let reg_addr = in_reg.bitcast(reg_addr, bx.cx.type_ptr_to(reg_type));\n+    let reg_value = in_reg.load(reg_type, reg_addr, layout.align.abi);\n     in_reg.br(&end.llbb());\n \n     // On Stack block"}, {"sha": "b392b2c4ab8acfc70aa129b04767cb9efb8d9338", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -20,10 +20,11 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, bx.type_ptr_to(bx.fn_ptr_backend_type(fn_abi)));\n+        let llty = bx.fn_ptr_backend_type(fn_abi);\n+        let llvtable = bx.pointercast(llvtable, bx.type_ptr_to(llty));\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let gep = bx.inbounds_gep(llvtable, &[bx.const_usize(self.0)]);\n-        let ptr = bx.load(gep, ptr_align);\n+        let ptr = bx.load(llty, gep, ptr_align);\n         bx.nonnull_metadata(ptr);\n         // Vtable loads are invariant.\n         bx.set_invariant_load(ptr);\n@@ -38,10 +39,11 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, bx.type_ptr_to(bx.type_isize()));\n+        let llty = bx.type_isize();\n+        let llvtable = bx.pointercast(llvtable, bx.type_ptr_to(llty));\n         let usize_align = bx.tcx().data_layout.pointer_align.abi;\n         let gep = bx.inbounds_gep(llvtable, &[bx.const_usize(self.0)]);\n-        let ptr = bx.load(gep, usize_align);\n+        let ptr = bx.load(llty, gep, usize_align);\n         // Vtable loads are invariant.\n         bx.set_invariant_load(ptr);\n         ptr"}, {"sha": "b584801a62de2cb91cefe79303dae8bb58d6fb3b", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 let op = self.codegen_consume(&mut bx, mir::Place::return_place().as_ref());\n                 if let Ref(llval, _, align) = op.val {\n-                    bx.load(llval, align)\n+                    bx.load(bx.backend_type(op.layout), llval, align)\n                 } else {\n                     op.immediate_or_packed_pair(&mut bx)\n                 }\n@@ -287,8 +287,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         llval\n                     }\n                 };\n-                let addr = bx.pointercast(llslot, bx.type_ptr_to(bx.cast_backend_type(&cast_ty)));\n-                bx.load(addr, self.fn_abi.ret.layout.align.abi)\n+                let ty = bx.cast_backend_type(&cast_ty);\n+                let addr = bx.pointercast(llslot, bx.type_ptr_to(ty));\n+                bx.load(ty, addr, self.fn_abi.ret.layout.align.abi)\n             }\n         };\n         bx.ret(llval);\n@@ -1086,15 +1087,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n-                let addr = bx.pointercast(llval, bx.type_ptr_to(bx.cast_backend_type(&ty)));\n-                llval = bx.load(addr, align.min(arg.layout.align.abi));\n+                let llty = bx.cast_backend_type(&ty);\n+                let addr = bx.pointercast(llval, bx.type_ptr_to(llty));\n+                llval = bx.load(llty, addr, align.min(arg.layout.align.abi));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n                 // used for this call is passing it by-value. In that case,\n                 // the load would just produce `OperandValue::Ref` instead\n                 // of the `OperandValue::Immediate` we need for the call.\n-                llval = bx.load(llval, align);\n+                llval = bx.load(bx.backend_type(arg.layout), llval, align);\n                 if let abi::Abi::Scalar(ref scalar) = arg.layout.abi {\n                     if scalar.is_bool() {\n                         bx.range_metadata(llval, 0..2);"}, {"sha": "c139f915e6cbb21932924f897e7a2822da161658", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -274,7 +274,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 match *elem {\n                     mir::ProjectionElem::Deref => {\n                         indirect_offsets.push(Size::ZERO);\n-                        place = place.project_deref(bx);\n+                        place = bx.load_operand(place).deref(bx.cx());\n                     }\n                     mir::ProjectionElem::Field(field, _) => {\n                         let i = field.index();"}, {"sha": "56ff1b3934c13e1b070bf56d2becc9e3af7b18d7", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -448,15 +448,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             if ty.is_unsafe_ptr() {\n                                 // Some platforms do not support atomic operations on pointers,\n                                 // so we cast to integer first...\n-                                let ptr_llty = bx.type_ptr_to(bx.type_isize());\n+                                let llty = bx.type_isize();\n+                                let ptr_llty = bx.type_ptr_to(llty);\n                                 source = bx.pointercast(source, ptr_llty);\n-                            }\n-                            let result = bx.atomic_load(source, order, size);\n-                            if ty.is_unsafe_ptr() {\n+                                let result = bx.atomic_load(llty, source, order, size);\n                                 // ... and then cast the result back to a pointer\n                                 bx.inttoptr(result, bx.backend_type(layout))\n                             } else {\n-                                result\n+                                bx.atomic_load(bx.backend_type(layout), source, order, size)\n                             }\n                         } else {\n                             return invalid_monomorphization(ty);"}, {"sha": "3c42b2cc2ea7a57206bf5a0b31587063f9690c82", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -289,6 +289,14 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n         }\n         match self {\n             OperandValue::Ref(r, None, source_align) => {\n+                if flags.contains(MemFlags::NONTEMPORAL) {\n+                    // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n+                    let ty = bx.backend_type(dest.layout);\n+                    let ptr = bx.pointercast(r, bx.type_ptr_to(ty));\n+                    let val = bx.load(ty, ptr, source_align);\n+                    bx.store_with_flags(val, dest.llval, dest.align, flags);\n+                    return;\n+                }\n                 base::memcpy_ty(bx, dest.llval, dest.align, r, source_align, dest.layout, flags)\n             }\n             OperandValue::Ref(_, Some(_), _) => {"}, {"sha": "66d9d1a1e0c490ef2237a25e1602c92f8ceda921", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -402,18 +402,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         downcast\n     }\n \n-    pub fn project_deref<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) -> Self {\n-        let target_ty = self.layout.ty.builtin_deref(true).expect(\"failed to deref\");\n-        let layout = bx.layout_of(target_ty.ty);\n-\n-        PlaceRef {\n-            llval: bx.load(self.llval, self.align),\n-            llextra: None,\n-            layout,\n-            align: layout.align.abi,\n-        }\n-    }\n-\n     pub fn storage_live<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }"}, {"sha": "f0c232a97bc946bd395957a3ecea12640b054b6d", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -137,9 +137,15 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n     fn array_alloca(&mut self, ty: Self::Type, len: Self::Value, align: Align) -> Self::Value;\n \n-    fn load(&mut self, ptr: Self::Value, align: Align) -> Self::Value;\n-    fn volatile_load(&mut self, ptr: Self::Value) -> Self::Value;\n-    fn atomic_load(&mut self, ptr: Self::Value, order: AtomicOrdering, size: Size) -> Self::Value;\n+    fn load(&mut self, ty: Self::Type, ptr: Self::Value, align: Align) -> Self::Value;\n+    fn volatile_load(&mut self, ty: Self::Type, ptr: Self::Value) -> Self::Value;\n+    fn atomic_load(\n+        &mut self,\n+        ty: Self::Type,\n+        ptr: Self::Value,\n+        order: AtomicOrdering,\n+        size: Size,\n+    ) -> Self::Value;\n     fn load_operand(&mut self, place: PlaceRef<'tcx, Self::Value>)\n     -> OperandRef<'tcx, Self::Value>;\n "}, {"sha": "4cdc8a4155bcc58ba6489aab09e433a750afdace", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/432e145bd5a974c5b6f4dd9b352891bd7502b69d/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=432e145bd5a974c5b6f4dd9b352891bd7502b69d", "patch": "@@ -349,11 +349,10 @@ extern \"C\" void LLVMRustSetFastMath(LLVMValueRef V) {\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMValueRef Source, const char *Name,\n-                        LLVMAtomicOrdering Order) {\n+LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Source,\n+                        const char *Name, LLVMAtomicOrdering Order) {\n   Value *Ptr = unwrap(Source);\n-  Type *Ty = Ptr->getType()->getPointerElementType();\n-  LoadInst *LI = unwrap(B)->CreateLoad(Ty, Ptr, Name);\n+  LoadInst *LI = unwrap(B)->CreateLoad(unwrap(Ty), Ptr, Name);\n   LI->setAtomic(fromRust(Order));\n   return wrap(LI);\n }"}]}