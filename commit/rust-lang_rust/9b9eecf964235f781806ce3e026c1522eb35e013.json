{"sha": "9b9eecf964235f781806ce3e026c1522eb35e013", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliOWVlY2Y5NjQyMzVmNzgxODA2Y2UzZTAyNmMxNTIyZWIzNWUwMTM=", "commit": {"author": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2019-07-13T02:00:06Z"}, "committer": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2019-08-17T16:43:02Z"}, "message": "Store allocation size, make bytes, undef_mask private\n\nDirect access to the bytes was previously a problem (#62931) where\ncomponents would read their contents without properly checking\nrelocations and/or definedness.\n\nMaking bytes private instead of purely renaming them also helps in\nallowing amendments to their allocation scheme (such as eliding\nallocation for undef of constant regions).", "tree": {"sha": "733be4b41abe8fa72514a6914f2e474d29a239ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/733be4b41abe8fa72514a6914f2e474d29a239ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9eecf964235f781806ce3e026c1522eb35e013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9eecf964235f781806ce3e026c1522eb35e013", "html_url": "https://github.com/rust-lang/rust/commit/9b9eecf964235f781806ce3e026c1522eb35e013", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9eecf964235f781806ce3e026c1522eb35e013/comments", "author": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c43d03a19f326f4a323569328cc501e86eb6d22e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c43d03a19f326f4a323569328cc501e86eb6d22e", "html_url": "https://github.com/rust-lang/rust/commit/c43d03a19f326f4a323569328cc501e86eb6d22e"}], "stats": {"total": 53, "additions": 42, "deletions": 11}, "files": [{"sha": "e33991bb1b6f84bc9b39aab2e4f4730e5e6b767d", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b9eecf964235f781806ce3e026c1522eb35e013/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9eecf964235f781806ce3e026c1522eb35e013/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=9b9eecf964235f781806ce3e026c1522eb35e013", "patch": "@@ -176,15 +176,21 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n         hasher: &mut StableHasher<W>,\n     ) {\n         let mir::interpret::Allocation {\n-            bytes, relocations, undef_mask, align, mutability,\n+            relocations, align, mutability, size,\n             extra: _,\n+            .. /* private bytes and undef_mask */\n         } = self;\n+\n+        let bytes = self.inspect_with_undef_and_ptr_outside_interpreter(0..self.len());\n+        let undef_mask = self.undef_mask();\n+\n         bytes.hash_stable(hcx, hasher);\n         relocations.len().hash_stable(hcx, hasher);\n         for reloc in relocations.iter() {\n             reloc.hash_stable(hcx, hasher);\n         }\n         undef_mask.hash_stable(hcx, hasher);\n+        size.hash_stable(hcx, hasher);\n         align.hash_stable(hcx, hasher);\n         mutability.hash_stable(hcx, hasher);\n     }"}, {"sha": "61b237c0bb3956a64919c9ca760a3cb5d04c9dae", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9b9eecf964235f781806ce3e026c1522eb35e013/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9eecf964235f781806ce3e026c1522eb35e013/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=9b9eecf964235f781806ce3e026c1522eb35e013", "patch": "@@ -16,15 +16,17 @@ use std::borrow::Cow;\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation<Tag=(),Extra=()> {\n     /// The actual bytes of the allocation.\n-    /// Note that the bytes of a pointer represent the offset of the pointer\n-    pub bytes: Vec<u8>,\n+    /// Note that the bytes of a pointer represent the offset of the pointer.\n+    bytes: Vec<u8>,\n     /// Maps from byte addresses to extra data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n     /// at the given offset.\n     pub relocations: Relocations<Tag>,\n-    /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n-    pub undef_mask: UndefMask,\n+    /// Denotes which part of this allocation is initialized.\n+    undef_mask: UndefMask,\n+    /// The size of the allocation. Currently, must always equal `bytes.len()`.\n+    pub size: Size,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n     /// Whether the allocation is mutable.\n@@ -85,11 +87,12 @@ impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n-        let undef_mask = UndefMask::new(Size::from_bytes(bytes.len() as u64), true);\n+        let size = Size::from_bytes(bytes.len() as u64);\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n-            undef_mask,\n+            undef_mask: UndefMask::new(size, true),\n+            size,\n             align,\n             mutability: Mutability::Immutable,\n             extra: (),\n@@ -106,13 +109,29 @@ impl<Tag> Allocation<Tag> {\n             bytes: vec![0; size.bytes() as usize],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n+            size,\n             align,\n             mutability: Mutability::Mutable,\n             extra: (),\n         }\n     }\n }\n \n+/// Raw accessors. Provide access to otherwise private bytes.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    pub fn len(&self) -> usize {\n+        self.size.bytes() as usize\n+    }\n+\n+    /// Look at a slice which may describe undefined bytes or describe a relocation. This differs\n+    /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n+    /// edges) at all. It further ignores `AllocationExtra` callbacks.\n+    /// This must not be used for reads affecting the interpreter execution.\n+    pub fn inspect_with_undef_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n+        &self.bytes[range]\n+    }\n+}\n+\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n /// Byte accessors\n@@ -132,9 +151,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         );\n         let end = end.bytes() as usize;\n         assert!(\n-            end <= self.bytes.len(),\n+            end <= self.len(),\n             \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n-            offset.bytes(), size.bytes(), self.bytes.len()\n+            offset.bytes(), size.bytes(), self.len()\n         );\n         (offset.bytes() as usize)..end\n     }"}, {"sha": "a72ecdb5745bbcfe8c884e43b00c714576b7a000", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9eecf964235f781806ce3e026c1522eb35e013/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9eecf964235f781806ce3e026c1522eb35e013/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=9b9eecf964235f781806ce3e026c1522eb35e013", "patch": "@@ -944,10 +944,16 @@ pub trait PrettyPrinter<'tcx>:\n                         .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    Some(&data.bytes[start..end])\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active slice reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Str) => {\n-                    let slice = &data.bytes[start..end];\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active `str` reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n                     let s = ::std::str::from_utf8(slice)\n                         .expect(\"non utf8 str from miri\");\n                     p!(write(\"{:?}\", s));"}]}