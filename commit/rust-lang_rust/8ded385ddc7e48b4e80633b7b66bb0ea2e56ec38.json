{"sha": "8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "node_id": "C_kwDOAAsO6NoAKDhkZWQzODVkZGM3ZTQ4YjRlODA2MzNiN2I2NmJiMGVhMmU1NmVjMzg", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-11-15T16:58:25Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-11-15T18:17:59Z"}, "message": "Improve `needless_borrow` lint.\n\n* Lint when a borrow is auto dereferenced more than once\n* Lint when the expression is used as the expression of a block for a match arm\n\nMoves `needless_borrow` and `ref_binding_to_reference` to `dereference`\nlint pass in preperation for `explicit_auto_deref` lint.", "tree": {"sha": "5da3ecc8bc2832aff095adffa0d745531091db9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5da3ecc8bc2832aff095adffa0d745531091db9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "html_url": "https://github.com/rust-lang/rust/commit/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f51fb341dd3ff79f400ee816dceb81eb2d0c5106", "url": "https://api.github.com/repos/rust-lang/rust/commits/f51fb341dd3ff79f400ee816dceb81eb2d0c5106", "html_url": "https://github.com/rust-lang/rust/commit/f51fb341dd3ff79f400ee816dceb81eb2d0c5106"}], "stats": {"total": 731, "additions": 425, "deletions": 306}, "files": [{"sha": "afb317421d0773aed78d0fdef2dc27089a6949d1", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -74,10 +74,10 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                     if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n                         &args[0]\n                     } else {\n-                        &filter_recv\n+                        filter_recv\n                     }\n                 } else {\n-                    &filter_recv\n+                    filter_recv\n                 };\n                 let mut applicability = Applicability::MaybeIncorrect;\n                 span_lint_and_sugg("}, {"sha": "fa2b348591be4d7a0118095a99734f9297f60900", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 330, "deletions": 5, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -1,14 +1,20 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_context;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::peel_mid_ty_refs;\n-use clippy_utils::{get_parent_node, is_lint_allowed};\n-use rustc_ast::util::parser::PREC_PREFIX;\n+use clippy_utils::{get_parent_expr, get_parent_node, is_lint_allowed, path_to_local};\n+use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, HirId, MatchSource, Mutability, Node, UnOp};\n+use rustc_hir::{\n+    BindingAnnotation, Body, BodyId, BorrowKind, Destination, Expr, ExprKind, HirId, MatchSource, Mutability, Node,\n+    Pat, PatKind, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::{self, Ty, TyCtxt, TyS, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span};\n+use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -40,8 +46,64 @@ declare_clippy_lint! {\n     \"Explicit use of deref or deref_mut method while not in a method chain.\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for address of operations (`&`) that are going to\n+    /// be dereferenced immediately by the compiler.\n+    ///\n+    /// ### Why is this bad?\n+    /// Suggests that the receiver of the expression borrows\n+    /// the expression.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn fun(_a: &i32) {}\n+    ///\n+    /// // Bad\n+    /// let x: &i32 = &&&&&&5;\n+    /// fun(&x);\n+    ///\n+    /// // Good\n+    /// let x: &i32 = &5;\n+    /// fun(x);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub NEEDLESS_BORROW,\n+    style,\n+    \"taking a reference that is going to be automatically dereferenced\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `ref` bindings which create a reference to a reference.\n+    ///\n+    /// ### Why is this bad?\n+    /// The address-of operator at the use site is clearer about the need for a reference.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // Bad\n+    /// let x = Some(\"\");\n+    /// if let Some(ref x) = x {\n+    ///     // use `x` here\n+    /// }\n+    ///\n+    /// // Good\n+    /// let x = Some(\"\");\n+    /// if let Some(x) = x {\n+    ///     // use `&x` here\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.54.0\"]\n+    pub REF_BINDING_TO_REFERENCE,\n+    pedantic,\n+    \"`ref` binding to a reference\"\n+}\n+\n impl_lint_pass!(Dereferencing => [\n     EXPLICIT_DEREF_METHODS,\n+    NEEDLESS_BORROW,\n+    REF_BINDING_TO_REFERENCE,\n ]);\n \n #[derive(Default)]\n@@ -52,6 +114,18 @@ pub struct Dereferencing {\n     // expression. This is to store the id of that expression so it can be skipped when\n     // `check_expr` is called for it.\n     skip_expr: Option<HirId>,\n+\n+    /// The body the first local was found in. Used to emit lints when the traversal of the body has\n+    /// been finished. Note we can't lint at the end of every body as they can be nested within each\n+    /// other.\n+    current_body: Option<BodyId>,\n+    /// The list of locals currently being checked by the lint.\n+    /// If the value is `None`, then the binding has been seen as a ref pattern, but is not linted.\n+    /// This is needed for or patterns where one of the branches can be linted, but another can not\n+    /// be.\n+    ///\n+    /// e.g. `m!(x) | Foo::Bar(ref x)`\n+    ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n }\n \n struct StateData {\n@@ -68,6 +142,9 @@ enum State {\n         ty_changed_count: usize,\n         is_final_ufcs: bool,\n     },\n+    DerefedBorrow {\n+        count: u32,\n+    },\n }\n \n // A reference operation considered by this lint pass\n@@ -77,13 +154,29 @@ enum RefOp {\n     AddrOf,\n }\n \n+struct RefPat {\n+    /// Whether every usage of the binding is dereferenced.\n+    always_deref: bool,\n+    /// The spans of all the ref bindings for this local.\n+    spans: Vec<Span>,\n+    /// The applicability of this suggestion.\n+    app: Applicability,\n+    /// All the replacements which need to be made.\n+    replacements: Vec<(Span, String)>,\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n+    #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Skip path expressions from deref calls. e.g. `Deref::deref(e)`\n         if Some(expr.hir_id) == self.skip_expr.take() {\n             return;\n         }\n \n+        if let Some(local) = path_to_local(expr) {\n+            self.check_local_usage(cx, expr, local);\n+        }\n+\n         // Stop processing sub expressions when a macro call is seen\n         if expr.span.from_expansion() {\n             if let Some((state, data)) = self.state.take() {\n@@ -128,6 +221,48 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             },\n                         ));\n                     },\n+                    RefOp::AddrOf => {\n+                        // Find the number of times the borrow is auto-derefed.\n+                        let mut iter = find_adjustments(cx.tcx, typeck, expr).iter();\n+                        if let Some((i, adjust)) = iter.by_ref().enumerate().find_map(|(i, adjust)| {\n+                            if !matches!(adjust.kind, Adjust::Deref(_)) {\n+                                Some((i, adjust))\n+                            } else if !adjust.target.is_ref() {\n+                                // Add one to the number of references found.\n+                                Some((i + 1, adjust))\n+                            } else {\n+                                None\n+                            }\n+                        }) {\n+                            // Found two consecutive derefs. At least one can be removed.\n+                            if i > 1 {\n+                                let target_mut = iter::once(adjust)\n+                                    .chain(iter)\n+                                    .find_map(|adjust| match adjust.kind {\n+                                        Adjust::Borrow(AutoBorrow::Ref(_, m)) => Some(m.into()),\n+                                        _ => None,\n+                                    })\n+                                    // This default should never happen. Auto-deref always reborrows.\n+                                    .unwrap_or(Mutability::Not);\n+                                self.state = Some((\n+                                    // Subtract one for the current borrow expression, and one to cover the last\n+                                    // reference which can't be removed (it's either reborrowed, or needed for\n+                                    // auto-deref to happen).\n+                                    State::DerefedBorrow {\n+                                        count:\n+                                            // Truncation here would require more than a `u32::MAX` level reference. The compiler\n+                                            // does not support this.\n+                                            #[allow(clippy::cast_possible_truncation)]\n+                                            { i as u32 - 2 }\n+                                    },\n+                                    StateData {\n+                                        span: expr.span,\n+                                        target_mut,\n+                                    },\n+                                ));\n+                            }\n+                        }\n+                    },\n                     _ => (),\n                 }\n             },\n@@ -144,10 +279,80 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     data,\n                 ));\n             },\n+            (Some((State::DerefedBorrow { count }, data)), RefOp::AddrOf) if count != 0 => {\n+                self.state = Some((State::DerefedBorrow { count: count - 1 }, data));\n+            },\n \n             (Some((state, data)), _) => report(cx, expr, state, data),\n         }\n     }\n+\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n+        if let PatKind::Binding(BindingAnnotation::Ref, id, name, _) = pat.kind {\n+            if let Some(opt_prev_pat) = self.ref_locals.get_mut(&id) {\n+                // This binding id has been seen before. Add this pattern to the list of changes.\n+                if let Some(prev_pat) = opt_prev_pat {\n+                    if pat.span.from_expansion() {\n+                        // Doesn't match the context of the previous pattern. Can't lint here.\n+                        *opt_prev_pat = None;\n+                    } else {\n+                        prev_pat.spans.push(pat.span);\n+                        prev_pat.replacements.push((\n+                            pat.span,\n+                            snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut prev_pat.app)\n+                                .0\n+                                .into(),\n+                        ));\n+                    }\n+                }\n+                return;\n+            }\n+\n+            if_chain! {\n+                if !pat.span.from_expansion();\n+                if let ty::Ref(_, tam, _) = *cx.typeck_results().pat_ty(pat).kind();\n+                // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n+                if let ty::Ref(_, _, Mutability::Not) = *tam.kind();\n+                then {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let snip = snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut app).0;\n+                    self.current_body = self.current_body.or(cx.enclosing_body);\n+                    self.ref_locals.insert(\n+                        id,\n+                        Some(RefPat {\n+                            always_deref: true,\n+                            spans: vec![pat.span],\n+                            app,\n+                            replacements: vec![(pat.span, snip.into())],\n+                        }),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        if Some(body.id()) == self.current_body {\n+            for pat in self.ref_locals.drain(..).filter_map(|(_, x)| x) {\n+                let replacements = pat.replacements;\n+                let app = pat.app;\n+                span_lint_and_then(\n+                    cx,\n+                    if pat.always_deref {\n+                        NEEDLESS_BORROW\n+                    } else {\n+                        REF_BINDING_TO_REFERENCE\n+                    },\n+                    pat.spans,\n+                    \"this pattern creates a reference to a reference\",\n+                    |diag| {\n+                        diag.multipart_suggestion(\"try this\", replacements, app);\n+                    },\n+                );\n+            }\n+            self.current_body = None;\n+        }\n+    }\n }\n \n fn try_parse_ref_op(\n@@ -251,6 +456,48 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n     }\n }\n \n+/// Adjustments are sometimes made in the parent block rather than the expression itself.\n+fn find_adjustments(\n+    tcx: TyCtxt<'tcx>,\n+    typeck: &'tcx TypeckResults<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> &'tcx [Adjustment<'tcx>] {\n+    let map = tcx.hir();\n+    let mut iter = map.parent_iter(expr.hir_id);\n+    let mut prev = expr;\n+\n+    loop {\n+        match typeck.expr_adjustments(prev) {\n+            [] => (),\n+            a => break a,\n+        };\n+\n+        match iter.next().map(|(_, x)| x) {\n+            Some(Node::Block(_)) => {\n+                if let Some((_, Node::Expr(e))) = iter.next() {\n+                    prev = e;\n+                } else {\n+                    // This shouldn't happen. Blocks are always contained in an expression.\n+                    break &[];\n+                }\n+            },\n+            Some(Node::Expr(&Expr {\n+                kind: ExprKind::Break(Destination { target_id: Ok(id), .. }, _),\n+                ..\n+            })) => {\n+                if let Some(Node::Expr(e)) = map.find(id) {\n+                    prev = e;\n+                    iter = map.parent_iter(id);\n+                } else {\n+                    // This shouldn't happen. The destination should exist.\n+                    break &[];\n+                }\n+            },\n+            _ => break &[],\n+        }\n+    }\n+}\n+\n #[allow(clippy::needless_pass_by_value)]\n fn report(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: StateData) {\n     match state {\n@@ -301,5 +548,83 @@ fn report(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: Stat\n                 app,\n             );\n         },\n+        State::DerefedBorrow { .. } => {\n+            let mut app = Applicability::MachineApplicable;\n+            let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_BORROW,\n+                data.span,\n+                &format!(\n+                    \"this expression borrows a reference (`{}`) that is immediately dereferenced by the compiler\",\n+                    cx.typeck_results().expr_ty(expr),\n+                ),\n+                \"change this to\",\n+                snip.into(),\n+                app,\n+            );\n+        },\n+    }\n+}\n+\n+impl Dereferencing {\n+    fn check_local_usage(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, local: HirId) {\n+        if let Some(outer_pat) = self.ref_locals.get_mut(&local) {\n+            if let Some(pat) = outer_pat {\n+                // Check for auto-deref\n+                if !matches!(\n+                    cx.typeck_results().expr_adjustments(e),\n+                    [\n+                        Adjustment {\n+                            kind: Adjust::Deref(_),\n+                            ..\n+                        },\n+                        Adjustment {\n+                            kind: Adjust::Deref(_),\n+                            ..\n+                        },\n+                        ..\n+                    ]\n+                ) {\n+                    match get_parent_expr(cx, e) {\n+                        // Field accesses are the same no matter the number of references.\n+                        Some(Expr {\n+                            kind: ExprKind::Field(..),\n+                            ..\n+                        }) => (),\n+                        Some(&Expr {\n+                            span,\n+                            kind: ExprKind::Unary(UnOp::Deref, _),\n+                            ..\n+                        }) if !span.from_expansion() => {\n+                            // Remove explicit deref.\n+                            let snip = snippet_with_context(cx, e.span, span.ctxt(), \"..\", &mut pat.app).0;\n+                            pat.replacements.push((span, snip.into()));\n+                        },\n+                        Some(parent) if !parent.span.from_expansion() => {\n+                            // Double reference might be needed at this point.\n+                            if parent.precedence().order() == PREC_POSTFIX {\n+                                // Parentheses would be needed here, don't lint.\n+                                *outer_pat = None;\n+                            } else {\n+                                pat.always_deref = false;\n+                                let snip = snippet_with_context(cx, e.span, parent.span.ctxt(), \"..\", &mut pat.app).0;\n+                                pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                            }\n+                        },\n+                        _ if !e.span.from_expansion() => {\n+                            // Double reference might be needed at this point.\n+                            pat.always_deref = false;\n+                            let snip = snippet_with_applicability(cx, e.span, \"..\", &mut pat.app);\n+                            pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                        },\n+                        // Edge case for macros. The span of the identifier will usually match the context of the\n+                        // binding, but not if the identifier was created in a macro. e.g. `concat_idents` and proc\n+                        // macros\n+                        _ => *outer_pat = None,\n+                    }\n+                }\n+            }\n+        }\n     }\n }"}, {"sha": "e24ed9905b6a26a8586f731a3c8c987166b638d4", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -33,6 +33,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(copies::IFS_SAME_COND),\n     LintId::of(copies::IF_SAME_THEN_ELSE),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n+    LintId::of(dereference::NEEDLESS_BORROW),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),\n     LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n@@ -203,7 +204,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n     LintId::of(needless_bool::BOOL_COMPARISON),\n     LintId::of(needless_bool::NEEDLESS_BOOL),\n-    LintId::of(needless_borrow::NEEDLESS_BORROW),\n     LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n     LintId::of(needless_option_as_deref::NEEDLESS_OPTION_AS_DEREF),\n     LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),"}, {"sha": "1458d6eab1a1d1a1cb77f9fac7d429bd8ca2d3ce", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -92,6 +92,8 @@ store.register_lints(&[\n     default::FIELD_REASSIGN_WITH_DEFAULT,\n     default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n     dereference::EXPLICIT_DEREF_METHODS,\n+    dereference::NEEDLESS_BORROW,\n+    dereference::REF_BINDING_TO_REFERENCE,\n     derivable_impls::DERIVABLE_IMPLS,\n     derive::DERIVE_HASH_XOR_EQ,\n     derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n@@ -356,8 +358,6 @@ store.register_lints(&[\n     needless_bitwise_bool::NEEDLESS_BITWISE_BOOL,\n     needless_bool::BOOL_COMPARISON,\n     needless_bool::NEEDLESS_BOOL,\n-    needless_borrow::NEEDLESS_BORROW,\n-    needless_borrow::REF_BINDING_TO_REFERENCE,\n     needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n     needless_continue::NEEDLESS_CONTINUE,\n     needless_for_each::NEEDLESS_FOR_EACH,"}, {"sha": "5ee7799f9c519647dd2e44282120d58b3beaf794", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -21,6 +21,7 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(copy_iterator::COPY_ITERATOR),\n     LintId::of(default::DEFAULT_TRAIT_ACCESS),\n     LintId::of(dereference::EXPLICIT_DEREF_METHODS),\n+    LintId::of(dereference::REF_BINDING_TO_REFERENCE),\n     LintId::of(derive::EXPL_IMPL_CLONE_ON_COPY),\n     LintId::of(derive::UNSAFE_DERIVE_DESERIALIZE),\n     LintId::of(doc::DOC_MARKDOWN),\n@@ -68,7 +69,6 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mut_mut::MUT_MUT),\n     LintId::of(needless_bitwise_bool::NEEDLESS_BITWISE_BOOL),\n-    LintId::of(needless_borrow::REF_BINDING_TO_REFERENCE),\n     LintId::of(needless_continue::NEEDLESS_CONTINUE),\n     LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n     LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),"}, {"sha": "f336441ea8420b380caf9335d7e3d39600c37628", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -15,6 +15,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(collapsible_match::COLLAPSIBLE_MATCH),\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n+    LintId::of(dereference::NEEDLESS_BORROW),\n     LintId::of(doc::MISSING_SAFETY_DOC),\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n     LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n@@ -81,7 +82,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(misc_early::REDUNDANT_PATTERN),\n     LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n     LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n-    LintId::of(needless_borrow::NEEDLESS_BORROW),\n     LintId::of(neg_multiply::NEG_MULTIPLY),\n     LintId::of(new_without_default::NEW_WITHOUT_DEFAULT),\n     LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),"}, {"sha": "60109e8aebcff7fa97bc4554ee429ed0d80fb4e9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -297,7 +297,6 @@ mod mutex_atomic;\n mod needless_arbitrary_self_type;\n mod needless_bitwise_bool;\n mod needless_bool;\n-mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n mod needless_for_each;\n@@ -602,7 +601,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(zero_div_zero::ZeroDiv));\n     store.register_late_pass(|| Box::new(mutex_atomic::Mutex));\n     store.register_late_pass(|| Box::new(needless_update::NeedlessUpdate));\n-    store.register_late_pass(|| Box::new(needless_borrow::NeedlessBorrow::default()));\n     store.register_late_pass(|| Box::new(needless_borrowed_ref::NeedlessBorrowedRef));\n     store.register_late_pass(|| Box::new(no_effect::NoEffect));\n     store.register_late_pass(|| Box::new(temporary_assignment::TemporaryAssignment));"}, {"sha": "6709fed91bd18040df18c333887c7990be4f3a10", "filename": "clippy_lints/src/needless_borrow.rs", "status": "removed", "additions": 0, "deletions": 284, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/f51fb341dd3ff79f400ee816dceb81eb2d0c5106/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51fb341dd3ff79f400ee816dceb81eb2d0c5106/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=f51fb341dd3ff79f400ee816dceb81eb2d0c5106", "patch": "@@ -1,284 +0,0 @@\n-//! Checks for needless address of operations (`&`)\n-//!\n-//! This lint is **warn** by default\n-\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::{snippet_opt, snippet_with_applicability, snippet_with_context};\n-use clippy_utils::{get_parent_expr, path_to_local};\n-use if_chain::if_chain;\n-use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_data_structures::fx::FxIndexMap;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, Body, BodyId, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, UnOp};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for address of operations (`&`) that are going to\n-    /// be dereferenced immediately by the compiler.\n-    ///\n-    /// ### Why is this bad?\n-    /// Suggests that the receiver of the expression borrows\n-    /// the expression.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn fun(_a: &i32) {}\n-    ///\n-    /// // Bad\n-    /// let x: &i32 = &&&&&&5;\n-    /// fun(&x);\n-    ///\n-    /// // Good\n-    /// let x: &i32 = &5;\n-    /// fun(x);\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub NEEDLESS_BORROW,\n-    style,\n-    \"taking a reference that is going to be automatically dereferenced\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `ref` bindings which create a reference to a reference.\n-    ///\n-    /// ### Why is this bad?\n-    /// The address-of operator at the use site is clearer about the need for a reference.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// // Bad\n-    /// let x = Some(\"\");\n-    /// if let Some(ref x) = x {\n-    ///     // use `x` here\n-    /// }\n-    ///\n-    /// // Good\n-    /// let x = Some(\"\");\n-    /// if let Some(x) = x {\n-    ///     // use `&x` here\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.54.0\"]\n-    pub REF_BINDING_TO_REFERENCE,\n-    pedantic,\n-    \"`ref` binding to a reference\"\n-}\n-\n-impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW, REF_BINDING_TO_REFERENCE]);\n-#[derive(Default)]\n-pub struct NeedlessBorrow {\n-    /// The body the first local was found in. Used to emit lints when the traversal of the body has\n-    /// been finished. Note we can't lint at the end of every body as they can be nested within each\n-    /// other.\n-    current_body: Option<BodyId>,\n-    /// The list of locals currently being checked by the lint.\n-    /// If the value is `None`, then the binding has been seen as a ref pattern, but is not linted.\n-    /// This is needed for or patterns where one of the branches can be linted, but another can not\n-    /// be.\n-    ///\n-    /// e.g. `m!(x) | Foo::Bar(ref x)`\n-    ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n-}\n-\n-struct RefPat {\n-    /// Whether every usage of the binding is dereferenced.\n-    always_deref: bool,\n-    /// The spans of all the ref bindings for this local.\n-    spans: Vec<Span>,\n-    /// The applicability of this suggestion.\n-    app: Applicability,\n-    /// All the replacements which need to be made.\n-    replacements: Vec<(Span, String)>,\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let Some(local) = path_to_local(e) {\n-            self.check_local_usage(cx, e, local);\n-        }\n-\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::AddrOf(BorrowKind::Ref, mutability, inner) = e.kind {\n-            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(inner).kind() {\n-                for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n-                    if let [\n-                        Adjustment {\n-                            kind: Adjust::Deref(_), ..\n-                        },\n-                        Adjustment {\n-                            kind: Adjust::Deref(_), ..\n-                        },\n-                        Adjustment {\n-                            kind: Adjust::Borrow(_),\n-                            ..\n-                        },\n-                    ] = *adj3\n-                    {\n-                        let help_msg_ty = if matches!(mutability, Mutability::Not) {\n-                            format!(\"&{}\", ty)\n-                        } else {\n-                            format!(\"&mut {}\", ty)\n-                        };\n-\n-                        span_lint_and_then(\n-                            cx,\n-                            NEEDLESS_BORROW,\n-                            e.span,\n-                            &format!(\n-                                \"this expression borrows a reference (`{}`) that is immediately dereferenced \\\n-                             by the compiler\",\n-                                help_msg_ty\n-                            ),\n-                            |diag| {\n-                                if let Some(snippet) = snippet_opt(cx, inner.span) {\n-                                    diag.span_suggestion(\n-                                        e.span,\n-                                        \"change this to\",\n-                                        snippet,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                            },\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if let PatKind::Binding(BindingAnnotation::Ref, id, name, _) = pat.kind {\n-            if let Some(opt_prev_pat) = self.ref_locals.get_mut(&id) {\n-                // This binding id has been seen before. Add this pattern to the list of changes.\n-                if let Some(prev_pat) = opt_prev_pat {\n-                    if pat.span.from_expansion() {\n-                        // Doesn't match the context of the previous pattern. Can't lint here.\n-                        *opt_prev_pat = None;\n-                    } else {\n-                        prev_pat.spans.push(pat.span);\n-                        prev_pat.replacements.push((\n-                            pat.span,\n-                            snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut prev_pat.app)\n-                                .0\n-                                .into(),\n-                        ));\n-                    }\n-                }\n-                return;\n-            }\n-\n-            if_chain! {\n-                if !pat.span.from_expansion();\n-                if let ty::Ref(_, tam, _) = *cx.typeck_results().pat_ty(pat).kind();\n-                // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n-                if let ty::Ref(_, _, Mutability::Not) = *tam.kind();\n-                then {\n-                    let mut app = Applicability::MachineApplicable;\n-                    let snip = snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut app).0;\n-                    self.current_body = self.current_body.or(cx.enclosing_body);\n-                    self.ref_locals.insert(\n-                        id,\n-                        Some(RefPat {\n-                            always_deref: true,\n-                            spans: vec![pat.span],\n-                            app,\n-                            replacements: vec![(pat.span, snip.into())],\n-                        }),\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n-        if Some(body.id()) == self.current_body {\n-            for pat in self.ref_locals.drain(..).filter_map(|(_, x)| x) {\n-                let replacements = pat.replacements;\n-                let app = pat.app;\n-                span_lint_and_then(\n-                    cx,\n-                    if pat.always_deref {\n-                        NEEDLESS_BORROW\n-                    } else {\n-                        REF_BINDING_TO_REFERENCE\n-                    },\n-                    pat.spans,\n-                    \"this pattern creates a reference to a reference\",\n-                    |diag| {\n-                        diag.multipart_suggestion(\"try this\", replacements, app);\n-                    },\n-                );\n-            }\n-            self.current_body = None;\n-        }\n-    }\n-}\n-impl NeedlessBorrow {\n-    fn check_local_usage(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, local: HirId) {\n-        if let Some(outer_pat) = self.ref_locals.get_mut(&local) {\n-            if let Some(pat) = outer_pat {\n-                // Check for auto-deref\n-                if !matches!(\n-                    cx.typeck_results().expr_adjustments(e),\n-                    [\n-                        Adjustment {\n-                            kind: Adjust::Deref(_),\n-                            ..\n-                        },\n-                        Adjustment {\n-                            kind: Adjust::Deref(_),\n-                            ..\n-                        },\n-                        ..\n-                    ]\n-                ) {\n-                    match get_parent_expr(cx, e) {\n-                        // Field accesses are the same no matter the number of references.\n-                        Some(Expr {\n-                            kind: ExprKind::Field(..),\n-                            ..\n-                        }) => (),\n-                        Some(&Expr {\n-                            span,\n-                            kind: ExprKind::Unary(UnOp::Deref, _),\n-                            ..\n-                        }) if !span.from_expansion() => {\n-                            // Remove explicit deref.\n-                            let snip = snippet_with_context(cx, e.span, span.ctxt(), \"..\", &mut pat.app).0;\n-                            pat.replacements.push((span, snip.into()));\n-                        },\n-                        Some(parent) if !parent.span.from_expansion() => {\n-                            // Double reference might be needed at this point.\n-                            if parent.precedence().order() == PREC_POSTFIX {\n-                                // Parentheses would be needed here, don't lint.\n-                                *outer_pat = None;\n-                            } else {\n-                                pat.always_deref = false;\n-                                let snip = snippet_with_context(cx, e.span, parent.span.ctxt(), \"..\", &mut pat.app).0;\n-                                pat.replacements.push((e.span, format!(\"&{}\", snip)));\n-                            }\n-                        },\n-                        _ if !e.span.from_expansion() => {\n-                            // Double reference might be needed at this point.\n-                            pat.always_deref = false;\n-                            let snip = snippet_with_applicability(cx, e.span, \"..\", &mut pat.app);\n-                            pat.replacements.push((e.span, format!(\"&{}\", snip)));\n-                        },\n-                        // Edge case for macros. The span of the identifier will usually match the context of the\n-                        // binding, but not if the identifier was created in a macro. e.g. `concat_idents` and proc\n-                        // macros\n-                        _ => *outer_pat = None,\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "9e37fb9255984fd5421bcff122e237c30d98abaf", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -1,9 +1,10 @@\n // run-rustfix\n \n #[warn(clippy::all, clippy::needless_borrow)]\n-#[allow(unused_variables)]\n+#[allow(unused_variables, clippy::unnecessary_mut_passed)]\n fn main() {\n     let a = 5;\n+    let ref_a = &a;\n     let _ = x(&a); // no warning\n     let _ = x(&a); // warn\n \n@@ -21,11 +22,29 @@ fn main() {\n         44 => &a,\n         45 => {\n             println!(\"foo\");\n-            &&a // FIXME: this should lint, too\n+            &a\n         },\n         46 => &a,\n+        47 => {\n+            println!(\"foo\");\n+            loop {\n+                println!(\"{}\", a);\n+                if a == 25 {\n+                    break ref_a;\n+                }\n+            }\n+        },\n         _ => panic!(),\n     };\n+\n+    let _ = x(&a);\n+    let _ = x(&a);\n+    let _ = x(&mut b);\n+    let _ = x(ref_a);\n+    {\n+        let b = &mut b;\n+        x(b);\n+    }\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "093277784beb2ea6225ecea6087ff98bd9a5130f", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -1,9 +1,10 @@\n // run-rustfix\n \n #[warn(clippy::all, clippy::needless_borrow)]\n-#[allow(unused_variables)]\n+#[allow(unused_variables, clippy::unnecessary_mut_passed)]\n fn main() {\n     let a = 5;\n+    let ref_a = &a;\n     let _ = x(&a); // no warning\n     let _ = x(&&a); // warn\n \n@@ -21,11 +22,29 @@ fn main() {\n         44 => &a,\n         45 => {\n             println!(\"foo\");\n-            &&a // FIXME: this should lint, too\n+            &&a\n         },\n         46 => &&a,\n+        47 => {\n+            println!(\"foo\");\n+            loop {\n+                println!(\"{}\", a);\n+                if a == 25 {\n+                    break &ref_a;\n+                }\n+            }\n+        },\n         _ => panic!(),\n     };\n+\n+    let _ = x(&&&a);\n+    let _ = x(&mut &&a);\n+    let _ = x(&&&mut b);\n+    let _ = x(&&ref_a);\n+    {\n+        let b = &mut b;\n+        x(&b);\n+    }\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "03a5b3d260e6a984179d5cbece2b9cb666393c77", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=8ded385ddc7e48b4e80633b7b66bb0ea2e56ec38", "patch": "@@ -1,22 +1,64 @@\n error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:8:15\n+  --> $DIR/needless_borrow.rs:9:15\n    |\n LL |     let _ = x(&&a); // warn\n    |               ^^^ help: change this to: `&a`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:12:13\n+  --> $DIR/needless_borrow.rs:13:13\n    |\n LL |     mut_ref(&mut &mut b); // warn\n    |             ^^^^^^^^^^^ help: change this to: `&mut b`\n \n error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:26:15\n+  --> $DIR/needless_borrow.rs:25:13\n+   |\n+LL |             &&a\n+   |             ^^^ help: change this to: `&a`\n+\n+error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:27:15\n    |\n LL |         46 => &&a,\n    |               ^^^ help: change this to: `&a`\n \n-error: aborting due to 3 previous errors\n+error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:33:27\n+   |\n+LL |                     break &ref_a;\n+   |                           ^^^^^^ help: change this to: `ref_a`\n+\n+error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:40:15\n+   |\n+LL |     let _ = x(&&&a);\n+   |               ^^^^ help: change this to: `&a`\n+\n+error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:41:15\n+   |\n+LL |     let _ = x(&mut &&a);\n+   |               ^^^^^^^^ help: change this to: `&a`\n+\n+error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:42:15\n+   |\n+LL |     let _ = x(&&&mut b);\n+   |               ^^^^^^^^ help: change this to: `&mut b`\n+\n+error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:43:15\n+   |\n+LL |     let _ = x(&&ref_a);\n+   |               ^^^^^^^ help: change this to: `ref_a`\n+\n+error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:46:11\n+   |\n+LL |         x(&b);\n+   |           ^^ help: change this to: `b`\n+\n+error: aborting due to 10 previous errors\n "}]}