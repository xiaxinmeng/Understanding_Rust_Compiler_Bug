{"sha": "4954a7ef5c5bb45f1c0d021491702ad05d470821", "node_id": "C_kwDOAAsO6NoAKDQ5NTRhN2VmNWM1YmI0NWYxYzBkMDIxNDkxNzAyYWQwNWQ0NzA4MjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-15T17:04:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-15T17:04:25Z"}, "message": "Auto merge of #104616 - RalfJung:ctfe-alignment, r=oli-obk,RalfJung\n\nalways check alignment during CTFE\n\nWe originally disabled alignment checks because they got in the way -- there are some things we do with the interpreter during CTFE which does not correspond to actually running user-written code, but is purely administrative, and we didn't want alignment checks there, so we just disabled them entirely. But with `-Zextra-const-ub-checks` we anyway had to figure out how to disable those alignment checks while doing checks in regular code. So now it is easy to enable CTFE alignment checking by default. Let's see what the perf consequences of that are.\n\nr? `@oli-obk`", "tree": {"sha": "69aff75808ced42e756b27f6a9812ac022ebcb3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69aff75808ced42e756b27f6a9812ac022ebcb3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4954a7ef5c5bb45f1c0d021491702ad05d470821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4954a7ef5c5bb45f1c0d021491702ad05d470821", "html_url": "https://github.com/rust-lang/rust/commit/4954a7ef5c5bb45f1c0d021491702ad05d470821", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4954a7ef5c5bb45f1c0d021491702ad05d470821/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "984eab57f708e62c09b3d708033fe620130b5f39", "url": "https://api.github.com/repos/rust-lang/rust/commits/984eab57f708e62c09b3d708033fe620130b5f39", "html_url": "https://github.com/rust-lang/rust/commit/984eab57f708e62c09b3d708033fe620130b5f39"}, {"sha": "2d89027fac84d7ba95cf2d66b49136d3f0d08ba2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d89027fac84d7ba95cf2d66b49136d3f0d08ba2", "html_url": "https://github.com/rust-lang/rust/commit/2d89027fac84d7ba95cf2d66b49136d3f0d08ba2"}], "stats": {"total": 894, "additions": 543, "deletions": 351}, "files": [{"sha": "13472cc2bfa0a5c4b8ed7ba81baa6eb3114ac9f9", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 65, "deletions": 70, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -86,6 +86,59 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         self.report_decorated(tcx, message, |_| {})\n     }\n \n+    #[instrument(level = \"trace\", skip(self, decorate))]\n+    pub(super) fn decorate(&self, err: &mut Diagnostic, decorate: impl FnOnce(&mut Diagnostic)) {\n+        trace!(\"reporting const eval failure at {:?}\", self.span);\n+        // Add some more context for select error types.\n+        match self.error {\n+            InterpError::Unsupported(\n+                UnsupportedOpInfo::ReadPointerAsBytes\n+                | UnsupportedOpInfo::PartialPointerOverwrite(_)\n+                | UnsupportedOpInfo::PartialPointerCopy(_),\n+            ) => {\n+                err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n+                err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n+            }\n+            _ => {}\n+        }\n+        // Add spans for the stacktrace. Don't print a single-line backtrace though.\n+        if self.stacktrace.len() > 1 {\n+            // Helper closure to print duplicated lines.\n+            let mut flush_last_line = |last_frame, times| {\n+                if let Some((line, span)) = last_frame {\n+                    err.span_note(span, &line);\n+                    // Don't print [... additional calls ...] if the number of lines is small\n+                    if times < 3 {\n+                        for _ in 0..times {\n+                            err.span_note(span, &line);\n+                        }\n+                    } else {\n+                        err.span_note(\n+                            span,\n+                            format!(\"[... {} additional calls {} ...]\", times, &line),\n+                        );\n+                    }\n+                }\n+            };\n+\n+            let mut last_frame = None;\n+            let mut times = 0;\n+            for frame_info in &self.stacktrace {\n+                let frame = (frame_info.to_string(), frame_info.span);\n+                if last_frame.as_ref() == Some(&frame) {\n+                    times += 1;\n+                } else {\n+                    flush_last_line(last_frame, times);\n+                    last_frame = Some(frame);\n+                    times = 0;\n+                }\n+            }\n+            flush_last_line(last_frame, times);\n+        }\n+        // Let the caller attach any additional information it wants.\n+        decorate(err);\n+    }\n+\n     /// Create a diagnostic for this const eval error.\n     ///\n     /// Sets the message passed in via `message` and adds span labels with detailed error\n@@ -101,88 +154,30 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         message: &str,\n         decorate: impl FnOnce(&mut Diagnostic),\n     ) -> ErrorHandled {\n-        let finish = |err: &mut Diagnostic, span_msg: Option<String>| {\n-            trace!(\"reporting const eval failure at {:?}\", self.span);\n-            if let Some(span_msg) = span_msg {\n-                err.span_label(self.span, span_msg);\n-            }\n-            // Add some more context for select error types.\n-            match self.error {\n-                InterpError::Unsupported(\n-                    UnsupportedOpInfo::ReadPointerAsBytes\n-                    | UnsupportedOpInfo::PartialPointerOverwrite(_)\n-                    | UnsupportedOpInfo::PartialPointerCopy(_),\n-                ) => {\n-                    err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n-                    err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n-                }\n-                _ => {}\n-            }\n-            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n-            if self.stacktrace.len() > 1 {\n-                // Helper closure to print duplicated lines.\n-                let mut flush_last_line = |last_frame, times| {\n-                    if let Some((line, span)) = last_frame {\n-                        err.span_note(span, &line);\n-                        // Don't print [... additional calls ...] if the number of lines is small\n-                        if times < 3 {\n-                            for _ in 0..times {\n-                                err.span_note(span, &line);\n-                            }\n-                        } else {\n-                            err.span_note(\n-                                span,\n-                                format!(\"[... {} additional calls {} ...]\", times, &line),\n-                            );\n-                        }\n-                    }\n-                };\n-\n-                let mut last_frame = None;\n-                let mut times = 0;\n-                for frame_info in &self.stacktrace {\n-                    let frame = (frame_info.to_string(), frame_info.span);\n-                    if last_frame.as_ref() == Some(&frame) {\n-                        times += 1;\n-                    } else {\n-                        flush_last_line(last_frame, times);\n-                        last_frame = Some(frame);\n-                        times = 0;\n-                    }\n-                }\n-                flush_last_line(last_frame, times);\n-            }\n-            // Let the caller attach any additional information it wants.\n-            decorate(err);\n-        };\n-\n         debug!(\"self.error: {:?}\", self.error);\n         // Special handling for certain errors\n         match &self.error {\n             // Don't emit a new diagnostic for these errors\n             err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n-                return ErrorHandled::TooGeneric;\n-            }\n-            err_inval!(AlreadyReported(error_reported)) => {\n-                return ErrorHandled::Reported(*error_reported);\n+                ErrorHandled::TooGeneric\n             }\n+            err_inval!(AlreadyReported(error_reported)) => ErrorHandled::Reported(*error_reported),\n             err_inval!(Layout(LayoutError::SizeOverflow(_))) => {\n                 // We must *always* hard error on these, even if the caller wants just a lint.\n                 // The `message` makes little sense here, this is a more serious error than the\n                 // caller thinks anyway.\n                 // See <https://github.com/rust-lang/rust/pull/63152>.\n                 let mut err = struct_error(tcx, &self.error.to_string());\n-                finish(&mut err, None);\n-                return ErrorHandled::Reported(err.emit());\n+                self.decorate(&mut err, decorate);\n+                ErrorHandled::Reported(err.emit())\n             }\n-            _ => {}\n-        };\n-\n-        let err_msg = self.error.to_string();\n-\n-        // Report as hard error.\n-        let mut err = struct_error(tcx, message);\n-        finish(&mut err, Some(err_msg));\n-        ErrorHandled::Reported(err.emit())\n+            _ => {\n+                // Report as hard error.\n+                let mut err = struct_error(tcx, message);\n+                err.span_label(self.span, self.error.to_string());\n+                self.decorate(&mut err, decorate);\n+                ErrorHandled::Reported(err.emit())\n+            }\n+        }\n     }\n }"}, {"sha": "18e01567ca35e44888e52e19abd6bb07edca0d0e", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -1,3 +1,4 @@\n+use crate::const_eval::CheckAlignment;\n use std::borrow::Cow;\n \n use either::{Left, Right};\n@@ -76,7 +77,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n             None => InternKind::Constant,\n         }\n     };\n-    ecx.machine.check_alignment = false; // interning doesn't need to respect alignment\n+    ecx.machine.check_alignment = CheckAlignment::No; // interning doesn't need to respect alignment\n     intern_const_alloc_recursive(ecx, intern_kind, &ret)?;\n     // we leave alignment checks off, since this `ecx` will not be used for further evaluation anyway\n \n@@ -102,11 +103,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n         tcx,\n         root_span,\n         param_env,\n-        CompileTimeInterpreter::new(\n-            tcx.const_eval_limit(),\n-            can_access_statics,\n-            /*check_alignment:*/ false,\n-        ),\n+        CompileTimeInterpreter::new(tcx.const_eval_limit(), can_access_statics, CheckAlignment::No),\n     )\n }\n \n@@ -311,7 +308,11 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         CompileTimeInterpreter::new(\n             tcx.const_eval_limit(),\n             /*can_access_statics:*/ is_static,\n-            /*check_alignment:*/ tcx.sess.opts.unstable_opts.extra_const_ub_checks,\n+            if tcx.sess.opts.unstable_opts.extra_const_ub_checks {\n+                CheckAlignment::Error\n+            } else {\n+                CheckAlignment::FutureIncompat\n+            },\n         ),\n     );\n "}, {"sha": "e006a62feeabd12bc568da7c5c42e76bdde1cc2f", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -1,9 +1,10 @@\n use rustc_hir::def::DefKind;\n-use rustc_hir::LangItem;\n+use rustc_hir::{LangItem, CRATE_HIR_ID};\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::PointerArithmetic;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_session::lint::builtin::INVALID_ALIGNMENT;\n use std::borrow::Borrow;\n use std::hash::Hash;\n use std::ops::ControlFlow;\n@@ -47,14 +48,34 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     pub(super) can_access_statics: bool,\n \n     /// Whether to check alignment during evaluation.\n-    pub(super) check_alignment: bool,\n+    pub(super) check_alignment: CheckAlignment,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum CheckAlignment {\n+    /// Ignore alignment when following relocations.\n+    /// This is mainly used in interning.\n+    No,\n+    /// Hard error when dereferencing a misaligned pointer.\n+    Error,\n+    /// Emit a future incompat lint when dereferencing a misaligned pointer.\n+    FutureIncompat,\n+}\n+\n+impl CheckAlignment {\n+    pub fn should_check(&self) -> bool {\n+        match self {\n+            CheckAlignment::No => false,\n+            CheckAlignment::Error | CheckAlignment::FutureIncompat => true,\n+        }\n+    }\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     pub(crate) fn new(\n         const_eval_limit: Limit,\n         can_access_statics: bool,\n-        check_alignment: bool,\n+        check_alignment: CheckAlignment,\n     ) -> Self {\n         CompileTimeInterpreter {\n             steps_remaining: const_eval_limit.0,\n@@ -309,7 +330,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     const PANIC_ON_ALLOC_FAIL: bool = false; // will be raised as a proper error\n \n     #[inline(always)]\n-    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment {\n         ecx.machine.check_alignment\n     }\n \n@@ -318,6 +339,36 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx.tcx.sess.opts.unstable_opts.extra_const_ub_checks\n     }\n \n+    fn alignment_check_failed(\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n+        has: Align,\n+        required: Align,\n+        check: CheckAlignment,\n+    ) -> InterpResult<'tcx, ()> {\n+        let err = err_ub!(AlignmentCheckFailed { has, required }).into();\n+        match check {\n+            CheckAlignment::Error => Err(err),\n+            CheckAlignment::No => span_bug!(\n+                ecx.cur_span(),\n+                \"`alignment_check_failed` called when no alignment check requested\"\n+            ),\n+            CheckAlignment::FutureIncompat => {\n+                let err = ConstEvalErr::new(ecx, err, None);\n+                ecx.tcx.struct_span_lint_hir(\n+                    INVALID_ALIGNMENT,\n+                    ecx.stack().iter().find_map(|frame| frame.lint_root()).unwrap_or(CRATE_HIR_ID),\n+                    err.span,\n+                    err.error.to_string(),\n+                    |db| {\n+                        err.decorate(db, |_| {});\n+                        db\n+                    },\n+                );\n+                Ok(())\n+            }\n+        }\n+    }\n+\n     fn load_mir(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         instance: ty::InstanceDef<'tcx>,"}, {"sha": "f551b5c29114d9984fcf108ceb1b9e12628db580", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -248,6 +248,15 @@ impl<'mir, 'tcx, Prov: Provenance, Extra> Frame<'mir, 'tcx, Prov, Extra> {\n             Right(span) => span,\n         }\n     }\n+\n+    pub fn lint_root(&self) -> Option<hir::HirId> {\n+        self.current_source_info().and_then(|source_info| {\n+            match &self.body.source_scopes[source_info.scope].local_data {\n+                mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n+                mir::ClearCrossCrate::Clear => None,\n+            }\n+        })\n+    }\n }\n \n impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n@@ -954,12 +963,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This deliberately does *not* honor `requires_caller_location` since it is used for much\n         // more than just panics.\n         for frame in stack.iter().rev() {\n-            let lint_root = frame.current_source_info().and_then(|source_info| {\n-                match &frame.body.source_scopes[source_info.scope].local_data {\n-                    mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n-                    mir::ClearCrossCrate::Clear => None,\n-                }\n-            });\n+            let lint_root = frame.lint_root();\n             let span = frame.current_span();\n \n             frames.push(FrameInfo { span, instance: frame.instance, lint_root });"}, {"sha": "1d4ef20d0651f7bd11d7cb466f0290d375ff27d8", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -10,9 +10,11 @@ use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::Size;\n+use rustc_target::abi::{Align, Size};\n use rustc_target::spec::abi::Abi as CallAbi;\n \n+use crate::const_eval::CheckAlignment;\n+\n use super::{\n     AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n     MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n@@ -122,14 +124,21 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     const PANIC_ON_ALLOC_FAIL: bool;\n \n     /// Whether memory accesses should be alignment-checked.\n-    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n+    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment;\n \n     /// Whether, when checking alignment, we should look at the actual address and thus support\n     /// custom alignment logic based on whatever the integer address happens to be.\n     ///\n     /// If this returns true, Provenance::OFFSET_IS_ADDR must be true.\n     fn use_addr_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n+    fn alignment_check_failed(\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n+        has: Align,\n+        required: Align,\n+        check: CheckAlignment,\n+    ) -> InterpResult<'tcx, ()>;\n+\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n "}, {"sha": "5b1ac6b2f65e29f7bc7a726d3044a6fd5cb95654", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -18,6 +18,8 @@ use rustc_middle::mir::display_allocation;\n use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n+use crate::const_eval::CheckAlignment;\n+\n use super::{\n     alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n     InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n@@ -349,11 +351,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<(AllocId, Size, M::ProvenanceExtra)>> {\n-        let align = M::enforce_alignment(&self).then_some(align);\n         self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n+            M::enforce_alignment(self),\n             CheckInAllocMsg::MemoryAccessTest,\n             |alloc_id, offset, prov| {\n                 let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n@@ -373,10 +375,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx> {\n-        self.check_and_deref_ptr(ptr, size, Some(align), msg, |alloc_id, _, _| {\n-            let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n-            Ok((size, align, ()))\n-        })?;\n+        self.check_and_deref_ptr(\n+            ptr,\n+            size,\n+            align,\n+            CheckAlignment::Error,\n+            msg,\n+            |alloc_id, _, _| {\n+                let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n+                Ok((size, align, ()))\n+            },\n+        )?;\n         Ok(())\n     }\n \n@@ -388,27 +397,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n-        align: Option<Align>,\n+        align: Align,\n+        check: CheckAlignment,\n         msg: CheckInAllocMsg,\n         alloc_size: impl FnOnce(\n             AllocId,\n             Size,\n             M::ProvenanceExtra,\n         ) -> InterpResult<'tcx, (Size, Align, T)>,\n     ) -> InterpResult<'tcx, Option<T>> {\n-        fn check_offset_align<'tcx>(offset: u64, align: Align) -> InterpResult<'tcx> {\n-            if offset % align.bytes() == 0 {\n-                Ok(())\n-            } else {\n-                // The biggest power of two through which `offset` is divisible.\n-                let offset_pow2 = 1 << offset.trailing_zeros();\n-                throw_ub!(AlignmentCheckFailed {\n-                    has: Align::from_bytes(offset_pow2).unwrap(),\n-                    required: align,\n-                })\n-            }\n-        }\n-\n         Ok(match self.ptr_try_get_alloc_id(ptr) {\n             Err(addr) => {\n                 // We couldn't get a proper allocation. This is only okay if the access size is 0,\n@@ -417,8 +414,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     throw_ub!(DanglingIntPointer(addr, msg));\n                 }\n                 // Must be aligned.\n-                if let Some(align) = align {\n-                    check_offset_align(addr, align)?;\n+                if check.should_check() {\n+                    self.check_offset_align(addr, align, check)?;\n                 }\n                 None\n             }\n@@ -441,16 +438,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n-                if let Some(align) = align {\n+                if check.should_check() {\n                     if M::use_addr_for_alignment_check(self) {\n                         // `use_addr_for_alignment_check` can only be true if `OFFSET_IS_ADDR` is true.\n-                        check_offset_align(ptr.addr().bytes(), align)?;\n+                        self.check_offset_align(ptr.addr().bytes(), align, check)?;\n                     } else {\n                         // Check allocation alignment and offset alignment.\n                         if alloc_align.bytes() < align.bytes() {\n-                            throw_ub!(AlignmentCheckFailed { has: alloc_align, required: align });\n+                            M::alignment_check_failed(self, alloc_align, align, check)?;\n                         }\n-                        check_offset_align(offset.bytes(), align)?;\n+                        self.check_offset_align(offset.bytes(), align, check)?;\n                     }\n                 }\n \n@@ -460,6 +457,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         })\n     }\n+\n+    fn check_offset_align(\n+        &self,\n+        offset: u64,\n+        align: Align,\n+        check: CheckAlignment,\n+    ) -> InterpResult<'tcx> {\n+        if offset % align.bytes() == 0 {\n+            Ok(())\n+        } else {\n+            // The biggest power of two through which `offset` is divisible.\n+            let offset_pow2 = 1 << offset.trailing_zeros();\n+            M::alignment_check_failed(self, Align::from_bytes(offset_pow2).unwrap(), align, check)\n+        }\n+    }\n }\n \n /// Allocation accessors\n@@ -560,11 +572,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n-        let align = M::enforce_alignment(self).then_some(align);\n         let ptr_and_alloc = self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n+            M::enforce_alignment(self),\n             CheckInAllocMsg::MemoryAccessTest,\n             |alloc_id, offset, prov| {\n                 let alloc = self.get_alloc_raw(alloc_id)?;"}, {"sha": "905eb71bb18edde28b2eeb30f7d406defedcf4ce", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -364,13 +364,8 @@ where\n             .size_and_align_of_mplace(&mplace)?\n             .unwrap_or((mplace.layout.size, mplace.layout.align.abi));\n         assert!(mplace.align <= align, \"dynamic alignment less strict than static one?\");\n-        let align = M::enforce_alignment(self).then_some(align);\n-        self.check_ptr_access_align(\n-            mplace.ptr,\n-            size,\n-            align.unwrap_or(Align::ONE),\n-            CheckInAllocMsg::DerefTest,\n-        )?;\n+        let align = if M::enforce_alignment(self).should_check() { align } else { Align::ONE };\n+        self.check_ptr_access_align(mplace.ptr, size, align, CheckInAllocMsg::DerefTest)?;\n         Ok(())\n     }\n "}, {"sha": "4ce107ea68d4f0f3869cebe3cce00c706a42f58d", "filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -3,7 +3,7 @@ use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_session::Limit;\n use rustc_target::abi::{Abi, FieldsShape, InitKind, Scalar, Variants};\n \n-use crate::const_eval::CompileTimeInterpreter;\n+use crate::const_eval::{CheckAlignment, CompileTimeInterpreter};\n use crate::interpret::{InterpCx, MemoryKind, OpTy};\n \n /// Determines if this type permits \"raw\" initialization by just transmuting some memory into an\n@@ -41,7 +41,7 @@ fn might_permit_raw_init_strict<'tcx>(\n     let machine = CompileTimeInterpreter::new(\n         Limit::new(0),\n         /*can_access_statics:*/ false,\n-        /*check_alignment:*/ true,\n+        CheckAlignment::Error,\n     );\n \n     let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);"}, {"sha": "33cb35e60ebb6cfc1edf37d68a4262b57956e19b", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -1019,6 +1019,44 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `invalid_alignment` lint detects dereferences of misaligned pointers during\n+    /// constant evluation.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![feature(const_ptr_read)]\n+    /// const FOO: () = unsafe {\n+    ///     let x = &[0_u8; 4];\n+    ///     let y = x.as_ptr().cast::<u32>();\n+    ///     y.read(); // the address of a `u8` array is unknown and thus we don't know if\n+    ///     // it is aligned enough for reading a `u32`.\n+    /// };\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The compiler allowed dereferencing raw pointers irrespective of alignment\n+    /// during const eval due to the const evaluator at the time not making it easy\n+    /// or cheap to check. Now that it is both, this is not accepted anymore.\n+    ///\n+    /// Since it was undefined behaviour to begin with, this breakage does not violate\n+    /// Rust's stability guarantees. Using undefined behaviour can cause arbitrary\n+    /// behaviour, including failure to build.\n+    ///\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n+    pub INVALID_ALIGNMENT,\n+    Deny,\n+    \"raw pointers must be aligned before dereferencing\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #68585 <https://github.com/rust-lang/rust/issues/104616>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n+    };\n+}\n+\n declare_lint! {\n     /// The `exported_private_dependencies` lint detects private dependencies\n     /// that are exposed in a public interface."}, {"sha": "044b7ce65bd71cd65ed54597d246e1e4efc01cac", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -6,6 +6,7 @@ use std::cell::Cell;\n use either::Right;\n \n use rustc_ast::Mutability;\n+use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n@@ -22,7 +23,7 @@ use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayo\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeVisitable};\n use rustc_span::{def_id::DefId, Span};\n-use rustc_target::abi::{self, HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::abi::{self, Align, HasDataLayout, Size, TargetDataLayout};\n use rustc_target::spec::abi::Abi as CallAbi;\n use rustc_trait_selection::traits;\n \n@@ -186,16 +187,27 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     type MemoryKind = !;\n \n     #[inline(always)]\n-    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment {\n         // We do not check for alignment to avoid having to carry an `Align`\n         // in `ConstValue::ByRef`.\n-        false\n+        CheckAlignment::No\n     }\n \n     #[inline(always)]\n     fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n     }\n+    fn alignment_check_failed(\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _has: Align,\n+        _required: Align,\n+        _check: CheckAlignment,\n+    ) -> InterpResult<'tcx, ()> {\n+        span_bug!(\n+            ecx.cur_span(),\n+            \"`alignment_check_failed` called when no alignment check requested\"\n+        )\n+    }\n \n     fn load_mir(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,"}, {"sha": "c75fe2327de3eb0b52e35f0cbebfe02fc9282838", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -2,6 +2,7 @@\n //!\n //! Currently, this pass only propagates scalar values.\n \n+use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_const_eval::interpret::{ConstValue, ImmTy, Immediate, InterpCx, Scalar};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n@@ -10,6 +11,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{Map, State, TrackElem, ValueAnalysis, ValueOrPlace};\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n use rustc_span::DUMMY_SP;\n+use rustc_target::abi::Align;\n \n use crate::MirPass;\n \n@@ -448,13 +450,21 @@ impl<'mir, 'tcx> rustc_const_eval::interpret::Machine<'mir, 'tcx> for DummyMachi\n     type MemoryKind = !;\n     const PANIC_ON_ALLOC_FAIL: bool = true;\n \n-    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment {\n         unimplemented!()\n     }\n \n     fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         unimplemented!()\n     }\n+    fn alignment_check_failed(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _has: Align,\n+        _required: Align,\n+        _check: CheckAlignment,\n+    ) -> interpret::InterpResult<'tcx, ()> {\n+        unimplemented!()\n+    }\n \n     fn find_mir_or_eval_fn(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "0079bb3aad6df5b72e8fb68ff9f1d7844c5a581b", "filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -27,7 +27,7 @@ LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-   = note: dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   = note: dereferencing pointer failed: allocN has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -45,7 +45,7 @@ LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) }\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500ALLOC_ID\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -57,7 +57,7 @@ LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500ALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -68,24 +68,24 @@ LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500ALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:32:1\n    |\n LL | pub static S7: &[u16] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500A_ID+0x1\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID+0x2\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-   = note: dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   = note: dereferencing pointer failed: allocN has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n note: inside `std::slice::from_raw_parts::<'_, u64>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -129,7 +129,7 @@ LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: allocN has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -149,7 +149,7 @@ LL | pub static R4: &[u8] = unsafe {\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -161,7 +161,7 @@ LL | pub static R5: &[u8] = unsafe {\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -172,31 +172,35 @@ LL | pub static R6: &[bool] = unsafe {\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:67:1\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL | pub static R7: &[u16] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   = note: accessing memory with alignment 1, but alignment 2 is required\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eA_ID+0x1\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n-           }\n+note: inside `std::slice::from_raw_parts::<'_, u16>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `from_ptr_range::<'_, u16>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `R7`\n+  --> $DIR/forbidden_slices.rs:69:5\n+   |\n+LL |     from_ptr_range(ptr..ptr.add(4))\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: allocN has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u64>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `ptr::const_ptr::<impl *const u64>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `R8`\n-  --> $DIR/forbidden_slices.rs:74:25\n+  --> $DIR/forbidden_slices.rs:73:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(1))\n    |                         ^^^^^^^^^^\n@@ -211,7 +215,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R9`\n-  --> $DIR/forbidden_slices.rs:79:34\n+  --> $DIR/forbidden_slices.rs:78:34\n    |\n LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -226,7 +230,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R10`\n-  --> $DIR/forbidden_slices.rs:80:35\n+  --> $DIR/forbidden_slices.rs:79:35\n    |\n LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "f4f9fe69516a6a258a1abb022c7c35b5b135d37a", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -27,7 +27,7 @@ LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-   = note: dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   = note: dereferencing pointer failed: allocN has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -45,7 +45,7 @@ LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) }\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -57,7 +57,7 @@ LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -68,24 +68,24 @@ LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:32:1\n    |\n LL | pub static S7: &[u16] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500ALLOC_ID+0x1\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID+0x2\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-   = note: dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   = note: dereferencing pointer failed: allocN has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n note: inside `std::slice::from_raw_parts::<'_, u64>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -129,7 +129,7 @@ LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: allocN has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -149,7 +149,7 @@ LL | pub static R4: &[u8] = unsafe {\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -161,7 +161,7 @@ LL | pub static R5: &[u8] = unsafe {\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -172,31 +172,35 @@ LL | pub static R6: &[bool] = unsafe {\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:67:1\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL | pub static R7: &[u16] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   = note: accessing memory with alignment 1, but alignment 2 is required\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500ALLOC_ID+0x1\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n+note: inside `std::slice::from_raw_parts::<'_, u16>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `from_ptr_range::<'_, u16>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `R7`\n+  --> $DIR/forbidden_slices.rs:69:5\n+   |\n+LL |     from_ptr_range(ptr..ptr.add(4))\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: allocN has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u64>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `ptr::const_ptr::<impl *const u64>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `R8`\n-  --> $DIR/forbidden_slices.rs:74:25\n+  --> $DIR/forbidden_slices.rs:73:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(1))\n    |                         ^^^^^^^^^^\n@@ -211,7 +215,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R9`\n-  --> $DIR/forbidden_slices.rs:79:34\n+  --> $DIR/forbidden_slices.rs:78:34\n    |\n LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -226,7 +230,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R10`\n-  --> $DIR/forbidden_slices.rs:80:35\n+  --> $DIR/forbidden_slices.rs:79:35\n    |\n LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "cc6100226dc1c00794ec90bbaf9524e9489f5f88", "filename": "src/test/ui/const-ptr/forbidden_slices.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -1,6 +1,6 @@\n // stderr-per-bitwidth\n-// normalize-stderr-test \"alloc[0-9]+\" -> \"ALLOC_ID\"\n-// normalize-stderr-test \"a[0-9]+\\+0x\" -> \"A_ID+0x\"\n+// normalize-stderr-test \"\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c\" -> \"\u257eALLOC_ID$2\u257c\"\n+// normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n // error-pattern: could not evaluate static initializer\n #![feature(\n     slice_from_ptr_range,\n@@ -31,7 +31,7 @@ pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) }; /\n // Reading padding is not ok\n pub static S7: &[u16] = unsafe {\n     //~^ ERROR: it is undefined behavior to use this value\n-    let ptr = (&D2 as *const Struct as *const u16).byte_add(1);\n+    let ptr = (&D2 as *const Struct as *const u16).add(1);\n \n     from_raw_parts(ptr, 4)\n };\n@@ -65,13 +65,12 @@ pub static R6: &[bool] = unsafe {\n     from_ptr_range(ptr..ptr.add(4))\n };\n pub static R7: &[u16] = unsafe {\n-    //~^ ERROR: it is undefined behavior to use this value\n     let ptr = (&D2 as *const Struct as *const u16).byte_add(1);\n-    from_ptr_range(ptr..ptr.add(4))\n+    from_ptr_range(ptr..ptr.add(4)) //~ inside `R7`\n };\n pub static R8: &[u64] = unsafe {\n     let ptr = (&D4 as *const [u32; 2] as *const u32).byte_add(1).cast::<u64>();\n-    from_ptr_range(ptr..ptr.add(1))\n+    from_ptr_range(ptr..ptr.add(1)) //~ inside `R8`\n };\n \n // This is sneaky: &D0 and &D0 point to different objects"}, {"sha": "a0a8d76d10d2d9b86e6fbd6733ddd3662f0b6026", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:13:1\n+  --> $DIR/ub-ref-ptr.rs:14:1\n    |\n LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n    | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n@@ -10,7 +10,7 @@ LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:17:1\n+  --> $DIR/ub-ref-ptr.rs:18:1\n    |\n LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n@@ -21,7 +21,7 @@ LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:21:1\n+  --> $DIR/ub-ref-ptr.rs:22:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n@@ -32,7 +32,7 @@ LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:24:1\n+  --> $DIR/ub-ref-ptr.rs:25:1\n    |\n LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n@@ -43,7 +43,7 @@ LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:31:1\n+  --> $DIR/ub-ref-ptr.rs:32:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -52,7 +52,7 @@ LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:34:39\n+  --> $DIR/ub-ref-ptr.rs:35:39\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -61,13 +61,13 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:34:38\n+  --> $DIR/ub-ref-ptr.rs:35:38\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:37:86\n+  --> $DIR/ub-ref-ptr.rs:38:86\n    |\n LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n    |                                                                                      ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -76,13 +76,13 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:37:85\n+  --> $DIR/ub-ref-ptr.rs:38:85\n    |\n LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n    |                                                                                     ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:40:1\n+  --> $DIR/ub-ref-ptr.rs:41:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n@@ -93,7 +93,7 @@ LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:43:1\n+  --> $DIR/ub-ref-ptr.rs:44:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n@@ -104,13 +104,13 @@ LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:46:41\n+  --> $DIR/ub-ref-ptr.rs:47:41\n    |\n LL | const UNINIT_PTR: *const i32 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:50:1\n+  --> $DIR/ub-ref-ptr.rs:51:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n@@ -121,13 +121,13 @@ LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:52:38\n+  --> $DIR/ub-ref-ptr.rs:53:38\n    |\n LL | const UNINIT_FN_PTR: fn() = unsafe { MaybeUninit { uninit: () }.init };\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:55:1\n+  --> $DIR/ub-ref-ptr.rs:56:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n@@ -138,7 +138,7 @@ LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:57:1\n+  --> $DIR/ub-ref-ptr.rs:58:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n@@ -148,6 +148,39 @@ LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n                \u257e\u2500alloc41\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n-error: aborting due to 14 previous errors\n+error: accessing memory with alignment 1, but alignment 4 is required\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n+note: inside `std::ptr::read::<u32>`\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::read`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+note: inside `UNALIGNED_READ`\n+  --> $DIR/ub-ref-ptr.rs:65:5\n+   |\n+LL |     ptr.read();\n+   |     ^^^^^^^^^^\n+   = note: `#[deny(invalid_alignment)]` on by default\n+\n+error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0080`.\n+Future incompatibility report: Future breakage diagnostic:\n+error: accessing memory with alignment 1, but alignment 4 is required\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n+note: inside `std::ptr::read::<u32>`\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::read`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+note: inside `UNALIGNED_READ`\n+  --> $DIR/ub-ref-ptr.rs:65:5\n+   |\n+LL |     ptr.read();\n+   |     ^^^^^^^^^^\n+   = note: `#[deny(invalid_alignment)]` on by default\n+"}, {"sha": "d53b44671e3f48eb53a2c6f1c3a085cb95b92d7b", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:13:1\n+  --> $DIR/ub-ref-ptr.rs:14:1\n    |\n LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n    | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n@@ -10,7 +10,7 @@ LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:17:1\n+  --> $DIR/ub-ref-ptr.rs:18:1\n    |\n LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n@@ -21,7 +21,7 @@ LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:21:1\n+  --> $DIR/ub-ref-ptr.rs:22:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n@@ -32,7 +32,7 @@ LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:24:1\n+  --> $DIR/ub-ref-ptr.rs:25:1\n    |\n LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n@@ -43,7 +43,7 @@ LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:31:1\n+  --> $DIR/ub-ref-ptr.rs:32:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -52,7 +52,7 @@ LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:34:39\n+  --> $DIR/ub-ref-ptr.rs:35:39\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -61,13 +61,13 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:34:38\n+  --> $DIR/ub-ref-ptr.rs:35:38\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:37:86\n+  --> $DIR/ub-ref-ptr.rs:38:86\n    |\n LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n    |                                                                                      ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -76,13 +76,13 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:37:85\n+  --> $DIR/ub-ref-ptr.rs:38:85\n    |\n LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n    |                                                                                     ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:40:1\n+  --> $DIR/ub-ref-ptr.rs:41:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n@@ -93,7 +93,7 @@ LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:43:1\n+  --> $DIR/ub-ref-ptr.rs:44:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n@@ -104,13 +104,13 @@ LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:46:41\n+  --> $DIR/ub-ref-ptr.rs:47:41\n    |\n LL | const UNINIT_PTR: *const i32 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:50:1\n+  --> $DIR/ub-ref-ptr.rs:51:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n@@ -121,13 +121,13 @@ LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:52:38\n+  --> $DIR/ub-ref-ptr.rs:53:38\n    |\n LL | const UNINIT_FN_PTR: fn() = unsafe { MaybeUninit { uninit: () }.init };\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:55:1\n+  --> $DIR/ub-ref-ptr.rs:56:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n@@ -138,7 +138,7 @@ LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:57:1\n+  --> $DIR/ub-ref-ptr.rs:58:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n@@ -148,6 +148,39 @@ LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc41\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n-error: aborting due to 14 previous errors\n+error: accessing memory with alignment 1, but alignment 4 is required\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n+note: inside `std::ptr::read::<u32>`\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::read`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+note: inside `UNALIGNED_READ`\n+  --> $DIR/ub-ref-ptr.rs:65:5\n+   |\n+LL |     ptr.read();\n+   |     ^^^^^^^^^^\n+   = note: `#[deny(invalid_alignment)]` on by default\n+\n+error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0080`.\n+Future incompatibility report: Future breakage diagnostic:\n+error: accessing memory with alignment 1, but alignment 4 is required\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n+note: inside `std::ptr::read::<u32>`\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::read`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+note: inside `UNALIGNED_READ`\n+  --> $DIR/ub-ref-ptr.rs:65:5\n+   |\n+LL |     ptr.read();\n+   |     ^^^^^^^^^^\n+   = note: `#[deny(invalid_alignment)]` on by default\n+"}, {"sha": "b0fc3c196a49fc3457915955dd277d352d6154c0", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -1,6 +1,7 @@\n // ignore-tidy-linelength\n // stderr-per-bitwidth\n #![allow(invalid_value)]\n+#![feature(const_ptr_read)]\n \n use std::mem;\n \n@@ -57,4 +58,12 @@ const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n //~^ ERROR it is undefined behavior to use this value\n \n+\n+const UNALIGNED_READ: () = unsafe {\n+    let x = &[0u8; 4];\n+    let ptr = x.as_ptr().cast::<u32>();\n+    ptr.read(); //~ inside `UNALIGNED_READ`\n+};\n+\n+\n fn main() {}"}, {"sha": "90a3dcada058d691ec0dfee66edc0e1e87ad53da", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -1,27 +1,27 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:36:1\n+  --> $DIR/ub-wide-ptr.rs:37:1\n    |\n LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500allocN\u2500\u2500\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:38:1\n+  --> $DIR/ub-wide-ptr.rs:39:1\n    |\n LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:41:1\n+  --> $DIR/ub-wide-ptr.rs:42:1\n    |\n LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -30,7 +30,7 @@ LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:44:1\n+  --> $DIR/ub-wide-ptr.rs:45:1\n    |\n LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -39,68 +39,68 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:46:1\n+  --> $DIR/ub-wide-ptr.rs:47:1\n    |\n LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:50:1\n+  --> $DIR/ub-wide-ptr.rs:51:1\n    |\n LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:53:1\n+  --> $DIR/ub-wide-ptr.rs:54:1\n    |\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:60:1\n+  --> $DIR/ub-wide-ptr.rs:61:1\n    |\n LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:67:1\n+  --> $DIR/ub-wide-ptr.rs:68:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:70:1\n+  --> $DIR/ub-wide-ptr.rs:71:1\n    |\n LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c ff ff ff 7f                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c ff ff ff 7f                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:73:1\n+  --> $DIR/ub-wide-ptr.rs:74:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -109,18 +109,18 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:76:1\n+  --> $DIR/ub-wide-ptr.rs:77:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:79:1\n+  --> $DIR/ub-wide-ptr.rs:80:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -129,165 +129,165 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:83:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:83:40\n+  --> $DIR/ub-wide-ptr.rs:84:40\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:90:1\n+  --> $DIR/ub-wide-ptr.rs:91:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257eallocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:90:42\n+  --> $DIR/ub-wide-ptr.rs:91:42\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:94:1\n+  --> $DIR/ub-wide-ptr.rs:95:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257eallocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:94:42\n+  --> $DIR/ub-wide-ptr.rs:95:42\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:102:1\n+  --> $DIR/ub-wide-ptr.rs:103:1\n    |\n LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:112:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:115:1\n+  --> $DIR/ub-wide-ptr.rs:116:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:119:1\n+  --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:122:57\n+  --> $DIR/ub-wide-ptr.rs:123:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:125:57\n+  --> $DIR/ub-wide-ptr.rs:126:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:128:56\n+  --> $DIR/ub-wide-ptr.rs:129:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:131:1\n+  --> $DIR/ub-wide-ptr.rs:132:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:136:1\n+  --> $DIR/ub-wide-ptr.rs:137:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:141:1\n+  --> $DIR/ub-wide-ptr.rs:142:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c 00 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257eALLOC_ID\u257c 00 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:143:1\n+  --> $DIR/ub-wide-ptr.rs:144:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:149:5\n+  --> $DIR/ub-wide-ptr.rs:150:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:153:5\n+  --> $DIR/ub-wide-ptr.rs:154:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable"}, {"sha": "ab25303ddc0cf611df2a306a549d4fde936f52e0", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -1,27 +1,27 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:36:1\n+  --> $DIR/ub-wide-ptr.rs:37:1\n    |\n LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:38:1\n+  --> $DIR/ub-wide-ptr.rs:39:1\n    |\n LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:41:1\n+  --> $DIR/ub-wide-ptr.rs:42:1\n    |\n LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -30,7 +30,7 @@ LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:44:1\n+  --> $DIR/ub-wide-ptr.rs:45:1\n    |\n LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -39,68 +39,68 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:46:1\n+  --> $DIR/ub-wide-ptr.rs:47:1\n    |\n LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:50:1\n+  --> $DIR/ub-wide-ptr.rs:51:1\n    |\n LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:53:1\n+  --> $DIR/ub-wide-ptr.rs:54:1\n    |\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:60:1\n+  --> $DIR/ub-wide-ptr.rs:61:1\n    |\n LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:67:1\n+  --> $DIR/ub-wide-ptr.rs:68:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:70:1\n+  --> $DIR/ub-wide-ptr.rs:71:1\n    |\n LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c ff ff ff ff ff ff ff 7f \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff 7f \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:73:1\n+  --> $DIR/ub-wide-ptr.rs:74:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -109,18 +109,18 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:76:1\n+  --> $DIR/ub-wide-ptr.rs:77:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:79:1\n+  --> $DIR/ub-wide-ptr.rs:80:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -129,165 +129,165 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:83:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:83:40\n+  --> $DIR/ub-wide-ptr.rs:84:40\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:90:1\n+  --> $DIR/ub-wide-ptr.rs:91:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:90:42\n+  --> $DIR/ub-wide-ptr.rs:91:42\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:94:1\n+  --> $DIR/ub-wide-ptr.rs:95:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:94:42\n+  --> $DIR/ub-wide-ptr.rs:95:42\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:102:1\n+  --> $DIR/ub-wide-ptr.rs:103:1\n    |\n LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:112:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:115:1\n+  --> $DIR/ub-wide-ptr.rs:116:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:119:1\n+  --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:122:57\n+  --> $DIR/ub-wide-ptr.rs:123:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:125:57\n+  --> $DIR/ub-wide-ptr.rs:126:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:128:56\n+  --> $DIR/ub-wide-ptr.rs:129:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:131:1\n+  --> $DIR/ub-wide-ptr.rs:132:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:136:1\n+  --> $DIR/ub-wide-ptr.rs:137:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:141:1\n+  --> $DIR/ub-wide-ptr.rs:142:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257eALLOC_ID\u257c 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:143:1\n+  --> $DIR/ub-wide-ptr.rs:144:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:149:5\n+  --> $DIR/ub-wide-ptr.rs:150:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:153:5\n+  --> $DIR/ub-wide-ptr.rs:154:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable"}, {"sha": "d12e5e2bed93ef20daa6f5b98b4cb27b3920146a", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -4,6 +4,7 @@\n \n use std::mem;\n \n+// normalize-stderr-test \"\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c\" -> \"\u257eALLOC_ID$2\u257c\"\n // normalize-stderr-test \"offset \\d+\" -> \"offset N\"\n // normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n // normalize-stderr-test \"size \\d+\" -> \"size N\""}, {"sha": "94d7bdc6bae9ff6222411821a5a3b912f6728fbf", "filename": "src/test/ui/consts/copy-intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fcopy-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fcopy-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcopy-intrinsic.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -17,7 +17,7 @@ const COPY_ZERO: () = unsafe {\n     // Since we are not copying anything, this should be allowed.\n     let src = ();\n     let mut dst = ();\n-    copy_nonoverlapping(&src as *const _ as *const i32, &mut dst as *mut _ as *mut i32, 0);\n+    copy_nonoverlapping(&src as *const _ as *const u8, &mut dst as *mut _ as *mut u8, 0);\n };\n \n const COPY_OOB_1: () = unsafe {"}, {"sha": "e2f8149883b1d980978e431889112462f1dd4e85", "filename": "src/test/ui/consts/extra-const-ub/detect-extra-ub.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -28,15 +28,4 @@ const UNALIGNED_PTR: () = unsafe {\n     //[with_flag]~| invalid value\n };\n \n-const UNALIGNED_READ: () = {\n-    INNER; //[with_flag]~ constant\n-    // There is an error here but its span is in the standard library so we cannot match it...\n-    // so we have this in a *nested* const, such that the *outer* const fails to use it.\n-    const INNER: () = unsafe {\n-        let x = &[0u8; 4];\n-        let ptr = x.as_ptr().cast::<u32>();\n-        ptr.read();\n-    };\n-};\n-\n fn main() {}"}, {"sha": "b2a5fd90149a3eee815afc6625507556b9a01c45", "filename": "src/test/ui/consts/extra-const-ub/detect-extra-ub.with_flag.stderr", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -28,27 +28,6 @@ error[E0080]: evaluation of constant value failed\n LL |     let _x: &u32 = transmute(&[0u8; 4]);\n    |                    ^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 4 byte alignment but found 1)\n \n-error[E0080]: evaluation of constant value failed\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-   = note: accessing memory with alignment 1, but alignment 4 is required\n-   |\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `INNER`\n-  --> $DIR/detect-extra-ub.rs:38:9\n-   |\n-LL |         ptr.read();\n-   |         ^^^^^^^^^^\n-\n-note: erroneous constant used\n-  --> $DIR/detect-extra-ub.rs:32:5\n-   |\n-LL |     INNER;\n-   |     ^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "ab629e4711b10c0e2ca8e5fec502336575f2ab9a", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4954a7ef5c5bb45f1c0d021491702ad05d470821/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=4954a7ef5c5bb45f1c0d021491702ad05d470821", "patch": "@@ -22,8 +22,9 @@ use rustc_middle::{\n };\n use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::Symbol;\n-use rustc_target::abi::Size;\n+use rustc_target::abi::{Size, Align};\n use rustc_target::spec::abi::Abi;\n+use rustc_const_eval::const_eval::CheckAlignment;\n \n use crate::{\n     concurrency::{data_race, weak_memory},\n@@ -752,15 +753,28 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     const PANIC_ON_ALLOC_FAIL: bool = false;\n \n     #[inline(always)]\n-    fn enforce_alignment(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n-        ecx.machine.check_alignment != AlignmentCheck::None\n+    fn enforce_alignment(ecx: &MiriInterpCx<'mir, 'tcx>) -> CheckAlignment {\n+        if ecx.machine.check_alignment == AlignmentCheck::None {\n+            CheckAlignment::No\n+        } else {\n+            CheckAlignment::Error\n+        }\n     }\n \n     #[inline(always)]\n     fn use_addr_for_alignment_check(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n         ecx.machine.check_alignment == AlignmentCheck::Int\n     }\n \n+    fn alignment_check_failed(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        has: Align,\n+        required: Align,\n+        _check: CheckAlignment,\n+    ) -> InterpResult<'tcx, ()> {\n+        throw_ub!(AlignmentCheckFailed { has, required })\n+    }\n+\n     #[inline(always)]\n     fn enforce_validity(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n         ecx.machine.validate"}]}