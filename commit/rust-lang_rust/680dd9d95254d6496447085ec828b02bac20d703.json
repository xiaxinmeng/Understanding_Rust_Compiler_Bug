{"sha": "680dd9d95254d6496447085ec828b02bac20d703", "node_id": "C_kwDOAAsO6NoAKDY4MGRkOWQ5NTI1NGQ2NDk2NDQ3MDg1ZWM4MjhiMDJiYWMyMGQ3MDM", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-10-14T11:23:46Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-10-14T11:23:46Z"}, "message": "Enable delegation generation for complex types", "tree": {"sha": "648798b0489f1cdc685788f0b0cb9874c5333066", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/648798b0489f1cdc685788f0b0cb9874c5333066"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/680dd9d95254d6496447085ec828b02bac20d703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/680dd9d95254d6496447085ec828b02bac20d703", "html_url": "https://github.com/rust-lang/rust/commit/680dd9d95254d6496447085ec828b02bac20d703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/680dd9d95254d6496447085ec828b02bac20d703/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9882c80020d2d93728f6b52ae58b1de5902146b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9882c80020d2d93728f6b52ae58b1de5902146b", "html_url": "https://github.com/rust-lang/rust/commit/c9882c80020d2d93728f6b52ae58b1de5902146b"}], "stats": {"total": 167, "additions": 133, "deletions": 34}, "files": [{"sha": "2716df0943a1d71f40bbe1b0e84e4e6a366b91b7", "filename": "crates/ide_assists/src/handlers/generate_delegate.rs", "status": "modified", "additions": 72, "deletions": 31, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/680dd9d95254d6496447085ec828b02bac20d703/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680dd9d95254d6496447085ec828b02bac20d703/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate.rs?ref=680dd9d95254d6496447085ec828b02bac20d703", "patch": "@@ -1,35 +1,50 @@\n use hir::{self, HasCrate, HasSource, HirDisplay};\n-use syntax::ast::{self, make, AstNode, HasName, HasVisibility};\n+use syntax::ast::{self, make, AstNode, HasGenericParams, HasName, HasVisibility};\n \n use crate::{\n     utils::{find_struct_impl, render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n };\n use syntax::ast::edit::AstNodeEdit;\n \n-// Assist: generate_setter\n+// Assist: generate_delegate\n //\n-// Generate a setter method.\n+// Generate a delegate method.\n //\n // ```\n+// struct Age(u8);\n+// impl Age {\n+//     fn age(&self) -> u8 {\n+//         self.0\n+//     }\n+// }\n+//\n // struct Person {\n-//     nam$0e: String,\n+//     ag$0e: Age,\n // }\n // ```\n // ->\n // ```\n+// struct Age(u8);\n+// impl Age {\n+//     fn age(&self) -> u8 {\n+//         self.0\n+//     }\n+// }\n+//\n // struct Person {\n-//     name: String,\n+//     age: Age,\n // }\n //\n // impl Person {\n-//     /// Set the person's name.\n-//     fn set_name(&mut self, name: String) {\n-//         self.name = name;\n+//     $0fn age(&self) -> u8 {\n+//         self.age.age()\n //     }\n // }\n // ```\n pub(crate) fn generate_delegate(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let cap = ctx.config.snippet_cap?;\n+\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n     let strukt_name = strukt.name()?;\n \n@@ -62,37 +77,39 @@ pub(crate) fn generate_delegate(acc: &mut Assists, ctx: &AssistContext) -> Optio\n             format!(\"Generate a delegate method for '{}'\", method.name(ctx.db())),\n             target,\n             |builder| {\n-                // make function\n+                // Create the function\n                 let method_source = match method.source(ctx.db()) {\n                     Some(source) => source.value,\n                     None => return,\n                 };\n                 let method_name = method.name(ctx.db());\n                 let vis = method_source.visibility();\n                 let name = make::name(&method.name(ctx.db()).to_string());\n-                let type_params = None;\n-                let self_ty = method\n-                    .self_param(ctx.db())\n-                    .map(|s| s.source(ctx.db()).map(|s| s.value))\n-                    .flatten();\n-                let params = make::param_list(self_ty, []);\n+                let params =\n+                    method_source.param_list().unwrap_or_else(|| make::param_list(None, []));\n                 let tail_expr = make::expr_method_call(\n-                    field_from_idents([\"self\", &field_name.to_string()]).unwrap(),\n+                    make::ext::field_from_idents([\"self\", &field_name.to_string()]).unwrap(), // This unwrap is ok because we have at least 1 arg in the list\n                     make::name_ref(&method_name.to_string()),\n                     make::arg_list([]),\n                 );\n+                let type_params = method_source.generic_param_list();\n                 let body = make::block_expr([], Some(tail_expr));\n-                let ret_type = &method.ret_type(ctx.db()).display(ctx.db()).to_string();\n-                let ret_type = Some(make::ret_type(make::ty(ret_type)));\n-                let is_async = false;\n+                let ret_type = method.ret_type(ctx.db());\n+                let ret_type = if ret_type.is_unknown() {\n+                    Some(make::ret_type(make::ty_placeholder()))\n+                } else {\n+                    let ret_type = &ret_type.display(ctx.db()).to_string();\n+                    Some(make::ret_type(make::ty(ret_type)))\n+                };\n+                let is_async = method_source.async_token().is_some();\n                 let f = make::fn_(vis, name, type_params, params, body, ret_type, is_async)\n                     .indent(ast::edit::IndentLevel(1))\n                     .clone_for_update();\n \n                 let cursor = Cursor::Before(f.syntax());\n-                let cap = ctx.config.snippet_cap.unwrap(); // FIXME.\n \n-                // Create or update an impl block, and attach the function to it.\n+                // Create or update an impl block, attach the function to it,\n+                // then insert into our code.\n                 match impl_def {\n                     Some(impl_def) => {\n                         // Remember where in our source our `impl` block lives.\n@@ -110,7 +127,10 @@ pub(crate) fn generate_delegate(acc: &mut Assists, ctx: &AssistContext) -> Optio\n                     None => {\n                         // Attach the function to the impl block\n                         let name = &strukt_name.to_string();\n-                        let impl_def = make::impl_(make::ext::ident_path(name)).clone_for_update();\n+                        let params = strukt.generic_param_list();\n+                        let ty_params = params.clone();\n+                        let impl_def = make::impl_(make::ext::ident_path(name), params, ty_params)\n+                            .clone_for_update();\n                         let assoc_items = impl_def.get_or_create_assoc_item_list();\n                         assoc_items.add_item(f.clone().into());\n \n@@ -127,15 +147,6 @@ pub(crate) fn generate_delegate(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     Some(())\n }\n \n-pub fn field_from_idents<'a>(\n-    parts: impl std::iter::IntoIterator<Item = &'a str>,\n-) -> Option<ast::Expr> {\n-    let mut iter = parts.into_iter();\n-    let base = make::expr_path(make::ext::ident_path(iter.next()?));\n-    let expr = iter.fold(base, |base, s| make::expr_field(base, s));\n-    Some(expr)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::check_assist;\n@@ -213,6 +224,36 @@ impl Person {\n }\"#,\n         );\n     }\n+\n+    #[test]\n+    fn test_generate_delegate_enable_all_attributes() {\n+        check_assist(\n+            generate_delegate,\n+            r#\"\n+struct Age<T>(T);\n+impl<T> Age<T> {\n+    pub(crate) async fn age<J, 'a>(&'a mut self, ty: T, arg: J) -> T {\n+        self.0\n+    }\n+}\n+\n+struct Person<T> {\n+    ag$0e: Age<T>,\n+}\"#,\n+            r#\"\n+struct Age<T>(T);\n+impl<T> Age<T> {\n+    pub(crate) async fn age<J, 'a>(&'a mut self, ty: T, arg: J) -> T {\n+        self.0\n+    }\n+}\n+\n+struct Person<T> {\n+    age: Age<T>,\n+}\n+\n+impl<T> Person<T> {\n+    $0pub(crate) async fn age<J, 'a>(&'a mut self, ty: T, arg: J) -> _ {\n         self.age.age()\n     }\n }\"#,"}, {"sha": "8729b2eb49975bbf4a16114516e224cf8265c261", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/680dd9d95254d6496447085ec828b02bac20d703/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680dd9d95254d6496447085ec828b02bac20d703/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=680dd9d95254d6496447085ec828b02bac20d703", "patch": "@@ -728,6 +728,43 @@ impl Default for Example {\n     )\n }\n \n+#[test]\n+fn doctest_generate_delegate() {\n+    check_doc_test(\n+        \"generate_delegate\",\n+        r#####\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person {\n+    ag$0e: Age,\n+}\n+\"#####,\n+        r#####\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person {\n+    age: Age,\n+}\n+\n+impl Person {\n+    $0fn age(&self) -> u8 {\n+        self.age.age()\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_generate_deref() {\n     check_doc_test("}, {"sha": "e67ac69073ea5a8dbeb5d9da4ff514f546058fb7", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/680dd9d95254d6496447085ec828b02bac20d703/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680dd9d95254d6496447085ec828b02bac20d703/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=680dd9d95254d6496447085ec828b02bac20d703", "patch": "@@ -44,6 +44,15 @@ pub mod ext {\n         Some(path)\n     }\n \n+    pub fn field_from_idents<'a>(\n+        parts: impl std::iter::IntoIterator<Item = &'a str>,\n+    ) -> Option<ast::Expr> {\n+        let mut iter = parts.into_iter();\n+        let base = expr_path(ext::ident_path(iter.next()?));\n+        let expr = iter.fold(base, |base, s| expr_field(base, s));\n+        Some(expr)\n+    }\n+\n     pub fn expr_unreachable() -> ast::Expr {\n         expr_from_text(\"unreachable!()\")\n     }\n@@ -124,8 +133,20 @@ pub fn assoc_item_list() -> ast::AssocItemList {\n     ast_from_text(\"impl C for D {}\")\n }\n \n-pub fn impl_(ty: ast::Path) -> ast::Impl {\n-    ast_from_text(&format!(\"impl {} {{}}\", ty))\n+pub fn impl_(\n+    ty: ast::Path,\n+    params: Option<ast::GenericParamList>,\n+    ty_params: Option<ast::GenericParamList>,\n+) -> ast::Impl {\n+    let params = match params {\n+        Some(params) => params.to_string(),\n+        None => String::new(),\n+    };\n+    let ty_params = match ty_params {\n+        Some(params) => params.to_string(),\n+        None => String::new(),\n+    };\n+    ast_from_text(&format!(\"impl{} {}{} {{}}\", params, ty, ty_params))\n }\n \n pub fn impl_trait(trait_: ast::Path, ty: ast::Path) -> ast::Impl {\n@@ -649,7 +670,7 @@ pub fn fn_(\n     is_async: bool,\n ) -> ast::Fn {\n     let type_params = match type_params {\n-        Some(type_params) => format!(\"<{}>\", type_params),\n+        Some(type_params) => format!(\"{}\", type_params),\n         None => \"\".into(),\n     };\n     let ret_type = match ret_type {"}]}