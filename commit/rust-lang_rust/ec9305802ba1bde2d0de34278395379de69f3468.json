{"sha": "ec9305802ba1bde2d0de34278395379de69f3468", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjOTMwNTgwMmJhMWJkZTJkMGRlMzQyNzgzOTUzNzlkZTY5ZjM0Njg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-25T22:12:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-18T02:46:42Z"}, "message": "std: Add flatpipes", "tree": {"sha": "d4869c5bb8eae9754b6429a9ff026afc59eea8dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4869c5bb8eae9754b6429a9ff026afc59eea8dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec9305802ba1bde2d0de34278395379de69f3468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec9305802ba1bde2d0de34278395379de69f3468", "html_url": "https://github.com/rust-lang/rust/commit/ec9305802ba1bde2d0de34278395379de69f3468", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec9305802ba1bde2d0de34278395379de69f3468/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f8a03cfbeb1266919d84a12b5bc417ef170e56", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f8a03cfbeb1266919d84a12b5bc417ef170e56", "html_url": "https://github.com/rust-lang/rust/commit/72f8a03cfbeb1266919d84a12b5bc417ef170e56"}], "stats": {"total": 1004, "additions": 1004, "deletions": 0}, "files": [{"sha": "5dac5eb9a8b24f4309d9093b16ce3444832c889c", "filename": "src/libstd/flatpipes.rs", "status": "added", "additions": 1003, "deletions": 0, "changes": 1003, "blob_url": "https://github.com/rust-lang/rust/blob/ec9305802ba1bde2d0de34278395379de69f3468/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9305802ba1bde2d0de34278395379de69f3468/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=ec9305802ba1bde2d0de34278395379de69f3468", "patch": "@@ -0,0 +1,1003 @@\n+/*!\n+\n+Generic communication channels for things that can be represented as,\n+or transformed to and from, byte vectors.\n+\n+The `FlatPort` and `FlatChan` types implement the generic channel and\n+port interface for arbitrary types and transport strategies. It can\n+particularly be used to send and recieve serializable types over I/O\n+streams.\n+\n+`FlatPort` and `FlatChan` implement the same comm traits as pipe-based\n+ports and channels.\n+\n+# Example\n+\n+This example sends boxed integers across tasks using serialization.\n+\n+~~~\n+let (port, chan) = serial::pipe_stream();\n+\n+do task::spawn |move chan| {\n+    for int::range(0, 10) |i| {\n+        chan.send(@i)\n+    }\n+}\n+\n+for int::range(0, 10) |i| {\n+    assert @i == port.recv()\n+}\n+~~~\n+\n+# Safety Note\n+\n+Flat pipes created from `io::Reader`s and `io::Writer`s share the same\n+blocking properties as the underlying stream. Since some implementations\n+block the scheduler thread, so will their pipes.\n+\n+*/\n+\n+// The basic send/recv interface FlatChan and PortChan will implement\n+use core::pipes::GenericChan;\n+use core::pipes::GenericPort;\n+\n+use core::sys::size_of;\n+\n+/**\n+A FlatPort, consisting of a `BytePort` that recieves byte vectors,\n+and an `Unflattener` that converts the bytes to a value.\n+\n+Create using the constructors in the `serial` and `pod` modules.\n+*/\n+pub struct FlatPort<T, U: Unflattener<T>, P: BytePort> {\n+    unflattener: U,\n+    byte_port: P\n+}\n+\n+/**\n+A FlatChan, consisting of a `Flattener` that converts values to\n+byte vectors, and a `ByteChan` that transmits the bytes.\n+\n+Create using the constructors in the `serial` and `pod` modules.\n+*/\n+pub struct FlatChan<T, F: Flattener<T>, C: ByteChan> {\n+    flattener: F,\n+    byte_chan: C\n+}\n+\n+/**\n+Constructors for flat pipes that using serialization-based flattening.\n+*/\n+pub mod serial {\n+\n+    pub use DefaultSerializer = ebml::writer::Serializer;\n+    pub use DefaultDeserializer = ebml::reader::Deserializer;\n+\n+    use core::io::{Reader, Writer};\n+    use core::pipes::{Port, Chan};\n+    use serialization::{Deserializable, Serializable};\n+    use flatpipes::flatteners::{DeserializingUnflattener,\n+                                SerializingFlattener};\n+    use flatpipes::flatteners::{deserialize_buffer, serialize_value};\n+    use flatpipes::bytepipes::{ReaderBytePort, WriterByteChan};\n+    use flatpipes::bytepipes::{PipeBytePort, PipeByteChan};\n+\n+    pub type ReaderPort<T, R> = FlatPort<\n+        T, DeserializingUnflattener<DefaultDeserializer, T>,\n+        ReaderBytePort<R>>;\n+    pub type WriterChan<T, W> = FlatChan<\n+        T, SerializingFlattener<DefaultSerializer, T>, WriterByteChan<W>>;\n+    pub type PipePort<T> = FlatPort<\n+        T, DeserializingUnflattener<DefaultDeserializer, T>, PipeBytePort>;\n+    pub type PipeChan<T> = FlatChan<\n+        T, SerializingFlattener<DefaultSerializer, T>, PipeByteChan>;\n+\n+    /// Create a `FlatPort` from a `Reader`\n+    pub fn reader_port<T: Deserializable<DefaultDeserializer>,\n+                       R: Reader>(reader: R) -> ReaderPort<T, R> {\n+        let unflat: DeserializingUnflattener<DefaultDeserializer, T> =\n+            DeserializingUnflattener::new(\n+                deserialize_buffer::<DefaultDeserializer, T>);\n+        let byte_port = ReaderBytePort::new(move reader);\n+        FlatPort::new(move unflat, move byte_port)\n+    }\n+\n+    /// Create a `FlatChan` from a `Writer`\n+    pub fn writer_chan<T: Serializable<DefaultSerializer>,\n+                       W: Writer>(writer: W) -> WriterChan<T, W> {\n+        let flat: SerializingFlattener<DefaultSerializer, T> =\n+            SerializingFlattener::new(\n+                serialize_value::<DefaultSerializer, T>);\n+        let byte_chan = WriterByteChan::new(move writer);\n+        FlatChan::new(move flat, move byte_chan)\n+    }\n+\n+    /// Create a `FlatPort` from a `Port<~[u8]>`\n+    pub fn pipe_port<T: Deserializable<DefaultDeserializer>>(\n+        port: Port<~[u8]>\n+    ) -> PipePort<T> {\n+        let unflat: DeserializingUnflattener<DefaultDeserializer, T> =\n+            DeserializingUnflattener::new(\n+                deserialize_buffer::<DefaultDeserializer, T>);\n+        let byte_port = PipeBytePort::new(move port);\n+        FlatPort::new(move unflat, move byte_port)\n+    }\n+\n+    /// Create a `FlatChan` from a `Chan<~[u8]>`\n+    pub fn pipe_chan<T: Serializable<DefaultSerializer>>(\n+        chan: Chan<~[u8]>\n+    ) -> PipeChan<T> {\n+        let flat: SerializingFlattener<DefaultSerializer, T> =\n+            SerializingFlattener::new(\n+                serialize_value::<DefaultSerializer, T>);\n+        let byte_chan = PipeByteChan::new(move chan);\n+        FlatChan::new(move flat, move byte_chan)\n+    }\n+\n+    /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n+    pub fn pipe_stream<T: Serializable<DefaultSerializer>\n+                          Deserializable<DefaultDeserializer>>(\n+                          ) -> (PipePort<T>, PipeChan<T>) {\n+        let (port, chan) = pipes::stream();\n+        return (pipe_port(move port), pipe_chan(move chan));\n+    }\n+\n+}\n+\n+// FIXME #4074 this doesn't correctly enforce POD bounds\n+/**\n+Constructors for flat pipes that send POD types using memcpy.\n+\n+# Safety Note\n+\n+This module is currently unsafe because it uses `Copy Owned` as a type\n+parameter bounds meaning POD (plain old data), but `Copy Owned` and\n+POD are not equivelant.\n+\n+*/\n+pub mod pod {\n+\n+    use core::io::{Reader, Writer};\n+    use core::pipes::{Port, Chan};\n+    use flatpipes::flatteners::{PodUnflattener, PodFlattener};\n+    use flatpipes::bytepipes::{ReaderBytePort, WriterByteChan};\n+    use flatpipes::bytepipes::{PipeBytePort, PipeByteChan};\n+\n+    pub type ReaderPort<T: Copy Owned, R> =\n+        FlatPort<T, PodUnflattener<T>, ReaderBytePort<R>>;\n+    pub type WriterChan<T: Copy Owned, W> =\n+        FlatChan<T, PodFlattener<T>, WriterByteChan<W>>;\n+    pub type PipePort<T: Copy Owned> =\n+        FlatPort<T, PodUnflattener<T>, PipeBytePort>;\n+    pub type PipeChan<T: Copy Owned> =\n+        FlatChan<T, PodFlattener<T>, PipeByteChan>;\n+\n+    /// Create a `FlatPort` from a `Reader`\n+    pub fn reader_port<T: Copy Owned, R: Reader>(\n+        reader: R\n+    ) -> ReaderPort<T, R> {\n+        let unflat: PodUnflattener<T> = PodUnflattener::new();\n+        let byte_port = ReaderBytePort::new(move reader);\n+        FlatPort::new(move unflat, move byte_port)\n+    }\n+\n+    /// Create a `FlatChan` from a `Writer`\n+    pub fn writer_chan<T: Copy Owned, W: Writer>(\n+        writer: W\n+    ) -> WriterChan<T, W> {\n+        let flat: PodFlattener<T> = PodFlattener::new();\n+        let byte_chan = WriterByteChan::new(move writer);\n+        FlatChan::new(move flat, move byte_chan)\n+    }\n+\n+    /// Create a `FlatPort` from a `Port<~[u8]>`\n+    pub fn pipe_port<T: Copy Owned>(port: Port<~[u8]>) -> PipePort<T> {\n+        let unflat: PodUnflattener<T> = PodUnflattener::new();\n+        let byte_port = PipeBytePort::new(move port);\n+        FlatPort::new(move unflat, move byte_port)\n+    }\n+\n+    /// Create a `FlatChan` from a `Chan<~[u8]>`\n+    pub fn pipe_chan<T: Copy Owned>(chan: Chan<~[u8]>) -> PipeChan<T> {\n+        let flat: PodFlattener<T> = PodFlattener::new();\n+        let byte_chan = PipeByteChan::new(move chan);\n+        FlatChan::new(move flat, move byte_chan)\n+    }\n+\n+    /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n+    pub fn pipe_stream<T: Copy Owned>() -> (PipePort<T>, PipeChan<T>) {\n+        let (port, chan) = pipes::stream();\n+        return (pipe_port(move port), pipe_chan(move chan));\n+    }\n+\n+}\n+\n+/**\n+Flatteners present a value as a byte vector\n+*/\n+pub trait Flattener<T> {\n+    fn flatten(&self, val: T) -> ~[u8];\n+}\n+\n+/**\n+Unflatteners convert a byte vector to a value\n+*/\n+pub trait Unflattener<T> {\n+    fn unflatten(&self, buf: ~[u8]) -> T;\n+}\n+\n+/**\n+BytePorts are a simple interface for receiving a specified number\n+*/\n+pub trait BytePort {\n+    fn try_recv(&self, count: uint) -> Option<~[u8]>;\n+}\n+\n+/**\n+ByteChans are a simple interface for sending bytes\n+*/\n+pub trait ByteChan {\n+    fn send(&self, val: ~[u8]);\n+}\n+\n+const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n+\n+impl<T, U: Unflattener<T>, P: BytePort> FlatPort<T, U, P>: GenericPort<T> {\n+    fn recv() -> T {\n+        match self.try_recv() {\n+            Some(move val) => move val,\n+            None => fail ~\"port is closed\"\n+        }\n+    }\n+    fn try_recv() -> Option<T> {\n+        let command = match self.byte_port.try_recv(CONTINUE.len()) {\n+            Some(move c) => move c,\n+            None => {\n+                warn!(\"flatpipe: broken pipe\");\n+                return None;\n+            }\n+        };\n+\n+        if vec::eq(command, CONTINUE) {\n+            let msg_len = match self.byte_port.try_recv(size_of::<u64>()) {\n+                Some(bytes) => {\n+                    io::u64_from_be_bytes(bytes, 0, size_of::<u64>())\n+                },\n+                None => {\n+                    warn!(\"flatpipe: broken pipe\");\n+                    return None;\n+                }\n+            };\n+\n+            let msg_len = msg_len as uint;\n+\n+            match self.byte_port.try_recv(msg_len) {\n+                Some(move bytes) => {\n+                    Some(self.unflattener.unflatten(move bytes))\n+                }\n+                None => {\n+                    warn!(\"flatpipe: broken pipe\");\n+                    return None;\n+                }\n+            }\n+        }\n+        else {\n+            fail ~\"flatpipe: unrecognized command\";\n+        }\n+    }\n+}\n+\n+impl<T, F: Flattener<T>, C: ByteChan> FlatChan<T, F, C>: GenericChan<T> {\n+    fn send(val: T) {\n+        self.byte_chan.send(CONTINUE.to_vec());\n+        let bytes = self.flattener.flatten(move val);\n+        let len = bytes.len() as u64;\n+        do io::u64_to_be_bytes(len, size_of::<u64>()) |len_bytes| {\n+            self.byte_chan.send(len_bytes.to_vec());\n+        }\n+        self.byte_chan.send(move bytes);\n+    }\n+}\n+\n+impl<T, U: Unflattener<T>, P: BytePort> FlatPort<T, U, P> {\n+    static fn new(u: U, p: P) -> FlatPort<T, U, P> {\n+        FlatPort {\n+            unflattener: move u,\n+            byte_port: move p\n+        }\n+    }\n+}\n+\n+impl<T, F: Flattener<T>, C: ByteChan> FlatChan<T, F, C> {\n+    static fn new(f: F, c: C) -> FlatChan<T, F, C> {\n+        FlatChan {\n+            flattener: move f,\n+            byte_chan: move c\n+        }\n+    }\n+}\n+\n+\n+pub mod flatteners {\n+\n+    use core::sys::size_of;\n+\n+    use serialization::{Serializer, Deserializer,\n+                        Serializable, Deserializable};\n+    use serialization::deserialize;\n+\n+    use core::io::{Writer, Reader, BytesWriter, ReaderUtil};\n+    use flatpipes::util::BufReader;\n+\n+    // XXX: Is copy/send equivalent to pod?\n+    pub struct PodUnflattener<T: Copy Owned> {\n+        bogus: ()\n+    }\n+\n+    pub struct PodFlattener<T: Copy Owned> {\n+        bogus: ()\n+    }\n+\n+    pub impl<T: Copy Owned> PodUnflattener<T>: Unflattener<T> {\n+        fn unflatten(&self, buf: ~[u8]) -> T {\n+            assert size_of::<T>() != 0;\n+            assert size_of::<T>() == buf.len();\n+            let addr_of_init: &u8 = unsafe { &*vec::raw::to_ptr(buf) };\n+            let addr_of_value: &T = unsafe { cast::transmute(addr_of_init) };\n+            copy *addr_of_value\n+        }\n+    }\n+\n+    pub impl<T: Copy Owned> PodFlattener<T>: Flattener<T> {\n+        fn flatten(&self, val: T) -> ~[u8] {\n+            assert size_of::<T>() != 0;\n+            let val: *T = ptr::to_unsafe_ptr(&val);\n+            let byte_value = val as *u8;\n+            unsafe { vec::from_buf(byte_value, size_of::<T>()) }\n+        }\n+    }\n+\n+    pub impl<T: Copy Owned> PodUnflattener<T> {\n+        static fn new() -> PodUnflattener<T> {\n+            PodUnflattener {\n+                bogus: ()\n+            }\n+        }\n+    }\n+\n+    pub impl<T: Copy Owned> PodFlattener<T> {\n+        static fn new() -> PodFlattener<T> {\n+            PodFlattener {\n+                bogus: ()\n+            }\n+        }\n+    }\n+\n+\n+    pub type DeserializeBuffer<T> = ~fn(buf: &[u8]) -> T;\n+\n+    pub struct DeserializingUnflattener<D: Deserializer,\n+                                        T: Deserializable<D>> {\n+        deserialize_buffer: DeserializeBuffer<T>\n+    }\n+\n+    pub type SerializeValue<T> = ~fn(val: &T) -> ~[u8];\n+\n+    pub struct SerializingFlattener<S: Serializer, T: Serializable<S>> {\n+        serialize_value: SerializeValue<T>\n+    }\n+\n+    pub impl<D: Deserializer, T: Deserializable<D>>\n+        DeserializingUnflattener<D, T>: Unflattener<T> {\n+        fn unflatten(&self, buf: ~[u8]) -> T {\n+            (self.deserialize_buffer)(buf)\n+        }\n+    }\n+\n+    pub impl<S: Serializer, T: Serializable<S>>\n+        SerializingFlattener<S, T>: Flattener<T> {\n+        fn flatten(&self, val: T) -> ~[u8] {\n+            (self.serialize_value)(&val)\n+        }\n+    }\n+\n+    pub impl<D: Deserializer, T: Deserializable<D>>\n+        DeserializingUnflattener<D, T> {\n+\n+        static fn new(deserialize_buffer: DeserializeBuffer<T>\n+                     ) -> DeserializingUnflattener<D, T> {\n+            DeserializingUnflattener {\n+                deserialize_buffer: move deserialize_buffer\n+            }\n+        }\n+    }\n+\n+    pub impl<S: Serializer, T: Serializable<S>>\n+        SerializingFlattener<S, T> {\n+\n+        static fn new(serialize_value: SerializeValue<T>\n+                     ) -> SerializingFlattener<S, T> {\n+            SerializingFlattener {\n+                serialize_value: move serialize_value\n+            }\n+        }\n+    }\n+\n+    /*\n+    Implementations of the serialization functions required by\n+    SerializingFlattener\n+    */\n+\n+    pub fn deserialize_buffer<D: Deserializer FromReader,\n+                          T: Deserializable<D>>(buf: &[u8]) -> T {\n+        let buf = vec::from_slice(buf);\n+        let buf_reader = @BufReader::new(move buf);\n+        let reader = buf_reader as @Reader;\n+        let deser: D = from_reader(reader);\n+        deserialize(&deser)\n+    }\n+\n+    pub fn serialize_value<D: Serializer FromWriter,\n+                       T: Serializable<D>>(val: &T) -> ~[u8] {\n+        let bytes_writer = @BytesWriter();\n+        let writer = bytes_writer as @Writer;\n+        let ser = from_writer(writer);\n+        val.serialize(&ser);\n+        let bytes = bytes_writer.bytes.check_out(|bytes| move bytes);\n+        return move bytes;\n+    }\n+\n+    pub trait FromReader {\n+        static fn from_reader(r: Reader) -> self;\n+    }\n+\n+    pub trait FromWriter {\n+        static fn from_writer(w: Writer) -> self;\n+    }\n+\n+    impl json::Deserializer: FromReader {\n+        static fn from_reader(r: Reader) -> json::Deserializer {\n+            match json::from_reader(r) {\n+                Ok(move json) => {\n+                    json::Deserializer(move json)\n+                }\n+                Err(e) => fail fmt!(\"flatpipe: can't parse json: %?\", e)\n+            }\n+        }\n+    }\n+\n+    impl json::Serializer: FromWriter {\n+        static fn from_writer(w: Writer) -> json::Serializer {\n+            json::Serializer(move w)\n+        }\n+    }\n+\n+    impl ebml::reader::Deserializer: FromReader {\n+        static fn from_reader(r: Reader) -> ebml::reader::Deserializer {\n+            let buf = @r.read_whole_stream();\n+            let doc = ebml::reader::Doc(buf);\n+            ebml::reader::Deserializer(move doc)\n+        }\n+    }\n+\n+    impl ebml::writer::Serializer: FromWriter {\n+        static fn from_writer(w: Writer) -> ebml::writer::Serializer {\n+            ebml::writer::Serializer(move w)\n+        }\n+    }\n+\n+}\n+\n+pub mod bytepipes {\n+\n+    use core::io::{Writer, Reader, ReaderUtil};\n+    use core::pipes::{Port, Chan};\n+\n+    pub struct ReaderBytePort<R: Reader> {\n+        reader: R\n+    }\n+\n+    pub struct WriterByteChan<W: Writer> {\n+        writer: W\n+    }\n+\n+    pub impl<R: Reader> ReaderBytePort<R>: BytePort {\n+        fn try_recv(&self, count: uint) -> Option<~[u8]> {\n+            let mut left = count;\n+            let mut bytes = ~[];\n+            while !self.reader.eof() && left > 0 {\n+                assert left <= count;\n+                assert left > 0;\n+                let new_bytes = self.reader.read_bytes(left);\n+                bytes.push_all(new_bytes);\n+                assert new_bytes.len() <= left;\n+                left -= new_bytes.len();\n+            }\n+\n+            if left == 0 {\n+                return Some(move bytes);\n+            } else {\n+                warn!(\"flatpipe: dropped %? broken bytes\", left);\n+                return None;\n+            }\n+        }\n+    }\n+\n+    pub impl<W: Writer> WriterByteChan<W>: ByteChan {\n+        fn send(&self, val: ~[u8]) {\n+            self.writer.write(val);\n+        }\n+    }\n+\n+    pub impl<R: Reader> ReaderBytePort<R> {\n+        static fn new(r: R) -> ReaderBytePort<R> {\n+            ReaderBytePort {\n+                reader: move r\n+            }\n+        }\n+    }\n+\n+    pub impl<W: Writer> WriterByteChan<W> {\n+        static fn new(w: W) -> WriterByteChan<W> {\n+            WriterByteChan {\n+                writer: move w\n+            }\n+        }\n+    }\n+\n+    pub struct PipeBytePort {\n+        port: pipes::Port<~[u8]>,\n+        mut buf: ~[u8]\n+    }\n+\n+    pub struct PipeByteChan {\n+        chan: pipes::Chan<~[u8]>\n+    }\n+\n+    pub impl PipeBytePort: BytePort {\n+        fn try_recv(&self, count: uint) -> Option<~[u8]> {\n+            if self.buf.len() >= count {\n+                let mut bytes = core::util::replace(&mut self.buf, ~[]);\n+                self.buf = bytes.slice(count, bytes.len());\n+                bytes.truncate(count);\n+                return Some(bytes);\n+            } else if self.buf.len() > 0 {\n+                let mut bytes = core::util::replace(&mut self.buf, ~[]);\n+                assert count > bytes.len();\n+                match self.try_recv(count - bytes.len()) {\n+                    Some(move rest) => {\n+                        bytes.push_all(rest);\n+                        return Some(move bytes);\n+                    }\n+                    None => return None\n+                }\n+            } else if self.buf.is_empty() {\n+                match self.port.try_recv() {\n+                    Some(move buf) => {\n+                        assert buf.is_not_empty();\n+                        self.buf = move buf;\n+                        return self.try_recv(count);\n+                    }\n+                    None => return None\n+                }\n+            } else {\n+                core::util::unreachable()\n+            }\n+        }\n+    }\n+\n+    pub impl PipeByteChan: ByteChan {\n+        fn send(&self, val: ~[u8]) {\n+            self.chan.send(move val)\n+        }\n+    }\n+\n+    pub impl PipeBytePort {\n+        static fn new(p: Port<~[u8]>) -> PipeBytePort {\n+            PipeBytePort {\n+                port: move p,\n+                buf: ~[]\n+            }\n+        }\n+    }\n+\n+    pub impl PipeByteChan {\n+        static fn new(c: Chan<~[u8]>) -> PipeByteChan {\n+            PipeByteChan {\n+                chan: move c\n+            }\n+        }\n+    }\n+\n+}\n+\n+// XXX: This belongs elsewhere\n+mod util {\n+\n+    use io::{Reader, BytesReader};\n+\n+    pub struct BufReader {\n+        buf: ~[u8],\n+        mut pos: uint\n+    }\n+\n+    pub impl BufReader {\n+        static pub fn new(v: ~[u8]) -> BufReader {\n+            BufReader {\n+                buf: move v,\n+                pos: 0\n+            }\n+        }\n+\n+        priv fn as_bytes_reader<A>(f: &fn(&BytesReader) -> A) -> A {\n+            // Recreating the BytesReader state every call since\n+            // I can't get the borrowing to work correctly\n+            let bytes_reader = BytesReader {\n+                bytes: core::util::id::<&[u8]>(self.buf),\n+                pos: self.pos\n+            };\n+\n+            let res = f(&bytes_reader);\n+\n+            // XXX: This isn't correct if f fails\n+            self.pos = bytes_reader.pos;\n+\n+            return move res;\n+        }\n+    }\n+\n+    impl BufReader: Reader {\n+        fn read(bytes: &[mut u8], len: uint) -> uint {\n+            self.as_bytes_reader(|r| r.read(bytes, len) )\n+        }\n+        fn read_byte() -> int {\n+            self.as_bytes_reader(|r| r.read_byte() )\n+        }\n+        fn eof() -> bool {\n+            self.as_bytes_reader(|r| r.eof() )\n+        }\n+        fn seek(offset: int, whence: io::SeekStyle) {\n+            self.as_bytes_reader(|r| r.seek(offset, whence) )\n+        }\n+        fn tell() -> uint {\n+            self.as_bytes_reader(|r| r.tell() )\n+        }\n+    }\n+\n+}\n+\n+#[cfg(test)]\n+mod test {\n+\n+    // XXX: json::Deserializer doesn't work because of problems related to\n+    // its interior pointers\n+    //use DefaultSerializer = json::Serializer;\n+    //use DefaultDeserializer = json::Deserializer;\n+    use DefaultSerializer = ebml::writer::Serializer;\n+    use DefaultDeserializer = ebml::reader::Deserializer;\n+\n+    use flatpipes::flatteners::*;\n+    use flatpipes::bytepipes::*;\n+\n+    use core::dvec::DVec;\n+    use io::BytesReader;\n+    use util::BufReader;\n+    use net::tcp::TcpSocketBuf;\n+\n+    #[test]\n+    fn test_serializing_memory_stream() {\n+        let writer = BytesWriter();\n+        let chan = serial::writer_chan(move writer);\n+\n+        chan.send(10);\n+\n+        let bytes = chan.byte_chan.writer.bytes.get();\n+\n+        let reader = BufReader::new(move bytes);\n+        let port = serial::reader_port(move reader);\n+\n+        let res: int = port.recv();\n+        assert res == 10i;\n+    }\n+\n+    #[test]\n+    fn test_serializing_pipes() {\n+        let (port, chan) = serial::pipe_stream();\n+\n+        do task::spawn |move chan| {\n+            for int::range(0, 10) |i| {\n+                chan.send(i)\n+            }\n+        }\n+\n+        for int::range(0, 10) |i| {\n+            assert i == port.recv()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_serializing_boxes() {\n+        let (port, chan) = serial::pipe_stream();\n+\n+        do task::spawn |move chan| {\n+            for int::range(0, 10) |i| {\n+                chan.send(@i)\n+            }\n+        }\n+\n+        for int::range(0, 10) |i| {\n+            assert @i == port.recv()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_pod_memory_stream() {\n+        let writer = BytesWriter();\n+        let chan = pod::writer_chan(move writer);\n+\n+        chan.send(10);\n+\n+        let bytes = chan.byte_chan.writer.bytes.get();\n+\n+        let reader = BufReader::new(move bytes);\n+        let port = pod::reader_port(move reader);\n+\n+        let res: int = port.recv();\n+        assert res == 10;\n+    }\n+\n+    #[test]\n+    fn test_pod_pipes() {\n+        let (port, chan) = pod::pipe_stream();\n+\n+        do task::spawn |move chan| {\n+            for int::range(0, 10) |i| {\n+                chan.send(i)\n+            }\n+        }\n+\n+        for int::range(0, 10) |i| {\n+            assert i == port.recv()\n+        }\n+    }\n+\n+    // XXX: Networking doesn't work on x86\n+    #[test]\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn test_pod_tcp_stream() {\n+        fn reader_port(buf: TcpSocketBuf\n+                      ) -> pod::ReaderPort<int, TcpSocketBuf> {\n+            pod::reader_port(move buf)\n+        }\n+        fn writer_chan(buf: TcpSocketBuf\n+                      ) -> pod::WriterChan<int, TcpSocketBuf> {\n+            pod::writer_chan(move buf)\n+        }\n+        test_some_tcp_stream(reader_port, writer_chan, 9666);\n+    }\n+\n+    #[test]\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn test_serializing_tcp_stream() {\n+        fn reader_port(buf: TcpSocketBuf\n+                      ) -> serial::ReaderPort<int, TcpSocketBuf> {\n+            serial::reader_port(move buf)\n+        }\n+        fn writer_chan(buf: TcpSocketBuf\n+                      ) -> serial::WriterChan<int, TcpSocketBuf> {\n+            serial::writer_chan(move buf)\n+        }\n+        test_some_tcp_stream(reader_port, writer_chan, 9667);\n+    }\n+\n+    type ReaderPortFactory<U: Unflattener<int>> =\n+        ~fn(TcpSocketBuf) -> FlatPort<int, U, ReaderBytePort<TcpSocketBuf>>;\n+    type WriterChanFactory<F: Flattener<int>> =\n+        ~fn(TcpSocketBuf) -> FlatChan<int, F, WriterByteChan<TcpSocketBuf>>;\n+\n+    fn test_some_tcp_stream<U: Unflattener<int>, F: Flattener<int>>(\n+        reader_port: ReaderPortFactory<U>,\n+        writer_chan: WriterChanFactory<F>,\n+        port: uint) {\n+\n+        use net::tcp;\n+        use net::ip;\n+        use cell::Cell;\n+        use net::tcp::TcpSocket;\n+\n+        // Indicate to the client task that the server is listening\n+        let (begin_connect_port, begin_connect_chan) = pipes::stream();\n+        // The connection is sent from the server task to the receiver task\n+        // to handle the connection\n+        let (accept_port, accept_chan) = pipes::stream();\n+        // The main task will wait until the test is over to proceed\n+        let (finish_port, finish_chan) = pipes::stream();\n+\n+        let addr = ip::v4::parse_addr(\"127.0.0.1\");\n+        let iotask = uv::global_loop::get();\n+\n+        let begin_connect_chan = Cell(move begin_connect_chan);\n+        let accept_chan = Cell(move accept_chan);\n+\n+        // The server task\n+        do task::spawn |copy addr, move begin_connect_chan,\n+                        move accept_chan| {\n+            let begin_connect_chan = begin_connect_chan.take();\n+            let accept_chan = accept_chan.take();\n+            let listen_res = do tcp::listen(\n+                copy addr, port, 128, iotask,\n+                |move begin_connect_chan, _kill_ch| {\n+                    // Tell the sender to initiate the connection\n+                    debug!(\"listening\");\n+                    begin_connect_chan.send(())\n+                }) |move accept_chan, new_conn, kill_ch| {\n+\n+                // Incoming connection. Send it to the receiver task to accept\n+                let (res_port, res_chan) = pipes::stream();\n+                accept_chan.send((move new_conn, move res_chan));\n+                // Wait until the connection is accepted\n+                res_port.recv();\n+\n+                // Stop listening\n+                kill_ch.send(None)\n+            };\n+\n+            assert listen_res.is_ok();\n+        }\n+\n+        // Client task\n+        do task::spawn |copy addr, move begin_connect_port,\n+                        move writer_chan| {\n+\n+            // Wait for the server to start listening\n+            begin_connect_port.recv();\n+\n+            debug!(\"connecting\");\n+            let connect_result = tcp::connect(copy addr, port, iotask);\n+            assert connect_result.is_ok();\n+            let sock = result::unwrap(move connect_result);\n+            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(move sock);\n+\n+            // TcpSocketBuf is a Writer!\n+            let chan = writer_chan(move socket_buf);\n+\n+            for int::range(0, 10) |i| {\n+                debug!(\"sending %?\", i);\n+                chan.send(i)\n+            }\n+        }\n+\n+        // Reciever task\n+        do task::spawn |move accept_port, move finish_chan,\n+                        move reader_port| {\n+\n+            // Wait for a connection\n+            let (conn, res_chan) = accept_port.recv();\n+\n+            debug!(\"accepting connection\");\n+            let accept_result = tcp::accept(conn);\n+            debug!(\"accepted\");\n+            assert accept_result.is_ok();\n+            let sock = result::unwrap(move accept_result);\n+            res_chan.send(());\n+\n+            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(move sock);\n+\n+            // TcpSocketBuf is a Reader!\n+            let port = reader_port(move socket_buf);\n+\n+            for int::range(0, 10) |i| {\n+                let j = port.recv();\n+                debug!(\"receieved %?\", j);\n+                assert i == j;\n+            }\n+\n+            // The test is over!\n+            finish_chan.send(());\n+        }\n+\n+        finish_port.recv();\n+    }\n+\n+    // Tests that the different backends behave the same when the\n+    // binary streaming protocol is broken\n+    mod broken_protocol {\n+        type PortLoader<P: BytePort> =\n+            ~fn(~[u8]) -> FlatPort<int, PodUnflattener<int>, P>;\n+\n+        fn reader_port_loader(bytes: ~[u8]\n+                             ) -> pod::ReaderPort<int, BufReader> {\n+            let reader = BufReader::new(move bytes);\n+            pod::reader_port(move reader)\n+        }\n+\n+        fn pipe_port_loader(bytes: ~[u8]\n+                           ) -> pod::PipePort<int> {\n+            let (port, chan) = pipes::stream();\n+            if bytes.is_not_empty() {\n+                chan.send(move bytes);\n+            }\n+            pod::pipe_port(move port)\n+        }\n+\n+        fn test_try_recv_none1<P: BytePort>(loader: PortLoader<P>) {\n+            let bytes = ~[];\n+            let port = loader(move bytes);\n+            let res: Option<int> = port.try_recv();\n+            assert res.is_none();\n+        }\n+\n+        #[test]\n+        fn test_try_recv_none1_reader() {\n+            test_try_recv_none1(reader_port_loader);\n+        }\n+        #[test]\n+        fn test_try_recv_none1_pipe() {\n+            test_try_recv_none1(pipe_port_loader);\n+        }\n+\n+        fn test_try_recv_none2<P: BytePort>(loader: PortLoader<P>) {\n+            // The control word in the protocol is interrupted\n+            let bytes = ~[0];\n+            let port = loader(move bytes);\n+            let res: Option<int> = port.try_recv();\n+            assert res.is_none();\n+        }\n+\n+        #[test]\n+        fn test_try_recv_none2_reader() {\n+            test_try_recv_none2(reader_port_loader);\n+        }\n+        #[test]\n+        fn test_try_recv_none2_pipe() {\n+            test_try_recv_none2(pipe_port_loader);\n+        }\n+\n+        fn test_try_recv_none3<P: BytePort>(loader: PortLoader<P>) {\n+            const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n+            // The control word is followed by garbage\n+            let bytes = CONTINUE.to_vec() + ~[0];\n+            let port = loader(move bytes);\n+            let res: Option<int> = port.try_recv();\n+            assert res.is_none();\n+        }\n+\n+        #[test]\n+        fn test_try_recv_none3_reader() {\n+            test_try_recv_none3(reader_port_loader);\n+        }\n+        #[test]\n+        fn test_try_recv_none3_pipe() {\n+            test_try_recv_none3(pipe_port_loader);\n+        }\n+\n+        fn test_try_recv_none4<P: BytePort>(+loader: PortLoader<P>) {\n+            assert do task::try |move loader| {\n+                const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n+                // The control word is followed by a valid length,\n+                // then undeserializable garbage\n+                let len_bytes = do io::u64_to_be_bytes(\n+                    1, sys::size_of::<u64>()) |len_bytes| {\n+                    len_bytes.to_vec()\n+                };\n+                let bytes = CONTINUE.to_vec() + len_bytes + ~[0, 0, 0, 0];\n+\n+                let port = loader(move bytes);\n+\n+                let _res: Option<int> = port.try_recv();\n+            }.is_err();\n+        }\n+\n+        #[test]\n+        #[ignore(cfg(windows))]\n+        fn test_try_recv_none4_reader() {\n+            test_try_recv_none4(reader_port_loader);\n+        }\n+        #[test]\n+        #[ignore(cfg(windows))]\n+        fn test_try_recv_none4_pipe() {\n+            test_try_recv_none4(pipe_port_loader);\n+        }\n+    }\n+\n+}"}, {"sha": "5ea90253d802975e6f53a58acfb7a74c8cb39226", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec9305802ba1bde2d0de34278395379de69f3468/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ec9305802ba1bde2d0de34278395379de69f3468/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=ec9305802ba1bde2d0de34278395379de69f3468", "patch": "@@ -65,6 +65,7 @@ pub mod arc;\n pub mod comm;\n pub mod future;\n pub mod task_pool;\n+pub mod flatpipes;\n \n // Collections\n "}]}