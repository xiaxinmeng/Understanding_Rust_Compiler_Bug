{"sha": "6b47e1ece87f8cb96709b772dbea1a2a979c1cbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNDdlMWVjZTg3ZjhjYjk2NzA5Yjc3MmRiZWExYTJhOTc5YzFjYmQ=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-17T17:31:21Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-08-28T19:45:02Z"}, "message": "Move save_in to file_format.", "tree": {"sha": "a82baf6abd1bdba516be309b68dfd06ae47433e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a82baf6abd1bdba516be309b68dfd06ae47433e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd", "html_url": "https://github.com/rust-lang/rust/commit/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4afdeaaabd021bf5ac03d74c7577747ccbb926d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4afdeaaabd021bf5ac03d74c7577747ccbb926d0", "html_url": "https://github.com/rust-lang/rust/commit/4afdeaaabd021bf5ac03d74c7577747ccbb926d0"}], "stats": {"total": 119, "additions": 61, "deletions": 58}, "files": [{"sha": "2da72bfc2927dbe22c068b0604383c45f21c6820", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=6b47e1ece87f8cb96709b772dbea1a2a979c1cbd", "patch": "@@ -12,11 +12,12 @@\n use std::env;\n use std::fs;\n use std::io::{self, Read};\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n \n use rustc_data_structures::memmap::Mmap;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encoder;\n+use rustc_session::Session;\n \n /// The first few bytes of files generated by incremental compilation.\n const FILE_MAGIC: &[u8] = b\"RSIC\";\n@@ -29,7 +30,7 @@ const HEADER_FORMAT_VERSION: u16 = 0;\n /// the Git commit hash.\n const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n \n-pub fn write_file_header(stream: &mut FileEncoder, nightly_build: bool) -> FileEncodeResult {\n+pub(crate) fn write_file_header(stream: &mut FileEncoder, nightly_build: bool) -> FileEncodeResult {\n     stream.emit_raw_bytes(FILE_MAGIC)?;\n     stream.emit_raw_bytes(&[\n         (HEADER_FORMAT_VERSION >> 0) as u8,\n@@ -42,6 +43,58 @@ pub fn write_file_header(stream: &mut FileEncoder, nightly_build: bool) -> FileE\n     stream.emit_raw_bytes(rustc_version.as_bytes())\n }\n \n+pub(crate) fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n+where\n+    F: FnOnce(&mut FileEncoder) -> FileEncodeResult,\n+{\n+    debug!(\"save: storing data in {}\", path_buf.display());\n+\n+    // Delete the old file, if any.\n+    // Note: It's important that we actually delete the old file and not just\n+    // truncate and overwrite it, since it might be a shared hard-link, the\n+    // underlying data of which we don't want to modify\n+    match fs::remove_file(&path_buf) {\n+        Ok(()) => {\n+            debug!(\"save: remove old file\");\n+        }\n+        Err(err) if err.kind() == io::ErrorKind::NotFound => (),\n+        Err(err) => {\n+            sess.err(&format!(\n+                \"unable to delete old {} at `{}`: {}\",\n+                name,\n+                path_buf.display(),\n+                err\n+            ));\n+            return;\n+        }\n+    }\n+\n+    let mut encoder = match FileEncoder::new(&path_buf) {\n+        Ok(encoder) => encoder,\n+        Err(err) => {\n+            sess.err(&format!(\"failed to create {} at `{}`: {}\", name, path_buf.display(), err));\n+            return;\n+        }\n+    };\n+\n+    if let Err(err) = write_file_header(&mut encoder, sess.is_nightly_build()) {\n+        sess.err(&format!(\"failed to write {} header to `{}`: {}\", name, path_buf.display(), err));\n+        return;\n+    }\n+\n+    if let Err(err) = encode(&mut encoder) {\n+        sess.err(&format!(\"failed to write {} to `{}`: {}\", name, path_buf.display(), err));\n+        return;\n+    }\n+\n+    if let Err(err) = encoder.flush() {\n+        sess.err(&format!(\"failed to flush {} to `{}`: {}\", name, path_buf.display(), err));\n+        return;\n+    }\n+\n+    debug!(\"save: data written to disk successfully\");\n+}\n+\n /// Reads the contents of a file with a file header as defined in this module.\n ///\n /// - Returns `Ok(Some(data, pos))` if the file existed and was generated by a"}, {"sha": "2feba71e010d38fb2b045eae28616febc3f90332", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=6b47e1ece87f8cb96709b772dbea1a2a979c1cbd", "patch": "@@ -6,8 +6,6 @@ use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_session::Session;\n use std::fs;\n-use std::io;\n-use std::path::PathBuf;\n \n use super::data::*;\n use super::dirty_clean;\n@@ -44,7 +42,9 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n         join(\n             move || {\n                 sess.time(\"incr_comp_persist_result_cache\", || {\n-                    save_in(sess, query_cache_path, \"query cache\", |e| encode_query_cache(tcx, e));\n+                    file_format::save_in(sess, query_cache_path, \"query cache\", |e| {\n+                        encode_query_cache(tcx, e)\n+                    });\n                 });\n             },\n             move || {\n@@ -86,7 +86,9 @@ pub fn save_work_product_index(\n     debug!(\"save_work_product_index()\");\n     dep_graph.assert_ignored();\n     let path = work_products_path(sess);\n-    save_in(sess, path, \"work product index\", |e| encode_work_product_index(&new_work_products, e));\n+    file_format::save_in(sess, path, \"work product index\", |e| {\n+        encode_work_product_index(&new_work_products, e)\n+    });\n \n     // We also need to clean out old work-products, as not all of them are\n     // deleted during invalidation. Some object files don't change their\n@@ -113,58 +115,6 @@ pub fn save_work_product_index(\n     });\n }\n \n-pub(crate) fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n-where\n-    F: FnOnce(&mut FileEncoder) -> FileEncodeResult,\n-{\n-    debug!(\"save: storing data in {}\", path_buf.display());\n-\n-    // Delete the old file, if any.\n-    // Note: It's important that we actually delete the old file and not just\n-    // truncate and overwrite it, since it might be a shared hard-link, the\n-    // underlying data of which we don't want to modify\n-    match fs::remove_file(&path_buf) {\n-        Ok(()) => {\n-            debug!(\"save: remove old file\");\n-        }\n-        Err(err) if err.kind() == io::ErrorKind::NotFound => (),\n-        Err(err) => {\n-            sess.err(&format!(\n-                \"unable to delete old {} at `{}`: {}\",\n-                name,\n-                path_buf.display(),\n-                err\n-            ));\n-            return;\n-        }\n-    }\n-\n-    let mut encoder = match FileEncoder::new(&path_buf) {\n-        Ok(encoder) => encoder,\n-        Err(err) => {\n-            sess.err(&format!(\"failed to create {} at `{}`: {}\", name, path_buf.display(), err));\n-            return;\n-        }\n-    };\n-\n-    if let Err(err) = file_format::write_file_header(&mut encoder, sess.is_nightly_build()) {\n-        sess.err(&format!(\"failed to write {} header to `{}`: {}\", name, path_buf.display(), err));\n-        return;\n-    }\n-\n-    if let Err(err) = encode(&mut encoder) {\n-        sess.err(&format!(\"failed to write {} to `{}`: {}\", name, path_buf.display(), err));\n-        return;\n-    }\n-\n-    if let Err(err) = encoder.flush() {\n-        sess.err(&format!(\"failed to flush {} to `{}`: {}\", name, path_buf.display(), err));\n-        return;\n-    }\n-\n-    debug!(\"save: data written to disk successfully\");\n-}\n-\n fn encode_work_product_index(\n     work_products: &FxHashMap<WorkProductId, WorkProduct>,\n     encoder: &mut FileEncoder,"}]}