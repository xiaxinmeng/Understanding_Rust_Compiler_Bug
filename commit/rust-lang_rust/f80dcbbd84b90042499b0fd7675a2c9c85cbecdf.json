{"sha": "f80dcbbd84b90042499b0fd7675a2c9c85cbecdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MGRjYmJkODRiOTAwNDI0OTliMGZkNzY3NWEyYzljODVjYmVjZGY=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-07T19:34:37Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-07T20:21:56Z"}, "message": "Split off binary search", "tree": {"sha": "4bfb3dbfc95e536eb19957840f12d51bfa8329a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bfb3dbfc95e536eb19957840f12d51bfa8329a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf", "html_url": "https://github.com/rust-lang/rust/commit/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "url": "https://api.github.com/repos/rust-lang/rust/commits/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "html_url": "https://github.com/rust-lang/rust/commit/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278"}], "stats": {"total": 155, "additions": 98, "deletions": 57}, "files": [{"sha": "e3146170f82d9a0b1d2678678feca2fdacd1bc5d", "filename": "src/expr.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=f80dcbbd84b90042499b0fd7675a2c9c85cbecdf", "patch": "@@ -14,7 +14,8 @@ use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n use StructLitStyle;\n-use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width, wrap_str};\n+use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width, wrap_str,\n+            binary_search};\n use visitor::FmtVisitor;\n use config::BlockIndentStyle;\n use comment::{FindUncommented, rewrite_comment, contains_comment};\n@@ -842,31 +843,19 @@ fn rewrite_call(context: &RewriteContext,\n                 width: usize,\n                 offset: usize)\n                 -> Option<String> {\n-    debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n+    let callback = |callee_max_width| {\n+                       rewrite_call_inner(context,\n+                                          callee,\n+                                          callee_max_width,\n+                                          args,\n+                                          span,\n+                                          width,\n+                                          offset)\n+                   };\n \n     // 2 is for parens\n-    let mut hi = try_opt!(width.checked_sub(2)) * 2;\n-    let mut lo = 0;\n-    let mut tries = 0;\n-\n-    // Binary search for the best split between callee and arguments.\n-    loop {\n-        let middle = (lo + hi) / 2;\n-\n-        match rewrite_call_inner(context, callee, middle, args, span, width, offset) {\n-            _ if tries > 10 => return None,\n-            Ok(result) => return Some(result),\n-            Err(Ordering::Less) => {\n-                lo = middle;\n-                tries += 1;\n-            }\n-            Err(Ordering::Greater) => {\n-                hi = middle;\n-                tries += 1;\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n+    let max_width = try_opt!(width.checked_sub(2));\n+    binary_search(1, max_width, callback)\n }\n \n fn rewrite_call_inner(context: &RewriteContext,\n@@ -877,7 +866,8 @@ fn rewrite_call_inner(context: &RewriteContext,\n                       width: usize,\n                       offset: usize)\n                       -> Result<String, Ordering> {\n-    // FIXME using byte lens instead of char lens (and probably all over the place too)\n+    // FIXME using byte lens instead of char lens (and probably all over the\n+    // place too)\n     let callee_str = match callee.rewrite(context, max_callee_width, offset) {\n         Some(string) => {\n             if !string.contains('\\n') && string.len() > max_callee_width {\n@@ -886,9 +876,8 @@ fn rewrite_call_inner(context: &RewriteContext,\n                 string\n             }\n         }\n-        None => return Err(Ordering::Less),\n+        None => return Err(Ordering::Greater),\n     };\n-    debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n \n     let extra_offset = extra_offset(&callee_str, offset);\n     // 2 is for parens.\n@@ -916,7 +905,7 @@ fn rewrite_call_inner(context: &RewriteContext,\n     let fmt = ListFormatting::for_fn(remaining_width, offset);\n     let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n         Some(str) => str,\n-        None => return Err(Ordering::Greater),\n+        None => return Err(Ordering::Less),\n     };\n \n     Ok(format!(\"{}({})\", callee_str, list_str))"}, {"sha": "cf68d86dd2b24ef8c420190d1edc2976eb9ec766", "filename": "src/lists.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=f80dcbbd84b90042499b0fd7675a2c9c85cbecdf", "patch": "@@ -204,8 +204,8 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n             }\n         }\n \n-        // FIXME: no magic numbers!\n-        let item_str = wrap_str(&item.item[..], 100, formatting.v_width, formatting.indent);\n+        let max_width = formatting.indent + formatting.v_width;\n+        let item_str = wrap_str(&item.item[..], max_width, formatting.v_width, formatting.indent);\n         result.push_str(&&try_opt!(item_str));\n \n         // Post-comments"}, {"sha": "dace1d84bca3b1bc7acf7ada7fa1fc7b1fdc3e4e", "filename": "src/types.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=f80dcbbd84b90042499b0fd7675a2c9c85cbecdf", "patch": "@@ -218,17 +218,22 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      \">\",\n                                      |param| param.get_span().lo,\n                                      |param| param.get_span().hi,\n-                                     // FIXME: need better params\n+                                     // FIXME(#133): write_list should call\n+                                     // rewrite itself, because it has a better\n+                                     // context.\n                                      |seg| {\n-                                         seg.rewrite(context, 1000, offset + extra_offset).unwrap()\n+                                         seg.rewrite(context,\n+                                                     context.config.max_width,\n+                                                     offset + extra_offset)\n+                                            .unwrap()\n                                      },\n                                      list_lo,\n                                      span_hi);\n \n             let fmt = ListFormatting::for_fn(list_width, offset + extra_offset);\n             let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n-            // update pos\n+            // Update position of last bracket.\n             *span_lo = next_span_lo;\n \n             format!(\"{}<{}>\", separator, list_str)\n@@ -256,9 +261,6 @@ fn rewrite_segment(segment: &ast::PathSegment,\n             let fmt = ListFormatting::for_fn(budget, offset + 1);\n             let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n-            // update pos\n-            *span_lo = data.span.hi + BytePos(1);\n-\n             format!(\"({}){}\", list_str, output)\n         }\n         _ => String::new(),"}, {"sha": "94f8fec2b0d8c543c1be0ca40c1d7fdb08cbe1a5", "filename": "src/utils.rs", "status": "modified", "additions": 71, "deletions": 21, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80dcbbd84b90042499b0fd7675a2c9c85cbecdf/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=f80dcbbd84b90042499b0fd7675a2c9c85cbecdf", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cmp::Ordering;\n+\n use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItem_};\n use syntax::codemap::{CodeMap, Span, BytePos};\n \n@@ -164,38 +166,86 @@ macro_rules! try_opt {\n     })\n }\n \n+// Wraps string-like values in an Option. Returns Some when the string adheres\n+// to the Rewrite constraints defined for the Rewrite trait and else otherwise.\n pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usize) -> Option<S> {\n-    let snippet = s.as_ref();\n-\n-    if !snippet.contains('\\n') && snippet.len() > width {\n-        return None;\n-    } else {\n-        let mut lines = snippet.lines();\n+    {\n+        let snippet = s.as_ref();\n \n-        // The caller of this function has already placed `offset`\n-        // characters on the first line.\n-        let first_line_max_len = try_opt!(max_width.checked_sub(offset));\n-        if lines.next().unwrap().len() > first_line_max_len {\n+        if !snippet.contains('\\n') && snippet.len() > width {\n             return None;\n-        }\n+        } else {\n+            let mut lines = snippet.lines();\n+\n+            // The caller of this function has already placed `offset`\n+            // characters on the first line.\n+            let first_line_max_len = try_opt!(max_width.checked_sub(offset));\n+            if lines.next().unwrap().len() > first_line_max_len {\n+                return None;\n+            }\n \n-        // The other lines must fit within the maximum width.\n-        if lines.find(|line| line.len() > max_width).is_some() {\n-            return None;\n-        }\n+            // The other lines must fit within the maximum width.\n+            if lines.find(|line| line.len() > max_width).is_some() {\n+                return None;\n+            }\n \n-        // `width` is the maximum length of the last line, excluding\n-        // indentation.\n-        // A special check for the last line, since the caller may\n-        // place trailing characters on this line.\n-        if snippet.lines().rev().next().unwrap().len() > offset + width {\n-            return None;\n+            // `width` is the maximum length of the last line, excluding\n+            // indentation.\n+            // A special check for the last line, since the caller may\n+            // place trailing characters on this line.\n+            if snippet.lines().rev().next().unwrap().len() > offset + width {\n+                return None;\n+            }\n         }\n     }\n \n     Some(s)\n }\n \n+// Binary search in integer range. Returns the first Ok value returned by the\n+// callback.\n+// The callback takes an integer and returns either an Ok, or an Err indicating\n+// whether the `guess' was too high (Ordering::Less), or too low.\n+// This function is guaranteed to try to the hi value first.\n+pub fn binary_search<C, T>(mut lo: usize, mut hi: usize, callback: C) -> Option<T>\n+    where C: Fn(usize) -> Result<T, Ordering>\n+{\n+    let mut middle = hi;\n+\n+    while lo <= hi {\n+        match callback(middle) {\n+            Ok(val) => return Some(val),\n+            Err(Ordering::Less) => {\n+                hi = middle - 1;\n+            }\n+            Err(..) => {\n+                lo = middle + 1;\n+            }\n+        }\n+        middle = (hi + lo) / 2;\n+    }\n+\n+    None\n+}\n+\n+#[test]\n+fn bin_search_test() {\n+    let closure = |i| {\n+                      match i {\n+                          4 => Ok(()),\n+                          j if j > 4 => Err(Ordering::Less),\n+                          j if j < 4 => Err(Ordering::Greater),\n+                          _ => unreachable!(),\n+                      }\n+                  };\n+\n+    assert_eq!(Some(()), binary_search(1, 10, &closure));\n+    assert_eq!(None, binary_search(1, 3, &closure));\n+    assert_eq!(Some(()), binary_search(0, 44, &closure));\n+    assert_eq!(Some(()), binary_search(4, 125, &closure));\n+    assert_eq!(None, binary_search(6, 100, &closure));\n+}\n+\n #[test]\n fn power_rounding() {\n     assert_eq!(0, round_up_to_power_of_two(0));"}]}