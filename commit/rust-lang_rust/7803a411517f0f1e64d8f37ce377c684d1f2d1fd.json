{"sha": "7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "node_id": "C_kwDOAAsO6NoAKDc4MDNhNDExNTE3ZjBmMWU2NGQ4ZjM3Y2UzNzdjNjg0ZDFmMmQxZmQ", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-21T12:01:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-21T13:13:02Z"}, "message": "rustdoc: Unindent doc fragments on `Attributes` construction", "tree": {"sha": "d90e88cd5adf93d13bd937f80d043cf0a980ca7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d90e88cd5adf93d13bd937f80d043cf0a980ca7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "html_url": "https://github.com/rust-lang/rust/commit/7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "html_url": "https://github.com/rust-lang/rust/commit/3d3dafb771fb714baeb36793f2d4cd333a8e9c34"}], "stats": {"total": 222, "additions": 89, "deletions": 133}, "files": [{"sha": "2b65b8f910c7069b74c23d24c4847a5240898dc8", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 86, "deletions": 3, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "patch": "@@ -1,13 +1,11 @@\n use std::cell::RefCell;\n use std::default::Default;\n-use std::fmt;\n use std::hash::Hash;\n-use std::iter;\n use std::lazy::SyncOnceCell as OnceCell;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::Arc;\n-use std::vec;\n+use std::{cmp, fmt, iter};\n \n use arrayvec::ArrayVec;\n \n@@ -55,6 +53,9 @@ crate use self::Type::{\n };\n crate use self::Visibility::{Inherited, Public};\n \n+#[cfg(test)]\n+mod tests;\n+\n crate type ItemIdSet = FxHashSet<ItemId>;\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]\n@@ -1028,6 +1029,86 @@ crate fn collapse_doc_fragments(doc_strings: &[DocFragment]) -> String {\n     acc\n }\n \n+/// Removes excess indentation on comments in order for the Markdown\n+/// to be parsed correctly. This is necessary because the convention for\n+/// writing documentation is to provide a space between the /// or //! marker\n+/// and the doc text, but Markdown is whitespace-sensitive. For example,\n+/// a block of text with four-space indentation is parsed as a code block,\n+/// so if we didn't unindent comments, these list items\n+///\n+/// /// A list:\n+/// ///\n+/// ///    - Foo\n+/// ///    - Bar\n+///\n+/// would be parsed as if they were in a code block, which is likely not what the user intended.\n+fn unindent_doc_fragments(docs: &mut Vec<DocFragment>) {\n+    // `add` is used in case the most common sugared doc syntax is used (\"/// \"). The other\n+    // fragments kind's lines are never starting with a whitespace unless they are using some\n+    // markdown formatting requiring it. Therefore, if the doc block have a mix between the two,\n+    // we need to take into account the fact that the minimum indent minus one (to take this\n+    // whitespace into account).\n+    //\n+    // For example:\n+    //\n+    // /// hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In this case, you want \"hello! another\" and not \"hello!  another\".\n+    let add = if docs.windows(2).any(|arr| arr[0].kind != arr[1].kind)\n+        && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n+    {\n+        // In case we have a mix of sugared doc comments and \"raw\" ones, we want the sugared one to\n+        // \"decide\" how much the minimum indent will be.\n+        1\n+    } else {\n+        0\n+    };\n+\n+    // `min_indent` is used to know how much whitespaces from the start of each lines must be\n+    // removed. Example:\n+    //\n+    // ///     hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In here, the `min_indent` is 1 (because non-sugared fragment are always counted with minimum\n+    // 1 whitespace), meaning that \"hello!\" will be considered a codeblock because it starts with 4\n+    // (5 - 1) whitespaces.\n+    let Some(min_indent) = docs\n+        .iter()\n+        .map(|fragment| {\n+            fragment.doc.as_str().lines().fold(usize::MAX, |min_indent, line| {\n+                if line.chars().all(|c| c.is_whitespace()) {\n+                    min_indent\n+                } else {\n+                    // Compare against either space or tab, ignoring whether they are\n+                    // mixed or not.\n+                    let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n+                    cmp::min(min_indent, whitespace)\n+                        + if fragment.kind == DocFragmentKind::SugaredDoc { 0 } else { add }\n+                }\n+            })\n+        })\n+        .min()\n+    else {\n+        return;\n+    };\n+\n+    for fragment in docs {\n+        if fragment.doc == kw::Empty {\n+            continue;\n+        }\n+\n+        let min_indent = if fragment.kind != DocFragmentKind::SugaredDoc && min_indent > 0 {\n+            min_indent - add\n+        } else {\n+            min_indent\n+        };\n+\n+        fragment.indent = min_indent;\n+    }\n+}\n+\n /// A link that has not yet been rendered.\n ///\n /// This link will be turned into a rendered link by [`Item::links`].\n@@ -1119,6 +1200,8 @@ impl Attributes {\n             }\n         }\n \n+        unindent_doc_fragments(&mut doc_strings);\n+\n         Attributes { doc_strings, other_attrs }\n     }\n "}, {"sha": "71eddf4348f1e7dadfc52fbf4c9a5de7c05517ee", "filename": "src/librustdoc/clean/types/tests.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs?ref=7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "patch": "@@ -20,7 +20,7 @@ fn create_doc_fragment(s: &str) -> Vec<DocFragment> {\n fn run_test(input: &str, expected: &str) {\n     create_default_session_globals_then(|| {\n         let mut s = create_doc_fragment(input);\n-        unindent_fragments(&mut s);\n+        unindent_doc_fragments(&mut s);\n         assert_eq!(collapse_doc_fragments(&s), expected);\n     });\n }", "previous_filename": "src/librustdoc/passes/unindent_comments/tests.rs"}, {"sha": "45ac16e75aa37474e81be14ddbaf9068d06375cf", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "patch": "@@ -1174,8 +1174,6 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         nested: F,\n     ) {\n         let ast_attrs = self.tcx.hir().attrs(hir_id);\n-        let mut attrs = Attributes::from_ast(ast_attrs, None);\n-\n         if let Some(ref cfg) = ast_attrs.cfg(self.tcx, &FxHashSet::default()) {\n             if !cfg.matches(&self.sess.parse_sess, Some(self.sess.features_untracked())) {\n                 return;\n@@ -1187,9 +1185,9 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n             self.collector.names.push(name);\n         }\n \n-        attrs.unindent_doc_comments();\n         // The collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n         // anything else, this will combine them for us.\n+        let attrs = Attributes::from_ast(ast_attrs, None);\n         if let Some(doc) = attrs.collapsed_doc_value() {\n             // Use the outermost invocation, so that doctest names come from where the docs were written.\n             let span = ast_attrs"}, {"sha": "429a4e1a9a0a62ba6117138eec5d9e5c1ad0d0df", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "patch": "@@ -63,9 +63,7 @@ crate fn early_resolve_intra_doc_links(\n }\n \n fn doc_attrs<'a>(attrs: impl Iterator<Item = &'a ast::Attribute>) -> Attributes {\n-    let mut attrs = Attributes::from_ast_iter(attrs.map(|attr| (attr, None)), true);\n-    attrs.unindent_doc_comments();\n-    attrs\n+    Attributes::from_ast_iter(attrs.map(|attr| (attr, None)), true)\n }\n \n struct EarlyDocLinkResolver<'r, 'ra> {"}, {"sha": "97a436c7500701f626c4136227d91759ddaffea2", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "patch": "@@ -24,9 +24,6 @@ crate use self::strip_private::STRIP_PRIVATE;\n mod strip_priv_imports;\n crate use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n \n-mod unindent_comments;\n-crate use self::unindent_comments::UNINDENT_COMMENTS;\n-\n mod propagate_doc_cfg;\n crate use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n \n@@ -81,7 +78,6 @@ crate enum Condition {\n crate const PASSES: &[Pass] = &[\n     CHECK_DOC_TEST_VISIBILITY,\n     STRIP_HIDDEN,\n-    UNINDENT_COMMENTS,\n     STRIP_PRIVATE,\n     STRIP_PRIV_IMPORTS,\n     PROPAGATE_DOC_CFG,\n@@ -96,7 +92,6 @@ crate const PASSES: &[Pass] = &[\n /// The list of passes run by default.\n crate const DEFAULT_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n-    ConditionalPass::always(UNINDENT_COMMENTS),\n     ConditionalPass::always(CHECK_DOC_TEST_VISIBILITY),\n     ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n     ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),"}, {"sha": "0f604157291bdcf6ab600c187c8d7459c4e0780f", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/3d3dafb771fb714baeb36793f2d4cd333a8e9c34/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3dafb771fb714baeb36793f2d4cd333a8e9c34/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "patch": "@@ -1,116 +0,0 @@\n-//! Removes excess indentation on comments in order for the Markdown\n-//! to be parsed correctly. This is necessary because the convention for\n-//! writing documentation is to provide a space between the /// or //! marker\n-//! and the doc text, but Markdown is whitespace-sensitive. For example,\n-//! a block of text with four-space indentation is parsed as a code block,\n-//! so if we didn't unindent comments, these list items\n-//!\n-//! /// A list:\n-//! ///\n-//! ///    - Foo\n-//! ///    - Bar\n-//!\n-//! would be parsed as if they were in a code block, which is likely not what the user intended.\n-use std::cmp;\n-\n-use rustc_span::symbol::kw;\n-\n-use crate::clean::{self, DocFragment, DocFragmentKind, Item};\n-use crate::core::DocContext;\n-use crate::fold::{self, DocFolder};\n-use crate::passes::Pass;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-crate const UNINDENT_COMMENTS: Pass = Pass {\n-    name: \"unindent-comments\",\n-    run: unindent_comments,\n-    description: \"removes excess indentation on comments in order for markdown to like it\",\n-};\n-\n-crate fn unindent_comments(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n-    CommentCleaner.fold_crate(krate)\n-}\n-\n-struct CommentCleaner;\n-\n-impl fold::DocFolder for CommentCleaner {\n-    fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-        i.attrs.unindent_doc_comments();\n-        Some(self.fold_item_recur(i))\n-    }\n-}\n-\n-impl clean::Attributes {\n-    crate fn unindent_doc_comments(&mut self) {\n-        unindent_fragments(&mut self.doc_strings);\n-    }\n-}\n-\n-fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n-    // `add` is used in case the most common sugared doc syntax is used (\"/// \"). The other\n-    // fragments kind's lines are never starting with a whitespace unless they are using some\n-    // markdown formatting requiring it. Therefore, if the doc block have a mix between the two,\n-    // we need to take into account the fact that the minimum indent minus one (to take this\n-    // whitespace into account).\n-    //\n-    // For example:\n-    //\n-    // /// hello!\n-    // #[doc = \"another\"]\n-    //\n-    // In this case, you want \"hello! another\" and not \"hello!  another\".\n-    let add = if docs.windows(2).any(|arr| arr[0].kind != arr[1].kind)\n-        && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n-    {\n-        // In case we have a mix of sugared doc comments and \"raw\" ones, we want the sugared one to\n-        // \"decide\" how much the minimum indent will be.\n-        1\n-    } else {\n-        0\n-    };\n-\n-    // `min_indent` is used to know how much whitespaces from the start of each lines must be\n-    // removed. Example:\n-    //\n-    // ///     hello!\n-    // #[doc = \"another\"]\n-    //\n-    // In here, the `min_indent` is 1 (because non-sugared fragment are always counted with minimum\n-    // 1 whitespace), meaning that \"hello!\" will be considered a codeblock because it starts with 4\n-    // (5 - 1) whitespaces.\n-    let Some(min_indent) = docs\n-        .iter()\n-        .map(|fragment| {\n-            fragment.doc.as_str().lines().fold(usize::MAX, |min_indent, line| {\n-                if line.chars().all(|c| c.is_whitespace()) {\n-                    min_indent\n-                } else {\n-                    // Compare against either space or tab, ignoring whether they are\n-                    // mixed or not.\n-                    let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n-                    cmp::min(min_indent, whitespace)\n-                        + if fragment.kind == DocFragmentKind::SugaredDoc { 0 } else { add }\n-                }\n-            })\n-        })\n-        .min()\n-    else {\n-        return;\n-    };\n-\n-    for fragment in docs {\n-        if fragment.doc == kw::Empty {\n-            continue;\n-        }\n-\n-        let min_indent = if fragment.kind != DocFragmentKind::SugaredDoc && min_indent > 0 {\n-            min_indent - add\n-        } else {\n-            min_indent\n-        };\n-\n-        fragment.indent = min_indent;\n-    }\n-}"}, {"sha": "a19e452b459e19c85d84fb048b34a3b03cac84fc", "filename": "src/test/rustdoc-ui/issue-91713.stdout", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/7803a411517f0f1e64d8f37ce377c684d1f2d1fd/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout?ref=7803a411517f0f1e64d8f37ce377c684d1f2d1fd", "patch": "@@ -1,7 +1,6 @@\n Available passes for running rustdoc:\n check_doc_test_visibility - run various visibility-related lints on doctests\n         strip-hidden - strips all `#[doc(hidden)]` items from the output\n-   unindent-comments - removes excess indentation on comments in order for markdown to like it\n        strip-private - strips all private items from a crate which cannot be seen externally, implies strip-priv-imports\n   strip-priv-imports - strips all private import statements (`use`, `extern crate`) from a crate\n    propagate-doc-cfg - propagates `#[doc(cfg(...))]` to child items\n@@ -14,7 +13,6 @@ check-invalid-html-tags - detects invalid HTML tags in doc comments\n \n Default passes for rustdoc:\n  collect-trait-impls\n-   unindent-comments\n check_doc_test_visibility\n         strip-hidden  (when not --document-hidden-items)\n        strip-private  (when not --document-private-items)"}]}