{"sha": "d72f58009f1b07175b6459ab3f538459cad8fd51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MmY1ODAwOWYxYjA3MTc1YjY0NTlhYjNmNTM4NDU5Y2FkOGZkNTE=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-01-08T01:41:34Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-01-08T01:42:51Z"}, "message": "Remove useless `fill_in` function\n\nIt was only used once, in a function that was otherwise trivial.", "tree": {"sha": "9477c8413b2695c9c68c9ab9a9e8aa9467abe860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9477c8413b2695c9c68c9ab9a9e8aa9467abe860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d72f58009f1b07175b6459ab3f538459cad8fd51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d72f58009f1b07175b6459ab3f538459cad8fd51", "html_url": "https://github.com/rust-lang/rust/commit/d72f58009f1b07175b6459ab3f538459cad8fd51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d72f58009f1b07175b6459ab3f538459cad8fd51/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8915eebeaaef9f7cc1cff6ffd97f578b03c2ac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8915eebeaaef9f7cc1cff6ffd97f578b03c2ac9", "html_url": "https://github.com/rust-lang/rust/commit/c8915eebeaaef9f7cc1cff6ffd97f578b03c2ac9"}], "stats": {"total": 89, "additions": 40, "deletions": 49}, "files": [{"sha": "f0678b1904e5084186d43b7e642d3aa7895343b0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 40, "deletions": 49, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d72f58009f1b07175b6459ab3f538459cad8fd51/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72f58009f1b07175b6459ab3f538459cad8fd51/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d72f58009f1b07175b6459ab3f538459cad8fd51", "patch": "@@ -441,60 +441,51 @@ crate fn build_impl(\n \n fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>) -> clean::Module {\n     let mut items = Vec::new();\n-    fill_in(cx, did, &mut items, visited);\n-    return clean::Module { items, is_crate: false };\n-\n-    fn fill_in(\n-        cx: &DocContext<'_>,\n-        did: DefId,\n-        items: &mut Vec<clean::Item>,\n-        visited: &mut FxHashSet<DefId>,\n-    ) {\n-        // If we're re-exporting a re-export it may actually re-export something in\n-        // two namespaces, so the target may be listed twice. Make sure we only\n-        // visit each node at most once.\n-        for &item in cx.tcx.item_children(did).iter() {\n-            if item.vis == ty::Visibility::Public {\n-                if let Some(def_id) = item.res.mod_def_id() {\n-                    if did == def_id || !visited.insert(def_id) {\n-                        continue;\n-                    }\n+\n+    // If we're re-exporting a re-export it may actually re-export something in\n+    // two namespaces, so the target may be listed twice. Make sure we only\n+    // visit each node at most once.\n+    for &item in cx.tcx.item_children(did).iter() {\n+        if item.vis == ty::Visibility::Public {\n+            if let Some(def_id) = item.res.mod_def_id() {\n+                if did == def_id || !visited.insert(def_id) {\n+                    continue;\n                 }\n-                if let Res::PrimTy(p) = item.res {\n-                    // Primitive types can't be inlined so generate an import instead.\n-                    items.push(clean::Item {\n-                        name: None,\n-                        attrs: clean::Attributes::default(),\n-                        source: clean::Span::dummy(),\n-                        def_id: DefId::local(CRATE_DEF_INDEX),\n-                        visibility: clean::Public,\n-                        kind: box clean::ImportItem(clean::Import::new_simple(\n-                            item.ident.name,\n-                            clean::ImportSource {\n-                                path: clean::Path {\n-                                    global: false,\n-                                    res: item.res,\n-                                    segments: vec![clean::PathSegment {\n-                                        name: clean::PrimitiveType::from(p).as_sym(),\n-                                        args: clean::GenericArgs::AngleBracketed {\n-                                            args: Vec::new(),\n-                                            bindings: Vec::new(),\n-                                        },\n-                                    }],\n-                                },\n-                                did: None,\n+            }\n+            if let Res::PrimTy(p) = item.res {\n+                // Primitive types can't be inlined so generate an import instead.\n+                items.push(clean::Item {\n+                    name: None,\n+                    attrs: clean::Attributes::default(),\n+                    source: clean::Span::dummy(),\n+                    def_id: DefId::local(CRATE_DEF_INDEX),\n+                    visibility: clean::Public,\n+                    kind: box clean::ImportItem(clean::Import::new_simple(\n+                        item.ident.name,\n+                        clean::ImportSource {\n+                            path: clean::Path {\n+                                global: false,\n+                                res: item.res,\n+                                segments: vec![clean::PathSegment {\n+                                    name: clean::PrimitiveType::from(p).as_sym(),\n+                                    args: clean::GenericArgs::AngleBracketed {\n+                                        args: Vec::new(),\n+                                        bindings: Vec::new(),\n+                                    },\n+                                }],\n                             },\n-                            true,\n-                        )),\n-                    });\n-                } else if let Some(i) =\n-                    try_inline(cx, did, item.res, item.ident.name, None, visited)\n-                {\n-                    items.extend(i)\n-                }\n+                            did: None,\n+                        },\n+                        true,\n+                    )),\n+                });\n+            } else if let Some(i) = try_inline(cx, did, item.res, item.ident.name, None, visited) {\n+                items.extend(i)\n             }\n         }\n     }\n+\n+    clean::Module { items, is_crate: false }\n }\n \n crate fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {"}]}