{"sha": "de84ad95b4b097e504171c7c606bf3715803c13b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlODRhZDk1YjRiMDk3ZTUwNDE3MWM3YzYwNmJmMzcxNTgwM2MxM2I=", "commit": {"author": {"name": "Fabian Zaiser", "email": "fabian.zaiser@gmail.com", "date": "2020-11-07T14:28:55Z"}, "committer": {"name": "Fabian Zaiser", "email": "fabian.zaiser@gmail.com", "date": "2020-11-11T12:10:52Z"}, "message": "Implement destructuring assignment for structs and slices\n\nCo-authored-by: varkor <github@varkor.com>", "tree": {"sha": "79e31aeb6e1fa6c147157399446837511900dcfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79e31aeb6e1fa6c147157399446837511900dcfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de84ad95b4b097e504171c7c606bf3715803c13b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de84ad95b4b097e504171c7c606bf3715803c13b", "html_url": "https://github.com/rust-lang/rust/commit/de84ad95b4b097e504171c7c606bf3715803c13b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de84ad95b4b097e504171c7c606bf3715803c13b/comments", "author": {"login": "fanzier", "id": 5846332, "node_id": "MDQ6VXNlcjU4NDYzMzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5846332?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fanzier", "html_url": "https://github.com/fanzier", "followers_url": "https://api.github.com/users/fanzier/followers", "following_url": "https://api.github.com/users/fanzier/following{/other_user}", "gists_url": "https://api.github.com/users/fanzier/gists{/gist_id}", "starred_url": "https://api.github.com/users/fanzier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fanzier/subscriptions", "organizations_url": "https://api.github.com/users/fanzier/orgs", "repos_url": "https://api.github.com/users/fanzier/repos", "events_url": "https://api.github.com/users/fanzier/events{/privacy}", "received_events_url": "https://api.github.com/users/fanzier/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fanzier", "id": 5846332, "node_id": "MDQ6VXNlcjU4NDYzMzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5846332?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fanzier", "html_url": "https://github.com/fanzier", "followers_url": "https://api.github.com/users/fanzier/followers", "following_url": "https://api.github.com/users/fanzier/following{/other_user}", "gists_url": "https://api.github.com/users/fanzier/gists{/gist_id}", "starred_url": "https://api.github.com/users/fanzier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fanzier/subscriptions", "organizations_url": "https://api.github.com/users/fanzier/orgs", "repos_url": "https://api.github.com/users/fanzier/repos", "events_url": "https://api.github.com/users/fanzier/events{/privacy}", "received_events_url": "https://api.github.com/users/fanzier/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf9cf7c923eb01146971429044f216a3ca905e06", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9cf7c923eb01146971429044f216a3ca905e06", "html_url": "https://github.com/rust-lang/rust/commit/cf9cf7c923eb01146971429044f216a3ca905e06"}], "stats": {"total": 725, "additions": 618, "deletions": 107}, "files": [{"sha": "1886581df9a94ec45bb22ec25411145ea9ea3c0a", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -1061,7 +1061,7 @@ pub struct Expr {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Expr, 112);\n+rustc_data_structures::static_assert_size!(Expr, 120);\n \n impl Expr {\n     /// Returns `true` if this expression would be valid somewhere that expects a value;\n@@ -1218,6 +1218,16 @@ pub enum RangeLimits {\n     Closed,\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub enum StructRest {\n+    /// `..x`.\n+    Base(P<Expr>),\n+    /// `..`.\n+    Rest(Span),\n+    /// No trailing `..` or expression.\n+    None,\n+}\n+\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ExprKind {\n     /// A `box x` expression.\n@@ -1312,7 +1322,7 @@ pub enum ExprKind {\n     Field(P<Expr>, Ident),\n     /// An indexing operation (e.g., `foo[2]`).\n     Index(P<Expr>, P<Expr>),\n-    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`).\n+    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assingment).\n     Range(Option<P<Expr>>, Option<P<Expr>>, RangeLimits),\n \n     /// Variable reference, possibly containing `::` and/or type\n@@ -1340,9 +1350,8 @@ pub enum ExprKind {\n \n     /// A struct literal expression.\n     ///\n-    /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. base}`,\n-    /// where `base` is the `Option<Expr>`.\n-    Struct(Path, Vec<Field>, Option<P<Expr>>),\n+    /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. rest}`.\n+    Struct(Path, Vec<Field>, StructRest),\n \n     /// An array literal constructed from one repeated element.\n     ///"}, {"sha": "a80a6adb4fae8956395741fc7d7d64e3ef52d5a0", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -1288,7 +1288,11 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         ExprKind::Struct(path, fields, expr) => {\n             vis.visit_path(path);\n             fields.flat_map_in_place(|field| vis.flat_map_field(field));\n-            visit_opt(expr, |expr| vis.visit_expr(expr));\n+            match expr {\n+                StructRest::Base(expr) => vis.visit_expr(expr),\n+                StructRest::Rest(_span) => {}\n+                StructRest::None => {}\n+            }\n         }\n         ExprKind::Paren(expr) => {\n             vis.visit_expr(expr);"}, {"sha": "0666eb199e67328ba932b8faa46b082a52a3c79b", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -719,7 +719,11 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::Struct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);\n             walk_list!(visitor, visit_field, fields);\n-            walk_list!(visitor, visit_expr, optional_base);\n+            match optional_base {\n+                StructRest::Base(expr) => visitor.visit_expr(expr),\n+                StructRest::Rest(_span) => {}\n+                StructRest::None => {}\n+            }\n         }\n         ExprKind::Tup(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);"}, {"sha": "330776fc8c5980f8fdaee02cac5cfdb3a4c365e7", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 119, "deletions": 7, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -187,8 +187,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(e.span, asm),\n                 ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_llvm_asm(asm),\n-                ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                    let maybe_expr = maybe_expr.as_ref().map(|x| self.lower_expr(x));\n+                ExprKind::Struct(ref path, ref fields, ref rest) => {\n+                    let rest = match rest {\n+                        StructRest::Base(e) => Some(self.lower_expr(e)),\n+                        StructRest::Rest(sp) => {\n+                            self.sess\n+                                .struct_span_err(*sp, \"base expression required after `..`\")\n+                                .span_label(*sp, \"add a base expression here\")\n+                                .emit();\n+                            Some(&*self.arena.alloc(self.expr_err(*sp)))\n+                        }\n+                        StructRest::None => None,\n+                    };\n                     hir::ExprKind::Struct(\n                         self.arena.alloc(self.lower_qpath(\n                             e.id,\n@@ -198,7 +208,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             ImplTraitContext::disallowed(),\n                         )),\n                         self.arena.alloc_from_iter(fields.iter().map(|x| self.lower_field(x))),\n-                        maybe_expr,\n+                        rest,\n                     )\n                 }\n                 ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n@@ -851,20 +861,22 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         whole_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         // Return early in case of an ordinary assignment.\n-        fn is_ordinary(lhs: &Expr) -> bool {\n+        fn is_ordinary(lower_ctx: &mut LoweringContext<'_, '_>, lhs: &Expr) -> bool {\n             match &lhs.kind {\n-                ExprKind::Tup(..) => false,\n+                ExprKind::Array(..) | ExprKind::Struct(..) | ExprKind::Tup(..) => false,\n+                // Check for tuple struct constructor.\n+                ExprKind::Call(callee, ..) => lower_ctx.extract_tuple_struct_path(callee).is_none(),\n                 ExprKind::Paren(e) => {\n                     match e.kind {\n                         // We special-case `(..)` for consistency with patterns.\n                         ExprKind::Range(None, None, RangeLimits::HalfOpen) => false,\n-                        _ => is_ordinary(e),\n+                        _ => is_ordinary(lower_ctx, e),\n                     }\n                 }\n                 _ => true,\n             }\n         }\n-        if is_ordinary(lhs) {\n+        if is_ordinary(self, lhs) {\n             return hir::ExprKind::Assign(self.lower_expr(lhs), self.lower_expr(rhs), eq_sign_span);\n         }\n         if !self.sess.features_untracked().destructuring_assignment {\n@@ -902,6 +914,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::ExprKind::Block(&self.block_all(whole_span, stmts, None), None)\n     }\n \n+    /// If the given expression is a path to a tuple struct, returns that path.\n+    /// It is not a complete check, but just tries to reject most paths early\n+    /// if they are not tuple structs.\n+    /// Type checking will take care of the full validation later.\n+    fn extract_tuple_struct_path<'a>(&mut self, expr: &'a Expr) -> Option<&'a Path> {\n+        // For tuple struct destructuring, it must be a non-qualified path (like in patterns).\n+        if let ExprKind::Path(None, path) = &expr.kind {\n+            // Does the path resolves to something disallowed in a tuple struct/variant pattern?\n+            if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n+                if partial_res.unresolved_segments() == 0\n+                    && !partial_res.base_res().expected_in_tuple_struct_pat()\n+                {\n+                    return None;\n+                }\n+            }\n+            return Some(path);\n+        }\n+        None\n+    }\n+\n     /// Convert the LHS of a destructuring assignment to a pattern.\n     /// Each sub-assignment is recorded in `assignments`.\n     fn destructure_assign(\n@@ -911,6 +943,86 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         assignments: &mut Vec<hir::Stmt<'hir>>,\n     ) -> &'hir hir::Pat<'hir> {\n         match &lhs.kind {\n+            // Slice patterns.\n+            ExprKind::Array(elements) => {\n+                let (pats, rest) =\n+                    self.destructure_sequence(elements, \"slice\", eq_sign_span, assignments);\n+                let slice_pat = if let Some((i, span)) = rest {\n+                    let (before, after) = pats.split_at(i);\n+                    hir::PatKind::Slice(\n+                        before,\n+                        Some(self.pat_without_dbm(span, hir::PatKind::Wild)),\n+                        after,\n+                    )\n+                } else {\n+                    hir::PatKind::Slice(pats, None, &[])\n+                };\n+                return self.pat_without_dbm(lhs.span, slice_pat);\n+            }\n+            // Tuple structs.\n+            ExprKind::Call(callee, args) => {\n+                if let Some(path) = self.extract_tuple_struct_path(callee) {\n+                    let (pats, rest) = self.destructure_sequence(\n+                        args,\n+                        \"tuple struct or variant\",\n+                        eq_sign_span,\n+                        assignments,\n+                    );\n+                    let qpath = self.lower_qpath(\n+                        callee.id,\n+                        &None,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    );\n+                    // Destructure like a tuple struct.\n+                    let tuple_struct_pat =\n+                        hir::PatKind::TupleStruct(qpath, pats, rest.map(|r| r.0));\n+                    return self.pat_without_dbm(lhs.span, tuple_struct_pat);\n+                }\n+            }\n+            // Structs.\n+            ExprKind::Struct(path, fields, rest) => {\n+                let field_pats = self.arena.alloc_from_iter(fields.iter().map(|f| {\n+                    let pat = self.destructure_assign(&f.expr, eq_sign_span, assignments);\n+                    hir::FieldPat {\n+                        hir_id: self.next_id(),\n+                        ident: f.ident,\n+                        pat,\n+                        is_shorthand: f.is_shorthand,\n+                        span: f.span,\n+                    }\n+                }));\n+                let qpath = self.lower_qpath(\n+                    lhs.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                let fields_omitted = match rest {\n+                    StructRest::Base(e) => {\n+                        self.sess\n+                            .struct_span_err(\n+                                e.span,\n+                                \"functional record updates are not allowed in destructuring \\\n+                                    assignments\",\n+                            )\n+                            .span_suggestion(\n+                                e.span,\n+                                \"consider removing the trailing pattern\",\n+                                String::new(),\n+                                rustc_errors::Applicability::MachineApplicable,\n+                            )\n+                            .emit();\n+                        true\n+                    }\n+                    StructRest::Rest(_) => true,\n+                    StructRest::None => false,\n+                };\n+                let struct_pat = hir::PatKind::Struct(qpath, field_pats, fields_omitted);\n+                return self.pat_without_dbm(lhs.span, struct_pat);\n+            }\n             // Tuples.\n             ExprKind::Tup(elements) => {\n                 let (pats, rest) ="}, {"sha": "2831675cb36712558a7fb6da536bf69696925e84", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -630,6 +630,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(const_trait_impl, \"const trait impls are experimental\");\n     gate_all!(half_open_range_patterns, \"half-open range patterns are unstable\");\n     gate_all!(inline_const, \"inline-const is experimental\");\n+    gate_all!(destructuring_assignment, \"destructuring assignments are unstable\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "17b3711b485eadc6b20b39d87720a4c283c5ade9", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -1729,7 +1729,7 @@ impl<'a> State<'a> {\n         &mut self,\n         path: &ast::Path,\n         fields: &[ast::Field],\n-        wth: &Option<P<ast::Expr>>,\n+        rest: &ast::StructRest,\n         attrs: &[ast::Attribute],\n     ) {\n         self.print_path(path, true, 0);\n@@ -1750,22 +1750,21 @@ impl<'a> State<'a> {\n             },\n             |f| f.span,\n         );\n-        match *wth {\n-            Some(ref expr) => {\n+        match rest {\n+            ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n                 self.ibox(INDENT_UNIT);\n                 if !fields.is_empty() {\n                     self.s.word(\",\");\n                     self.s.space();\n                 }\n                 self.s.word(\"..\");\n-                self.print_expr(expr);\n-                self.end();\n-            }\n-            _ => {\n-                if !fields.is_empty() {\n-                    self.s.word(\",\")\n+                if let ast::StructRest::Base(ref expr) = *rest {\n+                    self.print_expr(expr);\n                 }\n+                self.end();\n             }\n+            ast::StructRest::None if !fields.is_empty() => self.s.word(\",\"),\n+            _ => {}\n         }\n         self.s.word(\"}\");\n     }\n@@ -1891,8 +1890,8 @@ impl<'a> State<'a> {\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.print_expr_repeat(element, count, attrs);\n             }\n-            ast::ExprKind::Struct(ref path, ref fields, ref wth) => {\n-                self.print_expr_struct(path, &fields[..], wth, attrs);\n+            ast::ExprKind::Struct(ref path, ref fields, ref rest) => {\n+                self.print_expr_struct(path, &fields[..], rest, attrs);\n             }\n             ast::ExprKind::Tup(ref exprs) => {\n                 self.print_expr_tup(&exprs[..], attrs);"}, {"sha": "30f0fc6cddfa2cbd08d9101247bb76ef576bb396", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -298,7 +298,7 @@ impl<'a> ExtCtxt<'a> {\n         path: ast::Path,\n         fields: Vec<ast::Field>,\n     ) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprKind::Struct(path, fields, None))\n+        self.expr(span, ast::ExprKind::Struct(path, fields, ast::StructRest::None))\n     }\n     pub fn expr_struct_ident(\n         &self,"}, {"sha": "298cfcc254c86d745c35a6d600225ea01ad987d7", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -484,4 +484,9 @@ impl<Id> Res<Id> {\n     pub fn matches_ns(&self, ns: Namespace) -> bool {\n         self.ns().map_or(true, |actual_ns| actual_ns == ns)\n     }\n+\n+    /// Returns whether such a resolved path can occur in a tuple struct/variant pattern\n+    pub fn expected_in_tuple_struct_pat(&self) -> bool {\n+        matches!(self, Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..))\n+    }\n }"}, {"sha": "188bf227c4249ead979ceb1f9d8284985462c487", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -2087,7 +2087,7 @@ impl<'a> Parser<'a> {\n         recover: bool,\n     ) -> PResult<'a, P<Expr>> {\n         let mut fields = Vec::new();\n-        let mut base = None;\n+        let mut base = ast::StructRest::None;\n         let mut recover_async = false;\n \n         attrs.extend(self.parse_inner_attributes()?);\n@@ -2102,8 +2102,14 @@ impl<'a> Parser<'a> {\n         while self.token != token::CloseDelim(token::Brace) {\n             if self.eat(&token::DotDot) {\n                 let exp_span = self.prev_token.span;\n+                // We permit `.. }` on the left-hand side of a destructuring assignment.\n+                if self.check(&token::CloseDelim(token::Brace)) {\n+                    self.sess.gated_spans.gate(sym::destructuring_assignment, self.prev_token.span);\n+                    base = ast::StructRest::Rest(self.prev_token.span.shrink_to_hi());\n+                    break;\n+                }\n                 match self.parse_expr() {\n-                    Ok(e) => base = Some(e),\n+                    Ok(e) => base = ast::StructRest::Base(e),\n                     Err(mut e) if recover => {\n                         e.emit();\n                         self.recover_stmt();"}, {"sha": "2149fd7e011849e02dc1c6396bf699555f10e088", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -298,9 +298,7 @@ impl<'a> PathSource<'a> {\n                     _,\n                 )\n                 | Res::SelfCtor(..)),\n-            PathSource::TupleStruct(..) => {\n-                matches!(res, Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..))\n-            }\n+            PathSource::TupleStruct(..) => res.expected_in_tuple_struct_pat(),\n             PathSource::Struct => matches!(res, Res::Def(\n                     DefKind::Struct\n                     | DefKind::Union"}, {"sha": "40d60a8394be362662519ae2fcd1bf14d643a450", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -816,7 +816,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         path: &'tcx hir::QPath<'tcx>,\n         fields: &'tcx [hir::Field<'tcx>],\n         variant: &'tcx ty::VariantDef,\n-        base: Option<&'tcx hir::Expr<'tcx>>,\n+        rest: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n             if let hir::QPath::Resolved(_, path) = path {\n@@ -836,7 +836,9 @@ impl<'tcx> DumpVisitor<'tcx> {\n             }\n         }\n \n-        walk_list!(self, visit_expr, base);\n+        if let Some(base) = rest {\n+            self.visit_expr(&base);\n+        }\n     }\n \n     fn process_method_call(\n@@ -1399,7 +1401,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n         debug!(\"visit_expr {:?}\", ex.kind);\n         self.process_macro_use(ex.span);\n         match ex.kind {\n-            hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n+            hir::ExprKind::Struct(ref path, ref fields, ref rest) => {\n                 let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.hir_id);\n                 let adt = match self.save_ctxt.typeck_results().expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n@@ -1409,7 +1411,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     }\n                 };\n                 let res = self.save_ctxt.get_path_res(hir_expr.hir_id);\n-                self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *base)\n+                self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *rest)\n             }\n             hir::ExprKind::MethodCall(ref seg, _, args, _) => {\n                 self.process_method_call(ex, seg, args)"}, {"sha": "bff92d8607ece1936cc71b5dcd2f1232e101648b", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -155,7 +155,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             },\n             17 => {\n                 let path = Path::from_ident(Ident::from_str(\"S\"));\n-                g(ExprKind::Struct(path, vec![], Some(make_x())));\n+                g(ExprKind::Struct(path, vec![], StructRest::Base(make_x())));\n             },\n             18 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Try(e)));"}, {"sha": "393dfc16c0a1c131333f6526122e231d9b3186f9", "filename": "src/test/ui/destructuring-assignment/nested_destructure.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnested_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnested_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnested_destructure.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+struct Struct<S, T> {\n+    a: S,\n+    b: T,\n+}\n+\n+struct TupleStruct<S, T>(S, T);\n+\n+fn main() {\n+    let (a, b, c, d);\n+    Struct { a: TupleStruct((a, b), c), b: [d] } =\n+        Struct { a: TupleStruct((0, 1), 2), b: [3] };\n+    assert_eq!((a, b, c, d), (0, 1, 2, 3));\n+}"}, {"sha": "249fba7f920bc81153abc4d72338d1540a691fbf", "filename": "src/test/ui/destructuring-assignment/note-unsupported.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -7,18 +7,19 @@ fn main() {\n     (a, b) += (3, 4); //~ ERROR invalid left-hand side of assignment\n     //~| ERROR binary assignment operation `+=` cannot be applied\n \n-    [a, b] = [3, 4]; //~ ERROR invalid left-hand side of assignment\n+    [a, b] = [3, 4]; //~ ERROR destructuring assignments are unstable\n     [a, b] += [3, 4]; //~ ERROR invalid left-hand side of assignment\n     //~| ERROR binary assignment operation `+=` cannot be applied\n \n     let s = S { x: 3, y: 4 };\n \n-    S { x: a, y: b } = s; //~ ERROR invalid left-hand side of assignment\n+    S { x: a, y: b } = s; //~ ERROR destructuring assignments are unstable\n     S { x: a, y: b } += s; //~ ERROR invalid left-hand side of assignment\n     //~| ERROR binary assignment operation `+=` cannot be applied\n \n     S { x: a, ..s } = S { x: 3, y: 4 };\n-    //~^ ERROR invalid left-hand side of assignment\n+    //~^ ERROR functional record updates are not allowed in destructuring assignments\n+    //~| ERROR destructuring assignments are unstable\n \n     let c = 3;\n "}, {"sha": "a81324b99e5868c4ad3509244348e9e541e4f004", "filename": "src/test/ui/destructuring-assignment/note-unsupported.stderr", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -10,7 +10,46 @@ LL |     (a, b) = (3, 4);\n    = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n \n error[E0658]: destructuring assignments are unstable\n-  --> $DIR/note-unsupported.rs:25:17\n+  --> $DIR/note-unsupported.rs:10:12\n+   |\n+LL |     [a, b] = [3, 4];\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/note-unsupported.rs:16:22\n+   |\n+LL |     S { x: a, y: b } = s;\n+   |     ---------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/note-unsupported.rs:20:21\n+   |\n+LL |     S { x: a, ..s } = S { x: 3, y: 4 };\n+   |     --------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error: functional record updates are not allowed in destructuring assignments\n+  --> $DIR/note-unsupported.rs:20:17\n+   |\n+LL |     S { x: a, ..s } = S { x: 3, y: 4 };\n+   |                 ^ help: consider removing the trailing pattern\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/note-unsupported.rs:26:17\n    |\n LL |     ((a, b), c) = ((3, 4), 5);\n    |     ----------- ^\n@@ -36,14 +75,6 @@ LL |     (a, b) += (3, 4);\n    |     |\n    |     cannot assign to this expression\n \n-error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/note-unsupported.rs:10:12\n-   |\n-LL |     [a, b] = [3, 4];\n-   |     ------ ^\n-   |     |\n-   |     cannot assign to this expression\n-\n error[E0368]: binary assignment operation `+=` cannot be applied to type `[{integer}; 2]`\n   --> $DIR/note-unsupported.rs:11:5\n    |\n@@ -60,14 +91,6 @@ LL |     [a, b] += [3, 4];\n    |     |\n    |     cannot assign to this expression\n \n-error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/note-unsupported.rs:16:22\n-   |\n-LL |     S { x: a, y: b } = s;\n-   |     ---------------- ^\n-   |     |\n-   |     cannot assign to this expression\n-\n error[E0368]: binary assignment operation `+=` cannot be applied to type `S`\n   --> $DIR/note-unsupported.rs:17:5\n    |\n@@ -86,15 +109,7 @@ LL |     S { x: a, y: b } += s;\n    |     |\n    |     cannot assign to this expression\n \n-error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/note-unsupported.rs:20:21\n-   |\n-LL |     S { x: a, ..s } = S { x: 3, y: 4 };\n-   |     --------------- ^\n-   |     |\n-   |     cannot assign to this expression\n-\n-error: aborting due to 11 previous errors\n+error: aborting due to 12 previous errors\n \n-Some errors have detailed explanations: E0067, E0070, E0368, E0658.\n+Some errors have detailed explanations: E0067, E0368, E0658.\n For more information about an error, try `rustc --explain E0067`."}, {"sha": "3dd10aff19c72aaefb019b7d7d5a86fc309be765", "filename": "src/test/ui/destructuring-assignment/slice_destructure.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+fn main() {\n+  let (mut a, mut b);\n+  [a, b] = [0, 1];\n+  assert_eq!((a, b), (0, 1));\n+  let mut c;\n+  [a, .., b, c] = [1, 2, 3, 4, 5];\n+  assert_eq!((a, b, c), (1, 4, 5));\n+  [..] = [1, 2, 3];\n+  [c, ..] = [5, 6, 6];\n+  assert_eq!(c, 5);\n+}"}, {"sha": "f636ea3511c2672090e8e08db4a2a4b2f6d9e25a", "filename": "src/test/ui/destructuring-assignment/slice_destructure_fail.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,7 @@\n+#![feature(destructuring_assignment)]\n+\n+fn main() {\n+  let (mut a, mut b);\n+  [a, .., b, ..] = [0, 1]; //~ ERROR `..` can only be used once per slice pattern\n+  [a, a, b] = [1, 2]; //~ ERROR pattern requires 3 elements but array has 2\n+}"}, {"sha": "728687deb8bbbd96af66338f9708a5ead40e22cd", "filename": "src/test/ui/destructuring-assignment/slice_destructure_fail.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.stderr?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,17 @@\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/slice_destructure_fail.rs:5:14\n+   |\n+LL |   [a, .., b, ..] = [0, 1];\n+   |       --     ^^ can only be used once per slice pattern\n+   |       |\n+   |       previously used here\n+\n+error[E0527]: pattern requires 3 elements but array has 2\n+  --> $DIR/slice_destructure_fail.rs:6:3\n+   |\n+LL |   [a, a, b] = [1, 2];\n+   |   ^^^^^^^^^ expected 2 elements\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0527`."}, {"sha": "b3a96ee1573460c0ef6b9a49322568fd33771f48", "filename": "src/test/ui/destructuring-assignment/struct_destructure.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+struct Struct<S, T> {\n+    a: S,\n+    b: T,\n+}\n+\n+fn main() {\n+    let (mut a, mut b);\n+    Struct { a, b } = Struct { a: 0, b: 1 };\n+    assert_eq!((a, b), (0, 1));\n+    Struct { a: b, b: a }  = Struct { a: 1, b: 2 };\n+    assert_eq!((a,b), (2, 1));\n+    Struct { a, .. } = Struct { a: 1, b: 3 };\n+    assert_eq!((a, b), (1, 1));\n+    Struct { .. } = Struct { a: 1, b: 4 };\n+    assert_eq!((a, b), (1, 1));\n+}"}, {"sha": "c22695ed38849523faaec38300ab2cd322711f2d", "filename": "src/test/ui/destructuring-assignment/struct_destructure_fail.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,15 @@\n+#![feature(destructuring_assignment)]\n+struct Struct<S, T> {\n+    a: S,\n+    b: T,\n+}\n+\n+fn main() {\n+    let (mut a, b);\n+    let mut c;\n+    let d = Struct { a: 0, b: 1 };\n+    Struct { a, b, c } = Struct { a: 0, b: 1 }; //~ ERROR does not have a field named `c`\n+    Struct { a, ..d } = Struct { a: 1, b: 2 };\n+    //~^ ERROR functional record updates are not allowed in destructuring assignments\n+    Struct { a, .. }; //~ ERROR base expression required after `..`\n+}"}, {"sha": "4da4698804f1ad4ebea6cdfbbb083f0c28da2e92", "filename": "src/test/ui/destructuring-assignment/struct_destructure_fail.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,21 @@\n+error: functional record updates are not allowed in destructuring assignments\n+  --> $DIR/struct_destructure_fail.rs:12:19\n+   |\n+LL |     Struct { a, ..d } = Struct { a: 1, b: 2 };\n+   |                   ^ help: consider removing the trailing pattern\n+\n+error: base expression required after `..`\n+  --> $DIR/struct_destructure_fail.rs:14:19\n+   |\n+LL |     Struct { a, .. };\n+   |                   ^ add a base expression here\n+\n+error[E0026]: struct `Struct` does not have a field named `c`\n+  --> $DIR/struct_destructure_fail.rs:11:20\n+   |\n+LL |     Struct { a, b, c } = Struct { a: 0, b: 1 };\n+   |                    ^ struct `Struct` does not have this field\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0026`."}, {"sha": "106a9b16db45981167938c49cf75cedb3ba55b51", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,34 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+struct TupleStruct<S, T>(S, T);\n+\n+impl<S, T> TupleStruct<S, T> {\n+    fn assign(self, first: &mut S, second: &mut T) {\n+        // Test usage of `Self` instead of the struct name:\n+        Self(*first, *second) = self\n+    }\n+}\n+\n+enum Enum<S, T> {\n+    SingleVariant(S, T)\n+}\n+\n+type Alias<S> = Enum<S, isize>;\n+\n+fn main() {\n+    let (mut a, mut b);\n+    TupleStruct(a, b) = TupleStruct(0, 1);\n+    assert_eq!((a, b), (0, 1));\n+    TupleStruct(a, .., b) = TupleStruct(1, 2);\n+    assert_eq!((a, b), (1, 2));\n+    TupleStruct(..) = TupleStruct(3, 4);\n+    assert_eq!((a, b), (1, 2));\n+    TupleStruct(5,6).assign(&mut a, &mut b);\n+    assert_eq!((a, b), (5, 6));\n+    Enum::SingleVariant(a, b) = Enum::SingleVariant(7, 8);\n+    assert_eq!((a, b), (7, 8));\n+    Alias::SingleVariant(a, b) = Alias::SingleVariant(9, 10);\n+    assert_eq!((a, b), (9, 10));\n+}"}, {"sha": "61ae42a51751f0b92d2be5504d83e5cf58e996bc", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure_fail.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,42 @@\n+#![feature(destructuring_assignment)]\n+\n+struct TupleStruct<S, T>(S, T);\n+\n+enum Enum<S, T> {\n+    SingleVariant(S, T)\n+}\n+\n+type Alias<S> = Enum<S, isize>;\n+\n+trait Test {\n+    fn test() -> TupleStruct<isize, isize> {\n+        TupleStruct(0, 0)\n+    }\n+}\n+\n+impl Test for Alias<isize> {}\n+\n+fn test() -> TupleStruct<isize, isize> {\n+    TupleStruct(0, 0)\n+}\n+\n+fn main() {\n+    let (mut a, mut b);\n+    TupleStruct(a, .., b, ..) = TupleStruct(0, 1);\n+    //~^ ERROR `..` can only be used once per tuple struct or variant pattern\n+    Enum::SingleVariant(a, .., b, ..) = Enum::SingleVariant(0, 1);\n+    //~^ ERROR `..` can only be used once per tuple struct or variant pattern\n+\n+    TupleStruct(a, a, b) = TupleStruct(1, 2);\n+    //~^ ERROR this pattern has 3 fields, but the corresponding tuple struct has 2 fields\n+    Enum::SingleVariant(a, a, b) = Enum::SingleVariant(1, 2);\n+    //~^ ERROR this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n+\n+    // Check if `test` is recognized as not a tuple struct but a function call:\n+    test() = TupleStruct(0, 0);\n+    //~^ ERROR invalid left-hand side of assignment\n+    (test)() = TupleStruct(0, 0);\n+    //~^ ERROR invalid left-hand side of assignment\n+    <Alias::<isize> as Test>::test() = TupleStruct(0, 0);\n+    //~^ ERROR invalid left-hand side of assignment\n+}"}, {"sha": "863eedecf7697ac96980966cbf358b1533f2509a", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure_fail.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,62 @@\n+error: `..` can only be used once per tuple struct or variant pattern\n+  --> $DIR/tuple_struct_destructure_fail.rs:25:27\n+   |\n+LL |     TupleStruct(a, .., b, ..) = TupleStruct(0, 1);\n+   |                    --     ^^ can only be used once per tuple struct or variant pattern\n+   |                    |\n+   |                    previously used here\n+\n+error: `..` can only be used once per tuple struct or variant pattern\n+  --> $DIR/tuple_struct_destructure_fail.rs:27:35\n+   |\n+LL |     Enum::SingleVariant(a, .., b, ..) = Enum::SingleVariant(0, 1);\n+   |                            --     ^^ can only be used once per tuple struct or variant pattern\n+   |                            |\n+   |                            previously used here\n+\n+error[E0023]: this pattern has 3 fields, but the corresponding tuple struct has 2 fields\n+  --> $DIR/tuple_struct_destructure_fail.rs:30:5\n+   |\n+LL | struct TupleStruct<S, T>(S, T);\n+   | ------------------------------- tuple struct defined here\n+...\n+LL |     TupleStruct(a, a, b) = TupleStruct(1, 2);\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 3\n+\n+error[E0023]: this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n+  --> $DIR/tuple_struct_destructure_fail.rs:32:5\n+   |\n+LL |     SingleVariant(S, T)\n+   |     ------------------- tuple variant defined here\n+...\n+LL |     Enum::SingleVariant(a, a, b) = Enum::SingleVariant(1, 2);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 3\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/tuple_struct_destructure_fail.rs:36:12\n+   |\n+LL |     test() = TupleStruct(0, 0);\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/tuple_struct_destructure_fail.rs:38:14\n+   |\n+LL |     (test)() = TupleStruct(0, 0);\n+   |     -------- ^\n+   |     |\n+   |     cannot assign to this expression\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/tuple_struct_destructure_fail.rs:40:38\n+   |\n+LL |     <Alias::<isize> as Test>::test() = TupleStruct(0, 0);\n+   |     -------------------------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors have detailed explanations: E0023, E0070.\n+For more information about an error, try `rustc --explain E0023`."}, {"sha": "b41f2f52a3d6f5ce4aa0ea1ffcd9a15c60f17702", "filename": "src/test/ui/destructuring-assignment/underscore-range-expr-gating.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,8 @@\n+fn main() {}\n+\n+struct S { x : u32 }\n+\n+#[cfg(FALSE)]\n+fn foo() {\n+    S { x: 5, .. }; //~ ERROR destructuring assignments are unstable\n+}"}, {"sha": "442e36cd3065e6d10b1fe86e4a382745a6c87ffb", "filename": "src/test/ui/destructuring-assignment/underscore-range-expr-gating.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.stderr?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/underscore-range-expr-gating.rs:7:15\n+   |\n+LL |     S { x: 5, .. };\n+   |               ^^\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "a6a2401795ff4690de26464185566ef459dcd38e", "filename": "src/test/ui/issues/issue-77218.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fissues%2Fissue-77218.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fissues%2Fissue-77218.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77218.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -1,7 +1,11 @@\n fn main() {\n     let value = [7u8];\n-    while Some(0) = value.get(0) { //~ ERROR mismatched types\n-        //~^ NOTE expected `bool`, found `()`\n-        //~| HELP you might have meant to use pattern matching\n+    while Some(0) = value.get(0) { //~ ERROR destructuring assignments are unstable\n+        //~| ERROR invalid left-hand side of assignment\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+\n+        // FIXME The following diagnostic should also be emitted\n+        // HELP you might have meant to use pattern matching\n     }\n }"}, {"sha": "4f6fbaa2265d5ac01ca8de66553da8e8ddca240d", "filename": "src/test/ui/issues/issue-77218.stderr", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fissues%2Fissue-77218.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fissues%2Fissue-77218.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77218.stderr?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -1,14 +1,38 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/issue-77218.rs:3:19\n+   |\n+LL |     while Some(0) = value.get(0) {\n+   |           ------- ^\n+   |           |\n+   |           cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/issue-77218.rs:3:19\n+   |\n+LL |     while Some(0) = value.get(0) {\n+   |                -  ^\n+   |                |\n+   |                cannot assign to this expression\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-77218.rs:3:16\n+   |\n+LL |     while Some(0) = value.get(0) {\n+   |                ^\n+   |                |\n+   |                expected integer, found `&u8`\n+   |                help: consider dereferencing the borrow: `*0`\n+\n error[E0308]: mismatched types\n   --> $DIR/issue-77218.rs:3:11\n    |\n LL |     while Some(0) = value.get(0) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n-   |\n-help: you might have meant to use pattern matching\n-   |\n-LL |     while let Some(0) = value.get(0) {\n-   |           ^^^\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0070, E0308, E0658.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "688b6e826582610956fc49e3e50f6c56734652a2", "filename": "src/test/ui/suggestions/if-let-typo.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -2,7 +2,12 @@ fn main() {\n     let foo = Some(0);\n     let bar = None;\n     if Some(x) = foo {} //~ ERROR cannot find value `x` in this scope\n+    //~^ ERROR mismatched types\n+    //~^^ ERROR destructuring assignments are unstable\n     if Some(foo) = bar {} //~ ERROR mismatched types\n+    //~^ ERROR destructuring assignments are unstable\n     if 3 = foo {} //~ ERROR mismatched types\n     if Some(3) = foo {} //~ ERROR mismatched types\n+    //~^ ERROR destructuring assignments are unstable\n+    //~^^ ERROR invalid left-hand side of assignment\n }"}, {"sha": "ce1ee0cd06d4854788b78cd9ca1a7e61213d00e7", "filename": "src/test/ui/suggestions/if-let-typo.stderr", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.stderr?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -9,23 +9,53 @@ help: you might have meant to use pattern matching\n LL |     if let Some(x) = foo {}\n    |        ^^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/if-let-typo.rs:5:8\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/if-let-typo.rs:4:16\n+   |\n+LL |     if Some(x) = foo {}\n+   |        ------- ^\n+   |        |\n+   |        cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/if-let-typo.rs:7:18\n    |\n LL |     if Some(foo) = bar {}\n-   |        ^^^^^^^^^^^^^^^ expected `bool`, found `()`\n+   |        --------- ^\n+   |        |\n+   |        cannot assign to this expression\n    |\n-help: you might have meant to use pattern matching\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/if-let-typo.rs:10:16\n    |\n-LL |     if let Some(foo) = bar {}\n-   |        ^^^\n-help: you might have meant to compare for equality\n+LL |     if Some(3) = foo {}\n+   |        ------- ^\n+   |        |\n+   |        cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0308]: mismatched types\n+  --> $DIR/if-let-typo.rs:4:8\n+   |\n+LL |     if Some(x) = foo {}\n+   |        ^^^^^^^^^^^^^ expected `bool`, found `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/if-let-typo.rs:7:8\n    |\n-LL |     if Some(foo) == bar {}\n-   |                  ^^\n+LL |     if Some(foo) = bar {}\n+   |        ^^^^^^^^^^^^^^^ expected `bool`, found `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/if-let-typo.rs:6:8\n+  --> $DIR/if-let-typo.rs:9:8\n    |\n LL |     if 3 = foo {}\n    |        ^^^^^^^ expected `bool`, found `()`\n@@ -35,22 +65,21 @@ help: you might have meant to use pattern matching\n LL |     if let 3 = foo {}\n    |        ^^^\n \n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/if-let-typo.rs:10:16\n+   |\n+LL |     if Some(3) = foo {}\n+   |             -  ^\n+   |             |\n+   |             cannot assign to this expression\n+\n error[E0308]: mismatched types\n-  --> $DIR/if-let-typo.rs:7:8\n+  --> $DIR/if-let-typo.rs:10:8\n    |\n LL |     if Some(3) = foo {}\n    |        ^^^^^^^^^^^^^ expected `bool`, found `()`\n-   |\n-help: you might have meant to use pattern matching\n-   |\n-LL |     if let Some(3) = foo {}\n-   |        ^^^\n-help: you might have meant to compare for equality\n-   |\n-LL |     if Some(3) == foo {}\n-   |                ^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 9 previous errors\n \n-Some errors have detailed explanations: E0308, E0425.\n-For more information about an error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0070, E0308, E0425, E0658.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "7b65e664867ff6871c3844f63cfeb2570cd1a386", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -107,6 +107,15 @@ pub fn eq_expr_opt(l: &Option<P<Expr>>, r: &Option<P<Expr>>) -> bool {\n     both(l, r, |l, r| eq_expr(l, r))\n }\n \n+pub fn eq_struct_rest(l: &StructRest, r: &StructRest) -> bool {\n+    match (l, r) {\n+        (StructRest::Base(lb), StructRest::Base(rb)) => eq_expr(lb, rb),\n+        (StructRest::Rest(_), StructRest::Rest(_)) => true,\n+        (StructRest::None, StructRest::None) => true,\n+        _ => false,\n+    }\n+}\n+\n pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n     use ExprKind::*;\n     if !over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r)) {\n@@ -150,7 +159,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n         (Struct(lp, lfs, lb), Struct(rp, rfs, rb)) => {\n-            eq_path(lp, rp) && eq_expr_opt(lb, rb) && unordered_over(lfs, rfs, |l, r| eq_field(l, r))\n+            eq_path(lp, rp) && eq_struct_rest(lb, rb) && unordered_over(lfs, rfs, |l, r| eq_field(l, r))\n         },\n         _ => false,\n     }"}, {"sha": "c38727316cd4e8dff0d860c058609953eb1e42da", "filename": "src/tools/clippy/tests/ui/crashes/ice-6250.stderr", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de84ad95b4b097e504171c7c606bf3715803c13b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.stderr?ref=de84ad95b4b097e504171c7c606bf3715803c13b", "patch": "@@ -1,3 +1,14 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/ice-6250.rs:12:25\n+   |\n+LL |         Some(reference) = cache.data.get(key) {\n+   |         --------------- ^\n+   |         |\n+   |         cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n error[E0601]: `main` function not found in crate `ice_6250`\n   --> $DIR/ice-6250.rs:4:1\n    |\n@@ -10,18 +21,22 @@ LL | |     }\n LL | | }\n    | |_^ consider adding a `main` function to `$DIR/ice-6250.rs`\n \n+error[E0308]: mismatched types\n+  --> $DIR/ice-6250.rs:12:14\n+   |\n+LL |         Some(reference) = cache.data.get(key) {\n+   |              ^^^^^^^^^\n+   |              |\n+   |              expected integer, found `&i32`\n+   |              help: consider dereferencing the borrow: `*reference`\n+\n error[E0308]: mismatched types\n   --> $DIR/ice-6250.rs:12:9\n    |\n LL |         Some(reference) = cache.data.get(key) {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n-   |\n-help: you might have meant to use pattern matching\n-   |\n-LL |         let Some(reference) = cache.data.get(key) {\n-   |         ^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0308, E0601.\n+Some errors have detailed explanations: E0308, E0601, E0658.\n For more information about an error, try `rustc --explain E0308`."}]}