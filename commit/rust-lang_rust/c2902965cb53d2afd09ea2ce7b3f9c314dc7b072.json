{"sha": "c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOTAyOTY1Y2I1M2QyYWZkMDllYTJjZTdiM2Y5YzMxNGRjN2IwNzI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-18T08:13:45Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-18T11:17:37Z"}, "message": "Rollup merge of #30384 - nrc:diagnostics, r=@nikomatsakis\n\nShould make it possible to add JSON or HTML errors. Also tidies up a lot.", "tree": {"sha": "83b7c8e4e6118bfaa26d7be0d82923537c663bcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83b7c8e4e6118bfaa26d7be0d82923537c663bcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "html_url": "https://github.com/rust-lang/rust/commit/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb319fc84fa52773dd31ead8761b1c251e916e88", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb319fc84fa52773dd31ead8761b1c251e916e88", "html_url": "https://github.com/rust-lang/rust/commit/cb319fc84fa52773dd31ead8761b1c251e916e88"}, {"sha": "ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "html_url": "https://github.com/rust-lang/rust/commit/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104"}], "stats": {"total": 1629, "additions": 856, "deletions": 773}, "files": [{"sha": "db22000fd9f5d1b5080315b0324aa61c2ab04579", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -47,7 +47,7 @@ use rustc_front::hir;\n use rustc_front::util;\n use rustc_front::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n-use syntax::diagnostic;\n+use syntax::errors;\n \n /// Information about the registered lints.\n ///\n@@ -167,7 +167,7 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(diagnostic::Auto, &msg[..]),\n+                    (None, _) => early_error(errors::ColorConfig::Auto, &msg[..]),\n                     (Some(sess), false) => sess.bug(&msg[..]),\n \n                     // A duplicate name from a plugin is a user error.\n@@ -191,7 +191,7 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(diagnostic::Auto, &msg[..]),\n+                (None, _) => early_error(errors::ColorConfig::Auto, &msg[..]),\n                 (Some(sess), false) => sess.bug(&msg[..]),\n \n                 // A duplicate name from a plugin is a user error."}, {"sha": "e33fe9570c024f9bfaac483a1da7c47776a4834b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -27,7 +27,7 @@ use middle::cstore;\n use syntax::ast::{self, IntTy, UintTy};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::diagnostic::{ColorConfig, Auto, Always, Never, SpanHandler};\n+use syntax::errors::{ColorConfig, Handler};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::feature_gate::UnstableFeatures;\n@@ -238,7 +238,7 @@ pub fn basic_options() -> Options {\n         debugging_opts: basic_debugging_options(),\n         prints: Vec::new(),\n         cg: basic_codegen_options(),\n-        color: Auto,\n+        color: ColorConfig::Auto,\n         show_span: None,\n         externs: HashMap::new(),\n         crate_name: None,\n@@ -687,19 +687,19 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n     v\n }\n \n-pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n+pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n     let target = match Target::search(&opts.target_triple) {\n         Ok(t) => t,\n         Err(e) => {\n-            panic!(sp.handler().fatal(&format!(\"Error loading target specification: {}\", e)));\n+            panic!(sp.fatal(&format!(\"Error loading target specification: {}\", e)));\n         }\n     };\n \n     let (int_type, uint_type) = match &target.target_pointer_width[..] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n-        w    => panic!(sp.handler().fatal(&format!(\"target specification was invalid: \\\n-                                                    unrecognized target-pointer-width {}\", w))),\n+        w    => panic!(sp.fatal(&format!(\"target specification was invalid: \\\n+                                          unrecognized target-pointer-width {}\", w))),\n     };\n \n     Config {\n@@ -884,16 +884,16 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n \n pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n-        Some(\"auto\")   => Auto,\n-        Some(\"always\") => Always,\n-        Some(\"never\")  => Never,\n+        Some(\"auto\")   => ColorConfig::Auto,\n+        Some(\"always\") => ColorConfig::Always,\n+        Some(\"never\")  => ColorConfig::Never,\n \n-        None => Auto,\n+        None => ColorConfig::Auto,\n \n         Some(arg) => {\n-            early_error(Auto, &format!(\"argument for --color must be auto, always \\\n-                                        or never (instead was `{}`)\",\n-                                       arg))\n+            early_error(ColorConfig::Auto, &format!(\"argument for --color must be auto, always \\\n+                                                     or never (instead was `{}`)\",\n+                                                    arg))\n         }\n     };\n \n@@ -1224,7 +1224,7 @@ mod tests {\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry,\n                                      Rc::new(DummyCrateStore));\n-            assert!(!sess.can_print_warnings);\n+            assert!(!sess.diagnostic().can_emit_warnings);\n         }\n \n         {\n@@ -1236,7 +1236,7 @@ mod tests {\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry,\n                                      Rc::new(DummyCrateStore));\n-            assert!(sess.can_print_warnings);\n+            assert!(sess.diagnostic().can_emit_warnings);\n         }\n \n         {\n@@ -1247,7 +1247,7 @@ mod tests {\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry,\n                                      Rc::new(DummyCrateStore));\n-            assert!(sess.can_print_warnings);\n+            assert!(sess.diagnostic().can_emit_warnings);\n         }\n     }\n }"}, {"sha": "7b96db4bf0a3af87e3283dc5cd672b30c5303865", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 37, "deletions": 87, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -16,7 +16,8 @@ use util::nodemap::{NodeMap, FnvHashMap};\n \n use syntax::ast::{NodeId, NodeIdAssigner, Name};\n use syntax::codemap::Span;\n-use syntax::diagnostic::{self, Emitter};\n+use syntax::errors;\n+use syntax::errors::emitter::{Emitter, BasicEmitter};\n use syntax::diagnostics;\n use syntax::feature_gate;\n use syntax::parse;\n@@ -63,14 +64,10 @@ pub struct Session {\n     pub crate_metadata: RefCell<Vec<String>>,\n     pub features: RefCell<feature_gate::Features>,\n \n-    pub delayed_span_bug: RefCell<Option<(codemap::Span, String)>>,\n-\n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n     pub recursion_limit: Cell<usize>,\n \n-    pub can_print_warnings: bool,\n-\n     /// The metadata::creader module may inject an allocator dependency if it\n     /// didn't already find one, and this tracks what was injected.\n     pub injected_allocator: Cell<Option<ast::CrateNum>>,\n@@ -84,22 +81,13 @@ pub struct Session {\n \n impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         panic!(self.diagnostic().span_fatal(sp, msg))\n     }\n     pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         panic!(self.diagnostic().span_fatal_with_code(sp, msg, code))\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n-        if self.opts.treat_err_as_bug {\n-            self.bug(msg);\n-        }\n-        panic!(self.diagnostic().handler().fatal(msg))\n+        panic!(self.diagnostic().fatal(msg))\n     }\n     pub fn span_err_or_warn(&self, is_warning: bool, sp: Span, msg: &str) {\n         if is_warning {\n@@ -109,9 +97,6 @@ impl Session {\n         }\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err(sp, &msg[..]),\n             None => self.diagnostic().span_err(sp, msg)\n@@ -125,36 +110,22 @@ impl Session {\n                       See RFC 1214 for details.\"));\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[..], code),\n             None => self.diagnostic().span_err_with_code(sp, msg, code)\n         }\n     }\n     pub fn err(&self, msg: &str) {\n-        if self.opts.treat_err_as_bug {\n-            self.bug(msg);\n-        }\n-        self.diagnostic().handler().err(msg)\n+        self.diagnostic().err(msg)\n     }\n     pub fn err_count(&self) -> usize {\n-        self.diagnostic().handler().err_count()\n+        self.diagnostic().err_count()\n     }\n     pub fn has_errors(&self) -> bool {\n-        self.diagnostic().handler().has_errors()\n+        self.diagnostic().has_errors()\n     }\n     pub fn abort_if_errors(&self) {\n-        self.diagnostic().handler().abort_if_errors();\n-\n-        let delayed_bug = self.delayed_span_bug.borrow();\n-        match *delayed_bug {\n-            Some((span, ref errmsg)) => {\n-                self.diagnostic().span_bug(span, errmsg);\n-            },\n-            _ => {}\n-        }\n+        self.diagnostic().abort_if_errors();\n     }\n     pub fn abort_if_new_errors<F>(&self, mut f: F)\n         where F: FnMut()\n@@ -166,19 +137,13 @@ impl Session {\n         }\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n-        if self.can_print_warnings {\n-            self.diagnostic().span_warn(sp, msg)\n-        }\n+        self.diagnostic().span_warn(sp, msg)\n     }\n     pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        if self.can_print_warnings {\n-            self.diagnostic().span_warn_with_code(sp, msg, code)\n-        }\n+        self.diagnostic().span_warn_with_code(sp, msg, code)\n     }\n     pub fn warn(&self, msg: &str) {\n-        if self.can_print_warnings {\n-            self.diagnostic().handler().warn(msg)\n-        }\n+        self.diagnostic().warn(msg)\n     }\n     pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {\n         match opt_sp {\n@@ -195,7 +160,7 @@ impl Session {\n \n     /// Prints out a message with a suggested edit of the code.\n     ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    /// See `errors::RenderSpan::Suggestion` for more information.\n     pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n         self.diagnostic().span_suggestion(sp, msg, suggestion)\n     }\n@@ -209,10 +174,10 @@ impl Session {\n         self.diagnostic().fileline_help(sp, msg)\n     }\n     pub fn note(&self, msg: &str) {\n-        self.diagnostic().handler().note(msg)\n+        self.diagnostic().note(msg)\n     }\n     pub fn help(&self, msg: &str) {\n-        self.diagnostic().handler().help(msg)\n+        self.diagnostic().help(msg)\n     }\n     pub fn opt_span_bug(&self, opt_sp: Option<Span>, msg: &str) -> ! {\n         match opt_sp {\n@@ -222,20 +187,19 @@ impl Session {\n     }\n     /// Delay a span_bug() call until abort_if_errors()\n     pub fn delay_span_bug(&self, sp: Span, msg: &str) {\n-        let mut delayed = self.delayed_span_bug.borrow_mut();\n-        *delayed = Some((sp, msg.to_string()));\n+        self.diagnostic().delay_span_bug(sp, msg)\n     }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_bug(sp, msg)\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.diagnostic().handler().bug(msg)\n+        self.diagnostic().bug(msg)\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_unimpl(sp, msg)\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.diagnostic().handler().unimpl(msg)\n+        self.diagnostic().unimpl(msg)\n     }\n     pub fn add_lint(&self,\n                     lint: &'static lint::Lint,\n@@ -260,7 +224,7 @@ impl Session {\n \n         id\n     }\n-    pub fn diagnostic<'a>(&'a self) -> &'a diagnostic::SpanHandler {\n+    pub fn diagnostic<'a>(&'a self) -> &'a errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }\n     pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n@@ -269,8 +233,7 @@ impl Session {\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp,\n-                      &format!(\"impossible case reached: {}\", msg));\n+        self.span_bug(sp, &format!(\"impossible case reached: {}\", msg));\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n@@ -413,30 +376,33 @@ pub fn build_session(sopts: config::Options,\n         .map(|&(_, ref level)| *level != lint::Allow)\n         .last()\n         .unwrap_or(true);\n+    let treat_err_as_bug = sopts.treat_err_as_bug;\n \n-    let codemap = codemap::CodeMap::new();\n+    let codemap = Rc::new(codemap::CodeMap::new());\n     let diagnostic_handler =\n-        diagnostic::Handler::new(sopts.color, Some(registry), can_print_warnings);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+        errors::Handler::new(sopts.color,\n+                             Some(registry),\n+                             can_print_warnings,\n+                             treat_err_as_bug,\n+                             codemap.clone());\n \n-    build_session_(sopts, local_crate_source_file, span_diagnostic_handler, cstore)\n+    build_session_(sopts, local_crate_source_file, diagnostic_handler, codemap, cstore)\n }\n \n pub fn build_session_(sopts: config::Options,\n                       local_crate_source_file: Option<PathBuf>,\n-                      span_diagnostic: diagnostic::SpanHandler,\n+                      span_diagnostic: errors::Handler,\n+                      codemap: Rc<codemap::CodeMap>,\n                       cstore: Rc<for<'a> CrateStore<'a>>)\n                       -> Session {\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,\n         Err(e) => {\n-            panic!(span_diagnostic.handler()\n-                                  .fatal(&format!(\"Error loading host specification: {}\", e)));\n+            panic!(span_diagnostic.fatal(&format!(\"Error loading host specification: {}\", e)));\n     }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n-    let p_s = parse::ParseSess::with_span_handler(span_diagnostic);\n+    let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,\n         None => Some(filesearch::get_or_default_sysroot())\n@@ -451,13 +417,6 @@ pub fn build_session_(sopts: config::Options,\n         }\n     );\n \n-    let can_print_warnings = sopts.lint_opts\n-        .iter()\n-        .filter(|&&(ref key, _)| *key == \"warnings\")\n-        .map(|&(_, ref level)| *level != lint::Allow)\n-        .last()\n-        .unwrap_or(true);\n-\n     let sess = Session {\n         target: target_cfg,\n         host: host,\n@@ -478,10 +437,8 @@ pub fn build_session_(sopts: config::Options,\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n         crate_metadata: RefCell::new(Vec::new()),\n-        delayed_span_bug: RefCell::new(None),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n-        can_print_warnings: can_print_warnings,\n         next_node_id: Cell::new(1),\n         injected_allocator: Cell::new(None),\n         available_macros: RefCell::new(HashSet::new()),\n@@ -490,20 +447,13 @@ pub fn build_session_(sopts: config::Options,\n     sess\n }\n \n-// Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T, M>(sess: &Session, opt: Option<T>, msg: M) -> T where\n-    M: FnOnce() -> String,\n-{\n-    diagnostic::expect(sess.diagnostic(), opt, msg)\n-}\n-\n-pub fn early_error(color: diagnostic::ColorConfig, msg: &str) -> ! {\n-    let mut emitter = diagnostic::EmitterWriter::stderr(color, None);\n-    emitter.emit(None, msg, None, diagnostic::Fatal);\n-    panic!(diagnostic::FatalError);\n+pub fn early_error(color: errors::ColorConfig, msg: &str) -> ! {\n+    let mut emitter = BasicEmitter::stderr(color);\n+    emitter.emit(None, msg, None, errors::Level::Fatal);\n+    panic!(errors::FatalError);\n }\n \n-pub fn early_warn(color: diagnostic::ColorConfig, msg: &str) {\n-    let mut emitter = diagnostic::EmitterWriter::stderr(color, None);\n-    emitter.emit(None, msg, None, diagnostic::Warning);\n+pub fn early_warn(color: errors::ColorConfig, msg: &str) {\n+    let mut emitter = BasicEmitter::stderr(color);\n+    emitter.emit(None, msg, None, errors::Level::Warning);\n }"}, {"sha": "6a787139d77aa88c3d96dfa981da7f41c9fbdfde", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -11,7 +11,7 @@\n use std::slice;\n use std::path::{Path, PathBuf};\n use session::early_error;\n-use syntax::diagnostic;\n+use syntax::errors;\n \n #[derive(Clone, Debug)]\n pub struct SearchPaths {\n@@ -38,7 +38,7 @@ impl SearchPaths {\n         SearchPaths { paths: Vec::new() }\n     }\n \n-    pub fn add_path(&mut self, path: &str, color: diagnostic::ColorConfig) {\n+    pub fn add_path(&mut self, path: &str, color: errors::ColorConfig) {\n         let (kind, path) = if path.starts_with(\"native=\") {\n             (PathKind::Native, &path[\"native=\".len()..])\n         } else if path.starts_with(\"crate=\") {"}, {"sha": "f259698a220e2be8022a92de7bc1fae45b0b3be7", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -48,7 +48,7 @@\n use serialize::json::Json;\n use std::default::Default;\n use std::io::prelude::*;\n-use syntax::{diagnostic, abi};\n+use syntax::abi;\n \n mod android_base;\n mod apple_base;\n@@ -263,17 +263,13 @@ impl Target {\n     pub fn from_json(obj: Json) -> Target {\n         // this is 1. ugly, 2. error prone.\n \n-\n-        let handler = diagnostic::Handler::new(diagnostic::Auto, None, true);\n-\n         let get_req_field = |name: &str| {\n             match obj.find(name)\n                      .map(|s| s.as_string())\n                      .and_then(|os| os.map(|s| s.to_string())) {\n                 Some(val) => val,\n                 None => {\n-                    panic!(handler.fatal(&format!(\"Field {} in target specification is required\",\n-                                                  name)))\n+                    panic!(\"Field {} in target specification is required\", name)\n                 }\n             }\n         };"}, {"sha": "8cfaec62f47754cacf5cc2eea895ca647b68f125", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -59,8 +59,6 @@ extern crate log;\n extern crate syntax;\n extern crate syntax_ext;\n \n-pub use syntax::diagnostic;\n-\n use driver::CompileController;\n use pretty::{PpMode, UserIdentifiedItem};\n \n@@ -91,7 +89,8 @@ use rustc::session::early_error;\n \n use syntax::ast;\n use syntax::parse;\n-use syntax::diagnostic::Emitter;\n+use syntax::errors;\n+use syntax::errors::emitter::Emitter;\n use syntax::diagnostics;\n use syntax::parse::token;\n \n@@ -239,7 +238,7 @@ pub trait CompilerCalls<'a> {\n     fn early_callback(&mut self,\n                       _: &getopts::Matches,\n                       _: &diagnostics::registry::Registry,\n-                      _: diagnostic::ColorConfig)\n+                      _: errors::ColorConfig)\n                       -> Compilation {\n         Compilation::Continue\n     }\n@@ -315,7 +314,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn early_callback(&mut self,\n                       matches: &getopts::Matches,\n                       descriptions: &diagnostics::registry::Registry,\n-                      color: diagnostic::ColorConfig)\n+                      color: errors::ColorConfig)\n                       -> Compilation {\n         match matches.opt_str(\"explain\") {\n             Some(ref code) => {\n@@ -774,7 +773,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n                             &opt.opt_group.short_name\n                         };\n                         if m.opt_present(opt_name) {\n-                            early_error(diagnostic::Auto,\n+                            early_error(errors::ColorConfig::Auto,\n                                         &format!(\"use of unstable option '{}' requires -Z \\\n                                                   unstable-options\",\n                                                  opt_name));\n@@ -783,7 +782,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n                 }\n                 m\n             }\n-            Err(f) => early_error(diagnostic::Auto, &f.to_string()),\n+            Err(f) => early_error(errors::ColorConfig::Auto, &f.to_string()),\n         }\n     }\n \n@@ -895,25 +894,25 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n         }\n         Err(value) => {\n             // Thread panicked without emitting a fatal diagnostic\n-            if !value.is::<diagnostic::FatalError>() {\n-                let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n+            if !value.is::<errors::FatalError>() {\n+                let mut emitter = errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n \n                 // a .span_bug or .bug call has already printed what\n                 // it wants to print.\n-                if !value.is::<diagnostic::ExplicitBug>() {\n-                    emitter.emit(None, \"unexpected panic\", None, diagnostic::Bug);\n+                if !value.is::<errors::ExplicitBug>() {\n+                    emitter.emit(None, \"unexpected panic\", None, errors::Level::Bug);\n                 }\n \n                 let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n                           format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n                 for note in &xs {\n-                    emitter.emit(None, &note[..], None, diagnostic::Note)\n+                    emitter.emit(None, &note[..], None, errors::Level::Note)\n                 }\n                 if let None = env::var_os(\"RUST_BACKTRACE\") {\n                     emitter.emit(None,\n                                  \"run with `RUST_BACKTRACE=1` for a backtrace\",\n                                  None,\n-                                 diagnostic::Note);\n+                                 errors::Level::Note);\n                 }\n \n                 println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());"}, {"sha": "df9294a9d5bfb518cbcab55efb94e6b909154294", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -10,8 +10,6 @@\n \n //! # Standalone Tests for the Inference Module\n \n-use diagnostic;\n-use diagnostic::Emitter;\n use driver;\n use rustc_lint;\n use rustc_resolve as resolve;\n@@ -34,9 +32,10 @@ use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n use std::rc::Rc;\n use syntax::{abi, ast};\n-use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n-use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, Help};\n+use syntax::errors;\n+use syntax::errors::emitter::Emitter;\n+use syntax::errors::{Level, RenderSpan};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n \n@@ -60,8 +59,8 @@ struct ExpectErrorEmitter {\n \n fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n     match lvl {\n-        Bug | Fatal | Error => {}\n-        Warning | Note | Help => {\n+        Level::Bug | Level::Fatal | Level::Error => {}\n+        Level::Warning | Level::Note | Level::Help => {\n             return;\n         }\n     }\n@@ -79,14 +78,14 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n \n impl Emitter for ExpectErrorEmitter {\n     fn emit(&mut self,\n-            _cmsp: Option<(&codemap::CodeMap, Span)>,\n+            _sp: Option<Span>,\n             msg: &str,\n             _: Option<&str>,\n             lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n \n-    fn custom_emit(&mut self, _cm: &codemap::CodeMap, _sp: RenderSpan, msg: &str, lvl: Level) {\n+    fn custom_emit(&mut self, _sp: RenderSpan, msg: &str, lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n }\n@@ -105,13 +104,11 @@ fn test_env<F>(source_string: &str,\n     let mut options = config::basic_options();\n     options.debugging_opts.verbose = true;\n     options.unstable_features = UnstableFeatures::Allow;\n-    let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::with_emitter(true, emitter);\n-    let span_diagnostic_handler = diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-    let sess = session::build_session_(options, None, span_diagnostic_handler,\n-                                       cstore.clone());\n+    let sess = session::build_session_(options, None, diagnostic_handler,\n+                                       Rc::new(CodeMap::new()), cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let krate_config = Vec::new();\n     let input = config::Input::Str(source_string.to_string());\n@@ -366,13 +363,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         self.infcx.glb(true, trace)\n     }\n \n-    pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n-        match self.lub().relate(&t1, &t2) {\n-            Ok(t) => t,\n-            Err(ref e) => panic!(\"unexpected error computing LUB: {}\", e),\n-        }\n-    }\n-\n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {"}, {"sha": "13ddd9ca55ce4b359ca522b43989b54b3abc7ed4", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -14,7 +14,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n-use syntax::diagnostic;\n+use syntax::errors;\n use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::parse;\n@@ -121,7 +121,7 @@ pub const default_columns: usize = 78;\n /// it can scan the input text for comments and literals to\n /// copy forward.\n pub fn print_crate<'a>(cm: &'a CodeMap,\n-                       span_diagnostic: &diagnostic::SpanHandler,\n+                       span_diagnostic: &errors::Handler,\n                        krate: &hir::Crate,\n                        filename: String,\n                        input: &mut Read,\n@@ -142,7 +142,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n-                          span_diagnostic: &diagnostic::SpanHandler,\n+                          span_diagnostic: &errors::Handler,\n                           filename: String,\n                           input: &mut Read,\n                           out: Box<Write + 'a>,"}, {"sha": "cd70172e8fa2112500da97662a9d337d2cd87451", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -44,7 +44,7 @@ use syntax::abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n use syntax::parse::token::special_idents;\n use syntax;\n use rbml::writer::Encoder;\n@@ -57,7 +57,7 @@ pub type EncodeInlinedItem<'a> =\n     Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n \n pub struct EncodeParams<'a, 'tcx: 'a> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n@@ -69,7 +69,7 @@ pub struct EncodeParams<'a, 'tcx: 'a> {\n }\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n@@ -275,8 +275,7 @@ fn encode_symbol(ecx: &EncodeContext,\n             rbml_w.wr_tagged_str(tag_items_data_item_symbol, x);\n         }\n         None => {\n-            ecx.diag.handler().bug(\n-                &format!(\"encode_symbol: id not found {}\", id));\n+            ecx.diag.bug(&format!(\"encode_symbol: id not found {}\", id));\n         }\n     }\n }"}, {"sha": "81788e08c7ef2085135b3c90c59f2207cc8ff5d5", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -226,7 +226,7 @@ use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n use rustc_llvm::archive_ro::ArchiveRO;\n use syntax::codemap::Span;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n use rustc_back::target::Target;\n \n use std::cmp;\n@@ -697,8 +697,8 @@ impl<'a> Context<'a> {\n     }\n }\n \n-pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(&format!(\"crate name: {}\", name));\n+pub fn note_crate_name(diag: &Handler, name: &str) {\n+    diag.note(&format!(\"crate name: {}\", name));\n }\n \n impl ArchiveMetadata {"}, {"sha": "0119f1d5cc109bc0343148da32c62f4036b464a5", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -29,14 +29,14 @@ use rustc_front::hir;\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n \n use rbml::writer::{self, Encoder};\n \n macro_rules! mywrite { ($w:expr, $($arg:tt)*) => ({ write!($w.writer, $($arg)*); }) }\n \n pub struct ctxt<'a, 'tcx: 'a> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     // Def -> str Callback:\n     pub ds: fn(DefId) -> String,\n     // The type context.\n@@ -136,7 +136,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             enc_bare_fn_ty(w, cx, f);\n         }\n         ty::TyInfer(_) => {\n-            cx.diag.handler().bug(\"cannot encode inference variable types\");\n+            cx.diag.bug(\"cannot encode inference variable types\");\n         }\n         ty::TyParam(ParamTy {space, idx, name}) => {\n             mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name)\n@@ -279,7 +279,7 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n         }\n         ty::ReVar(_) | ty::ReSkolemized(..) => {\n             // these should not crop up after typeck\n-            cx.diag.handler().bug(\"cannot encode region variables\");\n+            cx.diag.bug(\"cannot encode region variables\");\n         }\n     }\n }"}, {"sha": "476425a75c22df73bb61953d0bf6cb2a124130bf", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -13,7 +13,7 @@\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::diagnostic;\n+use syntax::errors;\n use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n \n@@ -33,7 +33,7 @@ impl<'v> Visitor<'v> for RegistrarFinder {\n }\n \n /// Find the function marked with `#[plugin_registrar]`, if any.\n-pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n+pub fn find_plugin_registrar(diagnostic: &errors::Handler,\n                              krate: &hir::Crate)\n                              -> Option<ast::NodeId> {\n     let mut finder = RegistrarFinder { registrars: Vec::new() };\n@@ -46,11 +46,11 @@ pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n             Some(node_id)\n         },\n         _ => {\n-            diagnostic.handler().err(\"multiple plugin registration functions found\");\n+            diagnostic.err(\"multiple plugin registration functions found\");\n             for &(_, span) in &finder.registrars {\n                 diagnostic.span_note(span, \"one is here\");\n             }\n-            diagnostic.handler().abort_if_errors();\n+            diagnostic.abort_if_errors();\n             unreachable!();\n         }\n     }"}, {"sha": "8505c3968ee15ea761187821777340880c96416d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -101,7 +101,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n-                    write::llvm_err(sess.diagnostic().handler(),\n+                    write::llvm_err(sess.diagnostic(),\n                                     format!(\"failed to load bc of `{}`\",\n                                             &name[..]));\n                 }"}, {"sha": "dc20b99f9a6bb1159ed1c710926503f34bf60fcd", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -20,8 +20,8 @@ use trans::{CrateTranslation, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n use syntax::codemap;\n-use syntax::diagnostic;\n-use syntax::diagnostic::{Emitter, Handler, Level};\n+use syntax::errors::{self, Handler, Level};\n+use syntax::errors::emitter::Emitter;\n \n use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n@@ -34,7 +34,7 @@ use std::sync::mpsc::channel;\n use std::thread;\n use libc::{self, c_uint, c_int, c_void};\n \n-pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n+pub fn llvm_err(handler: &errors::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n@@ -49,7 +49,7 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n }\n \n pub fn write_output_file(\n-        handler: &diagnostic::Handler,\n+        handler: &errors::Handler,\n         target: llvm::TargetMachineRef,\n         pm: llvm::PassManagerRef,\n         m: ModuleRef,\n@@ -109,9 +109,9 @@ impl SharedEmitter {\n }\n \n impl Emitter for SharedEmitter {\n-    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, codemap::Span)>,\n+    fn emit(&mut self, sp: Option<codemap::Span>,\n             msg: &str, code: Option<&str>, lvl: Level) {\n-        assert!(cmsp.is_none(), \"SharedEmitter doesn't support spans\");\n+        assert!(sp.is_none(), \"SharedEmitter doesn't support spans\");\n \n         self.buffer.lock().unwrap().push(Diagnostic {\n             msg: msg.to_string(),\n@@ -120,8 +120,7 @@ impl Emitter for SharedEmitter {\n         });\n     }\n \n-    fn custom_emit(&mut self, _cm: &codemap::CodeMap,\n-                   _sp: diagnostic::RenderSpan, _msg: &str, _lvl: Level) {\n+    fn custom_emit(&mut self, _sp: errors::RenderSpan, _msg: &str, _lvl: Level) {\n         panic!(\"SharedEmitter doesn't support custom_emit\");\n     }\n }\n@@ -226,7 +225,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     };\n \n     if tm.is_null() {\n-        llvm_err(sess.diagnostic().handler(),\n+        llvm_err(sess.diagnostic(),\n                  format!(\"Could not create LLVM TargetMachine for triple: {}\",\n                          triple).to_string());\n     } else {\n@@ -333,7 +332,7 @@ impl<'a> CodegenContext<'a> {\n     fn new_with_session(sess: &'a Session, reachable: &'a [String]) -> CodegenContext<'a> {\n         CodegenContext {\n             lto_ctxt: Some((sess, reachable)),\n-            handler: sess.diagnostic().handler(),\n+            handler: sess.diagnostic(),\n             plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n             remark: sess.opts.cg.remark.clone(),\n             worker: 0,\n@@ -863,7 +862,7 @@ fn run_work_multithreaded(sess: &Session,\n         futures.push(rx);\n \n         thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move || {\n-            let diag_handler = Handler::with_emitter(true, box diag_emitter);\n+            let diag_handler = Handler::with_emitter(true, false, box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n             // fields.\n@@ -903,7 +902,7 @@ fn run_work_multithreaded(sess: &Session,\n             },\n         }\n         // Display any new diagnostics.\n-        diag_emitter.dump(sess.diagnostic().handler());\n+        diag_emitter.dump(sess.diagnostic());\n     }\n     if panicked {\n         sess.fatal(\"aborting due to worker thread panic\");"}, {"sha": "d33beab9313d0f16e2fa4292d08f7c654b5b6ec2", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -20,7 +20,6 @@ pub use self::CallArgs::*;\n \n use arena::TypedArena;\n use back::link;\n-use session;\n use llvm::{self, ValueRef, get_params};\n use middle::cstore::LOCAL_CRATE;\n use middle::def;\n@@ -57,6 +56,7 @@ use rustc_front::hir;\n \n use syntax::abi as synabi;\n use syntax::ast;\n+use syntax::errors;\n use syntax::ptr::P;\n \n #[derive(Copy, Clone)]\n@@ -412,8 +412,8 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             Some(n) => n,\n             None => { return false; }\n         };\n-        let map_node = session::expect(\n-            &tcx.sess,\n+        let map_node = errors::expect(\n+            &tcx.sess.diagnostic(),\n             tcx.map.find(node_id),\n             || \"local item should be in ast map\".to_string());\n "}, {"sha": "4b6a0d1a5096541cd77ba4349c0db612c417bc91", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use back::link::exported_name;\n-use session;\n use llvm::ValueRef;\n use llvm;\n use middle::def_id::DefId;\n@@ -32,6 +31,7 @@ use rustc_front::hir;\n use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n+use syntax::errors;\n use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -83,8 +83,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            hash_id);\n \n \n-    let map_node = session::expect(\n-        ccx.sess(),\n+    let map_node = errors::expect(\n+        ccx.sess().diagnostic(),\n         ccx.tcx().map.find(fn_node_id),\n         || {\n             format!(\"while monomorphizing {:?}, couldn't find it in \\"}, {"sha": "c6c98851f7c34af366a5b04575e980f171cf5836", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -22,7 +22,8 @@ use rustc_resolve as resolve;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_metadata::cstore::CStore;\n \n-use syntax::{ast, codemap, diagnostic};\n+use syntax::{ast, codemap, errors};\n+use syntax::errors::emitter::ColorConfig;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::parse::token;\n \n@@ -116,15 +117,16 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = codemap::CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::new(diagnostic::Auto, None, true);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let codemap = Rc::new(codemap::CodeMap::new());\n+    let diagnostic_handler = errors::Handler::new(ColorConfig::Auto,\n+                                                  None,\n+                                                  true,\n+                                                  false,\n+                                                  codemap.clone());\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n     let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n-    let sess = session::build_session_(sessopts, cpath,\n-                                       span_diagnostic_handler, cstore_);\n+    let sess = session::build_session_(sessopts, cpath, diagnostic_handler, codemap, cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);"}, {"sha": "31fdc1170c0261f54dc285cba4ff162f0d27eb58", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -65,7 +65,7 @@ use externalfiles::ExternalHtml;\n use serialize::Decodable;\n use serialize::json::{self, Json};\n use rustc::session::search_paths::SearchPaths;\n-use syntax::diagnostic;\n+use syntax::errors::emitter::ColorConfig;\n \n // reexported from `clean` so it can be easily updated with the mod itself\n pub use clean::SCHEMA_VERSION;\n@@ -228,7 +228,7 @@ pub fn main_args(args: &[String]) -> isize {\n \n     let mut libs = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        libs.add_path(s, diagnostic::Auto);\n+        libs.add_path(s, ColorConfig::Auto);\n     }\n     let externs = match parse_externs(&matches) {\n         Ok(ex) => ex,\n@@ -363,7 +363,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // First, parse the crate and extract all relevant information.\n     let mut paths = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        paths.add_path(s, diagnostic::Auto);\n+        paths.add_path(s, ColorConfig::Auto);\n     }\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");"}, {"sha": "fde8299d2d2e6f5a37a851df388ab52380e93c12", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -34,7 +34,8 @@ use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n use rustc_metadata::cstore::CStore;\n use syntax::codemap::CodeMap;\n-use syntax::diagnostic;\n+use syntax::errors;\n+use syntax::errors::emitter::ColorConfig;\n use syntax::parse::token;\n \n use core;\n@@ -71,16 +72,19 @@ pub fn run(input: &str,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::new(diagnostic::Auto, None, true);\n-    let span_diagnostic_handler =\n-    diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let codemap = Rc::new(CodeMap::new());\n+    let diagnostic_handler = errors::Handler::new(ColorConfig::Auto,\n+                                                  None,\n+                                                  true,\n+                                                  false,\n+                                                  codemap.clone());\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n     let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n                                        Some(input_path.clone()),\n-                                       span_diagnostic_handler,\n+                                       diagnostic_handler,\n+                                       codemap,\n                                        cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n@@ -220,21 +224,22 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         }\n     }\n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let emitter = diagnostic::EmitterWriter::new(box Sink(data.clone()), None);\n+    let codemap = Rc::new(CodeMap::new());\n+    let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n+                                                      None,\n+                                                      codemap.clone());\n     let old = io::set_panic(box Sink(data.clone()));\n     let _bomb = Bomb(data, old.unwrap_or(box io::stdout()));\n \n     // Compile the code\n-    let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::with_emitter(true, box emitter);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n     let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n                                        None,\n-                                       span_diagnostic_handler,\n+                                       diagnostic_handler,\n+                                       codemap,\n                                        cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n "}, {"sha": "26662605ba87fb68abab4d729ac722f7d669c3a9", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -21,7 +21,7 @@ use ast::{Expr, Item, Local, Decl};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use config::CfgDiag;\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use feature_gate::{GatedCfg, GatedCfgAttr};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n@@ -299,14 +299,14 @@ pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n }\n \n /// Find the value of #[export_name=*] attribute and check its validity.\n-pub fn find_export_name_attr(diag: &SpanHandler, attrs: &[Attribute]) -> Option<InternedString> {\n+pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<InternedString> {\n     attrs.iter().fold(None, |ia,attr| {\n         if attr.check_name(\"export_name\") {\n             if let s@Some(_) = attr.value_str() {\n                 s\n             } else {\n                 diag.span_err(attr.span, \"export_name attribute has invalid format\");\n-                diag.handler.help(\"use #[export_name=\\\"*\\\"]\");\n+                diag.help(\"use #[export_name=\\\"*\\\"]\");\n                 None\n             }\n         } else {\n@@ -324,7 +324,7 @@ pub enum InlineAttr {\n }\n \n /// Determine what `#[inline]` attribute is present in `attrs`, if any.\n-pub fn find_inline_attr(diagnostic: Option<&SpanHandler>, attrs: &[Attribute]) -> InlineAttr {\n+pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n     attrs.iter().fold(InlineAttr::None, |ia,attr| {\n         match attr.node.value.node {\n             MetaWord(ref n) if *n == \"inline\" => {\n@@ -426,7 +426,7 @@ impl StabilityLevel {\n     pub fn is_stable(&self) -> bool { if let Stable {..} = *self { true } else { false }}\n }\n \n-fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n+fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                  attrs_iter: I,\n                                  item_sp: Span)\n                                  -> Option<Stability>\n@@ -612,10 +612,10 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n     stab\n }\n \n-fn find_deprecation_generic<'a, I>(diagnostic: &SpanHandler,\n-                                 attrs_iter: I,\n-                                 item_sp: Span)\n-                                 -> Option<Deprecation>\n+fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n+                                   attrs_iter: I,\n+                                   item_sp: Span)\n+                                   -> Option<Deprecation>\n     where I: Iterator<Item = &'a Attribute>\n {\n     let mut depr: Option<Deprecation> = None;\n@@ -672,18 +672,18 @@ fn find_deprecation_generic<'a, I>(diagnostic: &SpanHandler,\n }\n \n /// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n+pub fn find_stability(diagnostic: &Handler, attrs: &[Attribute],\n                       item_sp: Span) -> Option<Stability> {\n     find_stability_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n /// Find the deprecation attribute. `None` if none exists.\n-pub fn find_deprecation(diagnostic: &SpanHandler, attrs: &[Attribute],\n-                      item_sp: Span) -> Option<Deprecation> {\n+pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n+                        item_sp: Span) -> Option<Deprecation> {\n     find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n-pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n+pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n     let mut set = HashSet::new();\n     for meta in metas {\n         let name = meta.name();\n@@ -702,7 +702,7 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n /// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n /// the same discriminant size that the corresponding C enum would or C\n /// structure layout, and `packed` to remove padding.\n-pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAttr> {\n+pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n     match attr.node.value.node {\n         ast::MetaList(ref s, ref items) if *s == \"repr\" => {"}, {"sha": "64b16538f05a14e0877ef28899475964ceba9b80", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use attr::AttrMetaMethods;\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use feature_gate::GatedCfgAttr;\n use fold::Folder;\n use {ast, fold, attr};\n@@ -23,12 +23,12 @@ use util::small_vector::SmallVector;\n /// configuration.\n struct Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n     in_cfg: F,\n-    diagnostic: &'a SpanHandler,\n+    diagnostic: &'a Handler,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate,\n+pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n                                 feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n                                 -> ast::Crate\n {\n@@ -83,7 +83,7 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n     }\n }\n \n-pub fn strip_items<'a, F>(diagnostic: &'a SpanHandler,\n+pub fn strip_items<'a, F>(diagnostic: &'a Handler,\n                           krate: ast::Crate, in_cfg: F) -> ast::Crate where\n     F: FnMut(&[ast::Attribute]) -> bool,\n {\n@@ -291,7 +291,7 @@ struct CfgAttrFolder<'a, T> {\n }\n \n // Process `#[cfg_attr]`.\n-fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate,\n+fn process_cfg_attr(diagnostic: &Handler, krate: ast::Crate,\n                     feature_gated_cfgs: &mut Vec<GatedCfgAttr>) -> ast::Crate {\n     let mut fld = CfgAttrFolder {\n         diag: CfgDiagReal {\n@@ -463,17 +463,17 @@ impl<'v, 'a, 'b> visit::Visitor<'v> for StmtExprAttrFeatureVisitor<'a, 'b> {\n }\n \n pub trait CfgDiag {\n-    fn emit_error<F>(&mut self, f: F) where F: FnMut(&SpanHandler);\n+    fn emit_error<F>(&mut self, f: F) where F: FnMut(&Handler);\n     fn flag_gated<F>(&mut self, f: F) where F: FnMut(&mut Vec<GatedCfgAttr>);\n }\n \n pub struct CfgDiagReal<'a, 'b> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     pub feature_gated_cfgs: &'b mut Vec<GatedCfgAttr>,\n }\n \n impl<'a, 'b> CfgDiag for CfgDiagReal<'a, 'b> {\n-    fn emit_error<F>(&mut self, mut f: F) where F: FnMut(&SpanHandler) {\n+    fn emit_error<F>(&mut self, mut f: F) where F: FnMut(&Handler) {\n         f(self.diag)\n     }\n     fn flag_gated<F>(&mut self, mut f: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {\n@@ -486,7 +486,7 @@ struct CfgDiagSilent {\n }\n \n impl CfgDiag for CfgDiagSilent {\n-    fn emit_error<F>(&mut self, _: F) where F: FnMut(&SpanHandler) {\n+    fn emit_error<F>(&mut self, _: F) where F: FnMut(&Handler) {\n         self.error = true;\n     }\n     fn flag_gated<F>(&mut self, _: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {}"}, {"sha": "7fef85a833e251224f3456ed46da1a11a8d270b4", "filename": "src/libsyntax/errors/emitter.rs", "status": "renamed", "additions": 229, "deletions": 449, "changes": 678, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,423 +8,156 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::Level::*;\n-pub use self::RenderSpan::*;\n-pub use self::ColorConfig::*;\n use self::Destination::*;\n \n use codemap::{self, COMMAND_LINE_SP, COMMAND_LINE_EXPN, Pos, Span};\n use diagnostics;\n \n-use std::cell::{RefCell, Cell};\n-use std::{cmp, error, fmt};\n+use errors::{Level, RenderSpan};\n+use errors::RenderSpan::*;\n+use errors::Level::*;\n+\n+use std::{cmp, fmt};\n use std::io::prelude::*;\n use std::io;\n+use std::rc::Rc;\n use term;\n \n-/// maximum number of lines we will print for each error; arbitrary.\n-const MAX_LINES: usize = 6;\n \n-#[derive(Clone)]\n-pub enum RenderSpan {\n-    /// A FullSpan renders with both with an initial line for the\n-    /// message, prefixed by file:linenum, followed by a summary of\n-    /// the source code covered by the span.\n-    FullSpan(Span),\n-\n-    /// Similar to a FullSpan, but the cited position is the end of\n-    /// the span, instead of the start. Used, at least, for telling\n-    /// compiletest/runtest to look at the last line of the span\n-    /// (since `end_highlight_lines` displays an arrow to the end\n-    /// of the span).\n-    EndSpan(Span),\n-\n-    /// A suggestion renders with both with an initial line for the\n-    /// message, prefixed by file:linenum, followed by a summary\n-    /// of hypothetical source code, where the `String` is spliced\n-    /// into the lines in place of the code covered by the span.\n-    Suggestion(Span, String),\n-\n-    /// A FileLine renders with just a line for the message prefixed\n-    /// by file:linenum.\n-    FileLine(Span),\n+pub trait Emitter {\n+    fn emit(&mut self, span: Option<Span>, msg: &str, code: Option<&str>, lvl: Level);\n+    fn custom_emit(&mut self, sp: RenderSpan, msg: &str, lvl: Level);\n }\n \n-impl RenderSpan {\n-    fn span(&self) -> Span {\n-        match *self {\n-            FullSpan(s) |\n-            Suggestion(s, _) |\n-            EndSpan(s) |\n-            FileLine(s) =>\n-                s\n-        }\n-    }\n-}\n+/// maximum number of lines we will print for each error; arbitrary.\n+const MAX_LINES: usize = 6;\n \n #[derive(Clone, Copy)]\n pub enum ColorConfig {\n     Auto,\n     Always,\n-    Never\n+    Never,\n }\n \n-pub trait Emitter {\n-    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str, code: Option<&str>, lvl: Level);\n-    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n-                   sp: RenderSpan, msg: &str, lvl: Level);\n-}\n-\n-/// Used as a return value to signify a fatal error occurred. (It is also\n-/// used as the argument to panic at the moment, but that will eventually\n-/// not be true.)\n-#[derive(Copy, Clone, Debug)]\n-#[must_use]\n-pub struct FatalError;\n-\n-impl fmt::Display for FatalError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(f, \"parser fatal error\")\n+impl ColorConfig {\n+    fn use_color(&self) -> bool {\n+        match *self {\n+            ColorConfig::Always => true,\n+            ColorConfig::Never  => false,\n+            ColorConfig::Auto   => stderr_isatty(),\n+        }\n     }\n }\n \n-impl error::Error for FatalError {\n-    fn description(&self) -> &str {\n-        \"The parser has encountered a fatal error\"\n-    }\n+// A basic emitter for when we don't have access to a codemap or registry. Used\n+// for reporting very early errors, etc.\n+pub struct BasicEmitter {\n+    dst: Destination,\n }\n \n-/// Signifies that the compiler died with an explicit call to `.bug`\n-/// or `.span_bug` rather than a failed assertion, etc.\n-#[derive(Copy, Clone, Debug)]\n-pub struct ExplicitBug;\n-\n-impl fmt::Display for ExplicitBug {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(f, \"parser internal bug\")\n-    }\n-}\n+impl Emitter for BasicEmitter {\n+    fn emit(&mut self,\n+            sp: Option<Span>,\n+            msg: &str,\n+            code: Option<&str>,\n+            lvl: Level) {\n+        assert!(sp.is_none(), \"BasicEmitter can't handle spans\");\n+        if let Err(e) = print_diagnostic(&mut self.dst, \"\", lvl, msg, code) {\n+            panic!(\"failed to print diagnostics: {:?}\", e);\n+        }\n \n-impl error::Error for ExplicitBug {\n-    fn description(&self) -> &str {\n-        \"The parser has encountered an internal bug\"\n     }\n-}\n \n-/// A span-handler is like a handler but also\n-/// accepts span information for source-location\n-/// reporting.\n-pub struct SpanHandler {\n-    pub handler: Handler,\n-    pub cm: codemap::CodeMap,\n-}\n-\n-impl SpanHandler {\n-    pub fn new(handler: Handler, cm: codemap::CodeMap) -> SpanHandler {\n-        SpanHandler {\n-            handler: handler,\n-            cm: cm,\n-        }\n+    fn custom_emit(&mut self, _: RenderSpan, _: &str, _: Level) {\n+        panic!(\"BasicEmitter can't handle custom_emit\");\n     }\n-    pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Fatal);\n-        return FatalError;\n-    }\n-    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> FatalError {\n-        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Fatal);\n-        return FatalError;\n-    }\n-    pub fn span_err(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Error);\n-        self.handler.bump_err_count();\n-    }\n-    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Error);\n-        self.handler.bump_err_count();\n-    }\n-    pub fn span_warn(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Warning);\n-    }\n-    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Warning);\n-    }\n-    pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Note);\n-    }\n-    pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, EndSpan(sp), msg, Note);\n-    }\n-    pub fn span_help(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Help);\n-    }\n-    /// Prints out a message with a suggested edit of the code.\n-    ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n-    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n-        self.handler.custom_emit(&self.cm, Suggestion(sp, suggestion), msg, Help);\n-    }\n-    pub fn fileline_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, FileLine(sp), msg, Note);\n-    }\n-    pub fn fileline_help(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, FileLine(sp), msg, Help);\n-    }\n-    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n-        panic!(ExplicitBug);\n-    }\n-    pub fn span_bug_no_panic(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n-        self.handler.bump_err_count();\n-    }\n-    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n-    }\n-    pub fn handler<'a>(&'a self) -> &'a Handler {\n-        &self.handler\n-    }\n-}\n-\n-/// A handler deals with errors; certain errors\n-/// (fatal, bug, unimpl) may cause immediate exit,\n-/// others log errors for later reporting.\n-pub struct Handler {\n-    err_count: Cell<usize>,\n-    emit: RefCell<Box<Emitter + Send>>,\n-    pub can_emit_warnings: bool\n }\n \n-impl Handler {\n-    pub fn new(color_config: ColorConfig,\n-               registry: Option<diagnostics::registry::Registry>,\n-               can_emit_warnings: bool) -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, registry));\n-        Handler::with_emitter(can_emit_warnings, emitter)\n-    }\n-    pub fn with_emitter(can_emit_warnings: bool, e: Box<Emitter + Send>) -> Handler {\n-        Handler {\n-            err_count: Cell::new(0),\n-            emit: RefCell::new(e),\n-            can_emit_warnings: can_emit_warnings\n-        }\n-    }\n-    pub fn fatal(&self, msg: &str) -> FatalError {\n-        self.emit.borrow_mut().emit(None, msg, None, Fatal);\n-        FatalError\n-    }\n-    pub fn err(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Error);\n-        self.bump_err_count();\n-    }\n-    pub fn bump_err_count(&self) {\n-        self.err_count.set(self.err_count.get() + 1);\n-    }\n-    pub fn err_count(&self) -> usize {\n-        self.err_count.get()\n-    }\n-    pub fn has_errors(&self) -> bool {\n-        self.err_count.get() > 0\n-    }\n-    pub fn abort_if_errors(&self) {\n-        let s;\n-        match self.err_count.get() {\n-            0 => return,\n-            1 => s = \"aborting due to previous error\".to_string(),\n-            _  => {\n-                s = format!(\"aborting due to {} previous errors\",\n-                            self.err_count.get());\n-            }\n+impl BasicEmitter {\n+    pub fn stderr(color_config: ColorConfig) -> BasicEmitter {\n+        if color_config.use_color() {\n+            let dst = Destination::from_stderr();\n+            BasicEmitter { dst: dst }\n+        } else {\n+            BasicEmitter { dst: Raw(Box::new(io::stderr())) }\n         }\n-\n-        panic!(self.fatal(&s[..]));\n-    }\n-    pub fn warn(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Warning);\n-    }\n-    pub fn note(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Note);\n-    }\n-    pub fn help(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Help);\n-    }\n-    pub fn bug(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().emit(None, msg, None, Bug);\n-        panic!(ExplicitBug);\n-    }\n-    pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(&format!(\"unimplemented {}\", msg));\n-    }\n-    pub fn emit(&self,\n-                cmsp: Option<(&codemap::CodeMap, Span)>,\n-                msg: &str,\n-                lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(cmsp, msg, None, lvl);\n-    }\n-    pub fn emit_with_code(&self,\n-                          cmsp: Option<(&codemap::CodeMap, Span)>,\n-                          msg: &str,\n-                          code: &str,\n-                          lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(cmsp, msg, Some(code), lvl);\n-    }\n-    pub fn custom_emit(&self, cm: &codemap::CodeMap,\n-                       sp: RenderSpan, msg: &str, lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().custom_emit(cm, sp, msg, lvl);\n     }\n }\n \n-#[derive(Copy, PartialEq, Clone, Debug)]\n-pub enum Level {\n-    Bug,\n-    Fatal,\n-    Error,\n-    Warning,\n-    Note,\n-    Help,\n+pub struct EmitterWriter {\n+    dst: Destination,\n+    registry: Option<diagnostics::registry::Registry>,\n+    cm: Rc<codemap::CodeMap>,\n }\n \n-impl fmt::Display for Level {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        use std::fmt::Display;\n+impl Emitter for EmitterWriter {\n+    fn emit(&mut self,\n+            sp: Option<Span>,\n+            msg: &str,\n+            code: Option<&str>,\n+            lvl: Level) {\n+        let error = match sp {\n+            Some(COMMAND_LINE_SP) => self.emit_(FileLine(COMMAND_LINE_SP), msg, code, lvl),\n+            Some(sp) => self.emit_(FullSpan(sp), msg, code, lvl),\n+            None => print_diagnostic(&mut self.dst, \"\", lvl, msg, code),\n+        };\n \n-        match *self {\n-            Bug => \"error: internal compiler error\".fmt(f),\n-            Fatal | Error => \"error\".fmt(f),\n-            Warning => \"warning\".fmt(f),\n-            Note => \"note\".fmt(f),\n-            Help => \"help\".fmt(f),\n+        if let Err(e) = error {\n+            panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n     }\n-}\n \n-impl Level {\n-    fn color(self) -> term::color::Color {\n-        match self {\n-            Bug | Fatal | Error => term::color::BRIGHT_RED,\n-            Warning => term::color::BRIGHT_YELLOW,\n-            Note => term::color::BRIGHT_GREEN,\n-            Help => term::color::BRIGHT_CYAN,\n+    fn custom_emit(&mut self,\n+                   sp: RenderSpan,\n+                   msg: &str,\n+                   lvl: Level) {\n+        match self.emit_(sp, msg, None, lvl) {\n+            Ok(()) => {}\n+            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n         }\n     }\n }\n \n-pub struct EmitterWriter {\n-    dst: Destination,\n-    registry: Option<diagnostics::registry::Registry>\n-}\n-\n-enum Destination {\n-    Terminal(Box<term::StderrTerminal>),\n-    Raw(Box<Write + Send>),\n-}\n-\n /// Do not use this for messages that end in `\\n` \u2013 use `println_maybe_styled` instead. See\n /// `EmitterWriter::print_maybe_styled` for details.\n macro_rules! print_maybe_styled {\n-    ($writer: expr, $style: expr, $($arg: tt)*) => {\n-        $writer.print_maybe_styled(format_args!($($arg)*), $style, false)\n+    ($dst: expr, $style: expr, $($arg: tt)*) => {\n+        $dst.print_maybe_styled(format_args!($($arg)*), $style, false)\n     }\n }\n \n macro_rules! println_maybe_styled {\n-    ($writer: expr, $style: expr, $($arg: tt)*) => {\n-        $writer.print_maybe_styled(format_args!($($arg)*), $style, true)\n+    ($dst: expr, $style: expr, $($arg: tt)*) => {\n+        $dst.print_maybe_styled(format_args!($($arg)*), $style, true)\n     }\n }\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n-                  registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n-        let stderr = io::stderr();\n-\n-        let use_color = match color_config {\n-            Always => true,\n-            Never  => false,\n-            Auto   => stderr_isatty(),\n-        };\n-\n-        if use_color {\n-            let dst = match term::stderr() {\n-                Some(t) => Terminal(t),\n-                None    => Raw(Box::new(stderr)),\n-            };\n-            EmitterWriter { dst: dst, registry: registry }\n+                  registry: Option<diagnostics::registry::Registry>,\n+                  code_map: Rc<codemap::CodeMap>)\n+                  -> EmitterWriter {\n+        if color_config.use_color() {\n+            let dst = Destination::from_stderr();\n+            EmitterWriter { dst: dst, registry: registry, cm: code_map }\n         } else {\n-            EmitterWriter { dst: Raw(Box::new(stderr)), registry: registry }\n+            EmitterWriter { dst: Raw(Box::new(io::stderr())), registry: registry, cm: code_map }\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n-               registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n-        EmitterWriter { dst: Raw(dst), registry: registry }\n-    }\n-\n-    fn print_maybe_styled(&mut self,\n-                          args: fmt::Arguments,\n-                          color: term::Attr,\n-                          print_newline_at_end: bool) -> io::Result<()> {\n-        match self.dst {\n-            Terminal(ref mut t) => {\n-                try!(t.attr(color));\n-                // If `msg` ends in a newline, we need to reset the color before\n-                // the newline. We're making the assumption that we end up writing\n-                // to a `LineBufferedWriter`, which means that emitting the reset\n-                // after the newline ends up buffering the reset until we print\n-                // another line or exit. Buffering the reset is a problem if we're\n-                // sharing the terminal with any other programs (e.g. other rustc\n-                // instances via `make -jN`).\n-                //\n-                // Note that if `msg` contains any internal newlines, this will\n-                // result in the `LineBufferedWriter` flushing twice instead of\n-                // once, which still leaves the opportunity for interleaved output\n-                // to be miscolored. We assume this is rare enough that we don't\n-                // have to worry about it.\n-                try!(t.write_fmt(args));\n-                try!(t.reset());\n-                if print_newline_at_end {\n-                    t.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-            Raw(ref mut w) => {\n-                try!(w.write_fmt(args));\n-                if print_newline_at_end {\n-                    w.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-        }\n-    }\n-\n-    fn print_diagnostic(&mut self, topic: &str, lvl: Level,\n-                        msg: &str, code: Option<&str>) -> io::Result<()> {\n-        if !topic.is_empty() {\n-            try!(write!(&mut self.dst, \"{} \", topic));\n-        }\n-\n-        try!(print_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n-                                 \"{}: \", lvl.to_string()));\n-        try!(print_maybe_styled!(self, term::Attr::Bold, \"{}\", msg));\n-\n-        match code {\n-            Some(code) => {\n-                let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-                try!(print_maybe_styled!(self, style, \" [{}]\", code.clone()));\n-            }\n-            None => ()\n-        }\n-        try!(write!(&mut self.dst, \"\\n\"));\n-        Ok(())\n+               registry: Option<diagnostics::registry::Registry>,\n+               code_map: Rc<codemap::CodeMap>)\n+               -> EmitterWriter {\n+        EmitterWriter { dst: Raw(dst), registry: registry, cm: code_map }\n     }\n \n-    fn emit_(&mut self, cm: &codemap::CodeMap, rsp: RenderSpan,\n-             msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n+    fn emit_(&mut self,\n+             rsp: RenderSpan,\n+             msg: &str,\n+             code: Option<&str>,\n+             lvl: Level)\n+             -> io::Result<()> {\n         let sp = rsp.span();\n \n         // We cannot check equality directly with COMMAND_LINE_SP\n@@ -433,25 +166,27 @@ impl EmitterWriter {\n             \"<command line option>\".to_string()\n         } else if let EndSpan(_) = rsp {\n             let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n-            cm.span_to_string(span_end)\n+            self.cm.span_to_string(span_end)\n         } else {\n-            cm.span_to_string(sp)\n+            self.cm.span_to_string(sp)\n         };\n \n-        try!(self.print_diagnostic(&ss[..], lvl, msg, code));\n+        try!(print_diagnostic(&mut self.dst, &ss[..], lvl, msg, code));\n \n         match rsp {\n             FullSpan(_) => {\n-                try!(self.highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n-                try!(self.print_macro_backtrace(cm, sp));\n+                let lines = self.cm.span_to_lines(sp);\n+                try!(self.highlight_lines(sp, lvl, lines));\n+                try!(self.print_macro_backtrace(sp));\n             }\n             EndSpan(_) => {\n-                try!(self.end_highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n-                try!(self.print_macro_backtrace(cm, sp));\n+                let lines = self.cm.span_to_lines(sp);\n+                try!(self.end_highlight_lines(sp, lvl, lines));\n+                try!(self.print_macro_backtrace(sp));\n             }\n             Suggestion(_, ref suggestion) => {\n-                try!(self.highlight_suggestion(cm, sp, suggestion));\n-                try!(self.print_macro_backtrace(cm, sp));\n+                try!(self.highlight_suggestion(sp, suggestion));\n+                try!(self.print_macro_backtrace(sp));\n             }\n             FileLine(..) => {\n                 // no source text in this case!\n@@ -462,9 +197,9 @@ impl EmitterWriter {\n             Some(code) =>\n                 match self.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n                     Some(_) => {\n-                        try!(self.print_diagnostic(&ss[..], Help,\n-                                                   &format!(\"run `rustc --explain {}` to see a \\\n-                                                             detailed explanation\", code), None));\n+                        try!(print_diagnostic(&mut self.dst, &ss[..], Help,\n+                                              &format!(\"run `rustc --explain {}` to see a \\\n+                                                       detailed explanation\", code), None));\n                     }\n                     None => ()\n                 },\n@@ -474,12 +209,11 @@ impl EmitterWriter {\n     }\n \n     fn highlight_suggestion(&mut self,\n-                            cm: &codemap::CodeMap,\n                             sp: Span,\n                             suggestion: &str)\n                             -> io::Result<()>\n     {\n-        let lines = cm.span_to_lines(sp).unwrap();\n+        let lines = self.cm.span_to_lines(sp).unwrap();\n         assert!(!lines.lines.is_empty());\n \n         // To build up the result, we want to take the snippet from the first\n@@ -521,7 +255,6 @@ impl EmitterWriter {\n     }\n \n     fn highlight_lines(&mut self,\n-                       cm: &codemap::CodeMap,\n                        sp: Span,\n                        lvl: Level,\n                        lines: codemap::FileLinesResult)\n@@ -581,7 +314,7 @@ impl EmitterWriter {\n         // FIXME (#3260)\n         // If there's one line at fault we can easily point to the problem\n         if lines.lines.len() == 1 {\n-            let lo = cm.lookup_char_pos(sp.lo);\n+            let lo = self.cm.lookup_char_pos(sp.lo);\n             let mut digits = 0;\n             let mut num = (lines.lines[0].line_index + 1) / 10;\n \n@@ -628,7 +361,7 @@ impl EmitterWriter {\n                 col += count;\n                 s.extend(::std::iter::repeat('~').take(count));\n \n-                let hi = cm.lookup_char_pos(sp.hi);\n+                let hi = self.cm.lookup_char_pos(sp.hi);\n                 if hi.col != lo.col {\n                     for (pos, ch) in iter {\n                         if pos >= hi.col.to_usize() { break; }\n@@ -646,7 +379,7 @@ impl EmitterWriter {\n                     s.pop();\n                 }\n \n-                try!(println_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n+                try!(println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n                                            \"{}\", s));\n             }\n         }\n@@ -661,7 +394,6 @@ impl EmitterWriter {\n     /// six lines.\n     #[allow(deprecated)]\n     fn end_highlight_lines(&mut self,\n-                           cm: &codemap::CodeMap,\n                            sp: Span,\n                            lvl: Level,\n                            lines: codemap::FileLinesResult)\n@@ -697,7 +429,7 @@ impl EmitterWriter {\n             }\n         }\n         let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n-        let hi = cm.lookup_char_pos(sp.hi);\n+        let hi = self.cm.lookup_char_pos(sp.hi);\n         let skip = last_line_start.chars().count();\n         let mut s = String::new();\n         for _ in 0..skip {\n@@ -719,55 +451,82 @@ impl EmitterWriter {\n             }\n         }\n         s.push('^');\n-        println_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n+        println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n                               \"{}\", s)\n     }\n \n     fn print_macro_backtrace(&mut self,\n-                             cm: &codemap::CodeMap,\n                              sp: Span)\n                              -> io::Result<()> {\n         let mut last_span = codemap::DUMMY_SP;\n-        let mut sp_opt = Some(sp);\n-\n-        while let Some(sp) = sp_opt {\n-            sp_opt = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> io::Result<_> {\n-                match expn_info {\n-                    Some(ei) => {\n-                        let (pre, post) = match ei.callee.format {\n-                            codemap::MacroAttribute(..) => (\"#[\", \"]\"),\n-                            codemap::MacroBang(..) => (\"\", \"!\"),\n-                        };\n-                        // Don't print recursive invocations\n-                        if ei.call_site != last_span {\n-                            last_span = ei.call_site;\n-\n-                            let mut diag_string = format!(\"in this expansion of {}{}{}\",\n-                                                          pre,\n-                                                          ei.callee.name(),\n-                                                          post);\n-\n-                            if let Some(def_site_span) = ei.callee.span {\n-                                diag_string.push_str(&format!(\" (defined in {})\",\n-                                                              cm.span_to_filename(def_site_span)));\n-                            }\n-\n-                            try!(self.print_diagnostic(&cm.span_to_string(ei.call_site),\n-                                                       Note,\n-                                                       &diag_string,\n-                                                       None));\n-                        }\n-                        Ok(Some(ei.call_site))\n-                    }\n-                    None => Ok(None)\n+        let mut span = sp;\n+\n+        loop {\n+            let span_name_span = self.cm.with_expn_info(span.expn_id, |expn_info| {\n+                expn_info.map(|ei| {\n+                    let (pre, post) = match ei.callee.format {\n+                        codemap::MacroAttribute(..) => (\"#[\", \"]\"),\n+                        codemap::MacroBang(..) => (\"\", \"!\"),\n+                    };\n+                    let macro_decl_name = format!(\"in this expansion of {}{}{}\",\n+                                                  pre,\n+                                                  ei.callee.name(),\n+                                                  post);\n+                    let def_site_span = ei.callee.span;\n+                    (ei.call_site, macro_decl_name, def_site_span)\n+                })\n+            });\n+            let (macro_decl_name, def_site_span) = match span_name_span {\n+                None => break,\n+                Some((sp, macro_decl_name, def_site_span)) => {\n+                    span = sp;\n+                    (macro_decl_name, def_site_span)\n                 }\n-            }));\n+            };\n+\n+            // Don't print recursive invocations\n+            if span != last_span {\n+                let mut diag_string = macro_decl_name;\n+                if let Some(def_site_span) = def_site_span {\n+                    diag_string.push_str(&format!(\" (defined in {})\",\n+                                                  self.cm.span_to_filename(def_site_span)));\n+                }\n+\n+                let snippet = self.cm.span_to_string(span);\n+                try!(print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None));\n+            }\n+            last_span = span;\n         }\n \n         Ok(())\n     }\n }\n \n+fn print_diagnostic(dst: &mut Destination,\n+                    topic: &str,\n+                    lvl: Level,\n+                    msg: &str,\n+                    code: Option<&str>)\n+                    -> io::Result<()> {\n+    if !topic.is_empty() {\n+        try!(write!(dst, \"{} \", topic));\n+    }\n+\n+    try!(print_maybe_styled!(dst, term::Attr::ForegroundColor(lvl.color()),\n+                             \"{}: \", lvl.to_string()));\n+    try!(print_maybe_styled!(dst, term::Attr::Bold, \"{}\", msg));\n+\n+    match code {\n+        Some(code) => {\n+            let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n+            try!(print_maybe_styled!(dst, style, \" [{}]\", code.clone()));\n+        }\n+        None => ()\n+    }\n+    try!(write!(dst, \"\\n\"));\n+    Ok(())\n+}\n+\n #[cfg(unix)]\n fn stderr_isatty() -> bool {\n     use libc;\n@@ -791,6 +550,60 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n+enum Destination {\n+    Terminal(Box<term::StderrTerminal>),\n+    Raw(Box<Write + Send>),\n+}\n+\n+impl Destination {\n+    fn from_stderr() -> Destination {\n+        match term::stderr() {\n+            Some(t) => Terminal(t),\n+            None    => Raw(Box::new(io::stderr())),\n+        }\n+    }\n+\n+    fn print_maybe_styled(&mut self,\n+                          args: fmt::Arguments,\n+                          color: term::Attr,\n+                          print_newline_at_end: bool)\n+                          -> io::Result<()> {\n+        match *self {\n+            Terminal(ref mut t) => {\n+                try!(t.attr(color));\n+                // If `msg` ends in a newline, we need to reset the color before\n+                // the newline. We're making the assumption that we end up writing\n+                // to a `LineBufferedWriter`, which means that emitting the reset\n+                // after the newline ends up buffering the reset until we print\n+                // another line or exit. Buffering the reset is a problem if we're\n+                // sharing the terminal with any other programs (e.g. other rustc\n+                // instances via `make -jN`).\n+                //\n+                // Note that if `msg` contains any internal newlines, this will\n+                // result in the `LineBufferedWriter` flushing twice instead of\n+                // once, which still leaves the opportunity for interleaved output\n+                // to be miscolored. We assume this is rare enough that we don't\n+                // have to worry about it.\n+                try!(t.write_fmt(args));\n+                try!(t.reset());\n+                if print_newline_at_end {\n+                    t.write_all(b\"\\n\")\n+                } else {\n+                    Ok(())\n+                }\n+            }\n+            Raw(ref mut w) => {\n+                try!(w.write_fmt(args));\n+                if print_newline_at_end {\n+                    w.write_all(b\"\\n\")\n+                } else {\n+                    Ok(())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl Write for Destination {\n     fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n         match *self {\n@@ -806,49 +619,16 @@ impl Write for Destination {\n     }\n }\n \n-impl Emitter for EmitterWriter {\n-    fn emit(&mut self,\n-            cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str, code: Option<&str>, lvl: Level) {\n-        let error = match cmsp {\n-            Some((cm, COMMAND_LINE_SP)) => self.emit_(cm,\n-                                                FileLine(COMMAND_LINE_SP),\n-                                                msg, code, lvl),\n-            Some((cm, sp)) => self.emit_(cm, FullSpan(sp), msg, code, lvl),\n-            None => self.print_diagnostic(\"\", lvl, msg, code),\n-        };\n-\n-        match error {\n-            Ok(()) => {}\n-            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n-        }\n-    }\n-\n-    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n-                   sp: RenderSpan, msg: &str, lvl: Level) {\n-        match self.emit_(cm, sp, msg, None, lvl) {\n-            Ok(()) => {}\n-            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n-        }\n-    }\n-}\n-\n-pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n-    M: FnOnce() -> String,\n-{\n-    match opt {\n-        Some(t) => t,\n-        None => diag.handler().bug(&msg()),\n-    }\n-}\n \n #[cfg(test)]\n mod test {\n-    use super::{EmitterWriter, Level};\n+    use errors::Level;\n+    use super::EmitterWriter;\n     use codemap::{mk_sp, CodeMap};\n     use std::sync::{Arc, Mutex};\n     use std::io::{self, Write};\n     use std::str::from_utf8;\n+    use std::rc::Rc;\n \n     // Diagnostic doesn't align properly in span where line number increases by one digit\n     #[test]\n@@ -861,8 +641,8 @@ mod test {\n             fn flush(&mut self) -> io::Result<()> { Ok(()) }\n         }\n         let data = Arc::new(Mutex::new(Vec::new()));\n-        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None);\n-        let cm = CodeMap::new();\n+        let cm = Rc::new(CodeMap::new());\n+        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n         let content = \"abcdefg\n         koksi\n         line3\n@@ -885,7 +665,7 @@ mod test {\n         println!(\"span_to_lines\");\n         let lines = cm.span_to_lines(sp);\n         println!(\"highlight_lines\");\n-        ew.highlight_lines(&cm, sp, lvl, lines).unwrap();\n+        ew.highlight_lines(sp, lvl, lines).unwrap();\n         println!(\"done\");\n         let vec = data.lock().unwrap().clone();\n         let vec: &[u8] = &vec;", "previous_filename": "src/libsyntax/diagnostic.rs"}, {"sha": "f2e61090ba23cfc86b1d72a3e9d2b9fe97b9dc1e", "filename": "src/libsyntax/errors/mod.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -0,0 +1,338 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use errors::emitter::ColorConfig;\n+\n+use self::Level::*;\n+use self::RenderSpan::*;\n+\n+use codemap::{self, Span};\n+use diagnostics;\n+use errors::emitter::{Emitter, EmitterWriter};\n+\n+use std::cell::{RefCell, Cell};\n+use std::{error, fmt};\n+use std::io::prelude::*;\n+use std::rc::Rc;\n+use term;\n+\n+pub mod emitter;\n+\n+#[derive(Clone)]\n+pub enum RenderSpan {\n+    /// A FullSpan renders with both with an initial line for the\n+    /// message, prefixed by file:linenum, followed by a summary of\n+    /// the source code covered by the span.\n+    FullSpan(Span),\n+\n+    /// Similar to a FullSpan, but the cited position is the end of\n+    /// the span, instead of the start. Used, at least, for telling\n+    /// compiletest/runtest to look at the last line of the span\n+    /// (since `end_highlight_lines` displays an arrow to the end\n+    /// of the span).\n+    EndSpan(Span),\n+\n+    /// A suggestion renders with both with an initial line for the\n+    /// message, prefixed by file:linenum, followed by a summary\n+    /// of hypothetical source code, where the `String` is spliced\n+    /// into the lines in place of the code covered by the span.\n+    Suggestion(Span, String),\n+\n+    /// A FileLine renders with just a line for the message prefixed\n+    /// by file:linenum.\n+    FileLine(Span),\n+}\n+\n+impl RenderSpan {\n+    fn span(&self) -> Span {\n+        match *self {\n+            FullSpan(s) |\n+            Suggestion(s, _) |\n+            EndSpan(s) |\n+            FileLine(s) =>\n+                s\n+        }\n+    }\n+}\n+\n+/// Used as a return value to signify a fatal error occurred. (It is also\n+/// used as the argument to panic at the moment, but that will eventually\n+/// not be true.)\n+#[derive(Copy, Clone, Debug)]\n+#[must_use]\n+pub struct FatalError;\n+\n+impl fmt::Display for FatalError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(f, \"parser fatal error\")\n+    }\n+}\n+\n+impl error::Error for FatalError {\n+    fn description(&self) -> &str {\n+        \"The parser has encountered a fatal error\"\n+    }\n+}\n+\n+/// Signifies that the compiler died with an explicit call to `.bug`\n+/// or `.span_bug` rather than a failed assertion, etc.\n+#[derive(Copy, Clone, Debug)]\n+pub struct ExplicitBug;\n+\n+impl fmt::Display for ExplicitBug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(f, \"parser internal bug\")\n+    }\n+}\n+\n+impl error::Error for ExplicitBug {\n+    fn description(&self) -> &str {\n+        \"The parser has encountered an internal bug\"\n+    }\n+}\n+\n+/// A handler deals with errors; certain errors\n+/// (fatal, bug, unimpl) may cause immediate exit,\n+/// others log errors for later reporting.\n+pub struct Handler {\n+    err_count: Cell<usize>,\n+    emit: RefCell<Box<Emitter>>,\n+    pub can_emit_warnings: bool,\n+    treat_err_as_bug: bool,\n+    delayed_span_bug: RefCell<Option<(codemap::Span, String)>>,\n+}\n+\n+impl Handler {\n+    pub fn new(color_config: ColorConfig,\n+               registry: Option<diagnostics::registry::Registry>,\n+               can_emit_warnings: bool,\n+               treat_err_as_bug: bool,\n+               cm: Rc<codemap::CodeMap>)\n+               -> Handler {\n+        let emitter = Box::new(EmitterWriter::stderr(color_config, registry, cm));\n+        Handler::with_emitter(can_emit_warnings, treat_err_as_bug, emitter)\n+    }\n+\n+    pub fn with_emitter(can_emit_warnings: bool,\n+                        treat_err_as_bug: bool,\n+                        e: Box<Emitter>) -> Handler {\n+        Handler {\n+            err_count: Cell::new(0),\n+            emit: RefCell::new(e),\n+            can_emit_warnings: can_emit_warnings,\n+            treat_err_as_bug: treat_err_as_bug,\n+            delayed_span_bug: RefCell::new(None),\n+        }\n+    }\n+\n+    pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit(Some(sp), msg, Fatal);\n+        return FatalError;\n+    }\n+    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> FatalError {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit_with_code(Some(sp), msg, code, Fatal);\n+        return FatalError;\n+    }\n+    pub fn span_err(&self, sp: Span, msg: &str) {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit(Some(sp), msg, Error);\n+        self.bump_err_count();\n+    }\n+    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit_with_code(Some(sp), msg, code, Error);\n+        self.bump_err_count();\n+    }\n+    pub fn span_warn(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Warning);\n+    }\n+    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        self.emit_with_code(Some(sp), msg, code, Warning);\n+    }\n+    pub fn span_note(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Note);\n+    }\n+    pub fn span_end_note(&self, sp: Span, msg: &str) {\n+        self.custom_emit(EndSpan(sp), msg, Note);\n+    }\n+    pub fn span_help(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Help);\n+    }\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n+        self.custom_emit(Suggestion(sp, suggestion), msg, Help);\n+    }\n+    pub fn fileline_note(&self, sp: Span, msg: &str) {\n+        self.custom_emit(FileLine(sp), msg, Note);\n+    }\n+    pub fn fileline_help(&self, sp: Span, msg: &str) {\n+        self.custom_emit(FileLine(sp), msg, Help);\n+    }\n+    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n+        self.emit(Some(sp), msg, Bug);\n+        panic!(ExplicitBug);\n+    }\n+    pub fn delay_span_bug(&self, sp: Span, msg: &str) {\n+        let mut delayed = self.delayed_span_bug.borrow_mut();\n+        *delayed = Some((sp, msg.to_string()));\n+    }\n+    pub fn span_bug_no_panic(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Bug);\n+        self.bump_err_count();\n+    }\n+    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n+        self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n+    }\n+    pub fn fatal(&self, msg: &str) -> FatalError {\n+        if self.treat_err_as_bug {\n+            self.bug(msg);\n+        }\n+        self.emit.borrow_mut().emit(None, msg, None, Fatal);\n+        FatalError\n+    }\n+    pub fn err(&self, msg: &str) {\n+        if self.treat_err_as_bug {\n+            self.bug(msg);\n+        }\n+        self.emit.borrow_mut().emit(None, msg, None, Error);\n+        self.bump_err_count();\n+    }\n+    pub fn warn(&self, msg: &str) {\n+        self.emit.borrow_mut().emit(None, msg, None, Warning);\n+    }\n+    pub fn note(&self, msg: &str) {\n+        self.emit.borrow_mut().emit(None, msg, None, Note);\n+    }\n+    pub fn help(&self, msg: &str) {\n+        self.emit.borrow_mut().emit(None, msg, None, Help);\n+    }\n+    pub fn bug(&self, msg: &str) -> ! {\n+        self.emit.borrow_mut().emit(None, msg, None, Bug);\n+        panic!(ExplicitBug);\n+    }\n+    pub fn unimpl(&self, msg: &str) -> ! {\n+        self.bug(&format!(\"unimplemented {}\", msg));\n+    }\n+\n+    pub fn bump_err_count(&self) {\n+        self.err_count.set(self.err_count.get() + 1);\n+    }\n+\n+    pub fn err_count(&self) -> usize {\n+        self.err_count.get()\n+    }\n+\n+    pub fn has_errors(&self) -> bool {\n+        self.err_count.get() > 0\n+    }\n+\n+    pub fn abort_if_errors(&self) {\n+        let s;\n+        match self.err_count.get() {\n+            0 => {\n+                let delayed_bug = self.delayed_span_bug.borrow();\n+                match *delayed_bug {\n+                    Some((span, ref errmsg)) => {\n+                        self.span_bug(span, errmsg);\n+                    },\n+                    _ => {}\n+                }\n+\n+                return;\n+            }\n+            1 => s = \"aborting due to previous error\".to_string(),\n+            _  => {\n+                s = format!(\"aborting due to {} previous errors\",\n+                            self.err_count.get());\n+            }\n+        }\n+\n+        panic!(self.fatal(&s[..]));\n+    }\n+\n+    pub fn emit(&self,\n+                sp: Option<Span>,\n+                msg: &str,\n+                lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings { return }\n+        self.emit.borrow_mut().emit(sp, msg, None, lvl);\n+    }\n+\n+    pub fn emit_with_code(&self,\n+                          sp: Option<Span>,\n+                          msg: &str,\n+                          code: &str,\n+                          lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings { return }\n+        self.emit.borrow_mut().emit(sp, msg, Some(code), lvl);\n+    }\n+\n+    pub fn custom_emit(&self, sp: RenderSpan, msg: &str, lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings { return }\n+        self.emit.borrow_mut().custom_emit(sp, msg, lvl);\n+    }\n+}\n+\n+\n+#[derive(Copy, PartialEq, Clone, Debug)]\n+pub enum Level {\n+    Bug,\n+    Fatal,\n+    Error,\n+    Warning,\n+    Note,\n+    Help,\n+}\n+\n+impl fmt::Display for Level {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use std::fmt::Display;\n+\n+        match *self {\n+            Bug => \"error: internal compiler error\".fmt(f),\n+            Fatal | Error => \"error\".fmt(f),\n+            Warning => \"warning\".fmt(f),\n+            Note => \"note\".fmt(f),\n+            Help => \"help\".fmt(f),\n+        }\n+    }\n+}\n+\n+impl Level {\n+    fn color(self) -> term::color::Color {\n+        match self {\n+            Bug | Fatal | Error => term::color::BRIGHT_RED,\n+            Warning => term::color::BRIGHT_YELLOW,\n+            Note => term::color::BRIGHT_GREEN,\n+            Help => term::color::BRIGHT_CYAN,\n+        }\n+    }\n+}\n+\n+pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n+    M: FnOnce() -> String,\n+{\n+    match opt {\n+        Some(t) => t,\n+        None => diag.bug(&msg()),\n+    }\n+}"}, {"sha": "f198460137d5f78f070af026c1c63e66c45d90be", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -720,7 +720,7 @@ impl<'a> ExtCtxt<'a> {\n         self.parse_sess.span_diagnostic.fileline_help(sp, msg);\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.handler().bug(msg);\n+        self.parse_sess.span_diagnostic.bug(msg);\n     }\n     pub fn trace_macros(&self) -> bool {\n         self.ecfg.trace_mac"}, {"sha": "743bcda18def441507ef0cd3a3f1ca4a2995b32e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -1301,7 +1301,7 @@ pub fn expand_crate(mut cx: ExtCtxt,\n \n         let mut ret = expander.fold_crate(c);\n         ret.exported_macros = expander.cx.exported_macros.clone();\n-        cx.parse_sess.span_diagnostic.handler().abort_if_errors();\n+        cx.parse_sess.span_diagnostic.abort_if_errors();\n         ret\n     };\n     return (ret, cx.syntax_env.names);"}, {"sha": "8878c606d6a2c80a0c4b86b1d956adf50511308d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -12,7 +12,7 @@ use self::LockstepIterSize::*;\n use ast;\n use ast::{TokenTree, Ident, Name};\n use codemap::{Span, DUMMY_SP};\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{DocComment, MatchNt, SubstNt};\n use parse::token::{Token, NtIdent, SpecialMacroVar};\n@@ -34,7 +34,7 @@ struct TtFrame {\n \n #[derive(Clone)]\n pub struct TtReader<'a> {\n-    pub sp_diag: &'a SpanHandler,\n+    pub sp_diag: &'a Handler,\n     /// the unzipped tree:\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n@@ -55,7 +55,7 @@ pub struct TtReader<'a> {\n /// This can do Macro-By-Example transcription. On the other hand, if\n /// `src` contains no `TokenTree::Sequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n-pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n+pub fn new_tt_reader<'a>(sp_diag: &'a Handler,\n                          interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                          imported_from: Option<Ident>,\n                          src: Vec<ast::TokenTree>)\n@@ -69,7 +69,7 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n /// This can do Macro-By-Example transcription. On the other hand, if\n /// `src` contains no `TokenTree::Sequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n-pub fn new_tt_reader_with_doc_flag<'a>(sp_diag: &'a SpanHandler,\n+pub fn new_tt_reader_with_doc_flag<'a>(sp_diag: &'a Handler,\n                                        interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                                        imported_from: Option<Ident>,\n                                        src: Vec<ast::TokenTree>,"}, {"sha": "89f318d09451b8b56c4890ce54bc9346ee1e525a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -32,7 +32,7 @@ use ast;\n use attr;\n use attr::AttrMetaMethods;\n use codemap::{CodeMap, Span};\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use visit;\n use visit::{FnKind, Visitor};\n use parse::token::InternedString;\n@@ -446,7 +446,7 @@ impl PartialOrd for GatedCfgAttr {\n }\n \n impl GatedCfgAttr {\n-    pub fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+    pub fn check_and_emit(&self, diagnostic: &Handler, features: &Features) {\n         match *self {\n             GatedCfgAttr::GatedCfg(ref cfg) => {\n                 cfg.check_and_emit(diagnostic, features);\n@@ -476,7 +476,7 @@ impl GatedCfg {\n                       }\n                   })\n     }\n-    fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+    fn check_and_emit(&self, diagnostic: &Handler, features: &Features) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n         if !has_feature(features) {\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n@@ -595,21 +595,21 @@ const EXPLAIN_PUSHPOP_UNSAFE: &'static str =\n const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n     \"attributes on non-item statements and expressions are experimental.\";\n \n-pub fn check_for_box_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+pub fn check_for_box_syntax(f: Option<&Features>, diag: &Handler, span: Span) {\n     if let Some(&Features { allow_box: true, .. }) = f {\n         return;\n     }\n     emit_feature_err(diag, \"box_syntax\", span, GateIssue::Language, EXPLAIN_BOX_SYNTAX);\n }\n \n-pub fn check_for_placement_in(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+pub fn check_for_placement_in(f: Option<&Features>, diag: &Handler, span: Span) {\n     if let Some(&Features { allow_placement_in: true, .. }) = f {\n         return;\n     }\n     emit_feature_err(diag, \"placement_in_syntax\", span, GateIssue::Language, EXPLAIN_PLACEMENT_IN);\n }\n \n-pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &Handler, span: Span) {\n     if let Some(&Features { allow_pushpop_unsafe: true, .. }) = f {\n         return;\n     }\n@@ -618,7 +618,7 @@ pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &SpanHandler, span:\n \n struct Context<'a> {\n     features: Vec<&'static str>,\n-    span_handler: &'a SpanHandler,\n+    span_handler: &'a Handler,\n     cm: &'a CodeMap,\n     plugin_attributes: &'a [(String, AttributeType)],\n }\n@@ -704,7 +704,7 @@ pub enum GateIssue {\n     Library(Option<u32>)\n }\n \n-pub fn emit_feature_err(diag: &SpanHandler, feature: &str, span: Span, issue: GateIssue,\n+pub fn emit_feature_err(diag: &Handler, feature: &str, span: Span, issue: GateIssue,\n                         explain: &str) {\n     let issue = match issue {\n         GateIssue::Language => find_lang_feature_issue(feature),\n@@ -1064,7 +1064,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n }\n \n-fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n+fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n                         krate: &ast::Crate,\n                         plugin_attributes: &[(String, AttributeType)],\n                         check: F)\n@@ -1161,13 +1161,13 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n     }\n }\n \n-pub fn check_crate_macros(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::Crate)\n+pub fn check_crate_macros(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate)\n -> Features {\n     check_crate_inner(cm, span_handler, krate, &[] as &'static [_],\n                       |ctx, krate| visit::walk_crate(&mut MacroVisitor { context: ctx }, krate))\n }\n \n-pub fn check_crate(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::Crate,\n+pub fn check_crate(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate,\n                    plugin_attributes: &[(String, AttributeType)],\n                    unstable: UnstableFeatures) -> Features\n {\n@@ -1192,7 +1192,7 @@ pub enum UnstableFeatures {\n     Cheat\n }\n \n-fn maybe_stage_features(span_handler: &SpanHandler, krate: &ast::Crate,\n+fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n                         unstable: UnstableFeatures) {\n     let allow_features = match unstable {\n         UnstableFeatures::Allow => true,"}, {"sha": "47340d312242b2b0d220baf7821874dc93f85fae", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -52,7 +52,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use diagnostic::FatalError;\n+        use errors::FatalError;\n         match $e {\n             Ok(e) => e,\n             Err(FatalError) => panic!(FatalError)\n@@ -78,6 +78,8 @@ pub mod diagnostics {\n     pub mod metadata;\n }\n \n+pub mod errors;\n+\n pub mod syntax {\n     pub use ext;\n     pub use parse;\n@@ -90,7 +92,6 @@ pub mod ast_util;\n pub mod attr;\n pub mod codemap;\n pub mod config;\n-pub mod diagnostic;\n pub mod entry;\n pub mod feature_gate;\n pub mod fold;"}, {"sha": "d2156d7cb68d25ae45b0420eb608b359ebe71ba7", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -12,7 +12,7 @@ pub use self::CommentStyle::*;\n \n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos};\n-use diagnostic;\n+use errors;\n use parse::lexer::is_block_doc_comment;\n use parse::lexer::{StringReader, TokenAndSpan};\n use parse::lexer::{is_whitespace, Reader};\n@@ -334,7 +334,7 @@ pub struct Literal {\n \n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments_and_literals(span_diagnostic: &diagnostic::SpanHandler,\n+pub fn gather_comments_and_literals(span_diagnostic: &errors::Handler,\n                                     path: String,\n                                     srdr: &mut Read)\n                                  -> (Vec<Comment>, Vec<Literal>) {"}, {"sha": "4619410ada7274c44cefe8f08032684bff346d78", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 56, "deletions": 33, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -11,8 +11,7 @@\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n-use diagnostic::FatalError;\n-use diagnostic::SpanHandler;\n+use errors::{FatalError, Handler};\n use ext::tt::transcribe::tt_next_token;\n use parse::token::str_to_ident;\n use parse::token;\n@@ -58,7 +57,7 @@ pub struct TokenAndSpan {\n }\n \n pub struct StringReader<'a> {\n-    pub span_diagnostic: &'a SpanHandler,\n+    pub span_diagnostic: &'a Handler,\n     /// The absolute offset within the codemap of the next character to read\n     pub pos: BytePos,\n     /// The absolute offset within the codemap of the last character read(curr)\n@@ -128,10 +127,10 @@ impl<'a> Reader for TtReader<'a> {\n \n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into pos and curr\n-    pub fn new_raw<'b>(span_diagnostic: &'b SpanHandler,\n+    pub fn new_raw<'b>(span_diagnostic: &'b Handler,\n                        filemap: Rc<codemap::FileMap>) -> StringReader<'b> {\n         if filemap.src.is_none() {\n-            span_diagnostic.handler.bug(&format!(\"Cannot lex filemap without source: {}\",\n+            span_diagnostic.bug(&format!(\"Cannot lex filemap without source: {}\",\n                                                  filemap.name)[..]);\n         }\n \n@@ -153,7 +152,7 @@ impl<'a> StringReader<'a> {\n         sr\n     }\n \n-    pub fn new<'b>(span_diagnostic: &'b SpanHandler,\n+    pub fn new<'b>(span_diagnostic: &'b Handler,\n                    filemap: Rc<codemap::FileMap>) -> StringReader<'b> {\n         let mut sr = StringReader::new_raw(span_diagnostic, filemap);\n         sr.advance_token();\n@@ -1423,28 +1422,30 @@ mod tests {\n     use super::*;\n \n     use codemap::{BytePos, CodeMap, Span, NO_EXPANSION};\n-    use diagnostic;\n+    use errors;\n     use parse::token;\n     use parse::token::{str_to_ident};\n     use std::io;\n+    use std::rc::Rc;\n \n-    fn mk_sh() -> diagnostic::SpanHandler {\n+    fn mk_sh(cm: Rc<CodeMap>) -> errors::Handler {\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-        let emitter = diagnostic::EmitterWriter::new(Box::new(io::sink()), None);\n-        let handler = diagnostic::Handler::with_emitter(true, Box::new(emitter));\n-        diagnostic::SpanHandler::new(handler, CodeMap::new())\n+        let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()), None, cm);\n+        errors::Handler::with_emitter(true, false, Box::new(emitter))\n     }\n \n     // open a string reader for the given string\n-    fn setup<'a>(span_handler: &'a diagnostic::SpanHandler,\n+    fn setup<'a>(cm: &CodeMap,\n+                 span_handler: &'a errors::Handler,\n                  teststr: String) -> StringReader<'a> {\n-        let fm = span_handler.cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n+        let fm = cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n         StringReader::new(span_handler, fm)\n     }\n \n     #[test] fn t1 () {\n-        let span_handler = mk_sh();\n-        let mut string_reader = setup(&span_handler,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        let mut string_reader = setup(&cm, &sh,\n             \"/* my source file */ \\\n              fn main() { println!(\\\"zebra\\\"); }\\n\".to_string());\n         let id = str_to_ident(\"fn\");\n@@ -1482,70 +1483,90 @@ mod tests {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        check_tokenization(setup(&mk_sh(), \"a b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a b\".to_string()),\n                            vec![mk_ident(\"a\", token::Plain),\n                                 token::Whitespace,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn dcparsing_2 () {\n-        check_tokenization(setup(&mk_sh(), \"a::b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a::b\".to_string()),\n                            vec![mk_ident(\"a\",token::ModName),\n                                 token::ModSep,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn dcparsing_3 () {\n-        check_tokenization(setup(&mk_sh(), \"a ::b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a ::b\".to_string()),\n                            vec![mk_ident(\"a\", token::Plain),\n                                 token::Whitespace,\n                                 token::ModSep,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn dcparsing_4 () {\n-        check_tokenization(setup(&mk_sh(), \"a:: b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a:: b\".to_string()),\n                            vec![mk_ident(\"a\",token::ModName),\n                                 token::ModSep,\n                                 token::Whitespace,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn character_a() {\n-        assert_eq!(setup(&mk_sh(), \"'a'\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(token::intern(\"a\")), None));\n     }\n \n     #[test] fn character_space() {\n-        assert_eq!(setup(&mk_sh(), \"' '\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n                    token::Literal(token::Char(token::intern(\" \")), None));\n     }\n \n     #[test] fn character_escaped() {\n-        assert_eq!(setup(&mk_sh(), \"'\\\\n'\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(token::intern(\"\\\\n\")), None));\n     }\n \n     #[test] fn lifetime_name() {\n-        assert_eq!(setup(&mk_sh(), \"'abc\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n                    token::Lifetime(token::str_to_ident(\"'abc\")));\n     }\n \n     #[test] fn raw_string() {\n-        assert_eq!(setup(&mk_sh(),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh,\n                          \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string()).next_token()\n                                                                  .tok,\n                    token::Literal(token::StrRaw(token::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n     }\n \n     #[test] fn literal_suffixes() {\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n         macro_rules! test {\n             ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n-                assert_eq!(setup(&mk_sh(), format!(\"{}suffix\", $input)).next_token().tok,\n+                assert_eq!(setup(&cm, &sh, format!(\"{}suffix\", $input)).next_token().tok,\n                            token::Literal(token::$tok_type(token::intern($tok_contents)),\n                                           Some(token::intern(\"suffix\"))));\n                 // with a whitespace separator:\n-                assert_eq!(setup(&mk_sh(), format!(\"{} suffix\", $input)).next_token().tok,\n+                assert_eq!(setup(&cm, &sh, format!(\"{} suffix\", $input)).next_token().tok,\n                            token::Literal(token::$tok_type(token::intern($tok_contents)),\n                                           None));\n             }}\n@@ -1561,13 +1582,13 @@ mod tests {\n         test!(\"1.0\", Float, \"1.0\");\n         test!(\"1.0e10\", Float, \"1.0e10\");\n \n-        assert_eq!(setup(&mk_sh(), \"2us\".to_string()).next_token().tok,\n+        assert_eq!(setup(&cm, &sh, \"2us\".to_string()).next_token().tok,\n                    token::Literal(token::Integer(token::intern(\"2\")),\n                                   Some(token::intern(\"us\"))));\n-        assert_eq!(setup(&mk_sh(), \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n+        assert_eq!(setup(&cm, &sh, \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n                    token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));\n-        assert_eq!(setup(&mk_sh(), \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n+        assert_eq!(setup(&cm, &sh, \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n                    token::Literal(token::ByteStrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));\n     }\n@@ -1579,8 +1600,9 @@ mod tests {\n     }\n \n     #[test] fn nested_block_comments() {\n-        let sh = mk_sh();\n-        let mut lexer = setup(&sh, \"/* /* */ */'a'\".to_string());\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        let mut lexer = setup(&cm, &sh, \"/* /* */ */'a'\".to_string());\n         match lexer.next_token().tok {\n             token::Comment => { },\n             _ => panic!(\"expected a comment!\")\n@@ -1589,8 +1611,9 @@ mod tests {\n     }\n \n     #[test] fn crlf_comments() {\n-        let sh = mk_sh();\n-        let mut lexer = setup(&sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();\n         assert_eq!(comment.tok, token::Comment);\n         assert_eq!(comment.sp, ::codemap::mk_sp(BytePos(0), BytePos(7)));"}, {"sha": "ed87961e7f3d7f2b686a0ab85c1f6db9ba3cd815", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -12,7 +12,7 @@\n \n use ast;\n use codemap::{self, Span, CodeMap, FileMap};\n-use diagnostic::{SpanHandler, Handler, Auto, FatalError};\n+use errors::{Handler, ColorConfig, FatalError};\n use parse::parser::Parser;\n use parse::token::InternedString;\n use ptr::P;\n@@ -40,26 +40,29 @@ pub mod obsolete;\n \n /// Info about a parsing session.\n pub struct ParseSess {\n-    pub span_diagnostic: SpanHandler, // better be the same as the one in the reader!\n+    pub span_diagnostic: Handler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: RefCell<Vec<PathBuf>>,\n+    code_map: Rc<CodeMap>,\n }\n \n impl ParseSess {\n     pub fn new() -> ParseSess {\n-        let handler = SpanHandler::new(Handler::new(Auto, None, true), CodeMap::new());\n-        ParseSess::with_span_handler(handler)\n+        let cm = Rc::new(CodeMap::new());\n+        let handler = Handler::new(ColorConfig::Auto, None, true, false, cm.clone());\n+        ParseSess::with_span_handler(handler, cm)\n     }\n \n-    pub fn with_span_handler(sh: SpanHandler) -> ParseSess {\n+    pub fn with_span_handler(handler: Handler, code_map: Rc<CodeMap>) -> ParseSess {\n         ParseSess {\n-            span_diagnostic: sh,\n-            included_mod_stack: RefCell::new(vec![])\n+            span_diagnostic: handler,\n+            included_mod_stack: RefCell::new(vec![]),\n+            code_map: code_map\n         }\n     }\n \n     pub fn codemap(&self) -> &CodeMap {\n-        &self.span_diagnostic.cm\n+        &self.code_map\n     }\n }\n \n@@ -235,7 +238,7 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n             let msg = format!(\"couldn't read {:?}: {}\", path.display(), e);\n             match spanopt {\n                 Some(sp) => panic!(sess.span_diagnostic.span_fatal(sp, &msg)),\n-                None => panic!(sess.span_diagnostic.handler().fatal(&msg))\n+                None => panic!(sess.span_diagnostic.fatal(&msg))\n             }\n         }\n     }\n@@ -438,7 +441,7 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n }\n \n fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n-                      sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+                      sd: &Handler, sp: Span) -> ast::Lit_ {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n     match suffix.as_ref().map(|s| &**s) {\n         Some(\"f32\") => ast::LitFloat(data, ast::TyF32),\n@@ -459,7 +462,7 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n     }\n }\n pub fn float_lit(s: &str, suffix: Option<InternedString>,\n-                 sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+                 sd: &Handler, sp: Span) -> ast::Lit_ {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -561,7 +564,7 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n \n pub fn integer_lit(s: &str,\n                    suffix: Option<InternedString>,\n-                   sd: &SpanHandler,\n+                   sd: &Handler,\n                    sp: Span)\n                    -> ast::Lit_ {\n     // s can only be ascii, byte indexing is fine"}, {"sha": "5dba1e189ab156dcb8ca3c0a65c17a01ad883de7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -66,10 +66,9 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n         }\n \n         if !self.obsolete_set.contains(&kind) &&\n-            (error || self.sess.span_diagnostic.handler().can_emit_warnings) {\n+            (error || self.sess.span_diagnostic.can_emit_warnings) {\n             self.sess\n                 .span_diagnostic\n-                .handler()\n                 .note(&format!(\"{}\", desc));\n             self.obsolete_set.insert(kind);\n         }"}, {"sha": "b8c4d8d63b58d660036c0e08898dee9fdd881777", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -60,7 +60,7 @@ use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast;\n use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n-use diagnostic;\n+use errors::{self, FatalError};\n use ext::tt::macro_parser;\n use parse;\n use parse::classify;\n@@ -75,7 +75,6 @@ use print::pprust;\n use ptr::P;\n use owned_slice::OwnedSlice;\n use parse::PResult;\n-use diagnostic::FatalError;\n \n use std::collections::HashSet;\n use std::io::prelude::*;\n@@ -983,16 +982,16 @@ impl<'a> Parser<'a> {\n         }\n         f(&self.buffer[((self.buffer_start + dist - 1) & 3) as usize].tok)\n     }\n-    pub fn fatal(&self, m: &str) -> diagnostic::FatalError {\n+    pub fn fatal(&self, m: &str) -> errors::FatalError {\n         self.sess.span_diagnostic.span_fatal(self.span, m)\n     }\n-    pub fn span_fatal(&self, sp: Span, m: &str) -> diagnostic::FatalError {\n+    pub fn span_fatal(&self, sp: Span, m: &str) -> errors::FatalError {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> diagnostic::FatalError {\n+    pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> errors::FatalError {\n         self.span_err(sp, m);\n         self.fileline_help(sp, help);\n-        diagnostic::FatalError\n+        errors::FatalError\n     }\n     pub fn span_note(&self, sp: Span, m: &str) {\n         self.sess.span_diagnostic.span_note(sp, m)\n@@ -1022,7 +1021,7 @@ impl<'a> Parser<'a> {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n     pub fn abort_if_errors(&self) {\n-        self.sess.span_diagnostic.handler().abort_if_errors();\n+        self.sess.span_diagnostic.abort_if_errors();\n     }\n \n     pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {"}, {"sha": "08448f25187c7ffe4694bf17183197f10034306c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -20,7 +20,7 @@ use attr;\n use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{self, CodeMap, BytePos};\n-use diagnostic;\n+use errors;\n use parse::token::{self, BinOpToken, Token, InternedString};\n use parse::lexer::comments;\n use parse;\n@@ -99,7 +99,7 @@ pub const DEFAULT_COLUMNS: usize = 78;\n /// it can scan the input text for comments and literals to\n /// copy forward.\n pub fn print_crate<'a>(cm: &'a CodeMap,\n-                       span_diagnostic: &diagnostic::SpanHandler,\n+                       span_diagnostic: &errors::Handler,\n                        krate: &ast::Crate,\n                        filename: String,\n                        input: &mut Read,\n@@ -139,7 +139,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n-                          span_diagnostic: &diagnostic::SpanHandler,\n+                          span_diagnostic: &errors::Handler,\n                           filename: String,\n                           input: &mut Read,\n                           out: Box<Write+'a>,"}, {"sha": "014c7b2a68f4f36935f96b38b726a1e6086d82c0", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -16,7 +16,7 @@\n use std::str::FromStr;\n \n use ast;\n-use diagnostic;\n+use errors;\n use visit;\n use visit::Visitor;\n \n@@ -40,7 +40,7 @@ impl FromStr for Mode {\n }\n \n struct ShowSpanVisitor<'a> {\n-    span_diagnostic: &'a diagnostic::SpanHandler,\n+    span_diagnostic: &'a errors::Handler,\n     mode: Mode,\n }\n \n@@ -71,7 +71,7 @@ impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n     }\n }\n \n-pub fn run(span_diagnostic: &diagnostic::SpanHandler,\n+pub fn run(span_diagnostic: &errors::Handler,\n            mode: &str,\n            krate: &ast::Crate) {\n     let mode = match mode.parse().ok() {"}, {"sha": "9e1d80b3f0de4ba0b3747bb5efdb3cb96c51d5ca", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -23,7 +23,7 @@ use attr::AttrMetaMethods;\n use attr;\n use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use codemap;\n-use diagnostic;\n+use errors;\n use config;\n use entry::{self, EntryPointType};\n use ext::base::ExtCtxt;\n@@ -55,7 +55,7 @@ struct Test {\n \n struct TestCtxt<'a> {\n     sess: &'a ParseSess,\n-    span_diagnostic: &'a diagnostic::SpanHandler,\n+    span_diagnostic: &'a errors::Handler,\n     path: Vec<ast::Ident>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n@@ -72,7 +72,7 @@ struct TestCtxt<'a> {\n pub fn modify_for_testing(sess: &ParseSess,\n                           cfg: &ast::CrateConfig,\n                           krate: ast::Crate,\n-                          span_diagnostic: &diagnostic::SpanHandler) -> ast::Crate {\n+                          span_diagnostic: &errors::Handler) -> ast::Crate {\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n@@ -275,7 +275,7 @@ fn generate_test_harness(sess: &ParseSess,\n                          reexport_test_harness_main: Option<InternedString>,\n                          krate: ast::Crate,\n                          cfg: &ast::CrateConfig,\n-                         sd: &diagnostic::SpanHandler) -> ast::Crate {\n+                         sd: &errors::Handler) -> ast::Crate {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n@@ -315,7 +315,7 @@ fn generate_test_harness(sess: &ParseSess,\n     return res;\n }\n \n-fn strip_test_functions(diagnostic: &diagnostic::SpanHandler, krate: ast::Crate)\n+fn strip_test_functions(diagnostic: &errors::Handler, krate: ast::Crate)\n                         -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n@@ -688,7 +688,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n         Some(id) => vec![id],\n         None => {\n             let diag = cx.span_diagnostic;\n-            diag.handler.bug(\"expected to find top-level re-export name, but found None\");\n+            diag.bug(\"expected to find top-level re-export name, but found None\");\n         }\n     };\n     visible_path.extend(path);"}, {"sha": "b76384ffb4adaf3bafa52b6c2bb2195d678875d4", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -203,7 +203,7 @@ use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{self, DUMMY_SP};\n use syntax::codemap::Span;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{intern, InternedString};\n@@ -742,7 +742,7 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-fn find_repr_type_name(diagnostic: &SpanHandler,\n+fn find_repr_type_name(diagnostic: &Handler,\n                        type_attrs: &[ast::Attribute]) -> &'static str {\n     let mut repr_type_name = \"i32\";\n     for a in type_attrs {"}, {"sha": "01dc9662588bfab02877dee362ad170fa407ec99", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -39,7 +39,7 @@ use syntax::parse::token::intern;\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use syntax::diagnostic::FatalError;\n+        use syntax::errors::FatalError;\n         match $e {\n             Ok(e) => e,\n             Err(FatalError) => panic!(FatalError)"}, {"sha": "7c1a45d020b22d61c84a280965eeffd773b31e3e", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -44,7 +44,7 @@ fn with_error_checking_parse<T, F>(s: String, f: F) -> PResult<T> where\n     let mut p = string_to_parser(&ps, s);\n     let x = f(&mut p);\n \n-    if ps.span_diagnostic.handler().has_errors() || p.token != token::Eof {\n+    if ps.span_diagnostic.has_errors() || p.token != token::Eof {\n         return Err(p.fatal(\"parse error\"));\n     }\n "}, {"sha": "e3eeeb863568800949e95c08d3bbe57d9910d2ef", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2902965cb53d2afd09ea2ce7b3f9c314dc7b072/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=c2902965cb53d2afd09ea2ce7b3f9c314dc7b072", "patch": "@@ -23,7 +23,7 @@ extern crate syntax;\n use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n-use syntax::{diagnostics, diagnostic};\n+use syntax::{diagnostics, errors};\n \n use std::path::PathBuf;\n \n@@ -35,7 +35,7 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     fn early_callback(&mut self,\n                       _: &getopts::Matches,\n                       _: &diagnostics::registry::Registry,\n-                      _: diagnostic::ColorConfig)\n+                      _: errors::emitter::ColorConfig)\n                       -> Compilation {\n         self.count *= 2;\n         Compilation::Continue"}]}