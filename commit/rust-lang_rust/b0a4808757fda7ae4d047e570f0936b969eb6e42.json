{"sha": "b0a4808757fda7ae4d047e570f0936b969eb6e42", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYTQ4MDg3NTdmZGE3YWU0ZDA0N2U1NzBmMDkzNmI5NjllYjZlNDI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-24T07:29:56Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-24T07:39:15Z"}, "message": "Remove direct variant-dispatch entirely from trans_struct_drop.\n\nThis addresses to-do in my code, and simplifies this method a lot to boot.\n\n(The necessary enum dispatch has now effectively been shifted entirely\ninto the scheduled cleanup code for the enum contents.)", "tree": {"sha": "7cb075da0ae5db804ff1e06a07e18ebe9e1cb249", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cb075da0ae5db804ff1e06a07e18ebe9e1cb249"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0a4808757fda7ae4d047e570f0936b969eb6e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a4808757fda7ae4d047e570f0936b969eb6e42", "html_url": "https://github.com/rust-lang/rust/commit/b0a4808757fda7ae4d047e570f0936b969eb6e42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0a4808757fda7ae4d047e570f0936b969eb6e42/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8", "html_url": "https://github.com/rust-lang/rust/commit/d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8"}], "stats": {"total": 78, "additions": 19, "deletions": 59}, "files": [{"sha": "652f6ad366aaa09604301d0f2a9c7e282598d70f", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 19, "deletions": 59, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4808757fda7ae4d047e570f0936b969eb6e42/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4808757fda7ae4d047e570f0936b969eb6e42/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=b0a4808757fda7ae4d047e570f0936b969eb6e42", "patch": "@@ -30,7 +30,6 @@ use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n-use trans::datum;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n@@ -361,75 +360,36 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  substs: &subst::Substs<'tcx>)\n                                  -> Block<'blk, 'tcx>\n {\n-    let repr = adt::represent_type(bcx.ccx(), t);\n+    debug!(\"trans_struct_drop t: {}\", bcx.ty_to_string(t));\n \n     // Find and call the actual destructor\n-    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t,\n-                                 class_did, substs);\n+    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t, class_did, substs);\n \n-    // The first argument is the \"self\" argument for drop\n+    // Class dtors have no explicit args, so the params should\n+    // just consist of the environment (self).\n     let params = unsafe {\n         let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n         ty.element_type().func_params()\n     };\n+    assert_eq!(params.len(), 1);\n \n-    let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n-    let self_ty = match fty.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n-            let sig = ty::erase_late_bound_regions(bcx.tcx(), &f.sig);\n-            assert!(sig.inputs.len() == 1);\n-            sig.inputs[0]\n-        }\n-        _ => bcx.sess().bug(&format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty)))\n-    };\n-\n-    let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n-        (v0, None)\n-    } else {\n-        let data = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-        let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n-        (Load(bcx, data), Some(Load(bcx, info)))\n-    };\n+    // Be sure to put the contents into a scope so we can use an invoke\n+    // instruction to call the user destructor but still call the field\n+    // destructors if the user destructor panics.\n+    //\n+    // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n+    // might well consider changing below to more direct code.\n+    let contents_scope = bcx.fcx.push_custom_cleanup_scope();\n \n-    debug!(\"trans_struct_drop t: {} fty: {} self_ty: {}\",\n-           bcx.ty_to_string(t), bcx.ty_to_string(fty), bcx.ty_to_string(self_ty));\n-    // TODO: surely no reason to keep dispatching on variants here.\n-    adt::fold_variants(bcx, &*repr, struct_data, |variant_cx, struct_info, value| {\n-        debug!(\"trans_struct_drop fold_variant: struct_info: {:?}\", struct_info);\n-        // Be sure to put the enum contents into a scope so we can use an invoke\n-        // instruction to call the user destructor but still call the field\n-        // destructors if the user destructor panics.\n-        let field_scope = variant_cx.fcx.push_custom_cleanup_scope();\n-        variant_cx.fcx.schedule_drop_enum_contents(cleanup::CustomScope(field_scope), v0, t);\n-\n-        // Class dtors have no explicit args, so the params should\n-        // just consist of the environment (self).\n-        assert_eq!(params.len(), 1);\n-        let self_arg = if type_is_fat_ptr(bcx.tcx(), self_ty) {\n-            // The dtor expects a fat pointer, so make one, even if we have to fake it.\n-            let scratch = datum::rvalue_scratch_datum(bcx, t, \"__fat_ptr_drop_self\");\n-            Store(bcx, value, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n-            Store(bcx,\n-                  // If we just had a thin pointer, make a fat pointer by sticking\n-                  // null where we put the unsizing info. This works because t\n-                  // is a sized type, so we will only unpack the fat pointer, never\n-                  // use the fake info.\n-                  info.unwrap_or(C_null(Type::i8p(bcx.ccx()))),\n-                  GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n-            PointerCast(variant_cx, scratch.val, params[0])\n-        } else {\n-            PointerCast(variant_cx, value, params[0])\n-        };\n+    // Issue #23611: schedule cleanup of contents, re-inspecting the\n+    // discriminant (if any) in case of variant swap in drop code.\n+    bcx.fcx.schedule_drop_enum_contents(cleanup::CustomScope(contents_scope), v0, t);\n \n-        let dtor_ty = ty::mk_ctor_fn(bcx.tcx(),\n-                                     class_did,\n-                                     &[get_drop_glue_type(bcx.ccx(), t)],\n-                                     ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &[self_arg], dtor_ty, DebugLoc::None);\n+    let glue_type = get_drop_glue_type(bcx.ccx(), t);\n+    let dtor_ty = ty::mk_ctor_fn(bcx.tcx(), class_did, &[glue_type], ty::mk_nil(bcx.tcx()));\n+    let (_, bcx) = invoke(bcx, dtor_addr, &[v0], dtor_ty, DebugLoc::None);\n \n-        variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope)\n-    })\n+    bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n \n fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)"}]}