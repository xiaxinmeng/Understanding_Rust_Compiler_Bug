{"sha": "9b6339e4b9747d473270baa42e77e1d2fff39bf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNjMzOWU0Yjk3NDdkNDczMjcwYmFhNDJlNzdlMWQyZmZmMzliZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-23T04:49:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-23T04:49:47Z"}, "message": "Auto merge of #82271 - Aaron1011:debug-refcell, r=m-ou-se\n\nAdd `debug-refcell` feature to libcore\n\nSee https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Attaching.20backtraces.20to.20RefCell/near/226273614\nfor some background discussion\n\nThis PR adds a new off-by-default feature `debug-refcell` to libcore.\nWhen enabled, this feature stores additional debugging information in\n`RefCell`. This information is included in the panic message when\n`borrow()` or `borrow_mut()` panics, to make it easier to track down the\nsource of the issue.\n\nCurrently, we store the caller location for the earliest active borrow.\nThis has a number of advantages:\n* There is only a constant amount of overhead per `RefCell`\n* We don't need any heap memory, so it can easily be implemented in core\n* Since we are storing the *earliest* active borrow, we don't need any\n  extra logic in the `Drop` implementation for `Ref` and `RefMut`\n\nLimitations:\n* We only store the caller location, not a full `Backtrace`. Until\n  we get support for `Backtrace` in libcore, this is the best tha we can\ndo.\n* The captured location is only displayed when `borrow()` or\n  `borrow_mut()` panics. If a crate calls `try_borrow().unwrap()`\n  or `try_borrow_mut().unwrap()`, this extra information will be lost.\n\nTo make testing easier, I've enabled the `debug-refcell` feature by\ndefault. I'm not sure how to write a test for this feature - we would\nneed to rebuild core from the test framework, and create a separate\nsysroot.\n\nSince this feature will be off-by-default, users will need to use\n`xargo` or `cargo -Z build-std` to enable this feature. For users using\na prebuilt standard library, this feature will be disabled with zero\noverhead.\n\nI've created a simple test program:\n\n```rust\nuse std::cell::RefCell;\n\nfn main() {\n    let _ = std::panic::catch_unwind(|| {\n        let val = RefCell::new(true);\n        let _first = val.borrow();\n        let _second = val.borrow();\n        let _third = val.borrow_mut();\n    });\n\n    let _ = std::panic::catch_unwind(|| {\n        let val  = RefCell::new(true);\n        let first = val.borrow_mut();\n        drop(first);\n\n        let _second = val.borrow_mut();\n\n        let _thid = val.borrow();\n    });\n}\n```\n\nwhich produces the following output:\n\n```\nthread 'main' panicked at 'already borrowed: BorrowMutError at refcell_test.rs:6:26', refcell_test.rs:8:26\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nthread 'main' panicked at 'already mutably borrowed: BorrowError at refcell_test.rs:16:27', refcell_test.rs:18:25\n```", "tree": {"sha": "e96ec38118428561cd1eb0ac653e065b8de4d686", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e96ec38118428561cd1eb0ac653e065b8de4d686"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b6339e4b9747d473270baa42e77e1d2fff39bf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b6339e4b9747d473270baa42e77e1d2fff39bf4", "html_url": "https://github.com/rust-lang/rust/commit/9b6339e4b9747d473270baa42e77e1d2fff39bf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b6339e4b9747d473270baa42e77e1d2fff39bf4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd94f4aa9683158c7df96b9661be193c39a55ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd94f4aa9683158c7df96b9661be193c39a55ed", "html_url": "https://github.com/rust-lang/rust/commit/2bd94f4aa9683158c7df96b9661be193c39a55ed"}, {"sha": "a23273e82c8156974553e43f7d61826651397fbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a23273e82c8156974553e43f7d61826651397fbc", "html_url": "https://github.com/rust-lang/rust/commit/a23273e82c8156974553e43f7d61826651397fbc"}], "stats": {"total": 87, "additions": 76, "deletions": 11}, "files": [{"sha": "b6aaf078cf00d6ad140fa5add446d838cf3a4f59", "filename": "library/core/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b6339e4b9747d473270baa42e77e1d2fff39bf4/library%2Fcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9b6339e4b9747d473270baa42e77e1d2fff39bf4/library%2Fcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2FCargo.toml?ref=9b6339e4b9747d473270baa42e77e1d2fff39bf4", "patch": "@@ -28,3 +28,6 @@ rand = \"0.7\"\n [features]\n # Make panics and failed asserts immediately abort without formatting any message\n panic_immediate_abort = []\n+# Make `RefCell` store additional debugging information, which is printed out when\n+# a borrow error occurs\n+debug_refcell = []"}, {"sha": "770169219aad2470d9f67000bd575084fc3d1aad", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 73, "deletions": 11, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9b6339e4b9747d473270baa42e77e1d2fff39bf4/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b6339e4b9747d473270baa42e77e1d2fff39bf4/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=9b6339e4b9747d473270baa42e77e1d2fff39bf4", "patch": "@@ -575,19 +575,32 @@ impl<T> Cell<[T]> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T: ?Sized> {\n     borrow: Cell<BorrowFlag>,\n+    // Stores the location of the earliest currently active borrow.\n+    // This gets updated whenver we go from having zero borrows\n+    // to having a single borrow. When a borrow occurs, this gets included\n+    // in the generated `BorroeError/`BorrowMutError`\n+    #[cfg(feature = \"debug_refcell\")]\n+    borrowed_at: Cell<Option<&'static crate::panic::Location<'static>>>,\n     value: UnsafeCell<T>,\n }\n \n /// An error returned by [`RefCell::try_borrow`].\n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n pub struct BorrowError {\n     _private: (),\n+    #[cfg(feature = \"debug_refcell\")]\n+    location: &'static crate::panic::Location<'static>,\n }\n \n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n impl Debug for BorrowError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BorrowError\").finish()\n+        let mut builder = f.debug_struct(\"BorrowError\");\n+\n+        #[cfg(feature = \"debug_refcell\")]\n+        builder.field(\"location\", self.location);\n+\n+        builder.finish()\n     }\n }\n \n@@ -602,12 +615,19 @@ impl Display for BorrowError {\n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n pub struct BorrowMutError {\n     _private: (),\n+    #[cfg(feature = \"debug_refcell\")]\n+    location: &'static crate::panic::Location<'static>,\n }\n \n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n impl Debug for BorrowMutError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BorrowMutError\").finish()\n+        let mut builder = f.debug_struct(\"BorrowMutError\");\n+\n+        #[cfg(feature = \"debug_refcell\")]\n+        builder.field(\"location\", self.location);\n+\n+        builder.finish()\n     }\n }\n \n@@ -658,7 +678,12 @@ impl<T> RefCell<T> {\n     #[rustc_const_stable(feature = \"const_refcell_new\", since = \"1.24.0\")]\n     #[inline]\n     pub const fn new(value: T) -> RefCell<T> {\n-        RefCell { value: UnsafeCell::new(value), borrow: Cell::new(UNUSED) }\n+        RefCell {\n+            value: UnsafeCell::new(value),\n+            borrow: Cell::new(UNUSED),\n+            #[cfg(feature = \"debug_refcell\")]\n+            borrowed_at: Cell::new(None),\n+        }\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n@@ -823,12 +848,29 @@ impl<T: ?Sized> RefCell<T> {\n     /// ```\n     #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n     #[inline]\n+    #[cfg_attr(feature = \"debug_refcell\", track_caller)]\n     pub fn try_borrow(&self) -> Result<Ref<'_, T>, BorrowError> {\n         match BorrowRef::new(&self.borrow) {\n-            // SAFETY: `BorrowRef` ensures that there is only immutable access\n-            // to the value while borrowed.\n-            Some(b) => Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b }),\n-            None => Err(BorrowError { _private: () }),\n+            Some(b) => {\n+                #[cfg(feature = \"debug_refcell\")]\n+                {\n+                    // `borrowed_at` is always the *first* active borrow\n+                    if b.borrow.get() == 1 {\n+                        self.borrowed_at.set(Some(crate::panic::Location::caller()));\n+                    }\n+                }\n+\n+                // SAFETY: `BorrowRef` ensures that there is only immutable access\n+                // to the value while borrowed.\n+                Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b })\n+            }\n+            None => Err(BorrowError {\n+                _private: (),\n+                // If a borrow occured, then we must already have an outstanding borrow,\n+                // so `borrowed_at` will be `Some`\n+                #[cfg(feature = \"debug_refcell\")]\n+                location: self.borrowed_at.get().unwrap(),\n+            }),\n         }\n     }\n \n@@ -896,11 +938,25 @@ impl<T: ?Sized> RefCell<T> {\n     /// ```\n     #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n     #[inline]\n+    #[cfg_attr(feature = \"debug_refcell\", track_caller)]\n     pub fn try_borrow_mut(&self) -> Result<RefMut<'_, T>, BorrowMutError> {\n         match BorrowRefMut::new(&self.borrow) {\n-            // SAFETY: `BorrowRef` guarantees unique access.\n-            Some(b) => Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b }),\n-            None => Err(BorrowMutError { _private: () }),\n+            Some(b) => {\n+                #[cfg(feature = \"debug_refcell\")]\n+                {\n+                    self.borrowed_at.set(Some(crate::panic::Location::caller()));\n+                }\n+\n+                // SAFETY: `BorrowRef` guarantees unique access.\n+                Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b })\n+            }\n+            None => Err(BorrowMutError {\n+                _private: (),\n+                // If a borrow occured, then we must already have an outstanding borrow,\n+                // so `borrowed_at` will be `Some`\n+                #[cfg(feature = \"debug_refcell\")]\n+                location: self.borrowed_at.get().unwrap(),\n+            }),\n         }\n     }\n \n@@ -1016,7 +1072,13 @@ impl<T: ?Sized> RefCell<T> {\n             // and is thus guaranteed to be valid for the lifetime of `self`.\n             Ok(unsafe { &*self.value.get() })\n         } else {\n-            Err(BorrowError { _private: () })\n+            Err(BorrowError {\n+                _private: (),\n+                // If a borrow occured, then we must already have an outstanding borrow,\n+                // so `borrowed_at` will be `Some`\n+                #[cfg(feature = \"debug_refcell\")]\n+                location: self.borrowed_at.get().unwrap(),\n+            })\n         }\n     }\n }"}]}