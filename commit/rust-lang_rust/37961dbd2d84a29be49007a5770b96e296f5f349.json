{"sha": "37961dbd2d84a29be49007a5770b96e296f5f349", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3OTYxZGJkMmQ4NGEyOWJlNDkwMDdhNTc3MGI5NmUyOTZmNWYzNDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-25T03:00:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-25T03:00:30Z"}, "message": "Auto merge of #55959 - matthewjasper:remove-end-region, r=nikomatsakis\n\nCleanup from lexical MIR borrowck removal\n\nLexical MIR borrowck was removed months ago now, and `EndRegion`s are no longer used for MIRI verification.\n\n* Remove `rustc::mir::StatementKind::EndRegion` and the `-Zemit_end_regions` flag\n* Use `RegionVid` instead of `Region` in BorrowSet\n* Rewrite drop generation to create fewer goto terminators.\n\nr? @nikomatsakis", "tree": {"sha": "3e5e4ab50aca7ace299809d9923f886b5f7eddc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e5e4ab50aca7ace299809d9923f886b5f7eddc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37961dbd2d84a29be49007a5770b96e296f5f349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37961dbd2d84a29be49007a5770b96e296f5f349", "html_url": "https://github.com/rust-lang/rust/commit/37961dbd2d84a29be49007a5770b96e296f5f349", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37961dbd2d84a29be49007a5770b96e296f5f349/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dd94c133ead2cd62636a876d6d72a2a00348943", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd94c133ead2cd62636a876d6d72a2a00348943", "html_url": "https://github.com/rust-lang/rust/commit/2dd94c133ead2cd62636a876d6d72a2a00348943"}, {"sha": "1d7fc0ca500d8e532e7b1019397baec353560c26", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d7fc0ca500d8e532e7b1019397baec353560c26", "html_url": "https://github.com/rust-lang/rust/commit/1d7fc0ca500d8e532e7b1019397baec353560c26"}], "stats": {"total": 1767, "additions": 207, "deletions": 1560}, "files": [{"sha": "d98bb82aabad1268a0232e1aa90f0b8b2ae90627", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -217,9 +217,6 @@ for mir::StatementKind<'gcx> {\n             mir::StatementKind::StorageDead(ref place) => {\n                 place.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::EndRegion(ref region_scope) => {\n-                region_scope.hash_stable(hcx, hasher);\n-            }\n             mir::StatementKind::EscapeToRaw(ref place) => {\n                 place.hash_stable(hcx, hasher);\n             }"}, {"sha": "a9ea1c9a1093141cd3a7bef89306756c51f12baa", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -15,7 +15,6 @@\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use hir::{self, HirId, InlineAsm};\n-use middle::region;\n use mir::interpret::{ConstValue, EvalErrorKind, Scalar};\n use mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n@@ -1789,10 +1788,6 @@ pub enum StatementKind<'tcx> {\n     /// for more details.\n     EscapeToRaw(Operand<'tcx>),\n \n-    /// Mark one terminating point of a region scope (i.e. static region).\n-    /// (The starting point(s) arise implicitly from borrows.)\n-    EndRegion(region::Scope),\n-\n     /// Encodes a user's type ascription. These need to be preserved\n     /// intact so that NLL can respect them. For example:\n     ///\n@@ -1846,8 +1841,6 @@ impl<'tcx> Debug for Statement<'tcx> {\n         match self.kind {\n             Assign(ref place, ref rv) => write!(fmt, \"{:?} = {:?}\", place, rv),\n             FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n-            // (reuse lifetime rendering policy from ppaux.)\n-            EndRegion(ref ce) => write!(fmt, \"EndRegion({})\", ty::ReScope(*ce)),\n             Retag { fn_entry, ref place } =>\n                 write!(fmt, \"Retag({}{:?})\", if fn_entry { \"[fn entry] \" } else { \"\" }, place),\n             EscapeToRaw(ref place) => write!(fmt, \"EscapeToRaw({:?})\", place),\n@@ -3028,7 +3021,6 @@ EnumTypeFoldableImpl! {\n         (StatementKind::InlineAsm) { asm, outputs, inputs },\n         (StatementKind::Retag) { fn_entry, place },\n         (StatementKind::EscapeToRaw)(place),\n-        (StatementKind::EndRegion)(a),\n         (StatementKind::AscribeUserType)(a, v, b),\n         (StatementKind::Nop),\n     }"}, {"sha": "0c9b06a8d8c7d2e3431045d76f418b4438785b16", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -377,7 +377,6 @@ macro_rules! make_mir_visitor {\n                             location\n                         );\n                     }\n-                    StatementKind::EndRegion(_) => {}\n                     StatementKind::SetDiscriminant{ ref $($mutability)* place, .. } => {\n                         self.visit_place(\n                             place,"}, {"sha": "3fd22793a08a0698bdca308f30323c4f884c4786", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -1149,8 +1149,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"when debug-printing compiler state, do not include spans\"), // o/w tests have closure@path\n     identify_regions: bool = (false, parse_bool, [UNTRACKED],\n         \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n-    emit_end_regions: bool = (false, parse_bool, [UNTRACKED],\n-        \"emit EndRegion as part of MIR; enable transforms that solely process EndRegion\"),\n     borrowck: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"select which borrowck is used (`ast`, `mir`, `migrate`, or `compare`)\"),\n     two_phase_borrows: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "1b947c276f3b37d30a7b33e23de7223b0a0c2ee3", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -1540,13 +1540,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Should we emit EndRegion MIR statements? These are consumed by\n-    /// MIR borrowck, but not when NLL is used.\n-    pub fn emit_end_regions(self) -> bool {\n-        self.sess.opts.debugging_opts.emit_end_regions ||\n-            self.use_mir_borrowck()\n-    }\n-\n     #[inline]\n     pub fn local_crate_exports_generics(self) -> bool {\n         debug_assert!(self.sess.opts.share_generics());"}, {"sha": "0d058c85f333bec0a310e0901832b25b8b5e9b8d", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -105,7 +105,6 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx\n             }\n             mir::StatementKind::FakeRead(..) |\n-            mir::StatementKind::EndRegion(..) |\n             mir::StatementKind::Retag { .. } |\n             mir::StatementKind::EscapeToRaw { .. } |\n             mir::StatementKind::AscribeUserType(..) |"}, {"sha": "fd7dc7fc4bd3af11d80d221fd86101b15bcbc9aa", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n use borrow_check::place_ext::PlaceExt;\n+use borrow_check::nll::ToRegionVid;\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n use rustc::mir::traversal;\n use rustc::mir::visit::{\n     PlaceContext, Visitor, NonUseContext, MutatingUseContext, NonMutatingUseContext\n };\n use rustc::mir::{self, Location, Mir, Place, Local};\n-use rustc::ty::{Region, TyCtxt};\n+use rustc::ty::{RegionVid, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::bit_set::BitSet;\n@@ -42,7 +43,7 @@ crate struct BorrowSet<'tcx> {\n \n     /// Every borrow has a region; this maps each such regions back to\n     /// its borrow-indexes.\n-    crate region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+    crate region_map: FxHashMap<RegionVid, FxHashSet<BorrowIndex>>,\n \n     /// Map from local to all the borrows on that local\n     crate local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n@@ -77,7 +78,7 @@ crate struct BorrowData<'tcx> {\n     /// What kind of borrow this is\n     crate kind: mir::BorrowKind,\n     /// The region for which this borrow is live\n-    crate region: Region<'tcx>,\n+    crate region: RegionVid,\n     /// Place from which we are borrowing\n     crate borrowed_place: mir::Place<'tcx>,\n     /// Place to which the borrow was stored\n@@ -92,13 +93,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n             mir::BorrowKind::Unique => \"uniq \",\n             mir::BorrowKind::Mut { .. } => \"mut \",\n         };\n-        let region = self.region.to_string();\n-        let separator = if !region.is_empty() {\n-            \" \"\n-        } else {\n-            \"\"\n-        };\n-        write!(w, \"&{}{}{}{:?}\", region, separator, kind, self.borrowed_place)\n+        write!(w, \"&{:?} {}{:?}\", self.region, kind, self.borrowed_place)\n     }\n }\n \n@@ -189,7 +184,7 @@ struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n     activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n-    region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+    region_map: FxHashMap<RegionVid, FxHashSet<BorrowIndex>>,\n     local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n \n     /// When we encounter a 2-phase borrow statement, it will always\n@@ -219,6 +214,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n                 return;\n             }\n \n+            let region = region.to_region_vid();\n+\n             let borrow = BorrowData {\n                 kind,\n                 region,\n@@ -230,7 +227,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             let idx = self.idx_vec.push(borrow);\n             self.location_map.insert(location, idx);\n \n-            self.insert_as_pending_if_two_phase(location, &assigned_place, region, kind, idx);\n+            self.insert_as_pending_if_two_phase(location, &assigned_place, kind, idx);\n \n             self.region_map.entry(region).or_default().insert(idx);\n             if let Some(local) = borrowed_place.root_local() {\n@@ -314,7 +311,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             let borrow_data = &self.idx_vec[borrow_index];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n-            assert_eq!(borrow_data.region, region);\n+            assert_eq!(borrow_data.region, region.to_region_vid());\n             assert_eq!(borrow_data.borrowed_place, *place);\n         }\n \n@@ -347,13 +344,12 @@ impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n         &mut self,\n         start_location: Location,\n         assigned_place: &mir::Place<'tcx>,\n-        region: Region<'tcx>,\n         kind: mir::BorrowKind,\n         borrow_index: BorrowIndex,\n     ) {\n         debug!(\n-            \"Borrows::insert_as_pending_if_two_phase({:?}, {:?}, {:?}, {:?})\",\n-            start_location, assigned_place, region, borrow_index,\n+            \"Borrows::insert_as_pending_if_two_phase({:?}, {:?}, {:?})\",\n+            start_location, assigned_place, borrow_index,\n         );\n \n         if !self.allow_two_phase_borrow(kind) {"}, {"sha": "76ba6ae5de6ee99e8586faa2e070b473b5d18a40", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -14,7 +14,6 @@ use borrow_check::nll::region_infer::RegionInferenceContext;\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::middle::borrowck::SignalledError;\n@@ -162,10 +161,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         move_data: move_data,\n         param_env: param_env,\n     };\n-    let body_id = match tcx.def_key(def_id).disambiguated_data.data {\n-        DefPathData::StructCtor | DefPathData::EnumVariant(_) => None,\n-        _ => Some(tcx.hir.body_owned_by(id)),\n-    };\n \n     let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n@@ -212,7 +207,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, mir, regioncx.clone(), def_id, body_id, &borrow_set),\n+        Borrows::new(tcx, mir, regioncx.clone(), &borrow_set),\n         |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n@@ -592,10 +587,6 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     self.consume_operand(context, (input, span), flow_state);\n                 }\n             }\n-            StatementKind::EndRegion(ref _rgn) => {\n-                // ignored when consuming results (update to\n-                // flow_state already handled).\n-            }\n             StatementKind::Nop\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Retag { .. }"}, {"sha": "bb9a29b055b7f849188d76fb44343ad8fa19bfdf", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -206,7 +206,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mir = self.mir;\n         let tcx = self.infcx.tcx;\n \n-        let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n+        let borrow_region_vid = borrow.region;\n         debug!(\n             \"explain_why_borrow_contains_point: borrow_region_vid={:?}\",\n             borrow_region_vid"}, {"sha": "8af23a8813a9e6d8eac91be8c07d60a2e0461433", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -132,8 +132,6 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                     self.consume_operand(context, input);\n                 }\n             }\n-            // EndRegion matters to older NLL/MIR AST borrowck, not to alias NLL\n-            StatementKind::EndRegion(..) |\n             StatementKind::Nop |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Retag { .. } |"}, {"sha": "e9f749ac092d26d25a1e83238cd7d14fbed2dd1b", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::subst::Substs;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{BasicBlock, Location, Mir, Statement, StatementKind, UserTypeAnnotation};\n+use rustc::mir::{Location, Mir, UserTypeAnnotation};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -119,16 +119,4 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n \n         debug!(\"visit_closure_substs: substs={:?}\", substs);\n     }\n-\n-    fn visit_statement(\n-        &mut self,\n-        block: BasicBlock,\n-        statement: &mut Statement<'tcx>,\n-        location: Location,\n-    ) {\n-        if let StatementKind::EndRegion(_) = statement.kind {\n-            statement.kind = StatementKind::Nop;\n-        }\n-        self.super_statement(block, statement, location);\n-    }\n }"}, {"sha": "b978d8c9d0ae0db232069d65e65eedbbd22dc3fa", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -1314,7 +1314,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             | StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)\n             | StatementKind::InlineAsm { .. }\n-            | StatementKind::EndRegion(_)\n             | StatementKind::Retag { .. }\n             | StatementKind::EscapeToRaw { .. }\n             | StatementKind::Nop => {}"}, {"sha": "2efb75c232d2e15529c9fb73d6f7a62d00dc1411", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -14,9 +14,7 @@\n //! Routines for manipulating the control-flow graph.\n \n use build::CFG;\n-use rustc::middle::region;\n use rustc::mir::*;\n-use rustc::ty::TyCtxt;\n \n impl<'tcx> CFG<'tcx> {\n     pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n@@ -45,30 +43,6 @@ impl<'tcx> CFG<'tcx> {\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n-    pub fn push_end_region<'a, 'gcx:'a+'tcx>(&mut self,\n-                                             tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                             block: BasicBlock,\n-                                             source_info: SourceInfo,\n-                                             region_scope: region::Scope) {\n-        if tcx.emit_end_regions() {\n-            if let region::ScopeData::CallSite = region_scope.data {\n-                // The CallSite scope (aka the root scope) is sort of weird, in that it is\n-                // supposed to \"separate\" the \"interior\" and \"exterior\" of a closure. Being\n-                // that, it is not really a part of the region hierarchy, but for some\n-                // reason it *is* considered a part of it.\n-                //\n-                // It should die a hopefully painful death with NLL, so let's leave this hack\n-                // for now so that nobody can complain about soundness.\n-                return\n-            }\n-\n-            self.push(block, Statement {\n-                source_info,\n-                kind: StatementKind::EndRegion(region_scope),\n-            });\n-        }\n-    }\n-\n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n                        source_info: SourceInfo,"}, {"sha": "2a11f24095b063f95066036c616811e6ca4a84e6", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 147, "deletions": 150, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -90,12 +90,13 @@ should go to.\n use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n use hair::LintLevel;\n use rustc::middle::region;\n-use rustc::ty::{Ty, TyCtxt};\n+use rustc::ty::Ty;\n use rustc::hir;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::mir::*;\n use syntax_pos::{Span};\n use rustc_data_structures::fx::FxHashMap;\n+use std::collections::hash_map::Entry;\n \n #[derive(Debug)]\n pub struct Scope<'tcx> {\n@@ -224,7 +225,7 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     ///\n-    /// `storage_only` controls whether to invalidate only drop paths run `StorageDead`.\n+    /// `storage_only` controls whether to invalidate only drop paths that run `StorageDead`.\n     /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n     /// top-of-scope (as opposed to dependent scopes).\n     fn invalidate_cache(&mut self, storage_only: bool, this_scope_only: bool) {\n@@ -242,8 +243,8 @@ impl<'tcx> Scope<'tcx> {\n         }\n \n         if !storage_only && !this_scope_only {\n-            for dropdata in &mut self.drops {\n-                if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n+            for drop_data in &mut self.drops {\n+                if let DropKind::Value { ref mut cached_block } = drop_data.kind {\n                     cached_block.invalidate();\n                 }\n             }\n@@ -323,7 +324,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let parent_hir_id =\n                     tcx.hir.definitions().node_to_hir_id(\n                         self.source_scope_local_data[source_scope].lint_root\n-                            );\n+                    );\n                 let current_hir_id =\n                     tcx.hir.definitions().node_to_hir_id(node_id);\n                 sets.lint_level_set(parent_hir_id) ==\n@@ -333,7 +334,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             if !same_lint_scopes {\n                 self.source_scope =\n                     self.new_source_scope(region_scope.1.span, lint_level,\n-                                              None);\n+                                          None);\n             }\n         }\n         self.push_scope(region_scope);\n@@ -381,24 +382,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let scope = self.scopes.pop().unwrap();\n         assert_eq!(scope.region_scope, region_scope.0);\n \n-        self.cfg.push_end_region(self.hir.tcx(), block, region_scope.1, scope.region_scope);\n-        let resume_block = self.resume_block();\n-        unpack!(block = build_scope_drops(&mut self.cfg,\n-                                          resume_block,\n-                                          &scope,\n-                                          &self.scopes,\n-                                          block,\n-                                          self.arg_count,\n-                                          false));\n+        let unwind_to = self.scopes.last().and_then(|next_scope| {\n+            next_scope.cached_unwind.get(false)\n+        }).unwrap_or_else(|| self.resume_block());\n+\n+        unpack!(block = build_scope_drops(\n+            &mut self.cfg,\n+            &scope,\n+            block,\n+            unwind_to,\n+            self.arg_count,\n+            false,\n+        ));\n \n         block.unit()\n     }\n \n \n     /// Branch out of `block` to `target`, exiting all scopes up to\n     /// and including `region_scope`.  This will insert whatever drops are\n-    /// needed, as well as tracking this exit for the SEME region. See\n-    /// module comment for details.\n+    /// needed. See module comment for details.\n     pub fn exit_scope(&mut self,\n                       span: Span,\n                       region_scope: (region::Scope, SourceInfo),\n@@ -416,41 +419,51 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n-        let may_panic = self.scopes[(len - scope_count)..].iter()\n-            .any(|s| s.drops.iter().any(|s| s.kind.may_panic()));\n+        let may_panic = self.scopes[(len - scope_count)..].iter().any(|s| s.needs_cleanup);\n         if may_panic {\n             self.diverge_cleanup();\n         }\n \n-        {\n-        let resume_block = self.resume_block();\n-        let mut rest = &mut self.scopes[(len - scope_count)..];\n-        while let Some((scope, rest_)) = {rest}.split_last_mut() {\n-            rest = rest_;\n-            block = if let Some(&e) = scope.cached_exits.get(&(target, region_scope.0)) {\n-                self.cfg.terminate(block, scope.source_info(span),\n-                                   TerminatorKind::Goto { target: e });\n-                return;\n-            } else {\n-                let b = self.cfg.start_new_block();\n-                self.cfg.terminate(block, scope.source_info(span),\n-                                   TerminatorKind::Goto { target: b });\n-                scope.cached_exits.insert((target, region_scope.0), b);\n-                b\n+        let mut scopes = self.scopes[(len - scope_count - 1)..].iter_mut().rev();\n+        let mut scope = scopes.next().unwrap();\n+        for next_scope in scopes {\n+            if scope.drops.is_empty() {\n+                scope = next_scope;\n+                continue;\n+            }\n+            let source_info = scope.source_info(span);\n+            block = match scope.cached_exits.entry((target, region_scope.0)) {\n+                Entry::Occupied(e) => {\n+                    self.cfg.terminate(block, source_info,\n+                                    TerminatorKind::Goto { target: *e.get() });\n+                    return;\n+                }\n+                Entry::Vacant(v) => {\n+                    let b = self.cfg.start_new_block();\n+                    self.cfg.terminate(block, source_info,\n+                                    TerminatorKind::Goto { target: b });\n+                    v.insert(b);\n+                    b\n+                }\n             };\n \n-            // End all regions for scopes out of which we are breaking.\n-            self.cfg.push_end_region(self.hir.tcx(), block, region_scope.1, scope.region_scope);\n+            let unwind_to = next_scope.cached_unwind.get(false).unwrap_or_else(|| {\n+                debug_assert!(!may_panic, \"cached block not present?\");\n+                START_BLOCK\n+            });\n \n-            unpack!(block = build_scope_drops(&mut self.cfg,\n-                                              resume_block,\n-                                              scope,\n-                                              rest,\n-                                              block,\n-                                              self.arg_count,\n-                                              false));\n-        }\n+            unpack!(block = build_scope_drops(\n+                &mut self.cfg,\n+                scope,\n+                block,\n+                unwind_to,\n+                self.arg_count,\n+                false,\n+            ));\n+\n+            scope = next_scope;\n         }\n+\n         let scope = &self.scopes[len - scope_count];\n         self.cfg.terminate(block, scope.source_info(span),\n                            TerminatorKind::Goto { target });\n@@ -465,20 +478,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        // Fill in the cache\n+        // Fill in the cache for unwinds\n         self.diverge_cleanup_gen(true);\n \n         let src_info = self.scopes[0].source_info(self.fn_span);\n+        let resume_block = self.resume_block();\n+        let mut scopes = self.scopes.iter_mut().rev().peekable();\n         let mut block = self.cfg.start_new_block();\n         let result = block;\n-        let resume_block = self.resume_block();\n-        let mut rest = &mut self.scopes[..];\n \n-        while let Some((scope, rest_)) = {rest}.split_last_mut() {\n-            rest = rest_;\n+        while let Some(scope) = scopes.next() {\n             if !scope.needs_cleanup {\n                 continue;\n             }\n+\n             block = if let Some(b) = scope.cached_generator_drop {\n                 self.cfg.terminate(block, src_info,\n                                    TerminatorKind::Goto { target: b });\n@@ -491,16 +504,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 b\n             };\n \n-            // End all regions for scopes out of which we are breaking.\n-            self.cfg.push_end_region(self.hir.tcx(), block, src_info, scope.region_scope);\n-\n-            unpack!(block = build_scope_drops(&mut self.cfg,\n-                                              resume_block,\n-                                              scope,\n-                                              rest,\n-                                              block,\n-                                              self.arg_count,\n-                                              true));\n+            let unwind_to = scopes.peek().as_ref().map(|scope| {\n+                scope.cached_unwind.get(true).unwrap_or_else(|| {\n+                    span_bug!(src_info.span, \"cached block not present?\")\n+                })\n+            }).unwrap_or(resume_block);\n+\n+            unpack!(block = build_scope_drops(\n+                &mut self.cfg,\n+                scope,\n+                block,\n+                unwind_to,\n+                self.arg_count,\n+                true,\n+            ));\n         }\n \n         self.cfg.terminate(block, src_info, TerminatorKind::GeneratorDrop);\n@@ -510,9 +527,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Creates a new source scope, nested in the current one.\n     pub fn new_source_scope(&mut self,\n-                                span: Span,\n-                                lint_level: LintLevel,\n-                                safety: Option<Safety>) -> SourceScope {\n+                            span: Span,\n+                            lint_level: LintLevel,\n+                            safety: Option<Safety>) -> SourceScope {\n         let parent = self.source_scope;\n         debug!(\"new_source_scope({:?}, {:?}, {:?}) - parent({:?})={:?}\",\n                span, lint_level, safety,\n@@ -749,8 +766,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Creates a path that performs all required cleanup for unwinding.\n     ///\n     /// This path terminates in Resume. Returns the start of the path.\n-    /// See module comment for more details. None indicates there\u2019s no\n-    /// cleanup to do at this point.\n+    /// See module comment for more details.\n     pub fn diverge_cleanup(&mut self) -> BasicBlock {\n         self.diverge_cleanup_gen(false)\n     }\n@@ -772,11 +788,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     fn diverge_cleanup_gen(&mut self, generator_drop: bool) -> BasicBlock {\n-        // To start, create the resume terminator.\n-        let mut target = self.resume_block();\n-\n-        let Builder { ref mut cfg, ref mut scopes, .. } = *self;\n-\n         // Build up the drops in **reverse** order. The end result will\n         // look like:\n         //\n@@ -788,11 +799,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // store caches. If everything is cached, we'll just walk right\n         // to left reading the cached results but never created anything.\n \n-        if scopes.iter().any(|scope| scope.needs_cleanup) {\n-            for scope in scopes.iter_mut() {\n-                target = build_diverge_scope(self.hir.tcx(), cfg, scope.region_scope_span,\n-                                             scope, target, generator_drop);\n-            }\n+        // Find the last cached block\n+        let (mut target, first_uncached) = if let Some(cached_index) = self.scopes.iter()\n+            .rposition(|scope| scope.cached_unwind.get(generator_drop).is_some()) {\n+            (self.scopes[cached_index].cached_unwind.get(generator_drop).unwrap(), cached_index + 1)\n+        } else {\n+            (self.resume_block(), 0)\n+        };\n+\n+        for scope in self.scopes[first_uncached..].iter_mut() {\n+            target = build_diverge_scope(&mut self.cfg, scope.region_scope_span,\n+                                         scope, target, generator_drop);\n         }\n \n         target\n@@ -866,64 +883,62 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n }\n \n /// Builds drops for pop_scope and exit_scope.\n-fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n-                           resume_block: BasicBlock,\n-                           scope: &Scope<'tcx>,\n-                           earlier_scopes: &[Scope<'tcx>],\n-                           mut block: BasicBlock,\n-                           arg_count: usize,\n-                           generator_drop: bool)\n-                           -> BlockAnd<()> {\n-    debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n-    let mut iter = scope.drops.iter().rev();\n-    while let Some(drop_data) = iter.next() {\n+fn build_scope_drops<'tcx>(\n+    cfg: &mut CFG<'tcx>,\n+    scope: &Scope<'tcx>,\n+    mut block: BasicBlock,\n+    last_unwind_to: BasicBlock,\n+    arg_count: usize,\n+    generator_drop: bool,\n+) -> BlockAnd<()> {\n+    debug!(\"build_scope_drops({:?} -> {:?}\", block, scope);\n+\n+    // Build up the drops in evaluation order. The end result will\n+    // look like:\n+    //\n+    // [SDs, drops[n]] --..> [SDs, drop[1]] -> [SDs, drop[0]] -> [[SDs]]\n+    //               |                    |                 |\n+    //               :                    |                 |\n+    //                                    V                 V\n+    // [drop[n]] -...-> [drop[1]] ------> [drop[0]] ------> [last_unwind_to]\n+    //\n+    // The horizontal arrows represent the execution path when the drops return\n+    // successfully. The downwards arrows represent the execution path when the\n+    // drops panic (panicking while unwinding will abort, so there's no need for\n+    // another set of arrows). The drops for the unwind path should have already\n+    // been generated by `diverge_cleanup_gen`.\n+    //\n+    // The code in this function reads from right to left.\n+    // Storage dead drops have to be done left to right (since we can only push\n+    // to the end of a Vec). So, we find the next drop and then call\n+    // push_storage_deads which will iterate backwards through them so that\n+    // they are added in the correct order.\n+\n+    let mut unwind_blocks = scope.drops.iter().rev().filter_map(|drop_data| {\n+        if let DropKind::Value { cached_block } = drop_data.kind {\n+            Some(cached_block.get(generator_drop).unwrap_or_else(|| {\n+                span_bug!(drop_data.span, \"cached block not present?\")\n+            }))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    // When we unwind from a drop, we start cleaning up from the next one, so\n+    // we don't need this block.\n+    unwind_blocks.next();\n+\n+    for drop_data in scope.drops.iter().rev() {\n         let source_info = scope.source_info(drop_data.span);\n         match drop_data.kind {\n             DropKind::Value { .. } => {\n-                // Try to find the next block with its cached block for us to\n-                // diverge into, either a previous block in this current scope or\n-                // the top of the previous scope.\n-                //\n-                // If it wasn't for EndRegion, we could just chain all the DropData\n-                // together and pick the first DropKind::Value. Please do that\n-                // when we replace EndRegion with NLL.\n-                let on_diverge = iter.clone().filter_map(|dd| {\n-                    match dd.kind {\n-                        DropKind::Value { cached_block } => Some(cached_block),\n-                        DropKind::Storage => None\n-                    }\n-                }).next().or_else(|| {\n-                    if earlier_scopes.iter().any(|scope| scope.needs_cleanup) {\n-                        // If *any* scope requires cleanup code to be run,\n-                        // we must use the cached unwind from the *topmost*\n-                        // scope, to ensure all EndRegions from surrounding\n-                        // scopes are executed before the drop code runs.\n-                        Some(earlier_scopes.last().unwrap().cached_unwind)\n-                    } else {\n-                        // We don't need any further cleanup, so return None\n-                        // to avoid creating a landing pad. We can skip\n-                        // EndRegions because all local regions end anyway\n-                        // when the function unwinds.\n-                        //\n-                        // This is an important optimization because LLVM is\n-                        // terrible at optimizing landing pads. FIXME: I think\n-                        // it would be cleaner and better to do this optimization\n-                        // in SimplifyCfg instead of here.\n-                        None\n-                    }\n-                });\n-\n-                let on_diverge = on_diverge.map(|cached_block| {\n-                    cached_block.get(generator_drop).unwrap_or_else(|| {\n-                        span_bug!(drop_data.span, \"cached block not present?\")\n-                    })\n-                });\n+                let unwind_to = unwind_blocks.next().unwrap_or(last_unwind_to);\n \n                 let next = cfg.start_new_block();\n                 cfg.terminate(block, source_info, TerminatorKind::Drop {\n                     location: drop_data.location.clone(),\n                     target: next,\n-                    unwind: Some(on_diverge.unwrap_or(resume_block))\n+                    unwind: Some(unwind_to)\n                 });\n                 block = next;\n             }\n@@ -950,21 +965,17 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n     block.unit()\n }\n \n-fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       cfg: &mut CFG<'tcx>,\n-                                       span: Span,\n-                                       scope: &mut Scope<'tcx>,\n-                                       mut target: BasicBlock,\n-                                       generator_drop: bool)\n-                                       -> BasicBlock\n+fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n+                             span: Span,\n+                             scope: &mut Scope<'tcx>,\n+                             mut target: BasicBlock,\n+                             generator_drop: bool)\n+                             -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n     // look like:\n     //\n-    //    [EndRegion Block] -> [drops[n]] -...-> [drops[0]] -> [Free] -> [target]\n-    //    |                                                         |\n-    //    +---------------------------------------------------------+\n-    //     code for scope\n+    //    [drops[n]] -...-> [drops[0]] -> [target]\n     //\n     // The code in this function reads from right to left. At each\n     // point, we check for cached blocks representing the\n@@ -1009,21 +1020,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         };\n     }\n \n-    // Finally, push the EndRegion block, used by mir-borrowck, and set\n-    // `cached_unwind` to point to it (Block becomes trivial goto after\n-    // pass that removes all EndRegions).\n-    target = {\n-        let cached_block = scope.cached_unwind.ref_mut(generator_drop);\n-        if let Some(cached_block) = *cached_block {\n-            cached_block\n-        } else {\n-            let block = cfg.start_new_cleanup_block();\n-            cfg.push_end_region(tcx, block, source_info(span), scope.region_scope);\n-            cfg.terminate(block, source_info(span), TerminatorKind::Goto { target });\n-            *cached_block = Some(block);\n-            block\n-        }\n-    };\n+    *scope.cached_unwind.ref_mut(generator_drop) = Some(target);\n \n     debug!(\"build_diverge_scope({:?}, {:?}) = {:?}\", scope, span, target);\n "}, {"sha": "27bc28ac81d8404ba30a42e3a65f62d4670716ae", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 10, "deletions": 87, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -12,18 +12,13 @@ use borrow_check::borrow_set::{BorrowSet, BorrowData};\n use borrow_check::place_ext::PlaceExt;\n \n use rustc;\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::region;\n use rustc::mir::{self, Location, Place, Mir};\n use rustc::ty::TyCtxt;\n-use rustc::ty::{RegionKind, RegionVid};\n-use rustc::ty::RegionKind::ReScope;\n+use rustc::ty::RegionVid;\n \n use rustc_data_structures::bit_set::{BitSet, BitSetOperator};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::sync::Lrc;\n \n use dataflow::{BitDenotation, BlockSets, InitialFlow};\n pub use dataflow::indexes::BorrowIndex;\n@@ -42,8 +37,6 @@ use std::rc::Rc;\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    scope_tree: Lrc<region::ScopeTree>,\n-    root_scope: Option<region::Scope>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n     borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n@@ -150,18 +143,8 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         mir: &'a Mir<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n-        def_id: DefId,\n-        body_id: Option<hir::BodyId>,\n         borrow_set: &Rc<BorrowSet<'tcx>>,\n     ) -> Self {\n-        let scope_tree = tcx.region_scope_tree(def_id);\n-        let root_scope = body_id.map(|body_id| {\n-            region::Scope {\n-                id: tcx.hir.body(body_id).value.hir_id.local_id,\n-                data: region::ScopeData::CallSite\n-            }\n-        });\n-\n         let mut borrows_out_of_scope_at_location = FxHashMap::default();\n         for (borrow_index, borrow_data) in borrow_set.borrows.iter_enumerated() {\n             let borrow_region = borrow_data.region.to_region_vid();\n@@ -177,8 +160,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir: mir,\n             borrow_set: borrow_set.clone(),\n             borrows_out_of_scope_at_location,\n-            scope_tree,\n-            root_scope,\n             _nonlexical_regioncx: nonlexical_regioncx,\n         }\n     }\n@@ -190,8 +171,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n-    /// That means either they went out of either a nonlexical scope, if we care about those\n-    /// at the moment, or the location represents a lexical EndRegion\n+    /// That means they went out of a nonlexical scope\n     fn kill_loans_out_of_scope_at_location(&self,\n                                            sets: &mut BlockSets<BorrowIndex>,\n                                            location: Location) {\n@@ -252,9 +232,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n         });\n \n         match stmt.kind {\n-            mir::StatementKind::EndRegion(_) => {\n-            }\n-\n             mir::StatementKind::Assign(ref lhs, ref rhs) => {\n                 // Make sure there are no remaining borrows for variables\n                 // that are assigned over.\n@@ -281,22 +258,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });\n \n-                    if let RegionKind::ReEmpty = region {\n-                        // If the borrowed value dies before the borrow is used, the region for\n-                        // the borrow can be empty. Don't track the borrow in that case.\n-                        debug!(\"Borrows::statement_effect_on_borrows \\\n-                                location: {:?} stmt: {:?} has empty region, killing {:?}\",\n-                               location, stmt.kind, index);\n-                        sets.kill(*index);\n-                        return\n-                    } else {\n-                        debug!(\"Borrows::statement_effect_on_borrows location: {:?} stmt: {:?}\",\n-                               location, stmt.kind);\n-                    }\n-\n-                    assert!(self.borrow_set.region_map.get(region).unwrap_or_else(|| {\n-                        panic!(\"could not find BorrowIndexs for region {:?}\", region);\n-                    }).contains(&index));\n+                    assert!(self.borrow_set.region_map\n+                        .get(&region.to_region_vid())\n+                        .unwrap_or_else(|| {\n+                            panic!(\"could not find BorrowIndexs for RegionVid {:?}\", region);\n+                        })\n+                        .contains(&index)\n+                    );\n                     sets.gen(*index);\n \n                     // Issue #46746: Two-phase borrows handles\n@@ -353,52 +321,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n         self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n-    fn terminator_effect(&self, sets: &mut BlockSets<BorrowIndex>, location: Location) {\n-        debug!(\"Borrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n-\n-        let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n-            panic!(\"could not find block at location {:?}\", location);\n-        });\n-\n-        let term = block.terminator();\n-        match term.kind {\n-            mir::TerminatorKind::Resume |\n-            mir::TerminatorKind::Return |\n-            mir::TerminatorKind::GeneratorDrop => {\n-                // When we return from the function, then all `ReScope`-style regions\n-                // are guaranteed to have ended.\n-                // Normally, there would be `EndRegion` statements that come before,\n-                // and hence most of these loans will already be dead -- but, in some cases\n-                // like unwind paths, we do not always emit `EndRegion` statements, so we\n-                // add some kills here as a \"backup\" and to avoid spurious error messages.\n-                for (borrow_index, borrow_data) in self.borrow_set.borrows.iter_enumerated() {\n-                    if let ReScope(scope) = borrow_data.region {\n-                        // Check that the scope is not actually a scope from a function that is\n-                        // a parent of our closure. Note that the CallSite scope itself is\n-                        // *outside* of the closure, for some weird reason.\n-                        if let Some(root_scope) = self.root_scope {\n-                            if *scope != root_scope &&\n-                                self.scope_tree.is_subscope_of(*scope, root_scope)\n-                            {\n-                                sets.kill(borrow_index);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            mir::TerminatorKind::Abort |\n-            mir::TerminatorKind::SwitchInt {..} |\n-            mir::TerminatorKind::Drop {..} |\n-            mir::TerminatorKind::DropAndReplace {..} |\n-            mir::TerminatorKind::Call {..} |\n-            mir::TerminatorKind::Assert {..} |\n-            mir::TerminatorKind::Yield {..} |\n-            mir::TerminatorKind::Goto {..} |\n-            mir::TerminatorKind::FalseEdges {..} |\n-            mir::TerminatorKind::FalseUnwind {..} |\n-            mir::TerminatorKind::Unreachable => {}\n-        }\n-    }\n+    fn terminator_effect(&self, _: &mut BlockSets<BorrowIndex>, _: Location) {}\n \n     fn propagate_call_return(&self,\n                              _in_out: &mut BitSet<BorrowIndex>,"}, {"sha": "3796b1cc4b0c84b2aaa14dde772c4acdb5bd0616", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -301,7 +301,6 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 span_bug!(stmt.source_info.span,\n                           \"SetDiscriminant should not exist during borrowck\");\n             }\n-            StatementKind::EndRegion(..) |\n             StatementKind::Retag { .. } |\n             StatementKind::EscapeToRaw { .. } |\n             StatementKind::AscribeUserType(..) |"}, {"sha": "8814118f65be4ef789150d7562f267b3b6f037be", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -129,7 +129,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             // Statements we do not track.\n-            EndRegion(..) => {}\n             AscribeUserType(..) => {}\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the"}, {"sha": "3404772f8255f4c31932fe62d1df50fa738f9d2f", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -112,7 +112,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             StatementKind::SetDiscriminant { .. } |\n             StatementKind::StorageLive(..) |\n             StatementKind::StorageDead(..) |\n-            StatementKind::EndRegion(..) |\n             StatementKind::Retag { .. } |\n             StatementKind::EscapeToRaw { .. } |\n             StatementKind::AscribeUserType(..) |"}, {"sha": "c0edd3926d32d131ace4719209a626f731c0bc16", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 12, "deletions": 97, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -10,111 +10,26 @@\n \n //! This module provides two passes:\n //!\n-//!   - `CleanEndRegions`, that reduces the set of `EndRegion` statements\n-//!     in the MIR.\n-//!   - `CleanAscribeUserType`, that replaces all `AscribeUserType` statements\n-//!     with `Nop`.\n+//!   - [CleanAscribeUserType], that replaces all\n+//!     [StatementKind::AscribeUserType] statements with [StatementKind::Nop].\n+//!   - [CleanFakeReadsAndBorrows], that replaces all [FakeRead] statements and\n+//!     borrows that are read by [FakeReadCause::ForMatchGuard] fake reads with\n+//!     [StatementKind::Nop].\n //!\n-//! The `CleanEndRegions` \"pass\" is actually implemented as two\n+//! The [CleanFakeReadsAndBorrows] \"pass\" is actually implemented as two\n //! traversals (aka visits) of the input MIR. The first traversal,\n-//! `GatherBorrowedRegions`, finds all of the regions in the MIR\n-//! that are involved in a borrow.\n-//!\n-//! The second traversal, `DeleteTrivialEndRegions`, walks over the\n-//! MIR and removes any `EndRegion` that is applied to a region that\n-//! was not seen in the previous pass.\n-//!\n-//! The `CleanAscribeUserType` pass runs at a distinct time from the\n-//! `CleanEndRegions` pass. It is important that the `CleanAscribeUserType`\n-//! pass runs after the MIR borrowck so that the NLL type checker can\n-//! perform the type assertion when it encounters the `AscribeUserType`\n-//! statements.\n+//! [DeleteAndRecordFakeReads], deletes the fake reads and finds the temporaries\n+//! read by [ForMatchGuard] reads, and [DeleteFakeBorrows] deletes the\n+//! initialization of those temporaries.\n \n use rustc_data_structures::fx::FxHashSet;\n \n-use rustc::middle::region;\n use rustc::mir::{BasicBlock, FakeReadCause, Local, Location, Mir, Place};\n-use rustc::mir::{Rvalue, Statement, StatementKind};\n-use rustc::mir::visit::{MutVisitor, Visitor, TyContext};\n-use rustc::ty::{Ty, RegionKind, TyCtxt};\n-use smallvec::smallvec;\n+use rustc::mir::{Statement, StatementKind};\n+use rustc::mir::visit::MutVisitor;\n+use rustc::ty::TyCtxt;\n use transform::{MirPass, MirSource};\n \n-pub struct CleanEndRegions;\n-\n-#[derive(Default)]\n-struct GatherBorrowedRegions {\n-    seen_regions: FxHashSet<region::Scope>,\n-}\n-\n-struct DeleteTrivialEndRegions<'a> {\n-    seen_regions: &'a FxHashSet<region::Scope>,\n-}\n-\n-impl MirPass for CleanEndRegions {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _source: MirSource,\n-                          mir: &mut Mir<'tcx>) {\n-        if !tcx.emit_end_regions() { return; }\n-\n-        let mut gather = GatherBorrowedRegions::default();\n-        gather.visit_mir(mir);\n-\n-        let mut delete = DeleteTrivialEndRegions { seen_regions: &mut gather.seen_regions };\n-        delete.visit_mir(mir);\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for GatherBorrowedRegions {\n-    fn visit_rvalue(&mut self,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n-        // Gather regions that are used for borrows\n-        if let Rvalue::Ref(r, _, _) = *rvalue {\n-            if let RegionKind::ReScope(ce) = *r {\n-                self.seen_regions.insert(ce);\n-            }\n-        }\n-        self.super_rvalue(rvalue, location);\n-    }\n-\n-    fn visit_ty(&mut self, ty: &Ty<'tcx>, _: TyContext) {\n-        // Gather regions that occur in types\n-        let mut regions = smallvec![];\n-        for t in ty.walk() {\n-            t.push_regions(&mut regions);\n-        }\n-        for re in regions {\n-            match *re {\n-                RegionKind::ReScope(ce) => { self.seen_regions.insert(ce); }\n-                _ => {},\n-            }\n-        }\n-        self.super_ty(ty);\n-    }\n-}\n-\n-impl<'a, 'tcx> MutVisitor<'tcx> for DeleteTrivialEndRegions<'a> {\n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &mut Statement<'tcx>,\n-                       location: Location) {\n-        let mut delete_it = false;\n-\n-        if let StatementKind::EndRegion(ref region_scope) = statement.kind {\n-            if !self.seen_regions.contains(region_scope) {\n-                delete_it = true;\n-            }\n-        }\n-\n-        if delete_it {\n-            statement.make_nop();\n-        }\n-        self.super_statement(block, statement, location);\n-    }\n-}\n-\n pub struct CleanAscribeUserType;\n \n pub struct DeleteAscribeUserType;"}, {"sha": "a5b5a7e86d21bfb07c9db6c0b799e2d0011ca38c", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -12,7 +12,7 @@\n //! We want to do this once just before codegen, so codegen does not have to take\n //! care erasing regions all over the place.\n //! NOTE:  We do NOT erase regions of statements that are relevant for\n-//! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid, and EndRegion.\n+//! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid\n \n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -54,10 +54,6 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {\n-        if let StatementKind::EndRegion(_) = statement.kind {\n-            statement.kind = StatementKind::Nop;\n-        }\n-\n         self.super_statement(block, statement, location);\n     }\n }"}, {"sha": "a77e9b502ac267947f78e1377a2a74cd0363b6eb", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -209,9 +209,6 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n \n     let mut mir = tcx.mir_built(def_id).steal();\n     run_passes(tcx, &mut mir, def_id, MirPhase::Const, &[\n-        // Remove all `EndRegion` statements that are not involved in borrows.\n-        &cleanup_post_borrowck::CleanEndRegions,\n-\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n         &type_check::TypeckMir,"}, {"sha": "816e85948851eba2d50e952cb7ef163f3b0b8a29", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -1168,7 +1168,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n                 StatementKind::InlineAsm {..} |\n-                StatementKind::EndRegion(_) |\n                 StatementKind::Retag { .. } |\n                 StatementKind::EscapeToRaw { .. } |\n                 StatementKind::AscribeUserType(..) |"}, {"sha": "13e134ba8592850b437b5d440b9702e9e5dfbdbb", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -243,7 +243,6 @@ fn check_statement(\n         | StatementKind::StorageDead(_)\n         | StatementKind::Retag { .. }\n         | StatementKind::EscapeToRaw { .. }\n-        | StatementKind::EndRegion(_)\n         | StatementKind::AscribeUserType(..)\n         | StatementKind::Nop => Ok(()),\n     }"}, {"sha": "a31d12baed2b468cf8547d3cc564832946339ba7", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -52,12 +52,9 @@ impl RemoveNoopLandingPads {\n                 StatementKind::FakeRead(..) |\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n-                StatementKind::EndRegion(_) |\n                 StatementKind::AscribeUserType(..) |\n                 StatementKind::Nop => {\n-                    // These are all nops in a landing pad (there's some\n-                    // borrowck interaction between EndRegion and storage\n-                    // instructions, but this should all run after borrowck).\n+                    // These are all nops in a landing pad\n                 }\n \n                 StatementKind::Assign(Place::Local(_), box Rvalue::Use(_)) => {"}, {"sha": "f852195b8351a6bb868b0c65a2d168f9d5f6729c", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -161,7 +161,6 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |\n-            mir::StatementKind::EndRegion(_) |\n             mir::StatementKind::Retag { .. } |\n             mir::StatementKind::EscapeToRaw { .. } |\n             mir::StatementKind::AscribeUserType(..) |"}, {"sha": "fb37f03a1cc41244d0a1466174cfc009fabeb37b", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -83,7 +83,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.record(match statement.kind {\n             StatementKind::Assign(..) => \"StatementKind::Assign\",\n             StatementKind::FakeRead(..) => \"StatementKind::FakeRead\",\n-            StatementKind::EndRegion(..) => \"StatementKind::EndRegion\",\n             StatementKind::Retag { .. } => \"StatementKind::Retag\",\n             StatementKind::EscapeToRaw { .. } => \"StatementKind::EscapeToRaw\",\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\","}, {"sha": "dd1c2bd51260b066f2942a2f519165f6722b3caf", "filename": "src/test/mir-opt/end_region_1.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_1.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// This is just about the simplest program that exhibits an EndRegion.\n-\n-fn main() {\n-    let a = 3;\n-    let b = &a;\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-//     let mut _0: ();\n-//     ...\n-//     let _2: &'11_1rs i32;\n-//     ...\n-//     let _1: i32;\n-//     ...\n-//     bb0: {\n-//         StorageLive(_1);\n-//         _1 = const 3i32;\n-//         FakeRead(ForLet, _1);\n-//         StorageLive(_2);\n-//         _2 = &'11_1rs _1;\n-//         FakeRead(ForLet, _2);\n-//         _0 = ();\n-//         EndRegion('11_1rs);\n-//         StorageDead(_2);\n-//         StorageDead(_1);\n-//         return;\n-//     }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "6b0a28b8110073c9eac5bd5a7e48a2b4dd31973d", "filename": "src/test/mir-opt/end_region_2.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_2.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,81 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// We will EndRegion for borrows in a loop that occur before break but\n-// not those after break.\n-\n-fn main() {\n-    loop {\n-        let a = true;\n-        let b = &a;\n-        if a { break; }\n-        let c = &a;\n-    }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-//     let mut _0: ();\n-//     ...\n-//     let _7: &'26_3rs bool;\n-//     ...\n-//     let _3: &'26_1rs bool;\n-//     ...\n-//     let _2: bool;\n-//     ...\n-//     let mut _4: ();\n-//     let mut _5: bool;\n-//     ...\n-//     bb0: {\n-//         goto -> bb1;\n-//     }\n-//     bb1: {\n-//          falseUnwind -> [real: bb2, cleanup: bb3];\n-//     }\n-//     bb2: {\n-//         StorageLive(_2);\n-//         _2 = const true;\n-//         FakeRead(ForLet, _2);\n-//         StorageLive(_3);\n-//         _3 = &'26_1rs _2;\n-//         FakeRead(ForLet, _3);\n-//         StorageLive(_5);\n-//         _5 = _2;\n-//         switchInt(move _5) -> [false: bb5, otherwise: bb4];\n-//     }\n-//     bb3: {\n-//         ...\n-//     }\n-//     bb4: {\n-//         _0 = ();\n-//         StorageDead(_5);\n-//         EndRegion('26_1rs);\n-//         StorageDead(_3);\n-//         StorageDead(_2);\n-//         return;\n-//     }\n-//     bb5: {\n-//         _4 = ();\n-//         StorageDead(_5);\n-//         StorageLive(_7);\n-//         _7 = &'26_3rs _2;\n-//         FakeRead(ForLet, _7);\n-//         _1 = ();\n-//         EndRegion('26_3rs);\n-//         StorageDead(_7);\n-//         EndRegion('26_1rs);\n-//         StorageDead(_3);\n-//         StorageDead(_2);\n-//         goto -> bb1;\n-//     }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "d8d48358e53fc27fb98a708dbeae316a480d7f5c", "filename": "src/test/mir-opt/end_region_3.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_3.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,81 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// Binding the borrow's subject outside the loop does not increase the\n-// scope of the borrow.\n-\n-fn main() {\n-    let mut a;\n-    loop {\n-        a = true;\n-        let b = &a;\n-        if a { break; }\n-        let c = &a;\n-    }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-//     let mut _0: ();\n-//     ...\n-//     let _7: &'30_3rs bool;\n-//     ...\n-//     let _3: &'30_1rs bool;\n-//     ...\n-//     let mut _1: bool;\n-//     ...\n-//     let mut _2: ();\n-//     let mut _4: ();\n-//     let mut _5: bool;\n-//     let mut _6: !;\n-//     bb0: {\n-//         StorageLive(_1);\n-//         goto -> bb1;\n-//     }\n-//     bb1: {\n-//         falseUnwind -> [real: bb2, cleanup: bb3];\n-//     }\n-//     bb2: {\n-//         _1 = const true;\n-//         StorageLive(_3);\n-//         _3 = &'30_1rs _1;\n-//         FakeRead(ForLet, _3);\n-//         StorageLive(_5);\n-//         _5 = _1;\n-//         switchInt(move _5) -> [false: bb5, otherwise: bb4];\n-//     }\n-//     bb3: {\n-//         ...\n-//     }\n-//     bb4: {\n-//         _0 = ();\n-//         StorageDead(_5);\n-//         EndRegion('30_1rs);\n-//         StorageDead(_3);\n-//         StorageDead(_1);\n-//         return;\n-//     }\n-//     bb5: {\n-//         _4 = ();\n-//         StorageDead(_5);\n-//         StorageLive(_7);\n-//         _7 = &'30_3rs _1;\n-//         FakeRead(ForLet, _7);\n-//         _2 = ();\n-//         EndRegion('30_3rs);\n-//         StorageDead(_7);\n-//         EndRegion('30_1rs);\n-//         StorageDead(_3);\n-//         goto -> bb1;\n-//     }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "3d15f20bd05f33bd4098e9918242108897926c1e", "filename": "src/test/mir-opt/end_region_4.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// Unwinding should EndRegion for in-scope borrows: Direct borrows.\n-\n-fn main() {\n-    let d = D(0);\n-    let a = 0;\n-    let b = &a;\n-    foo(*b);\n-    let c = &a;\n-}\n-\n-struct D(i32);\n-impl Drop for D { fn drop(&mut self) { println!(\"dropping D({})\", self.0); } }\n-\n-fn foo(i: i32) {\n-    if i > 0 { panic!(\"im positive\"); }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-//     let mut _0: ();\n-//     ...\n-//     let _6: &'31_4rs i32;\n-//     ...\n-//     let _3: &'31_2rs i32;\n-//     ...\n-//     let _2: i32;\n-//     ...\n-//     let _1: D;\n-//     ...\n-//     let mut _4: ();\n-//     let mut _5: i32;\n-//     bb0: {\n-//         StorageLive(_1);\n-//         _1 = D(const 0i32,);\n-//         FakeRead(ForLet, _1);\n-//         StorageLive(_2);\n-//         _2 = const 0i32;\n-//         FakeRead(ForLet, _2);\n-//         StorageLive(_3);\n-//         _3 = &'31_2rs _2;\n-//         FakeRead(ForLet, _3);\n-//         StorageLive(_5);\n-//         _5 = (*_3);\n-//         _4 = const foo(move _5) -> [return: bb2, unwind: bb3];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         StorageDead(_5);\n-//         StorageLive(_6);\n-//         _6 = &'31_4rs _2;\n-//         FakeRead(ForLet, _6);\n-//         _0 = ();\n-//         EndRegion('31_4rs);\n-//         StorageDead(_6);\n-//         EndRegion('31_2rs);\n-//         StorageDead(_3);\n-//         StorageDead(_2);\n-//         drop(_1) -> [return: bb4, unwind: bb1];\n-//     }\n-//     bb3: {\n-//         EndRegion('31_2rs);\n-//         drop(_1) -> bb1;\n-//     }\n-//     bb4: {\n-//         StorageDead(_1);\n-//         return;\n-//     }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "06d1fbabe16167863d1428bc1c65c37b3f7df22c", "filename": "src/test/mir-opt/end_region_5.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z span_free_formats -Z emit-end-regions\n-\n-// Unwinding should EndRegion for in-scope borrows: Borrowing via by-ref closure.\n-\n-fn main() {\n-    let d = D(0);\n-    foo(|| -> i32 { d.0 });\n-}\n-\n-struct D(i32);\n-impl Drop for D { fn drop(&mut self) { println!(\"dropping D({})\", self.0); } }\n-\n-fn foo<F>(f: F) where F: FnOnce() -> i32 {\n-    if f() > 0 { panic!(\"im positive\"); }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-// fn main() -> () {\n-//     ...\n-//     let mut _0: ();\n-//     ...\n-//     let _1: D;\n-//     ...\n-//     let mut _2: ();\n-//     let mut _3: [closure@NodeId(28) d:&'18s D];\n-//     let mut _4: &'18s D;\n-//     bb0: {\n-//         StorageLive(_1);\n-//         _1 = D(const 0i32,);\n-//         FakeRead(ForLet, _1);\n-//         StorageLive(_3);\n-//         StorageLive(_4);\n-//         _4 = &'18s _1;\n-//         _3 = [closure@NodeId(28)] { d: move _4 };\n-//         StorageDead(_4);\n-//         _2 = const foo(move _3) -> [return: bb2, unwind: bb3];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         EndRegion('18s);\n-//         StorageDead(_3);\n-//         _0 = ();\n-//         drop(_1) -> [return: bb4, unwind: bb1];\n-//     }\n-//     bb3: {\n-//         EndRegion('18s);\n-//         drop(_1) -> bb1;\n-//     }\n-//     bb4: {\n-//         StorageDead(_1);\n-//         return;\n-//     }\n-// }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir\n-\n-// START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(28) d:&'18s D]) -> i32 {\n-//    let mut _0: i32;\n-//\n-//    bb0: {\n-//        _0 = ((*(_1.0: &'18s D)).0: i32);\n-//        return;\n-//    }\n-// END rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "d0db23e6de0ee177095cc7f390cdf645502d37d9", "filename": "src/test/mir-opt/end_region_6.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z span_free_formats -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// Unwinding should EndRegion for in-scope borrows: 2nd borrow within by-ref closure.\n-\n-fn main() {\n-    let d = D(0);\n-    foo(|| -> i32 { let r = &d; r.0 });\n-}\n-\n-struct D(i32);\n-impl Drop for D { fn drop(&mut self) { println!(\"dropping D({})\", self.0); } }\n-\n-fn foo<F>(f: F) where F: FnOnce() -> i32 {\n-    if f() > 0 { panic!(\"im positive\"); }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-// fn main() -> () {\n-//     let mut _0: ();\n-//     ...\n-//     let _1: D;\n-//     ...\n-//     let mut _2: ();\n-//     let mut _3: [closure@NodeId(33) d:&'24s D];\n-//     let mut _4: &'24s D;\n-//     bb0: {\n-//         StorageLive(_1);\n-//         _1 = D(const 0i32,);\n-//         FakeRead(ForLet, _1);\n-//         StorageLive(_3);\n-//         StorageLive(_4);\n-//         _4 = &'24s _1;\n-//         _3 = [closure@NodeId(33)] { d: move _4 };\n-//         StorageDead(_4);\n-//         _2 = const foo(move _3) -> [return: bb2, unwind: bb3];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         EndRegion('24s);\n-//         StorageDead(_3);\n-//         _0 = ();\n-//         drop(_1) -> [return: bb4, unwind: bb1];\n-//     }\n-//     bb3: {\n-//         EndRegion('24s);\n-//         drop(_1) -> bb1;\n-//     }\n-//     bb4: {\n-//         StorageDead(_1);\n-//         return;\n-//     }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir\n-\n-// START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(33) d:&'24s D]) -> i32 {\n-//     let mut _0: i32;\n-//     ...\n-//     let _2: &'21_0rs D;\n-//     ...\n-//     bb0: {\n-//         StorageLive(_2);\n-//         _2 = &'21_0rs (*(_1.0: &'24s D));\n-//         FakeRead(ForLet, _2);\n-//         _0 = ((*_2).0: i32);\n-//         EndRegion('21_0rs);\n-//         StorageDead(_2);\n-//         return;\n-//     }\n-// END rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "c7df440ebe2f31ef212edc28f24cb4fa67a6f442", "filename": "src/test/mir-opt/end_region_7.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z span_free_formats -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// Unwinding should EndRegion for in-scope borrows: Borrow of moved data.\n-\n-fn main() {\n-    let d = D(0);\n-    foo(move || -> i32 { let r = &d; r.0 });\n-}\n-\n-struct D(i32);\n-impl Drop for D { fn drop(&mut self) { println!(\"dropping D({})\", self.0); } }\n-\n-fn foo<F>(f: F) where F: FnOnce() -> i32 {\n-    if f() > 0 { panic!(\"im positive\"); }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-// fn main() -> () {\n-//     let mut _0: ();\n-//     ...\n-//     let _1: D;\n-//     ...\n-//     let mut _2: ();\n-//     let mut _3: [closure@NodeId(33) d:D];\n-//     bb0: {\n-//         StorageLive(_1);\n-//         _1 = D(const 0i32,);\n-//         FakeRead(ForLet, _1);\n-//         StorageLive(_3);\n-//         _3 = [closure@NodeId(33)] { d: move _1 };\n-//         _2 = const foo(move _3) -> [return: bb2, unwind: bb4];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         drop(_3) -> [return: bb5, unwind: bb3];\n-//     }\n-//     bb3: {\n-//         drop(_1) -> bb1;\n-//     }\n-//     bb4: {\n-//         drop(_3) -> bb3;\n-//     }\n-//     bb5: {\n-//         StorageDead(_3);\n-//         _0 = ();\n-//         drop(_1) -> [return: bb6, unwind: bb1];\n-//     }\n-//     bb6: {\n-//         StorageDead(_1);\n-//         return;\n-//     }\n-// }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir\n-\n-// START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(33) d:D]) -> i32 {\n-//     let mut _0: i32;\n-//     ...\n-//     let _2: &'21_0rs D;\n-//     ...\n-//     bb0: {\n-//         StorageLive(_2);\n-//         _2 = &'21_0rs (_1.0: D);\n-//         FakeRead(ForLet, _2);\n-//         _0 = ((*_2).0: i32);\n-//         EndRegion('21_0rs);\n-//         StorageDead(_2);\n-//         drop(_1) -> [return: bb2, unwind: bb1];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         return;\n-//     }\n-// }\n-// END rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "9f2a9c3b72e8b6d685acd37f7b03ddfc12a001ff", "filename": "src/test/mir-opt/end_region_8.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z span_free_formats -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// Unwinding should EndRegion for in-scope borrows: Move of borrow into closure.\n-\n-fn main() {\n-    let d = D(0);\n-    let r = &d;\n-    foo(move || -> i32 { r.0 });\n-}\n-\n-struct D(i32);\n-impl Drop for D { fn drop(&mut self) { println!(\"dropping D({})\", self.0); } }\n-\n-fn foo<F>(f: F) where F: FnOnce() -> i32 {\n-    if f() > 0 { panic!(\"im positive\"); }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-// fn main() -> () {\n-//    let mut _0: ();\n-//    ...\n-//    let _2: &'26_1rs D;\n-//    ...\n-//    let _1: D;\n-//    ...\n-//    let mut _3: ();\n-//    let mut _4: [closure@NodeId(33) r:&'24s D];\n-//    bb0: {\n-//        StorageLive(_1);\n-//        _1 = D(const 0i32,);\n-//        FakeRead(ForLet, _1);\n-//        StorageLive(_2);\n-//        _2 = &'26_1rs _1;\n-//        FakeRead(ForLet, _2);\n-//        StorageLive(_4);\n-//        _4 = [closure@NodeId(33)] { r: _2 };\n-//        _3 = const foo(move _4) -> [return: bb2, unwind: bb3];\n-//    }\n-//    bb1: {\n-//        resume;\n-//    }\n-//    bb2: {\n-//        EndRegion('24s);\n-//        StorageDead(_4);\n-//        _0 = ();\n-//        EndRegion('26_1rs);\n-//        StorageDead(_2);\n-//        drop(_1) -> [return: bb4, unwind: bb1];\n-//    }\n-//    bb3: {\n-//        EndRegion('24s);\n-//        EndRegion('26_1rs);\n-//        drop(_1) -> bb1;\n-//    }\n-//    bb4: {\n-//        StorageDead(_1);\n-//        return;\n-//    }\n-// }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir\n-\n-// START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(33) r:&'24s D]) -> i32 {\n-//     let mut _0: i32;\n-//\n-//     bb0: {\n-//         _0 = ((*(_1.0: &'26_1rs D)).0: i32);\n-//         return;\n-//     }\n-// }\n-// END rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "ef2d949d3074eb4c990c8c06636c5d190abb9f1c", "filename": "src/test/mir-opt/end_region_9.rs", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_9.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,97 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z span_free_formats -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// This test models a scenario that arielb1 found during review.\n-// Namely, any filtering of EndRegions must ensure to continue to emit\n-// any necessary EndRegions that occur earlier in the source than the\n-// first borrow involving that region.\n-//\n-// It is tricky to actually construct examples of this, which is the\n-// main reason that I am keeping this test even though I have now\n-// removed the pre-filter that motivated the test in the first place.\n-\n-fn main() {\n-    let mut second_iter = false;\n-    let x = 3;\n-    'a: loop {\n-        let mut y;\n-        loop {\n-            if second_iter {\n-                break 'a; // want to generate `EndRegion('a)` here\n-            } else {\n-                y = &/*'a*/ x;\n-            }\n-            second_iter = true;\n-        }\n-    }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-// fn main() -> () {\n-//     let mut _0: ();\n-//     ...\n-//     let mut _4: &'37_0rs i32;\n-//     ...\n-//     let _2: i32;\n-//     ...\n-//     let mut _1: bool;\n-//     ...\n-//     let mut _3: ();\n-//     let mut _5: !;\n-//     let mut _6: ();\n-//     let mut _7: bool;\n-//     let mut _8: !;\n-//     bb0: {\n-//        StorageLive(_1);\n-//        _1 = const false;\n-//        FakeRead(ForLet, _1);\n-//        StorageLive(_2);\n-//        _2 = const 3i32;\n-//        FakeRead(ForLet, _2);\n-//        falseUnwind -> [real: bb2, cleanup: bb1];\n-//    }\n-//    bb1: {\n-//        ...\n-//    }\n-//    bb2: {\n-//        StorageLive(_4);\n-//        goto -> bb3;\n-//    }\n-//    bb3: {\n-//        falseUnwind -> [real: bb4, cleanup: bb1];\n-//    }\n-//    bb4: {\n-//        StorageLive(_7);\n-//        _7 = _1;\n-//        switchInt(move _7) -> [false: bb6, otherwise: bb5];\n-//    }\n-//    bb5: {\n-//        _0 = ();\n-//        StorageDead(_7);\n-//        EndRegion('37_0rs);\n-//        StorageDead(_4);\n-//        StorageDead(_2);\n-//        StorageDead(_1);\n-//        return;\n-//    }\n-//    bb6: {\n-//        _4 = &'37_0rs _2;\n-//        _6 = ();\n-//        StorageDead(_7);\n-//        _1 = const true;\n-//        _3 = ();\n-//        goto -> bb3;\n-//    }\n-// }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "3dbc73caf65d87e6d396fa5975f73adf0bf93094", "filename": "src/test/mir-opt/end_region_cyclic.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,141 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z span_free_formats -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// This test models a scenario with a cyclic reference. Rust obviously\n-// needs to handle such cases.\n-//\n-// The interesting part about this test is that such case shows that\n-// one cannot generally force all references to be dead before you hit\n-// their EndRegion; at least, not without breaking the more important\n-// property that all borrowed storage locations have their regions\n-// ended strictly before their StorageDeads. (This test was inspired\n-// by discussion on Issue #43481.)\n-\n-use std::cell::Cell;\n-\n-struct S<'a> {\n-    r: Cell<Option<&'a S<'a>>>,\n-}\n-\n-fn main() {\n-    loop {\n-        let x = S { r: Cell::new(None) };\n-        x.r.set(Some(&x));\n-        if query() { break; }\n-        x.r.set(Some(&x));\n-    }\n-}\n-\n-fn query() -> bool { true }\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-// fn main() -> (){\n-//     let mut _0: ();\n-//     scope 1 {\n-//     }\n-//     scope 2 {\n-//         let _2: S<'49_0rs>;\n-//     }\n-//     let mut _1: ();\n-//     let mut _3: std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>;\n-//     let mut _4: std::option::Option<&'49_0rs S<'49_0rs>>;\n-//     let mut _5: ();\n-//     let mut _6: &'25s std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>;\n-//     let mut _7: std::option::Option<&'49_0rs S<'49_0rs>>;\n-//     let mut _8: &'49_0rs S<'49_0rs>;\n-//     let mut _9: &'49_0rs S<'49_0rs>;\n-//     let mut _10: ();\n-//     let mut _11: bool;\n-//     let mut _12: !;\n-//     let mut _13: ();\n-//     let mut _14: &'47s std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>;\n-//     let mut _15: std::option::Option<&'49_0rs S<'49_0rs>>;\n-//     let mut _16: &'49_0rs S<'49_0rs>;\n-//     let mut _17: &'49_0rs S<'49_0rs>;\n-//     bb0: {\n-//         goto -> bb1;\n-//     }\n-//     bb1: {\n-//         falseUnwind -> [real: bb2, cleanup: bb3];\n-//     }\n-//     bb2: {\n-//         StorageLive(_2);\n-//         StorageLive(_3);\n-//         StorageLive(_4);\n-//         _4 = std::option::Option<&'49_0rs S<'49_0rs>>::None;\n-//         _3 = const <std::cell::Cell<T>>::new(move _4) -> [return: bb4, unwind: bb3];\n-//     }\n-//     bb3: {\n-//         resume;\n-//     }\n-//     bb4: {\n-//         StorageDead(_4);\n-//         _2 = S<'49_0rs> { r: move _3 };\n-//         StorageDead(_3);\n-//         FakeRead(ForLet, _2);\n-//         StorageLive(_6);\n-//         _6 = &'25s (_2.0: std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>);\n-//         StorageLive(_7);\n-//         StorageLive(_8);\n-//         StorageLive(_9);\n-//         _9 = &'49_0rs _2;\n-//         _8 = &'49_0rs (*_9);\n-//         _7 = std::option::Option<&'49_0rs S<'49_0rs>>::Some(move _8,);\n-//         StorageDead(_8);\n-//         _5 = const <std::cell::Cell<T>>::set(move _6, move _7) -> [return: bb5, unwind: bb3];\n-//     }\n-//     bb5: {\n-//         EndRegion('25s);\n-//         StorageDead(_7);\n-//         StorageDead(_6);\n-//         StorageDead(_9);\n-//         StorageLive(_11);\n-//         _11 = const query() -> [return: bb6, unwind: bb3];\n-//     }\n-//     bb6: {\n-//         switchInt(move _11) -> [false: bb8, otherwise: bb7];\n-//     }\n-//     bb7: {\n-//         _0 = ();\n-//         StorageDead(_11);\n-//         EndRegion('49_0rs);\n-//         StorageDead(_2);\n-//         return;\n-//     }\n-//     bb8: {\n-//         _10 = ();\n-//         StorageDead(_11);\n-//         StorageLive(_14);\n-//         _14 = &'47s (_2.0: std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>);\n-//         StorageLive(_15);\n-//         StorageLive(_16);\n-//         StorageLive(_17);\n-//         _17 = &'49_0rs _2;\n-//         _16 = &'49_0rs (*_17);\n-//         _15 = std::option::Option<&'49_0rs S<'49_0rs>>::Some(move _16,);\n-//         StorageDead(_16);\n-//         _13 = const <std::cell::Cell<T>>::set(move _14, move _15) -> [return: bb9, unwind: bb3];\n-//     }\n-//     bb9: {\n-//         EndRegion('47s);\n-//         StorageDead(_15);\n-//         StorageDead(_14);\n-//         StorageDead(_17);\n-//         _1 = ();\n-//         EndRegion('49_0rs);\n-//         StorageDead(_2);\n-//         goto -> bb1;\n-//     }\n-// }\n-// END rustc.main.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "eb381dfc5521fb53a7175fe081e4882cdb1c110d", "filename": "src/test/mir-opt/end_region_destruction_extents_1.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,154 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z span_free_formats -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// A scenario with significant destruction code extents (which have\n-// suffix \"dce\" in current `-Z identify_regions` rendering).\n-\n-#![feature(dropck_eyepatch)]\n-\n-fn main() {\n-    // Since the second param to `D1` is may_dangle, it is legal for\n-    // the region of that parameter to end before the drop code for D1\n-    // is executed.\n-    (D1(&S1(\"ex1\"), &S1(\"dang1\"))).0;\n-}\n-\n-#[derive(Debug)]\n-struct S1(&'static str);\n-\n-#[derive(Debug)]\n-struct D1<'a, 'b>(&'a S1, &'b S1);\n-\n-// The `#[may_dangle]` means that references of type `&'b _` may be\n-// invalid during the execution of this destructor; i.e. in this case\n-// the destructor code is not allowed to read or write `*self.1`, while\n-// it can read/write `*self.0`.\n-unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n-    fn drop(&mut self) {\n-        println!(\"D1({:?}, _)\", self.0);\n-    }\n-}\n-\n-// Notes on the MIR output below:\n-//\n-// 1. The `EndRegion('13s)` is allowed to precede the `drop(_3)`\n-//    solely because of the #[may_dangle] mentioned above.\n-//\n-// 2. Regarding the occurrence of `EndRegion('15ds)` *after* `StorageDead(_6)`\n-//    (where we have borrows `&'15ds _6`): Eventually:\n-//\n-//    i. this code should be rejected (by mir-borrowck), or\n-//\n-//    ii. the MIR code generation should be changed so that the\n-//        EndRegion('15ds)` precedes `StorageDead(_6)` in the\n-//        control-flow.  (Note: arielb1 views drop+storagedead as one\n-//        unit, and does not see this option as a useful avenue to\n-//        explore.), or\n-//\n-//    iii. the presence of EndRegion should be made irrelevant by a\n-//        transformation encoding the effects of rvalue-promotion.\n-//        This may be the simplest and most-likely option; note in\n-//        particular that `StorageDead(_6)` goes away below in\n-//        rustc.main.QualifyAndPromoteConstants.after.mir\n-\n-// END RUST SOURCE\n-\n-// START rustc.main.QualifyAndPromoteConstants.before.mir\n-// fn main() -> () {\n-// let mut _0: ();\n-//     let mut _1: &'15ds S1;\n-//     let mut _2: D1<'15ds, '13s>;\n-//     let mut _3: &'15ds S1;\n-//     let mut _4: &'15ds S1;\n-//     let _5: S1;\n-//     let mut _6: &'13s S1;\n-//     let mut _7: &'13s S1;\n-//     let _8: S1;\n-//     bb0: {\n-//         StorageLive(_2);\n-//         StorageLive(_3);\n-//         StorageLive(_4);\n-//         StorageLive(_5);\n-//         _5 = S1(const \"ex1\",);\n-//         _4 = &'15ds _5;\n-//         _3 = &'15ds (*_4);\n-//         StorageLive(_6);\n-//         StorageLive(_7);\n-//         StorageLive(_8);\n-//         _8 = S1(const \"dang1\",);\n-//         _7 = &'13s _8;\n-//         _6 = &'13s (*_7);\n-//         _2 = D1<'15ds, '13s>(move _3, move _6);\n-//         EndRegion('13s);\n-//         StorageDead(_6);\n-//         StorageDead(_3);\n-//         _1 = (_2.0: &'15ds S1);\n-//         drop(_2) -> [return: bb2, unwind: bb1];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         StorageDead(_2);\n-//         StorageDead(_7);\n-//         StorageDead(_8);\n-//         StorageDead(_4);\n-//         StorageDead(_5);\n-//         EndRegion('15ds);\n-//         _0 = ();\n-//         return;\n-//     }\n-// }\n-// END rustc.main.QualifyAndPromoteConstants.before.mir\n-\n-// START rustc.main.QualifyAndPromoteConstants.after.mir\n-// fn main() -> (){\n-//     let mut _0: ();\n-//     let mut _1: &'15ds S1;\n-//     let mut _2: D1<'15ds, '13s>;\n-//     let mut _3: &'15ds S1;\n-//     let mut _4: &'15ds S1;\n-//     let _5: S1;\n-//     let mut _6: &'13s S1;\n-//     let mut _7: &'13s S1;\n-//     let _8: S1;\n-//     bb0: {\n-//         StorageLive(_2);\n-//         StorageLive(_3);\n-//         StorageLive(_4);\n-//         _4 = &'15ds (promoted[1]: S1);\n-//         _3 = &'15ds (*_4);\n-//         StorageLive(_6);\n-//         StorageLive(_7);\n-//         _7 = &'13s (promoted[0]: S1);\n-//         _6 = &'13s (*_7);\n-//         _2 = D1<'15ds, '13s>(move _3, move _6);\n-//         EndRegion('13s);\n-//         StorageDead(_6);\n-//         StorageDead(_3);\n-//         _1 = (_2.0: &'15ds S1);\n-//         drop(_2) -> [return: bb2, unwind: bb1];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         StorageDead(_2);\n-//         StorageDead(_7);\n-//         StorageDead(_4);\n-//         EndRegion('15ds);\n-//         _0 = ();\n-//         return;\n-//     }\n-// }\n-// END rustc.main.QualifyAndPromoteConstants.after.mir"}, {"sha": "85cecc5070cd55c97c30eb0623cac7527730aef1", "filename": "src/test/mir-opt/issue-43457.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fissue-43457.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fmir-opt%2Fissue-43457.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-43457.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1,55 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z identify_regions -Z span_free_formats -Z emit-end-regions\n-// ignore-tidy-linelength\n-\n-// Regression test for #43457: an `EndRegion` was missing from output\n-// because compiler was using a faulty means for region map lookup.\n-\n-use std::cell::RefCell;\n-\n-fn rc_refcell_test(r: RefCell<i32>) {\n-    r.borrow_mut();\n-}\n-\n-fn main() { }\n-\n-// END RUST SOURCE\n-// START rustc.rc_refcell_test.SimplifyCfg-qualify-consts.after.mir\n-//\n-// fn rc_refcell_test(_1: std::cell::RefCell<i32>) -> () {\n-//     let mut _0: ();\n-//     scope 1 {\n-//         let _2: std::cell::RefCell<i32>;\n-//     }\n-//     let mut _3: std::cell::RefMut<'17ds, i32>;\n-//     let mut _4: &'17ds std::cell::RefCell<i32>;\n-//\n-//     bb0: {\n-//         StorageLive(_2);\n-//         _2 = _1;\n-//         StorageLive(_4);\n-//         _4 = &'17ds _2;\n-//         _3 = const <std::cell::RefCell<T>>::borrow_mut(_4) -> bb1;\n-//     }\n-//\n-//     bb1: {\n-//         drop(_3) -> bb2;\n-//     }\n-//\n-//     bb2: {\n-//         StorageDead(_4);\n-//         EndRegion('17ds);\n-//         _0 = ();\n-//         StorageDead(_2);\n-//         return;\n-//     }\n-// }"}, {"sha": "d8365c8c9cc2374749969e8c249d8b1c2c3961df", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 7, "deletions": 34, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -44,7 +44,7 @@ fn main() {\n //         falseUnwind -> [real: bb3, cleanup: bb4];\n //     }\n //     bb2: {\n-//         goto -> bb29;\n+//         goto -> bb20;\n //     }\n //     bb3: {\n //         StorageLive(_2);\n@@ -90,58 +90,31 @@ fn main() {\n //         StorageDead(_3);\n //         StorageLive(_6);\n //         _6 = &_2;\n-//         _5 = const std::mem::drop(move _6) -> [return: bb28, unwind: bb4];\n+//         _5 = const std::mem::drop(move _6) -> [return: bb19, unwind: bb4];\n //     }\n //     bb15: {\n+//         StorageDead(_3);\n //         goto -> bb16;\n //     }\n //     bb16: {\n-//         goto -> bb17;\n-//     }\n-//     bb17: {\n-//         goto -> bb18;\n-//     }\n-//     bb18: {\n-//         goto -> bb19;\n-//     }\n-//     bb19: {\n-//         goto -> bb20;\n-//     }\n-//     bb20: {\n-//         StorageDead(_3);\n-//         goto -> bb21;\n-//     }\n-//     bb21: {\n-//         goto -> bb22;\n-//     }\n-//     bb22: {\n //         StorageDead(_2);\n-//         goto -> bb23;\n-//     }\n-//     bb23: {\n-//         goto -> bb24;\n-//     }\n-//     bb24: {\n-//         goto -> bb25;\n-//     }\n-//     bb25: {\n //         goto -> bb2;\n //     }\n-//     bb26: {\n+//     bb17: {\n //         _4 = ();\n //         unreachable;\n //     }\n-//     bb27: {\n+//     bb18: {\n //         StorageDead(_4);\n //         goto -> bb14;\n //     }\n-//     bb28: {\n+//     bb19: {\n //         StorageDead(_6);\n //         _1 = ();\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }\n-//     bb29: {\n+//     bb20: {\n //         return;\n //     }\n // }"}, {"sha": "77616f1d39ad451b2e87689357f5c1e02a1ca0d4", "filename": "src/test/mir-opt/loop_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fmir-opt%2Floop_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fmir-opt%2Floop_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Floop_test.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z identify_regions -Z emit-end-regions\n+// compile-flags: -Z identify_regions\n \n // Tests to make sure we correctly generate falseUnwind edges in loops\n "}, {"sha": "14bda56dd8fbe52c8562d68ce93839d9670d1dcf", "filename": "src/test/run-pass/issues/issue-16671.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16671.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // run-pass\n-//compile-flags: -Z borrowck=compare -Z emit-end-regions\n+//compile-flags: -Z borrowck=compare\n \n #![deny(warnings)]\n "}, {"sha": "c5291ab3e1dbf40d0f40895065f6716d65c4a683", "filename": "src/test/ui/borrowck/immutable-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Z borrowck=compare\n+//compile-flags: -Z borrowck=compare\n \n fn foo(_x: u32) {\n     _x = 4;"}, {"sha": "e79bfb23b05afb1f66ead73f28b055f27644fb3f", "filename": "src/test/ui/issues/issue-45697-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-45697-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-45697-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45697-1.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -11,7 +11,7 @@\n // Test that assignments to an `&mut` pointer which is found in a\n // borrowed (but otherwise non-aliasable) location is illegal.\n \n-// compile-flags: -Z emit-end-regions -Z borrowck=compare -C overflow-checks=on\n+// compile-flags: -Z borrowck=compare -C overflow-checks=on\n \n struct S<'a> {\n     pointer: &'a mut isize"}, {"sha": "936e8a40fa83f0b6448219186f5eb14388513f84", "filename": "src/test/ui/issues/issue-45697.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-45697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-45697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45697.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -11,7 +11,7 @@\n // Test that assignments to an `&mut` pointer which is found in a\n // borrowed (but otherwise non-aliasable) location is illegal.\n \n-// compile-flags: -Z emit-end-regions -Z borrowck=compare -C overflow-checks=off\n+// compile-flags: -Z borrowck=compare -C overflow-checks=off\n \n struct S<'a> {\n     pointer: &'a mut isize"}, {"sha": "ea7e627eadf1091abe4476a02affe69226d498da", "filename": "src/test/ui/issues/issue-46023.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-46023.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-46023.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46023.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // revisions: ast mir\n-//[mir]compile-flags: -Z emit-end-regions -Z borrowck=mir\n+//[mir]compile-flags: -Z borrowck=mir\n \n fn main() {\n     let x = 0;"}, {"sha": "7fb77f9ce8bf6f933234850f126b3923432d8ed0", "filename": "src/test/ui/issues/issue-46471-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-46471-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-46471-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46471-1.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z emit-end-regions -Z borrowck=compare\n+// compile-flags: -Z borrowck=compare\n \n fn main() {\n     let y = {"}, {"sha": "201b8e2de9a7946899a087a4fda0eaef8b9ddee4", "filename": "src/test/ui/issues/issue-46471.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-46471.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-46471.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46471.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z emit-end-regions -Z borrowck=compare\n+// compile-flags: -Z borrowck=compare\n \n fn foo() -> &'static u32 {\n     let x = 0;"}, {"sha": "b6838a48b1b6808355af1296daf1bb7aa9405d49", "filename": "src/test/ui/issues/issue-46472.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-46472.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fissues%2Fissue-46472.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46472.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z emit-end-regions -Z borrowck=compare\n+// compile-flags: -Z borrowck=compare\n \n fn bar<'a>() -> &'a mut u32 {\n     &mut 4"}, {"sha": "9dda275d95eaa124bcc27ba6e19b54fd92bd4db6", "filename": "src/test/ui/moves/moves-based-on-type-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-// compile-flags: -Z emit-end-regions -Z borrowck=compare\n+// compile-flags: -Z borrowck=compare\n \n fn dup(x: Box<isize>) -> Box<(Box<isize>,Box<isize>)> {\n     box (x, x)"}, {"sha": "f96e73ce09f5f9468dd4b1b20c6d2ce12af9b832", "filename": "src/test/ui/nll/maybe-initialized-drop-uninitialized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z emit-end-regions -Zborrowck=mir\n+// compile-flags: -Zborrowck=mir\n // compile-pass\n \n #![allow(warnings)]"}, {"sha": "0e9cdf2f428addef81627dc2c1c027d1557f7b4e", "filename": "src/test/ui/nll/maybe-initialized-drop-with-fragment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir\n+//compile-flags: -Zborrowck=mir\n \n #![allow(warnings)]\n "}, {"sha": "080fdfe0228013fcf30810b4c7514426630b0103", "filename": "src/test/ui/nll/maybe-initialized-drop-with-uninitialized-fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir\n+//compile-flags: -Zborrowck=mir\n \n #![allow(warnings)]\n "}, {"sha": "db680ef8bea17c3fab5f44eb00aeff8f08d2d0b9", "filename": "src/test/ui/nll/maybe-initialized-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37961dbd2d84a29be49007a5770b96e296f5f349/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs?ref=37961dbd2d84a29be49007a5770b96e296f5f349", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir\n+//compile-flags: -Zborrowck=mir\n \n #![allow(warnings)]\n "}]}