{"sha": "72a28e85d77bab7f1073ad2224d536ae232cfc50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYTI4ZTg1ZDc3YmFiN2YxMDczYWQyMjI0ZDUzNmFlMjMyY2ZjNTA=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-04-01T01:13:57Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-04-01T06:40:27Z"}, "message": "Improve `ModuleConfig` initialization.\n\nThere are three `ModuleConfigs`, one for each `ModuleKind`. The code to\ninitialized them is spaghetti imperative code that sets each field to a\ndefault value and then modifies many fields in complicated ways. This\nmakes it very hard to tell what value ends up in each field in each\nconfig.\n\nFor example, the `modules_config.emit_pre_lto_bc` field is set twice,\nwhich means it can be set to true and then incorrectly set back to\nfalse. (This probably hasn't been noticed because it happens in a very\nobscure case.)\n\nThis commit changes the code to a declarative style in which\n`ModuleConfig::new` initializes all fields and then they are never\nchanged again. This is slightly more concise and much easier to read.\n(And it fixes the abovementioned `emit_pre_lto_bc` error as well.)", "tree": {"sha": "0f77906c83eba7d64d2ad4eaf51b92785167415e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f77906c83eba7d64d2ad4eaf51b92785167415e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72a28e85d77bab7f1073ad2224d536ae232cfc50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72a28e85d77bab7f1073ad2224d536ae232cfc50", "html_url": "https://github.com/rust-lang/rust/commit/72a28e85d77bab7f1073ad2224d536ae232cfc50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72a28e85d77bab7f1073ad2224d536ae232cfc50/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c8bf5028f31c0d82bbf46a50b2375131a488623", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c8bf5028f31c0d82bbf46a50b2375131a488623", "html_url": "https://github.com/rust-lang/rust/commit/4c8bf5028f31c0d82bbf46a50b2375131a488623"}], "stats": {"total": 289, "additions": 137, "deletions": 152}, "files": [{"sha": "b06ad5b2f1c149ba1f05b25ba8dcd5c11cdc279c", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 137, "deletions": 152, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/72a28e85d77bab7f1073ad2224d536ae232cfc50/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a28e85d77bab7f1073ad2224d536ae232cfc50/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=72a28e85d77bab7f1073ad2224d536ae232cfc50", "patch": "@@ -104,6 +104,7 @@ pub struct ModuleConfig {\n     pub emit_ir: bool,\n     pub emit_asm: bool,\n     pub emit_obj: EmitObj,\n+\n     // Miscellaneous flags.  These are mostly copied from command-line\n     // options.\n     pub verify_llvm_ir: bool,\n@@ -118,77 +119,144 @@ pub struct ModuleConfig {\n }\n \n impl ModuleConfig {\n-    fn new(passes: Vec<String>) -> ModuleConfig {\n-        ModuleConfig {\n-            passes,\n-            opt_level: None,\n-            opt_size: None,\n-\n-            pgo_gen: SwitchWithOptPath::Disabled,\n-            pgo_use: None,\n-\n-            sanitizer: None,\n-            sanitizer_recover: Default::default(),\n-            sanitizer_memory_track_origins: 0,\n-\n-            emit_no_opt_bc: false,\n-            emit_pre_lto_bc: false,\n-            emit_bc: false,\n-            emit_bc_compressed: false,\n-            emit_ir: false,\n-            emit_asm: false,\n-            emit_obj: EmitObj::None,\n-\n-            verify_llvm_ir: false,\n-            no_prepopulate_passes: false,\n-            no_builtins: false,\n-            time_module: true,\n-            vectorize_loop: false,\n-            vectorize_slp: false,\n-            merge_functions: false,\n-            inline_threshold: None,\n-            new_llvm_pass_manager: None,\n+    fn new(kind: ModuleKind, sess: &Session, no_builtins: bool) -> ModuleConfig {\n+        // If it's a regular module, use `$regular`, otherwise use `$other`.\n+        // `$regular` and `$other` are evaluated lazily.\n+        macro_rules! if_regular {\n+            ($regular: expr, $other: expr) => {\n+                if let ModuleKind::Regular = kind { $regular } else { $other }\n+            };\n         }\n-    }\n \n-    fn set_flags(&mut self, sess: &Session, no_builtins: bool) {\n-        self.verify_llvm_ir = sess.verify_llvm_ir();\n-        self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n-        self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n-        self.inline_threshold = sess.opts.cg.inline_threshold;\n-        self.new_llvm_pass_manager = sess.opts.debugging_opts.new_llvm_pass_manager;\n-\n-        // Copy what clang does by turning on loop vectorization at O2 and\n-        // slp vectorization at O3. Otherwise configure other optimization aspects\n-        // of this pass manager builder.\n-        self.vectorize_loop = !sess.opts.cg.no_vectorize_loops\n-            && (sess.opts.optimize == config::OptLevel::Default\n-                || sess.opts.optimize == config::OptLevel::Aggressive);\n-\n-        self.vectorize_slp =\n-            !sess.opts.cg.no_vectorize_slp && sess.opts.optimize == config::OptLevel::Aggressive;\n-\n-        // Some targets (namely, NVPTX) interact badly with the MergeFunctions\n-        // pass. This is because MergeFunctions can generate new function calls\n-        // which may interfere with the target calling convention; e.g. for the\n-        // NVPTX target, PTX kernels should not call other PTX kernels.\n-        // MergeFunctions can also be configured to generate aliases instead,\n-        // but aliases are not supported by some backends (again, NVPTX).\n-        // Therefore, allow targets to opt out of the MergeFunctions pass,\n-        // but otherwise keep the pass enabled (at O2 and O3) since it can be\n-        // useful for reducing code size.\n-        self.merge_functions = match sess\n-            .opts\n-            .debugging_opts\n-            .merge_functions\n-            .unwrap_or(sess.target.target.options.merge_functions)\n+        let opt_level_and_size = if_regular!(Some(sess.opts.optimize), None);\n+\n+        let save_temps = sess.opts.cg.save_temps;\n+\n+        let should_emit_obj = sess.opts.output_types.contains_key(&OutputType::Exe)\n+            || match kind {\n+                ModuleKind::Regular => sess.opts.output_types.contains_key(&OutputType::Object),\n+                ModuleKind::Allocator => false,\n+                ModuleKind::Metadata => sess.opts.output_types.contains_key(&OutputType::Metadata),\n+            };\n+\n+        let emit_obj = if !should_emit_obj {\n+            EmitObj::None\n+        } else if sess.target.target.options.obj_is_bitcode\n+            || sess.opts.cg.linker_plugin_lto.enabled()\n         {\n-            MergeFunctions::Disabled => false,\n-            MergeFunctions::Trampolines | MergeFunctions::Aliases => {\n-                sess.opts.optimize == config::OptLevel::Default\n-                    || sess.opts.optimize == config::OptLevel::Aggressive\n+            EmitObj::Bitcode\n+        } else if sess.opts.debugging_opts.embed_bitcode {\n+            match sess.opts.optimize {\n+                config::OptLevel::No | config::OptLevel::Less => {\n+                    EmitObj::ObjectCode(BitcodeSection::Marker)\n+                }\n+                _ => EmitObj::ObjectCode(BitcodeSection::Full),\n             }\n+        } else {\n+            EmitObj::ObjectCode(BitcodeSection::None)\n         };\n+\n+        ModuleConfig {\n+            passes: if_regular!(\n+                {\n+                    let mut passes = sess.opts.cg.passes.clone();\n+                    if sess.opts.debugging_opts.profile {\n+                        passes.push(\"insert-gcov-profiling\".to_owned());\n+                    }\n+                    passes\n+                },\n+                vec![]\n+            ),\n+\n+            opt_level: opt_level_and_size,\n+            opt_size: opt_level_and_size,\n+\n+            pgo_gen: if_regular!(\n+                sess.opts.cg.profile_generate.clone(),\n+                SwitchWithOptPath::Disabled\n+            ),\n+            pgo_use: if_regular!(sess.opts.cg.profile_use.clone(), None),\n+\n+            sanitizer: if_regular!(sess.opts.debugging_opts.sanitizer.clone(), None),\n+            sanitizer_recover: if_regular!(\n+                sess.opts.debugging_opts.sanitizer_recover.clone(),\n+                vec![]\n+            ),\n+            sanitizer_memory_track_origins: if_regular!(\n+                sess.opts.debugging_opts.sanitizer_memory_track_origins,\n+                0\n+            ),\n+\n+            emit_pre_lto_bc: if_regular!(\n+                save_temps || need_pre_lto_bitcode_for_incr_comp(sess),\n+                false\n+            ),\n+            emit_no_opt_bc: if_regular!(save_temps, false),\n+            emit_bc: if_regular!(\n+                save_temps || sess.opts.output_types.contains_key(&OutputType::Bitcode),\n+                save_temps\n+            ),\n+            emit_bc_compressed: match kind {\n+                ModuleKind::Regular | ModuleKind::Allocator => {\n+                    // Emit compressed bitcode files for the crate if we're\n+                    // emitting an rlib. Whenever an rlib is created, the\n+                    // bitcode is inserted into the archive in order to allow\n+                    // LTO against it.\n+                    need_crate_bitcode_for_rlib(sess)\n+                }\n+                ModuleKind::Metadata => false,\n+            },\n+            emit_ir: if_regular!(\n+                sess.opts.output_types.contains_key(&OutputType::LlvmAssembly),\n+                false\n+            ),\n+            emit_asm: if_regular!(\n+                sess.opts.output_types.contains_key(&OutputType::Assembly),\n+                false\n+            ),\n+            emit_obj,\n+\n+            verify_llvm_ir: sess.verify_llvm_ir(),\n+            no_prepopulate_passes: sess.opts.cg.no_prepopulate_passes,\n+            no_builtins: no_builtins || sess.target.target.options.no_builtins,\n+\n+            // Exclude metadata and allocator modules from time_passes output,\n+            // since they throw off the \"LLVM passes\" measurement.\n+            time_module: if_regular!(true, false),\n+\n+            // Copy what clang does by turning on loop vectorization at O2 and\n+            // slp vectorization at O3.\n+            vectorize_loop: !sess.opts.cg.no_vectorize_loops\n+                && (sess.opts.optimize == config::OptLevel::Default\n+                    || sess.opts.optimize == config::OptLevel::Aggressive),\n+            vectorize_slp: !sess.opts.cg.no_vectorize_slp\n+                && sess.opts.optimize == config::OptLevel::Aggressive,\n+\n+            // Some targets (namely, NVPTX) interact badly with the\n+            // MergeFunctions pass. This is because MergeFunctions can generate\n+            // new function calls which may interfere with the target calling\n+            // convention; e.g. for the NVPTX target, PTX kernels should not\n+            // call other PTX kernels. MergeFunctions can also be configured to\n+            // generate aliases instead, but aliases are not supported by some\n+            // backends (again, NVPTX). Therefore, allow targets to opt out of\n+            // the MergeFunctions pass, but otherwise keep the pass enabled (at\n+            // O2 and O3) since it can be useful for reducing code size.\n+            merge_functions: match sess\n+                .opts\n+                .debugging_opts\n+                .merge_functions\n+                .unwrap_or(sess.target.target.options.merge_functions)\n+            {\n+                MergeFunctions::Disabled => false,\n+                MergeFunctions::Trampolines | MergeFunctions::Aliases => {\n+                    sess.opts.optimize == config::OptLevel::Default\n+                        || sess.opts.optimize == config::OptLevel::Aggressive\n+                }\n+            },\n+\n+            inline_threshold: sess.opts.cg.inline_threshold,\n+            new_llvm_pass_manager: sess.opts.debugging_opts.new_llvm_pass_manager,\n+        }\n     }\n \n     pub fn bitcode_needed(&self) -> bool {\n@@ -353,92 +421,9 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let linker_info = LinkerInfo::new(tcx);\n     let crate_info = CrateInfo::new(tcx);\n \n-    // Figure out what we actually need to build.\n-    let mut modules_config = ModuleConfig::new(sess.opts.cg.passes.clone());\n-    let mut metadata_config = ModuleConfig::new(vec![]);\n-    let mut allocator_config = ModuleConfig::new(vec![]);\n-\n-    if sess.opts.debugging_opts.profile {\n-        modules_config.passes.push(\"insert-gcov-profiling\".to_owned())\n-    }\n-\n-    modules_config.pgo_gen = sess.opts.cg.profile_generate.clone();\n-    modules_config.pgo_use = sess.opts.cg.profile_use.clone();\n-    modules_config.sanitizer = sess.opts.debugging_opts.sanitizer.clone();\n-    modules_config.sanitizer_recover = sess.opts.debugging_opts.sanitizer_recover.clone();\n-    modules_config.sanitizer_memory_track_origins =\n-        sess.opts.debugging_opts.sanitizer_memory_track_origins;\n-    modules_config.opt_level = Some(sess.opts.optimize);\n-    modules_config.opt_size = Some(sess.opts.optimize);\n-\n-    // Save all versions of the bytecode if we're saving our temporaries.\n-    if sess.opts.cg.save_temps {\n-        modules_config.emit_no_opt_bc = true;\n-        modules_config.emit_pre_lto_bc = true;\n-        modules_config.emit_bc = true;\n-        metadata_config.emit_bc = true;\n-        allocator_config.emit_bc = true;\n-    }\n-\n-    // Emit compressed bitcode files for the crate if we're emitting an rlib.\n-    // Whenever an rlib is created, the bitcode is inserted into the archive in\n-    // order to allow LTO against it.\n-    if need_crate_bitcode_for_rlib(sess) {\n-        modules_config.emit_bc_compressed = true;\n-        allocator_config.emit_bc_compressed = true;\n-    }\n-\n-    let emit_obj =\n-        if sess.target.target.options.obj_is_bitcode || sess.opts.cg.linker_plugin_lto.enabled() {\n-            EmitObj::Bitcode\n-        } else if sess.opts.debugging_opts.embed_bitcode {\n-            match sess.opts.optimize {\n-                config::OptLevel::No | config::OptLevel::Less => {\n-                    EmitObj::ObjectCode(BitcodeSection::Marker)\n-                }\n-                _ => EmitObj::ObjectCode(BitcodeSection::Full),\n-            }\n-        } else {\n-            EmitObj::ObjectCode(BitcodeSection::None)\n-        };\n-\n-    modules_config.emit_pre_lto_bc = need_pre_lto_bitcode_for_incr_comp(sess);\n-\n-    for output_type in sess.opts.output_types.keys() {\n-        match *output_type {\n-            OutputType::Bitcode => {\n-                modules_config.emit_bc = true;\n-            }\n-            OutputType::LlvmAssembly => {\n-                modules_config.emit_ir = true;\n-            }\n-            OutputType::Assembly => {\n-                modules_config.emit_asm = true;\n-            }\n-            OutputType::Object => {\n-                modules_config.emit_obj = emit_obj;\n-            }\n-            OutputType::Metadata => {\n-                metadata_config.emit_obj = emit_obj;\n-            }\n-            OutputType::Exe => {\n-                modules_config.emit_obj = emit_obj;\n-                metadata_config.emit_obj = emit_obj;\n-                allocator_config.emit_obj = emit_obj;\n-            }\n-            OutputType::Mir => {}\n-            OutputType::DepInfo => {}\n-        }\n-    }\n-\n-    modules_config.set_flags(sess, no_builtins);\n-    metadata_config.set_flags(sess, no_builtins);\n-    allocator_config.set_flags(sess, no_builtins);\n-\n-    // Exclude metadata and allocator modules from time_passes output, since\n-    // they throw off the \"LLVM passes\" measurement.\n-    metadata_config.time_module = false;\n-    allocator_config.time_module = false;\n+    let modules_config = ModuleConfig::new(ModuleKind::Regular, sess, no_builtins);\n+    let metadata_config = ModuleConfig::new(ModuleKind::Metadata, sess, no_builtins);\n+    let allocator_config = ModuleConfig::new(ModuleKind::Allocator, sess, no_builtins);\n \n     let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n     let (codegen_worker_send, codegen_worker_receive) = channel();"}]}