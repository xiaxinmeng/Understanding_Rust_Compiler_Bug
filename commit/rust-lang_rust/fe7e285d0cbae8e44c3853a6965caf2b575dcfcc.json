{"sha": "fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlN2UyODVkMGNiYWU4ZTQ0YzM4NTNhNjk2NWNhZjJiNTc1ZGNmY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-03T14:20:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-03T14:20:47Z"}, "message": "auto merge of #20432 : nikomatsakis/rust/fn-inference-2, r=eddyb\n\nPreviously, the borrow mode of each upvar was inferred as part of regionck. This PR moves it into its own separate step. It also employs the `ExprUseVisitor`, further simplifying the code. The eventual goal is to support better inference of `Fn` vs `FnMut` vs `FnOnce` that is not based on the expected type, as well as supporting individual by-move upvars.\r\n\r\nr? @eddyb", "tree": {"sha": "b373f2a7540f38f2e2e70a5fd194839e2ddf576d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b373f2a7540f38f2e2e70a5fd194839e2ddf576d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "html_url": "https://github.com/rust-lang/rust/commit/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2ba13939aa9672d886beb06efde7aeda2d5f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2ba13939aa9672d886beb06efde7aeda2d5f7f", "html_url": "https://github.com/rust-lang/rust/commit/fc2ba13939aa9672d886beb06efde7aeda2d5f7f"}, {"sha": "cbeff8b8b3bd28e99a3a034a41c8bdcd830fa884", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbeff8b8b3bd28e99a3a034a41c8bdcd830fa884", "html_url": "https://github.com/rust-lang/rust/commit/cbeff8b8b3bd28e99a3a034a41c8bdcd830fa884"}], "stats": {"total": 1921, "additions": 1064, "deletions": 857}, "files": [{"sha": "53249c724627e0839cb5197367d4b38b2f7086d3", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -1612,15 +1612,11 @@ impl LintPass for MissingCopyImplementations {\n             }\n             _ => return,\n         };\n-        let parameter_environment = ty::empty_parameter_environment();\n-        if !ty::type_moves_by_default(cx.tcx,\n-                                      ty,\n-                                      &parameter_environment) {\n+        let parameter_environment = ty::empty_parameter_environment(cx.tcx);\n+        if !ty::type_moves_by_default(&parameter_environment, item.span, ty) {\n             return\n         }\n-        if ty::can_type_implement_copy(cx.tcx,\n-                                       ty,\n-                                       &parameter_environment).is_ok() {\n+        if ty::can_type_implement_copy(&parameter_environment, item.span, ty).is_ok() {\n             cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n                          item.span,\n                          \"type could implement `Copy`; consider adding `impl \\"}, {"sha": "9cb8674c3e1b7478137e2b37a1c598ae92b049b0", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -99,7 +99,7 @@ impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n \n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub param_env: ParameterEnvironment<'tcx>,\n+    pub param_env: ParameterEnvironment<'a, 'tcx>,\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -148,7 +148,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut MatchCheckCtxt {\n         tcx: tcx,\n-        param_env: ty::empty_parameter_environment(),\n+        param_env: ty::empty_parameter_environment(tcx),\n     }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n@@ -1032,9 +1032,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                 match p.node {\n                     ast::PatIdent(ast::BindByValue(_), _, ref sub) => {\n                         let pat_ty = ty::node_id_to_type(tcx, p.id);\n-                        if ty::type_moves_by_default(tcx,\n-                                                      pat_ty,\n-                                                      &cx.param_env) {\n+                        if ty::type_moves_by_default(&cx.param_env, pat.span, pat_ty) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n@@ -1063,8 +1061,7 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n         cx: cx,\n     };\n     let mut visitor = ExprUseVisitor::new(&mut checker,\n-                                          checker.cx.tcx,\n-                                          &cx.param_env);\n+                                          &checker.cx.param_env);\n     visitor.walk_expr(guard);\n }\n "}, {"sha": "c383b1579ef84332a9817a10dc5cafc9dc133ba6", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n         {\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n             let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n-            let mut euv = euv::ExprUseVisitor::new(&mut delegate, self.tcx, &param_env);\n+            let mut euv = euv::ExprUseVisitor::new(&mut delegate, &param_env);\n             euv.walk_fn(fd, b);\n         }\n         visit::walk_fn(self, fk, fd, b, s)\n@@ -50,7 +50,7 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n \n struct RvalueContextDelegate<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'a,'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n@@ -60,7 +60,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n-        if !ty::type_is_sized(self.tcx, cmt.ty, self.param_env) {\n+        if !ty::type_is_sized(self.param_env, span, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n                 ty_to_string(self.tcx, cmt.ty));"}, {"sha": "9c9e68002c980d9c40e2c6b5b2177f019b54aa5e", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -54,7 +54,7 @@ struct CheckStaticVisitor<'a, 'tcx: 'a> {\n }\n \n struct GlobalVisitor<'a,'b,'tcx:'a+'b>(\n-    euv::ExprUseVisitor<'a,'b,'tcx,ty::ctxt<'tcx>>);\n+    euv::ExprUseVisitor<'a,'b,'tcx,ty::ParameterEnvironment<'b,'tcx>>);\n struct GlobalChecker {\n     static_consumptions: NodeSet,\n     const_borrows: NodeSet,\n@@ -70,8 +70,8 @@ pub fn check_crate(tcx: &ty::ctxt) {\n         static_local_borrows: NodeSet::new(),\n     };\n     {\n-        let param_env = ty::empty_parameter_environment();\n-        let visitor = euv::ExprUseVisitor::new(&mut checker, tcx, &param_env);\n+        let param_env = ty::empty_parameter_environment(tcx);\n+        let visitor = euv::ExprUseVisitor::new(&mut checker, &param_env);\n         visit::walk_crate(&mut GlobalVisitor(visitor), tcx.map.krate());\n     }\n     visit::walk_crate(&mut CheckStaticVisitor {\n@@ -121,8 +121,8 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        let env = ty::empty_parameter_environment();\n-        match fulfill_cx.select_all_or_error(&infcx, &env, self.tcx) {\n+        let env = ty::empty_parameter_environment(self.tcx);\n+        match fulfill_cx.select_all_or_error(&infcx, &env) {\n             Ok(()) => { },\n             Err(ref errors) => {\n                 traits::report_fulfillment_errors(&infcx, errors);"}, {"sha": "acbb7d567dceac8b253230a17d00fb9163e0e08c", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -126,6 +126,12 @@ impl TraitItemKind {\n }\n \n impl Def {\n+    pub fn local_node_id(&self) -> ast::NodeId {\n+        let def_id = self.def_id();\n+        assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+        def_id.node\n+    }\n+\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n             DefFn(id, _) | DefStaticMethod(id, _) | DefMod(id) |"}, {"sha": "f5cf4af1230a4a02dc66d1ba95599bf3a7fdf313", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 99, "deletions": 72, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -23,7 +23,7 @@ use self::OverloadedCallType::*;\n use middle::{def, region, pat_util};\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Typer;\n-use middle::ty::{mod, ParameterEnvironment, Ty};\n+use middle::ty::{mod};\n use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::ty::{MethodStatic, MethodStaticUnboxedClosure};\n@@ -299,7 +299,22 @@ pub struct ExprUseVisitor<'d,'t,'tcx:'t,TYPER:'t> {\n     typer: &'t TYPER,\n     mc: mc::MemCategorizationContext<'t,TYPER>,\n     delegate: &'d mut (Delegate<'tcx>+'d),\n-    param_env: &'t ParameterEnvironment<'tcx>,\n+}\n+\n+// If the TYPER results in an error, it's because the type check\n+// failed (or will fail, when the error is uncovered and reported\n+// during writeback). In this case, we just ignore this part of the\n+// code.\n+//\n+// Note that this macro appears similar to try!(), but, unlike try!(),\n+// it does not propagate the error.\n+macro_rules! return_if_err {\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => v,\n+            Err(()) => return\n+        }\n+    )\n }\n \n /// Whether the elements of an overloaded operation are passed by value or by reference\n@@ -310,14 +325,12 @@ enum PassArgs {\n \n impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     pub fn new(delegate: &'d mut Delegate<'tcx>,\n-               typer: &'t TYPER,\n-               param_env: &'t ParameterEnvironment<'tcx>)\n+               typer: &'t TYPER)\n                -> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         ExprUseVisitor {\n             typer: typer,\n             mc: mc::MemCategorizationContext::new(typer),\n             delegate: delegate,\n-            param_env: param_env,\n         }\n     }\n \n@@ -332,7 +345,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                          decl: &ast::FnDecl,\n                          body: &ast::Block) {\n         for arg in decl.inputs.iter() {\n-            let arg_ty = self.typer.node_ty(arg.pat.id);\n+            let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n \n             let fn_body_scope = region::CodeExtent::from_node_id(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -353,10 +366,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n                         cmt: mc::cmt<'tcx>) {\n-        let mode = copy_or_move(self.tcx(),\n-                                cmt.ty,\n-                                self.param_env,\n-                                DirectRefMove);\n+        let mode = copy_or_move(self.typer, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -369,7 +379,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     pub fn consume_expr(&mut self, expr: &ast::Expr) {\n         debug!(\"consume_expr(expr={})\", expr.repr(self.tcx()));\n \n-        let cmt = self.mc.cat_expr(expr);\n+        let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate_consume(expr.id, expr.span, cmt);\n         self.walk_expr(expr);\n     }\n@@ -378,7 +388,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                    assignment_expr: &ast::Expr,\n                    expr: &ast::Expr,\n                    mode: MutateMode) {\n-        let cmt = self.mc.cat_expr(expr);\n+        let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.mutate(assignment_expr.id, assignment_expr.span, cmt, mode);\n         self.walk_expr(expr);\n     }\n@@ -391,7 +401,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"borrow_expr(expr={}, r={}, bk={})\",\n                expr.repr(self.tcx()), r.repr(self.tcx()), bk.repr(self.tcx()));\n \n-        let cmt = self.mc.cat_expr(expr);\n+        let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n \n         // Note: Unlike consume, we can ignore ExprParen. cat_expr\n@@ -491,7 +501,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprMatch(ref discr, ref arms, _) => {\n-                let discr_cmt = self.mc.cat_expr(&**discr);\n+                let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n                 self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n@@ -509,7 +519,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             ast::ExprAddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n-                let expr_ty = ty::expr_ty(self.tcx(), expr);\n+                let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n                 let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n                 let bk = ty::BorrowKind::from_mutbl(m);\n                 self.borrow_expr(&**base, r, bk, AddrOf);\n@@ -550,7 +560,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // Fetch the type of the value that the iteration yields to\n                 // produce the pattern's categorized mutable type.\n-                let pattern_type = self.typer.node_ty(pat.id);\n+                let pattern_type = return_if_err!(self.typer.node_ty(pat.id));\n                 let blk_scope = region::CodeExtent::from_node_id(blk.id);\n                 let pat_cmt = self.mc.cat_rvalue(pat.id,\n                                                  pat.span,\n@@ -638,7 +648,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn walk_callee(&mut self, call: &ast::Expr, callee: &ast::Expr) {\n-        let callee_ty = self.typer.expr_ty_adjusted(callee);\n+        let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={} callee_ty={}\",\n                callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n         let call_scope = region::CodeExtent::from_node_id(call.id);\n@@ -659,6 +669,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     }\n                 }\n             }\n+            ty::ty_err => { }\n             _ => {\n                 let overloaded_call_type =\n                     match self.typer.node_method_origin(MethodCall::expr(call.id)) {\n@@ -735,7 +746,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n                 self.walk_expr(&**expr);\n-                let init_cmt = self.mc.cat_expr(&**expr);\n+                let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n                 self.walk_irrefutable_pat(init_cmt, &*local.pat);\n             }\n         }\n@@ -769,7 +780,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             None => { return; }\n         };\n \n-        let with_cmt = self.mc.cat_expr(&*with_expr);\n+        let with_cmt = return_if_err!(self.mc.cat_expr(&*with_expr));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -778,9 +789,17 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 ty::struct_fields(self.tcx(), did, substs)\n             }\n             _ => {\n-                self.tcx().sess.span_bug(\n-                    with_expr.span,\n-                    \"with expression doesn't evaluate to a struct\");\n+                // the base expression should always evaluate to a\n+                // struct; however, when EUV is run during typeck, it\n+                // may not. This will generate an error earlier in typeck,\n+                // so we can just ignore it.\n+                if !self.tcx().sess.has_errors() {\n+                    self.tcx().sess.span_bug(\n+                        with_expr.span,\n+                        \"with expression doesn't evaluate to a struct\");\n+                }\n+                assert!(self.tcx().sess.has_errors());\n+                vec!()\n             }\n         };\n \n@@ -824,7 +843,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // rvalue.\n                         debug!(\"walk_adjustment(AutoAddEnv|AdjustReifyFnPointer)\");\n                         let cmt_unadjusted =\n-                            self.mc.cat_expr_unadjusted(expr);\n+                            return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                     }\n                     ty::AdjustDerefRef(ty::AutoDerefRef {\n@@ -858,7 +877,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             match self.typer.node_method_ty(deref_id) {\n                 None => {}\n                 Some(method_ty) => {\n-                    let cmt = self.mc.cat_expr_autoderefd(expr, i);\n+                    let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n                     let self_ty = ty::ty_fn_args(method_ty)[0];\n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n@@ -888,14 +907,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 assert!(n == 1, format!(\"Expected exactly 1 deref with Uniq \\\n                                          AutoRefs, found: {}\", n));\n                 let cmt_unadjusted =\n-                    self.mc.cat_expr_unadjusted(expr);\n+                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                 self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 return;\n             }\n             _ => {}\n         }\n \n-        let cmt_derefd = self.mc.cat_expr_autoderefd(expr, n);\n+        let cmt_derefd = return_if_err!(\n+            self.mc.cat_expr_autoderefd(expr, n));\n         debug!(\"walk_adjustment: cmt_derefd={}\",\n                cmt_derefd.repr(self.tcx()));\n \n@@ -988,18 +1008,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                mode: &mut TrackMatchMode<Span>) {\n         debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n-        self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n-            let tcx = self.typer.tcx();\n-            let def_map = &self.typer.tcx().def_map;\n+        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n+            let tcx = self.tcx();\n+            let def_map = &self.tcx().def_map;\n             if pat_util::pat_is_binding(def_map, pat) {\n                 match pat.node {\n                     ast::PatIdent(ast::BindByRef(_), _, _) =>\n                         mode.lub(BorrowingMatch),\n                     ast::PatIdent(ast::BindByValue(_), _, _) => {\n-                        match copy_or_move(tcx,\n-                                           cmt_pat.ty,\n-                                           self.param_env,\n-                                           PatBindingMove) {\n+                        match copy_or_move(self.typer, &cmt_pat, PatBindingMove) {\n                             Copy => mode.lub(CopyingMatch),\n                             Move(_) => mode.lub(MovingMatch),\n                         }\n@@ -1011,7 +1028,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     }\n                 }\n             }\n-        });\n+        }));\n     }\n \n     /// The core driver for walking a pattern; `match_mode` must be\n@@ -1026,10 +1043,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n         let mc = &self.mc;\n         let typer = self.typer;\n-        let def_map = &self.typer.tcx().def_map;\n+        let def_map = &self.tcx().def_map;\n         let delegate = &mut self.delegate;\n-        let param_env = self.param_env;\n-        mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n@@ -1039,13 +1055,17 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                        match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = typer.node_ty(pat.id);\n+                let pat_ty = return_if_err!(typer.node_ty(pat.id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n                 let def = def_map.borrow()[pat.id].clone();\n-                let binding_cmt = mc.cat_def(pat.id, pat.span, pat_ty, def);\n-                delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n+                match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n+                    Ok(binding_cmt) => {\n+                        delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n+                    }\n+                    Err(_) => { }\n+                }\n \n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n@@ -1058,15 +1078,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                              r, bk, RefBinding);\n                     }\n                     ast::PatIdent(ast::BindByValue(_), _, _) => {\n-                        let mode = copy_or_move(typer.tcx(),\n-                                                cmt_pat.ty,\n-                                                param_env,\n-                                                PatBindingMove);\n+                        let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n                     _ => {\n-                        typer.tcx().sess.span_bug(\n+                        tcx.sess.span_bug(\n                             pat.span,\n                             \"binding pattern not an identifier\");\n                     }\n@@ -1080,7 +1097,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // matched.\n \n                         let (slice_cmt, slice_mutbl, slice_r) =\n-                            mc.cat_slice_pattern(cmt_pat, &**slice_pat);\n+                            return_if_err!(mc.cat_slice_pattern(cmt_pat, &**slice_pat));\n \n                         // Note: We declare here that the borrow\n                         // occurs upon entering the `[...]`\n@@ -1110,13 +1127,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     _ => { }\n                 }\n             }\n-        });\n+        }));\n \n         // Do a second pass over the pattern, calling `matched_pat` on\n         // the interior nodes (enum variants and structs), as opposed\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n-        mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             let def_map = def_map.borrow();\n             let tcx = typer.tcx();\n \n@@ -1167,17 +1184,29 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // An enum's type -- should never be in a\n                             // pattern.\n \n-                            let msg = format!(\"Pattern has unexpected type: {}\", def);\n-                            tcx.sess.span_bug(pat.span, msg[])\n+                            if !tcx.sess.has_errors() {\n+                                let msg = format!(\"Pattern has unexpected type: {} and type {}\",\n+                                                  def,\n+                                                  cmt_pat.ty.repr(tcx));\n+                                tcx.sess.span_bug(pat.span, msg[])\n+                            }\n                         }\n \n                         Some(def) => {\n                             // Remaining cases are e.g. DefFn, to\n                             // which identifiers within patterns\n-                            // should not resolve.\n-\n-                            let msg = format!(\"Pattern has unexpected def: {}\", def);\n-                            tcx.sess.span_bug(pat.span, msg[])\n+                            // should not resolve. However, we do\n+                            // encouter this when using the\n+                            // expr-use-visitor during typeck. So just\n+                            // ignore it, an error should have been\n+                            // reported.\n+\n+                            if !tcx.sess.has_errors() {\n+                                let msg = format!(\"Pattern has unexpected def: {} and type {}\",\n+                                                  def,\n+                                                  cmt_pat.ty.repr(tcx));\n+                                tcx.sess.span_bug(pat.span, msg[])\n+                            }\n                         }\n                     }\n                 }\n@@ -1197,14 +1226,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     // cases either.\n                 }\n             }\n-        });\n+        }));\n     }\n \n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n         debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n \n-        let tcx = self.typer.tcx();\n-        ty::with_freevars(tcx, closure_expr.id, |freevars| {\n+        ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n             match self.tcx().capture_mode(closure_expr.id) {\n                 ast::CaptureByRef => {\n                     self.walk_by_ref_captures(closure_expr, freevars);\n@@ -1221,9 +1249,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let id_var = freevar.def.def_id().node;\n-            let cmt_var = self.cat_captured_var(closure_expr.id,\n-                                                closure_expr.span,\n-                                                freevar.def);\n+            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n+                                                               closure_expr.span,\n+                                                               freevar.def));\n \n             // Lookup the kind of borrow the callee requires, as\n             // inferred by regionbk\n@@ -1244,11 +1272,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                               closure_expr: &ast::Expr,\n                               freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n-            let cmt_var = self.cat_captured_var(closure_expr.id,\n-                                                closure_expr.span,\n-                                                freevar.def);\n-            let mode = copy_or_move(self.tcx(), cmt_var.ty,\n-                                    self.param_env, CaptureMove);\n+            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n+                                                               closure_expr.span,\n+                                                               freevar.def));\n+            let mode = copy_or_move(self.typer, &cmt_var, CaptureMove);\n             self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n         }\n     }\n@@ -1257,21 +1284,21 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n                         upvar_def: def::Def)\n-                        -> mc::cmt<'tcx> {\n+                        -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = upvar_def.def_id().node;\n-        let var_ty = self.typer.node_ty(var_id);\n+        let var_ty = try!(self.typer.node_ty(var_id));\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }\n \n-fn copy_or_move<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                      ty: Ty<'tcx>,\n-                      param_env: &ParameterEnvironment<'tcx>,\n+fn copy_or_move<'tcx>(typer: &mc::Typer<'tcx>,\n+                      cmt: &mc::cmt<'tcx>,\n                       move_reason: MoveReason)\n-                      -> ConsumeMode {\n-    if ty::type_moves_by_default(tcx, ty, param_env) {\n+                      -> ConsumeMode\n+{\n+    if typer.type_moves_by_default(cmt.span, cmt.ty) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "2962b7b7c8e48b2727eab61cb4c53d24df2a029f", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -41,7 +41,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n     // environments for each function we encounter. When we find a\n     // call to `transmute`, we can check it in the context of the top\n     // of the stack (which ought not to be empty).\n-    param_envs: Vec<ty::ParameterEnvironment<'tcx>>,\n+    param_envs: Vec<ty::ParameterEnvironment<'a,'tcx>>,\n \n     // Dummy sized/unsized types that use to substitute for type\n     // parameters in order to estimate how big a type will be for any\n@@ -170,6 +170,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n \n         let mut substs = param_env.free_substs.clone();\n         self.with_each_combination(\n+            span,\n             param_env,\n             param_env.free_substs.types.iter_enumerated(),\n             &mut substs,\n@@ -187,7 +188,8 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n \n     fn with_each_combination(&self,\n-                             param_env: &ty::ParameterEnvironment<'tcx>,\n+                             span: Span,\n+                             param_env: &ty::ParameterEnvironment<'a,'tcx>,\n                              mut types_in_scope: EnumeratedItems<Ty<'tcx>>,\n                              substs: &mut Substs<'tcx>,\n                              callback: &mut FnMut(&Substs<'tcx>))\n@@ -210,15 +212,17 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n                 debug!(\"with_each_combination: space={}, index={}, param_ty={}\",\n                        space, index, param_ty.repr(self.tcx));\n \n-                if !ty::type_is_sized(self.tcx, param_ty, param_env) {\n+                if !ty::type_is_sized(param_env, span, param_ty) {\n                     debug!(\"with_each_combination: param_ty is not known to be sized\");\n \n                     substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;\n-                    self.with_each_combination(param_env, types_in_scope.clone(), substs, callback);\n+                    self.with_each_combination(span, param_env, types_in_scope.clone(),\n+                                               substs, callback);\n                 }\n \n                 substs.types.get_mut_slice(space)[index] = self.dummy_sized_ty;\n-                self.with_each_combination(param_env, types_in_scope, substs, callback);\n+                self.with_each_combination(span, param_env, types_in_scope,\n+                                           substs, callback);\n             }\n         }\n     }"}, {"sha": "722fe82d41c32446bd3f3bbdfcd77008d9a1f690", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 180, "deletions": 185, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -75,7 +75,7 @@ use middle::def;\n use middle::region;\n use middle::ty::{mod, Ty};\n use util::nodemap::{NodeMap};\n-use util::ppaux::{ty_to_string, Repr};\n+use util::ppaux::{Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n@@ -195,51 +195,39 @@ pub enum deref_kind {\n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n-pub fn opt_deref_kind(t: Ty) -> Option<deref_kind> {\n+pub fn deref_kind(t: Ty) -> McResult<deref_kind> {\n     match t.sty {\n         ty::ty_uniq(_) |\n         ty::ty_closure(box ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n-            Some(deref_ptr(Unique))\n+            Ok(deref_ptr(Unique))\n         }\n \n         ty::ty_rptr(r, mt) => {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n-            Some(deref_ptr(BorrowedPtr(kind, *r)))\n+            Ok(deref_ptr(BorrowedPtr(kind, *r)))\n         }\n \n         ty::ty_closure(box ty::ClosureTy {\n                 store: ty::RegionTraitStore(r, _),\n                 ..\n             }) => {\n-            Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n+            Ok(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n         }\n \n         ty::ty_ptr(ref mt) => {\n-            Some(deref_ptr(UnsafePtr(mt.mutbl)))\n+            Ok(deref_ptr(UnsafePtr(mt.mutbl)))\n         }\n \n         ty::ty_enum(..) |\n         ty::ty_struct(..) => { // newtype\n-            Some(deref_interior(InteriorField(PositionalField(0))))\n+            Ok(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n         ty::ty_vec(_, _) | ty::ty_str => {\n-            Some(deref_interior(InteriorElement(element_kind(t))))\n+            Ok(deref_interior(InteriorElement(element_kind(t))))\n         }\n \n-        _ => None\n-    }\n-}\n-\n-pub fn deref_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> deref_kind {\n-    debug!(\"deref_kind {}\", ty_to_string(tcx, t));\n-    match opt_deref_kind(t) {\n-      Some(k) => k,\n-      None => {\n-        tcx.sess.bug(\n-            format!(\"deref_kind() invoked on non-derefable type {}\",\n-                    ty_to_string(tcx, t))[]);\n-      }\n+        _ => Err(()),\n     }\n }\n \n@@ -264,6 +252,8 @@ pub struct MemCategorizationContext<'t,TYPER:'t> {\n \n impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n \n+pub type McResult<T> = Result<T, ()>;\n+\n /// The `Typer` trait provides the interface for the mem-categorization\n /// module to the results of the type check. It can be used to query\n /// the type assigned to an expression node, to inquire after adjustments,\n@@ -282,8 +272,9 @@ impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n /// can be sure that only `Ok` results will occur.\n pub trait Typer<'tcx> : ty::UnboxedClosureTyper<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx>;\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx>;\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool;\n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>;\n@@ -382,24 +373,24 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         self.typer.tcx()\n     }\n \n-    fn expr_ty(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+    fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(expr.id)\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n-        let unadjusted_ty = self.expr_ty(expr);\n-        ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n-                      self.typer.adjustments().borrow().get(&expr.id),\n-                      |method_call| self.typer.node_method_ty(method_call))\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+        let unadjusted_ty = try!(self.expr_ty(expr));\n+        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n+                         self.typer.adjustments().borrow().get(&expr.id),\n+                         |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&self, pat: &ast::Pat) -> Ty<'tcx> {\n+    fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n         let tcx = self.typer.tcx();\n-        let base_ty = self.typer.node_ty(pat.id);\n+        let base_ty = try!(self.typer.node_ty(pat.id));\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n@@ -409,18 +400,19 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n-                ty::deref(base_ty, false).unwrap_or_else(|| {\n-                    panic!(\"encountered BindByRef with non &-type\");\n-                }).ty\n+                match ty::deref(base_ty, false) {\n+                    Some(t) => t.ty,\n+                    None => { return Err(()); }\n+                }\n             }\n             _ => base_ty,\n         };\n         debug!(\"pat_ty(pat={}) base_ty={} ret_ty={}\",\n                pat.repr(tcx), base_ty.repr(tcx), ret_ty.repr(tcx));\n-        ret_ty\n+        Ok(ret_ty)\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> cmt<'tcx> {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n         match self.typer.adjustments().borrow().get(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -434,8 +426,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                expr.repr(self.tcx()));\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n-                        let expr_ty = self.expr_ty_adjusted(expr);\n-                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                        let expr_ty = try!(self.expr_ty_adjusted(expr));\n+                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n                     ty::AdjustDerefRef(\n@@ -445,8 +437,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                expr.repr(self.tcx()));\n                         // Equivalent to &*expr or something similar.\n                         // Result is an rvalue.\n-                        let expr_ty = self.expr_ty_adjusted(expr);\n-                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                        let expr_ty = try!(self.expr_ty_adjusted(expr));\n+                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n                     ty::AdjustDerefRef(\n@@ -463,46 +455,46 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n                                autoderefs: uint)\n-                               -> cmt<'tcx> {\n-        let mut cmt = self.cat_expr_unadjusted(expr);\n+                               -> McResult<cmt<'tcx>> {\n+        let mut cmt = try!(self.cat_expr_unadjusted(expr));\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n                autoderefs,\n                cmt.repr(self.tcx()));\n         for deref in range(1u, autoderefs + 1) {\n-            cmt = self.cat_deref(expr, cmt, deref, false);\n+            cmt = try!(self.cat_deref(expr, cmt, deref, false));\n         }\n-        return cmt;\n+        return Ok(cmt);\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> cmt<'tcx> {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n         debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n \n-        let expr_ty = self.expr_ty(expr);\n+        let expr_ty = try!(self.expr_ty(expr));\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, ref e_base) => {\n-            let base_cmt = self.cat_expr(&**e_base);\n+            let base_cmt = try!(self.cat_expr(&**e_base));\n             self.cat_deref(expr, base_cmt, 0, false)\n           }\n \n           ast::ExprField(ref base, f_name) => {\n-            let base_cmt = self.cat_expr(&**base);\n+            let base_cmt = try!(self.cat_expr(&**base));\n             debug!(\"cat_expr(cat_field): id={} expr={} base={}\",\n                    expr.id,\n                    expr.repr(self.tcx()),\n                    base_cmt.repr(self.tcx()));\n-            self.cat_field(expr, base_cmt, f_name.node.name, expr_ty)\n+            Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n           }\n \n           ast::ExprTupField(ref base, idx) => {\n-            let base_cmt = self.cat_expr(&**base);\n-            self.cat_tup_field(expr, base_cmt, idx.node, expr_ty)\n+            let base_cmt = try!(self.cat_expr(&**base));\n+            Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n           }\n \n           ast::ExprIndex(ref base, ref idx) => {\n             match idx.node {\n                 ast::ExprRange(..) => {\n                     // Slicing syntax special case (KILLME).\n-                    self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                    Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                 }\n                 _ => {\n                     let method_call = ty::MethodCall::expr(expr.id());\n@@ -517,7 +509,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                                                 ret_ty), 1, true)\n                         }\n                         None => {\n-                            self.cat_index(expr, self.cat_expr(&**base))\n+                            self.cat_index(expr, try!(self.cat_expr(&**base)))\n                         }\n                     }\n                 }\n@@ -545,7 +537,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n           ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n           ast::ExprForLoop(..) => {\n-            self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+            Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n \n           ast::ExprIfLet(..) => {\n@@ -562,43 +554,43 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n                    def: def::Def)\n-                   -> cmt<'tcx> {\n+                   -> McResult<cmt<'tcx>> {\n         debug!(\"cat_def: id={} expr={} def={}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefFn(..) |\n           def::DefStaticMethod(..) | def::DefConst(..) => {\n-                self.cat_rvalue_node(id, span, expr_ty)\n+                Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n           def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n           def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n           def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) |\n           def::DefAssociatedTy(..) | def::DefAssociatedPath(..)=> {\n-              Rc::new(cmt_ {\n+              Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McImmutable,\n                   ty:expr_ty,\n                   note: NoteNone\n-              })\n+              }))\n           }\n \n           def::DefStatic(_, mutbl) => {\n-              Rc::new(cmt_ {\n+              Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: if mutbl { McDeclared } else { McImmutable},\n                   ty:expr_ty,\n                   note: NoteNone\n-              })\n+              }))\n           }\n \n           def::DefUpvar(var_id, fn_node_id, _) => {\n-              let ty = self.node_ty(fn_node_id);\n+              let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n                   ty::ty_closure(ref closure_ty) => {\n                       // Translate old closure type info into unboxed\n@@ -635,14 +627,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           def::DefLocal(vid) => {\n-            Rc::new(cmt_ {\n+            Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n                 mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n                 ty: expr_ty,\n                 note: NoteNone\n-            })\n+            }))\n           }\n         }\n     }\n@@ -657,7 +649,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  kind: ty::UnboxedClosureKind,\n                  mode: ast::CaptureClause,\n                  is_unboxed: bool)\n-                 -> cmt<'tcx> {\n+                 -> McResult<cmt<'tcx>> {\n         // An upvar can have up to 3 components.  The base is a\n         // `cat_upvar`.  Next, we add a deref through the implicit\n         // environment pointer with an anonymous free region 'env and\n@@ -679,7 +671,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // FnOnce         | copied               | upvar -> &'up bk\n         // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n         // old proc/once  | copied               | N/A\n-        let var_ty = self.node_ty(var_id);\n+        let var_ty = try!(self.node_ty(var_id));\n \n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n@@ -727,7 +719,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         });\n \n         // First, switch by capture mode\n-        match mode {\n+        Ok(match mode {\n             ast::CaptureByValue => {\n                 let mut base = cmt_ {\n                     id: id,\n@@ -809,7 +801,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteUpvarRef(upvar_id)\n                 })\n             }\n-        }\n+        })\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -882,7 +874,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                              base_cmt: cmt<'tcx>,\n                              deref_cnt: uint,\n                              implicit: bool)\n-                             -> cmt<'tcx> {\n+                             -> McResult<cmt<'tcx>> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => ty::AutoObject,\n             _ if deref_cnt != 0 => ty::AutoDeref(deref_cnt),\n@@ -896,7 +888,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let method_ty = self.typer.node_method_ty(method_call);\n \n         debug!(\"cat_deref: method_call={} method_ty={}\",\n-            method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n+               method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n \n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n@@ -905,13 +897,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n             None => base_cmt\n         };\n-        match ty::deref(base_cmt.ty, true) {\n+        let base_cmt_ty = base_cmt.ty;\n+        match ty::deref(base_cmt_ty, true) {\n             Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty, implicit),\n             None => {\n-                self.tcx().sess.span_bug(\n-                    node.span(),\n-                    format!(\"Explicit deref of non-derefable type: {}\",\n-                            base_cmt.ty.repr(self.tcx()))[]);\n+                debug!(\"Explicit deref of non-derefable type: {}\",\n+                       base_cmt_ty.repr(self.tcx()));\n+                return Err(());\n             }\n         }\n     }\n@@ -922,8 +914,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                     deref_cnt: uint,\n                                     deref_ty: Ty<'tcx>,\n                                     implicit: bool)\n-                                    -> cmt<'tcx> {\n-        let (m, cat) = match deref_kind(self.tcx(), base_cmt.ty) {\n+                                    -> McResult<cmt<'tcx>>\n+    {\n+        let (m, cat) = match try!(deref_kind(base_cmt.ty)) {\n             deref_ptr(ptr) => {\n                 let ptr = if implicit {\n                     match ptr {\n@@ -943,20 +936,20 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n             }\n         };\n-        Rc::new(cmt_ {\n+        Ok(Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             cat: cat,\n             mutbl: m,\n             ty: deref_ty,\n             note: NoteNone\n-        })\n+        }))\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n                                  mut base_cmt: cmt<'tcx>)\n-                                 -> cmt<'tcx> {\n+                                 -> McResult<cmt<'tcx>> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n@@ -987,17 +980,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n                     Some(ty) => ty,\n                     None => {\n-                        self.tcx().sess.span_bug(\n-                            elt.span(),\n-                            format!(\"Explicit index of non-index type `{}`\",\n-                                    base_cmt.ty.repr(self.tcx()))[]);\n+                        return Err(());\n                     }\n                 }\n             }\n         };\n \n         let m = base_cmt.mutbl.inherit();\n-        return interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty);\n+        return Ok(interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty));\n \n         fn interior<'tcx, N: ast_node>(elt: &N,\n                                        of_cmt: cmt<'tcx>,\n@@ -1021,15 +1011,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn deref_vec<N:ast_node>(&self,\n                              elt: &N,\n                              base_cmt: cmt<'tcx>)\n-                             -> cmt<'tcx> {\n-        match deref_kind(self.tcx(), base_cmt.ty) {\n+                             -> McResult<cmt<'tcx>>\n+    {\n+        match try!(deref_kind(base_cmt.ty)) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n \n                 // the deref is explicit in the resulting cmt\n-                Rc::new(cmt_ {\n+                Ok(Rc::new(cmt_ {\n                     id:elt.id(),\n                     span:elt.span(),\n                     cat:cat_deref(base_cmt.clone(), 0, ptr),\n@@ -1039,11 +1030,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         None => self.tcx().sess.bug(\"Found non-derefable type\")\n                     },\n                     note: NoteNone\n-                })\n+                }))\n             }\n \n             deref_interior(_) => {\n-                base_cmt\n+                Ok(base_cmt)\n             }\n         }\n     }\n@@ -1058,13 +1049,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt<'tcx>,\n                              slice_pat: &ast::Pat)\n-                             -> (cmt<'tcx>, ast::Mutability, ty::Region) {\n-        let slice_ty = self.node_ty(slice_pat.id);\n+                             -> McResult<(cmt<'tcx>, ast::Mutability, ty::Region)> {\n+        let slice_ty = try!(self.node_ty(slice_pat.id));\n         let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n                                                     slice_pat,\n                                                     slice_ty);\n-        let cmt_slice = self.cat_index(slice_pat, self.deref_vec(slice_pat, vec_cmt));\n-        return (cmt_slice, slice_mutbl, slice_r);\n+        let cmt_slice = try!(self.cat_index(slice_pat, try!(self.deref_vec(slice_pat, vec_cmt))));\n+        return Ok((cmt_slice, slice_mutbl, slice_r));\n \n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n         /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n@@ -1119,15 +1110,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         })\n     }\n \n-    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) where\n-        F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) -> McResult<()>\n+        where F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, op: &mut F) where\n-        F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, op: &mut F)\n+                       -> McResult<()>\n+        where F : FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1208,29 +1200,29 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 Some(&def::DefVariant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n+                        let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        self.cat_pattern_(subcmt, &**subpat, op);\n+                        try!(self.cat_pattern_(subcmt, &**subpat, op));\n                     }\n                 }\n                 Some(&def::DefStruct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n+                        let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        self.cat_pattern_(cmt_field, &**subpat, op);\n+                        try!(self.cat_pattern_(cmt_field, &**subpat, op));\n                     }\n                 }\n                 Some(&def::DefConst(..)) => {\n                     for subpat in subpats.iter() {\n-                        self.cat_pattern_(cmt.clone(), &**subpat, op);\n+                        try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }\n                 }\n                 _ => {\n@@ -1242,7 +1234,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::PatIdent(_, _, Some(ref subpat)) => {\n-              self.cat_pattern_(cmt, &**subpat, op);\n+              try!(self.cat_pattern_(cmt, &**subpat, op));\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -1252,42 +1244,42 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n-                let field_ty = self.pat_ty(&*fp.node.pat); // see (*2)\n+                let field_ty = try!(self.pat_ty(&*fp.node.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.ident.name, field_ty);\n-                self.cat_pattern_(cmt_field, &*fp.node.pat, op);\n+                try!(self.cat_pattern_(cmt_field, &*fp.node.pat, op));\n             }\n           }\n \n           ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n+                let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                self.cat_pattern_(subcmt, &**subpat, op);\n+                try!(self.cat_pattern_(subcmt, &**subpat, op));\n             }\n           }\n \n           ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n             // @p1, ~p1, ref p1\n-            let subcmt = self.cat_deref(pat, cmt, 0, false);\n-            self.cat_pattern_(subcmt, &**subpat, op);\n+            let subcmt = try!(self.cat_deref(pat, cmt, 0, false));\n+              try!(self.cat_pattern_(subcmt, &**subpat, op));\n           }\n \n           ast::PatVec(ref before, ref slice, ref after) => {\n-              let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n+              let elt_cmt = try!(self.cat_index(pat, try!(self.deref_vec(pat, cmt))));\n               for before_pat in before.iter() {\n-                  self.cat_pattern_(elt_cmt.clone(), &**before_pat, op);\n+                  try!(self.cat_pattern_(elt_cmt.clone(), &**before_pat, op));\n               }\n               for slice_pat in slice.iter() {\n-                  let slice_ty = self.pat_ty(&**slice_pat);\n+                  let slice_ty = try!(self.pat_ty(&**slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  self.cat_pattern_(slice_cmt, &**slice_pat, op);\n+                  try!(self.cat_pattern_(slice_cmt, &**slice_pat, op));\n               }\n               for after_pat in after.iter() {\n-                  self.cat_pattern_(elt_cmt.clone(), &**after_pat, op);\n+                  try!(self.cat_pattern_(elt_cmt.clone(), &**after_pat, op));\n               }\n           }\n \n@@ -1299,77 +1291,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               self.tcx().sess.span_bug(pat.span, \"unexpanded macro\");\n           }\n         }\n-    }\n \n-    pub fn cmt_to_string(&self, cmt: &cmt_<'tcx>) -> String {\n-        fn upvar_to_string(upvar: &Upvar, is_copy: bool) -> String {\n-            if upvar.is_unboxed {\n-                let kind = match upvar.kind {\n-                    ty::FnUnboxedClosureKind => \"Fn\",\n-                    ty::FnMutUnboxedClosureKind => \"FnMut\",\n-                    ty::FnOnceUnboxedClosureKind => \"FnOnce\"\n-                };\n-                format!(\"captured outer variable in an `{}` closure\", kind)\n-            } else {\n-                (match (upvar.kind, is_copy) {\n-                    (ty::FnOnceUnboxedClosureKind, true) => \"captured outer variable in a proc\",\n-                    _ => \"captured outer variable\"\n-                }).to_string()\n-            }\n-        }\n-\n-        match cmt.cat {\n-          cat_static_item => {\n-              \"static item\".to_string()\n-          }\n-          cat_rvalue(..) => {\n-              \"non-lvalue\".to_string()\n-          }\n-          cat_local(vid) => {\n-              match self.tcx().map.find(vid) {\n-                  Some(ast_map::NodeArg(_)) => {\n-                      \"argument\".to_string()\n-                  }\n-                  _ => \"local variable\".to_string()\n-              }\n-          }\n-          cat_deref(_, _, pk) => {\n-              let upvar = cmt.upvar();\n-              match upvar.as_ref().map(|i| &i.cat) {\n-                  Some(&cat_upvar(ref var)) => {\n-                      upvar_to_string(var, false)\n-                  }\n-                  Some(_) => unreachable!(),\n-                  None => {\n-                      match pk {\n-                          Implicit(..) => {\n-                            \"dereference (dereference is implicit, due to indexing)\".to_string()\n-                          }\n-                          Unique => format!(\"dereference of `{}`\", ptr_sigil(pk)),\n-                          _ => format!(\"dereference of `{}`-pointer\", ptr_sigil(pk))\n-                      }\n-                  }\n-              }\n-          }\n-          cat_interior(_, InteriorField(NamedField(_))) => {\n-              \"field\".to_string()\n-          }\n-          cat_interior(_, InteriorField(PositionalField(_))) => {\n-              \"anonymous field\".to_string()\n-          }\n-          cat_interior(_, InteriorElement(VecElement)) => {\n-              \"vec content\".to_string()\n-          }\n-          cat_interior(_, InteriorElement(OtherElement)) => {\n-              \"indexed content\".to_string()\n-          }\n-          cat_upvar(ref var) => {\n-              upvar_to_string(var, true)\n-          }\n-          cat_downcast(ref cmt, _) => {\n-            self.cmt_to_string(&**cmt)\n-          }\n-        }\n+        Ok(())\n     }\n }\n \n@@ -1481,6 +1404,78 @@ impl<'tcx> cmt_<'tcx> {\n             NoteNone => None\n         }\n     }\n+\n+\n+    pub fn descriptive_string(&self, tcx: &ty::ctxt) -> String {\n+        fn upvar_to_string(upvar: &Upvar, is_copy: bool) -> String {\n+            if upvar.is_unboxed {\n+                let kind = match upvar.kind {\n+                    ty::FnUnboxedClosureKind => \"Fn\",\n+                    ty::FnMutUnboxedClosureKind => \"FnMut\",\n+                    ty::FnOnceUnboxedClosureKind => \"FnOnce\"\n+                };\n+                format!(\"captured outer variable in an `{}` closure\", kind)\n+            } else {\n+                (match (upvar.kind, is_copy) {\n+                    (ty::FnOnceUnboxedClosureKind, true) => \"captured outer variable in a proc\",\n+                    _ => \"captured outer variable\"\n+                }).to_string()\n+            }\n+        }\n+\n+        match self.cat {\n+            cat_static_item => {\n+                \"static item\".to_string()\n+            }\n+            cat_rvalue(..) => {\n+                \"non-lvalue\".to_string()\n+            }\n+            cat_local(vid) => {\n+                match tcx.map.find(vid) {\n+                    Some(ast_map::NodeArg(_)) => {\n+                        \"argument\".to_string()\n+                    }\n+                    _ => \"local variable\".to_string()\n+                }\n+            }\n+            cat_deref(_, _, pk) => {\n+                let upvar = self.upvar();\n+                match upvar.as_ref().map(|i| &i.cat) {\n+                    Some(&cat_upvar(ref var)) => {\n+                        upvar_to_string(var, false)\n+                    }\n+                    Some(_) => unreachable!(),\n+                    None => {\n+                        match pk {\n+                            Implicit(..) => {\n+                                \"dereference (dereference is implicit, due to indexing)\".to_string()\n+                            }\n+                            Unique => format!(\"dereference of `{}`\", ptr_sigil(pk)),\n+                            _ => format!(\"dereference of `{}`-pointer\", ptr_sigil(pk))\n+                        }\n+                    }\n+                }\n+            }\n+            cat_interior(_, InteriorField(NamedField(_))) => {\n+                \"field\".to_string()\n+            }\n+            cat_interior(_, InteriorField(PositionalField(_))) => {\n+                \"anonymous field\".to_string()\n+            }\n+            cat_interior(_, InteriorElement(VecElement)) => {\n+                \"vec content\".to_string()\n+            }\n+            cat_interior(_, InteriorElement(OtherElement)) => {\n+                \"indexed content\".to_string()\n+            }\n+            cat_upvar(ref var) => {\n+                upvar_to_string(var, true)\n+            }\n+            cat_downcast(ref cmt, _) => {\n+                cmt.descriptive_string(tcx)\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> Repr<'tcx> for cmt_<'tcx> {"}, {"sha": "6a8b6d49cc0c562640ff8562bd71c5add05f7909", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -42,8 +42,8 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n \n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n-    let param_env = ty::empty_parameter_environment();\n-    let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n+    let param_env = ty::empty_parameter_environment(infcx.tcx);\n+    let mut selcx = SelectionContext::intercrate(infcx, &param_env);\n     let obligation = Obligation::new(ObligationCause::dummy(),\n                                      ty::Binder(ty::TraitPredicate {\n                                          trait_ref: Rc::new(impl1_trait_ref),"}, {"sha": "05ea2f9a7d2580c0292e6d24834dc89f05cb8210", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -77,7 +77,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     \"overflow evaluating the requirement `{}`\",\n                     predicate.user_string(infcx.tcx)).as_slice());\n \n-            suggest_new_overflow_limit(infcx, obligation.cause.span);\n+            suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n \n             note_obligation_cause(infcx, obligation);\n         }\n@@ -332,10 +332,10 @@ fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn suggest_new_overflow_limit(infcx: &InferCtxt, span: Span) {\n-    let current_limit = infcx.tcx.sess.recursion_limit.get();\n+pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n+    let current_limit = tcx.sess.recursion_limit.get();\n     let suggested_limit = current_limit * 2;\n-    infcx.tcx.sess.span_note(\n+    tcx.sess.span_note(\n         span,\n         format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\","}, {"sha": "e8a22e3d1d8f8963eddc57541c8dedd7308e2438", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -109,7 +109,6 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// `projection_ty` again.\n     pub fn normalize_projection_type<'a>(&mut self,\n                                          infcx: &InferCtxt<'a,'tcx>,\n-                                         param_env: &ty::ParameterEnvironment<'tcx>,\n                                          typer: &ty::UnboxedClosureTyper<'tcx>,\n                                          projection_ty: ty::ProjectionTy<'tcx>,\n                                          cause: ObligationCause<'tcx>)\n@@ -122,7 +121,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         // FIXME(#20304) -- cache\n \n-        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+        let mut selcx = SelectionContext::new(infcx, typer);\n         let normalized = project::normalize_projection_type(&mut selcx, projection_ty, cause, 0);\n \n         for obligation in normalized.obligations.into_iter() {\n@@ -186,11 +185,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     pub fn select_all_or_error<'a>(&mut self,\n                                    infcx: &InferCtxt<'a,'tcx>,\n-                                   param_env: &ty::ParameterEnvironment<'tcx>,\n                                    typer: &ty::UnboxedClosureTyper<'tcx>)\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        try!(self.select_where_possible(infcx, param_env, typer));\n+        try!(self.select_where_possible(infcx, typer));\n \n         // Anything left is ambiguous.\n         let errors: Vec<FulfillmentError> =\n@@ -212,21 +210,19 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// results in `O(n^2)` performance (#18208).\n     pub fn select_new_obligations<'a>(&mut self,\n                                       infcx: &InferCtxt<'a,'tcx>,\n-                                      param_env: &ty::ParameterEnvironment<'tcx>,\n                                       typer: &ty::UnboxedClosureTyper<'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+        let mut selcx = SelectionContext::new(infcx, typer);\n         self.select(&mut selcx, true)\n     }\n \n     pub fn select_where_possible<'a>(&mut self,\n                                      infcx: &InferCtxt<'a,'tcx>,\n-                                     param_env: &ty::ParameterEnvironment<'tcx>,\n                                      typer: &ty::UnboxedClosureTyper<'tcx>)\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+        let mut selcx = SelectionContext::new(infcx, typer);\n         self.select(&mut selcx, false)\n     }\n "}, {"sha": "1a1d52a047c84ac696840ca71a0fabc85c286134", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 80, "deletions": 11, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -15,16 +15,18 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n+use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n use std::slice::Iter;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n pub use self::error_reporting::report_fulfillment_errors;\n+pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n@@ -288,29 +290,62 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                                 param_env: &ty::ParameterEnvironment<'tcx>,\n-                                                 ty: Ty<'tcx>,\n-                                                 bound: ty::BuiltinBound)\n-                                                 -> bool\n+pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                       typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                       ty: Ty<'tcx>,\n+                                       bound: ty::BuiltinBound,\n+                                       span: Span)\n+                                       -> SelectionResult<'tcx, ()>\n {\n     debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={})\",\n            ty.repr(infcx.tcx),\n            bound);\n \n     let mut fulfill_cx = FulfillmentContext::new();\n \n-    // We can use dummy values here because we won't report any errors\n-    // that result nor will we pay any mind to region obligations that arise\n-    // (there shouldn't really be any anyhow).\n-    let cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+    // We can use a dummy node-id here because we won't pay any mind\n+    // to region obligations that arise (there shouldn't really be any\n+    // anyhow).\n+    let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n \n     fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n \n     // Note: we only assume something is `Copy` if we can\n     // *definitively* show that it implements `Copy`. Otherwise,\n     // assume it is move; linear is always ok.\n-    let result = fulfill_cx.select_all_or_error(infcx, param_env, infcx.tcx).is_ok();\n+    let result = match fulfill_cx.select_all_or_error(infcx, typer) {\n+        Ok(()) => Ok(Some(())), // Success, we know it implements Copy.\n+        Err(errors) => {\n+            // Check if overflow occurred anywhere and propagate that.\n+            if errors.iter().any(\n+                |err| match err.code { CodeSelectionError(Overflow) => true, _ => false })\n+            {\n+                return Err(Overflow);\n+            }\n+\n+            // Otherwise, if there were any hard errors, propagate an\n+            // arbitrary one of those. If no hard errors at all,\n+            // report ambiguity.\n+            let sel_error =\n+                errors.iter()\n+                      .filter_map(|err| {\n+                          match err.code {\n+                              CodeAmbiguity => None,\n+                              CodeSelectionError(ref e) => Some(e.clone()),\n+                              CodeProjectionError(_) => {\n+                                  infcx.tcx.sess.span_bug(\n+                                      span,\n+                                      \"projection error while selecting?\")\n+                              }\n+                          }\n+                      })\n+                      .next();\n+            match sel_error {\n+                None => { Ok(None) }\n+                Some(e) => { Err(e) }\n+            }\n+        }\n+    };\n \n     debug!(\"type_known_to_meet_builtin_bound: ty={} bound={} result={}\",\n            ty.repr(infcx.tcx),\n@@ -320,6 +355,40 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     result\n }\n \n+pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                                 typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                                 ty: Ty<'tcx>,\n+                                                 bound: ty::BuiltinBound,\n+                                                 span: Span)\n+                                                 -> bool\n+{\n+    match evaluate_builtin_bound(infcx, typer, ty, bound, span) {\n+        Ok(Some(())) => {\n+            // definitely impl'd\n+            true\n+        }\n+        Ok(None) => {\n+            // ambiguous: if coherence check was successful, shouldn't\n+            // happen, but we might have reported an error and been\n+            // soldering on, so just treat this like not implemented\n+            false\n+        }\n+        Err(Overflow) => {\n+            infcx.tcx.sess.span_err(\n+                span,\n+                format!(\"overflow evaluating whether `{}` is `{}`\",\n+                        ty.user_string(infcx.tcx),\n+                        bound.user_string(infcx.tcx))[]);\n+            suggest_new_overflow_limit(infcx.tcx, span);\n+            false\n+        }\n+        Err(_) => {\n+            // other errors: not implemented.\n+            false\n+        }\n+    }\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)"}, {"sha": "7da33babaeb6078f9597041f5ad4579694c636ee", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -46,7 +46,6 @@ use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    param_env: &'cx ty::ParameterEnvironment<'tcx>,\n     closure_typer: &'cx (ty::UnboxedClosureTyper<'tcx>+'cx),\n \n     /// Freshener used specifically for skolemizing entries on the\n@@ -181,25 +180,21 @@ enum EvaluationResult<'tcx> {\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-               param_env: &'cx ty::ParameterEnvironment<'tcx>,\n                closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n-            param_env: param_env,\n             closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n \n     pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-                      param_env: &'cx ty::ParameterEnvironment<'tcx>,\n                       closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n                       -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n-            param_env: param_env,\n             closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: true,\n@@ -210,14 +205,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'tcx> {\n-        self.param_env\n-    }\n-\n     pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n+    pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'cx, 'tcx> {\n+        self.closure_typer.param_env()\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -650,7 +645,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // it's not worth going to more trouble to increase the\n         // hit-rate I don't think.\n         if self.intercrate {\n-            return &self.param_env.selection_cache;\n+            return &self.param_env().selection_cache;\n         }\n \n         // If the trait refers to any parameters in scope, then use\n@@ -659,7 +654,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             cache_fresh_trait_pred.0.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n-            return &self.param_env.selection_cache;\n+            return &self.param_env().selection_cache;\n         }\n \n         // If the trait refers to unbound type variables, and there\n@@ -668,11 +663,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // common case, then we can use the global environment.\n         // See the discussion in doc.rs for more details.\n         if\n-            !self.param_env.caller_bounds.is_empty() &&\n+            !self.param_env().caller_bounds.is_empty() &&\n             cache_fresh_trait_pred.0.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n-            return &self.param_env.selection_cache;\n+            return &self.param_env().selection_cache;\n         }\n \n         // Otherwise, we can use the global cache.\n@@ -902,7 +897,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()));\n \n         let caller_trait_refs: Vec<_> =\n-            self.param_env.caller_bounds.predicates.iter()\n+            self.param_env().caller_bounds.predicates.iter()\n             .filter_map(|o| o.to_opt_poly_trait_ref())\n             .collect();\n "}, {"sha": "c720032bef264956c579f1d08f975759cc2464ce", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 114, "deletions": 64, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -2058,7 +2058,9 @@ impl<'tcx> TraitRef<'tcx> {\n /// future I hope to refine the representation of types so as to make\n /// more distinctions clearer.\n #[deriving(Clone)]\n-pub struct ParameterEnvironment<'tcx> {\n+pub struct ParameterEnvironment<'a, 'tcx:'a> {\n+    pub tcx: &'a ctxt<'tcx>,\n+\n     /// A substitution that can be applied to move from\n     /// the \"outer\" view of a type or method to the \"inner\" view.\n     /// In general, this means converting from bound parameters to\n@@ -2082,8 +2084,8 @@ pub struct ParameterEnvironment<'tcx> {\n     pub selection_cache: traits::SelectionCache<'tcx>,\n }\n \n-impl<'tcx> ParameterEnvironment<'tcx> {\n-    pub fn for_item(cx: &ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'tcx> {\n+impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n+    pub fn for_item(cx: &'a ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match **impl_item {\n@@ -2272,6 +2274,8 @@ impl UnboxedClosureKind {\n }\n \n pub trait UnboxedClosureTyper<'tcx> {\n+    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx>;\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind;\n@@ -2424,6 +2428,21 @@ impl<'tcx> ctxt<'tcx> {\n         self.region_interner.borrow_mut().insert(region, region);\n         region\n     }\n+\n+    pub fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.unboxed_closures.borrow()[def_id].kind\n+    }\n+\n+    pub fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        self.unboxed_closures.borrow()[def_id].closure_type.subst(self, substs)\n+    }\n }\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n@@ -3377,7 +3396,8 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_unboxed_closure(did, r, substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n-                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n+                let param_env = ty::empty_parameter_environment(cx);\n+                let upvars = unboxed_closure_upvars(&param_env, did, substs).unwrap();\n                 TypeContents::union(upvars.as_slice(),\n                                     |f| tc_ty(cx, f.ty, cache))\n                     | borrowed_contents(*r, MutMutable)\n@@ -3526,12 +3546,12 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n     }\n }\n \n-fn type_impls_bound<'tcx>(cx: &ctxt<'tcx>,\n-                          cache: &RefCell<HashMap<Ty<'tcx>,bool>>,\n-                          param_env: &ParameterEnvironment<'tcx>,\n-                          ty: Ty<'tcx>,\n-                          bound: ty::BuiltinBound)\n-                          -> bool\n+fn type_impls_bound<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n+                             cache: &RefCell<HashMap<Ty<'tcx>,bool>>,\n+                             ty: Ty<'tcx>,\n+                             bound: ty::BuiltinBound,\n+                             span: Span)\n+                             -> bool\n {\n     assert!(!ty::type_needs_infer(ty));\n \n@@ -3540,19 +3560,20 @@ fn type_impls_bound<'tcx>(cx: &ctxt<'tcx>,\n             None => {}\n             Some(&result) => {\n                 debug!(\"type_impls_bound({}, {}) = {} (cached)\",\n-                       ty_to_string(cx, ty),\n+                       ty.repr(param_env.tcx),\n                        bound,\n                        result);\n                 return result\n             }\n         }\n     }\n \n-    let infcx = infer::new_infer_ctxt(cx);\n-    let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound);\n+    let infcx = infer::new_infer_ctxt(param_env.tcx);\n+\n+    let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound, span);\n \n     debug!(\"type_impls_bound({}, {}) = {}\",\n-           ty_to_string(cx, ty),\n+           ty.repr(param_env.tcx),\n            bound,\n            is_impld);\n \n@@ -3564,20 +3585,22 @@ fn type_impls_bound<'tcx>(cx: &ctxt<'tcx>,\n     is_impld\n }\n \n-pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n-                                   ty: Ty<'tcx>,\n-                                   param_env: &ParameterEnvironment<'tcx>)\n-                                   -> bool\n+pub fn type_moves_by_default<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n+                                      span: Span,\n+                                      ty: Ty<'tcx>)\n+                                      -> bool\n {\n-    !type_impls_bound(cx, &cx.type_impls_copy_cache, param_env, ty, ty::BoundCopy)\n+    let tcx = param_env.tcx;\n+    !type_impls_bound(param_env, &tcx.type_impls_copy_cache, ty, ty::BoundCopy, span)\n }\n \n-pub fn type_is_sized<'tcx>(cx: &ctxt<'tcx>,\n-                           ty: Ty<'tcx>,\n-                           param_env: &ParameterEnvironment<'tcx>)\n-                           -> bool\n+pub fn type_is_sized<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n+                              span: Span,\n+                              ty: Ty<'tcx>)\n+                              -> bool\n {\n-    type_impls_bound(cx, &cx.type_impls_sized_cache, param_env, ty, ty::BoundSized)\n+    let tcx = param_env.tcx;\n+    type_impls_bound(param_env, &tcx.type_impls_sized_cache, ty, ty::BoundSized, span)\n }\n \n pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -3622,8 +3645,6 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_str |\n             ty_bare_fn(..) |\n             ty_closure(_) |\n-            ty_infer(_) |\n-            ty_err |\n             ty_param(_) |\n             ty_projection(_) |\n             ty_vec(_, None) => {\n@@ -3656,9 +3677,12 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n                 r\n             }\n \n-            ty_unboxed_closure(did, _, substs) => {\n-                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n-                upvars.iter().any(|f| type_requires(cx, seen, r_ty, f.ty))\n+            ty_err |\n+            ty_infer(_) |\n+            ty_unboxed_closure(..) => {\n+                // this check is run on type definitions, so we don't expect to see\n+                // inference by-products or unboxed closure types\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\", ty)[])\n             }\n \n             ty_tup(ref ts) => {\n@@ -3748,9 +3772,10 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n                 find_nonrepresentable(cx, sp, seen, iter)\n             }\n-            ty_unboxed_closure(did, _, substs) => {\n-                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n-                find_nonrepresentable(cx, sp, seen, upvars.iter().map(|f| f.ty))\n+            ty_unboxed_closure(..) => {\n+                // this check is run on type definitions, so we don't expect to see\n+                // unboxed closure types\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\", ty)[])\n             }\n             _ => Representable,\n         }\n@@ -5708,7 +5733,10 @@ pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n             freevars.iter()\n                     .map(|freevar| {\n                         let freevar_def_id = freevar.def.def_id();\n-                        let freevar_ty = typer.node_ty(freevar_def_id.node);\n+                        let freevar_ty = match typer.node_ty(freevar_def_id.node) {\n+                            Ok(t) => { t }\n+                            Err(()) => { return None; }\n+                        };\n                         let freevar_ty = freevar_ty.subst(tcx, substs);\n \n                         match capture_mode {\n@@ -6371,19 +6399,20 @@ impl Variance {\n \n /// Construct a parameter environment suitable for static contexts or other contexts where there\n /// are no free type/lifetime parameters in scope.\n-pub fn empty_parameter_environment<'tcx>() -> ParameterEnvironment<'tcx> {\n-    ty::ParameterEnvironment { free_substs: Substs::empty(),\n+pub fn empty_parameter_environment<'a,'tcx>(cx: &'a ctxt<'tcx>) -> ParameterEnvironment<'a,'tcx> {\n+    ty::ParameterEnvironment { tcx: cx,\n+                               free_substs: Substs::empty(),\n                                caller_bounds: GenericBounds::empty(),\n                                implicit_region_bound: ty::ReEmpty,\n                                selection_cache: traits::SelectionCache::new(), }\n }\n \n /// See `ParameterEnvironment` struct def'n for details\n-pub fn construct_parameter_environment<'tcx>(\n-    tcx: &ctxt<'tcx>,\n+pub fn construct_parameter_environment<'a,'tcx>(\n+    tcx: &'a ctxt<'tcx>,\n     generics: &ty::Generics<'tcx>,\n     free_id: ast::NodeId)\n-    -> ParameterEnvironment<'tcx>\n+    -> ParameterEnvironment<'a, 'tcx>\n {\n \n     //\n@@ -6426,6 +6455,7 @@ pub fn construct_parameter_environment<'tcx>(\n            bounds.repr(tcx));\n \n     return ty::ParameterEnvironment {\n+        tcx: tcx,\n         free_substs: free_substs,\n         implicit_region_bound: ty::ReScope(free_id_scope),\n         caller_bounds: bounds,\n@@ -6516,65 +6546,84 @@ impl BorrowKind {\n     }\n }\n \n-impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        self\n+impl<'tcx> ctxt<'tcx> {\n+    pub fn capture_mode(&self, closure_expr_id: ast::NodeId)\n+                    -> ast::CaptureClause {\n+        self.capture_modes.borrow()[closure_expr_id].clone()\n+    }\n+\n+    pub fn is_method_call(&self, expr_id: ast::NodeId) -> bool {\n+        self.method_map.borrow().contains_key(&MethodCall::expr(expr_id))\n+    }\n+}\n+\n+impl<'a,'tcx> mc::Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.tcx\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        ty::node_id_to_type(self, id)\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n+        Ok(ty::node_id_to_type(self.tcx, id))\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n-        ty::expr_ty_adjusted(self, expr)\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n+        Ok(ty::expr_ty_adjusted(self.tcx, expr))\n     }\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n-        self.method_map.borrow().get(&method_call).map(|method| method.ty)\n+        self.tcx.method_map.borrow().get(&method_call).map(|method| method.ty)\n     }\n \n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>\n     {\n-        self.method_map.borrow().get(&method_call).map(|method| method.origin.clone())\n+        self.tcx.method_map.borrow().get(&method_call).map(|method| method.origin.clone())\n     }\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.adjustments\n+    fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        &self.tcx.adjustments\n     }\n \n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.method_map.borrow().contains_key(&MethodCall::expr(id))\n+        self.tcx.is_method_call(id)\n     }\n \n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n-        self.region_maps.temporary_scope(rvalue_id)\n+        self.tcx.region_maps.temporary_scope(rvalue_id)\n     }\n \n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-        Some(self.upvar_borrow_map.borrow()[upvar_id].clone())\n+        Some(self.tcx.upvar_borrow_map.borrow()[upvar_id].clone())\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n-        self.capture_modes.borrow()[closure_expr_id].clone()\n+        self.tcx.capture_mode(closure_expr_id)\n+    }\n+\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+        type_moves_by_default(self, span, ty)\n     }\n }\n \n-impl<'tcx> UnboxedClosureTyper<'tcx> for ty::ctxt<'tcx> {\n+impl<'a,'tcx> UnboxedClosureTyper<'tcx> for ty::ParameterEnvironment<'a,'tcx> {\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        self\n+    }\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind\n     {\n-        self.unboxed_closures.borrow()[def_id].kind\n+        self.tcx.unboxed_closure_kind(def_id)\n     }\n \n     fn unboxed_closure_type(&self,\n                             def_id: ast::DefId,\n                             substs: &subst::Substs<'tcx>)\n                             -> ty::ClosureTy<'tcx>\n     {\n-        self.unboxed_closures.borrow()[def_id].closure_type.subst(self, substs)\n+        self.tcx.unboxed_closure_type(def_id, substs)\n     }\n \n     fn unboxed_closure_upvars(&self,\n@@ -6941,15 +6990,18 @@ pub enum CopyImplementationError {\n     TypeIsStructural,\n }\n \n-pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n-                                     self_type: Ty<'tcx>,\n-                                     param_env: &ParameterEnvironment<'tcx>)\n-                                     -> Result<(),CopyImplementationError> {\n+pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tcx>,\n+                                        span: Span,\n+                                        self_type: Ty<'tcx>)\n+                                        -> Result<(),CopyImplementationError>\n+{\n+    let tcx = param_env.tcx;\n+\n     match self_type.sty {\n         ty::ty_struct(struct_did, substs) => {\n             let fields = ty::struct_fields(tcx, struct_did, substs);\n             for field in fields.iter() {\n-                if type_moves_by_default(tcx, field.mt.ty, param_env) {\n+                if type_moves_by_default(param_env, span, field.mt.ty) {\n                     return Err(FieldDoesNotImplementCopy(field.name))\n                 }\n             }\n@@ -6960,9 +7012,7 @@ pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n                 for variant_arg_type in variant.args.iter() {\n                     let substd_arg_type =\n                         variant_arg_type.subst(tcx, substs);\n-                    if type_moves_by_default(tcx,\n-                                             substd_arg_type,\n-                                             param_env) {\n+                    if type_moves_by_default(param_env, span, substd_arg_type) {\n                         return Err(VariantDoesNotImplementCopy(variant.name))\n                     }\n                 }"}, {"sha": "17a3f4a88e5c080801f7ee23def2f2d4186eb5c3", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -87,7 +87,7 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n     move_data: move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n-    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n@@ -208,9 +208,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     {\n-        let mut euv = euv::ExprUseVisitor::new(&mut clcx,\n-                                               bccx.tcx,\n-                                               &param_env);\n+        let mut euv = euv::ExprUseVisitor::new(&mut clcx, &param_env);\n         euv.walk_fn(decl, body);\n     }\n }"}, {"sha": "1e9e5b22aa0ed85ac85865537b16111e6c49946a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -51,9 +51,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n \n     {\n-        let mut euv = euv::ExprUseVisitor::new(&mut glcx,\n-                                               bccx.tcx,\n-                                               &param_env);\n+        let mut euv = euv::ExprUseVisitor::new(&mut glcx, &param_env);\n         euv.walk_fn(decl, body);\n     }\n \n@@ -485,13 +483,15 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n /// This visitor walks static initializer's expressions and makes\n /// sure the loans being taken are sound.\n struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let ast::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let base_cmt = self.bccx.cat_expr(&**base);\n+            let param_env = ty::empty_parameter_environment(self.bccx.tcx);\n+            let mc = mc::MemCategorizationContext::new(&param_env);\n+            let base_cmt = mc.cat_expr(&**base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n             // Check that we don't allow borrows of unsafe static items.\n             if check_aliasability(self.bccx, ex.span, euv::AddrOf,"}, {"sha": "d81974d1ae038441ef8191004d0de33f4876d97d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -511,28 +511,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n-    pub fn mc(&self) -> mc::MemCategorizationContext<'a, ty::ctxt<'tcx>> {\n-        mc::MemCategorizationContext::new(self.tcx)\n-    }\n-\n-    pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt<'tcx> {\n-        self.mc().cat_expr(expr)\n-    }\n-\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n             self.bckerr_to_string(&err)[]);\n         self.note_and_explain_bckerr(err);\n     }\n \n-    pub fn report_use_of_moved_value(&self,\n-                                     use_span: Span,\n-                                     use_kind: MovedValueUseKind,\n-                                     lp: &LoanPath<'tcx>,\n-                                     the_move: &move_data::Move,\n-                                     moved_lp: &LoanPath<'tcx>,\n-                                     param_env: &ty::ParameterEnvironment<'tcx>) {\n+    pub fn report_use_of_moved_value<'b>(&self,\n+                                         use_span: Span,\n+                                         use_kind: MovedValueUseKind,\n+                                         lp: &LoanPath<'tcx>,\n+                                         the_move: &move_data::Move,\n+                                         moved_lp: &LoanPath<'tcx>,\n+                                         param_env: &ty::ParameterEnvironment<'b,'tcx>) {\n         let verb = match use_kind {\n             MovedInUse => \"use\",\n             MovedInCapture => \"capture\",\n@@ -608,8 +600,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                   r)[])\n                     }\n                 };\n-                let (suggestion, _) = move_suggestion(self.tcx, param_env, expr_ty,\n-                        (\"moved by default\", \"\"));\n+                let (suggestion, _) =\n+                    move_suggestion(param_env, expr_span, expr_ty, (\"moved by default\", \"\"));\n                 self.tcx.sess.span_note(\n                     expr_span,\n                     format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n@@ -646,11 +638,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                   r)[])\n                     }\n                 };\n-                let (suggestion, help) = move_suggestion(self.tcx,\n-                                                         param_env,\n-                                                         expr_ty,\n-                        (\"moved by default\", \"make a copy and \\\n-                         capture that instead to override\"));\n+                let (suggestion, help) =\n+                    move_suggestion(param_env,\n+                                    expr_span,\n+                                    expr_ty,\n+                                    (\"moved by default\",\n+                                     \"make a copy and capture that instead to override\"));\n                 self.tcx.sess.span_note(\n                     expr_span,\n                     format!(\"`{}` moved into closure environment here{} because it \\\n@@ -663,22 +656,27 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn move_suggestion<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 param_env: &ty::ParameterEnvironment<'tcx>,\n-                                 ty: Ty<'tcx>,\n-                                 default_msgs: (&'static str, &'static str))\n-                                 -> (&'static str, &'static str) {\n+        fn move_suggestion<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n+                                    span: Span,\n+                                    ty: Ty<'tcx>,\n+                                    default_msgs: (&'static str, &'static str))\n+                                    -> (&'static str, &'static str) {\n             match ty.sty {\n                 ty::ty_closure(box ty::ClosureTy {\n-                        store: ty::RegionTraitStore(..),\n-                        ..\n-                    }) =>\n+                    store: ty::RegionTraitStore(..),\n+                    ..\n+                }) => {\n                     (\"a non-copyable stack closure\",\n-                     \"capture it in a new closure, e.g. `|x| f(x)`, to override\"),\n-                _ if ty::type_moves_by_default(tcx, ty, param_env) =>\n-                    (\"non-copyable\",\n-                     \"perhaps you meant to use `clone()`?\"),\n-                _ => default_msgs,\n+                     \"capture it in a new closure, e.g. `|x| f(x)`, to override\")\n+                }\n+                _ => {\n+                    if ty::type_moves_by_default(param_env, span, ty) {\n+                        (\"non-copyable\",\n+                         \"perhaps you meant to use `clone()`?\")\n+                    } else {\n+                        default_msgs\n+                    }\n+                }\n             }\n         }\n     }\n@@ -991,7 +989,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn cmt_to_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n-        self.mc().cmt_to_string(cmt)\n+        cmt.descriptive_string(self.tcx)\n     }\n }\n "}, {"sha": "19781a51d578b759353ad522c84ad9b469eb5768", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -542,7 +542,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n             check_match::Constructor::Variant(def_id)\n     };\n \n-    let param_env = ty::empty_parameter_environment();\n+    let param_env = ty::empty_parameter_environment(bcx.tcx());\n     let mcx = check_match::MatchCheckCtxt {\n         tcx: bcx.tcx(),\n         param_env: param_env,\n@@ -1008,7 +1008,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let mcx = check_match::MatchCheckCtxt {\n         tcx: bcx.tcx(),\n-        param_env: ty::empty_parameter_environment(),\n+        param_env: ty::empty_parameter_environment(bcx.tcx()),\n     };\n     let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n@@ -1262,8 +1262,7 @@ fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool\n         reassigned: false\n     };\n     {\n-        let param_env = ty::empty_parameter_environment();\n-        let mut visitor = euv::ExprUseVisitor::new(&mut rc, bcx, &param_env);\n+        let mut visitor = euv::ExprUseVisitor::new(&mut rc, bcx);\n         visitor.walk_expr(body);\n     }\n     rc.reassigned\n@@ -1321,15 +1320,14 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n         let tcx = bcx.tcx();\n-        let param_env = ty::empty_parameter_environment();\n+        let param_env = ty::empty_parameter_environment(tcx);\n \n         let llmatch;\n         let trmode;\n         match bm {\n             ast::BindByValue(_)\n-                if !ty::type_moves_by_default(tcx,\n-                                              variable_ty,\n-                                              &param_env) || reassigned => {\n+                if !ty::type_moves_by_default(&param_env, span, variable_ty) || reassigned =>\n+            {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n                                  \"__llmatch\");"}, {"sha": "85a7ec330695064f33a966264d58bcf8f33e0dd9", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -61,7 +61,7 @@ use trans::datum;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, UnboxedClosureTyper};\n use middle::ty::Disr;\n use syntax::ast;\n use syntax::attr;\n@@ -168,7 +168,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, substs) => {\n-            let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs).unwrap();\n+            let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n+            let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, upvar_types[], false, t), false)\n         }"}, {"sha": "4c29467d93a44f9dfe337c57a75ffafe4669b64b", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -731,7 +731,8 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n       }\n       ty::ty_unboxed_closure(def_id, _, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs).unwrap();\n+          let typer = common::NormalizingUnboxedClosureTyper::new(cx.tcx());\n+          let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n           for (i, upvar) in upvars.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);\n@@ -1451,6 +1452,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           llfn: llfndecl,\n           llenv: None,\n           llretslotptr: Cell::new(None),\n+          param_env: ty::empty_parameter_environment(ccx.tcx()),\n           alloca_insert_pt: Cell::new(None),\n           llreturn: Cell::new(None),\n           needs_ret_allocas: nested_returns,"}, {"sha": "6efdcc2f0fa0ff61de6bcfa44b574a469823bc06", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -302,6 +302,9 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // section of the executable we're generating.\n     pub llfn: ValueRef,\n \n+    // always an empty parameter-environment\n+    pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+\n     // The environment argument in a closure.\n     pub llenv: Option<ValueRef>,\n \n@@ -579,12 +582,12 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx()\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        node_id_type(self, id)\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n+        Ok(node_id_type(self, id))\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n-        expr_ty_adjusted(self, expr)\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n+        Ok(expr_ty_adjusted(self, expr))\n     }\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n@@ -625,9 +628,17 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n                     -> ast::CaptureClause {\n         self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n     }\n+\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+        self.fcx.param_env.type_moves_by_default(span, ty)\n+    }\n }\n \n impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n+    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n+        &self.fcx.param_env\n+    }\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind\n@@ -941,14 +952,10 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    // Parameter environment is used to give details about type parameters,\n-    // but since we are in trans, everything is fully monomorphized.\n-    let param_env = ty::empty_parameter_environment();\n-\n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, &typer);\n+    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {\n@@ -983,7 +990,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let vtable = selection.map_move_nested(|predicate| {\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });\n-    let vtable = drain_fulfillment_cx(span, &infcx, &param_env, &mut fulfill_cx, &vtable);\n+    let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n \n     info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n     ccx.trait_cache().borrow_mut().insert(trait_ref,\n@@ -993,21 +1000,27 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub struct NormalizingUnboxedClosureTyper<'a,'tcx:'a> {\n-    tcx: &'a ty::ctxt<'tcx>\n+    param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n \n impl<'a,'tcx> NormalizingUnboxedClosureTyper<'a,'tcx> {\n     pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-        NormalizingUnboxedClosureTyper { tcx: tcx }\n+        // Parameter environment is used to give details about type parameters,\n+        // but since we are in trans, everything is fully monomorphized.\n+        NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n     }\n }\n \n impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'a,'tcx> {\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.param_env\n+    }\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind\n     {\n-        self.tcx.unboxed_closure_kind(def_id)\n+        self.param_env.tcx.unboxed_closure_kind(def_id)\n     }\n \n     fn unboxed_closure_type(&self,\n@@ -1017,8 +1030,8 @@ impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let closure_ty = self.tcx.unboxed_closure_type(def_id, substs);\n-        monomorphize::normalize_associated_type(self.tcx, &closure_ty)\n+        let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n+        monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n     }\n \n     fn unboxed_closure_upvars(&self,\n@@ -1028,14 +1041,13 @@ impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let result = ty::unboxed_closure_upvars(self.tcx, def_id, substs);\n-        monomorphize::normalize_associated_type(self.tcx, &result)\n+        let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n+        monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n     }\n }\n \n pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n                                        infcx: &infer::InferCtxt<'a,'tcx>,\n-                                       param_env: &ty::ParameterEnvironment<'tcx>,\n                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                        result: &T)\n                                        -> T\n@@ -1048,7 +1060,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n     let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n-    match fulfill_cx.select_all_or_error(infcx, param_env, &typer) {\n+    match fulfill_cx.select_all_or_error(infcx, &typer) {\n         Ok(()) => { }\n         Err(errors) => {\n             if errors.iter().all(|e| e.is_overflow()) {"}, {"sha": "72074040a2c678fc37c719911f1febbebf4374de", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -28,6 +28,7 @@ use util::ppaux::{ty_to_string};\n \n use std::fmt;\n use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n \n /// A `Datum` encapsulates the result of evaluating an expression.  It\n /// describes where the value is stored, what Rust type the value has,\n@@ -543,8 +544,9 @@ impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n          * affine values (since they must never be duplicated).\n          */\n \n-        let param_env = ty::empty_parameter_environment();\n-        assert!(!ty::type_moves_by_default(bcx.tcx(), self.ty, &param_env));\n+        assert!(!ty::type_moves_by_default(&ty::empty_parameter_environment(bcx.tcx()),\n+                                           DUMMY_SP,\n+                                           self.ty));\n         self.shallow_copy_raw(bcx, dst)\n     }\n "}, {"sha": "cc259e6765c34f2180030d2a1225d830168b03a9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -322,9 +322,8 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     // FIXME(#20304) -- cache\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    let param_env = ty::empty_parameter_environment();\n-    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, &typer);\n+    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } =\n         traits::normalize(&mut selcx, cause, value);\n@@ -337,7 +336,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     for obligation in obligations.into_iter() {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n-    let result = drain_fulfillment_cx(DUMMY_SP, &infcx, &param_env, &mut fulfill_cx, &result);\n+    let result = drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n \n     result\n }"}, {"sha": "6950850e5f3c140d95306d34f159aafe8ac1c9fa", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -18,7 +18,6 @@ use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                                param_env: &ty::ParameterEnvironment<'tcx>,\n                                                 typer: &(ty::UnboxedClosureTyper<'tcx>+'a),\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,\n                                                 span: Span,\n@@ -28,7 +27,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n {\n     debug!(\"normalize_associated_types_in(value={})\", value.repr(infcx.tcx));\n-    let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+    let mut selcx = SelectionContext::new(infcx, typer);\n     let cause = ObligationCause::new(span, body_id, MiscObligation);\n     let Normalized { value: result, obligations } = traits::normalize(&mut selcx, cause, value);\n     debug!(\"normalize_associated_types_in: result={} predicates={}\","}, {"sha": "92b8c2bbcf718152acf80d06b5256cb683bcf355", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -169,9 +169,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                               poly_trait_ref.as_predicate());\n \n     // Now we want to know if this can be matched\n-    let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n-                                                  &fcx.inh.param_env,\n-                                                  fcx);\n+    let mut selcx = traits::SelectionContext::new(fcx.infcx(), fcx);\n     if !selcx.evaluate_obligation(&obligation) {\n         debug!(\"--> Cannot match obligation\");\n         return None; // Cannot be matched, no such method resolution is possible."}, {"sha": "cd97d89b2465a668dcf7bb1de19088d860e0b2e1", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -788,9 +788,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n \n                     // Evaluate those obligations to see if they might possibly hold.\n-                    let mut selcx = traits::SelectionContext::new(self.infcx(),\n-                                                                  &self.fcx.inh.param_env,\n-                                                                  self.fcx);\n+                    let mut selcx = traits::SelectionContext::new(self.infcx(), self.fcx);\n                     obligations.all(|o| selcx.evaluate_obligation(o))\n                 }\n "}, {"sha": "82525b71052d2be0a625baee3bb2d9ed24d50f37", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -87,6 +87,7 @@ use middle::{const_eval, def};\n use middle::infer;\n use middle::lang_items::IteratorItem;\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::McResult;\n use middle::pat_util::{mod, pat_id_map};\n use middle::region::CodeExtent;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n@@ -129,6 +130,7 @@ pub mod regionmanip;\n pub mod regionck;\n pub mod demand;\n pub mod method;\n+mod upvar;\n pub mod wf;\n mod closure;\n mod callee;\n@@ -146,7 +148,7 @@ mod callee;\n pub struct Inherited<'a, 'tcx: 'a> {\n     infcx: infer::InferCtxt<'a, 'tcx>,\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n-    param_env: ty::ParameterEnvironment<'tcx>,\n+    param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n     // Temporary tables:\n     node_types: RefCell<NodeMap<Ty<'tcx>>>,\n@@ -288,13 +290,17 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         let ty = self.node_ty(id);\n-        self.infcx().resolve_type_vars_if_possible(&ty)\n+        self.resolve_type_vars_or_error(&ty)\n     }\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n-        let ty = self.expr_ty_adjusted(expr);\n-        self.infcx().resolve_type_vars_if_possible(&ty)\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+        let ty = self.adjust_expr_ty(expr, self.inh.adjustments.borrow().get(&expr.id));\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+        let ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        traits::type_known_to_meet_builtin_bound(self.infcx(), self, ty, ty::BoundCopy, span)\n     }\n     fn node_method_ty(&self, method_call: ty::MethodCall)\n                       -> Option<Ty<'tcx>> {\n@@ -317,7 +323,7 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.inh.method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n     }\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n-        self.tcx().temporary_scope(rvalue_id)\n+        self.param_env().temporary_scope(rvalue_id)\n     }\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n         self.inh.upvar_borrow_map.borrow().get(&upvar_id).cloned()\n@@ -329,6 +335,10 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ty::UnboxedClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.inh.param_env\n+    }\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind\n@@ -355,7 +365,7 @@ impl<'a, 'tcx> ty::UnboxedClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n-           param_env: ty::ParameterEnvironment<'tcx>)\n+           param_env: ty::ParameterEnvironment<'a, 'tcx>)\n            -> Inherited<'a, 'tcx> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n@@ -383,7 +393,6 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n-                                             &self.param_env,\n                                              typer,\n                                              &mut *fulfillment_cx, span,\n                                              body_id,\n@@ -413,7 +422,7 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n                                     -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n-    let param_env = ty::empty_parameter_environment();\n+    let param_env = ty::empty_parameter_environment(ccx.tcx);\n     Inherited::new(ccx.tcx, param_env)\n }\n \n@@ -457,7 +466,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            body: &ast::Block,\n                            id: ast::NodeId,\n                            raw_fty: Ty<'tcx>,\n-                           param_env: ty::ParameterEnvironment<'tcx>) {\n+                           param_env: ty::ParameterEnvironment<'a, 'tcx>) {\n     match raw_fty.sty {\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n@@ -468,12 +477,13 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fn_sig =\n                 liberate_late_bound_regions(ccx.tcx, CodeExtent::from_node_id(body.id), &fn_sig);\n             let fn_sig =\n-                inh.normalize_associated_types_in(ccx.tcx, body.span, body.id, &fn_sig);\n+                inh.normalize_associated_types_in(&inh.param_env, body.span, body.id, &fn_sig);\n \n             let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_sig,\n                                decl, id, body, &inh);\n \n             vtable::select_all_fcx_obligations_or_error(&fcx);\n+            upvar::closure_analyze_fn(&fcx, id, decl, body);\n             regionck::regionck_fn(&fcx, id, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n@@ -1220,7 +1230,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let impl_sig =\n             assoc::normalize_associated_types_in(&infcx,\n                                                  &impl_param_env,\n-                                                 infcx.tcx,\n                                                  &mut fulfillment_cx,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n@@ -1241,7 +1250,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let trait_sig =\n             assoc::normalize_associated_types_in(&infcx,\n                                                  &impl_param_env,\n-                                                 infcx.tcx,\n                                                  &mut fulfillment_cx,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n@@ -1277,7 +1285,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Run the fulfillment context to completion to accommodate any\n     // associated type normalizations that may have occurred.\n-    match fulfillment_cx.select_all_or_error(&infcx, &impl_param_env, tcx) {\n+    match fulfillment_cx.select_all_or_error(&infcx, &impl_param_env) {\n         Ok(()) => { }\n         Err(errors) => {\n             traits::report_fulfillment_errors(&infcx, &errors);\n@@ -1457,7 +1465,7 @@ fn check_cast(fcx: &FnCtxt,\n         return\n     }\n \n-    if !fcx.type_is_known_to_be_sized(t_1) {\n+    if !fcx.type_is_known_to_be_sized(t_1, cast_expr.span) {\n         let tstr = fcx.infcx().ty_to_string(t_1);\n         fcx.type_error_message(span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n@@ -1655,11 +1663,11 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    pub fn infcx(&self) -> &infer::InferCtxt<'a, 'tcx> {\n+    pub fn infcx(&self) -> &infer::InferCtxt<'a,'tcx> {\n         &self.inh.infcx\n     }\n \n-    pub fn param_env(&self) -> &ty::ParameterEnvironment<'tcx> {\n+    pub fn param_env(&self) -> &ty::ParameterEnvironment<'a,'tcx> {\n         &self.inh.param_env\n     }\n \n@@ -1671,6 +1679,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n+    /// Resolves all type variables in `t` and then, if any were left\n+    /// unresolved, substitutes an error type. This is used after the\n+    /// main checking when doing a second pass before writeback. The\n+    /// justification is that writeback will produce an error for\n+    /// these unconstrained type variables.\n+    fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n+        let t = self.infcx().resolve_type_vars_if_possible(t);\n+        if ty::type_has_ty_infer(t) || ty::type_is_error(t) { Err(()) } else { Ok(t) }\n+    }\n+\n     pub fn tag(&self) -> String {\n         format!(\"{}\", self as *const FnCtxt)\n     }\n@@ -1820,7 +1838,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.fulfillment_cx\n             .borrow_mut()\n             .normalize_projection_type(self.infcx(),\n-                                       &self.inh.param_env,\n                                        self,\n                                        ty::ProjectionTy {\n                                            trait_ref: trait_ref,\n@@ -1966,13 +1983,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn type_is_known_to_be_sized(&self,\n-                                     ty: Ty<'tcx>)\n+                                     ty: Ty<'tcx>,\n+                                     span: Span)\n                                      -> bool\n     {\n         traits::type_known_to_meet_builtin_bound(self.infcx(),\n                                                  self.param_env(),\n                                                  ty,\n-                                                 ty::BoundSized)\n+                                                 ty::BoundSized,\n+                                                 span)\n     }\n \n     pub fn register_builtin_bound(&self,"}, {"sha": "e97a29ec458c7f9d6ea3f55833ba15a62d75a396", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 23, "deletions": 351, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -81,38 +81,6 @@\n //! traversed.  This is essentially the same as the ownership\n //! relation, except that a borrowed pointer never owns its\n //! contents.\n-//!\n-//! ### Inferring borrow kinds for upvars\n-//!\n-//! Whenever there is a closure expression, we need to determine how each\n-//! upvar is used. We do this by initially assigning each upvar an\n-//! immutable \"borrow kind\" (see `ty::BorrowKind` for details) and then\n-//! \"escalating\" the kind as needed. The borrow kind proceeds according to\n-//! the following lattice:\n-//!\n-//!     ty::ImmBorrow -> ty::UniqueImmBorrow -> ty::MutBorrow\n-//!\n-//! So, for example, if we see an assignment `x = 5` to an upvar `x`, we\n-//! will promote its borrow kind to mutable borrow. If we see an `&mut x`\n-//! we'll do the same. Naturally, this applies not just to the upvar, but\n-//! to everything owned by `x`, so the result is the same for something\n-//! like `x.f = 5` and so on (presuming `x` is not a borrowed pointer to a\n-//! struct). These adjustments are performed in\n-//! `adjust_upvar_borrow_kind()` (you can trace backwards through the code\n-//! from there).\n-//!\n-//! The fact that we are inferring borrow kinds as we go results in a\n-//! semi-hacky interaction with mem-categorization. In particular,\n-//! mem-categorization will query the current borrow kind as it\n-//! categorizes, and we'll return the *current* value, but this may get\n-//! adjusted later. Therefore, in this module, we generally ignore the\n-//! borrow kind (and derived mutabilities) that are returned from\n-//! mem-categorization, since they may be inaccurate. (Another option\n-//! would be to use a unification scheme, where instead of returning a\n-//! concrete borrow kind like `ty::ImmBorrow`, we return a\n-//! `ty::InferBorrow(upvar_id)` or something like that, but this would\n-//! then mean that all later passes would have to check for these figments\n-//! and report an error, and it just seems like more mess in the end.)\n \n use astconv::AstConv;\n use check::FnCtxt;\n@@ -126,20 +94,20 @@ use middle::ty::{ReScope};\n use middle::ty::{mod, Ty, MethodCall};\n use middle::infer;\n use middle::pat_util;\n-use util::nodemap::{FnvHashMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-use std::cell::{RefCell};\n-use std::collections::hash_map::Entry::{Vacant, Occupied};\n-\n use self::RepeatingScope::Repeating;\n use self::SubjectNode::Subject;\n \n+// a variation on try that just returns unit\n+macro_rules! ignore_err {\n+    ($e:expr) => (match $e { Ok(e) => e, Err(_) => return () })\n+}\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -193,19 +161,6 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n-// Stores parameters for a potential call to link_region()\n-// to perform if an upvar reference is marked unique/mutable after\n-// it has already been processed before.\n-struct MaybeLink<'tcx> {\n-    span: Span,\n-    borrow_region: ty::Region,\n-    borrow_kind: ty::BorrowKind,\n-    borrow_cmt: mc::cmt<'tcx>\n-}\n-\n-// A map associating an upvar ID to a vector of the above\n-type MaybeLinkMap<'tcx> = RefCell<FnvHashMap<ty::UpvarId, Vec<MaybeLink<'tcx>>>>;\n-\n pub struct Rcx<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n \n@@ -216,10 +171,6 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n     // id of AST node being analyzed (the subject of the analysis).\n     subject: SubjectNode,\n-\n-    // Possible region links we will establish if an upvar\n-    // turns out to be unique/mutable\n-    maybe_links: MaybeLinkMap<'tcx>\n }\n \n /// Returns the validity region of `def` -- that is, how long is `def` valid?\n@@ -254,8 +205,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               subject: subject,\n-              region_param_pairs: Vec::new(),\n-              maybe_links: RefCell::new(FnvHashMap::new()) }\n+              region_param_pairs: Vec::new() }\n     }\n \n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n@@ -586,19 +536,12 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n-        ast::ExprAssign(ref lhs, _) => {\n-            adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n-            visit::walk_expr(rcx, expr);\n-        }\n-\n         ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n                 constrain_call(rcx, expr, Some(&**lhs),\n                                Some(&**rhs).into_iter(), true);\n             }\n \n-            adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n-\n             visit::walk_expr(rcx, expr);\n         }\n \n@@ -834,22 +777,6 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     visit::walk_expr(rcx, expr);\n     rcx.set_repeating_scope(repeating_scope);\n \n-    match function_type.sty {\n-        ty::ty_closure(box ty::ClosureTy { store: ty::RegionTraitStore(..), .. }) => {\n-            ty::with_freevars(tcx, expr.id, |freevars| {\n-                propagate_upupvar_borrow_kind(rcx, expr, freevars);\n-            })\n-        }\n-        ty::ty_unboxed_closure(..) => {\n-            if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n-                ty::with_freevars(tcx, expr.id, |freevars| {\n-                    propagate_upupvar_borrow_kind(rcx, expr, freevars);\n-                });\n-            }\n-        }\n-        _ => {}\n-    }\n-\n     match function_type.sty {\n         ty::ty_closure(box ty::ClosureTy {ref bounds, ..}) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n@@ -926,7 +853,6 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         freevars: &[ty::Freevar])\n     {\n         let tcx = rcx.fcx.ccx.tcx;\n-        let infcx = rcx.fcx.infcx();\n         debug!(\"constrain_free_variables({}, {})\",\n                region_bound.repr(tcx), expr.repr(tcx));\n         for freevar in freevars.iter() {\n@@ -942,20 +868,10 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                          closure_expr_id: expr.id };\n \n-            // Create a region variable to represent this borrow. This borrow\n-            // must outlive the region on the closure.\n-            let origin = infer::UpvarRegion(upvar_id, expr.span);\n-            let freevar_region = infcx.next_region_var(origin);\n-            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                            region_bound, freevar_region);\n+            let upvar_borrow = rcx.fcx.inh.upvar_borrow_map.borrow()[upvar_id];\n \n-            // Create a UpvarBorrow entry. Note that we begin with a\n-            // const borrow_kind, but change it to either mut or\n-            // immutable as dictated by the uses.\n-            let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n-                                                 region: freevar_region };\n-            rcx.fcx.inh.upvar_borrow_map.borrow_mut().insert(upvar_id,\n-                                                             upvar_borrow);\n+            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n+                            region_bound, upvar_borrow.region);\n \n             // Guarantee that the closure does not outlive the variable itself.\n             let enclosing_region = region_of_def(rcx.fcx, def);\n@@ -964,52 +880,6 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                             region_bound, enclosing_region);\n         }\n     }\n-\n-    fn propagate_upupvar_borrow_kind(rcx: &mut Rcx,\n-                                     expr: &ast::Expr,\n-                                     freevars: &[ty::Freevar]) {\n-        let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"propagate_upupvar_borrow_kind({})\", expr.repr(tcx));\n-        for freevar in freevars.iter() {\n-            // Because of the semi-hokey way that we are doing\n-            // borrow_kind inference, we need to check for\n-            // indirect dependencies, like so:\n-            //\n-            //     let mut x = 0;\n-            //     outer_call(|| {\n-            //         inner_call(|| {\n-            //             x = 1;\n-            //         });\n-            //     });\n-            //\n-            // Here, the `inner_call` is basically \"reborrowing\" the\n-            // outer pointer. With no other changes, `inner_call`\n-            // would infer that it requires a mutable borrow, but\n-            // `outer_call` would infer that a const borrow is\n-            // sufficient. This is because we haven't linked the\n-            // borrow_kind of the borrow that occurs in the inner\n-            // closure to the borrow_kind of the borrow in the outer\n-            // closure. Note that regions *are* naturally linked\n-            // because we have a proper inference scheme there.\n-            //\n-            // Anyway, for borrow_kind, we basically go back over now\n-            // after checking the inner closure (and hence\n-            // determining the final borrow_kind) and propagate that as\n-            // a constraint on the outer closure.\n-            if let def::DefUpvar(var_id, outer_closure_id, _) = freevar.def {\n-                // thing being captured is itself an upvar:\n-                let outer_upvar_id = ty::UpvarId {\n-                    var_id: var_id,\n-                    closure_expr_id: outer_closure_id };\n-                let inner_upvar_id = ty::UpvarId {\n-                    var_id: var_id,\n-                    closure_expr_id: expr.id };\n-                link_upvar_borrow_kind_for_nested_closures(rcx,\n-                                                           inner_upvar_id,\n-                                                           outer_upvar_id);\n-            }\n-        }\n-    }\n }\n \n fn constrain_callee(rcx: &mut Rcx,\n@@ -1027,7 +897,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                     // While we're here, link the closure's region with a unique\n                     // immutable borrow (gathered later in borrowck)\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-                    let expr_cmt = mc.cat_expr(callee_expr);\n+                    let expr_cmt = ignore_err!(mc.cat_expr(callee_expr));\n                     link_region(rcx, callee_expr.span, call_region,\n                                 ty::UniqueImmBorrow, expr_cmt);\n                     r\n@@ -1136,7 +1006,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 };\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-                    let self_cmt = mc.cat_expr_autoderefd(deref_expr, i);\n+                    let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     link_region(rcx, deref_expr.span, *r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n@@ -1232,7 +1102,7 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n \n     let cmt = {\n         let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-        mc.cat_expr(base)\n+        ignore_err!(mc.cat_expr(base))\n     };\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n@@ -1247,7 +1117,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n         Some(ref expr) => &**expr,\n     };\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let discr_cmt = mc.cat_expr(init_expr);\n+    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n     link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n \n@@ -1257,7 +1127,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let discr_cmt = mc.cat_expr(discr);\n+    let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n     for arm in arms.iter() {\n         for root_pat in arm.pats.iter() {\n@@ -1303,11 +1173,14 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n                 // `[_, ..slice, _]` pattern\n                 ast::PatVec(_, Some(ref slice_pat), _) => {\n-                    let (slice_cmt, slice_mutbl, slice_r) =\n-                        mc.cat_slice_pattern(sub_cmt, &**slice_pat);\n-                    link_region(rcx, sub_pat.span, slice_r,\n-                                ty::BorrowKind::from_mutbl(slice_mutbl),\n-                                slice_cmt);\n+                    match mc.cat_slice_pattern(sub_cmt, &**slice_pat) {\n+                        Ok((slice_cmt, slice_mutbl, slice_r)) => {\n+                            link_region(rcx, sub_pat.span, slice_r,\n+                                        ty::BorrowKind::from_mutbl(slice_mutbl),\n+                                        slice_cmt);\n+                        }\n+                        Err(()) => {}\n+                    }\n                 }\n                 _ => {}\n             }\n@@ -1323,7 +1196,7 @@ fn link_autoref(rcx: &Rcx,\n \n     debug!(\"link_autoref(autoref={})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let expr_cmt = mc.cat_expr_autoderefd(expr, autoderefs);\n+    let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n     match *autoref {\n@@ -1345,7 +1218,7 @@ fn link_by_ref(rcx: &Rcx,\n     debug!(\"link_by_ref(expr={}, callee_scope={})\",\n            expr.repr(tcx), callee_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let expr_cmt = mc.cat_expr(expr);\n+    let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n     link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n }\n@@ -1484,14 +1357,6 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n             match upvar_borrow_map.get_mut(upvar_id) {\n                 Some(upvar_borrow) => {\n-                    // Adjust mutability that we infer for the upvar\n-                    // so it can accommodate being borrowed with\n-                    // mutability `kind`:\n-                    adjust_upvar_borrow_kind_for_loan(rcx,\n-                                                      *upvar_id,\n-                                                      upvar_borrow,\n-                                                      borrow_kind);\n-\n                     // The mutability of the upvar may have been modified\n                     // by the above adjustment, so update our local variable.\n                     ref_kind = upvar_borrow.kind;\n@@ -1576,27 +1441,6 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n             // else the user is borrowed imm memory as mut memory,\n             // which means they'll get an error downstream in borrowck\n             // anyhow.)\n-            //\n-            // If mutability was inferred from an upvar, we may be\n-            // forced to revisit this decision later if processing\n-            // another borrow or nested closure ends up converting the\n-            // upvar borrow kind to mutable/unique.  Record the\n-            // information needed to perform the recursive link in the\n-            // maybe link map.\n-            if let mc::NoteUpvarRef(upvar_id) = note {\n-                let link = MaybeLink {\n-                    span: span,\n-                    borrow_region: borrow_region,\n-                    borrow_kind: new_borrow_kind,\n-                    borrow_cmt: ref_cmt\n-                };\n-\n-                match rcx.maybe_links.borrow_mut().entry(upvar_id) {\n-                    Vacant(entry) => { entry.set(vec![link]); }\n-                    Occupied(entry) => { entry.into_mut().push(link); }\n-                }\n-            }\n-\n             return None;\n         }\n \n@@ -1608,178 +1452,6 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     }\n }\n \n-/// Adjusts the inferred borrow_kind as needed to account for upvars that are assigned to in an\n-/// assignment expression.\n-fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n-                                         lhs: &ast::Expr) {\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let cmt = mc.cat_expr(lhs);\n-    adjust_upvar_borrow_kind_for_mut(rcx, cmt);\n-}\n-\n-/// Indicates that `cmt` is being directly mutated (e.g., assigned to). If cmt contains any by-ref\n-/// upvars, this implies that those upvars must be borrowed using an `&mut` borow.\n-fn adjust_upvar_borrow_kind_for_mut<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                              cmt: mc::cmt<'tcx>) {\n-    let mut cmt = cmt;\n-    loop {\n-        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n-               cmt.repr(rcx.tcx()));\n-\n-        match cmt.cat.clone() {\n-            mc::cat_deref(base, _, mc::Unique) |\n-            mc::cat_interior(base, _) |\n-            mc::cat_downcast(base, _) => {\n-                // Interior or owned data is mutable if base is\n-                // mutable, so iterate to the base.\n-                cmt = base;\n-                continue;\n-            }\n-\n-            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n-            mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(ref upvar_id) = cmt.note {\n-                    // if this is an implicit deref of an\n-                    // upvar, then we need to modify the\n-                    // borrow_kind of the upvar to make sure it\n-                    // is inferred to mutable if necessary\n-                    let mut upvar_borrow_map =\n-                        rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                    let ub = &mut (*upvar_borrow_map)[*upvar_id];\n-                    return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::MutBorrow);\n-                }\n-\n-                // assignment to deref of an `&mut`\n-                // borrowed pointer implies that the\n-                // pointer itself must be unique, but not\n-                // necessarily *mutable*\n-                return adjust_upvar_borrow_kind_for_unique(rcx, base);\n-            }\n-\n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-            mc::cat_static_item |\n-            mc::cat_rvalue(_) |\n-            mc::cat_local(_) |\n-            mc::cat_upvar(..) => {\n-                return;\n-            }\n-        }\n-    }\n-}\n-\n-fn adjust_upvar_borrow_kind_for_unique<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, cmt: mc::cmt<'tcx>) {\n-    let mut cmt = cmt;\n-    loop {\n-        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n-               cmt.repr(rcx.tcx()));\n-\n-        match cmt.cat.clone() {\n-            mc::cat_deref(base, _, mc::Unique) |\n-            mc::cat_interior(base, _) |\n-            mc::cat_downcast(base, _) => {\n-                // Interior or owned data is unique if base is\n-                // unique.\n-                cmt = base;\n-                continue;\n-            }\n-\n-            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n-            mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(ref upvar_id) = cmt.note {\n-                    // if this is an implicit deref of an\n-                    // upvar, then we need to modify the\n-                    // borrow_kind of the upvar to make sure it\n-                    // is inferred to unique if necessary\n-                    let mut ub = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                    let ub = &mut (*ub)[*upvar_id];\n-                    return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::UniqueImmBorrow);\n-                }\n-\n-                // for a borrowed pointer to be unique, its\n-                // base must be unique\n-                return adjust_upvar_borrow_kind_for_unique(rcx, base);\n-            }\n-\n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-            mc::cat_static_item |\n-            mc::cat_rvalue(_) |\n-            mc::cat_local(_) |\n-            mc::cat_upvar(..) => {\n-                return;\n-            }\n-        }\n-    }\n-}\n-\n-/// Indicates that the borrow_kind of `outer_upvar_id` must permit a reborrowing with the\n-/// borrow_kind of `inner_upvar_id`. This occurs in nested closures, see comment above at the call\n-/// to this function.\n-fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n-                                              inner_upvar_id: ty::UpvarId,\n-                                              outer_upvar_id: ty::UpvarId) {\n-    debug!(\"link_upvar_borrow_kind: inner_upvar_id={} outer_upvar_id={}\",\n-           inner_upvar_id, outer_upvar_id);\n-\n-    let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-    let inner_borrow = upvar_borrow_map[inner_upvar_id].clone();\n-    match upvar_borrow_map.get_mut(&outer_upvar_id) {\n-        Some(outer_borrow) => {\n-            adjust_upvar_borrow_kind(rcx, outer_upvar_id, outer_borrow, inner_borrow.kind);\n-        }\n-        None => { /* outer closure is not a stack closure */ }\n-    }\n-}\n-\n-fn adjust_upvar_borrow_kind_for_loan(rcx: &Rcx,\n-                                     upvar_id: ty::UpvarId,\n-                                     upvar_borrow: &mut ty::UpvarBorrow,\n-                                     kind: ty::BorrowKind) {\n-    debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={} kind={} -> {}\",\n-           upvar_id, upvar_borrow.kind, kind);\n-\n-    adjust_upvar_borrow_kind(rcx, upvar_id, upvar_borrow, kind)\n-}\n-\n-/// We infer the borrow_kind with which to borrow upvars in a stack closure. The borrow_kind\n-/// basically follows a lattice of `imm < unique-imm < mut`, moving from left to right as needed\n-/// (but never right to left). Here the argument `mutbl` is the borrow_kind that is required by\n-/// some particular use.\n-fn adjust_upvar_borrow_kind(rcx: &Rcx,\n-                            upvar_id: ty::UpvarId,\n-                            upvar_borrow: &mut ty::UpvarBorrow,\n-                            kind: ty::BorrowKind) {\n-    debug!(\"adjust_upvar_borrow_kind: id={} kind=({} -> {})\",\n-           upvar_id, upvar_borrow.kind, kind);\n-\n-    match (upvar_borrow.kind, kind) {\n-        // Take RHS:\n-        (ty::ImmBorrow, ty::UniqueImmBorrow) |\n-        (ty::ImmBorrow, ty::MutBorrow) |\n-        (ty::UniqueImmBorrow, ty::MutBorrow) => {\n-            upvar_borrow.kind = kind;\n-\n-            // Check if there are any region links we now need to\n-            // establish due to adjusting the borrow kind of the upvar\n-            match rcx.maybe_links.borrow_mut().entry(upvar_id) {\n-                Occupied(entry) => {\n-                    for MaybeLink { span, borrow_region,\n-                                    borrow_kind, borrow_cmt } in entry.take().into_iter()\n-                    {\n-                        link_region(rcx, span, borrow_region, borrow_kind, borrow_cmt);\n-                    }\n-                }\n-                Vacant(_) => {}\n-            }\n-        }\n-        // Take LHS:\n-        (ty::ImmBorrow, ty::ImmBorrow) |\n-        (ty::UniqueImmBorrow, ty::ImmBorrow) |\n-        (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n-        (ty::MutBorrow, _) => {\n-        }\n-    }\n-}\n-\n /// Ensures that all borrowed data reachable via `ty` outlives `region`.\n fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                origin: infer::SubregionOrigin<'tcx>,"}, {"sha": "a4c3550fcd676d4c6c9cc2efe0eef8847a9b8376", "filename": "src/librustc_typeck/check/upvar.rs", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -0,0 +1,373 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! ### Inferring borrow kinds for upvars\n+//!\n+//! Whenever there is a closure expression, we need to determine how each\n+//! upvar is used. We do this by initially assigning each upvar an\n+//! immutable \"borrow kind\" (see `ty::BorrowKind` for details) and then\n+//! \"escalating\" the kind as needed. The borrow kind proceeds according to\n+//! the following lattice:\n+//!\n+//!     ty::ImmBorrow -> ty::UniqueImmBorrow -> ty::MutBorrow\n+//!\n+//! So, for example, if we see an assignment `x = 5` to an upvar `x`, we\n+//! will promote its borrow kind to mutable borrow. If we see an `&mut x`\n+//! we'll do the same. Naturally, this applies not just to the upvar, but\n+//! to everything owned by `x`, so the result is the same for something\n+//! like `x.f = 5` and so on (presuming `x` is not a borrowed pointer to a\n+//! struct). These adjustments are performed in\n+//! `adjust_upvar_borrow_kind()` (you can trace backwards through the code\n+//! from there).\n+//!\n+//! The fact that we are inferring borrow kinds as we go results in a\n+//! semi-hacky interaction with mem-categorization. In particular,\n+//! mem-categorization will query the current borrow kind as it\n+//! categorizes, and we'll return the *current* value, but this may get\n+//! adjusted later. Therefore, in this module, we generally ignore the\n+//! borrow kind (and derived mutabilities) that are returned from\n+//! mem-categorization, since they may be inaccurate. (Another option\n+//! would be to use a unification scheme, where instead of returning a\n+//! concrete borrow kind like `ty::ImmBorrow`, we return a\n+//! `ty::InferBorrow(upvar_id)` or something like that, but this would\n+//! then mean that all later passes would have to check for these figments\n+//! and report an error, and it just seems like more mess in the end.)\n+\n+use super::FnCtxt;\n+\n+use middle::expr_use_visitor as euv;\n+use middle::mem_categorization as mc;\n+use middle::ty::{mod};\n+use middle::infer::{InferCtxt, UpvarRegion};\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::visit::{mod, Visitor};\n+use util::ppaux::Repr;\n+\n+///////////////////////////////////////////////////////////////////////////\n+// PUBLIC ENTRY POINTS\n+\n+pub fn closure_analyze_fn(fcx: &FnCtxt,\n+                          _id: ast::NodeId,\n+                          decl: &ast::FnDecl,\n+                          body: &ast::Block) {\n+    let mut seed = SeedBorrowKind::new(fcx);\n+    seed.visit_block(body);\n+\n+    let mut adjust = AdjustBorrowKind::new(fcx);\n+    adjust.analyze_fn(decl, body);\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// SEED BORROW KIND\n+\n+struct SeedBorrowKind<'a,'tcx:'a> {\n+    fcx: &'a FnCtxt<'a,'tcx>,\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &ast::Expr) {\n+        match expr.node {\n+            ast::ExprClosure(cc, _, _, ref body) => {\n+                self.check_closure(expr, cc, &**body);\n+            }\n+\n+            _ => { }\n+        }\n+\n+        visit::walk_expr(self, expr);\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fn_kind: visit::FnKind<'v>,\n+                decl: &'v ast::FnDecl,\n+                block: &'v ast::Block,\n+                span: Span,\n+                _id: ast::NodeId)\n+    {\n+        match fn_kind {\n+            visit::FkItemFn(..) | visit::FkMethod(..) => {\n+                // ignore nested fn items\n+            }\n+            visit::FkFnBlock => {\n+                visit::walk_fn(self, fn_kind, decl, block, span);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a,'tcx>) -> SeedBorrowKind<'a,'tcx> {\n+        SeedBorrowKind { fcx: fcx }\n+    }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n+\n+    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+        self.fcx.infcx()\n+    }\n+\n+    fn check_closure(&mut self,\n+                     expr: &ast::Expr,\n+                     capture_clause: ast::CaptureClause,\n+                     _body: &ast::Block)\n+    {\n+        let is_old_skool_closure = match self.fcx.expr_ty(expr).sty {\n+            ty::ty_closure(..) => true,\n+            _ => false,\n+        };\n+\n+        match capture_clause {\n+            ast::CaptureByValue if !is_old_skool_closure => {\n+            }\n+            _ => {\n+                ty::with_freevars(self.tcx(), expr.id, |freevars| {\n+                    for freevar in freevars.iter() {\n+                        let var_node_id = freevar.def.local_node_id();\n+                        let upvar_id = ty::UpvarId { var_id: var_node_id,\n+                                                     closure_expr_id: expr.id };\n+                        debug!(\"seed upvar_id {}\", upvar_id);\n+                        let origin = UpvarRegion(upvar_id, expr.span);\n+                        let freevar_region = self.infcx().next_region_var(origin);\n+                        let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n+                                                             region: freevar_region };\n+                        self.fcx.inh.upvar_borrow_map.borrow_mut().insert(upvar_id,\n+                                                                          upvar_borrow);\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// ADJUST BORROW KIND\n+\n+struct AdjustBorrowKind<'a,'tcx:'a> {\n+    fcx: &'a FnCtxt<'a,'tcx>\n+}\n+\n+impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n+    fn new(fcx: &'a FnCtxt<'a,'tcx>) -> AdjustBorrowKind<'a,'tcx> {\n+        AdjustBorrowKind { fcx: fcx }\n+    }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n+\n+    fn analyze_fn(&mut self, decl: &ast::FnDecl, body: &ast::Block) {\n+        /*!\n+         * Analysis starting point.\n+         */\n+\n+        self.visit_block(body);\n+\n+        debug!(\"analyzing fn body with id {}\", body.id);\n+\n+        let mut euv = euv::ExprUseVisitor::new(self, self.fcx);\n+        euv.walk_fn(decl, body);\n+    }\n+\n+    /// Indicates that `cmt` is being directly mutated (e.g., assigned\n+    /// to). If cmt contains any by-ref upvars, this implies that\n+    /// those upvars must be borrowed using an `&mut` borow.\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n+               cmt.repr(self.tcx()));\n+\n+        match cmt.cat.clone() {\n+            mc::cat_deref(base, _, mc::Unique) |\n+            mc::cat_interior(base, _) |\n+            mc::cat_downcast(base, _) => {\n+                // Interior or owned data is mutable if base is\n+                // mutable, so iterate to the base.\n+                self.adjust_upvar_borrow_kind_for_mut(base);\n+            }\n+\n+            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n+            mc::cat_deref(base, _, mc::Implicit(..)) => {\n+                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n+                    // if this is an implicit deref of an\n+                    // upvar, then we need to modify the\n+                    // borrow_kind of the upvar to make sure it\n+                    // is inferred to mutable if necessary\n+                    let mut upvar_borrow_map = self.fcx.inh.upvar_borrow_map.borrow_mut();\n+                    let ub = &mut upvar_borrow_map[upvar_id];\n+                    self.adjust_upvar_borrow_kind(upvar_id, ub, ty::MutBorrow);\n+                } else {\n+                    // assignment to deref of an `&mut`\n+                    // borrowed pointer implies that the\n+                    // pointer itself must be unique, but not\n+                    // necessarily *mutable*\n+                    self.adjust_upvar_borrow_kind_for_unique(base);\n+                }\n+            }\n+\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_static_item |\n+            mc::cat_rvalue(_) |\n+            mc::cat_local(_) |\n+            mc::cat_upvar(..) => {\n+                return;\n+            }\n+        }\n+    }\n+\n+    fn adjust_upvar_borrow_kind_for_unique(&self, cmt: mc::cmt<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n+               cmt.repr(self.tcx()));\n+\n+        match cmt.cat.clone() {\n+            mc::cat_deref(base, _, mc::Unique) |\n+            mc::cat_interior(base, _) |\n+            mc::cat_downcast(base, _) => {\n+                // Interior or owned data is unique if base is\n+                // unique.\n+                self.adjust_upvar_borrow_kind_for_unique(base);\n+            }\n+\n+            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n+            mc::cat_deref(base, _, mc::Implicit(..)) => {\n+                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n+                    // if this is an implicit deref of an\n+                    // upvar, then we need to modify the\n+                    // borrow_kind of the upvar to make sure it\n+                    // is inferred to unique if necessary\n+                    let mut ub = self.fcx.inh.upvar_borrow_map.borrow_mut();\n+                    let ub = &mut ub[upvar_id];\n+                    self.adjust_upvar_borrow_kind(upvar_id, ub, ty::UniqueImmBorrow);\n+                } else {\n+                    // for a borrowed pointer to be unique, its\n+                    // base must be unique\n+                    self.adjust_upvar_borrow_kind_for_unique(base);\n+                }\n+            }\n+\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_static_item |\n+            mc::cat_rvalue(_) |\n+            mc::cat_local(_) |\n+            mc::cat_upvar(..) => {\n+            }\n+        }\n+    }\n+\n+    /// We infer the borrow_kind with which to borrow upvars in a stack closure. The borrow_kind\n+    /// basically follows a lattice of `imm < unique-imm < mut`, moving from left to right as needed\n+    /// (but never right to left). Here the argument `mutbl` is the borrow_kind that is required by\n+    /// some particular use.\n+    fn adjust_upvar_borrow_kind(&self,\n+                                upvar_id: ty::UpvarId,\n+                                upvar_borrow: &mut ty::UpvarBorrow,\n+                                kind: ty::BorrowKind) {\n+        debug!(\"adjust_upvar_borrow_kind: id={} kind=({} -> {})\",\n+               upvar_id, upvar_borrow.kind, kind);\n+\n+        match (upvar_borrow.kind, kind) {\n+            // Take RHS:\n+            (ty::ImmBorrow, ty::UniqueImmBorrow) |\n+            (ty::ImmBorrow, ty::MutBorrow) |\n+            (ty::UniqueImmBorrow, ty::MutBorrow) => {\n+                upvar_borrow.kind = kind;\n+            }\n+            // Take LHS:\n+            (ty::ImmBorrow, ty::ImmBorrow) |\n+            (ty::UniqueImmBorrow, ty::ImmBorrow) |\n+            (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n+            (ty::MutBorrow, _) => {\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx> {\n+    fn visit_fn(&mut self,\n+                fn_kind: visit::FnKind<'v>,\n+                decl: &'v ast::FnDecl,\n+                body: &'v ast::Block,\n+                span: Span,\n+                _id: ast::NodeId)\n+    {\n+        match fn_kind {\n+            visit::FkItemFn(..) | visit::FkMethod(..) => {\n+                // ignore nested fn items\n+            }\n+            visit::FkFnBlock => {\n+                self.analyze_fn(decl, body);\n+                visit::walk_fn(self, fn_kind, decl, body, span);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n+    fn consume(&mut self,\n+               _consume_id: ast::NodeId,\n+               _consume_span: Span,\n+               _cmt: mc::cmt<'tcx>,\n+               _mode: euv::ConsumeMode)\n+    {}\n+\n+    fn matched_pat(&mut self,\n+                   _matched_pat: &ast::Pat,\n+                   _cmt: mc::cmt<'tcx>,\n+                   _mode: euv::MatchMode)\n+    {}\n+\n+    fn consume_pat(&mut self,\n+                   _consume_pat: &ast::Pat,\n+                   _cmt: mc::cmt<'tcx>,\n+                   _mode: euv::ConsumeMode)\n+    {}\n+\n+    fn borrow(&mut self,\n+              borrow_id: ast::NodeId,\n+              _borrow_span: Span,\n+              cmt: mc::cmt<'tcx>,\n+              _loan_region: ty::Region,\n+              bk: ty::BorrowKind,\n+              _loan_cause: euv::LoanCause)\n+    {\n+        debug!(\"borrow(borrow_id={}, cmt={}, bk={})\",\n+               borrow_id, cmt.repr(self.tcx()), bk);\n+\n+        match bk {\n+            ty::ImmBorrow => { }\n+            ty::UniqueImmBorrow => {\n+                self.adjust_upvar_borrow_kind_for_unique(cmt);\n+            }\n+            ty::MutBorrow => {\n+                self.adjust_upvar_borrow_kind_for_mut(cmt);\n+            }\n+        }\n+    }\n+\n+    fn decl_without_init(&mut self,\n+                         _id: ast::NodeId,\n+                         _span: Span)\n+    {}\n+\n+    fn mutate(&mut self,\n+              _assignment_id: ast::NodeId,\n+              _assignment_span: Span,\n+              assignee_cmt: mc::cmt<'tcx>,\n+              _mode: euv::MutateMode)\n+    {\n+        debug!(\"mutate(assignee_cmt={})\",\n+               assignee_cmt.repr(self.tcx()));\n+\n+        self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n+    }\n+}\n+\n+"}, {"sha": "8566d1f1e12b97e3b773cf0df57dde3e153cf01e", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -287,9 +287,7 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     fcx.default_type_parameters();\n \n     let mut fulfillment_cx = fcx.inh.fulfillment_cx.borrow_mut();\n-    let r = fulfillment_cx.select_all_or_error(fcx.infcx(),\n-                                               &fcx.inh.param_env,\n-                                               fcx);\n+    let r = fulfillment_cx.select_all_or_error(fcx.infcx(), fcx);\n     match r {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n@@ -302,7 +300,7 @@ pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt)\n     match\n         fcx.inh.fulfillment_cx\n         .borrow_mut()\n-        .select_where_possible(fcx.infcx(), &fcx.inh.param_env, fcx)\n+        .select_where_possible(fcx.infcx(), fcx)\n     {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n@@ -316,7 +314,7 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n     match\n         fcx.inh.fulfillment_cx\n         .borrow_mut()\n-        .select_new_obligations(fcx.infcx(), &fcx.inh.param_env, fcx)\n+        .select_new_obligations(fcx.infcx(), fcx)\n     {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }"}, {"sha": "bb308198330f3408e87ce3b01dc8c1fae59adf7a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -482,7 +482,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_copy: self_type={} (free)\",\n                    self_type.repr(tcx));\n \n-            match ty::can_type_implement_copy(tcx, self_type, &param_env) {\n+            match ty::can_type_implement_copy(&param_env, span, self_type) {\n                 Ok(()) => {}\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n                     tcx.sess"}, {"sha": "8163df5e967cd52f8ec9ea9225f3c05bfb4a5952", "filename": "src/test/compile-fail/borrowck-closures-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -24,6 +24,7 @@ fn a(x: &int) {\n     //~^ ERROR cannot borrow\n     let c2 = || set(&mut *x);\n     //~^ ERROR cannot borrow\n+    //~| ERROR closure requires unique access\n }\n \n fn main() {"}, {"sha": "3889b6f4f7dceca1d9d261603bdddfe69d598a30", "filename": "src/test/compile-fail/issue-17551.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -13,6 +13,6 @@\n struct B<T>;\n \n fn main() {\n-    let foo = B; //~ ERROR unable to infer enough type information\n-    let closure = |:| foo;\n+    let foo = B;\n+    let closure = |:| foo; //~ ERROR unable to infer enough type information\n }"}, {"sha": "41621a934d17abd4dbcab663b46f34cf77a0b0a9", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -14,6 +14,9 @@\n #[lang=\"sized\"]\n pub trait Sized {}\n \n+#[lang=\"copy\"]\n+pub trait Copy {}\n+\n mod bar {\n     // shouldn't bring in too much\n     pub use self::glob::*;"}, {"sha": "70e7e2df98a690d4f9e29628fa400d775b2dd674", "filename": "src/test/compile-fail/privacy4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs?ref=fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "patch": "@@ -12,6 +12,7 @@\n #![no_std] // makes debugging this test *a lot* easier (during resolve)\n \n #[lang = \"sized\"] pub trait Sized for Sized? {}\n+#[lang=\"copy\"] pub trait Copy {}\n \n // Test to make sure that private items imported through globs remain private\n // when  they're used."}]}