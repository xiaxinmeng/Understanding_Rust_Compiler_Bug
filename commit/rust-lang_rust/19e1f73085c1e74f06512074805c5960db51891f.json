{"sha": "19e1f73085c1e74f06512074805c5960db51891f", "node_id": "C_kwDOAAsO6NoAKDE5ZTFmNzMwODVjMWU3NGYwNjUxMjA3NDgwNWM1OTYwZGI1MTg5MWY", "commit": {"author": {"name": "Christian Poveda", "email": "git@pvdrz.com", "date": "2022-05-18T15:50:59Z"}, "committer": {"name": "Christian Poveda", "email": "git@pvdrz.com", "date": "2022-05-18T15:50:59Z"}, "message": "generate `set_arg` code inside `generate_field_attrs_code`", "tree": {"sha": "4a8ad337848e025b25c269abee763766bf3373e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a8ad337848e025b25c269abee763766bf3373e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19e1f73085c1e74f06512074805c5960db51891f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQRsB8A/3NrzTlMMjT0nUl7150IKUAUCYoUV4wAKCRAnUl7150IK\nUGgVAQCGw25+5iy9pdFw/Qw/sDqxycSHX2N2fDt/vjHPK8UaowEA/jakQpr/7tl0\nlpCoGhZ3wKCszsMAKVjm/gG3yd+7Ggw=\n=1gbQ\n-----END PGP SIGNATURE-----", "payload": "tree 4a8ad337848e025b25c269abee763766bf3373e2\nparent 462c1c846b5488024c2e5fec6e1ed4700642b49e\nauthor Christian Poveda <git@pvdrz.com> 1652889059 -0500\ncommitter Christian Poveda <git@pvdrz.com> 1652889059 -0500\n\ngenerate `set_arg` code inside `generate_field_attrs_code`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19e1f73085c1e74f06512074805c5960db51891f", "html_url": "https://github.com/rust-lang/rust/commit/19e1f73085c1e74f06512074805c5960db51891f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19e1f73085c1e74f06512074805c5960db51891f/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "462c1c846b5488024c2e5fec6e1ed4700642b49e", "url": "https://api.github.com/repos/rust-lang/rust/commits/462c1c846b5488024c2e5fec6e1ed4700642b49e", "html_url": "https://github.com/rust-lang/rust/commit/462c1c846b5488024c2e5fec6e1ed4700642b49e"}], "stats": {"total": 200, "additions": 101, "deletions": 99}, "files": [{"sha": "25cba2df7f19b869072198f638601817d2df33ae", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 101, "deletions": 99, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/19e1f73085c1e74f06512074805c5960db51891f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e1f73085c1e74f06512074805c5960db51891f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=19e1f73085c1e74f06512074805c5960db51891f", "patch": "@@ -71,91 +71,72 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                     }\n                 };\n \n-                // Keep track of which fields are subdiagnostics\n-                let mut subdiagnostics = std::collections::HashSet::new();\n+                // Keep track of which fields are subdiagnostics or have no attributes.\n+                let mut subdiagnostics_or_empty = std::collections::HashSet::new();\n \n                 // Generates calls to `span_label` and similar functions based on the attributes\n                 // on fields. Code for suggestions uses formatting machinery and the value of\n                 // other fields - because any given field can be referenced multiple times, it\n-                // should be accessed through a borrow. When passing fields to `set_arg` (which\n-                // happens below) for Fluent, we want to move the data, so that has to happen\n-                // in a separate pass over the fields.\n+                // should be accessed through a borrow. When passing fields to `add_subdiagnostic`\n+                // or `set_arg` (which happens below) for Fluent, we want to move the data, so that\n+                // has to happen in a separate pass over the fields.\n                 let attrs = structure\n                     .clone()\n-                    // Remove the fields that have a `subdiagnostic` attribute.\n                     .filter(|field_binding| {\n-                        field_binding.ast().attrs.iter().all(|attr| {\n-                            \"subdiagnostic\" != attr.path.segments.last().unwrap().ident.to_string()\n-                                || {\n-                                    subdiagnostics.insert(field_binding.binding.clone());\n-                                    false\n-                                }\n-                        })\n+                        let attrs = &field_binding.ast().attrs;\n+\n+                        (!attrs.is_empty()\n+                            && attrs.iter().all(|attr| {\n+                                \"subdiagnostic\"\n+                                    != attr.path.segments.last().unwrap().ident.to_string()\n+                            }))\n+                            || {\n+                                subdiagnostics_or_empty.insert(field_binding.binding.clone());\n+                                false\n+                            }\n                     })\n                     .each(|field_binding| {\n                         let field = field_binding.ast();\n-                        let result = field.attrs.iter().map(|attr| {\n-                            builder\n-                                .generate_field_attr_code(\n-                                    attr,\n-                                    FieldInfo {\n-                                        vis: &field.vis,\n-                                        binding: field_binding,\n-                                        ty: &field.ty,\n-                                        span: &field.span(),\n-                                    },\n-                                )\n-                                .unwrap_or_else(|v| v.to_compile_error())\n-                        });\n-\n-                        quote! { #(#result);* }\n+                        let field_span = field.span();\n+\n+                        builder.generate_field_attrs_code(\n+                            &field.attrs,\n+                            FieldInfo {\n+                                vis: &field.vis,\n+                                binding: field_binding,\n+                                ty: &field.ty,\n+                                span: &field_span,\n+                            },\n+                        )\n                     });\n \n-                // When generating `set_arg` calls, move data rather than borrow it to avoid\n-                // requiring clones - this must therefore be the last use of each field (for\n-                // example, any formatting machinery that might refer to a field should be\n-                // generated already).\n+                // When generating `set_arg` or `add_subdiagnostic` calls, move data rather than\n+                // borrow it to avoid requiring clones - this must therefore be the last use of\n+                // each field (for example, any formatting machinery that might refer to a field\n+                // should be generated already).\n                 structure.bind_with(|_| synstructure::BindStyle::Move);\n-                let args = structure.each(|field_binding| {\n-                    let field = field_binding.ast();\n-                    // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n-                    // need to be passed as an argument to the diagnostic. But when a field has no\n-                    // attributes then it must be passed as an argument to the diagnostic so that\n-                    // it can be referred to by Fluent messages.\n-                    let tokens = if field.attrs.is_empty() {\n-                        let diag = &builder.diag;\n-                        let ident = field_binding.ast().ident.as_ref().unwrap();\n-                        quote! {\n-                            #diag.set_arg(\n-                                stringify!(#ident),\n-                                #field_binding\n-                            );\n-                        }\n-                    } else {\n-                        quote! {}\n-                    };\n-                    // If this field had a subdiagnostic attribute, we generate the code here to\n-                    // avoid binding it twice.\n-                    if subdiagnostics.contains(&field_binding.binding) {\n-                        let result = field.attrs.iter().map(|attr| {\n-                            builder\n-                                .generate_field_attr_code(\n-                                    attr,\n-                                    FieldInfo {\n-                                        vis: &field.vis,\n-                                        binding: field_binding,\n-                                        ty: &field.ty,\n-                                        span: &field.span(),\n-                                    },\n-                                )\n-                                .unwrap_or_else(|v| v.to_compile_error())\n-                        });\n-\n-                        quote! { #(#result);* #tokens }\n-                    } else {\n-                        tokens\n-                    }\n-                });\n+                // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n+                // need to be passed as an argument to the diagnostic. But when a field has no\n+                // attributes or a `#[subdiagnostic]` attribute then it must be passed as an\n+                // argument to the diagnostic so that it can be referred to by Fluent messages.\n+                let args = structure\n+                    .filter(|field_binding| {\n+                        subdiagnostics_or_empty.contains(&field_binding.binding)\n+                    })\n+                    .each(|field_binding| {\n+                        let field = field_binding.ast();\n+                        let field_span = field.span();\n+\n+                        builder.generate_field_attrs_code(\n+                            &field.attrs,\n+                            FieldInfo {\n+                                vis: &field.vis,\n+                                binding: field_binding,\n+                                ty: &field.ty,\n+                                span: &field_span,\n+                            },\n+                        )\n+                    });\n \n                 let span = ast.span().unwrap();\n                 let (diag, sess) = (&builder.diag, &builder.sess);\n@@ -383,38 +364,59 @@ impl SessionDiagnosticDeriveBuilder {\n         Ok(tokens.drain(..).collect())\n     }\n \n-    fn generate_field_attr_code(\n-        &mut self,\n-        attr: &syn::Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+    fn generate_field_attrs_code<'a>(\n+        &'a mut self,\n+        attrs: &'a [syn::Attribute],\n+        info: FieldInfo<'a>,\n+    ) -> TokenStream {\n         let field_binding = &info.binding.binding;\n \n         let inner_ty = FieldInnerTy::from_type(&info.ty);\n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n-        let (binding, needs_destructure) = match (name.as_str(), &inner_ty) {\n-            // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n-            (\"primary_span\", FieldInnerTy::Vec(_)) => (quote! { #field_binding.clone() }, false),\n-            // `subdiagnostics` are not derefed because they are bound by value.\n-            (\"subdiagnostic\", _) => (quote! { #field_binding }, true),\n-            _ => (quote! { *#field_binding }, true),\n-        };\n-\n-        let generated_code = self.generate_inner_field_code(\n-            attr,\n-            FieldInfo {\n-                vis: info.vis,\n-                binding: info.binding,\n-                ty: inner_ty.inner_type().unwrap_or(&info.ty),\n-                span: info.span,\n-            },\n-            binding,\n-        )?;\n \n-        if needs_destructure {\n-            Ok(inner_ty.with(field_binding, generated_code))\n+        if attrs.is_empty() {\n+            let diag = &self.diag;\n+            let ident = info.binding.ast().ident.as_ref().unwrap();\n+            quote! {\n+                #diag.set_arg(\n+                    stringify!(#ident),\n+                    #field_binding\n+                );\n+            }\n         } else {\n-            Ok(generated_code)\n+            attrs\n+                .iter()\n+                .map(move |attr| {\n+                    let name = attr.path.segments.last().unwrap().ident.to_string();\n+                    let (binding, needs_destructure) = match (name.as_str(), &inner_ty) {\n+                        // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n+                        (\"primary_span\", FieldInnerTy::Vec(_)) => {\n+                            (quote! { #field_binding.clone() }, false)\n+                        }\n+                        // `subdiagnostics` are not derefed because they are bound by value.\n+                        (\"subdiagnostic\", _) => (quote! { #field_binding }, true),\n+                        _ => (quote! { *#field_binding }, true),\n+                    };\n+\n+                    let generated_code = self\n+                        .generate_inner_field_code(\n+                            attr,\n+                            FieldInfo {\n+                                vis: info.vis,\n+                                binding: info.binding,\n+                                ty: inner_ty.inner_type().unwrap_or(&info.ty),\n+                                span: info.span,\n+                            },\n+                            binding,\n+                        )\n+                        .unwrap_or_else(|v| v.to_compile_error());\n+\n+                    if needs_destructure {\n+                        inner_ty.with(field_binding, generated_code)\n+                    } else {\n+                        generated_code\n+                    }\n+                })\n+                .collect()\n         }\n     }\n "}]}