{"sha": "5e8897b7b51636f157630e6639b711d698e1d101", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlODg5N2I3YjUxNjM2ZjE1NzYzMGU2NjM5YjcxMWQ2OThlMWQxMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-21T18:55:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-21T18:55:26Z"}, "message": "Auto merge of #68423 - Centril:rollup-bdjykrv, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #67686 (Simplify NodeHeader by avoiding slices in BTreeMaps with shared roots)\n - #68140 (Implement `?const` opt-out for trait bounds)\n - #68313 (Options IP_MULTICAST_TTL and IP_MULTICAST_LOOP are 1 byte on BSD)\n - #68328 (Actually pass target LLVM args to LLVM)\n - #68399 (check_match: misc unifications and ICE fixes)\n - #68415 (tidy: fix most clippy warnings)\n - #68416 (lowering: cleanup some hofs)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "84d3e859322ab66693b9de43bf397856866e372c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84d3e859322ab66693b9de43bf397856866e372c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e8897b7b51636f157630e6639b711d698e1d101", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8897b7b51636f157630e6639b711d698e1d101", "html_url": "https://github.com/rust-lang/rust/commit/5e8897b7b51636f157630e6639b711d698e1d101", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e8897b7b51636f157630e6639b711d698e1d101/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cf24ab89123532f0e84995301ee734a88bf4701", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cf24ab89123532f0e84995301ee734a88bf4701", "html_url": "https://github.com/rust-lang/rust/commit/2cf24ab89123532f0e84995301ee734a88bf4701"}, {"sha": "c1b20b1ae3a6fd3f95f462ac452c8574f19702d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1b20b1ae3a6fd3f95f462ac452c8574f19702d6", "html_url": "https://github.com/rust-lang/rust/commit/c1b20b1ae3a6fd3f95f462ac452c8574f19702d6"}], "stats": {"total": 1344, "additions": 780, "deletions": 564}, "files": [{"sha": "cbb40f4e2a25e2230f921477fec031b4af84aa24", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -3763,6 +3763,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\","}, {"sha": "e70f881bc3d7e4b9c7efb2b15872aebe0b12c2d0", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1968,7 +1968,7 @@ where\n                 (i, false) => i,\n             },\n             (_, Unbounded) => 0,\n-            (true, Included(_)) => min_node.keys().len(),\n+            (true, Included(_)) => min_node.len(),\n             (true, Excluded(_)) => 0,\n         };\n \n@@ -1987,9 +1987,9 @@ where\n                 }\n                 (i, false) => i,\n             },\n-            (_, Unbounded) => max_node.keys().len(),\n+            (_, Unbounded) => max_node.len(),\n             (true, Included(_)) => 0,\n-            (true, Excluded(_)) => max_node.keys().len(),\n+            (true, Excluded(_)) => max_node.len(),\n         };\n \n         if !diverged {"}, {"sha": "d9cdebb4f73542495f1cac6c69ad6a72fc4090bf", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 11, "deletions": 54, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -54,10 +54,8 @@ pub const CAPACITY: usize = 2 * B - 1;\n /// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n /// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n /// by `as_header`.)\n-/// See `into_key_slice` for an explanation of K2. K2 cannot be safely transmuted around\n-/// because the size of `NodeHeader` depends on its alignment!\n #[repr(C)]\n-struct NodeHeader<K, V, K2 = ()> {\n+struct NodeHeader<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n     /// This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n@@ -72,9 +70,6 @@ struct NodeHeader<K, V, K2 = ()> {\n     /// This next to `parent_idx` to encourage the compiler to join `len` and\n     /// `parent_idx` into the same 32-bit word, reducing space overhead.\n     len: u16,\n-\n-    /// See `into_key_slice`.\n-    keys_start: [K2; 0],\n }\n #[repr(C)]\n struct LeafNode<K, V> {\n@@ -128,7 +123,7 @@ unsafe impl Sync for NodeHeader<(), ()> {}\n // We use just a header in order to save space, since no operation on an empty tree will\n // ever take a pointer past the first key.\n static EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n-    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0, keys_start: [] };\n+    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0 };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n@@ -390,14 +385,13 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// Works on all possible nodes, including the shared root.\n-    pub fn keys(&self) -> &[K] {\n+    /// The caller must ensure that the node is not the shared root.\n+    pub unsafe fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n     /// Borrows a view into the values stored in the node.\n     /// The caller must ensure that the node is not the shared root.\n-    /// This function is not public, so doesn't have to support shared roots like `keys` does.\n     fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n@@ -515,7 +509,6 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n \n     /// The caller must ensure that the node is not the shared root.\n-    /// This function is not public, so doesn't have to support shared roots like `keys` does.\n     fn keys_mut(&mut self) -> &mut [K] {\n         unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n@@ -527,48 +520,11 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    fn into_key_slice(self) -> &'a [K] {\n-        // We have to be careful here because we might be pointing to the shared root.\n-        // In that case, we must not create an `&LeafNode`.  We could just return\n-        // an empty slice whenever the length is 0 (this includes the shared root),\n-        // but we want to avoid that run-time check.\n-        // Instead, we create a slice pointing into the node whenever possible.\n-        // We can sometimes do this even for the shared root, as the slice will be\n-        // empty and `NodeHeader` contains an empty `keys_start` array.\n-        // We cannot *always* do this because:\n-        // - `keys_start` is not correctly typed because we want `NodeHeader`'s size to\n-        //   not depend on the alignment of `K` (needed because `as_header` should be safe).\n-        //   For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n-        //   and hence just adds a size-0-align-1 field, not affecting layout).\n-        //   If the correctly typed header is more highly aligned than the allocated header,\n-        //   we cannot transmute safely.\n-        // - Even if we can transmute, the offset of a correctly typed `keys_start` might\n-        //   be different and outside the bounds of the allocated header!\n-        // So we do an alignment check and a size check first, that will be evaluated\n-        // at compile-time, and only do any run-time check in the rare case that\n-        // the compile-time checks signal danger.\n-        if (mem::align_of::<NodeHeader<K, V, K>>() > mem::align_of::<NodeHeader<K, V>>()\n-            || mem::size_of::<NodeHeader<K, V, K>>() != mem::size_of::<NodeHeader<K, V>>())\n-            && self.is_shared_root()\n-        {\n-            &[]\n-        } else {\n-            // If we are a `LeafNode<K, V>`, we can always transmute to\n-            // `NodeHeader<K, V, K>` and `keys_start` always has the same offset\n-            // as the actual `keys`.\n-            // Thanks to the checks above, we know that we can transmute to\n-            // `NodeHeader<K, V, K>` and that `keys_start` will be\n-            // in-bounds of some allocation even if this is the shared root!\n-            // (We might be one-past-the-end, but that is allowed by LLVM.)\n-            // Thus we can use `NodeHeader<K, V, K>`\n-            // to compute the pointer where the keys start.\n-            // This entire hack will become unnecessary once\n-            // <https://github.com/rust-lang/rfcs/pull/2582> lands, then we can just take a raw\n-            // pointer to the `keys` field of `*const InternalNode<K, V>`.\n-            let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n-            let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n-            unsafe { slice::from_raw_parts(keys, self.len()) }\n-        }\n+    /// The caller must ensure that the node is not the shared root.\n+    unsafe fn into_key_slice(self) -> &'a [K] {\n+        debug_assert!(!self.is_shared_root());\n+        // We cannot be the shared root, so `as_leaf` is okay.\n+        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n     }\n \n     /// The caller must ensure that the node is not the shared root.\n@@ -578,9 +534,10 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_slices(self) -> (&'a [K], &'a [V]) {\n         let k = unsafe { ptr::read(&self) };\n-        (k.into_key_slice(), self.into_val_slice())\n+        (unsafe { k.into_key_slice() }, self.into_val_slice())\n     }\n }\n "}, {"sha": "579624cdd2b6a8d2ab47d6ce41a3adc43be8325e", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -61,16 +61,18 @@ where\n {\n     // This function is defined over all borrow types (immutable, mutable, owned),\n     // and may be called on the shared root in each case.\n-    // Crucially, we use `keys()` here, i.e., we work with immutable data.\n-    // `keys_mut()` does not support the shared root, so we cannot use it.\n     // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n     // is an index -- not a reference.\n-    for (i, k) in node.keys().iter().enumerate() {\n-        match key.cmp(k.borrow()) {\n-            Ordering::Greater => {}\n-            Ordering::Equal => return (i, true),\n-            Ordering::Less => return (i, false),\n+    let len = node.len();\n+    if len > 0 {\n+        let keys = unsafe { node.keys() }; // safe because a non-empty node cannot be the shared root\n+        for (i, k) in keys.iter().enumerate() {\n+            match key.cmp(k.borrow()) {\n+                Ordering::Greater => {}\n+                Ordering::Equal => return (i, true),\n+                Ordering::Less => return (i, false),\n+            }\n         }\n     }\n-    (node.keys().len(), false)\n+    (len, false)\n }"}, {"sha": "c97c5c2077f85f4f30d5fcea41b51f76a5013fdb", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -337,7 +337,10 @@ impl AutoTraitFinder<'tcx> {\n                 &Err(SelectionError::Unimplemented) => {\n                     if self.is_param_no_infer(pred.skip_binder().trait_ref.substs) {\n                         already_visited.remove(&pred);\n-                        self.add_user_pred(&mut user_computed_preds, ty::Predicate::Trait(pred));\n+                        self.add_user_pred(\n+                            &mut user_computed_preds,\n+                            ty::Predicate::Trait(pred, ast::Constness::NotConst),\n+                        );\n                         predicates.push_back(pred);\n                     } else {\n                         debug!(\n@@ -405,7 +408,7 @@ impl AutoTraitFinder<'tcx> {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n             match (&new_pred, old_pred) {\n-                (&ty::Predicate::Trait(new_trait), ty::Predicate::Trait(old_trait)) => {\n+                (&ty::Predicate::Trait(new_trait, _), ty::Predicate::Trait(old_trait, _)) => {\n                     if new_trait.def_id() == old_trait.def_id() {\n                         let new_substs = new_trait.skip_binder().trait_ref.substs;\n                         let old_substs = old_trait.skip_binder().trait_ref.substs;\n@@ -627,7 +630,7 @@ impl AutoTraitFinder<'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n             match &predicate {\n-                &ty::Predicate::Trait(p) => {\n+                &ty::Predicate::Trait(p, _) => {\n                     if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred"}, {"sha": "84bfc86e6a94ecc887580a428c50423d5e15a18b", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n-use crate::ty::{self, ToPredicate, Ty, TyCtxt};\n+use crate::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_hir::def_id::DefId;\n \n use super::{ChalkFulfillmentContext, FulfillmentContext, FulfillmentError};\n@@ -33,7 +33,7 @@ pub trait TraitEngine<'tcx>: 'tcx {\n                 cause,\n                 recursion_depth: 0,\n                 param_env,\n-                predicate: trait_ref.to_predicate(),\n+                predicate: trait_ref.without_const().to_predicate(),\n             },\n         );\n     }"}, {"sha": "d1c369d0abbf313f40cf255682588cd8e1b63af5", "filename": "src/librustc/traits/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -19,7 +19,9 @@ use crate::ty::error::ExpectedFound;\n use crate::ty::fast_reject;\n use crate::ty::fold::TypeFolder;\n use crate::ty::SubtypePredicate;\n-use crate::ty::{self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{\n+    self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n@@ -128,15 +130,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         let (cond, error) = match (cond, error) {\n-            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error)) => (cond, error),\n+            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error, _)) => (cond, error),\n             _ => {\n                 // FIXME: make this work in other cases too.\n                 return false;\n             }\n         };\n \n         for implication in super::elaborate_predicates(self.tcx, vec![cond.clone()]) {\n-            if let ty::Predicate::Trait(implication) = implication {\n+            if let ty::Predicate::Trait(implication, _) = implication {\n                 let error = error.to_poly_trait_ref();\n                 let implication = implication.to_poly_trait_ref();\n                 // FIXME: I'm just not taking associated types at all here.\n@@ -528,7 +530,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n                 match obligation.predicate {\n-                    ty::Predicate::Trait(ref trait_predicate) => {\n+                    ty::Predicate::Trait(ref trait_predicate, _) => {\n                         let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n@@ -581,7 +583,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             \"{}\",\n                             message.unwrap_or_else(|| format!(\n                                 \"the trait bound `{}` is not satisfied{}\",\n-                                trait_ref.to_predicate(),\n+                                trait_ref.without_const().to_predicate(),\n                                 post_message,\n                             ))\n                         );\n@@ -693,7 +695,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 trait_pred\n                             });\n                             let unit_obligation = Obligation {\n-                                predicate: ty::Predicate::Trait(predicate),\n+                                predicate: ty::Predicate::Trait(\n+                                    predicate,\n+                                    ast::Constness::NotConst,\n+                                ),\n                                 ..obligation.clone()\n                             };\n                             if self.predicate_may_hold(&unit_obligation) {\n@@ -986,7 +991,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> PredicateObligation<'tcx> {\n         let new_trait_ref =\n             ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n-        Obligation::new(cause, param_env, new_trait_ref.to_predicate())\n+        Obligation::new(cause, param_env, new_trait_ref.without_const().to_predicate())\n     }\n }\n \n@@ -1074,7 +1079,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         let mut err = match predicate {\n-            ty::Predicate::Trait(ref data) => {\n+            ty::Predicate::Trait(ref data, _) => {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n                 debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n@@ -1267,8 +1272,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             )\n             .value;\n \n-            let obligation =\n-                Obligation::new(ObligationCause::dummy(), param_env, cleaned_pred.to_predicate());\n+            let obligation = Obligation::new(\n+                ObligationCause::dummy(),\n+                param_env,\n+                cleaned_pred.without_const().to_predicate(),\n+            );\n \n             self.predicate_may_hold(&obligation)\n         })"}, {"sha": "4559007ea426aa879d59bc4f37c49e0540c06cab", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -6,7 +6,7 @@ use super::{\n use crate::infer::InferCtxt;\n use crate::traits::object_safety::object_safety_violations;\n use crate::ty::TypeckTables;\n-use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n \n use rustc_errors::{\n     error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             } else {\n                                 \" where\"\n                             },\n-                            trait_ref.to_predicate(),\n+                            trait_ref.without_const().to_predicate(),\n                         ),\n                         Applicability::MachineApplicable,\n                     );\n@@ -338,8 +338,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let new_self_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, self_ty);\n             let substs = self.tcx.mk_substs_trait(new_self_ty, &[]);\n             let new_trait_ref = ty::TraitRef::new(obligation.parent_trait_ref.def_id(), substs);\n-            let new_obligation =\n-                Obligation::new(ObligationCause::dummy(), param_env, new_trait_ref.to_predicate());\n+            let new_obligation = Obligation::new(\n+                ObligationCause::dummy(),\n+                param_env,\n+                new_trait_ref.without_const().to_predicate(),\n+            );\n             if self.predicate_must_hold_modulo_regions(&new_obligation) {\n                 if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                     // We have a very specific type of error, where just borrowing this argument\n@@ -1120,7 +1123,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // the type. The last generator has information about where the bound was introduced. At\n         // least one generator should be present for this diagnostic to be modified.\n         let (mut trait_ref, mut target_ty) = match obligation.predicate {\n-            ty::Predicate::Trait(p) => {\n+            ty::Predicate::Trait(p, _) => {\n                 (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n             }\n             _ => (None, None),\n@@ -1543,7 +1546,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.note(&format!(\"required because it appears within the type `{}`\", ty));\n                 obligated_types.push(ty);\n \n-                let parent_predicate = parent_trait_ref.to_predicate();\n+                let parent_predicate = parent_trait_ref.without_const().to_predicate();\n                 if !self.is_recursive_obligation(obligated_types, &data.parent_code) {\n                     self.note_obligation_cause_code(\n                         err,\n@@ -1560,7 +1563,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     parent_trait_ref.print_only_trait_path(),\n                     parent_trait_ref.skip_binder().self_ty()\n                 ));\n-                let parent_predicate = parent_trait_ref.to_predicate();\n+                let parent_predicate = parent_trait_ref.without_const().to_predicate();\n                 self.note_obligation_cause_code(\n                     err,\n                     &parent_predicate,"}, {"sha": "0aac6fb81e4a3436abc5214ed47a72bb87ce84b9", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         }\n \n         match obligation.predicate {\n-            ty::Predicate::Trait(ref data) => {\n+            ty::Predicate::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(data.clone());\n \n                 if data.is_global() {"}, {"sha": "daaba95cf6b1356daa76e1b7bbf9ba3832d95e99", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -29,7 +29,7 @@ use crate::mir::interpret::ErrorHandled;\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{InternalSubsts, SubstsRef};\n-use crate::ty::{self, AdtKind, GenericParamDefKind, List, ToPredicate, Ty, TyCtxt};\n+use crate::ty::{self, AdtKind, GenericParamDefKind, List, ToPredicate, Ty, TyCtxt, WithConstness};\n use crate::util::common::ErrorReported;\n use chalk_engine;\n use rustc_hir as hir;\n@@ -732,7 +732,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         param_env,\n         cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n         recursion_depth: 0,\n-        predicate: trait_ref.to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(),\n     };\n \n     let result = infcx.predicate_must_hold_modulo_regions(&obligation);"}, {"sha": "15f81bb3f47ed5e3e33d707d82e42a9d47291306", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -12,7 +12,7 @@ use super::elaborate_predicates;\n \n use crate::traits::{self, Obligation, ObligationCause};\n use crate::ty::subst::{InternalSubsts, Subst};\n-use crate::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n@@ -234,7 +234,7 @@ fn predicates_reference_self(tcx: TyCtxt<'_>, trait_def_id: DefId, supertraits_o\n         .map(|(predicate, _)| predicate.subst_supertrait(tcx, &trait_ref))\n         .any(|predicate| {\n             match predicate {\n-                ty::Predicate::Trait(ref data) => {\n+                ty::Predicate::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n                     data.skip_binder().input_types().skip(1).any(has_self_ty)\n                 }\n@@ -285,7 +285,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n     elaborate_predicates(tcx, predicates).any(|predicate| match predicate {\n-        ty::Predicate::Trait(ref trait_pred) => {\n+        ty::Predicate::Trait(ref trait_pred, _) => {\n             trait_pred.def_id() == sized_def_id && trait_pred.skip_binder().self_ty().is_param(0)\n         }\n         ty::Predicate::Projection(..)\n@@ -585,6 +585,7 @@ fn receiver_is_dispatchable<'tcx>(\n             def_id: unsize_did,\n             substs: tcx.mk_substs_trait(tcx.types.self_param, &[unsized_self_ty.into()]),\n         }\n+        .without_const()\n         .to_predicate();\n \n         // U: Trait<Arg1, ..., ArgN>\n@@ -598,7 +599,7 @@ fn receiver_is_dispatchable<'tcx>(\n                     }\n                 });\n \n-            ty::TraitRef { def_id: unsize_did, substs }.to_predicate()\n+            ty::TraitRef { def_id: unsize_did, substs }.without_const().to_predicate()\n         };\n \n         let caller_bounds: Vec<Predicate<'tcx>> = param_env\n@@ -620,6 +621,7 @@ fn receiver_is_dispatchable<'tcx>(\n             def_id: dispatch_from_dyn_did,\n             substs: tcx.mk_substs_trait(receiver_ty, &[unsized_receiver_ty.into()]),\n         }\n+        .without_const()\n         .to_predicate();\n \n         Obligation::new(ObligationCause::dummy(), param_env, predicate)"}, {"sha": "62672a78104805c08035e89672c71fcff48b0790", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -16,7 +16,7 @@ use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::{InternalSubsts, Subst};\n-use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt};\n+use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n@@ -738,7 +738,12 @@ fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n     depth: usize,\n ) -> PredicateObligation<'tcx> {\n     let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n-    Obligation { cause, recursion_depth: depth, param_env, predicate: trait_ref.to_predicate() }\n+    Obligation {\n+        cause,\n+        recursion_depth: depth,\n+        param_env,\n+        predicate: trait_ref.without_const().to_predicate(),\n+    }\n }\n \n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n@@ -772,7 +777,7 @@ fn normalize_to_error<'a, 'tcx>(\n         cause,\n         recursion_depth: depth,\n         param_env,\n-        predicate: trait_ref.to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(),\n     };\n     let tcx = selcx.infcx().tcx;\n     let def_id = projection_ty.item_def_id;"}, {"sha": "15870ec95d8d28b168a13d78a0b15ac2d3026ba0", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let Predicate::Trait(trait_ref) = key.value.predicate {\n+        if let Predicate::Trait(trait_ref, _) = key.value.predicate {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n                     if trait_ref.skip_binder().self_ty().is_trivially_sized(tcx) {"}, {"sha": "ac1ca4db9d6bbc300a01021dfb5e5d296aab27b4", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -37,7 +37,7 @@ use crate::middle::lang_items;\n use crate::ty::fast_reject;\n use crate::ty::relate::TypeRelation;\n use crate::ty::subst::{Subst, SubstsRef};\n-use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -51,7 +51,7 @@ use std::cmp;\n use std::fmt::{self, Display};\n use std::iter;\n use std::rc::Rc;\n-use syntax::attr;\n+use syntax::{ast, attr};\n \n pub struct SelectionContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n@@ -718,7 +718,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         match obligation.predicate {\n-            ty::Predicate::Trait(ref t) => {\n+            ty::Predicate::Trait(ref t, _) => {\n                 debug_assert!(!t.has_escaping_bound_vars());\n                 let obligation = obligation.with(t.clone());\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n@@ -945,7 +945,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // trait refs. This is important because it's only a cycle\n             // if the regions match exactly.\n             let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n-            let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n+            let cycle = cycle.map(|stack| {\n+                ty::Predicate::Trait(stack.obligation.predicate, ast::Constness::NotConst)\n+            });\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\", stack.fresh_trait_ref);\n                 Some(EvaluatedToOk)\n@@ -1060,7 +1062,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n         let result = match predicate {\n-            ty::Predicate::Trait(ref data) => self.tcx().trait_is_auto(data.def_id()),\n+            ty::Predicate::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n         debug!(\"coinductive_predicate({:?}) = {:?}\", predicate, result);\n@@ -3366,7 +3368,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                     tcx.mk_substs_trait(source, &[]),\n                 );\n-                nested.push(predicate_to_obligation(tr.to_predicate()));\n+                nested.push(predicate_to_obligation(tr.without_const().to_predicate()));\n \n                 // If the type is `Foo + 'a`, ensure that the type\n                 // being cast to `Foo + 'a` outlives `'a`:"}, {"sha": "f3bd98b855190a4b6334507621ba96b86751ba3a", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -4,7 +4,7 @@ use smallvec::SmallVec;\n \n use crate::ty::outlives::Component;\n use crate::ty::subst::{GenericArg, Subst, SubstsRef};\n-use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt};\n+use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -13,8 +13,8 @@ use super::{Normalized, Obligation, ObligationCause, PredicateObligation, Select\n \n fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n     match *pred {\n-        ty::Predicate::Trait(ref data) => {\n-            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data))\n+        ty::Predicate::Trait(ref data, constness) => {\n+            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n         }\n \n         ty::Predicate::RegionOutlives(ref data) => {\n@@ -99,14 +99,14 @@ pub fn elaborate_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> Elaborator<'tcx> {\n-    elaborate_predicates(tcx, vec![trait_ref.to_predicate()])\n+    elaborate_predicates(tcx, vec![trait_ref.without_const().to_predicate()])\n }\n \n pub fn elaborate_trait_refs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.to_predicate()).collect();\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate()).collect();\n     elaborate_predicates(tcx, predicates)\n }\n \n@@ -127,7 +127,7 @@ impl Elaborator<'tcx> {\n     fn elaborate(&mut self, predicate: &ty::Predicate<'tcx>) {\n         let tcx = self.visited.tcx;\n         match *predicate {\n-            ty::Predicate::Trait(ref data) => {\n+            ty::Predicate::Trait(ref data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n@@ -358,7 +358,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n     fn expand(&mut self, item: &TraitAliasExpansionInfo<'tcx>) -> bool {\n         let tcx = self.tcx;\n         let trait_ref = item.trait_ref();\n-        let pred = trait_ref.to_predicate();\n+        let pred = trait_ref.without_const().to_predicate();\n \n         debug!(\"expand_trait_aliases: trait_ref={:?}\", trait_ref);\n \n@@ -370,13 +370,9 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n \n         // Don't recurse if this trait alias is already on the stack for the DFS search.\n         let anon_pred = anonymize_predicate(tcx, &pred);\n-        if item\n-            .path\n-            .iter()\n-            .rev()\n-            .skip(1)\n-            .any(|(tr, _)| anonymize_predicate(tcx, &tr.to_predicate()) == anon_pred)\n-        {\n+        if item.path.iter().rev().skip(1).any(|(tr, _)| {\n+            anonymize_predicate(tcx, &tr.without_const().to_predicate()) == anon_pred\n+        }) {\n             return false;\n         }\n \n@@ -471,7 +467,7 @@ impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         while let Some(pred) = self.base_iterator.next() {\n-            if let ty::Predicate::Trait(data) = pred {\n+            if let ty::Predicate::Trait(data, _) = pred {\n                 return Some(data.to_poly_trait_ref());\n             }\n         }\n@@ -545,7 +541,12 @@ pub fn predicate_for_trait_ref<'tcx>(\n     trait_ref: ty::TraitRef<'tcx>,\n     recursion_depth: usize,\n ) -> PredicateObligation<'tcx> {\n-    Obligation { cause, param_env, recursion_depth, predicate: trait_ref.to_predicate() }\n+    Obligation {\n+        cause,\n+        param_env,\n+        recursion_depth,\n+        predicate: trait_ref.without_const().to_predicate(),\n+    }\n }\n \n pub fn predicate_for_trait_def("}, {"sha": "a0cb8446c921704c9c8b84d3015518eb29c09d4f", "filename": "src/librustc/traits/wf.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fwf.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -3,7 +3,7 @@ use crate::infer::InferCtxt;\n use crate::middle::lang_items;\n use crate::traits::{self, AssocTypeBoundData};\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::{kw, Ident};\n@@ -62,7 +62,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n \n     // (*) ok to skip binders, because wf code is prepared for it\n     match *predicate {\n-        ty::Predicate::Trait(ref t) => {\n+        ty::Predicate::Trait(ref t, _) => {\n             wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n         }\n         ty::Predicate::RegionOutlives(..) => {}\n@@ -245,7 +245,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    ty::Predicate::Trait(proj) => {\n+                    ty::Predicate::Trait(proj, _) => {\n                         // An associated item obligation born out of the `trait` failed to be met.\n                         // Point at the `impl` that failed the obligation, the associated item that\n                         // needed to meet the obligation, and the definition of that associated item,\n@@ -350,7 +350,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         self.compute_trait_ref(&trait_ref, Elaborate::None);\n \n         if !data.has_escaping_bound_vars() {\n-            let predicate = trait_ref.to_predicate();\n+            let predicate = trait_ref.without_const().to_predicate();\n             let cause = self.cause(traits::ProjectionWf(data));\n             self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n@@ -378,7 +378,11 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                 substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n             };\n-            self.out.push(traits::Obligation::new(cause, self.param_env, trait_ref.to_predicate()));\n+            self.out.push(traits::Obligation::new(\n+                cause,\n+                self.param_env,\n+                trait_ref.without_const().to_predicate(),\n+            ));\n         }\n     }\n "}, {"sha": "0dddca98c62576842301b9dee6fec6720c9b08bd", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -150,6 +150,15 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     }\n }\n \n+impl TypeFoldable<'tcx> for syntax::ast::Constness {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n /// The `TypeFolder` trait defines the actual *folding*. There is a\n /// method defined for every foldable type. Each of these has a\n /// default implementation that does an \"identity\" fold. Within each"}, {"sha": "0470ab20dc4644b8f80d7e04559249eec574f322", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 59, "deletions": 10, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -52,7 +52,7 @@ use std::ops::Deref;\n use std::ops::Range;\n use std::slice;\n use std::{mem, ptr};\n-use syntax::ast::{self, Ident, Name, NodeId};\n+use syntax::ast::{self, Constness, Ident, Name, NodeId};\n use syntax::attr;\n \n pub use self::sty::BoundRegion::*;\n@@ -1068,7 +1068,11 @@ pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n-    Trait(PolyTraitPredicate<'tcx>),\n+    ///\n+    /// A trait predicate will have `Constness::Const` if it originates\n+    /// from a bound on a `const fn` without the `?const` opt-out (e.g.,\n+    /// `const fn foobar<Foo: Bar>() {}`).\n+    Trait(PolyTraitPredicate<'tcx>, Constness),\n \n     /// `where 'a: 'b`\n     RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n@@ -1191,8 +1195,8 @@ impl<'tcx> Predicate<'tcx> {\n \n         let substs = &trait_ref.skip_binder().substs;\n         match *self {\n-            Predicate::Trait(ref binder) => {\n-                Predicate::Trait(binder.map_bound(|data| data.subst(tcx, substs)))\n+            Predicate::Trait(ref binder, constness) => {\n+                Predicate::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n             }\n             Predicate::Subtype(ref binder) => {\n                 Predicate::Subtype(binder.map_bound(|data| data.subst(tcx, substs)))\n@@ -1336,15 +1340,33 @@ pub trait ToPredicate<'tcx> {\n     fn to_predicate(&self) -> Predicate<'tcx>;\n }\n \n-impl<'tcx> ToPredicate<'tcx> for TraitRef<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n+    fn to_predicate(&self) -> Predicate<'tcx> {\n+        ty::Predicate::Trait(\n+            ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value.clone() }),\n+            self.constness,\n+        )\n+    }\n+}\n+\n+impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n+    fn to_predicate(&self) -> Predicate<'tcx> {\n+        ty::Predicate::Trait(\n+            ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value.clone() }),\n+            self.constness,\n+        )\n+    }\n+}\n+\n+impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.clone() }))\n+        ty::Predicate::Trait(self.value.to_poly_trait_predicate(), self.constness)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for PolyTraitRef<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&PolyTraitRef<'tcx>> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(self.to_poly_trait_predicate())\n+        ty::Predicate::Trait(self.value.to_poly_trait_predicate(), self.constness)\n     }\n }\n \n@@ -1413,7 +1435,7 @@ impl<'tcx> Predicate<'tcx> {\n     /// with depth 0 are bound by the predicate.\n     pub fn walk_tys(&'a self) -> impl Iterator<Item = Ty<'tcx>> + 'a {\n         match *self {\n-            ty::Predicate::Trait(ref data) => {\n+            ty::Predicate::Trait(ref data, _) => {\n                 WalkTysIter::InputTypes(data.skip_binder().input_types())\n             }\n             ty::Predicate::Subtype(binder) => {\n@@ -1439,7 +1461,7 @@ impl<'tcx> Predicate<'tcx> {\n \n     pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n         match *self {\n-            Predicate::Trait(ref t) => Some(t.to_poly_trait_ref()),\n+            Predicate::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n             Predicate::Projection(..)\n             | Predicate::Subtype(..)\n             | Predicate::RegionOutlives(..)\n@@ -1700,6 +1722,33 @@ impl<'tcx> ParamEnv<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct ConstnessAnd<T> {\n+    pub constness: Constness,\n+    pub value: T,\n+}\n+\n+// FIXME(ecstaticmorse): Audit all occurrences of `without_const().to_predicate()` to ensure that\n+// the constness of trait bounds is being propagated correctly.\n+pub trait WithConstness: Sized {\n+    #[inline]\n+    fn with_constness(self, constness: Constness) -> ConstnessAnd<Self> {\n+        ConstnessAnd { constness, value: self }\n+    }\n+\n+    #[inline]\n+    fn with_const(self) -> ConstnessAnd<Self> {\n+        self.with_constness(Constness::Const)\n+    }\n+\n+    #[inline]\n+    fn without_const(self) -> ConstnessAnd<Self> {\n+        self.with_constness(Constness::NotConst)\n+    }\n+}\n+\n+impl<T> WithConstness for T {}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TypeFoldable)]\n pub struct ParamEnvAnd<'tcx, T> {\n     pub param_env: ParamEnv<'tcx>,"}, {"sha": "9091de55b7d8ea5f4762e9f3f25e3a239c7170c3", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1791,7 +1791,12 @@ define_print_and_forward_display! {\n \n     ty::Predicate<'tcx> {\n         match *self {\n-            ty::Predicate::Trait(ref data) => p!(print(data)),\n+            ty::Predicate::Trait(ref data, constness) => {\n+                if let ast::Constness::Const = constness {\n+                    p!(write(\"const \"));\n+                }\n+                p!(print(data))\n+            }\n             ty::Predicate::Subtype(ref predicate) => p!(print(predicate)),\n             ty::Predicate::RegionOutlives(ref predicate) => p!(print(predicate)),\n             ty::Predicate::TypeOutlives(ref predicate) => p!(print(predicate)),"}, {"sha": "25f9dc5b0c7bfec208097dbe1328f3a6257085bf", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -15,6 +15,7 @@ use smallvec::SmallVec;\n use std::fmt;\n use std::rc::Rc;\n use std::sync::Arc;\n+use syntax::ast;\n \n impl fmt::Debug for ty::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -234,7 +235,12 @@ impl fmt::Debug for ty::ProjectionPredicate<'tcx> {\n impl fmt::Debug for ty::Predicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::Predicate::Trait(ref a) => a.fmt(f),\n+            ty::Predicate::Trait(ref a, constness) => {\n+                if let ast::Constness::Const = constness {\n+                    write!(f, \"const \")?;\n+                }\n+                a.fmt(f)\n+            }\n             ty::Predicate::Subtype(ref pair) => pair.fmt(f),\n             ty::Predicate::RegionOutlives(ref pair) => pair.fmt(f),\n             ty::Predicate::TypeOutlives(ref pair) => pair.fmt(f),\n@@ -474,7 +480,9 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n     type Lifted = ty::Predicate<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::Predicate::Trait(ref binder) => tcx.lift(binder).map(ty::Predicate::Trait),\n+            ty::Predicate::Trait(ref binder, constness) => {\n+                tcx.lift(binder).map(|binder| ty::Predicate::Trait(binder, constness))\n+            }\n             ty::Predicate::Subtype(ref binder) => tcx.lift(binder).map(ty::Predicate::Subtype),\n             ty::Predicate::RegionOutlives(ref binder) => {\n                 tcx.lift(binder).map(ty::Predicate::RegionOutlives)"}, {"sha": "13f623aadb1a37fb3d2e08260db8637e98c33d50", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -12,7 +12,9 @@ use crate::mir::interpret::Scalar;\n use crate::mir::Promoted;\n use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n-use crate::ty::{self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable};\n+use crate::ty::{\n+    self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable, WithConstness,\n+};\n use crate::ty::{List, ParamEnv, ParamEnvAnd, TyS};\n use polonius_engine::Atom;\n use rustc_data_structures::captures::Captures;\n@@ -665,14 +667,16 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n         match *self.skip_binder() {\n-            ExistentialPredicate::Trait(tr) => Binder(tr).with_self_ty(tcx, self_ty).to_predicate(),\n+            ExistentialPredicate::Trait(tr) => {\n+                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate()\n+            }\n             ExistentialPredicate::Projection(p) => {\n                 ty::Predicate::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n                 let trait_ref =\n                     Binder(ty::TraitRef { def_id: did, substs: tcx.mk_substs_trait(self_ty, &[]) });\n-                trait_ref.to_predicate()\n+                trait_ref.without_const().to_predicate()\n             }\n         }\n     }"}, {"sha": "5dc855e935c0764c70ad8170a70b6391530bb86e", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -848,10 +848,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn with_catch_scope<T, F>(&mut self, catch_id: NodeId, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_catch_scope<T>(&mut self, catch_id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n         let len = self.catch_scopes.len();\n         self.catch_scopes.push(catch_id);\n \n@@ -867,10 +864,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         result\n     }\n \n-    fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_loop_scope<T>(&mut self, loop_id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n         // We're no longer in the base loop's condition; we're in another loop.\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n@@ -892,10 +886,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         result\n     }\n \n-    fn with_loop_condition_scope<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_loop_condition_scope<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = true;\n "}, {"sha": "2025d0c1c8e342140794fb4097b650b272952133", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -66,9 +66,8 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl { ref of_trait, .. } = item.kind {\n-                    if of_trait.as_ref().map(|tr| tr.constness.is_some()).unwrap_or(false) {\n-                        this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n+                if let ItemKind::Impl { constness, ref of_trait, .. } = item.kind {\n+                    if constness == Constness::Const {\n                         this.lctx\n                             .diagnostic()\n                             .span_err(item.span, \"const trait impls are not yet implemented\");\n@@ -365,6 +364,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 unsafety,\n                 polarity,\n                 defaultness,\n+                constness,\n                 generics: ref ast_generics,\n                 of_trait: ref trait_ref,\n                 self_ty: ref ty,\n@@ -421,6 +421,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     unsafety,\n                     polarity,\n                     defaultness: self.lower_defaultness(defaultness, true /* [1] */),\n+                    constness,\n                     generics,\n                     of_trait: trait_ref,\n                     self_ty: lowered_ty,"}, {"sha": "284ede3b4fa1a119d92a81f3794da7c370aa7f2a", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1249,10 +1249,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     let bounds =\n                         this.arena.alloc_from_iter(bounds.iter().filter_map(\n                             |bound| match *bound {\n-                                GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n+                                GenericBound::Trait(ref ty, TraitBoundModifier::None)\n+                                | GenericBound::Trait(ref ty, TraitBoundModifier::MaybeConst) => {\n                                     Some(this.lower_poly_trait_ref(ty, itctx.reborrow()))\n                                 }\n-                                GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                                // `?const ?Bound` will cause an error during AST validation\n+                                // anyways, so treat it like `?Bound` as compilation proceeds.\n+                                GenericBound::Trait(_, TraitBoundModifier::Maybe)\n+                                | GenericBound::Trait(_, TraitBoundModifier::MaybeConstMaybe) => {\n+                                    None\n+                                }\n                                 GenericBound::Outlives(ref lifetime) => {\n                                     if lifetime_bound.is_none() {\n                                         lifetime_bound = Some(this.lower_lifetime(lifetime));\n@@ -2157,10 +2163,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &PolyTraitRef,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::PolyTraitRef<'hir> {\n-        if p.trait_ref.constness.is_some() {\n-            self.diagnostic().span_err(p.span, \"`?const` on trait bounds is not yet implemented\");\n-        }\n-\n         let bound_generic_params = self.lower_generic_params(\n             &p.bound_generic_params,\n             &NodeMap::default(),\n@@ -2299,7 +2301,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_trait_bound_modifier(&mut self, f: TraitBoundModifier) -> hir::TraitBoundModifier {\n         match f {\n             TraitBoundModifier::None => hir::TraitBoundModifier::None,\n-            TraitBoundModifier::Maybe => hir::TraitBoundModifier::Maybe,\n+            TraitBoundModifier::MaybeConst => hir::TraitBoundModifier::MaybeConst,\n+\n+            // `MaybeConstMaybe` will cause an error during AST validation, but we need to pick a\n+            // placeholder for compilation to proceed.\n+            TraitBoundModifier::MaybeConstMaybe | TraitBoundModifier::Maybe => {\n+                hir::TraitBoundModifier::Maybe\n+            }\n         }\n     }\n "}, {"sha": "152086bfce0eafcf9d964d5eff0d5095b3b5b10f", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -614,6 +614,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 unsafety,\n                 polarity,\n                 defaultness: _,\n+                constness: _,\n                 generics: _,\n                 of_trait: Some(_),\n                 ref self_ty,\n@@ -647,6 +648,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 unsafety,\n                 polarity,\n                 defaultness,\n+                constness,\n                 generics: _,\n                 of_trait: None,\n                 self_ty: _,\n@@ -674,6 +676,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         .note(\"only trait implementations may be annotated with default\")\n                         .emit();\n                 }\n+                if constness == Constness::Const {\n+                    self.err_handler()\n+                        .struct_span_err(item.span, \"inherent impls cannot be `const`\")\n+                        .note(\"only trait implementations may be annotated with `const`\")\n+                        .emit();\n+                }\n             }\n             ItemKind::Fn(ref sig, ref generics, _) => {\n                 self.visit_fn_header(&sig.header);\n@@ -907,23 +915,20 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_param_bound(&mut self, bound: &'a GenericBound) {\n-        if let GenericBound::Trait(poly, maybe_bound) = bound {\n-            match poly.trait_ref.constness {\n-                Some(Constness::NotConst) => {\n-                    if *maybe_bound == TraitBoundModifier::Maybe {\n-                        self.err_handler()\n-                            .span_err(bound.span(), \"`?const` and `?` are mutually exclusive\");\n-                    }\n-\n-                    if let Some(ctx) = self.bound_context {\n-                        let msg = format!(\"`?const` is not permitted in {}\", ctx.description());\n-                        self.err_handler().span_err(bound.span(), &msg);\n-                    }\n+        match bound {\n+            GenericBound::Trait(_, TraitBoundModifier::MaybeConst) => {\n+                if let Some(ctx) = self.bound_context {\n+                    let msg = format!(\"`?const` is not permitted in {}\", ctx.description());\n+                    self.err_handler().span_err(bound.span(), &msg);\n                 }\n+            }\n \n-                Some(Constness::Const) => panic!(\"Parser should reject bare `const` on bounds\"),\n-                None => {}\n+            GenericBound::Trait(_, TraitBoundModifier::MaybeConstMaybe) => {\n+                self.err_handler()\n+                    .span_err(bound.span(), \"`?const` and `?` are mutually exclusive\");\n             }\n+\n+            _ => {}\n         }\n \n         visit::walk_param_bound(self, bound)"}, {"sha": "f8918016c1b9835a803d2b8afa734f3f0b24d586", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -709,6 +709,7 @@ impl<'a> TraitDef<'a> {\n                 unsafety,\n                 polarity: ast::ImplPolarity::Positive,\n                 defaultness: ast::Defaultness::Final,\n+                constness: ast::Constness::NotConst,\n                 generics: trait_generics,\n                 of_trait: opt_trait_ref,\n                 self_ty: self_type,"}, {"sha": "914dcdf196921dc7088e44fd33fffda06903bd8c", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -160,6 +160,7 @@ fn inject_impl_of_structural_trait(\n             unsafety: ast::Unsafety::Normal,\n             polarity: ast::ImplPolarity::Positive,\n             defaultness: ast::Defaultness::Final,\n+            constness: ast::Constness::NotConst,\n             generics,\n             of_trait: Some(trait_ref),\n             self_ty: self_type,"}, {"sha": "4823fe10c463fee932a7b86b3a1acd4b1497f935", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -58,9 +58,10 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     let cg_opts = sess.opts.cg.llvm_args.iter();\n     let tg_opts = sess.target.target.options.llvm_args.iter();\n+    let sess_args = cg_opts.chain(tg_opts);\n \n     let user_specified_args: FxHashSet<_> =\n-        cg_opts.chain(tg_opts).map(|s| llvm_arg_to_arg_name(s)).filter(|s| s.len() > 0).collect();\n+        sess_args.clone().map(|s| llvm_arg_to_arg_name(s)).filter(|s| s.len() > 0).collect();\n \n     {\n         // This adds the given argument to LLVM. Unless `force` is true\n@@ -107,7 +108,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         // during inlining. Unfortunately these may block other optimizations.\n         add(\"-preserve-alignment-assumptions-during-inlining=false\", false);\n \n-        for arg in &sess.opts.cg.llvm_args {\n+        for arg in sess_args {\n             add(&(*arg), true);\n         }\n     }"}, {"sha": "11f94ab2e627980b0445e92a50967bc442e46b68", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -110,7 +110,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn trait_ref(&self, path: ast::Path) -> ast::TraitRef {\n-        ast::TraitRef { path, constness: None, ref_id: ast::DUMMY_NODE_ID }\n+        ast::TraitRef { path, ref_id: ast::DUMMY_NODE_ID }\n     }\n \n     pub fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef {"}, {"sha": "b62a7e413e3031b30b58ccd8aa04065fdfac7373", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -364,6 +364,7 @@ impl GenericArgs<'_> {\n pub enum TraitBoundModifier {\n     None,\n     Maybe,\n+    MaybeConst,\n }\n \n /// The AST represents all type param bounds as types.\n@@ -2440,6 +2441,7 @@ pub enum ItemKind<'hir> {\n         unsafety: Unsafety,\n         polarity: ImplPolarity,\n         defaultness: Defaultness,\n+        constness: Constness,\n         generics: Generics<'hir>,\n \n         /// The trait being implemented, if any."}, {"sha": "539a0eee0e31222087da244f2bd703e772fa0f98", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -570,6 +570,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             unsafety: _,\n             defaultness: _,\n             polarity: _,\n+            constness: _,\n             ref generics,\n             ref of_trait,\n             ref self_ty,"}, {"sha": "b9598c93761466723ec18975943157ecbdebb237", "filename": "src/librustc_hir/print.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -631,6 +631,7 @@ impl<'a> State<'a> {\n                 unsafety,\n                 polarity,\n                 defaultness,\n+                constness,\n                 ref generics,\n                 ref of_trait,\n                 ref self_ty,\n@@ -647,6 +648,10 @@ impl<'a> State<'a> {\n                     self.s.space();\n                 }\n \n+                if constness == ast::Constness::Const {\n+                    self.word_nbsp(\"const\");\n+                }\n+\n                 if let hir::ImplPolarity::Negative = polarity {\n                     self.s.word(\"!\");\n                 }"}, {"sha": "15158c09af0743274d5c4b3b7e089fb981676c73", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n                     for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n-                        if let ty::Predicate::Trait(ref poly_trait_predicate) = predicate {\n+                        if let ty::Predicate::Trait(ref poly_trait_predicate, _) = predicate {\n                             let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n                             let def_id = trait_ref.def_id;\n                             let descr_pre ="}, {"sha": "c9a1c465165d71c1839f1684ad5ca90a1acded4e", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -32,6 +32,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::{Span, DUMMY_SP};\n+use syntax::ast;\n \n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n@@ -1930,12 +1931,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,\n-                                    ty::Predicate::Trait(ty::Binder::bind(ty::TraitPredicate {\n-                                        trait_ref: ty::TraitRef::new(\n-                                            self.tcx().lang_items().copy_trait().unwrap(),\n-                                            tcx.mk_substs_trait(ty, &[]),\n-                                        ),\n-                                    })),\n+                                    ty::Predicate::Trait(\n+                                        ty::Binder::bind(ty::TraitPredicate {\n+                                            trait_ref: ty::TraitRef::new(\n+                                                self.tcx().lang_items().copy_trait().unwrap(),\n+                                                tcx.mk_substs_trait(ty, &[]),\n+                                            ),\n+                                        }),\n+                                        ast::Constness::NotConst,\n+                                    ),\n                                 ),\n                                 &traits::SelectionError::Unimplemented,\n                                 false,\n@@ -2573,7 +2577,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::Predicate::Trait(trait_ref.to_poly_trait_ref().to_poly_trait_predicate())),\n+            Some(ty::Predicate::Trait(\n+                trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n+                ast::Constness::NotConst,\n+            )),\n             locations,\n             category,\n         );"}, {"sha": "b047e534e4f1ce4a38838e8408b5bf6cc635af48", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::def_id::DefId;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use std::borrow::Cow;\n-use syntax::attr;\n+use syntax::{ast, attr};\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n@@ -27,12 +27,19 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                     bug!(\"closure kind predicate on function: {:#?}\", predicate)\n                 }\n                 Predicate::Subtype(_) => bug!(\"subtype predicate on function: {:#?}\", predicate),\n-                Predicate::Trait(pred) => {\n+                Predicate::Trait(pred, constness) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }\n                     match pred.skip_binder().self_ty().kind {\n                         ty::Param(ref p) => {\n+                            // Allow `T: ?const Trait`\n+                            if *constness == ast::Constness::NotConst\n+                                && feature_allowed(tcx, def_id, sym::const_trait_bound_opt_out)\n+                            {\n+                                continue;\n+                            }\n+\n                             let generics = tcx.generics_of(current);\n                             let def = generics.type_param(p, tcx);\n                             let span = tcx.def_span(def.def_id);"}, {"sha": "a22c4d18d516aac646078b180acebc953515e0df", "filename": "src/librustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2FCargo.toml?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -21,6 +21,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "20183fd55c871ccfd208cbef9af9ed6791421acb", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -582,15 +582,12 @@ crate struct MatchCheckCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n-    crate fn create_and_enter<F, R>(\n+    crate fn create_and_enter<R>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         module: DefId,\n-        f: F,\n-    ) -> R\n-    where\n-        F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R,\n-    {\n+        f: impl for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R,\n+    ) -> R {\n         let pattern_arena = TypedArena::default();\n \n         f(MatchCheckCtxt { tcx, param_env, module, pattern_arena: &pattern_arena })"}, {"sha": "49b7c2d41fcbb2978cf9e938e7cd63a115ffd25d", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 66, "deletions": 87, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -5,16 +5,17 @@ use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack}\n use super::{PatCtxt, PatKind, PatternError};\n \n use rustc::hir::map::Map;\n-use rustc::lint;\n-use rustc::session::parse::feature_err;\n-use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n+use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n+use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n+use rustc_session::parse::feature_err;\n+use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::{MultiSpan, Span};\n use syntax::ast::Mutability;\n@@ -67,18 +68,13 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n             hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n         };\n         self.check_irrefutable(&loc.pat, msg, sp);\n-\n-        // Check legality of move bindings and `@` patterns.\n         self.check_patterns(false, &loc.pat);\n     }\n \n-    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n-        intravisit::walk_body(self, body);\n-\n-        for param in body.params {\n-            self.check_irrefutable(&param.pat, \"function argument\", None);\n-            self.check_patterns(false, &param.pat);\n-        }\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        intravisit::walk_param(self, param);\n+        self.check_irrefutable(&param.pat, \"function argument\", None);\n+        self.check_patterns(false, &param.pat);\n     }\n }\n \n@@ -123,6 +119,25 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         if !self.tcx.features().bindings_after_at {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n         }\n+        check_for_bindings_named_same_as_variants(self, pat);\n+    }\n+\n+    fn lower_pattern<'p>(\n+        &self,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+        pat: &'tcx hir::Pat<'tcx>,\n+        have_errors: &mut bool,\n+    ) -> (&'p super::Pat<'tcx>, Ty<'tcx>) {\n+        let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.tables);\n+        patcx.include_lint_checks();\n+        let pattern = patcx.lower_pattern(pat);\n+        let pattern_ty = pattern.ty;\n+        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+        if !patcx.errors.is_empty() {\n+            *have_errors = true;\n+            patcx.report_inlining_errors(pat.span);\n+        }\n+        (pattern, pattern_ty)\n     }\n \n     fn check_match(\n@@ -132,11 +147,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         source: hir::MatchSource,\n     ) {\n         for arm in arms {\n-            // First, check legality of move bindings.\n+            // Check the arm for some things unrelated to exhaustiveness.\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n-\n-            // Second, perform some lints.\n-            check_for_bindings_named_same_as_variants(self, &arm.pat);\n         }\n \n         let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n@@ -145,16 +157,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n             let inlined_arms: Vec<_> = arms\n                 .iter()\n-                .map(|arm| {\n-                    let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.tables);\n-                    patcx.include_lint_checks();\n-                    let pattern = patcx.lower_pattern(&arm.pat);\n-                    let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n-                    if !patcx.errors.is_empty() {\n-                        patcx.report_inlining_errors(arm.pat.span);\n-                        have_errors = true;\n-                    }\n-                    (pattern, &*arm.pat, arm.guard.is_some())\n+                .map(|hir::Arm { pat, guard, .. }| {\n+                    (self.lower_pattern(cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n                 })\n                 .collect();\n \n@@ -178,11 +182,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n-            let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.tables);\n-            patcx.include_lint_checks();\n-            let pattern = patcx.lower_pattern(pat);\n-            let pattern_ty = pattern.ty;\n-            let pattern = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+            let (pattern, pattern_ty) = self.lower_pattern(cx, pat, &mut false);\n             let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n \n             let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n@@ -285,7 +285,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                         let ty_path = cx.tcx.def_path_str(edef.did);\n                         cx.tcx\n                             .struct_span_lint_hir(\n-                                lint::builtin::BINDINGS_WITH_VARIANT_NAME,\n+                                BINDINGS_WITH_VARIANT_NAME,\n                                 p.hir_id,\n                                 p.span,\n                                 &format!(\n@@ -310,79 +310,63 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(pat: &Pat<'_>) -> bool {\n-    match pat.kind {\n-        hir::PatKind::Binding(.., None) => true,\n-        hir::PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n-        hir::PatKind::Ref(ref s, _) => pat_is_catchall(s),\n-        hir::PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(&p)),\n+fn pat_is_catchall(pat: &super::Pat<'_>) -> bool {\n+    use super::PatKind::*;\n+    match &*pat.kind {\n+        Binding { subpattern: None, .. } => true,\n+        Binding { subpattern: Some(s), .. } | Deref { subpattern: s } => pat_is_catchall(s),\n+        Leaf { subpatterns: s } => s.iter().all(|p| pat_is_catchall(&p.pattern)),\n         _ => false,\n     }\n }\n \n+fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<Span>) {\n+    let mut err = tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, \"unreachable pattern\");\n+    if let Some(catchall) = catchall {\n+        // We had a catchall pattern, hint at that.\n+        err.span_label(span, \"unreachable pattern\");\n+        err.span_label(catchall, \"matches any value\");\n+    }\n+    err.emit();\n+}\n+\n+fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::MatchSource) {\n+    let msg = match source {\n+        hir::MatchSource::IfLetDesugar { .. } => \"irrefutable if-let pattern\",\n+        hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n+        _ => bug!(),\n+    };\n+    tcx.lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, msg);\n+}\n+\n /// Check for unreachable patterns.\n fn check_arms<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    arms: &[(&'p super::Pat<'tcx>, &hir::Pat<'_>, bool)],\n+    arms: &[(&'p super::Pat<'tcx>, HirId, bool)],\n     source: hir::MatchSource,\n ) -> Matrix<'p, 'tcx> {\n     let mut seen = Matrix::empty();\n     let mut catchall = None;\n-    for (arm_index, (pat, hir_pat, has_guard)) in arms.iter().enumerate() {\n+    for (arm_index, (pat, id, has_guard)) in arms.iter().copied().enumerate() {\n         let v = PatStack::from_pattern(pat);\n-\n-        match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id, true) {\n+        match is_useful(cx, &seen, &v, LeaveOutWitness, id, true) {\n             NotUseful => {\n                 match source {\n                     hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n \n                     hir::MatchSource::IfLetDesugar { .. } | hir::MatchSource::WhileLetDesugar => {\n-                        // check which arm we're on.\n+                        // Check which arm we're on.\n                         match arm_index {\n                             // The arm with the user-specified pattern.\n-                            0 => {\n-                                cx.tcx.lint_hir(\n-                                    lint::builtin::UNREACHABLE_PATTERNS,\n-                                    hir_pat.hir_id,\n-                                    pat.span,\n-                                    \"unreachable pattern\",\n-                                );\n-                            }\n+                            0 => unreachable_pattern(cx.tcx, pat.span, id, None),\n                             // The arm with the wildcard pattern.\n-                            1 => {\n-                                let msg = match source {\n-                                    hir::MatchSource::IfLetDesugar { .. } => {\n-                                        \"irrefutable if-let pattern\"\n-                                    }\n-                                    hir::MatchSource::WhileLetDesugar => {\n-                                        \"irrefutable while-let pattern\"\n-                                    }\n-                                    _ => bug!(),\n-                                };\n-                                cx.tcx.lint_hir(\n-                                    lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                    hir_pat.hir_id,\n-                                    pat.span,\n-                                    msg,\n-                                );\n-                            }\n+                            1 => irrefutable_let_pattern(cx.tcx, pat.span, id, source),\n                             _ => bug!(),\n                         }\n                     }\n \n                     hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                        let mut err = cx.tcx.struct_span_lint_hir(\n-                            lint::builtin::UNREACHABLE_PATTERNS,\n-                            hir_pat.hir_id,\n-                            pat.span,\n-                            \"unreachable pattern\",\n-                        );\n-                        // if we had a catchall pattern, hint at that\n-                        if let Some(catchall) = catchall {\n-                            err.span_label(pat.span, \"unreachable pattern\");\n-                            err.span_label(catchall, \"matches any value\");\n-                        }\n-                        err.emit();\n+                        unreachable_pattern(cx.tcx, pat.span, id, catchall);\n                     }\n \n                     // Unreachable patterns in try and await expressions occur when one of\n@@ -392,19 +376,14 @@ fn check_arms<'p, 'tcx>(\n             }\n             Useful(unreachable_subpatterns) => {\n                 for pat in unreachable_subpatterns {\n-                    cx.tcx.lint_hir(\n-                        lint::builtin::UNREACHABLE_PATTERNS,\n-                        hir_pat.hir_id,\n-                        pat.span,\n-                        \"unreachable pattern\",\n-                    );\n+                    unreachable_pattern(cx.tcx, pat.span, id, None);\n                 }\n             }\n             UsefulWithWitness(_) => bug!(),\n         }\n         if !has_guard {\n             seen.push(v);\n-            if catchall.is_none() && pat_is_catchall(hir_pat) {\n+            if catchall.is_none() && pat_is_catchall(pat) {\n                 catchall = Some(pat.span);\n             }\n         }"}, {"sha": "31db7fc5f759d086c2abafe01cfc5564d2b65297", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -4,7 +4,7 @@ use super::{FollowedByType, Parser, PathStyle};\n use crate::maybe_whole;\n \n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult, StashKey};\n-use rustc_span::source_map::{self, respan, Span, Spanned};\n+use rustc_span::source_map::{self, respan, Span};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::BytePos;\n use syntax::ast::{self, AttrKind, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n@@ -565,9 +565,9 @@ impl<'a> Parser<'a> {\n         let constness = if self.eat_keyword(kw::Const) {\n             let span = self.prev_span;\n             self.sess.gated_spans.gate(sym::const_trait_impl, span);\n-            Some(respan(span, Constness::Const))\n+            Constness::Const\n         } else {\n-            None\n+            Constness::NotConst\n         };\n \n         // Disambiguate `impl !Trait for Type { ... }` and `impl ! { ... }` for the never type.\n@@ -630,32 +630,26 @@ impl<'a> Parser<'a> {\n                         err_path(ty_first.span)\n                     }\n                 };\n-                let constness = constness.map(|c| c.node);\n-                let trait_ref = TraitRef { path, constness, ref_id: ty_first.id };\n+                let trait_ref = TraitRef { path, ref_id: ty_first.id };\n \n                 ItemKind::Impl {\n                     unsafety,\n                     polarity,\n                     defaultness,\n+                    constness,\n                     generics,\n                     of_trait: Some(trait_ref),\n                     self_ty: ty_second,\n                     items: impl_items,\n                 }\n             }\n             None => {\n-                // Reject `impl const Type {}` here\n-                if let Some(Spanned { node: Constness::Const, span }) = constness {\n-                    self.struct_span_err(span, \"`const` cannot modify an inherent impl\")\n-                        .help(\"only a trait impl can be `const`\")\n-                        .emit();\n-                }\n-\n                 // impl Type\n                 ItemKind::Impl {\n                     unsafety,\n                     polarity,\n                     defaultness,\n+                    constness,\n                     generics,\n                     of_trait: None,\n                     self_ty: ty_first,"}, {"sha": "a4cc9fa48f2a6a0acbf5d4c69934aec693f5580f", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -26,10 +26,12 @@ struct BoundModifiers {\n }\n \n impl BoundModifiers {\n-    fn trait_bound_modifier(&self) -> TraitBoundModifier {\n-        match self.maybe {\n-            Some(_) => TraitBoundModifier::Maybe,\n-            None => TraitBoundModifier::None,\n+    fn to_trait_bound_modifier(&self) -> TraitBoundModifier {\n+        match (self.maybe, self.maybe_const) {\n+            (None, None) => TraitBoundModifier::None,\n+            (Some(_), None) => TraitBoundModifier::Maybe,\n+            (None, Some(_)) => TraitBoundModifier::MaybeConst,\n+            (Some(_), Some(_)) => TraitBoundModifier::MaybeConstMaybe,\n         }\n     }\n }\n@@ -214,7 +216,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, TyKind> {\n         assert_ne!(self.token, token::Question);\n \n-        let poly_trait_ref = PolyTraitRef::new(generic_params, path, None, lo.to(self.prev_span));\n+        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n         let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n@@ -556,9 +558,9 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Paren))?;\n         }\n \n-        let constness = modifiers.maybe_const.map(|_| ast::Constness::NotConst);\n-        let poly_trait = PolyTraitRef::new(lifetime_defs, path, constness, lo.to(self.prev_span));\n-        Ok(GenericBound::Trait(poly_trait, modifiers.trait_bound_modifier()))\n+        let modifier = modifiers.to_trait_bound_modifier();\n+        let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n+        Ok(GenericBound::Trait(poly_trait, modifier))\n     }\n \n     /// Optionally parses `for<$generic_params>`."}, {"sha": "60bf271d2d2a8bf184541f36bc1a8042f3efc2cb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -91,7 +91,7 @@ where\n         let ty::GenericPredicates { parent: _, predicates } = predicates;\n         for (predicate, _span) in predicates {\n             match predicate {\n-                ty::Predicate::Trait(poly_predicate) => {\n+                ty::Predicate::Trait(poly_predicate, _) => {\n                     let ty::TraitPredicate { trait_ref } = *poly_predicate.skip_binder();\n                     if self.visit_trait(trait_ref) {\n                         return true;\n@@ -1235,7 +1235,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n             let bounds = rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n \n-            for (trait_predicate, _) in bounds.trait_bounds {\n+            for (trait_predicate, _, _) in bounds.trait_bounds {\n                 if self.visit_trait(*trait_predicate.skip_binder()) {\n                     return;\n                 }"}, {"sha": "a9d2bfabb1ba61c6ff84dd48b7f99e7ee943b175", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -486,6 +486,7 @@ impl Sig for ast::Item {\n                 unsafety,\n                 polarity,\n                 defaultness,\n+                constness,\n                 ref generics,\n                 ref of_trait,\n                 ref self_ty,\n@@ -499,6 +500,9 @@ impl Sig for ast::Item {\n                     text.push_str(\"unsafe \");\n                 }\n                 text.push_str(\"impl\");\n+                if constness == ast::Constness::Const {\n+                    text.push_str(\" const\");\n+                }\n \n                 let generics_sig = generics.make(offset + text.len(), id, scx)?;\n                 text.push_str(&generics_sig.text);"}, {"sha": "b77c603da9a74a58ad9ac6cbe25872da0187ba6f", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -94,7 +94,7 @@ impl<'tcx> Lower<PolyDomainGoal<'tcx>> for ty::Predicate<'tcx> {\n         use rustc::ty::Predicate;\n \n         match self {\n-            Predicate::Trait(predicate) => predicate.lower(),\n+            Predicate::Trait(predicate, _) => predicate.lower(),\n             Predicate::RegionOutlives(predicate) => predicate.lower(),\n             Predicate::TypeOutlives(predicate) => predicate.lower(),\n             Predicate::Projection(predicate) => predicate.lower(),"}, {"sha": "8b62403e6ce5277320870598c775080f98397863", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::map as hir_map;\n use rustc::session::CrateDisambiguator;\n use rustc::traits::{self};\n use rustc::ty::subst::Subst;\n-use rustc::ty::{self, ToPredicate, Ty, TyCtxt};\n+use rustc::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n@@ -58,6 +58,7 @@ fn sized_constraint_for_ty(tcx: TyCtxt<'tcx>, adtdef: &ty::AdtDef, ty: Ty<'tcx>)\n                 def_id: sized_trait,\n                 substs: tcx.mk_substs_trait(ty, &[]),\n             })\n+            .without_const()\n             .to_predicate();\n             let predicates = tcx.predicates_of(adtdef.did).predicates;\n             if predicates.iter().any(|(p, _)| *p == sized_predicate) { vec![] } else { vec![ty] }"}, {"sha": "89eeed8d11ebc5a189b4567a3befa05c09e3e11e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -3,6 +3,8 @@\n //! The main routine here is `ast_ty_to_ty()`; each use is parameterized by an\n //! instance of `AstConv`.\n \n+// ignore-tidy-filelength\n+\n use crate::collect::PlaceholderHirTyCollector;\n use crate::lint;\n use crate::middle::lang_items::SizedTraitLangItem;\n@@ -17,7 +19,7 @@ use rustc::traits::astconv_object_safety_violations;\n use rustc::traits::error_reporting::report_object_safety_error;\n use rustc::traits::wf::object_region_bounds;\n use rustc::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n-use rustc::ty::{self, Const, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Const, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId};\n@@ -31,7 +33,7 @@ use rustc_span::symbol::sym;\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use smallvec::SmallVec;\n-use syntax::ast;\n+use syntax::ast::{self, Constness};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::collections::BTreeSet;\n@@ -48,6 +50,8 @@ pub trait AstConv<'tcx> {\n \n     fn item_def_id(&self) -> Option<DefId>;\n \n+    fn default_constness_for_trait_bounds(&self) -> Constness;\n+\n     /// Returns predicates in scope of the form `X: Foo`, where `X` is\n     /// a type parameter `X` with the given id `def_id`. This is a\n     /// subset of the full set of predicates.\n@@ -918,6 +922,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         trait_ref: &hir::TraitRef<'_>,\n         span: Span,\n+        constness: Constness,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n@@ -946,7 +951,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n         let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n \n-        bounds.trait_bounds.push((poly_trait_ref, span));\n+        bounds.trait_bounds.push((poly_trait_ref, span, constness));\n \n         let mut dup_bindings = FxHashMap::default();\n         for binding in &assoc_bindings {\n@@ -992,12 +997,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn instantiate_poly_trait_ref(\n         &self,\n         poly_trait_ref: &hir::PolyTraitRef<'_>,\n+        constness: Constness,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n     ) -> Option<Vec<Span>> {\n         self.instantiate_poly_trait_ref_inner(\n             &poly_trait_ref.trait_ref,\n             poly_trait_ref.span,\n+            constness,\n             self_ty,\n             bounds,\n             false,\n@@ -1180,18 +1187,22 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut trait_bounds = Vec::new();\n         let mut region_bounds = Vec::new();\n \n+        let constness = self.default_constness_for_trait_bounds();\n         for ast_bound in ast_bounds {\n             match *ast_bound {\n                 hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) => {\n-                    trait_bounds.push(b)\n+                    trait_bounds.push((b, constness))\n+                }\n+                hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::MaybeConst) => {\n+                    trait_bounds.push((b, Constness::NotConst))\n                 }\n                 hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n                 hir::GenericBound::Outlives(ref l) => region_bounds.push(l),\n             }\n         }\n \n-        for bound in trait_bounds {\n-            let _ = self.instantiate_poly_trait_ref(bound, param_ty, bounds);\n+        for (bound, constness) in trait_bounds {\n+            let _ = self.instantiate_poly_trait_ref(bound, constness, param_ty, bounds);\n         }\n \n         bounds.region_bounds.extend(\n@@ -1225,7 +1236,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut bounds = Bounds::default();\n \n         self.add_bounds(param_ty, ast_bounds, &mut bounds);\n-        bounds.trait_bounds.sort_by_key(|(t, _)| t.def_id());\n+        bounds.trait_bounds.sort_by_key(|(t, _, _)| t.def_id());\n \n         bounds.implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n             if !self.is_unsized(ast_bounds, span) { Some(span) } else { None }\n@@ -1416,15 +1427,21 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n         for trait_bound in trait_bounds.iter().rev() {\n-            let cur_potential_assoc_types =\n-                self.instantiate_poly_trait_ref(trait_bound, dummy_self, &mut bounds);\n+            let cur_potential_assoc_types = self.instantiate_poly_trait_ref(\n+                trait_bound,\n+                Constness::NotConst,\n+                dummy_self,\n+                &mut bounds,\n+            );\n             potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n         }\n \n         // Expand trait aliases recursively and check that only one regular (non-auto) trait\n         // is used and no 'maybe' bounds are used.\n-        let expanded_traits =\n-            traits::expand_trait_aliases(tcx, bounds.trait_bounds.iter().cloned());\n+        let expanded_traits = traits::expand_trait_aliases(\n+            tcx,\n+            bounds.trait_bounds.iter().map(|&(a, b, _)| (a.clone(), b)),\n+        );\n         let (mut auto_traits, regular_traits): (Vec<_>, Vec<_>) =\n             expanded_traits.partition(|i| tcx.trait_is_auto(i.trait_ref().def_id()));\n         if regular_traits.len() > 1 {\n@@ -1480,16 +1497,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let regular_traits_refs_spans = bounds\n             .trait_bounds\n             .into_iter()\n-            .filter(|(trait_ref, _)| !tcx.trait_is_auto(trait_ref.def_id()));\n+            .filter(|(trait_ref, _, _)| !tcx.trait_is_auto(trait_ref.def_id()));\n+\n+        for (base_trait_ref, span, constness) in regular_traits_refs_spans {\n+            assert_eq!(constness, ast::Constness::NotConst);\n \n-        for (base_trait_ref, span) in regular_traits_refs_spans {\n             for trait_ref in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n                 debug!(\n                     \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n                     trait_ref\n                 );\n                 match trait_ref {\n-                    ty::Predicate::Trait(pred) => {\n+                    ty::Predicate::Trait(pred, _) => {\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n                                 .filter(|item| item.kind == ty::AssocKind::Type)\n@@ -2948,7 +2967,7 @@ pub struct Bounds<'tcx> {\n \n     /// A list of trait bounds. So if you had `T: Debug` this would be\n     /// `T: Debug`. Note that the self-type is explicit here.\n-    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span)>,\n+    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span, Constness)>,\n \n     /// A list of projection equality bounds. So if you had `T:\n     /// Iterator<Item = u32>` this would include `<T as\n@@ -2979,7 +2998,7 @@ impl<'tcx> Bounds<'tcx> {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[]),\n                 });\n-                (trait_ref.to_predicate(), span)\n+                (trait_ref.without_const().to_predicate(), span)\n             })\n         });\n \n@@ -2996,11 +3015,10 @@ impl<'tcx> Bounds<'tcx> {\n                         let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n                         (ty::Binder::bind(outlives).to_predicate(), span)\n                     })\n-                    .chain(\n-                        self.trait_bounds\n-                            .iter()\n-                            .map(|&(bound_trait_ref, span)| (bound_trait_ref.to_predicate(), span)),\n-                    )\n+                    .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n+                        let predicate = bound_trait_ref.with_constness(constness).to_predicate();\n+                        (predicate, span)\n+                    }))\n                     .chain(\n                         self.projection_bounds\n                             .iter()"}, {"sha": "e4dec97183c7de5eec3b480134fb2b2f6cfbe671", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -5,7 +5,7 @@ use rustc::infer::{InferCtxt, InferOk};\n use rustc::session::DiagnosticMessageId;\n use rustc::traits::{self, TraitEngine};\n use rustc::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n-use rustc::ty::{self, TraitRef, Ty, TyCtxt};\n+use rustc::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -122,8 +122,11 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n \n         let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n-        let obligation =\n-            traits::Obligation::new(cause.clone(), self.param_env, trait_ref.to_predicate());\n+        let obligation = traits::Obligation::new(\n+            cause.clone(),\n+            self.param_env,\n+            trait_ref.without_const().to_predicate(),\n+        );\n         if !self.infcx.predicate_may_hold(&obligation) {\n             debug!(\"overloaded_deref_ty: cannot match obligation\");\n             return None;"}, {"sha": "54b32c3a50fcdc194158af01eec9dffbc47416f1", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -564,7 +564,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let trait_ref = match obligation.predicate {\n-                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n+                ty::Predicate::Trait(ref tr, _) if traits.contains(&tr.def_id()) => {\n                     if unsize_did == tr.def_id() {\n                         let sty = &tr.skip_binder().input_types().nth(1).unwrap().kind;\n                         if let ty::Tuple(..) = sty {"}, {"sha": "32773e2ed807c9123bcf2fc4e301628054d67914", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -232,7 +232,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         let predicate_matches_closure = |p: &'_ Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n             match (predicate, p) {\n-                (Predicate::Trait(a), Predicate::Trait(b)) => relator.relate(a, b).is_ok(),\n+                (Predicate::Trait(a, _), Predicate::Trait(b, _)) => relator.relate(a, b).is_ok(),\n                 (Predicate::Projection(a), Predicate::Projection(b)) => {\n                     relator.relate(a, b).is_ok()\n                 }"}, {"sha": "2012a2a1526b1c440e00b8f813448c5f6769e767", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -569,7 +569,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.clone())\n             .filter_map(|predicate| match predicate {\n-                ty::Predicate::Trait(trait_pred) if trait_pred.def_id() == sized_def_id => {\n+                ty::Predicate::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n                     Some(trait_pred)\n                 }\n                 _ => None,"}, {"sha": "c1cf3522b5d9c1ac72f6864aece8d925bca656c7", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -17,7 +17,7 @@ use rustc::traits;\n use rustc::ty::subst::Subst;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::GenericParamDefKind;\n-use rustc::ty::{self, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TypeFoldable};\n+use rustc::ty::{self, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TypeFoldable, WithConstness};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -322,7 +322,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             span,\n             self.body_id,\n             self.param_env,\n-            poly_trait_ref.to_predicate(),\n+            poly_trait_ref.without_const().to_predicate(),\n         );\n \n         // Now we want to know if this can be matched"}, {"sha": "2adf125f048d04cf0a892568d48c565ad3bca712", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -25,6 +25,7 @@ use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc::ty::GenericParamDefKind;\n use rustc::ty::{\n     self, ParamEnvAnd, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeFoldable,\n+    WithConstness,\n };\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n@@ -824,7 +825,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // FIXME: do we want to commit to this behavior for param bounds?\n \n         let bounds = self.param_env.caller_bounds.iter().filter_map(|predicate| match *predicate {\n-            ty::Predicate::Trait(ref trait_predicate) => {\n+            ty::Predicate::Trait(ref trait_predicate, _) => {\n                 match trait_predicate.skip_binder().trait_ref.self_ty().kind {\n                     ty::Param(ref p) if *p == param_ty => Some(trait_predicate.to_poly_trait_ref()),\n                     _ => None,\n@@ -1394,7 +1395,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n \n                 TraitCandidate(trait_ref) => {\n-                    let predicate = trait_ref.to_predicate();\n+                    let predicate = trait_ref.without_const().to_predicate();\n                     let obligation = traits::Obligation::new(cause, self.param_env, predicate);\n                     if !self.predicate_may_hold(&obligation) {\n                         if self.probe(|_| self.select_trait_candidate(trait_ref).is_err()) {\n@@ -1428,7 +1429,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let o = self.resolve_vars_if_possible(&o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n-                    if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n+                    if let &ty::Predicate::Trait(ref pred, _) = &o.predicate {\n                         possibly_unsatisfied_predicates.push(pred.skip_binder().trait_ref);\n                     }\n                 }"}, {"sha": "e9942fad3bc64d29f39032436ddc36f5bc28ce8f", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -9,7 +9,7 @@ use rustc::hir::map::Map;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::traits::Obligation;\n use rustc::ty::print::with_crate_prefix;\n-use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             span,\n                             self.body_id,\n                             self.param_env,\n-                            poly_trait_ref.to_predicate(),\n+                            poly_trait_ref.without_const().to_predicate(),\n                         );\n                         self.predicate_may_hold(&obligation)\n                     })"}, {"sha": "3818750e920ce1fead3f2f9c7a2ee3fb264401b0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -90,6 +90,7 @@ pub mod writeback;\n use crate::astconv::{AstConv, PathSeg};\n use crate::middle::lang_items;\n use crate::namespace::Namespace;\n+use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::Map;\n use rustc::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc::infer::error_reporting::TypeAnnotationNeeded::E0282;\n@@ -112,7 +113,7 @@ use rustc::ty::subst::{GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSel\n use rustc::ty::util::{Discr, IntTypeExt, Representability};\n use rustc::ty::{\n     self, AdtKind, CanonicalUserType, Const, GenericParamDefKind, RegionKind, ToPolyTraitRef,\n-    ToPredicate, Ty, TyCtxt, UserType,\n+    ToPredicate, Ty, TyCtxt, UserType, WithConstness,\n };\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -1421,7 +1422,7 @@ fn check_fn<'a, 'tcx>(\n                 inherited.register_predicate(traits::Obligation::new(\n                     cause,\n                     param_env,\n-                    trait_ref.to_predicate(),\n+                    trait_ref.without_const().to_predicate(),\n                 ));\n             }\n         }\n@@ -2610,6 +2611,16 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    fn default_constness_for_trait_bounds(&self) -> ast::Constness {\n+        // FIXME: refactor this into a method\n+        let node = self.tcx.hir().get(self.body_id);\n+        if let Some(fn_like) = FnLikeNode::from_node(node) {\n+            fn_like.constness()\n+        } else {\n+            ast::Constness::NotConst\n+        }\n+    }\n+\n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -2621,7 +2632,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             parent: None,\n             predicates: tcx.arena.alloc_from_iter(self.param_env.caller_bounds.iter().filter_map(\n                 |&predicate| match predicate {\n-                    ty::Predicate::Trait(ref data)\n+                    ty::Predicate::Trait(ref data, _)\n                         if data.skip_binder().self_ty().is_param(index) =>\n                     {\n                         // HACK(eddyb) should get the original `Span`.\n@@ -3693,7 +3704,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ty::Predicate::Projection(ref data) => {\n                     Some((data.to_poly_trait_ref(self.tcx), obligation))\n                 }\n-                ty::Predicate::Trait(ref data) => Some((data.to_poly_trait_ref(), obligation)),\n+                ty::Predicate::Trait(ref data, _) => Some((data.to_poly_trait_ref(), obligation)),\n                 ty::Predicate::Subtype(..) => None,\n                 ty::Predicate::RegionOutlives(..) => None,\n                 ty::Predicate::TypeOutlives(..) => None,\n@@ -3996,7 +4007,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 continue;\n             }\n \n-            if let ty::Predicate::Trait(predicate) = error.obligation.predicate {\n+            if let ty::Predicate::Trait(predicate, _) = error.obligation.predicate {\n                 // Collect the argument position for all arguments that could have caused this\n                 // `FulfillmentError`.\n                 let mut referenced_in = final_arg_types\n@@ -4040,7 +4051,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::Predicate::Trait(predicate) = error.obligation.predicate {\n+                        if let ty::Predicate::Trait(predicate, _) = error.obligation.predicate {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860).\n                             for arg in path"}, {"sha": "82811826ae7e7f4ab455f5a410a7f4376d182b8c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -6,7 +6,9 @@ use rustc::middle::lang_items;\n use rustc::session::parse::feature_err;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::subst::{InternalSubsts, Subst};\n-use rustc::ty::{self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{\n+    self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir::def_id::DefId;\n@@ -953,7 +955,8 @@ fn receiver_is_implemented(\n         substs: fcx.tcx.mk_substs_trait(receiver_ty, &[]),\n     };\n \n-    let obligation = traits::Obligation::new(cause, fcx.param_env, trait_ref.to_predicate());\n+    let obligation =\n+        traits::Obligation::new(cause, fcx.param_env, trait_ref.without_const().to_predicate());\n \n     if fcx.predicate_must_hold_modulo_regions(&obligation) {\n         true"}, {"sha": "5821977391b0aa4a28e0d10b4324732896765ba0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -20,6 +20,7 @@ use crate::constrained_generic_params as cgp;\n use crate::lint;\n use crate::middle::resolve_lifetime as rl;\n use crate::middle::weak_lang_items;\n+use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::Map;\n use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc::mir::mono::Linkage;\n@@ -30,7 +31,7 @@ use rustc::ty::subst::GenericArgKind;\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::util::Discr;\n use rustc::ty::util::IntTypeExt;\n-use rustc::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt, WithConstness};\n use rustc::ty::{ReprOptions, ToPredicate};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n@@ -286,6 +287,22 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         Some(self.item_def_id)\n     }\n \n+    fn default_constness_for_trait_bounds(&self) -> ast::Constness {\n+        // FIXME: refactor this into a method\n+        let hir_id = self\n+            .tcx\n+            .hir()\n+            .as_local_hir_id(self.item_def_id)\n+            .expect(\"Non-local call to local provider is_const_fn\");\n+\n+        let node = self.tcx.hir().get(hir_id);\n+        if let Some(fn_like) = FnLikeNode::from_node(node) {\n+            fn_like.constness()\n+        } else {\n+            ast::Constness::NotConst\n+        }\n+    }\n+\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n         self.tcx.at(span).type_param_predicates((self.item_def_id, def_id))\n     }\n@@ -409,7 +426,8 @@ fn type_param_predicates(\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_hir_id {\n                         let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n-                        extend = Some((identity_trait_ref.to_predicate(), item.span));\n+                        extend =\n+                            Some((identity_trait_ref.without_const().to_predicate(), item.span));\n                     }\n                     generics\n                 }\n@@ -430,7 +448,7 @@ fn type_param_predicates(\n         icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n             .into_iter()\n             .filter(|(predicate, _)| match predicate {\n-                ty::Predicate::Trait(ref data) => data.skip_binder().self_ty().is_param(index),\n+                ty::Predicate::Trait(ref data, _) => data.skip_binder().self_ty().is_param(index),\n                 _ => false,\n             }),\n     );\n@@ -451,6 +469,7 @@ impl ItemCtxt<'tcx> {\n         ty: Ty<'tcx>,\n         only_self_bounds: OnlySelfBounds,\n     ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n+        let constness = self.default_constness_for_trait_bounds();\n         let from_ty_params = ast_generics\n             .params\n             .iter()\n@@ -459,7 +478,7 @@ impl ItemCtxt<'tcx> {\n                 _ => None,\n             })\n             .flat_map(|bounds| bounds.iter())\n-            .flat_map(|b| predicates_from_bound(self, ty, b));\n+            .flat_map(|b| predicates_from_bound(self, ty, b, constness));\n \n         let from_where_clauses = ast_generics\n             .where_clause\n@@ -479,7 +498,7 @@ impl ItemCtxt<'tcx> {\n                 };\n                 bp.bounds.iter().filter_map(move |b| bt.map(|bt| (bt, b)))\n             })\n-            .flat_map(|(bt, b)| predicates_from_bound(self, bt, b));\n+            .flat_map(|(bt, b)| predicates_from_bound(self, bt, b, constness));\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n@@ -855,7 +874,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in superbounds {\n         debug!(\"superbound: {:?}\", pred);\n-        if let ty::Predicate::Trait(bound) = pred {\n+        if let ty::Predicate::Trait(bound, _) = pred {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n     }\n@@ -2054,7 +2073,7 @@ fn predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n         let span = tcx.def_span(def_id);\n         result.predicates =\n             tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(std::iter::once((\n-                ty::TraitRef::identity(tcx, def_id).to_predicate(),\n+                ty::TraitRef::identity(tcx, def_id).without_const().to_predicate(),\n                 span,\n             ))));\n     }\n@@ -2104,6 +2123,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     let mut is_default_impl_trait = None;\n \n     let icx = ItemCtxt::new(tcx, def_id);\n+    let constness = icx.default_constness_for_trait_bounds();\n \n     const NO_GENERICS: &hir::Generics<'_> = &hir::Generics::empty();\n \n@@ -2228,7 +2248,10 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     // (see below). Recall that a default impl is not itself an impl, but rather a\n     // set of defaults that can be incorporated into another impl.\n     if let Some(trait_ref) = is_default_impl_trait {\n-        predicates.push((trait_ref.to_poly_trait_ref().to_predicate(), tcx.def_span(def_id)));\n+        predicates.push((\n+            trait_ref.to_poly_trait_ref().without_const().to_predicate(),\n+            tcx.def_span(def_id),\n+        ));\n     }\n \n     // Collect the region predicates that were declared inline as\n@@ -2302,11 +2325,18 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n-                        &hir::GenericBound::Trait(ref poly_trait_ref, _) => {\n+                        &hir::GenericBound::Trait(ref poly_trait_ref, modifier) => {\n+                            let constness = match modifier {\n+                                hir::TraitBoundModifier::MaybeConst => ast::Constness::NotConst,\n+                                hir::TraitBoundModifier::None => constness,\n+                                hir::TraitBoundModifier::Maybe => bug!(\"this wasn't handled\"),\n+                            };\n+\n                             let mut bounds = Bounds::default();\n                             let _ = AstConv::instantiate_poly_trait_ref(\n                                 &icx,\n                                 poly_trait_ref,\n+                                constness,\n                                 ty,\n                                 &mut bounds,\n                             );\n@@ -2482,19 +2512,25 @@ fn predicates_from_bound<'tcx>(\n     astconv: &dyn AstConv<'tcx>,\n     param_ty: Ty<'tcx>,\n     bound: &'tcx hir::GenericBound<'tcx>,\n+    constness: ast::Constness,\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     match *bound {\n-        hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n+        hir::GenericBound::Trait(ref tr, modifier) => {\n+            let constness = match modifier {\n+                hir::TraitBoundModifier::Maybe => return vec![],\n+                hir::TraitBoundModifier::MaybeConst => ast::Constness::NotConst,\n+                hir::TraitBoundModifier::None => constness,\n+            };\n+\n             let mut bounds = Bounds::default();\n-            let _ = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut bounds);\n+            let _ = astconv.instantiate_poly_trait_ref(tr, constness, param_ty, &mut bounds);\n             bounds.predicates(astconv.tcx(), param_ty)\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n             vec![(ty::Predicate::TypeOutlives(pred), lifetime.span)]\n         }\n-        hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => vec![],\n     }\n }\n "}, {"sha": "3d27f9191dd397fc7c33c42b1991b7559a840d11", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -380,6 +380,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n         &item_cx,\n         hir_trait,\n         DUMMY_SP,\n+        syntax::ast::Constness::NotConst,\n         tcx.types.err,\n         &mut bounds,\n         true,"}, {"sha": "27f8059691a14040701622ecbada80a9c5efb7e1", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n                     || match p {\n-                        &&ty::Predicate::Trait(pred) => pred.def_id() == sized_trait,\n+                        ty::Predicate::Trait(pred, _) => pred.def_id() == sized_trait,\n                         _ => false,\n                     }\n             })"}, {"sha": "18ebd254507eaff5bdbec46c01840047bfa88af7", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1,7 +1,7 @@\n use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::subst::Subst;\n-use rustc::ty::ToPredicate;\n+use rustc::ty::{ToPredicate, WithConstness};\n use rustc_hir as hir;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_span::DUMMY_SP;\n@@ -64,7 +64,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         match infcx.evaluate_obligation(&traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            trait_ref.to_predicate(),\n+                            trait_ref.without_const().to_predicate(),\n                         )) {\n                             Ok(eval_result) => eval_result.may_apply(),\n                             Err(traits::OverflowError) => true, // overflow doesn't mean yes *or* no"}, {"sha": "7a7d69c68a585aaacae347bf9de867799e99ef22", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -482,7 +482,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n         use rustc::ty::Predicate;\n \n         match *self {\n-            Predicate::Trait(ref pred) => Some(pred.clean(cx)),\n+            Predicate::Trait(ref pred, _) => Some(pred.clean(cx)),\n             Predicate::Subtype(ref pred) => Some(pred.clean(cx)),\n             Predicate::RegionOutlives(ref pred) => pred.clean(cx),\n             Predicate::TypeOutlives(ref pred) => pred.clean(cx),"}, {"sha": "2b59c60f0b77f26d613b988ebfa77bff46e34357", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -141,7 +141,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId)\n         .predicates\n         .iter()\n         .filter_map(|(pred, _)| {\n-            if let ty::Predicate::Trait(ref pred) = *pred {\n+            if let ty::Predicate::Trait(ref pred, _) = *pred {\n                 if pred.skip_binder().trait_ref.self_ty() == self_ty {\n                     Some(pred.def_id())\n                 } else {"}, {"sha": "218674b757f39686bb258a7ca660b1afce201e73", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -203,6 +203,7 @@ pub struct Impl<'hir> {\n     pub unsafety: hir::Unsafety,\n     pub polarity: hir::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n+    pub constness: ast::Constness,\n     pub generics: &'hir hir::Generics<'hir>,\n     pub trait_: &'hir Option<hir::TraitRef<'hir>>,\n     pub for_: &'hir hir::Ty<'hir>,"}, {"sha": "79923fc3d3689fc218af171ed59f004e58918570", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -361,6 +361,7 @@ impl clean::GenericBound {\n                 let modifier_str = match modifier {\n                     hir::TraitBoundModifier::None => \"\",\n                     hir::TraitBoundModifier::Maybe => \"?\",\n+                    hir::TraitBoundModifier::MaybeConst => \"?const\",\n                 };\n                 if f.alternate() {\n                     write!(f, \"{}{:#}\", modifier_str, ty.print())"}, {"sha": "d3d45ccccad3654892448e865aca1225ecc8a9b2", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -562,6 +562,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 unsafety,\n                 polarity,\n                 defaultness,\n+                constness,\n                 ref generics,\n                 ref of_trait,\n                 self_ty,\n@@ -576,6 +577,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         unsafety,\n                         polarity,\n                         defaultness,\n+                        constness,\n                         generics,\n                         trait_: of_trait,\n                         for_: self_ty,"}, {"sha": "135e8308afaea5c3e0a320e997e53582aad8914f", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 51, "deletions": 73, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -13,75 +13,43 @@ use crate::time::Duration;\n \n use libc::{c_int, c_void};\n \n-#[cfg(not(any(\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"solaris\",\n-    target_os = \"haiku\",\n-    target_os = \"l4re\"\n-)))]\n-use crate::sys::net::netc::IPV6_ADD_MEMBERSHIP;\n-#[cfg(not(any(\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"solaris\",\n-    target_os = \"haiku\",\n-    target_os = \"l4re\"\n-)))]\n-use crate::sys::net::netc::IPV6_DROP_MEMBERSHIP;\n-#[cfg(any(\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"solaris\",\n-    target_os = \"haiku\",\n-    target_os = \"l4re\"\n-))]\n-use crate::sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n-#[cfg(any(\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"solaris\",\n-    target_os = \"haiku\",\n-    target_os = \"l4re\"\n-))]\n-use crate::sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n-\n-#[cfg(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"haiku\"\n-))]\n-use libc::MSG_NOSIGNAL;\n-#[cfg(not(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"haiku\"\n-)))]\n-const MSG_NOSIGNAL: c_int = 0x0;\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"dragonfly\", target_os = \"freebsd\",\n+        target_os = \"ios\", target_os = \"macos\",\n+        target_os = \"openbsd\", target_os = \"netbsd\",\n+        target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\"))] {\n+        use crate::sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n+        use crate::sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n+    } else {\n+        use crate::sys::net::netc::IPV6_ADD_MEMBERSHIP;\n+        use crate::sys::net::netc::IPV6_DROP_MEMBERSHIP;\n+    }\n+}\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"linux\", target_os = \"android\",\n+        target_os = \"dragonfly\", target_os = \"freebsd\",\n+        target_os = \"openbsd\", target_os = \"netbsd\",\n+        target_os = \"haiku\"))] {\n+        use libc::MSG_NOSIGNAL;\n+    } else {\n+        const MSG_NOSIGNAL: c_int = 0x0;\n+    }\n+}\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"dragonfly\", target_os = \"freebsd\",\n+        target_os = \"openbsd\", target_os = \"netbsd\",\n+        target_os = \"solaris\"))] {\n+        use libc::c_uchar;\n+        type IpV4MultiCastType = c_uchar;\n+    } else {\n+        type IpV4MultiCastType = c_int;\n+    }\n+}\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n@@ -566,20 +534,30 @@ impl UdpSocket {\n     }\n \n     pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n-        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP, multicast_loop_v4 as c_int)\n+        setsockopt(\n+            &self.inner,\n+            c::IPPROTO_IP,\n+            c::IP_MULTICAST_LOOP,\n+            multicast_loop_v4 as IpV4MultiCastType,\n+        )\n     }\n \n     pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n+        let raw: IpV4MultiCastType = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n         Ok(raw != 0)\n     }\n \n     pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n-        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL, multicast_ttl_v4 as c_int)\n+        setsockopt(\n+            &self.inner,\n+            c::IPPROTO_IP,\n+            c::IP_MULTICAST_TTL,\n+            multicast_ttl_v4 as IpV4MultiCastType,\n+        )\n     }\n \n     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n+        let raw: IpV4MultiCastType = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n         Ok(raw as u32)\n     }\n "}, {"sha": "5f38ac4cc0f42ed27e7fc264317b09d8f517fc16", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -266,12 +266,24 @@ pub const CRATE_NODE_ID: NodeId = NodeId::from_u32_const(0);\n /// small, positive ids.\n pub const DUMMY_NODE_ID: NodeId = NodeId::MAX;\n \n-/// A modifier on a bound, currently this is only used for `?Sized`, where the\n-/// modifier is `Maybe`. Negative bounds should also be handled here.\n+/// A modifier on a bound, e.g., `?Sized` or `?const Trait`.\n+///\n+/// Negative bounds should also be handled here.\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub enum TraitBoundModifier {\n+    /// No modifiers\n     None,\n+\n+    /// `?Trait`\n     Maybe,\n+\n+    /// `?const Trait`\n+    MaybeConst,\n+\n+    /// `?const ?Trait`\n+    //\n+    // This parses but will be rejected during AST validation.\n+    MaybeConstMaybe,\n }\n \n /// The AST represents all type param bounds as types.\n@@ -1033,7 +1045,7 @@ impl Expr {\n     pub fn to_bound(&self) -> Option<GenericBound> {\n         match &self.kind {\n             ExprKind::Path(None, path) => Some(GenericBound::Trait(\n-                PolyTraitRef::new(Vec::new(), path.clone(), None, self.span),\n+                PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n                 TraitBoundModifier::None,\n             )),\n             _ => None,\n@@ -2158,7 +2170,8 @@ impl IsAsync {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum Constness {\n     Const,\n     NotConst,\n@@ -2376,15 +2389,6 @@ pub enum AttrKind {\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n-\n-    /// The `const` modifier, if any, that appears before this trait.\n-    ///\n-    /// |                | `constness`                 |\n-    /// |----------------|-----------------------------|\n-    /// | `Trait`        | `None`                      |\n-    /// | `const Trait`  | `Some(Constness::Const)`    |\n-    /// | `?const Trait` | `Some(Constness::NotConst)` |\n-    pub constness: Option<Constness>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -2399,15 +2403,10 @@ pub struct PolyTraitRef {\n }\n \n impl PolyTraitRef {\n-    pub fn new(\n-        generic_params: Vec<GenericParam>,\n-        path: Path,\n-        constness: Option<Constness>,\n-        span: Span,\n-    ) -> Self {\n+    pub fn new(generic_params: Vec<GenericParam>, path: Path, span: Span) -> Self {\n         PolyTraitRef {\n             bound_generic_params: generic_params,\n-            trait_ref: TraitRef { path, constness, ref_id: DUMMY_NODE_ID },\n+            trait_ref: TraitRef { path, ref_id: DUMMY_NODE_ID },\n             span,\n         }\n     }\n@@ -2618,6 +2617,7 @@ pub enum ItemKind {\n         unsafety: Unsafety,\n         polarity: ImplPolarity,\n         defaultness: Defaultness,\n+        constness: Constness,\n         generics: Generics,\n \n         /// The trait being implemented, if any."}, {"sha": "4a460c5d7b24c17cdf1e854a2f209840473787ea", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -838,8 +838,7 @@ pub fn noop_visit_variant_data<T: MutVisitor>(vdata: &mut VariantData, vis: &mut\n     }\n }\n \n-pub fn noop_visit_trait_ref<T: MutVisitor>(tr: &mut TraitRef, vis: &mut T) {\n-    let TraitRef { path, ref_id, constness: _ } = tr;\n+pub fn noop_visit_trait_ref<T: MutVisitor>(TraitRef { path, ref_id }: &mut TraitRef, vis: &mut T) {\n     vis.visit_path(path);\n     vis.visit_id(ref_id);\n }\n@@ -922,6 +921,7 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             unsafety: _,\n             polarity: _,\n             defaultness: _,\n+            constness: _,\n             generics,\n             of_trait,\n             self_ty,"}, {"sha": "3927e4f903011fda4bfab0619ff07605f84cced1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1230,6 +1230,7 @@ impl<'a> State<'a> {\n                 unsafety,\n                 polarity,\n                 defaultness,\n+                constness,\n                 ref generics,\n                 ref of_trait,\n                 ref self_ty,\n@@ -1240,6 +1241,7 @@ impl<'a> State<'a> {\n                 self.print_defaultness(defaultness);\n                 self.print_unsafety(unsafety);\n                 self.word_nbsp(\"impl\");\n+                self.print_constness(constness);\n \n                 if !generics.params.is_empty() {\n                     self.print_generic_params(&generics.params);\n@@ -2773,6 +2775,13 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    crate fn print_constness(&mut self, s: ast::Constness) {\n+        match s {\n+            ast::Constness::Const => self.word_nbsp(\"const\"),\n+            ast::Constness::NotConst => {}\n+        }\n+    }\n+\n     crate fn print_is_auto(&mut self, s: ast::IsAuto) {\n         match s {\n             ast::IsAuto::Yes => self.word_nbsp(\"auto\"),"}, {"sha": "946a0d29cd399028c798787d73657c64d7962f2a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -312,6 +312,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             unsafety: _,\n             polarity: _,\n             defaultness: _,\n+            constness: _,\n             ref generics,\n             ref of_trait,\n             ref self_ty,"}, {"sha": "a98b4f2fd4450a1789f8526207d9921db994a07d", "filename": "src/test/ui/lint/lint-uppercase-variables.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -25,6 +25,16 @@ fn main() {\n //~^^^ WARN unused variable: `Foo`\n     }\n \n+    let Foo = foo::Foo::Foo;\n+    //~^ ERROR variable `Foo` should have a snake case name\n+    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n+    //~^^^ WARN unused variable: `Foo`\n+\n+    fn in_param(Foo: foo::Foo) {}\n+    //~^ ERROR variable `Foo` should have a snake case name\n+    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n+    //~^^^ WARN unused variable: `Foo`\n+\n     test(1);\n \n     let _ = Something { X: 0 };"}, {"sha": "a38f3e7626bca477f52863940ad277618c301646", "filename": "src/test/ui/lint/lint-uppercase-variables.stderr", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -6,6 +6,18 @@ LL |         Foo => {}\n    |\n    = note: `#[warn(bindings_with_variant_name)]` on by default\n \n+warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n+  --> $DIR/lint-uppercase-variables.rs:28:9\n+   |\n+LL |     let Foo = foo::Foo::Foo;\n+   |         ^^^ help: to match on the variant, qualify the path: `foo::Foo::Foo`\n+\n+warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n+  --> $DIR/lint-uppercase-variables.rs:33:17\n+   |\n+LL |     fn in_param(Foo: foo::Foo) {}\n+   |                 ^^^ help: to match on the variant, qualify the path: `foo::Foo::Foo`\n+\n warning: unused variable: `Foo`\n   --> $DIR/lint-uppercase-variables.rs:22:9\n    |\n@@ -19,6 +31,18 @@ LL | #![warn(unused)]\n    |         ^^^^^^\n    = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n \n+warning: unused variable: `Foo`\n+  --> $DIR/lint-uppercase-variables.rs:28:9\n+   |\n+LL |     let Foo = foo::Foo::Foo;\n+   |         ^^^ help: consider prefixing with an underscore: `_Foo`\n+\n+warning: unused variable: `Foo`\n+  --> $DIR/lint-uppercase-variables.rs:33:17\n+   |\n+LL |     fn in_param(Foo: foo::Foo) {}\n+   |                 ^^^ help: consider prefixing with an underscore: `_Foo`\n+\n error: structure field `X` should have a snake case name\n   --> $DIR/lint-uppercase-variables.rs:10:5\n    |\n@@ -49,6 +73,18 @@ error: variable `Foo` should have a snake case name\n LL |         Foo => {}\n    |         ^^^ help: convert the identifier to snake case (notice the capitalization): `foo`\n \n-error: aborting due to 4 previous errors\n+error: variable `Foo` should have a snake case name\n+  --> $DIR/lint-uppercase-variables.rs:28:9\n+   |\n+LL |     let Foo = foo::Foo::Foo;\n+   |         ^^^ help: convert the identifier to snake case (notice the capitalization): `foo`\n+\n+error: variable `Foo` should have a snake case name\n+  --> $DIR/lint-uppercase-variables.rs:33:17\n+   |\n+LL |     fn in_param(Foo: foo::Foo) {}\n+   |                 ^^^ help: convert the identifier to snake case (notice the capitalization): `foo`\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0170`."}, {"sha": "95ead6b5d4a611589fa90f7bcb5377f598b81555", "filename": "src/test/ui/pattern/issue-68393-let-pat-assoc-constant.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -0,0 +1,26 @@\n+pub enum EFoo {\n+    A,\n+}\n+\n+pub trait Foo {\n+    const X: EFoo;\n+}\n+\n+struct Abc;\n+\n+impl Foo for Abc {\n+    const X: EFoo = EFoo::A;\n+}\n+\n+struct Def;\n+impl Foo for Def {\n+    const X: EFoo = EFoo::A;\n+}\n+\n+pub fn test<A: Foo, B: Foo>(arg: EFoo, A::X: EFoo) {\n+    //~^ ERROR associated consts cannot be referenced in patterns\n+    let A::X = arg;\n+    //~^ ERROR associated consts cannot be referenced in patterns\n+}\n+\n+fn main() {}"}, {"sha": "54ecc24981f80943769fdd3da5ed082c8a89c081", "filename": "src/test/ui/pattern/issue-68393-let-pat-assoc-constant.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -0,0 +1,15 @@\n+error[E0158]: associated consts cannot be referenced in patterns\n+  --> $DIR/issue-68393-let-pat-assoc-constant.rs:20:40\n+   |\n+LL | pub fn test<A: Foo, B: Foo>(arg: EFoo, A::X: EFoo) {\n+   |                                        ^^^^\n+\n+error[E0158]: associated consts cannot be referenced in patterns\n+  --> $DIR/issue-68393-let-pat-assoc-constant.rs:22:9\n+   |\n+LL |     let A::X = arg;\n+   |         ^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0158`."}, {"sha": "f10a7f2d8a54f0be593e3b43c55d3e03215d2da3", "filename": "src/test/ui/pattern/issue-68394-let-pat-runtime-value.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let x = 255u8;\n+    let 0u8..=x = 0;\n+    //~^ ERROR runtime values cannot be referenced in patterns\n+}"}, {"sha": "c1508bd71ff7a6c1f6cdc8d205fb258b58cdb954", "filename": "src/test/ui/pattern/issue-68394-let-pat-runtime-value.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: runtime values cannot be referenced in patterns\n+  --> $DIR/issue-68394-let-pat-runtime-value.rs:3:15\n+   |\n+LL |     let 0u8..=x = 0;\n+   |               ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "afc599a4b22b6a0efbedcaa4adeeb4f12fd700d2", "filename": "src/test/ui/pattern/issue-68396-let-float-bug.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let 1234567890123456789012345678901234567890e-340: f64 = 0.0;\n+    //~^ ERROR could not evaluate float literal (see issue #31407)\n+\n+    fn param(1234567890123456789012345678901234567890e-340: f64) {}\n+    //~^ ERROR could not evaluate float literal (see issue #31407)\n+}"}, {"sha": "618aa4b5021f10e3aa053633a3403056a465c0a1", "filename": "src/test/ui/pattern/issue-68396-let-float-bug.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -0,0 +1,15 @@\n+error[E0080]: could not evaluate float literal (see issue #31407)\n+  --> $DIR/issue-68396-let-float-bug.rs:2:9\n+   |\n+LL |     let 1234567890123456789012345678901234567890e-340: f64 = 0.0;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: could not evaluate float literal (see issue #31407)\n+  --> $DIR/issue-68396-let-float-bug.rs:5:14\n+   |\n+LL |     fn param(1234567890123456789012345678901234567890e-340: f64) {}\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "0115fc081a9701f06ce37608998fb3b15547e26c", "filename": "src/test/ui/pattern/usefulness/struct-pattern-match-useless.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-pattern-match-useless.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-pattern-match-useless.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-pattern-match-useless.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1,8 +1,10 @@\n error: unreachable pattern\n   --> $DIR/struct-pattern-match-useless.rs:12:9\n    |\n+LL |         Foo { x: _x, y: _y } => (),\n+   |         -------------------- matches any value\n LL |         Foo { .. } => ()\n-   |         ^^^^^^^^^^\n+   |         ^^^^^^^^^^ unreachable pattern\n    |\n note: lint level defined here\n   --> $DIR/struct-pattern-match-useless.rs:1:9"}, {"sha": "e4f4d4262b64d54e21adcf2375edef1f54a362f2", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/feature-gate.gated.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.gated.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1,8 +1,8 @@\n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/feature-gate.rs:11:29\n+error: fatal error triggered by #[rustc_error]\n+  --> $DIR/feature-gate.rs:16:1\n    |\n-LL | const fn get_assoc_const<S: ?const T>() -> i32 { <S as T>::CONST }\n-   |                             ^^^^^^^^\n+LL | fn main() {}\n+   | ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d600b53e448750bfb6a76cec02e8d9f5ac575b36", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/feature-gate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -3,13 +3,14 @@\n \n #![cfg_attr(gated, feature(const_trait_bound_opt_out))]\n #![allow(incomplete_features)]\n+#![feature(rustc_attrs)]\n \n trait T {\n     const CONST: i32;\n }\n \n const fn get_assoc_const<S: ?const T>() -> i32 { <S as T>::CONST }\n //[stock]~^ ERROR `?const` on trait bounds is experimental\n-//[stock,gated]~^^ ERROR `?const` on trait bounds is not yet implemented\n \n-fn main() {}\n+#[rustc_error]\n+fn main() {} //[gated]~ ERROR fatal error triggered by #[rustc_error]"}, {"sha": "fbd3840cb1d2bc1ffe53c784b24f401cce66bcfe", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/feature-gate.stock.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.stock.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1,18 +1,12 @@\n error[E0658]: `?const` on trait bounds is experimental\n-  --> $DIR/feature-gate.rs:11:29\n+  --> $DIR/feature-gate.rs:12:29\n    |\n LL | const fn get_assoc_const<S: ?const T>() -> i32 { <S as T>::CONST }\n    |                             ^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/67794\n    = help: add `#![feature(const_trait_bound_opt_out)]` to the crate attributes to enable\n \n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/feature-gate.rs:11:29\n-   |\n-LL | const fn get_assoc_const<S: ?const T>() -> i32 { <S as T>::CONST }\n-   |                             ^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "f5561a922ddcd7555d6803c57332fc405f372266", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-impl-trait.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -8,18 +8,14 @@ impl T for S {}\n \n fn rpit() -> impl ?const T { S }\n //~^ ERROR `?const` is not permitted in `impl Trait`\n-//~| ERROR `?const` on trait bounds is not yet implemented\n \n fn apit(_: impl ?const T) {}\n //~^ ERROR `?const` is not permitted in `impl Trait`\n-//~| ERROR `?const` on trait bounds is not yet implemented\n \n fn rpit_assoc_bound() -> impl IntoIterator<Item: ?const T> { Some(S) }\n //~^ ERROR `?const` is not permitted in `impl Trait`\n-//~| ERROR `?const` on trait bounds is not yet implemented\n \n fn apit_assoc_bound(_: impl IntoIterator<Item: ?const T>) {}\n //~^ ERROR `?const` is not permitted in `impl Trait`\n-//~| ERROR `?const` on trait bounds is not yet implemented\n \n fn main() {}"}, {"sha": "06cd00a956a2d99999ad837e585e3c4668af4404", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-impl-trait.stderr", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -5,46 +5,22 @@ LL | fn rpit() -> impl ?const T { S }\n    |                   ^^^^^^^^\n \n error: `?const` is not permitted in `impl Trait`\n-  --> $DIR/in-impl-trait.rs:13:17\n+  --> $DIR/in-impl-trait.rs:12:17\n    |\n LL | fn apit(_: impl ?const T) {}\n    |                 ^^^^^^^^\n \n error: `?const` is not permitted in `impl Trait`\n-  --> $DIR/in-impl-trait.rs:17:50\n+  --> $DIR/in-impl-trait.rs:15:50\n    |\n LL | fn rpit_assoc_bound() -> impl IntoIterator<Item: ?const T> { Some(S) }\n    |                                                  ^^^^^^^^\n \n error: `?const` is not permitted in `impl Trait`\n-  --> $DIR/in-impl-trait.rs:21:48\n+  --> $DIR/in-impl-trait.rs:18:48\n    |\n LL | fn apit_assoc_bound(_: impl IntoIterator<Item: ?const T>) {}\n    |                                                ^^^^^^^^\n \n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/in-impl-trait.rs:9:19\n-   |\n-LL | fn rpit() -> impl ?const T { S }\n-   |                   ^^^^^^^^\n-\n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/in-impl-trait.rs:13:17\n-   |\n-LL | fn apit(_: impl ?const T) {}\n-   |                 ^^^^^^^^\n-\n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/in-impl-trait.rs:17:50\n-   |\n-LL | fn rpit_assoc_bound() -> impl IntoIterator<Item: ?const T> { Some(S) }\n-   |                                                  ^^^^^^^^\n-\n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/in-impl-trait.rs:21:48\n-   |\n-LL | fn apit_assoc_bound(_: impl IntoIterator<Item: ?const T>) {}\n-   |                                                ^^^^^^^^\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "fc9ed5b1dc22e10ab2101576d623266c0dccef17", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-trait-bounds.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -4,6 +4,5 @@\n trait Super {}\n trait T: ?const Super {}\n //~^ ERROR `?const` is not permitted in supertraits\n-//~| ERROR `?const` on trait bounds is not yet implemented\n \n fn main() {}"}, {"sha": "a0d8f95acd2a839313f73b39b3ed399f9f351b68", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-trait-bounds.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -4,11 +4,5 @@ error: `?const` is not permitted in supertraits\n LL | trait T: ?const Super {}\n    |          ^^^^^^^^^^^^\n \n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/in-trait-bounds.rs:5:10\n-   |\n-LL | trait T: ?const Super {}\n-   |          ^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "b3d1f48ace147403190ef7e220b17950619c95c1", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-trait-object.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -9,14 +9,11 @@ impl T for S {}\n // An inherent impl for the trait object `?const T`.\n impl ?const T {}\n //~^ ERROR `?const` is not permitted in trait objects\n-//~| ERROR `?const` on trait bounds is not yet implemented\n \n fn trait_object() -> &'static dyn ?const T { &S }\n //~^ ERROR `?const` is not permitted in trait objects\n-//~| ERROR `?const` on trait bounds is not yet implemented\n \n fn trait_object_in_apit(_: impl IntoIterator<Item = Box<dyn ?const T>>) {}\n //~^ ERROR `?const` is not permitted in trait objects\n-//~| ERROR `?const` on trait bounds is not yet implemented\n \n fn main() {}"}, {"sha": "331fe0423fa9499abfedb7cb525dbc99bc9fb178", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-trait-object.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -5,34 +5,16 @@ LL | impl ?const T {}\n    |      ^^^^^^^^\n \n error: `?const` is not permitted in trait objects\n-  --> $DIR/in-trait-object.rs:14:35\n+  --> $DIR/in-trait-object.rs:13:35\n    |\n LL | fn trait_object() -> &'static dyn ?const T { &S }\n    |                                   ^^^^^^^^\n \n error: `?const` is not permitted in trait objects\n-  --> $DIR/in-trait-object.rs:18:61\n+  --> $DIR/in-trait-object.rs:16:61\n    |\n LL | fn trait_object_in_apit(_: impl IntoIterator<Item = Box<dyn ?const T>>) {}\n    |                                                             ^^^^^^^^\n \n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/in-trait-object.rs:10:6\n-   |\n-LL | impl ?const T {}\n-   |      ^^^^^^^^\n-\n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/in-trait-object.rs:14:35\n-   |\n-LL | fn trait_object() -> &'static dyn ?const T { &S }\n-   |                                   ^^^^^^^^\n-\n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/in-trait-object.rs:18:61\n-   |\n-LL | fn trait_object_in_apit(_: impl IntoIterator<Item = Box<dyn ?const T>>) {}\n-   |                                                             ^^^^^^^^\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "c2c8689e2942bcd33ba2ad795acd56b809544537", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/with-maybe-sized.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -3,6 +3,5 @@\n \n struct S<T: ?const ?Sized>(std::marker::PhantomData<T>);\n //~^ ERROR `?const` and `?` are mutually exclusive\n-//~| ERROR `?const` on trait bounds is not yet implemented\n \n fn main() {}"}, {"sha": "e8e9d6c1e76215671845463d21c0656e70b5e111", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/with-maybe-sized.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -4,11 +4,5 @@ error: `?const` and `?` are mutually exclusive\n LL | struct S<T: ?const ?Sized>(std::marker::PhantomData<T>);\n    |             ^^^^^^^^^^^^^\n \n-error: `?const` on trait bounds is not yet implemented\n-  --> $DIR/with-maybe-sized.rs:4:13\n-   |\n-LL | struct S<T: ?const ?Sized>(std::marker::PhantomData<T>);\n-   |             ^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "7f064c0c53ade98d5fb14af17eff69ecc2080ee2", "filename": "src/test/ui/rfc-2632-const-trait-impl/inherent-impl.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags: -Z parse-only\n-\n #![feature(const_trait_impl)]\n #![feature(const_trait_bound_opt_out)]\n #![allow(incomplete_features)]\n@@ -8,7 +6,12 @@\n struct S;\n trait T {}\n \n+impl const S {}\n+//~^ ERROR inherent impls cannot be `const`\n+//~| ERROR const trait impls are not yet implemented\n+\n impl const T {}\n-//~^ ERROR `const` cannot modify an inherent impl\n+//~^ ERROR inherent impls cannot be `const`\n+//~| ERROR const trait impls are not yet implemented\n \n fn main() {}"}, {"sha": "508c6f4c747e1745839b039208be5a974289164d", "filename": "src/test/ui/rfc-2632-const-trait-impl/inherent-impl.stderr", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.stderr?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -1,10 +1,30 @@\n-error: `const` cannot modify an inherent impl\n-  --> $DIR/inherent-impl.rs:11:6\n+error: inherent impls cannot be `const`\n+  --> $DIR/inherent-impl.rs:9:1\n+   |\n+LL | impl const S {}\n+   | ^^^^^^^^^^^^^^^\n+   |\n+   = note: only trait implementations may be annotated with `const`\n+\n+error: inherent impls cannot be `const`\n+  --> $DIR/inherent-impl.rs:13:1\n    |\n LL | impl const T {}\n-   |      ^^^^^\n+   | ^^^^^^^^^^^^^^^\n+   |\n+   = note: only trait implementations may be annotated with `const`\n+\n+error: const trait impls are not yet implemented\n+  --> $DIR/inherent-impl.rs:9:1\n+   |\n+LL | impl const S {}\n+   | ^^^^^^^^^^^^^^^\n+\n+error: const trait impls are not yet implemented\n+  --> $DIR/inherent-impl.rs:13:1\n    |\n-   = help: only a trait impl can be `const`\n+LL | impl const T {}\n+   | ^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n "}, {"sha": "408be83b926e2bb6c709db611cb2851d66dfe2ee", "filename": "src/tools/tidy/src/debug_artifacts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Fdebug_artifacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Fdebug_artifacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdebug_artifacts.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -2,7 +2,7 @@\n \n use std::path::{Path, PathBuf};\n \n-const GRAPHVIZ_POSTFLOW_MSG: &'static str = \"`borrowck_graphviz_postflow` attribute in test\";\n+const GRAPHVIZ_POSTFLOW_MSG: &str = \"`borrowck_graphviz_postflow` attribute in test\";\n \n pub fn check(path: &Path, bad: &mut bool) {\n     let test_dir: PathBuf = path.join(\"test\");"}, {"sha": "428c57d3ee82236ba3f0c707003ea9b883675080", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -53,7 +53,7 @@ fn extract_error_codes(f: &str, error_codes: &mut HashMap<String, bool>, path: &\n                     error_codes.insert(err_code.clone(), false);\n                 }\n                 // Now we extract the tests from the markdown file!\n-                let md = some_or_continue!(s.splitn(2, \"include_str!(\\\"\").skip(1).next());\n+                let md = some_or_continue!(s.splitn(2, \"include_str!(\\\"\").nth(1));\n                 let md_file_name = some_or_continue!(md.splitn(2, \"\\\")\").next());\n                 let path = some_or_continue!(path.parent()).join(md_file_name);\n                 match read_to_string(&path) {\n@@ -84,7 +84,7 @@ fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, boo\n         let s = line.trim();\n         if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n             if let Some(err_code) = s.splitn(2, ']').next() {\n-                if let Some(err_code) = err_code.splitn(2, '[').skip(1).next() {\n+                if let Some(err_code) = err_code.splitn(2, '[').nth(1) {\n                     let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n                     *nb = true;\n                 }"}, {"sha": "12f93a87cb1729818bccf8636ef6f907441ed553", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -232,7 +232,7 @@ fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n             }\n         }\n     }\n-    return false;\n+    false\n }\n \n pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n@@ -344,7 +344,7 @@ fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features\n                 }\n                 None\n             } else {\n-                let s = issue_str.split('(').nth(1).unwrap().split(')').nth(0).unwrap();\n+                let s = issue_str.split('(').nth(1).unwrap().split(')').next().unwrap();\n                 Some(s.parse().unwrap())\n             };\n             Some((name.to_owned(), Feature { level, since, has_gate_test: false, tracking_issue }))"}, {"sha": "620be2f9852305d2e1bbbd08f7730b8e4324839d", "filename": "src/tools/tidy/src/features/version.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -38,7 +38,7 @@ impl FromStr for Version {\n \n         let parts = [part()?, part()?, part()?];\n \n-        if let Some(_) = iter.next() {\n+        if iter.next().is_some() {\n             // Ensure we don't have more than 3 parts.\n             return Err(ParseVersionError::WrongNumberOfParts);\n         }"}, {"sha": "4247fcb3b7f53129ec96ca7fa7a8602beb011074", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8897b7b51636f157630e6639b711d698e1d101/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=5e8897b7b51636f157630e6639b711d698e1d101", "patch": "@@ -58,7 +58,7 @@ enum LIUState {\n fn line_is_url(columns: usize, line: &str) -> bool {\n     // more basic check for error_codes.rs, to avoid complexity in implementing two state machines\n     if columns == ERROR_CODE_COLS {\n-        return line.starts_with(\"[\") && line.contains(\"]:\") && line.contains(\"http\");\n+        return line.starts_with('[') && line.contains(\"]:\") && line.contains(\"http\");\n     }\n \n     use self::LIUState::*;"}]}