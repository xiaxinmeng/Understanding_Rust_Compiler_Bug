{"sha": "f448cdff9d05fcc8c907820bb5af34a383beee9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NDhjZGZmOWQwNWZjYzhjOTA3ODIwYmI1YWYzNGEzODNiZWVlOWQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-18T18:05:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-18T18:05:45Z"}, "message": "Rollup merge of #41361 - arielb1:move-mir-init, r=pnkfelix\n\nlower `move_val_init` during MIR construction\n\nBecause of its \"magic\" order-of-evaluation semantics, `move_val_init` must be lowered during MIR construction in order to work without needing a temporary.\n\nr? @eddyb", "tree": {"sha": "ebfb19e20683794ca380ca0444c5254390821f5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebfb19e20683794ca380ca0444c5254390821f5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f448cdff9d05fcc8c907820bb5af34a383beee9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f448cdff9d05fcc8c907820bb5af34a383beee9d", "html_url": "https://github.com/rust-lang/rust/commit/f448cdff9d05fcc8c907820bb5af34a383beee9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f448cdff9d05fcc8c907820bb5af34a383beee9d/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceaa55ea451c8ff40ce9c91f5d9c2f2b30e96d3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceaa55ea451c8ff40ce9c91f5d9c2f2b30e96d3b", "html_url": "https://github.com/rust-lang/rust/commit/ceaa55ea451c8ff40ce9c91f5d9c2f2b30e96d3b"}, {"sha": "ed3810bf5e284b243b4500951652839235dd2113", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3810bf5e284b243b4500951652839235dd2113", "html_url": "https://github.com/rust-lang/rust/commit/ed3810bf5e284b243b4500951652839235dd2113"}], "stats": {"total": 122, "additions": 79, "deletions": 43}, "files": [{"sha": "a334923546fb2df76a8c4ccb73cd242bf11ae6ab", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=f448cdff9d05fcc8c907820bb5af34a383beee9d", "patch": "@@ -38,9 +38,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"expr_as_temp(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { .. } = expr.kind {\n-            span_bug!(expr.span, \"unexpected scope expression in as_temp: {:?}\",\n-                      expr);\n+        if let ExprKind::Scope { extent, value } = expr.kind {\n+            return this.in_scope(extent, block, |this| {\n+                this.as_temp(block, temp_lifetime, value)\n+            });\n         }\n \n         let expr_ty = expr.ty.clone();"}, {"sha": "5982d3bdc81a49191e8e1771261ac7df5d9912c0", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=f448cdff9d05fcc8c907820bb5af34a383beee9d", "patch": "@@ -16,6 +16,8 @@ use hair::*;\n use rustc::ty;\n use rustc::mir::*;\n \n+use syntax::abi::Abi;\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n@@ -206,25 +208,49 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     _ => false\n                 };\n+                let intrinsic = match ty.sty {\n+                    ty::TyFnDef(def_id, _, ref f) if\n+                        f.abi() == Abi::RustIntrinsic ||\n+                        f.abi() == Abi::PlatformIntrinsic =>\n+                    {\n+                        Some(this.hir.tcx().item_name(def_id).as_str())\n+                    }\n+                    _ => None\n+                };\n+                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n                 let fun = unpack!(block = this.as_local_operand(block, fun));\n-                let args: Vec<_> =\n-                    args.into_iter()\n-                        .map(|arg| unpack!(block = this.as_local_operand(block, arg)))\n-                        .collect();\n+                if intrinsic == Some(\"move_val_init\") {\n+                    // `move_val_init` has \"magic\" semantics - the second argument is\n+                    // always evaluated \"directly\" into the first one.\n \n-                let success = this.cfg.start_new_block();\n-                let cleanup = this.diverge_cleanup();\n-                this.cfg.terminate(block, source_info, TerminatorKind::Call {\n-                    func: fun,\n-                    args: args,\n-                    cleanup: cleanup,\n-                    destination: if diverges {\n-                        None\n-                    } else {\n-                        Some ((destination.clone(), success))\n-                    }\n-                });\n-                success.unit()\n+                    let mut args = args.into_iter();\n+                    let ptr = args.next().expect(\"0 arguments to `move_val_init`\");\n+                    let val = args.next().expect(\"1 argument to `move_val_init`\");\n+                    assert!(args.next().is_none(), \">2 arguments to `move_val_init`\");\n+\n+                    let topmost_scope = this.topmost_scope();\n+                    let ptr = unpack!(block = this.as_temp(block, Some(topmost_scope), ptr));\n+                    this.into(&ptr.deref(), block, val)\n+                } else {\n+                    let args: Vec<_> =\n+                        args.into_iter()\n+                            .map(|arg| unpack!(block = this.as_local_operand(block, arg)))\n+                            .collect();\n+\n+                    let success = this.cfg.start_new_block();\n+                    let cleanup = this.diverge_cleanup();\n+                    this.cfg.terminate(block, source_info, TerminatorKind::Call {\n+                        func: fun,\n+                        args: args,\n+                        cleanup: cleanup,\n+                        destination: if diverges {\n+                            None\n+                        } else {\n+                            Some ((destination.clone(), success))\n+                        }\n+                    });\n+                    success.unit()\n+                }\n             }\n \n             // These cases don't actually need a destination"}, {"sha": "4d70540a7c688166b58f1bb265a49decd31cb5dc", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=f448cdff9d05fcc8c907820bb5af34a383beee9d", "patch": "@@ -205,12 +205,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                 patch: MirPatch::new(&mir),\n                 tcx, param_env\n             };\n-            let dropee = Lvalue::Projection(\n-                box Projection {\n-                    base: Lvalue::Local(Local::new(1+0)),\n-                    elem: ProjectionElem::Deref\n-                }\n-                );\n+            let dropee = Lvalue::Local(Local::new(1+0)).deref();\n             let resume_block = elaborator.patch.resume_block();\n             elaborate_drops::elaborate_drop(\n                 &mut elaborator,\n@@ -310,9 +305,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     let rcvr = match rcvr_adjustment {\n         Adjustment::Identity => Operand::Consume(rcvr_l),\n-        Adjustment::Deref => Operand::Consume(Lvalue::Projection(\n-            box Projection { base: rcvr_l, elem: ProjectionElem::Deref }\n-        )),\n+        Adjustment::Deref => Operand::Consume(rcvr_l.deref()),\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n             let re_erased = tcx.mk_region(ty::ReErased);\n@@ -352,10 +345,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     if let Some(untuple_args) = untuple_args {\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n             let arg_lv = Lvalue::Local(Local::new(1+1));\n-            Operand::Consume(Lvalue::Projection(box Projection {\n-                base: arg_lv,\n-                elem: ProjectionElem::Field(Field::new(i), *ity)\n-            }))\n+            Operand::Consume(arg_lv.field(Field::new(i), *ity))\n         }));\n     } else {\n         args.extend((1..sig.inputs().len()).map(|i| {"}, {"sha": "0f5a38ac7f6b886343372514dd9ce887baa29a08", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f448cdff9d05fcc8c907820bb5af34a383beee9d", "patch": "@@ -418,16 +418,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n \n-                if intrinsic == Some(\"move_val_init\") {\n-                    let &(_, target) = destination.as_ref().unwrap();\n-                    // The first argument is a thin destination pointer.\n-                    let llptr = self.trans_operand(&bcx, &args[0]).immediate();\n-                    let val = self.trans_operand(&bcx, &args[1]);\n-                    self.store_operand(&bcx, llptr, None, val);\n-                    funclet_br(self, bcx, target);\n-                    return;\n-                }\n-\n                 if intrinsic == Some(\"transmute\") {\n                     let &(ref dest, target) = destination.as_ref().unwrap();\n                     self.trans_transmute(&bcx, &args[0], dest);"}, {"sha": "98b7db60b68fc8a6016519ee0fdaa0884c5fc285", "filename": "src/test/codegen/move-val-init.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Ftest%2Fcodegen%2Fmove-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f448cdff9d05fcc8c907820bb5af34a383beee9d/src%2Ftest%2Fcodegen%2Fmove-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmove-val-init.rs?ref=f448cdff9d05fcc8c907820bb5af34a383beee9d", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![feature(core_intrinsics)]\n+#![crate_type = \"lib\"]\n+\n+// test that `move_val_init` actually avoids big allocas\n+\n+use std::intrinsics::move_val_init;\n+\n+pub struct Big {\n+    pub data: [u8; 65536]\n+}\n+\n+// CHECK-LABEL: @test_mvi\n+#[no_mangle]\n+pub unsafe fn test_mvi(target: *mut Big, make_big: fn() -> Big) {\n+    // CHECK: call void %1(%Big*{{[^%]*}} %0)\n+    move_val_init(target, make_big());\n+}"}]}