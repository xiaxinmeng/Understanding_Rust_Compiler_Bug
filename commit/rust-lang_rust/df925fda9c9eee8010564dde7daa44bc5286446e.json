{"sha": "df925fda9c9eee8010564dde7daa44bc5286446e", "node_id": "C_kwDOAAsO6NoAKGRmOTI1ZmRhOWM5ZWVlODAxMDU2NGRkZTdkYWE0NGJjNTI4NjQ0NmU", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-06-18T02:10:07Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-06-18T02:10:07Z"}, "message": "review fixups", "tree": {"sha": "8be972508319a7ee3c041e00e0979ae188047791", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8be972508319a7ee3c041e00e0979ae188047791"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df925fda9c9eee8010564dde7daa44bc5286446e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df925fda9c9eee8010564dde7daa44bc5286446e", "html_url": "https://github.com/rust-lang/rust/commit/df925fda9c9eee8010564dde7daa44bc5286446e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df925fda9c9eee8010564dde7daa44bc5286446e/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af514240089891ddfaa3b9368dd255513141e7a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/af514240089891ddfaa3b9368dd255513141e7a9", "html_url": "https://github.com/rust-lang/rust/commit/af514240089891ddfaa3b9368dd255513141e7a9"}], "stats": {"total": 113, "additions": 43, "deletions": 70}, "files": [{"sha": "af0b5639d61363c192d27d52ff9743f21943ca61", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df925fda9c9eee8010564dde7daa44bc5286446e/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df925fda9c9eee8010564dde7daa44bc5286446e/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=df925fda9c9eee8010564dde7daa44bc5286446e", "patch": "@@ -498,12 +498,13 @@ impl server::TokenStream for Rustc<'_, '_> {\n         }\n         builder.build()\n     }\n-    fn into_iter(\n+    fn into_trees(\n         &mut self,\n         stream: Self::TokenStream,\n     ) -> Vec<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n-        // FIXME: This is a raw port of the previous approach, and can probably\n-        // be optimized.\n+        // FIXME: This is a raw port of the previous approach (which had a\n+        // `TokenStreamIter` server-side object with a single `next` method),\n+        // and can probably be optimized (for bulk conversion).\n         let mut cursor = stream.into_trees();\n         let mut stack = Vec::new();\n         let mut tts = Vec::new();"}, {"sha": "4e931569ef6337f625b95ec5f3e7ba9fb2c05070", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/df925fda9c9eee8010564dde7daa44bc5286446e/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df925fda9c9eee8010564dde7daa44bc5286446e/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=df925fda9c9eee8010564dde7daa44bc5286446e", "patch": "@@ -73,9 +73,9 @@ macro_rules! with_api {\n                 ) -> $S::TokenStream;\n                 fn concat_streams(\n                     base: Option<$S::TokenStream>,\n-                    trees: Vec<$S::TokenStream>,\n+                    streams: Vec<$S::TokenStream>,\n                 ) -> $S::TokenStream;\n-                fn into_iter(\n+                fn into_trees(\n                     $self: $S::TokenStream\n                 ) -> Vec<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n             },\n@@ -307,32 +307,6 @@ impl<'a, T, M> Unmark for &'a mut Marked<T, M> {\n     }\n }\n \n-impl<T: Mark> Mark for Option<T> {\n-    type Unmarked = Option<T::Unmarked>;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        unmarked.map(T::mark)\n-    }\n-}\n-impl<T: Unmark> Unmark for Option<T> {\n-    type Unmarked = Option<T::Unmarked>;\n-    fn unmark(self) -> Self::Unmarked {\n-        self.map(T::unmark)\n-    }\n-}\n-\n-impl<T: Mark, E: Mark> Mark for Result<T, E> {\n-    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        unmarked.map(T::mark).map_err(E::mark)\n-    }\n-}\n-impl<T: Unmark, E: Unmark> Unmark for Result<T, E> {\n-    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n-    fn unmark(self) -> Self::Unmarked {\n-        self.map(T::unmark).map_err(E::unmark)\n-    }\n-}\n-\n impl<T: Mark> Mark for Vec<T> {\n     type Unmarked = Vec<T::Unmarked>;\n     fn mark(unmarked: Self::Unmarked) -> Self {\n@@ -378,7 +352,6 @@ mark_noop! {\n     Level,\n     LineColumn,\n     Spacing,\n-    Bound<usize>,\n }\n \n rpc_encode_decode!(\n@@ -438,6 +411,28 @@ macro_rules! compound_traits {\n     };\n }\n \n+compound_traits!(\n+    enum Bound<T> {\n+        Included(x),\n+        Excluded(x),\n+        Unbounded,\n+    }\n+);\n+\n+compound_traits!(\n+    enum Option<T> {\n+        Some(t),\n+        None,\n+    }\n+);\n+\n+compound_traits!(\n+    enum Result<T, E> {\n+        Ok(t),\n+        Err(e),\n+    }\n+);\n+\n #[derive(Clone)]\n pub enum TokenTree<G, P, I, L> {\n     Group(G),"}, {"sha": "e9d7a46c06f6d270d66e848788e9f01fbd776e54", "filename": "library/proc_macro/src/bridge/rpc.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/df925fda9c9eee8010564dde7daa44bc5286446e/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df925fda9c9eee8010564dde7daa44bc5286446e/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs?ref=df925fda9c9eee8010564dde7daa44bc5286446e", "patch": "@@ -4,7 +4,6 @@ use std::any::Any;\n use std::char;\n use std::io::Write;\n use std::num::NonZeroU32;\n-use std::ops::Bound;\n use std::str;\n \n pub(super) type Writer = super::buffer::Buffer;\n@@ -186,28 +185,6 @@ impl<'a, S, A: for<'s> DecodeMut<'a, 's, S>, B: for<'s> DecodeMut<'a, 's, S>> De\n     }\n }\n \n-rpc_encode_decode!(\n-    enum Bound<T> {\n-        Included(x),\n-        Excluded(x),\n-        Unbounded,\n-    }\n-);\n-\n-rpc_encode_decode!(\n-    enum Option<T> {\n-        None,\n-        Some(x),\n-    }\n-);\n-\n-rpc_encode_decode!(\n-    enum Result<T, E> {\n-        Ok(x),\n-        Err(e),\n-    }\n-);\n-\n impl<S> Encode<S> for &[u8] {\n     fn encode(self, w: &mut Writer, s: &mut S) {\n         self.len().encode(w, s);"}, {"sha": "5e1289ec79d30fcaa52b6bb875fe883d20a7ec96", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/df925fda9c9eee8010564dde7daa44bc5286446e/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df925fda9c9eee8010564dde7daa44bc5286446e/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=df925fda9c9eee8010564dde7daa44bc5286446e", "patch": "@@ -235,7 +235,7 @@ impl From<TokenTree> for TokenStream {\n \n /// Non-generic helper for implementing `FromIterator<TokenTree>` and\n /// `Extend<TokenTree>` with less monomorphization in calling crates.\n-struct ExtendStreamWithTreesHelper {\n+struct ConcatTreesHelper {\n     trees: Vec<\n         bridge::TokenTree<\n             bridge::client::Group,\n@@ -246,9 +246,9 @@ struct ExtendStreamWithTreesHelper {\n     >,\n }\n \n-impl ExtendStreamWithTreesHelper {\n+impl ConcatTreesHelper {\n     fn new(capacity: usize) -> Self {\n-        ExtendStreamWithTreesHelper { trees: Vec::with_capacity(capacity) }\n+        ConcatTreesHelper { trees: Vec::with_capacity(capacity) }\n     }\n \n     fn push(&mut self, tree: TokenTree) {\n@@ -263,7 +263,7 @@ impl ExtendStreamWithTreesHelper {\n         }\n     }\n \n-    fn extend(self, stream: &mut TokenStream) {\n+    fn append_to(self, stream: &mut TokenStream) {\n         if self.trees.is_empty() {\n             return;\n         }\n@@ -273,13 +273,13 @@ impl ExtendStreamWithTreesHelper {\n \n /// Non-generic helper for implementing `FromIterator<TokenStream>` and\n /// `Extend<TokenStream>` with less monomorphization in calling crates.\n-struct ExtendStreamWithStreamsHelper {\n+struct ConcatStreamsHelper {\n     streams: Vec<bridge::client::TokenStream>,\n }\n \n-impl ExtendStreamWithStreamsHelper {\n+impl ConcatStreamsHelper {\n     fn new(capacity: usize) -> Self {\n-        ExtendStreamWithStreamsHelper { streams: Vec::with_capacity(capacity) }\n+        ConcatStreamsHelper { streams: Vec::with_capacity(capacity) }\n     }\n \n     fn push(&mut self, stream: TokenStream) {\n@@ -296,7 +296,7 @@ impl ExtendStreamWithStreamsHelper {\n         }\n     }\n \n-    fn extend(mut self, stream: &mut TokenStream) {\n+    fn append_to(mut self, stream: &mut TokenStream) {\n         if self.streams.is_empty() {\n             return;\n         }\n@@ -314,7 +314,7 @@ impl ExtendStreamWithStreamsHelper {\n impl iter::FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n         let iter = trees.into_iter();\n-        let mut builder = ExtendStreamWithTreesHelper::new(iter.size_hint().0);\n+        let mut builder = ConcatTreesHelper::new(iter.size_hint().0);\n         iter.for_each(|tree| builder.push(tree));\n         builder.build()\n     }\n@@ -326,7 +326,7 @@ impl iter::FromIterator<TokenTree> for TokenStream {\n impl iter::FromIterator<TokenStream> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n         let iter = streams.into_iter();\n-        let mut builder = ExtendStreamWithStreamsHelper::new(iter.size_hint().0);\n+        let mut builder = ConcatStreamsHelper::new(iter.size_hint().0);\n         iter.for_each(|stream| builder.push(stream));\n         builder.build()\n     }\n@@ -336,19 +336,19 @@ impl iter::FromIterator<TokenStream> for TokenStream {\n impl Extend<TokenTree> for TokenStream {\n     fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n         let iter = trees.into_iter();\n-        let mut builder = ExtendStreamWithTreesHelper::new(iter.size_hint().0);\n+        let mut builder = ConcatTreesHelper::new(iter.size_hint().0);\n         iter.for_each(|tree| builder.push(tree));\n-        builder.extend(self);\n+        builder.append_to(self);\n     }\n }\n \n #[stable(feature = \"token_stream_extend\", since = \"1.30.0\")]\n impl Extend<TokenStream> for TokenStream {\n     fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n         let iter = streams.into_iter();\n-        let mut builder = ExtendStreamWithStreamsHelper::new(iter.size_hint().0);\n+        let mut builder = ConcatStreamsHelper::new(iter.size_hint().0);\n         iter.for_each(|stream| builder.push(stream));\n-        builder.extend(self);\n+        builder.append_to(self);\n     }\n }\n \n@@ -393,7 +393,7 @@ pub mod token_stream {\n         type IntoIter = IntoIter;\n \n         fn into_iter(self) -> IntoIter {\n-            IntoIter(self.0.map(|v| v.into_iter()).unwrap_or_default().into_iter())\n+            IntoIter(self.0.map(|v| v.into_trees()).unwrap_or_default().into_iter())\n         }\n     }\n }"}]}