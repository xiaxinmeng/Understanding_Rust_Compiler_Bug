{"sha": "ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZDkyYzJhNGU1ZWQ2MzRiYmJkNmQzYTViZDQ5MWM0N2I4MGY2NDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-16T12:49:21Z"}, "committer": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-01T15:04:26Z"}, "message": "correct subtle bug in the type variable code", "tree": {"sha": "b93490e4910d6271c7d42c562e3a8559bb6b3ba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b93490e4910d6271c7d42c562e3a8559bb6b3ba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642", "html_url": "https://github.com/rust-lang/rust/commit/ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57a593fcbb6af3db567c27b70b3a03c5a244705f", "url": "https://api.github.com/repos/rust-lang/rust/commits/57a593fcbb6af3db567c27b70b3a03c5a244705f", "html_url": "https://github.com/rust-lang/rust/commit/57a593fcbb6af3db567c27b70b3a03c5a244705f"}], "stats": {"total": 171, "additions": 63, "deletions": 108}, "files": [{"sha": "9e98c16c819b9c89655bbb7604bedf0a48b66380", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 63, "deletions": 108, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642", "patch": "@@ -12,15 +12,18 @@ use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n \n-use std::cmp::min;\n use std::marker::PhantomData;\n use std::u32;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n \n pub struct TypeVariableTable<'tcx> {\n-    values: sv::SnapshotVec<Delegate>,\n+    /// Extra data for each type variable, such as the origin. This is\n+    /// not stored in the unification table since, when we inquire\n+    /// after the origin of a variable X, we want the origin of **that\n+    /// variable X**, not the origin of some other variable Y with\n+    /// which X has been unified.\n+    var_data: Vec<TypeVariableData>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n     /// constraint `?X == ?Y`. This table also stores, for each key,\n@@ -82,21 +85,20 @@ enum TypeVariableValue<'tcx> {\n }\n \n pub struct Snapshot<'tcx> {\n-    snapshot: sv::Snapshot,\n+    /// number of variables at the time of the snapshot\n+    num_vars: usize,\n+\n+    /// snapshot from the `eq_relations` table\n     eq_snapshot: ut::Snapshot<ut::InPlace<TyVidEqKey<'tcx>>>,\n-    sub_snapshot: ut::Snapshot<ut::InPlace<ty::TyVid>>,\n-}\n \n-struct Instantiate {\n-    vid: ty::TyVid,\n+    /// snapshot from the `sub_relations` table\n+    sub_snapshot: ut::Snapshot<ut::InPlace<ty::TyVid>>,\n }\n \n-struct Delegate;\n-\n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n         TypeVariableTable {\n-            values: sv::SnapshotVec::new(),\n+            var_data: Vec::new(),\n             eq_relations: ut::UnificationTable::new(),\n             sub_relations: ut::UnificationTable::new(),\n         }\n@@ -107,15 +109,15 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n-        self.values.get(vid.index as usize).diverging\n+        self.var_data[vid.index as usize].diverging\n     }\n \n     /// Returns the origin that was given when `vid` was created.\n     ///\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n     pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n-        &self.values.get(vid.index as usize).origin\n+        &self.var_data[vid.index as usize].origin\n     }\n \n     /// Records that `a == b`, depending on `dir`.\n@@ -147,11 +149,6 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                       \"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n                       vid, ty, self.eq_relations.probe_value(vid));\n         self.eq_relations.union_value(vid, TypeVariableValue::Known { value: ty });\n-\n-        // Hack: we only need this so that `types_escaping_snapshot`\n-        // can see what has been unified; see the Delegate impl for\n-        // more details.\n-        self.values.record(Instantiate { vid: vid });\n     }\n \n     /// Creates a new type variable.\n@@ -173,11 +170,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         let sub_key = self.sub_relations.new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n \n-        let index = self.values.push(TypeVariableData {\n-            origin,\n-            diverging,\n-        });\n-        assert_eq!(eq_key.vid.index, index as u32);\n+        assert_eq!(self.var_data.len(), sub_key.index as usize);\n+        self.var_data.push(TypeVariableData { origin, diverging });\n \n         debug!(\"new_var(index={:?}, diverging={:?}, origin={:?}\", eq_key.vid, diverging, origin);\n \n@@ -186,7 +180,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n     /// Returns the number of type variables created thus far.\n     pub fn num_vars(&self) -> usize {\n-        self.values.len()\n+        self.var_data.len()\n     }\n \n     /// Returns the \"root\" variable of `vid` in the `eq_relations`\n@@ -246,7 +240,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// be processed in a stack-like fashion.\n     pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n         Snapshot {\n-            snapshot: self.values.start_snapshot(),\n+            num_vars: self.var_data.len(),\n             eq_snapshot: self.eq_relations.snapshot(),\n             sub_snapshot: self.sub_relations.snapshot(),\n         }\n@@ -256,30 +250,21 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// snapshots created since that point must already have been\n     /// committed or rolled back.\n     pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n-        debug!(\"rollback_to{:?}\", {\n-            for action in self.values.actions_since_snapshot(&s.snapshot) {\n-                match *action {\n-                    sv::UndoLog::NewElem(index) => {\n-                        debug!(\"inference variable _#{}t popped\", index)\n-                    }\n-                    _ => { }\n-                }\n-            }\n-        });\n-\n-        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n-        self.values.rollback_to(snapshot);\n+        let Snapshot { num_vars, eq_snapshot, sub_snapshot } = s;\n+        debug!(\"type_variables::rollback_to(num_vars = {})\", num_vars);\n+        assert!(self.var_data.len() >= num_vars);\n         self.eq_relations.rollback_to(eq_snapshot);\n         self.sub_relations.rollback_to(sub_snapshot);\n+        self.var_data.truncate(num_vars);\n     }\n \n     /// Commits all changes since the snapshot was created, making\n     /// them permanent (unless this snapshot was created within\n     /// another snapshot). Any snapshots created since that point\n     /// must already have been committed or rolled back.\n     pub fn commit(&mut self, s: Snapshot<'tcx>) {\n-        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n-        self.values.commit(snapshot);\n+        let Snapshot { num_vars, eq_snapshot, sub_snapshot } = s;\n+        debug!(\"type_variables::commit(num_vars = {})\", num_vars);\n         self.eq_relations.commit(eq_snapshot);\n         self.sub_relations.commit(sub_snapshot);\n     }\n@@ -288,19 +273,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// ty-variables created during the snapshot, and the values\n     /// `{V2}` are the root variables that they were unified with,\n     /// along with their origin.\n-    pub fn types_created_since_snapshot(&mut self, s: &Snapshot<'tcx>) -> TypeVariableMap {\n-        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n-\n-        actions_since_snapshot\n+    pub fn types_created_since_snapshot(&mut self, snapshot: &Snapshot<'tcx>) -> TypeVariableMap {\n+        self.var_data\n             .iter()\n-            .filter_map(|action| match action {\n-                &sv::UndoLog::NewElem(index) => Some(ty::TyVid { index: index as u32 }),\n-                _ => None,\n-            })\n-            .map(|vid| {\n-                let origin = self.values.get(vid.index as usize).origin.clone();\n-                (vid, origin)\n-            })\n+            .enumerate()\n+            .skip(snapshot.num_vars) // skip those that existed when snapshot was taken\n+            .map(|(index, data)| (ty::TyVid { index: index as u32 }, data.origin))\n             .collect()\n     }\n \n@@ -310,47 +288,45 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// a type variable `V0`, then we started the snapshot, then we\n     /// created a type variable `V1`, unifed `V0` with `T0`, and\n     /// unified `V1` with `T1`, this function would return `{T0}`.\n-    pub fn types_escaping_snapshot(&mut self, s: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n-        let mut new_elem_threshold = u32::MAX;\n-        let mut escaping_types = Vec::new();\n-        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n-        debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n-        for action in actions_since_snapshot {\n-            match *action {\n-                sv::UndoLog::NewElem(index) => {\n-                    // if any new variables were created during the\n-                    // snapshot, remember the lower index (which will\n-                    // always be the first one we see). Note that this\n-                    // action must precede those variables being\n-                    // specified.\n-                    new_elem_threshold = min(new_elem_threshold, index as u32);\n-                    debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n-                }\n-\n-                sv::UndoLog::Other(Instantiate { vid, .. }) => {\n-                    if vid.index < new_elem_threshold {\n-                        // quick check to see if this variable was\n-                        // created since the snapshot started or not.\n-                        let escaping_type = match self.eq_relations.probe_value(vid) {\n-                            TypeVariableValue::Unknown => bug!(),\n-                            TypeVariableValue::Known { value } => value,\n-                        };\n-                        escaping_types.push(escaping_type);\n-                    }\n-                    debug!(\"SpecifyVar({:?}) new_elem_threshold={}\", vid, new_elem_threshold);\n-                }\n-\n-                _ => { }\n-            }\n-        }\n-\n+    pub fn types_escaping_snapshot(&mut self, snapshot: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n+        // We want to select only those instantiations that have\n+        // occurred since the snapshot *and* which affect some\n+        // variable that existed prior to the snapshot. This code just\n+        // affects all instantiatons that ever occurred which affect\n+        // variables prior to the snapshot.\n+        //\n+        // It's hard to do better than this, though, without changing\n+        // the unification table to prefer \"lower\" vids -- the problem\n+        // is that we may have a variable X (from before the snapshot)\n+        // and Y (from after the snapshot) which get unified, with Y\n+        // chosen as the new root. Now we are \"instantiating\" Y with a\n+        // value, but it escapes into X, but we wouldn't readily see\n+        // that. (In fact, earlier revisions of this code had this\n+        // bug; it was introduced when we added the `eq_relations`\n+        // table, but it's hard to create rust code that triggers it.)\n+        //\n+        // We could tell the table to prefer lower vids, and then we would\n+        // see the case above, but we would get less-well-balanced trees.\n+        //\n+        // Since I hope to kill the leak-check in this branch, and\n+        // that's the code which uses this logic anyway, I'm going to\n+        // use the less efficient algorithm for now.\n+        let mut escaping_types = Vec::with_capacity(snapshot.num_vars);\n+        escaping_types.extend(\n+            (0..snapshot.num_vars) // for all variables that pre-exist the snapshot...\n+                .map(|i| ty::TyVid { index: i as u32 })\n+                .filter_map(|vid| match self.eq_relations.probe_value(vid) {\n+                    TypeVariableValue::Unknown => None,\n+                    TypeVariableValue::Known { value } => Some(value),\n+                })); // ...collect what types they've been instantiated with.\n+        debug!(\"types_escaping_snapshot = {:?}\", escaping_types);\n         escaping_types\n     }\n \n     /// Returns indices of all variables that are not yet\n     /// instantiated.\n     pub fn unsolved_variables(&mut self) -> Vec<ty::TyVid> {\n-        (0..self.values.len())\n+        (0..self.var_data.len())\n             .filter_map(|i| {\n                 let vid = ty::TyVid { index: i as u32 };\n                 if self.probe(vid).is_some() {\n@@ -362,27 +338,6 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             .collect()\n     }\n }\n-\n-impl sv::SnapshotVecDelegate for Delegate {\n-    type Value = TypeVariableData;\n-    type Undo = Instantiate;\n-\n-    fn reverse(_values: &mut Vec<TypeVariableData>, _action: Instantiate) {\n-        // We don't actually have to *do* anything to reverse an\n-        // instanation; the value for a variable is stored in the\n-        // `eq_relations` and hence its rollback code will handle\n-        // it. In fact, we could *almost* just remove the\n-        // `SnapshotVec` entirely, except that we would have to\n-        // reproduce *some* of its logic, since we want to know which\n-        // type variables have been instantiated since the snapshot\n-        // was started, so we can implement `types_escaping_snapshot`.\n-        //\n-        // (If we extended the `UnificationTable` to let us see which\n-        // values have been unified and so forth, that might also\n-        // suffice.)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n \n /// These structs (a newtyped TyVid) are used as the unification key"}]}