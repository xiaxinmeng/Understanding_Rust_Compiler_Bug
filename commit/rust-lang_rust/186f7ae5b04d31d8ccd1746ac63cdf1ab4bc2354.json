{"sha": "186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NmY3YWU1YjA0ZDMxZDhjY2QxNzQ2YWM2M2NkZjFhYjRiYzIzNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-03T15:12:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-03T15:12:19Z"}, "message": "Auto merge of #81294 - pnkfelix:issue-81211-use-ufcs-in-derive-debug, r=oli-obk\n\nUse ufcs in derive(Debug)\n\nCc #81211.\n\n(Arguably this *is* the fix for it.)", "tree": {"sha": "a8c3d451b31ddc271ae52cbf2426e31e424bc840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8c3d451b31ddc271ae52cbf2426e31e424bc840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "html_url": "https://github.com/rust-lang/rust/commit/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ad11e2e25919b75ebbc36d7910f2a1126a7e873", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad11e2e25919b75ebbc36d7910f2a1126a7e873", "html_url": "https://github.com/rust-lang/rust/commit/6ad11e2e25919b75ebbc36d7910f2a1126a7e873"}, {"sha": "1783c476fac1bfe475157be3817e051811e90897", "url": "https://api.github.com/repos/rust-lang/rust/commits/1783c476fac1bfe475157be3817e051811e90897", "html_url": "https://github.com/rust-lang/rust/commit/1783c476fac1bfe475157be3817e051811e90897"}], "stats": {"total": 358, "additions": 315, "deletions": 43}, "files": [{"sha": "ba43be6ae9a9e72ef2b30254ba17dcf09b53f6b6", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "patch": "@@ -8,6 +8,10 @@ use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n \n+fn make_mut_borrow(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<Expr>) -> P<Expr> {\n+    cx.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Mut, expr))\n+}\n+\n pub fn expand_deriving_debug(\n     cx: &mut ExtCtxt<'_>,\n     span: Span,\n@@ -67,34 +71,34 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     let fmt = substr.nonself_args[0].clone();\n \n     let mut stmts = Vec::with_capacity(fields.len() + 2);\n+    let fn_path_finish;\n     match vdata {\n         ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n             // tuple struct/\"normal\" variant\n-            let expr =\n-                cx.expr_method_call(span, fmt, Ident::new(sym::debug_tuple, span), vec![name]);\n+            let fn_path_debug_tuple = cx.std_path(&[sym::fmt, sym::Formatter, sym::debug_tuple]);\n+            let expr = cx.expr_call_global(span, fn_path_debug_tuple, vec![fmt, name]);\n             stmts.push(cx.stmt_let(span, true, builder, expr));\n \n             for field in fields {\n                 // Use double indirection to make sure this works for unsized types\n                 let field = cx.expr_addr_of(field.span, field.self_.clone());\n                 let field = cx.expr_addr_of(field.span, field);\n \n-                let expr = cx.expr_method_call(\n-                    span,\n-                    builder_expr.clone(),\n-                    Ident::new(sym::field, span),\n-                    vec![field],\n-                );\n+                let fn_path_field = cx.std_path(&[sym::fmt, sym::DebugTuple, sym::field]);\n+                let builder_recv = make_mut_borrow(cx, span, builder_expr.clone());\n+                let expr = cx.expr_call_global(span, fn_path_field, vec![builder_recv, field]);\n \n                 // Use `let _ = expr;` to avoid triggering the\n                 // unused_results lint.\n                 stmts.push(stmt_let_underscore(cx, span, expr));\n             }\n+\n+            fn_path_finish = cx.std_path(&[sym::fmt, sym::DebugTuple, sym::finish]);\n         }\n         ast::VariantData::Struct(..) => {\n             // normal struct/struct variant\n-            let expr =\n-                cx.expr_method_call(span, fmt, Ident::new(sym::debug_struct, span), vec![name]);\n+            let fn_path_debug_struct = cx.std_path(&[sym::fmt, sym::Formatter, sym::debug_struct]);\n+            let expr = cx.expr_call_global(span, fn_path_debug_struct, vec![fmt, name]);\n             stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n             for field in fields {\n@@ -104,20 +108,20 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 );\n \n                 // Use double indirection to make sure this works for unsized types\n+                let fn_path_field = cx.std_path(&[sym::fmt, sym::DebugStruct, sym::field]);\n                 let field = cx.expr_addr_of(field.span, field.self_.clone());\n                 let field = cx.expr_addr_of(field.span, field);\n-                let expr = cx.expr_method_call(\n-                    span,\n-                    builder_expr.clone(),\n-                    Ident::new(sym::field, span),\n-                    vec![name, field],\n-                );\n+                let builder_recv = make_mut_borrow(cx, span, builder_expr.clone());\n+                let expr =\n+                    cx.expr_call_global(span, fn_path_field, vec![builder_recv, name, field]);\n                 stmts.push(stmt_let_underscore(cx, span, expr));\n             }\n+            fn_path_finish = cx.std_path(&[sym::fmt, sym::DebugStruct, sym::finish]);\n         }\n     }\n \n-    let expr = cx.expr_method_call(span, builder_expr, Ident::new(sym::finish, span), vec![]);\n+    let builder_recv = make_mut_borrow(cx, span, builder_expr);\n+    let expr = cx.expr_call_global(span, fn_path_finish, vec![builder_recv]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);"}, {"sha": "df23b4006b347e5a5fcd69f67aa2654c7f049410", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "patch": "@@ -133,6 +133,8 @@ symbols! {\n         Copy,\n         Count,\n         Debug,\n+        DebugStruct,\n+        DebugTuple,\n         Decodable,\n         Decoder,\n         Default,"}, {"sha": "94c77025ecf1cd0eacc46c62daa9d987f3784c9e", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.partial_eq/partial_eq.{impl#7}-fmt.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.partial_eq%2Fpartial_eq.%7Bimpl%237%7D-fmt.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.partial_eq%2Fpartial_eq.%7Bimpl%237%7D-fmt.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.partial_eq%2Fpartial_eq.%7Bimpl%237%7D-fmt.-------.InstrumentCoverage.0.html?ref=186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "patch": "@@ -78,32 +78,36 @@\n 4:17-4:22: @0[13]: _8 = &amp;(*_9)\n 4:17-4:22: @0.Call: _6 = Formatter::debug_struct(move _7, move _8) -&gt; [return: bb1, unwind: bb6]\n 4:17-4:22: @1[2]: FakeRead(ForLet, _6)\n-4:17-4:22: @1[6]: _11 = &amp;mut _6\n-4:17-4:22: @1[9]: _13 = const &quot;major&quot;\n-4:17-4:22: @1[10]: _12 = &amp;(*_13)\n-4:17-4:22: @1[15]: _17 = &amp;(*_3)\n-4:17-4:22: @1[16]: _16 = &amp;_17\n-4:17-4:22: @1[17]: _15 = &amp;(*_16)\n-4:17-4:22: @1[18]: _14 = move _15 as &amp;dyn std::fmt::Debug (Pointer(Unsize))\n-4:17-4:22: @1.Call: _10 = DebugStruct::field(move _11, move _12, move _14) -&gt; [return: bb2, unwind: bb6]\n-4:17-4:22: @2[9]: _19 = &amp;mut _6\n-4:17-4:22: @2[12]: _21 = const &quot;minor&quot;\n-4:17-4:22: @2[13]: _20 = &amp;(*_21)\n-4:17-4:22: @2[18]: _25 = &amp;(*_4)\n-4:17-4:22: @2[19]: _24 = &amp;_25\n-4:17-4:22: @2[20]: _23 = &amp;(*_24)\n-4:17-4:22: @2[21]: _22 = move _23 as &amp;dyn std::fmt::Debug (Pointer(Unsize))\n-4:17-4:22: @2.Call: _18 = DebugStruct::field(move _19, move _20, move _22) -&gt; [return: bb3, unwind: bb6]\n-4:17-4:22: @3[9]: _27 = &amp;mut _6\n-4:17-4:22: @3[12]: _29 = const &quot;patch&quot;\n-4:17-4:22: @3[13]: _28 = &amp;(*_29)\n-4:17-4:22: @3[18]: _33 = &amp;(*_5)\n-4:17-4:22: @3[19]: _32 = &amp;_33\n-4:17-4:22: @3[20]: _31 = &amp;(*_32)\n-4:17-4:22: @3[21]: _30 = move _31 as &amp;dyn std::fmt::Debug (Pointer(Unsize))\n-4:17-4:22: @3.Call: _26 = DebugStruct::field(move _27, move _28, move _30) -&gt; [return: bb4, unwind: bb6]\n-4:17-4:22: @4[8]: _34 = &amp;mut _6\n-4:17-4:22: @4.Call: _0 = DebugStruct::finish(move _34) -&gt; [return: bb5, unwind: bb6]\n+4:17-4:22: @1[7]: _12 = &amp;mut _6\n+4:17-4:22: @1[8]: _11 = &amp;mut (*_12)\n+4:17-4:22: @1[11]: _14 = const &quot;major&quot;\n+4:17-4:22: @1[12]: _13 = &amp;(*_14)\n+4:17-4:22: @1[17]: _18 = &amp;(*_3)\n+4:17-4:22: @1[18]: _17 = &amp;_18\n+4:17-4:22: @1[19]: _16 = &amp;(*_17)\n+4:17-4:22: @1[20]: _15 = move _16 as &amp;dyn std::fmt::Debug (Pointer(Unsize))\n+4:17-4:22: @1.Call: _10 = DebugStruct::field(move _11, move _13, move _15) -&gt; [return: bb2, unwind: bb6]\n+4:17-4:22: @2[11]: _21 = &amp;mut _6\n+4:17-4:22: @2[12]: _20 = &amp;mut (*_21)\n+4:17-4:22: @2[15]: _23 = const &quot;minor&quot;\n+4:17-4:22: @2[16]: _22 = &amp;(*_23)\n+4:17-4:22: @2[21]: _27 = &amp;(*_4)\n+4:17-4:22: @2[22]: _26 = &amp;_27\n+4:17-4:22: @2[23]: _25 = &amp;(*_26)\n+4:17-4:22: @2[24]: _24 = move _25 as &amp;dyn std::fmt::Debug (Pointer(Unsize))\n+4:17-4:22: @2.Call: _19 = DebugStruct::field(move _20, move _22, move _24) -&gt; [return: bb3, unwind: bb6]\n+4:17-4:22: @3[11]: _30 = &amp;mut _6\n+4:17-4:22: @3[12]: _29 = &amp;mut (*_30)\n+4:17-4:22: @3[15]: _32 = const &quot;patch&quot;\n+4:17-4:22: @3[16]: _31 = &amp;(*_32)\n+4:17-4:22: @3[21]: _36 = &amp;(*_5)\n+4:17-4:22: @3[22]: _35 = &amp;_36\n+4:17-4:22: @3[23]: _34 = &amp;(*_35)\n+4:17-4:22: @3[24]: _33 = move _34 as &amp;dyn std::fmt::Debug (Pointer(Unsize))\n+4:17-4:22: @3.Call: _28 = DebugStruct::field(move _29, move _31, move _33) -&gt; [return: bb4, unwind: bb6]\n+4:17-4:22: @4[10]: _38 = &amp;mut _6\n+4:17-4:22: @4[11]: _37 = &amp;mut (*_38)\n+4:17-4:22: @4.Call: _0 = DebugStruct::finish(move _37) -&gt; [return: bb5, unwind: bb6]\n 4:22-4:22: @5.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5\u298a</span>Debug<span class=\"annotation\">\u2989@0,1,2,3,4,5</span></span></span></span></div>\n </body>\n </html>"}, {"sha": "cb9dda84159273dcd8b25da3d5fe98ac0a1cb40c", "filename": "src/test/ui/derives/derive-Debug-use-ufcs-struct.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/src%2Ftest%2Fui%2Fderives%2Fderive-Debug-use-ufcs-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/src%2Ftest%2Fui%2Fderives%2Fderive-Debug-use-ufcs-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-Debug-use-ufcs-struct.rs?ref=186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "patch": "@@ -0,0 +1,40 @@\n+// run-pass\n+#![allow(warnings)]\n+\n+#[derive(Debug)]\n+pub struct Bar { pub t: () }\n+\n+impl<T> Access for T {}\n+pub trait Access {\n+    fn field(&self, _: impl Sized, _: impl Sized) {\n+        panic!(\"got into Access::field\");\n+    }\n+\n+    fn finish(&self) -> Result<(), std::fmt::Error> {\n+        panic!(\"got into Access::finish\");\n+    }\n+\n+    fn debug_struct(&self, _: impl Sized, _: impl Sized) {\n+        panic!(\"got into Access::debug_struct\");\n+    }\n+}\n+\n+impl<T> MutAccess for T {}\n+pub trait MutAccess {\n+    fn field(&mut self, _: impl Sized, _: impl Sized) {\n+        panic!(\"got into MutAccess::field\");\n+    }\n+\n+    fn finish(&mut self) -> Result<(), std::fmt::Error> {\n+        panic!(\"got into MutAccess::finish\");\n+    }\n+\n+    fn debug_struct(&mut self, _: impl Sized, _: impl Sized) {\n+        panic!(\"got into MutAccess::debug_struct\");\n+    }\n+}\n+\n+fn main() {\n+    let bar = Bar { t: () };\n+    assert_eq!(\"Bar { t: () }\", format!(\"{:?}\", bar));\n+}"}, {"sha": "5f786769fe73b153a2588fa659f9a51f93075f6f", "filename": "src/test/ui/derives/derive-Debug-use-ufcs-tuple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/src%2Ftest%2Fui%2Fderives%2Fderive-Debug-use-ufcs-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/src%2Ftest%2Fui%2Fderives%2Fderive-Debug-use-ufcs-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-Debug-use-ufcs-tuple.rs?ref=186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "patch": "@@ -0,0 +1,32 @@\n+// run-pass\n+#![allow(warnings)]\n+\n+#[derive(Debug)]\n+pub struct Foo<T>(pub T);\n+\n+use std::fmt;\n+\n+impl<T> Field for T {}\n+impl<T> Finish for T {}\n+impl Dt for &mut fmt::Formatter<'_> {}\n+\n+pub trait Field {\n+    fn field(&self, _: impl Sized) {\n+        panic!(\"got into field\");\n+    }\n+}\n+pub trait Finish {\n+    fn finish(&self) -> Result<(), std::fmt::Error> {\n+        panic!(\"got into finish\");\n+    }\n+}\n+pub trait Dt {\n+    fn debug_tuple(&self, _: &str) {\n+        panic!(\"got into debug_tuple\");\n+    }\n+}\n+\n+fn main() {\n+    let foo = Foo(());\n+    assert_eq!(\"Foo(())\", format!(\"{:?}\", foo));\n+}"}, {"sha": "986fe103cdc796cbd6f609d5341eb659fe660948", "filename": "src/test/ui/methods/method-lookup-order.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/src%2Ftest%2Fui%2Fmethods%2Fmethod-lookup-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354/src%2Ftest%2Fui%2Fmethods%2Fmethod-lookup-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-lookup-order.rs?ref=186f7ae5b04d31d8ccd1746ac63cdf1ab4bc2354", "patch": "@@ -0,0 +1,190 @@\n+// ignore-tidy-linelength\n+\n+// run-pass\n+\n+// There are five cfg's below. I explored the set of all non-empty combinations\n+// of the below five cfg's, which is 2^5 - 1 = 31 combinations.\n+//\n+// Of the 31, 11 resulted in ambiguous method resolutions; while it may be good\n+// to have a test for all of the eleven variations of that error, I am not sure\n+// this particular test is the best way to encode it. So they are skipped in\n+// this revisions list (but not in the expansion mapping the binary encoding to\n+// the corresponding cfg flags).\n+//\n+// Notable, here are the cases that will be incompatible if something does not override them first:\n+// {bar_for_foo, valbar_for_et_foo}: these are higher precedent than the `&mut self` method on `Foo`, and so no case matching bx1x1x is included.\n+// {mutbar_for_foo, valbar_for_etmut_foo} (which are lower precedent than the inherent `&mut self` method on `Foo`; e.g. b10101 *is* included.\n+\n+// revisions: b00001 b00010 b00011 b00100 b00101 b00110 b00111 b01000 b01001 b01100 b01101 b10000 b10001 b10010 b10011 b10101 b10111 b11000 b11001 b11101\n+\n+//[b00001]compile-flags:  --cfg inherent_mut\n+//[b00010]compile-flags:                     --cfg bar_for_foo\n+//[b00011]compile-flags:  --cfg inherent_mut --cfg bar_for_foo\n+//[b00100]compile-flags:                                       --cfg mutbar_for_foo\n+//[b00101]compile-flags:  --cfg inherent_mut                   --cfg mutbar_for_foo\n+//[b00110]compile-flags:                     --cfg bar_for_foo --cfg mutbar_for_foo\n+//[b00111]compile-flags:  --cfg inherent_mut --cfg bar_for_foo --cfg mutbar_for_foo\n+//[b01000]compile-flags:                                                            --cfg valbar_for_et_foo\n+//[b01001]compile-flags:  --cfg inherent_mut                                        --cfg valbar_for_et_foo\n+//[b01010]compile-flags:                     --cfg bar_for_foo                      --cfg valbar_for_et_foo\n+//[b01011]compile-flags:  --cfg inherent_mut --cfg bar_for_foo                      --cfg valbar_for_et_foo\n+//[b01100]compile-flags:                                       --cfg mutbar_for_foo --cfg valbar_for_et_foo\n+//[b01101]compile-flags:  --cfg inherent_mut                   --cfg mutbar_for_foo --cfg valbar_for_et_foo\n+//[b01110]compile-flags:                     --cfg bar_for_foo --cfg mutbar_for_foo --cfg valbar_for_et_foo\n+//[b01111]compile-flags:  --cfg inherent_mut --cfg bar_for_foo --cfg mutbar_for_foo --cfg valbar_for_et_foo\n+//[b10000]compile-flags:                                                                                    --cfg valbar_for_etmut_foo\n+//[b10001]compile-flags:  --cfg inherent_mut                                                                --cfg valbar_for_etmut_foo\n+//[b10010]compile-flags:                     --cfg bar_for_foo                                              --cfg valbar_for_etmut_foo\n+//[b10011]compile-flags:  --cfg inherent_mut --cfg bar_for_foo                                              --cfg valbar_for_etmut_foo\n+//[b10100]compile-flags:                                       --cfg mutbar_for_foo                         --cfg valbar_for_etmut_foo\n+//[b10101]compile-flags:  --cfg inherent_mut                   --cfg mutbar_for_foo                         --cfg valbar_for_etmut_foo\n+//[b10110]compile-flags:                     --cfg bar_for_foo --cfg mutbar_for_foo                         --cfg valbar_for_etmut_foo\n+//[b10111]compile-flags:  --cfg inherent_mut --cfg bar_for_foo --cfg mutbar_for_foo                         --cfg valbar_for_etmut_foo\n+//[b11000]compile-flags:                                                            --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11001]compile-flags:  --cfg inherent_mut                                        --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11010]compile-flags:                     --cfg bar_for_foo                      --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11011]compile-flags:  --cfg inherent_mut --cfg bar_for_foo                      --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11100]compile-flags:                                       --cfg mutbar_for_foo --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11101]compile-flags:  --cfg inherent_mut                   --cfg mutbar_for_foo --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11110]compile-flags:                     --cfg bar_for_foo --cfg mutbar_for_foo --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11111]compile-flags:  --cfg inherent_mut --cfg bar_for_foo --cfg mutbar_for_foo --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+\n+struct Foo {}\n+\n+type S = &'static str;\n+\n+trait Bar {\n+    fn bar(&self, _: &str) -> S;\n+}\n+\n+trait MutBar {\n+    fn bar(&mut self, _: &str) -> S;\n+}\n+\n+trait ValBar {\n+    fn bar(self, _: &str) -> S;\n+}\n+\n+#[cfg(inherent_mut)]\n+impl Foo {\n+    fn bar(&mut self, _: &str) -> S {\n+        \"In struct impl!\"\n+    }\n+}\n+\n+#[cfg(bar_for_foo)]\n+impl Bar for Foo {\n+    fn bar(&self, _: &str) -> S {\n+        \"In trait &self impl!\"\n+    }\n+}\n+\n+#[cfg(mutbar_for_foo)]\n+impl MutBar for Foo {\n+    fn bar(&mut self, _: &str) -> S {\n+        \"In trait &mut self impl!\"\n+    }\n+}\n+\n+#[cfg(valbar_for_et_foo)]\n+impl ValBar for &Foo {\n+    fn bar(self, _: &str) -> S {\n+        \"In trait self impl for &Foo!\"\n+    }\n+}\n+\n+#[cfg(valbar_for_etmut_foo)]\n+impl ValBar for &mut Foo {\n+    fn bar(self, _: &str) -> S {\n+        \"In trait self impl for &mut Foo!\"\n+    }\n+}\n+\n+fn main() {\n+    #![allow(unused_mut)] // some of the impls above will want it.\n+\n+    #![allow(unreachable_patterns)] // the cfg-coding pattern below generates unreachable patterns.\n+\n+    {\n+        macro_rules! all_variants_on_value {\n+            ($e:expr) => {\n+                match $e {\n+                    #[cfg(bar_for_foo)]\n+                    x => assert_eq!(x, \"In trait &self impl!\"),\n+\n+                    #[cfg(valbar_for_et_foo)]\n+                    x => assert_eq!(x, \"In trait self impl for &Foo!\"),\n+\n+                    #[cfg(inherent_mut)]\n+                    x => assert_eq!(x, \"In struct impl!\"),\n+\n+                    #[cfg(mutbar_for_foo)]\n+                    x => assert_eq!(x, \"In trait &mut self impl!\"),\n+\n+                    #[cfg(valbar_for_etmut_foo)]\n+                    x => assert_eq!(x, \"In trait self impl for &mut Foo!\"),\n+                }\n+            }\n+        }\n+\n+        let mut f = Foo {};\n+        all_variants_on_value!(f.bar(\"f.bar\"));\n+\n+        let f_mr = &mut Foo {};\n+        all_variants_on_value!((*f_mr).bar(\"(*f_mr).bar\"));\n+    }\n+\n+    // This is sort of interesting: `&mut Foo` ends up with a significantly\n+    // different resolution order than what was devised above. Presumably this\n+    // is because we can get to a `&self` method by first a deref of the given\n+    // `&mut Foo` and then an autoref, and that is a longer path than a mere\n+    // auto-ref of a `Foo`.\n+\n+    {\n+        let f_mr = &mut Foo {};\n+\n+        match f_mr.bar(\"f_mr.bar\") {\n+            #[cfg(inherent_mut)]\n+            x => assert_eq!(x, \"In struct impl!\"),\n+\n+            #[cfg(valbar_for_etmut_foo)]\n+            x => assert_eq!(x, \"In trait self impl for &mut Foo!\"),\n+\n+            #[cfg(mutbar_for_foo)]\n+            x => assert_eq!(x, \"In trait &mut self impl!\"),\n+\n+            #[cfg(valbar_for_et_foo)]\n+            x => assert_eq!(x, \"In trait self impl for &Foo!\"),\n+\n+            #[cfg(bar_for_foo)]\n+            x => assert_eq!(x, \"In trait &self impl!\"),\n+        }\n+    }\n+\n+\n+    // Note that this isn't actually testing a resolution order; if both of these are\n+    // enabled, it yields an ambiguous method resolution error. The test tries to embed\n+    // that fact by testing *both* orders (and so the only way that can be right is if\n+    // they are not actually compatible).\n+    #[cfg(any(bar_for_foo, valbar_for_et_foo))]\n+    {\n+        let f_r = &Foo {};\n+\n+        match f_r.bar(\"f_r.bar\") {\n+            #[cfg(bar_for_foo)]\n+            x => assert_eq!(x, \"In trait &self impl!\"),\n+\n+            #[cfg(valbar_for_et_foo)]\n+            x => assert_eq!(x, \"In trait self impl for &Foo!\"),\n+        }\n+\n+        match f_r.bar(\"f_r.bar\") {\n+            #[cfg(valbar_for_et_foo)]\n+            x => assert_eq!(x, \"In trait self impl for &Foo!\"),\n+\n+            #[cfg(bar_for_foo)]\n+            x => assert_eq!(x, \"In trait &self impl!\"),\n+        }\n+    }\n+\n+}"}]}