{"sha": "d36612d65b67e18c7f8d247055f83b28a602e875", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNjYxMmQ2NWI2N2UxOGM3ZjhkMjQ3MDU1ZjgzYjI4YTYwMmU4NzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-08T14:45:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-08T14:45:57Z"}, "message": "auto merge of #9054 : huonw/rust/labelled-for, r=thestinger\n\nThe following parses and works as expected with this change:\r\n\r\n```rust\r\n'foo: for i in range(0, 10) {\r\n    for j in range(0, 10) {\r\n        if i + j == 15 { break 'foo; }\r\n    }\r\n}\r\n```", "tree": {"sha": "da8753d901a569992bf4ee1a30c016b377221485", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da8753d901a569992bf4ee1a30c016b377221485"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d36612d65b67e18c7f8d247055f83b28a602e875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d36612d65b67e18c7f8d247055f83b28a602e875", "html_url": "https://github.com/rust-lang/rust/commit/d36612d65b67e18c7f8d247055f83b28a602e875", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d36612d65b67e18c7f8d247055f83b28a602e875/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b609d022c4df307e4d68499b063c81a9ecb1e9cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b609d022c4df307e4d68499b063c81a9ecb1e9cf", "html_url": "https://github.com/rust-lang/rust/commit/b609d022c4df307e4d68499b063c81a9ecb1e9cf"}, {"sha": "14183114e1048097869a5c56ebfa4a6d71e1a492", "url": "https://api.github.com/repos/rust-lang/rust/commits/14183114e1048097869a5c56ebfa4a6d71e1a492", "html_url": "https://github.com/rust-lang/rust/commit/14183114e1048097869a5c56ebfa4a6d71e1a492"}], "stats": {"total": 214, "additions": 69, "deletions": 145}, "files": [{"sha": "b89414a6a53a00407633870400a62cc2a01295ce", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d36612d65b67e18c7f8d247055f83b28a602e875", "patch": "@@ -2064,7 +2064,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 }\n             }\n \n-            ast::ExprForLoop(_, _, _) => {\n+            ast::ExprForLoop(_, _, _, _) => {\n                 cx.sess.span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n                                             Found unexpanded for-loop.\");\n             }"}, {"sha": "6957f9ae3519d20cbdd2f215fc564660e3e6bd7c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d36612d65b67e18c7f8d247055f83b28a602e875", "patch": "@@ -528,7 +528,7 @@ pub enum Expr_ {\n     ExprCast(@Expr, Ty),\n     ExprIf(@Expr, Block, Option<@Expr>),\n     ExprWhile(@Expr, Block),\n-    ExprForLoop(@Pat, @Expr, Block),\n+    ExprForLoop(@Pat, @Expr, Block, Option<Ident>),\n     /* Conditionless loop (can be exited with break, cont, or ret)\n        Same semantics as while(true) { body }, but typestate knows that the\n        (implicit) condition is always true. */"}, {"sha": "099fa54c0c2991900e801b57b57ef58cda11ae38", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 39, "deletions": 131, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d36612d65b67e18c7f8d247055f83b28a602e875", "patch": "@@ -14,13 +14,13 @@ use ast::{item_mac, Mrk, Stmt_, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::{token_tree};\n use ast;\n use ast_util::{mtwt_outer_mark, new_rename, new_mark};\n+use ext::build::AstBuilder;\n use attr;\n use attr::AttrMetaMethods;\n use codemap;\n-use codemap::{Span, Spanned, spanned, ExpnInfo, NameAndSpan};\n+use codemap::{Span, Spanned, ExpnInfo, NameAndSpan};\n use ext::base::*;\n use fold::*;\n-use opt_vec;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token;\n@@ -33,7 +33,7 @@ use std::vec;\n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    e: &Expr_,\n-                   s: Span,\n+                   span: Span,\n                    fld: @ast_fold,\n                    orig: @fn(&Expr_, Span, @ast_fold) -> (Expr_, Span))\n                 -> (Expr_, Span) {\n@@ -66,7 +66,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         }\n                         Some(@SE(NormalTT(expandfun, exp_span))) => {\n                             cx.bt_push(ExpnInfo {\n-                                call_site: s,\n+                                call_site: span,\n                                 callee: NameAndSpan {\n                                     name: extnamestr,\n                                     span: exp_span,\n@@ -98,7 +98,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                 fld.fold_expr(marked_after).node.clone();\n                             cx.bt_pop();\n \n-                            (fully_expanded, s)\n+                            (fully_expanded, span)\n                         }\n                         _ => {\n                             cx.span_fatal(\n@@ -112,62 +112,18 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         }\n \n         // Desugar expr_for_loop\n-        // From: `for <src_pat> in <src_expr> <src_loop_block>`\n-        ast::ExprForLoop(src_pat, src_expr, ref src_loop_block) => {\n-            let src_pat = src_pat.clone();\n-            let src_expr = src_expr.clone();\n-\n+        // From: `['<ident>:] for <src_pat> in <src_expr> <src_loop_block>`\n+        ast::ExprForLoop(src_pat, src_expr, ref src_loop_block, opt_ident) => {\n             // Expand any interior macros etc.\n             // NB: we don't fold pats yet. Curious.\n-            let src_expr = fld.fold_expr(src_expr).clone();\n-            let src_loop_block = fld.fold_block(src_loop_block).clone();\n-\n-            let span = s;\n-            let lo = s.lo;\n-            let hi = s.hi;\n-\n-            pub fn mk_expr(cx: @ExtCtxt, span: Span,\n-                           node: Expr_) -> @ast::Expr {\n-                @ast::Expr {\n-                    id: cx.next_id(),\n-                    node: node,\n-                    span: span,\n-                }\n-            }\n-\n-            fn mk_block(cx: @ExtCtxt,\n-                        stmts: &[@ast::Stmt],\n-                        expr: Option<@ast::Expr>,\n-                        span: Span) -> ast::Block {\n-                ast::Block {\n-                    view_items: ~[],\n-                    stmts: stmts.to_owned(),\n-                    expr: expr,\n-                    id: cx.next_id(),\n-                    rules: ast::DefaultBlock,\n-                    span: span,\n-                }\n-            }\n-\n-            fn mk_simple_path(ident: ast::Ident, span: Span) -> ast::Path {\n-                ast::Path {\n-                    span: span,\n-                    global: false,\n-                    segments: ~[\n-                        ast::PathSegment {\n-                            identifier: ident,\n-                            lifetime: None,\n-                            types: opt_vec::Empty,\n-                        }\n-                    ],\n-                }\n-            }\n+            let src_expr = fld.fold_expr(src_expr);\n+            let src_loop_block = fld.fold_block(src_loop_block);\n \n             // to:\n             //\n             // {\n             //   let _i = &mut <src_expr>;\n-            //   loop {\n+            //   ['<ident>:] loop {\n             //       match i.next() {\n             //           None => break,\n             //           Some(<src_pat>) => <src_loop_block>\n@@ -176,98 +132,50 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n             // }\n \n             let local_ident = token::gensym_ident(\"i\");\n-            let some_ident = token::str_to_ident(\"Some\");\n-            let none_ident = token::str_to_ident(\"None\");\n-            let next_ident = token::str_to_ident(\"next\");\n+            let next_ident = cx.ident_of(\"next\");\n+            let none_ident = cx.ident_of(\"None\");\n \n-            let local_path_1 = mk_simple_path(local_ident, span);\n-            let local_path_2 = mk_simple_path(local_ident, span);\n-            let some_path = mk_simple_path(some_ident, span);\n-            let none_path = mk_simple_path(none_ident, span);\n+            let local_path = cx.path_ident(span, local_ident);\n+            let some_path = cx.path_ident(span, cx.ident_of(\"Some\"));\n \n             // `let i = &mut <src_expr>`\n-            let iter_decl_stmt = {\n-                let ty = ast::Ty {\n-                    id: cx.next_id(),\n-                    node: ast::ty_infer,\n-                    span: span\n-                };\n-                let local = @ast::Local {\n-                    is_mutbl: false,\n-                    ty: ty,\n-                    pat: @ast::Pat {\n-                        id: cx.next_id(),\n-                        node: ast::PatIdent(ast::BindInfer, local_path_1, None),\n-                        span: src_expr.span\n-                    },\n-                    init: Some(mk_expr(cx, src_expr.span,\n-                                       ast::ExprAddrOf(ast::MutMutable, src_expr))),\n-                    id: cx.next_id(),\n-                    span: src_expr.span,\n-                };\n-                let e = @spanned(src_expr.span.lo,\n-                                 src_expr.span.hi,\n-                                 ast::DeclLocal(local));\n-                @spanned(lo, hi, ast::StmtDecl(e, cx.next_id()))\n-            };\n+            let iter_decl_stmt = cx.stmt_let(span, false, local_ident,\n+                                             cx.expr_mut_addr_of(span, src_expr));\n \n-            // `None => break;`\n+            // `None => break ['<ident>];`\n             let none_arm = {\n-                let break_expr = mk_expr(cx, span, ast::ExprBreak(None));\n-                let break_stmt = @spanned(lo, hi, ast::StmtExpr(break_expr, cx.next_id()));\n-                let none_block = mk_block(cx, [break_stmt], None, span);\n-                let none_pat = @ast::Pat {\n-                    id: cx.next_id(),\n-                    node: ast::PatIdent(ast::BindInfer, none_path, None),\n-                    span: span\n-                };\n-                ast::Arm {\n-                    pats: ~[none_pat],\n-                    guard: None,\n-                    body: none_block\n-                }\n+                let break_expr = cx.expr(span, ast::ExprBreak(opt_ident));\n+                let none_pat = cx.pat_ident(span, none_ident);\n+                cx.arm(span, ~[none_pat], break_expr)\n             };\n \n             // `Some(<src_pat>) => <src_loop_block>`\n-            let some_arm = {\n-                let pat = @ast::Pat {\n-                    id: cx.next_id(),\n-                    node: ast::PatEnum(some_path, Some(~[src_pat])),\n-                    span: src_pat.span\n-                };\n-                ast::Arm {\n-                    pats: ~[pat],\n-                    guard: None,\n-                    body: src_loop_block\n-                }\n-            };\n+            let some_arm =\n+                cx.arm(span,\n+                       ~[cx.pat_enum(span, some_path, ~[src_pat])],\n+                       cx.expr_block(src_loop_block));\n \n             // `match i.next() { ... }`\n-            let match_stmt = {\n-                let local_expr = mk_expr(cx, span, ast::ExprPath(local_path_2));\n-                let next_call_expr = mk_expr(cx, span,\n-                                             ast::ExprMethodCall(cx.next_id(),\n-                                                                   local_expr, next_ident,\n-                                                                   ~[], ~[], ast::NoSugar));\n-                let match_expr = mk_expr(cx, span, ast::ExprMatch(next_call_expr,\n-                                                                   ~[none_arm, some_arm]));\n-                @spanned(lo, hi, ast::StmtExpr(match_expr, cx.next_id()))\n-            };\n+            let match_expr = {\n+                let next_call_expr =\n+                    cx.expr_method_call(span, cx.expr_path(local_path), next_ident, ~[]);\n \n-            // `loop { ... }`\n-            let loop_block = {\n-                let loop_body_block = mk_block(cx, [match_stmt], None, span);\n-                let loop_body_expr = mk_expr(cx, span, ast::ExprLoop(loop_body_block, None));\n-                let loop_body_stmt = @spanned(lo, hi, ast::StmtExpr(loop_body_expr, cx.next_id()));\n-                mk_block(cx, [iter_decl_stmt,\n-                              loop_body_stmt],\n-                         None, span)\n+                cx.expr_match(span, next_call_expr, ~[none_arm, some_arm])\n             };\n \n-            (ast::ExprBlock(loop_block), span)\n+            // ['ident:] loop { ... }\n+            let loop_expr = cx.expr(span,\n+                                    ast::ExprLoop(cx.block_expr(match_expr), opt_ident));\n+\n+            // `{ let ... ;  loop { ... } }`\n+            let block = cx.block(span,\n+                                 ~[iter_decl_stmt],\n+                                 Some(loop_expr));\n+\n+            (ast::ExprBlock(block), span)\n         }\n \n-        _ => orig(e, s, fld)\n+        _ => orig(e, span, fld)\n     }\n }\n "}, {"sha": "11e39163992d86313514899446506e2e40871737", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d36612d65b67e18c7f8d247055f83b28a602e875", "patch": "@@ -557,10 +557,11 @@ pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n         ExprWhile(cond, ref body) => {\n             ExprWhile(fld.fold_expr(cond), fld.fold_block(body))\n         }\n-        ExprForLoop(pat, iter, ref body) => {\n+        ExprForLoop(pat, iter, ref body, opt_ident) => {\n             ExprForLoop(fld.fold_pat(pat),\n-                          fld.fold_expr(iter),\n-                          fld.fold_block(body))\n+                        fld.fold_expr(iter),\n+                        fld.fold_block(body),\n+                        opt_ident.map_move(|x| fld.fold_ident(x)))\n         }\n         ExprLoop(ref body, opt_ident) => {\n             ExprLoop("}, {"sha": "850f73096edbb21beedffae02a692718d08651b0", "filename": "src/libsyntax/oldvisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=d36612d65b67e18c7f8d247055f83b28a602e875", "patch": "@@ -523,7 +523,7 @@ pub fn visit_expr<E:Clone>(ex: @Expr, (e, v): (E, vt<E>)) {\n             (v.visit_expr)(x, (e.clone(), v));\n             (v.visit_block)(b, (e.clone(), v));\n         }\n-        ExprForLoop(pattern, subexpression, ref block) => {\n+        ExprForLoop(pattern, subexpression, ref block, _) => {\n             (v.visit_pat)(pattern, (e.clone(), v));\n             (v.visit_expr)(subexpression, (e.clone(), v));\n             (v.visit_block)(block, (e.clone(), v))"}, {"sha": "b86153525047e2b8e53a6937629582cfc0390ce1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d36612d65b67e18c7f8d247055f83b28a602e875", "patch": "@@ -1771,7 +1771,7 @@ impl Parser {\n         } else if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else if self.eat_keyword(keywords::For) {\n-            return self.parse_for_expr();\n+            return self.parse_for_expr(None);\n         } else if self.eat_keyword(keywords::Do) {\n             return self.parse_sugary_call_expr(lo, ~\"do\", DoSugar,\n                                                ExprDoBody);\n@@ -1781,8 +1781,13 @@ impl Parser {\n             let lifetime = self.get_lifetime(&*self.token);\n             self.bump();\n             self.expect(&token::COLON);\n-            self.expect_keyword(keywords::Loop);\n-            return self.parse_loop_expr(Some(lifetime));\n+            if self.eat_keyword(keywords::For) {\n+                return self.parse_for_expr(Some(lifetime))\n+            } else if self.eat_keyword(keywords::Loop) {\n+                return self.parse_loop_expr(Some(lifetime))\n+            } else {\n+                self.fatal(\"expected `for` or `loop` after a label\")\n+            }\n         } else if self.eat_keyword(keywords::Loop) {\n             return self.parse_loop_expr(None);\n         } else if self.eat_keyword(keywords::Match) {\n@@ -2467,7 +2472,7 @@ impl Parser {\n     }\n \n     // parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&self) -> @Expr {\n+    pub fn parse_for_expr(&self, opt_ident: Option<ast::Ident>) -> @Expr {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let lo = self.last_span.lo;\n@@ -2477,7 +2482,7 @@ impl Parser {\n         let loop_block = self.parse_block();\n         let hi = self.span.hi;\n \n-        self.mk_expr(lo, hi, ExprForLoop(pat, expr, loop_block))\n+        self.mk_expr(lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident))\n     }\n \n "}, {"sha": "282b66b2c59ef61cf9671a1c4a71b44261690a08", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d36612d65b67e18c7f8d247055f83b28a602e875", "patch": "@@ -1232,7 +1232,12 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         space(s.s);\n         print_block(s, blk);\n       }\n-      ast::ExprForLoop(pat, iter, ref blk) => {\n+      ast::ExprForLoop(pat, iter, ref blk, opt_ident) => {\n+        for ident in opt_ident.iter() {\n+            word(s.s, \"'\");\n+            print_ident(s, *ident);\n+            word_space(s, \":\");\n+        }\n         head(s, \"for\");\n         print_pat(s, pat);\n         space(s.s);"}, {"sha": "191b4509a80b32881b1d525d9f396616059530f7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d36612d65b67e18c7f8d247055f83b28a602e875", "patch": "@@ -599,7 +599,7 @@ pub fn walk_expr<E:Clone, V:Visitor<E>>(visitor: &mut V, expression: @Expr, env:\n             visitor.visit_expr(subexpression, env.clone());\n             visitor.visit_block(block, env.clone())\n         }\n-        ExprForLoop(pattern, subexpression, ref block) => {\n+        ExprForLoop(pattern, subexpression, ref block, _) => {\n             visitor.visit_pat(pattern, env.clone());\n             visitor.visit_expr(subexpression, env.clone());\n             visitor.visit_block(block, env.clone())\n@@ -812,4 +812,3 @@ impl Visitor<()> for SimpleVisitorVisitor {\n         walk_struct_field(self, struct_field, env)\n     }\n }\n-"}, {"sha": "d7d210c7524149834ec341f695940ef9d141a6d5", "filename": "src/test/run-pass/labeled-break.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Ftest%2Frun-pass%2Flabeled-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36612d65b67e18c7f8d247055f83b28a602e875/src%2Ftest%2Frun-pass%2Flabeled-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flabeled-break.rs?ref=d36612d65b67e18c7f8d247055f83b28a602e875", "patch": "@@ -14,4 +14,10 @@ pub fn main() {\n             break 'foo;\n         }\n     }\n+\n+    'bar: for _ in range(0, 100) {\n+        loop {\n+            break 'bar;\n+        }\n+    }\n }"}]}