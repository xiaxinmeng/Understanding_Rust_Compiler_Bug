{"sha": "8c14649ce859194b7b939597ea2b3c0dee0611b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMTQ2NDljZTg1OTE5NGI3YjkzOTU5N2VhMmIzYzBkZWUwNjExYjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-16T10:21:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-16T10:22:42Z"}, "message": "Document `ObligationForest` better.", "tree": {"sha": "3ec2db252360e2a00bb4ae4562324d7b1afe3736", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ec2db252360e2a00bb4ae4562324d7b1afe3736"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c14649ce859194b7b939597ea2b3c0dee0611b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c14649ce859194b7b939597ea2b3c0dee0611b9", "html_url": "https://github.com/rust-lang/rust/commit/8c14649ce859194b7b939597ea2b3c0dee0611b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c14649ce859194b7b939597ea2b3c0dee0611b9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0723d6c6edbca3cc7bd8ef2a988594756c9c0b36", "url": "https://api.github.com/repos/rust-lang/rust/commits/0723d6c6edbca3cc7bd8ef2a988594756c9c0b36", "html_url": "https://github.com/rust-lang/rust/commit/0723d6c6edbca3cc7bd8ef2a988594756c9c0b36"}], "stats": {"total": 229, "additions": 179, "deletions": 50}, "files": [{"sha": "6ef8404cf079a7ce9ef61f499c9bf8dd8ef4f5ee", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c14649ce859194b7b939597ea2b3c0dee0611b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c14649ce859194b7b939597ea2b3c0dee0611b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=8c14649ce859194b7b939597ea2b3c0dee0611b9", "patch": "@@ -281,7 +281,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select_where_possible: outcome={:?}\", outcome);\n \n             // these are obligations that were proven to be true.\n-            for pending_obligation in outcome.successful {\n+            for pending_obligation in outcome.completed {\n                 let predicate = &pending_obligation.obligation.predicate;\n                 if predicate.is_global() {\n                     selcx.tcx().fulfilled_predicates.borrow_mut()"}, {"sha": "1ffe07bb43b4e12565d079c817c94aae20a2cf46", "filename": "src/librustc_data_structures/obligation_forest/README.md", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8c14649ce859194b7b939597ea2b3c0dee0611b9/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c14649ce859194b7b939597ea2b3c0dee0611b9/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md?ref=8c14649ce859194b7b939597ea2b3c0dee0611b9", "patch": "@@ -0,0 +1,80 @@\n+The `ObligationForest` is a utility data structure used in trait\n+matching to track the set of outstanding obligations (those not yet\n+resolved to success or error). It also tracks the \"backtrace\" of each\n+pending obligation (why we are trying to figure this out in the first\n+place).\n+\n+### External view\n+\n+`ObligationForest` supports two main public operations (there are a\n+few others not discussed here):\n+\n+1. Add a new root obligation (`push_root`).\n+2. Process the pending obligations (`process_obligations`).\n+\n+When a new obligation `N` is added, it becomes the root of an\n+obligation tree. This tree is a singleton to start, so `N` is both the\n+root and the only leaf. Each time the `process_obligations` method is\n+called, it will invoke its callback with every pending obligation (so\n+that will include `N`, the first time). The callback shoud process the\n+obligation `O` that it is given and return one of three results:\n+\n+- `Ok(None)` -> ambiguous result. Obligation was neither a success\n+  nor a failure. It is assumed that further attempts to process the\n+  obligation will yield the same result unless something in the\n+  surrounding environment changes.\n+- `Ok(Some(C))` - the obligation was *shallowly successful*. The\n+  vector `C` is a list of subobligations. The meaning of this is that\n+  `O` was successful on the assumption that all the obligations in `C`\n+  are also successful. Therefore, `O` is only considered a \"true\"\n+  success if `C` is empty. Otherwise, `O` is put into a suspended\n+  state and the obligations in `C` become the new pending\n+  obligations. They will be processed the next time you call\n+  `process_obligations`.\n+- `Err(E)` -> obligation failed with error `E`. We will collect this\n+  error and return it from `process_obligations`, along with the\n+  \"backtrace\" of obligations (that is, the list of obligations up to\n+  and including the root of the failed obligation). No further\n+  obligations from that same tree will be processed, since the tree is\n+  now considered to be in error.\n+\n+When the call to `process_obligations` completes, you get back an `Outcome`,\n+which includes three bits of information:\n+\n+- `completed`: a list of obligations where processing was fully\n+  completed without error (meaning that all transitive subobligations\n+  have also been completed). So, for example, if the callback from\n+  `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n+  then `O` will be considered completed right away if `C` is the\n+  empty vector. Otherwise it will only be considered completed once\n+  all the obligations in `C` have been found completed.\n+- `errors`: a list of errors that occurred and associated backtraces\n+  at the time of error, which can be used to give context to the user.\n+- `stalled`: if true, then none of the existing obligations were\n+  *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n+  This implies that all obligations were either errors or returned an\n+  ambiguous result, which means that any further calls to\n+  `process_obligations` would simply yield back further ambiguous\n+  results. This is used by the `FulfillmentContext` to decide when it\n+  has reached a steady state.\n+  \n+#### Snapshots\n+\n+The `ObligationForest` supports a limited form of snapshots; see\n+`start_snapshot`; `commit_snapshot`; and `rollback_snapshot`. In\n+particular, you can use a snapshot to roll back new root\n+obligations. However, it is an error to attempt to\n+`process_obligations` during a snapshot.\n+\n+### Implementation details\n+\n+For the most part, comments specific to the implementation are in the\n+code.  This file only contains a very high-level overview. Basically,\n+the forest is stored in a vector. Each element of the vector is a node\n+in some tree. Each node in the vector has the index of an (optional)\n+parent and (for convenience) its root (which may be itself). It also\n+has a current state, described by `NodeState`. After each\n+processing step, we compress the vector to remove completed and error\n+nodes, which aren't needed anymore.\n+\n+  "}, {"sha": "0d92a2b158f82496ac10e5e16edde3ccacf23ae0", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 85, "deletions": 36, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/8c14649ce859194b7b939597ea2b3c0dee0611b9/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c14649ce859194b7b939597ea2b3c0dee0611b9/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=8c14649ce859194b7b939597ea2b3c0dee0611b9", "patch": "@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! The `ObligationForest` is a utility data structure used in trait\n+//! matching to track the set of outstanding obligations (those not\n+//! yet resolved to success or error). It also tracks the \"backtrace\"\n+//! of each pending obligation (why we are trying to figure this out\n+//! in the first place). See README.md for a general overview of how\n+//! to use this class.\n+\n use std::fmt::Debug;\n use std::mem;\n \n@@ -17,6 +24,18 @@ mod node_index;\n mod test;\n \n pub struct ObligationForest<O> {\n+    /// The list of obligations. In between calls to\n+    /// `process_obligations`, this list only contains nodes in the\n+    /// `Pending` or `Success` state (with a non-zero number of\n+    /// incomplete children). During processing, some of those nodes\n+    /// may be changed to the error state, or we may find that they\n+    /// are completed (That is, `num_incomplete_children` drops to 0).\n+    /// At the end of processing, those nodes will be removed by a\n+    /// call to `compress`.\n+    ///\n+    /// At all times we maintain the invariant that every node appears\n+    /// at a higher index than its parent. This is needed by the\n+    /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n     snapshots: Vec<usize>\n }\n@@ -33,28 +52,44 @@ struct Node<O> {\n     root: NodeIndex, // points to the root, which may be the current node\n }\n \n+/// The state of one node in some tree within the forest. This\n+/// represents the current state of processing for the obligation (of\n+/// type `O`) associated with this node.\n #[derive(Debug)]\n enum NodeState<O> {\n-    Leaf { obligation: O },\n-    Success { obligation: O, num_children: usize },\n+    /// Obligation not yet resolved to success or error.\n+    Pending { obligation: O },\n+\n+    /// Obligation resolved to success; `num_incomplete_children`\n+    /// indicates the number of children still in an \"incomplete\"\n+    /// state. Incomplete means that either the child is still\n+    /// pending, or it has children which are incomplete. (Basically,\n+    /// there is pending work somewhere in the subtree of the child.)\n+    ///\n+    /// Once all children have completed, success nodes are removed\n+    /// from the vector by the compression step.\n+    Success { obligation: O, num_incomplete_children: usize },\n+\n+    /// This obligation was resolved to an error. Error nodes are\n+    /// removed from the vector by the compression step.\n     Error,\n }\n \n #[derive(Debug)]\n pub struct Outcome<O,E> {\n     /// Obligations that were completely evaluated, including all\n     /// (transitive) subobligations.\n-    pub successful: Vec<O>,\n+    pub completed: Vec<O>,\n \n     /// Backtrace of obligations that were found to be in error.\n     pub errors: Vec<Error<O,E>>,\n \n     /// If true, then we saw no successful obligations, which means\n     /// there is no point in further iteration. This is based on the\n-    /// assumption that `Err` and `Ok(None)` results do not affect\n-    /// environmental inference state. (Note that if we invoke\n-    /// `process_obligations` with no pending obligations, stalled\n-    /// will be true.)\n+    /// assumption that when trait matching returns `Err` or\n+    /// `Ok(None)`, those results do not affect environmental\n+    /// inference state. (Note that if we invoke `process_obligations`\n+    /// with no pending obligations, stalled will be true.)\n     pub stalled: bool,\n }\n \n@@ -90,13 +125,15 @@ impl<O: Debug> ObligationForest<O> {\n     }\n \n     pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n-        // check that we are obeying stack discipline\n+        // Check that we are obeying stack discipline.\n         assert_eq!(snapshot.len, self.snapshots.len());\n         let nodes_len = self.snapshots.pop().unwrap();\n \n-        // the only action permitted while in a snapshot is to push new roots\n+        // The only action permitted while in a snapshot is to push\n+        // new root obligations. Because no processing will have been\n+        // done, those roots should still be in the pending state.\n         debug_assert!(self.nodes[nodes_len..].iter().all(|n| match n.state {\n-            NodeState::Leaf { .. } => true,\n+            NodeState::Pending { .. } => true,\n             _ => false,\n         }));\n \n@@ -116,12 +153,15 @@ impl<O: Debug> ObligationForest<O> {\n     }\n \n     /// Convert all remaining obligations to the given error.\n+    ///\n+    /// This cannot be done during a snapshot.\n     pub fn to_errors<E:Clone>(&mut self, error: E) -> Vec<Error<O,E>> {\n+        assert!(!self.in_snapshot());\n         let mut errors = vec![];\n         for index in 0..self.nodes.len() {\n             debug_assert!(!self.nodes[index].is_popped());\n             self.inherit_error(index);\n-            if let NodeState::Leaf { .. } = self.nodes[index].state {\n+            if let NodeState::Pending { .. } = self.nodes[index].state {\n                 let backtrace = self.backtrace(index);\n                 errors.push(Error { error: error.clone(), backtrace: backtrace });\n             }\n@@ -131,11 +171,11 @@ impl<O: Debug> ObligationForest<O> {\n         errors\n     }\n \n-    /// Convert all remaining obligations to the given error.\n+    /// Returns the set of obligations that are in a pending state.\n     pub fn pending_obligations(&self) -> Vec<O> where O: Clone {\n         self.nodes.iter()\n                   .filter_map(|n| match n.state {\n-                      NodeState::Leaf { ref obligation } => Some(obligation),\n+                      NodeState::Pending { ref obligation } => Some(obligation),\n                       _ => None,\n                   })\n                   .cloned()\n@@ -174,9 +214,11 @@ impl<O: Debug> ObligationForest<O> {\n                 let (prefix, suffix) = self.nodes.split_at_mut(index);\n                 let backtrace = Backtrace::new(prefix, parent);\n                 match suffix[0].state {\n-                    NodeState::Error => continue,\n-                    NodeState::Success { .. } => continue,\n-                    NodeState::Leaf { ref mut obligation } => action(obligation, backtrace),\n+                    NodeState::Error |\n+                    NodeState::Success { .. } =>\n+                        continue,\n+                    NodeState::Pending { ref mut obligation } =>\n+                        action(obligation, backtrace),\n                 }\n             };\n \n@@ -204,7 +246,7 @@ impl<O: Debug> ObligationForest<O> {\n         debug!(\"process_obligations: complete\");\n \n         Outcome {\n-            successful: successful_obligations,\n+            completed: successful_obligations,\n             errors: errors,\n             stalled: stalled,\n         }\n@@ -219,9 +261,9 @@ impl<O: Debug> ObligationForest<O> {\n     fn success(&mut self, index: usize, children: Vec<O>) {\n         debug!(\"success(index={}, children={:?})\", index, children);\n \n-        let num_children = children.len();\n+        let num_incomplete_children = children.len();\n \n-        if num_children == 0 {\n+        if num_incomplete_children == 0 {\n             // if there is no work left to be done, decrement parent's ref count\n             self.update_parent(index);\n         } else {\n@@ -233,13 +275,14 @@ impl<O: Debug> ObligationForest<O> {\n                         .map(|o| Node::new(root_index, Some(node_index), o)));\n         }\n \n-        // change state from `Leaf` to `Success`, temporarily swapping in `Error`\n+        // change state from `Pending` to `Success`, temporarily swapping in `Error`\n         let state = mem::replace(&mut self.nodes[index].state, NodeState::Error);\n         self.nodes[index].state = match state {\n-            NodeState::Leaf { obligation } =>\n+            NodeState::Pending { obligation } =>\n                 NodeState::Success { obligation: obligation,\n-                                     num_children: num_children },\n-            NodeState::Success { .. } | NodeState::Error =>\n+                                     num_incomplete_children: num_incomplete_children },\n+            NodeState::Success { .. } |\n+            NodeState::Error =>\n                 unreachable!()\n         };\n     }\n@@ -251,9 +294,9 @@ impl<O: Debug> ObligationForest<O> {\n         if let Some(parent) = self.nodes[child].parent {\n             let parent = parent.get();\n             match self.nodes[parent].state {\n-                NodeState::Success { ref mut num_children, .. } => {\n-                    *num_children -= 1;\n-                    if *num_children > 0 {\n+                NodeState::Success { ref mut num_incomplete_children, .. } => {\n+                    *num_incomplete_children -= 1;\n+                    if *num_incomplete_children > 0 {\n                         return;\n                     }\n                 }\n@@ -263,8 +306,10 @@ impl<O: Debug> ObligationForest<O> {\n         }\n     }\n \n-    /// If the root of `child` is in an error error, places `child`\n-    /// into an error state.\n+    /// If the root of `child` is in an error state, places `child`\n+    /// into an error state. This is used during processing so that we\n+    /// skip the remaining obligations from a tree once some other\n+    /// node in the tree is found to be in error.\n     fn inherit_error(&mut self, child: usize) {\n         let root = self.nodes[child].root.get();\n         if let NodeState::Error = self.nodes[root].state {\n@@ -274,12 +319,15 @@ impl<O: Debug> ObligationForest<O> {\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n+    /// The fact that the root is now marked as an error is used by\n+    /// `inherit_error` above to propagate the error state to the\n+    /// remainder of the tree.\n     fn backtrace(&mut self, mut p: usize) -> Vec<O> {\n         let mut trace = vec![];\n         loop {\n             let state = mem::replace(&mut self.nodes[p].state, NodeState::Error);\n             match state {\n-                NodeState::Leaf { obligation } |\n+                NodeState::Pending { obligation } |\n                 NodeState::Success { obligation, .. } => {\n                     trace.push(obligation);\n                 }\n@@ -338,9 +386,9 @@ impl<O: Debug> ObligationForest<O> {\n             (0 .. dead).map(|_| self.nodes.pop().unwrap())\n                        .flat_map(|node| match node.state {\n                            NodeState::Error => None,\n-                           NodeState::Leaf { .. } => unreachable!(),\n-                           NodeState::Success { obligation, num_children } => {\n-                               assert_eq!(num_children, 0);\n+                           NodeState::Pending { .. } => unreachable!(),\n+                           NodeState::Success { obligation, num_incomplete_children } => {\n+                               assert_eq!(num_incomplete_children, 0);\n                                Some(obligation)\n                            }\n                        })\n@@ -365,15 +413,15 @@ impl<O> Node<O> {\n     fn new(root: NodeIndex, parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n         Node {\n             parent: parent,\n-            state: NodeState::Leaf { obligation: obligation },\n+            state: NodeState::Pending { obligation: obligation },\n             root: root\n         }\n     }\n \n     fn is_popped(&self) -> bool {\n         match self.state {\n-            NodeState::Leaf { .. } => false,\n-            NodeState::Success { num_children, .. } => num_children == 0,\n+            NodeState::Pending { .. } => false,\n+            NodeState::Success { num_incomplete_children, .. } => num_incomplete_children == 0,\n             NodeState::Error => true,\n         }\n     }\n@@ -399,7 +447,8 @@ impl<'b, O> Iterator for Backtrace<'b, O> {\n         if let Some(p) = self.pointer {\n             self.pointer = self.nodes[p.get()].parent;\n             match self.nodes[p.get()].state {\n-                NodeState::Leaf { ref obligation } | NodeState::Success { ref obligation, .. } => {\n+                NodeState::Pending { ref obligation } |\n+                NodeState::Success { ref obligation, .. } => {\n                     Some(obligation)\n                 }\n                 NodeState::Error => {"}, {"sha": "519b282a6a8c7a0f523a1ea81a9886e50572bb6d", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c14649ce859194b7b939597ea2b3c0dee0611b9/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c14649ce859194b7b939597ea2b3c0dee0611b9/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=8c14649ce859194b7b939597ea2b3c0dee0611b9", "patch": "@@ -21,7 +21,7 @@ fn push_pop() {\n     //      A |-> A.1\n     //        |-> A.2\n     //        |-> A.3\n-    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n         match *obligation {\n             \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n             \"B\" => Err(\"B is for broken\"),\n@@ -40,7 +40,7 @@ fn push_pop() {\n     //      D |-> D.1\n     //        |-> D.2\n     forest.push_root(\"D\");\n-    let Outcome { successful: ok, errors: err, .. }: Outcome<&'static str, ()> =\n+    let Outcome { completed: ok, errors: err, .. }: Outcome<&'static str, ()> =\n         forest.process_obligations(|obligation, _| {\n             match *obligation {\n                 \"A.1\" => Ok(None),\n@@ -58,7 +58,7 @@ fn push_pop() {\n     // propagates to A.3.i, but not D.1 or D.2.\n     //      D |-> D.1 |-> D.1.i\n     //        |-> D.2 |-> D.2.i\n-    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n         match *obligation {\n             \"A.1\" => Ok(Some(vec![])),\n             \"A.2\" => Err(\"A is for apple\"),\n@@ -72,7 +72,7 @@ fn push_pop() {\n                                  backtrace: vec![\"A.2\", \"A\"] }]);\n \n     // fourth round: error in D.1.i that should propagate to D.2.i\n-    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n         match *obligation {\n             \"D.1.i\" => Err(\"D is for dumb\"),\n             _ => panic!(\"unexpected obligation {:?}\", obligation),\n@@ -96,7 +96,7 @@ fn success_in_grandchildren() {\n     let mut forest = ObligationForest::new();\n     forest.push_root(\"A\");\n \n-    let Outcome { successful: ok, errors: err, .. } =\n+    let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations::<(),_>(|obligation, _| {\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n@@ -106,7 +106,7 @@ fn success_in_grandchildren() {\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n \n-    let Outcome { successful: ok, errors: err, .. } =\n+    let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations::<(),_>(|obligation, _| {\n             match *obligation {\n                 \"A.1\" => Ok(Some(vec![])),\n@@ -118,7 +118,7 @@ fn success_in_grandchildren() {\n     assert_eq!(ok, vec![\"A.3\", \"A.1\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { successful: ok, errors: err, .. } =\n+    let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations::<(),_>(|obligation, _| {\n             match *obligation {\n                 \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n@@ -129,7 +129,7 @@ fn success_in_grandchildren() {\n     assert_eq!(ok, vec![\"A.2.ii\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { successful: ok, errors: err, .. } =\n+    let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations::<(),_>(|obligation, _| {\n             match *obligation {\n                 \"A.2.i.a\" => Ok(Some(vec![])),\n@@ -139,7 +139,7 @@ fn success_in_grandchildren() {\n     assert_eq!(ok, vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { successful: ok, errors: err, .. } =\n+    let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations::<(),_>(|_, _| unreachable!());\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n@@ -151,7 +151,7 @@ fn to_errors_no_throw() {\n     // only yields one of them (and does not panic, in particular).\n     let mut forest = ObligationForest::new();\n     forest.push_root(\"A\");\n-    let Outcome { successful: ok, errors: err, .. } =\n+    let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations::<(),_>(|obligation, _| {\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n@@ -170,7 +170,7 @@ fn backtrace() {\n     // only yields one of them (and does not panic, in particular).\n     let mut forest: ObligationForest<&'static str> = ObligationForest::new();\n     forest.push_root(\"A\");\n-    let Outcome { successful: ok, errors: err, .. } =\n+    let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n             assert!(backtrace.next().is_none());\n             match *obligation {\n@@ -180,7 +180,7 @@ fn backtrace() {\n         });\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n-    let Outcome { successful: ok, errors: err, .. } =\n+    let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n             assert!(backtrace.next().unwrap() == &\"A\");\n             assert!(backtrace.next().is_none());\n@@ -191,7 +191,7 @@ fn backtrace() {\n         });\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n-    let Outcome { successful: ok, errors: err, .. } =\n+    let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n             assert!(backtrace.next().unwrap() == &\"A.1\");\n             assert!(backtrace.next().unwrap() == &\"A\");"}]}