{"sha": "fc9b234928c1d64cc45686d9e61bb5993d8747fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjOWIyMzQ5MjhjMWQ2NGNjNDU2ODZkOWU2MWJiNTk5M2Q4NzQ3ZmE=", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2020-10-31T18:50:34Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-03-23T00:02:06Z"}, "message": "Add IEEE754 tests", "tree": {"sha": "e24bf7dff183cd71553703aa15cc671aa0e1718d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e24bf7dff183cd71553703aa15cc671aa0e1718d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc9b234928c1d64cc45686d9e61bb5993d8747fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc9b234928c1d64cc45686d9e61bb5993d8747fa", "html_url": "https://github.com/rust-lang/rust/commit/fc9b234928c1d64cc45686d9e61bb5993d8747fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc9b234928c1d64cc45686d9e61bb5993d8747fa/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2287a8823d2d731b9bf3064da305fc5c408b24e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2287a8823d2d731b9bf3064da305fc5c408b24e2", "html_url": "https://github.com/rust-lang/rust/commit/2287a8823d2d731b9bf3064da305fc5c408b24e2"}], "stats": {"total": 159, "additions": 159, "deletions": 0}, "files": [{"sha": "f6e5dfc98c793b160b778c050437415fa17dd41e", "filename": "library/core/tests/num/ieee754.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/fc9b234928c1d64cc45686d9e61bb5993d8747fa/library%2Fcore%2Ftests%2Fnum%2Fieee754.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9b234928c1d64cc45686d9e61bb5993d8747fa/library%2Fcore%2Ftests%2Fnum%2Fieee754.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fieee754.rs?ref=fc9b234928c1d64cc45686d9e61bb5993d8747fa", "patch": "@@ -0,0 +1,158 @@\n+//! IEEE 754 floating point compliance tests\n+//!\n+//! To understand IEEE 754's requirements on a programming language, one must understand that the\n+//! requirements of IEEE 754 rest on the total programming environment, and not entirely on any\n+//! one component. That means the hardware, language, and even libraries are considered part of\n+//! conforming floating point support in a programming environment.\n+//!\n+//! A programming language's duty, accordingly, is:\n+//!   1. offer access to the hardware where the hardware offers support\n+//!   2. provide operations that fulfill the remaining requirements of the standard\n+//!   3. provide the ability to write additional software that can fulfill those requirements\n+//!\n+//! This may be fulfilled in any combination that the language sees fit. However, to claim that\n+//! a language supports IEEE 754 is to suggest that it has fulfilled requirements 1 and 2, without\n+//! deferring minimum requirements to libraries. This is because support for IEEE 754 is defined\n+//! as complete support for at least one specified floating point type as an \"arithmetic\" and\n+//! \"interchange\" format, plus specified type conversions to \"external character sequences\" and\n+//! integer types.\n+//!\n+//! For our purposes,\n+//! \"interchange format\"          => f32, f64\n+//! \"arithmetic format\"           => f32, f64, and any \"soft floats\"\n+//! \"external character sequence\" => str from any float\n+//! \"integer format\"              => {i,u}{8,16,32,64,128}\n+//!\n+//! None of these tests are against Rust's own implementation. They are only tests against the\n+//! standard. That is why they accept wildly diverse inputs or may seem to duplicate other tests.\n+//! Please consider this carefully when adding, removing, or reorganizing these tests. They are\n+//! here so that it is clear what tests are required by the standard and what can be changed.\n+use ::core::str::FromStr;\n+\n+// IEEE 754 for many tests is applied to specific bit patterns.\n+// These generally are not applicable to NaN, however.\n+macro_rules! assert_biteq {\n+    ($lhs:expr, $rhs:expr) => {\n+        assert_eq!($lhs.to_bits(), $rhs.to_bits())\n+    };\n+}\n+\n+// ToString uses the default fmt::Display impl without special concerns, and bypasses other parts\n+// of the formatting infrastructure, which makes it ideal for testing here.\n+#[allow(unused_macros)]\n+macro_rules! roundtrip {\n+    ($f:expr => $t:ty) => {\n+        ($f).to_string().parse::<$t>().unwrap()\n+    };\n+}\n+\n+macro_rules! assert_floats_roundtrip {\n+    ($f:ident) => {\n+        assert_biteq!(f32::$f, roundtrip!(f32::$f => f32));\n+        assert_biteq!(f64::$f, roundtrip!(f64::$f => f64));\n+    };\n+    ($f:expr) => {\n+        assert_biteq!($f as f32, roundtrip!($f => f32));\n+        assert_biteq!($f as f64, roundtrip!($f => f64));\n+    }\n+}\n+\n+macro_rules! assert_floats_bitne {\n+    ($lhs:ident, $rhs:ident) => {\n+        assert_ne!(f32::$lhs.to_bits(), f32::$rhs.to_bits());\n+        assert_ne!(f64::$lhs.to_bits(), f64::$rhs.to_bits());\n+    };\n+    ($lhs:expr, $rhs:expr) => {\n+        assert_ne!(f32::to_bits($lhs), f32::to_bits($rhs));\n+        assert_ne!(f64::to_bits($lhs), f64::to_bits($rhs));\n+    };\n+}\n+\n+// We must preserve signs on all numbers. That includes zero.\n+// -0 and 0 are == normally, so test bit equality.\n+#[test]\n+fn preserve_signed_zero() {\n+    assert_floats_roundtrip!(-0.0);\n+    assert_floats_roundtrip!(0.0);\n+    assert_floats_bitne!(0.0, -0.0);\n+}\n+\n+#[test]\n+fn preserve_signed_infinity() {\n+    assert_floats_roundtrip!(INFINITY);\n+    assert_floats_roundtrip!(NEG_INFINITY);\n+    assert_floats_bitne!(INFINITY, NEG_INFINITY);\n+}\n+\n+#[test]\n+fn infinity_to_str() {\n+    assert!(match f32::INFINITY.to_string().to_lowercase().as_str() {\n+        \"+infinity\" | \"infinity\" => true,\n+        \"+inf\" | \"inf\" => true,\n+        _ => false,\n+    });\n+    assert!(\n+        match f64::INFINITY.to_string().to_lowercase().as_str() {\n+            \"+infinity\" | \"infinity\" => true,\n+            \"+inf\" | \"inf\" => true,\n+            _ => false,\n+        },\n+        \"Infinity must write to a string as some casing of inf or infinity, with an optional +.\"\n+    );\n+}\n+\n+#[test]\n+fn neg_infinity_to_str() {\n+    assert!(match f32::NEG_INFINITY.to_string().to_lowercase().as_str() {\n+        \"-infinity\" | \"-inf\" => true,\n+        _ => false,\n+    });\n+    assert!(\n+        match f64::NEG_INFINITY.to_string().to_lowercase().as_str() {\n+            \"-infinity\" | \"-inf\" => true,\n+            _ => false,\n+        },\n+        \"Negative Infinity must write to a string as some casing of -inf or -infinity\"\n+    )\n+}\n+\n+#[test]\n+fn nan_to_str() {\n+    assert!(\n+        match f32::NAN.to_string().to_lowercase().as_str() {\n+            \"nan\" | \"+nan\" | \"-nan\" => true,\n+            _ => false,\n+        },\n+        \"NaNs must write to a string as some casing of nan.\"\n+    )\n+}\n+\n+// \"+\"?(\"inf\"|\"infinity\") in any case => Infinity\n+#[test]\n+fn infinity_from_str() {\n+    assert_biteq!(f32::INFINITY, f32::from_str(\"infinity\").unwrap());\n+    assert_biteq!(f32::INFINITY, f32::from_str(\"inf\").unwrap());\n+    assert_biteq!(f32::INFINITY, f32::from_str(\"+infinity\").unwrap());\n+    assert_biteq!(f32::INFINITY, f32::from_str(\"+inf\").unwrap());\n+    // yes! this means you are weLcOmE tO mY iNfInItElY tWiStEd MiNd\n+    assert_biteq!(f32::INFINITY, f32::from_str(\"+iNfInItY\").unwrap());\n+}\n+\n+// \"-inf\"|\"-infinity\" in any case => Negative Infinity\n+#[test]\n+fn neg_infinity_from_str() {\n+    assert_biteq!(f32::NEG_INFINITY, f32::from_str(\"-infinity\").unwrap());\n+    assert_biteq!(f32::NEG_INFINITY, f32::from_str(\"-inf\").unwrap());\n+    assert_biteq!(f32::NEG_INFINITY, f32::from_str(\"-INF\").unwrap());\n+    assert_biteq!(f32::NEG_INFINITY, f32::from_str(\"-INFinity\").unwrap());\n+}\n+\n+// (\"+\"|\"-\"\")?\"s\"?\"nan\" in any case => qNaN\n+#[test]\n+fn qnan_from_str() {\n+    assert!(\"nan\".parse::<f32>().unwrap().is_nan());\n+    assert!(\"-nan\".parse::<f32>().unwrap().is_nan());\n+    assert!(\"+nan\".parse::<f32>().unwrap().is_nan());\n+    assert!(\"+NAN\".parse::<f32>().unwrap().is_nan());\n+    assert!(\"-NaN\".parse::<f32>().unwrap().is_nan());\n+}"}, {"sha": "bbb67667dfc057223743fe713c3a3046804de1e6", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc9b234928c1d64cc45686d9e61bb5993d8747fa/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9b234928c1d64cc45686d9e61bb5993d8747fa/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=fc9b234928c1d64cc45686d9e61bb5993d8747fa", "patch": "@@ -32,6 +32,7 @@ mod flt2dec;\n mod ops;\n mod wrapping;\n \n+mod ieee754;\n mod nan;\n \n /// Adds the attribute to all items in the block."}]}