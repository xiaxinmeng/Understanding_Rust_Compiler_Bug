{"sha": "dae8b68d9d4beea0fb2edc648321ae2af8870336", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZThiNjhkOWQ0YmVlYTBmYjJlZGM2NDgzMjFhZTJhZjg4NzAzMzY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-18T13:44:15Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-18T13:44:15Z"}, "message": "Merge #857\n\n857: remove local-vfs r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "2c03b6df907077945f02f52ce6c5ca131b69ee93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c03b6df907077945f02f52ce6c5ca131b69ee93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dae8b68d9d4beea0fb2edc648321ae2af8870336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dae8b68d9d4beea0fb2edc648321ae2af8870336", "html_url": "https://github.com/rust-lang/rust/commit/dae8b68d9d4beea0fb2edc648321ae2af8870336", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dae8b68d9d4beea0fb2edc648321ae2af8870336/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a591c3460b88f56fbab6af2d4e0c47ca12197405", "url": "https://api.github.com/repos/rust-lang/rust/commits/a591c3460b88f56fbab6af2d4e0c47ca12197405", "html_url": "https://github.com/rust-lang/rust/commit/a591c3460b88f56fbab6af2d4e0c47ca12197405"}, {"sha": "a6897a837c2f633bdc88b87c614db227aab3b1ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6897a837c2f633bdc88b87c614db227aab3b1ad", "html_url": "https://github.com/rust-lang/rust/commit/a6897a837c2f633bdc88b87c614db227aab3b1ad"}], "stats": {"total": 942, "additions": 6, "deletions": 936}, "files": [{"sha": "7b1412556c5c70efe09802ca2092032b730a1791", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dae8b68d9d4beea0fb2edc648321ae2af8870336/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dae8b68d9d4beea0fb2edc648321ae2af8870336/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dae8b68d9d4beea0fb2edc648321ae2af8870336", "patch": "@@ -928,7 +928,7 @@ dependencies = [\n  \"ra_hir 0.1.0\",\n  \"ra_project_model 0.1.0\",\n  \"ra_syntax 0.1.0\",\n- \"ra_vfs 0.1.0\",\n+ \"ra_vfs 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n@@ -1050,7 +1050,7 @@ dependencies = [\n  \"ra_project_model 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"ra_vfs 0.1.0\",\n+ \"ra_vfs 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.88 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1121,15 +1121,14 @@ dependencies = [\n [[package]]\n name = \"ra_vfs\"\n version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.10.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"notify 4.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"tempfile 3.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1986,6 +1985,7 @@ dependencies = [\n \"checksum proptest 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8ea66c78d75f2c6e9f304269eaef90899798daecc69f1a625d5a3dd793ff3522\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdd8e04bd9c52e0342b406469d494fcb033be4bdbe5c606016defbb1681411e1\"\n+\"checksum ra_vfs 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d191ef0680eea419a302e0d09a00c00dfed1ec320406813bc100f93d1abe28dc\"\n \"checksum rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca\"\n \"checksum rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef\"\n \"checksum rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b\""}, {"sha": "5b78cb76ed669576d86176de0c374f90ceabeae5", "filename": "crates/ra_batch/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dae8b68d9d4beea0fb2edc648321ae2af8870336/crates%2Fra_batch%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dae8b68d9d4beea0fb2edc648321ae2af8870336/crates%2Fra_batch%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2FCargo.toml?ref=dae8b68d9d4beea0fb2edc648321ae2af8870336", "patch": "@@ -10,10 +10,10 @@ rustc-hash = \"1.0\"\n \n failure = \"0.1.4\"\n \n+ra_vfs = \"0.1.0\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_db = { path = \"../ra_db\" }\n ra_hir = { path = \"../ra_hir\" }\n-ra_vfs = { path = \"../ra_vfs\" }\n ra_project_model = { path = \"../ra_project_model\" }\n \n [dev-dependencies]"}, {"sha": "6342e06280bc4881db0f6180007e91a19cb93494", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dae8b68d9d4beea0fb2edc648321ae2af8870336/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dae8b68d9d4beea0fb2edc648321ae2af8870336/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=dae8b68d9d4beea0fb2edc648321ae2af8870336", "patch": "@@ -19,13 +19,13 @@ lsp-types = \"0.55.0\"\n rustc-hash = \"1.0\"\n parking_lot = \"0.7.0\"\n \n+ra_vfs = \"0.1.0\"\n thread_worker = { path = \"../thread_worker\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_ide_api = { path = \"../ra_ide_api\" }\n ra_arena = { path = \"../ra_arena\" }\n gen_lsp_server = { path = \"../gen_lsp_server\" }\n-ra_vfs = { path = \"../ra_vfs\" }\n ra_project_model = { path = \"../ra_project_model\" }\n \n [dev-dependencies]"}, {"sha": "fdaf31b9c6f02997f1efe468e61d2dd0f2a0d705", "filename": "crates/ra_vfs/Cargo.toml", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2FCargo.toml?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -1,18 +0,0 @@\n-[package]\n-edition = \"2018\"\n-name = \"ra_vfs\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n-\n-[dependencies]\n-walkdir = \"2.2.7\"\n-relative-path = \"0.4.0\"\n-rustc-hash = \"1.0\"\n-crossbeam-channel = \"0.3.5\"\n-log = \"0.4.6\"\n-notify = \"4.0.9\"\n-parking_lot = \"0.7.0\"\n-\n-[dev-dependencies]\n-tempfile = \"3\"\n-flexi_logger = \"0.10.0\""}, {"sha": "5969ee0d06191e9d2206e694884472c59c5f2dee", "filename": "crates/ra_vfs/src/io.rs", "status": "removed", "additions": 0, "deletions": 286, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -1,286 +0,0 @@\n-use std::{\n-    fs,\n-    path::{Path, PathBuf},\n-    sync::{mpsc, Arc},\n-    time::Duration,\n-    thread,\n-};\n-use crossbeam_channel::{Sender, Receiver, unbounded, RecvError, select};\n-use relative_path::RelativePathBuf;\n-use walkdir::WalkDir;\n-use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n-\n-use crate::{Roots, VfsRoot, VfsTask};\n-\n-pub(crate) enum Task {\n-    AddRoot { root: VfsRoot },\n-}\n-\n-/// `TaskResult` transfers files read on the IO thread to the VFS on the main\n-/// thread.\n-#[derive(Debug)]\n-pub(crate) enum TaskResult {\n-    /// Emitted when we've recursively scanned a source root during the initial\n-    /// load.\n-    BulkLoadRoot { root: VfsRoot, files: Vec<(RelativePathBuf, String)> },\n-    /// Emitted when we've noticed that a single file has changed.\n-    ///\n-    /// Note that this by design does not distinguish between\n-    /// create/delete/write events, and instead specifies the *current* state of\n-    /// the file. The idea is to guarantee that in the quiescent state the sum\n-    /// of all results equals to the current state of the file system, while\n-    /// allowing to skip intermediate events in non-quiescent states.\n-    SingleFile { root: VfsRoot, path: RelativePathBuf, text: Option<String> },\n-}\n-\n-/// The kind of raw notification we've received from the notify library.\n-///\n-/// Note that these are not necessary 100% precise (for example we might receive\n-/// `Create` instead of `Write`, see #734), but we try do distinguish `Create`s\n-/// to implement recursive watching of directories.\n-#[derive(Debug)]\n-enum ChangeKind {\n-    Create,\n-    Write,\n-    Remove,\n-}\n-\n-const WATCHER_DELAY: Duration = Duration::from_millis(250);\n-\n-// Like thread::JoinHandle, but joins the thread on drop.\n-//\n-// This is useful because it guarantees the absence of run-away threads, even if\n-// code panics. This is important, because we might see panics in the test and\n-// we might be used in an IDE context, where a failed component is just\n-// restarted.\n-//\n-// Because all threads are joined, care must be taken to avoid deadlocks. That\n-// typically means ensuring that channels are dropped before the threads.\n-struct ScopedThread(Option<thread::JoinHandle<()>>);\n-\n-impl ScopedThread {\n-    fn spawn(name: String, f: impl FnOnce() + Send + 'static) -> ScopedThread {\n-        let handle = thread::Builder::new().name(name).spawn(f).unwrap();\n-        ScopedThread(Some(handle))\n-    }\n-}\n-\n-impl Drop for ScopedThread {\n-    fn drop(&mut self) {\n-        let res = self.0.take().unwrap().join();\n-        if !thread::panicking() {\n-            res.unwrap();\n-        }\n-    }\n-}\n-\n-pub(crate) struct Worker {\n-    // XXX: field order is significant here.\n-    //\n-    // In Rust, fields are dropped in the declaration order, and we rely on this\n-    // here. We must close sender first, so that the  `thread` (who holds the\n-    // opposite side of the channel) noticed shutdown. Then, we must join the\n-    // thread, but we must keep receiver alive so that the thread does not\n-    // panic.\n-    pub(crate) sender: Sender<Task>,\n-    _thread: ScopedThread,\n-    pub(crate) receiver: Receiver<VfsTask>,\n-}\n-\n-pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n-    // This is a pretty elaborate setup of threads & channels! It is\n-    // explained by the following concerns:\n-    //    * we need to burn a thread translating from notify's mpsc to\n-    //      crossbeam_channel.\n-    //    * we want to read all files from a single thread, to guarantee that\n-    //      we always get fresher versions and never go back in time.\n-    //    * we want to tear down everything neatly during shutdown.\n-    let _thread;\n-    // This are the channels we use to communicate with outside world.\n-    // If `input_receiver` is closed we need to tear ourselves down.\n-    // `output_sender` should not be closed unless the parent died.\n-    let (input_sender, input_receiver) = unbounded();\n-    let (output_sender, output_receiver) = unbounded();\n-\n-    _thread = ScopedThread::spawn(\"vfs\".to_string(), move || {\n-        // Make sure that the destruction order is\n-        //\n-        // * notify_sender\n-        // * _thread\n-        // * watcher_sender\n-        //\n-        // this is required to avoid deadlocks.\n-\n-        // These are the corresponding crossbeam channels\n-        let (watcher_sender, watcher_receiver) = unbounded();\n-        let _notify_thread;\n-        {\n-            // These are `std` channels notify will send events to\n-            let (notify_sender, notify_receiver) = mpsc::channel();\n-\n-            let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n-                .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n-                .ok();\n-            // Start a silly thread to transform between two channels\n-            _notify_thread = ScopedThread::spawn(\"notify-convertor\".to_string(), move || {\n-                notify_receiver\n-                    .into_iter()\n-                    .for_each(|event| convert_notify_event(event, &watcher_sender))\n-            });\n-\n-            // Process requests from the called or notifications from\n-            // watcher until the caller says stop.\n-            loop {\n-                select! {\n-                    // Received request from the caller. If this channel is\n-                    // closed, we should shutdown everything.\n-                    recv(input_receiver) -> t => match t {\n-                        Err(RecvError) => {\n-                            drop(input_receiver);\n-                            break\n-                        },\n-                        Ok(Task::AddRoot { root }) => {\n-                            watch_root(watcher.as_mut(), &output_sender, &*roots, root);\n-                        }\n-                    },\n-                    // Watcher send us changes. If **this** channel is\n-                    // closed, the watcher has died, which indicates a bug\n-                    // -- escalate!\n-                    recv(watcher_receiver) -> event => match event {\n-                        Err(RecvError) => panic!(\"watcher is dead\"),\n-                        Ok((path, change)) => {\n-                            handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n-                        }\n-                    },\n-                }\n-            }\n-        }\n-        // Drain pending events: we are not interested in them anyways!\n-        watcher_receiver.into_iter().for_each(|_| ());\n-    });\n-    Worker { sender: input_sender, _thread, receiver: output_receiver }\n-}\n-\n-fn watch_root(\n-    watcher: Option<&mut RecommendedWatcher>,\n-    sender: &Sender<VfsTask>,\n-    roots: &Roots,\n-    root: VfsRoot,\n-) {\n-    let root_path = roots.path(root);\n-    log::debug!(\"loading {} ...\", root_path.display());\n-    let files = watch_recursive(watcher, root_path, roots, root)\n-        .into_iter()\n-        .filter_map(|path| {\n-            let abs_path = path.to_path(&root_path);\n-            let text = read_to_string(&abs_path)?;\n-            Some((path, text))\n-        })\n-        .collect();\n-    let res = TaskResult::BulkLoadRoot { root, files };\n-    sender.send(VfsTask(res)).unwrap();\n-    log::debug!(\"... loaded {}\", root_path.display());\n-}\n-\n-fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeKind)>) {\n-    // forward relevant events only\n-    match event {\n-        DebouncedEvent::NoticeWrite(_)\n-        | DebouncedEvent::NoticeRemove(_)\n-        | DebouncedEvent::Chmod(_) => {\n-            // ignore\n-        }\n-        DebouncedEvent::Rescan => {\n-            // TODO: rescan all roots\n-        }\n-        DebouncedEvent::Create(path) => {\n-            sender.send((path, ChangeKind::Create)).unwrap();\n-        }\n-        DebouncedEvent::Write(path) => {\n-            sender.send((path, ChangeKind::Write)).unwrap();\n-        }\n-        DebouncedEvent::Remove(path) => {\n-            sender.send((path, ChangeKind::Remove)).unwrap();\n-        }\n-        DebouncedEvent::Rename(src, dst) => {\n-            sender.send((src, ChangeKind::Remove)).unwrap();\n-            sender.send((dst, ChangeKind::Create)).unwrap();\n-        }\n-        DebouncedEvent::Error(err, path) => {\n-            // TODO: should we reload the file contents?\n-            log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n-        }\n-    }\n-}\n-\n-fn handle_change(\n-    watcher: Option<&mut RecommendedWatcher>,\n-    sender: &Sender<VfsTask>,\n-    roots: &Roots,\n-    path: PathBuf,\n-    kind: ChangeKind,\n-) {\n-    let (root, rel_path) = match roots.find(&path) {\n-        None => return,\n-        Some(it) => it,\n-    };\n-    match kind {\n-        ChangeKind::Create => {\n-            let mut paths = Vec::new();\n-            if path.is_dir() {\n-                paths.extend(watch_recursive(watcher, &path, roots, root));\n-            } else {\n-                paths.push(rel_path);\n-            }\n-            paths\n-                .into_iter()\n-                .try_for_each(|rel_path| {\n-                    let abs_path = rel_path.to_path(&roots.path(root));\n-                    let text = read_to_string(&abs_path);\n-                    let res = TaskResult::SingleFile { root, path: rel_path, text };\n-                    sender.send(VfsTask(res))\n-                })\n-                .unwrap()\n-        }\n-        ChangeKind::Write | ChangeKind::Remove => {\n-            let text = read_to_string(&path);\n-            let res = TaskResult::SingleFile { root, path: rel_path, text };\n-            sender.send(VfsTask(res)).unwrap();\n-        }\n-    }\n-}\n-\n-fn watch_recursive(\n-    mut watcher: Option<&mut RecommendedWatcher>,\n-    dir: &Path,\n-    roots: &Roots,\n-    root: VfsRoot,\n-) -> Vec<RelativePathBuf> {\n-    let mut files = Vec::new();\n-    for entry in WalkDir::new(dir)\n-        .into_iter()\n-        .filter_entry(|it| roots.contains(root, it.path()).is_some())\n-        .filter_map(|it| it.map_err(|e| log::warn!(\"watcher error: {}\", e)).ok())\n-    {\n-        if entry.file_type().is_dir() {\n-            if let Some(watcher) = &mut watcher {\n-                watch_one(watcher, entry.path());\n-            }\n-        } else {\n-            let path = roots.contains(root, entry.path()).unwrap();\n-            files.push(path.to_owned());\n-        }\n-    }\n-    files\n-}\n-\n-fn watch_one(watcher: &mut RecommendedWatcher, dir: &Path) {\n-    match watcher.watch(dir, RecursiveMode::NonRecursive) {\n-        Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n-        Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n-    }\n-}\n-\n-fn read_to_string(path: &Path) -> Option<String> {\n-    fs::read_to_string(&path).map_err(|e| log::warn!(\"failed to read file {}\", e)).ok()\n-}"}, {"sha": "808c138dfee19d8c051ed27692acd99afbae5731", "filename": "crates/ra_vfs/src/lib.rs", "status": "removed", "additions": 0, "deletions": 296, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -1,296 +0,0 @@\n-//! VFS stands for Virtual File System.\n-//!\n-//! When doing analysis, we don't want to do any IO, we want to keep all source\n-//! code in memory. However, the actual source code is stored on disk, so you\n-//! need to get it into the memory in the first place somehow. VFS is the\n-//! component which does this.\n-//!\n-//! It is also responsible for watching the disk for changes, and for merging\n-//! editor state (modified, unsaved files) with disk state.\n-//!\n-//! TODO: Some LSP clients support watching the disk, so this crate should to\n-//! support custom watcher events (related to\n-//! <https://github.com/rust-analyzer/rust-analyzer/issues/131>)\n-//!\n-//! VFS is based on a concept of roots: a set of directories on the file system\n-//! which are watched for changes. Typically, there will be a root for each\n-//! Cargo package.\n-mod roots;\n-mod io;\n-\n-use std::{\n-    fmt, fs, mem,\n-    path::{Path, PathBuf},\n-    sync::Arc,\n-};\n-\n-use crossbeam_channel::Receiver;\n-use relative_path::{RelativePath, RelativePathBuf};\n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use crate::{\n-    io::{TaskResult, Worker},\n-    roots::Roots,\n-};\n-\n-pub use crate::roots::VfsRoot;\n-\n-/// Opaque wrapper around file-system event.\n-///\n-/// Calling code is expected to just pass `VfsTask` to `handle_task` method. It\n-/// is exposed as a public API so that the caller can plug vfs events into the\n-/// main event loop and be notified when changes happen.\n-pub struct VfsTask(TaskResult);\n-\n-impl fmt::Debug for VfsTask {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"VfsTask { ... }\")\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsFile(pub u32);\n-\n-struct VfsFileData {\n-    root: VfsRoot,\n-    path: RelativePathBuf,\n-    is_overlayed: bool,\n-    text: Arc<String>,\n-}\n-\n-pub struct Vfs {\n-    roots: Arc<Roots>,\n-    files: Vec<VfsFileData>,\n-    root2files: FxHashMap<VfsRoot, FxHashSet<VfsFile>>,\n-    pending_changes: Vec<VfsChange>,\n-    worker: Worker,\n-}\n-\n-impl fmt::Debug for Vfs {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Vfs\")\n-            .field(\"n_roots\", &self.roots.len())\n-            .field(\"n_files\", &self.files.len())\n-            .field(\"n_pending_changes\", &self.pending_changes.len())\n-            .finish()\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-pub enum VfsChange {\n-    AddRoot { root: VfsRoot, files: Vec<(VfsFile, RelativePathBuf, Arc<String>)> },\n-    AddFile { root: VfsRoot, file: VfsFile, path: RelativePathBuf, text: Arc<String> },\n-    RemoveFile { root: VfsRoot, file: VfsFile, path: RelativePathBuf },\n-    ChangeFile { file: VfsFile, text: Arc<String> },\n-}\n-\n-impl Vfs {\n-    pub fn new(roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n-        let roots = Arc::new(Roots::new(roots));\n-        let worker = io::start(Arc::clone(&roots));\n-        let mut root2files = FxHashMap::default();\n-\n-        for root in roots.iter() {\n-            root2files.insert(root, Default::default());\n-            worker.sender.send(io::Task::AddRoot { root }).unwrap();\n-        }\n-        let res = Vfs { roots, files: Vec::new(), root2files, worker, pending_changes: Vec::new() };\n-        let vfs_roots = res.roots.iter().collect();\n-        (res, vfs_roots)\n-    }\n-\n-    pub fn root2path(&self, root: VfsRoot) -> PathBuf {\n-        self.roots.path(root).to_path_buf()\n-    }\n-\n-    pub fn path2file(&self, path: &Path) -> Option<VfsFile> {\n-        if let Some((_root, _path, Some(file))) = self.find_root(path) {\n-            return Some(file);\n-        }\n-        None\n-    }\n-\n-    pub fn file2path(&self, file: VfsFile) -> PathBuf {\n-        let rel_path = &self.file(file).path;\n-        let root_path = &self.roots.path(self.file(file).root);\n-        rel_path.to_path(root_path)\n-    }\n-\n-    pub fn n_roots(&self) -> usize {\n-        self.roots.len()\n-    }\n-\n-    pub fn load(&mut self, path: &Path) -> Option<VfsFile> {\n-        if let Some((root, rel_path, file)) = self.find_root(path) {\n-            return if let Some(file) = file {\n-                Some(file)\n-            } else {\n-                let text = fs::read_to_string(path).unwrap_or_default();\n-                let text = Arc::new(text);\n-                let file = self.raw_add_file(root, rel_path.clone(), Arc::clone(&text), false);\n-                let change = VfsChange::AddFile { file, text, root, path: rel_path };\n-                self.pending_changes.push(change);\n-                Some(file)\n-            };\n-        }\n-        None\n-    }\n-\n-    pub fn add_file_overlay(&mut self, path: &Path, text: String) -> Option<VfsFile> {\n-        let (root, rel_path, file) = self.find_root(path)?;\n-        if let Some(file) = file {\n-            self.change_file_event(file, text, true);\n-            Some(file)\n-        } else {\n-            self.add_file_event(root, rel_path, text, true)\n-        }\n-    }\n-\n-    pub fn change_file_overlay(&mut self, path: &Path, new_text: String) {\n-        if let Some((_root, _path, file)) = self.find_root(path) {\n-            let file = file.expect(\"can't change a file which wasn't added\");\n-            self.change_file_event(file, new_text, true);\n-        }\n-    }\n-\n-    pub fn remove_file_overlay(&mut self, path: &Path) -> Option<VfsFile> {\n-        let (root, rel_path, file) = self.find_root(path)?;\n-        let file = file.expect(\"can't remove a file which wasn't added\");\n-        let full_path = rel_path.to_path(&self.roots.path(root));\n-        if let Ok(text) = fs::read_to_string(&full_path) {\n-            self.change_file_event(file, text, false);\n-        } else {\n-            self.remove_file_event(root, rel_path, file);\n-        }\n-        Some(file)\n-    }\n-\n-    pub fn commit_changes(&mut self) -> Vec<VfsChange> {\n-        mem::replace(&mut self.pending_changes, Vec::new())\n-    }\n-\n-    pub fn task_receiver(&self) -> &Receiver<VfsTask> {\n-        &self.worker.receiver\n-    }\n-\n-    pub fn handle_task(&mut self, task: VfsTask) {\n-        match task.0 {\n-            TaskResult::BulkLoadRoot { root, files } => {\n-                let mut cur_files = Vec::new();\n-                // While we were scanning the root in the background, a file might have\n-                // been open in the editor, so we need to account for that.\n-                let existing = self.root2files[&root]\n-                    .iter()\n-                    .map(|&file| (self.file(file).path.clone(), file))\n-                    .collect::<FxHashMap<_, _>>();\n-                for (path, text) in files {\n-                    if let Some(&file) = existing.get(&path) {\n-                        let text = Arc::clone(&self.file(file).text);\n-                        cur_files.push((file, path, text));\n-                        continue;\n-                    }\n-                    let text = Arc::new(text);\n-                    let file = self.raw_add_file(root, path.clone(), Arc::clone(&text), false);\n-                    cur_files.push((file, path, text));\n-                }\n-\n-                let change = VfsChange::AddRoot { root, files: cur_files };\n-                self.pending_changes.push(change);\n-            }\n-            TaskResult::SingleFile { root, path, text } => {\n-                let existing_file = self.find_file(root, &path);\n-                if existing_file.map(|file| self.file(file).is_overlayed) == Some(true) {\n-                    return;\n-                }\n-                match (existing_file, text) {\n-                    (Some(file), None) => {\n-                        self.remove_file_event(root, path, file);\n-                    }\n-                    (None, Some(text)) => {\n-                        self.add_file_event(root, path, text, false);\n-                    }\n-                    (Some(file), Some(text)) => {\n-                        self.change_file_event(file, text, false);\n-                    }\n-                    (None, None) => (),\n-                }\n-            }\n-        }\n-    }\n-\n-    // *_event calls change the state of VFS and push a change onto pending\n-    // changes array.\n-\n-    fn add_file_event(\n-        &mut self,\n-        root: VfsRoot,\n-        path: RelativePathBuf,\n-        text: String,\n-        is_overlay: bool,\n-    ) -> Option<VfsFile> {\n-        let text = Arc::new(text);\n-        let file = self.raw_add_file(root, path.clone(), text.clone(), is_overlay);\n-        self.pending_changes.push(VfsChange::AddFile { file, root, path, text });\n-        Some(file)\n-    }\n-\n-    fn change_file_event(&mut self, file: VfsFile, text: String, is_overlay: bool) {\n-        let text = Arc::new(text);\n-        self.raw_change_file(file, text.clone(), is_overlay);\n-        self.pending_changes.push(VfsChange::ChangeFile { file, text });\n-    }\n-\n-    fn remove_file_event(&mut self, root: VfsRoot, path: RelativePathBuf, file: VfsFile) {\n-        self.raw_remove_file(file);\n-        self.pending_changes.push(VfsChange::RemoveFile { root, path, file });\n-    }\n-\n-    // raw_* calls change the state of VFS, but **do not** emit events.\n-\n-    fn raw_add_file(\n-        &mut self,\n-        root: VfsRoot,\n-        path: RelativePathBuf,\n-        text: Arc<String>,\n-        is_overlayed: bool,\n-    ) -> VfsFile {\n-        let data = VfsFileData { root, path, text, is_overlayed };\n-        let file = VfsFile(self.files.len() as u32);\n-        self.files.push(data);\n-        self.root2files.get_mut(&root).unwrap().insert(file);\n-        file\n-    }\n-\n-    fn raw_change_file(&mut self, file: VfsFile, new_text: Arc<String>, is_overlayed: bool) {\n-        let mut file_data = &mut self.file_mut(file);\n-        file_data.text = new_text;\n-        file_data.is_overlayed = is_overlayed;\n-    }\n-\n-    fn raw_remove_file(&mut self, file: VfsFile) {\n-        // FIXME: use arena with removal\n-        self.file_mut(file).text = Default::default();\n-        self.file_mut(file).path = Default::default();\n-        let root = self.file(file).root;\n-        let removed = self.root2files.get_mut(&root).unwrap().remove(&file);\n-        assert!(removed);\n-    }\n-\n-    fn find_root(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf, Option<VfsFile>)> {\n-        let (root, path) = self.roots.find(&path)?;\n-        let file = self.find_file(root, &path);\n-        Some((root, path, file))\n-    }\n-\n-    fn find_file(&self, root: VfsRoot, path: &RelativePath) -> Option<VfsFile> {\n-        self.root2files[&root].iter().map(|&it| it).find(|&file| self.file(file).path == path)\n-    }\n-\n-    fn file(&self, file: VfsFile) -> &VfsFileData {\n-        &self.files[file.0 as usize]\n-    }\n-\n-    fn file_mut(&mut self, file: VfsFile) -> &mut VfsFileData {\n-        &mut self.files[file.0 as usize]\n-    }\n-}"}, {"sha": "4503458eed173e62513a180a3e96edf607046ee6", "filename": "crates/ra_vfs/src/roots.rs", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Froots.rs?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -1,108 +0,0 @@\n-use std::{\n-    iter,\n-    path::{Path, PathBuf},\n-};\n-\n-use relative_path::{ RelativePath, RelativePathBuf};\n-\n-/// VfsRoot identifies a watched directory on the file system.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsRoot(pub u32);\n-\n-/// Describes the contents of a single source root.\n-///\n-/// `RootConfig` can be thought of as a glob pattern like `src/**.rs` which\n-/// specifies the source root or as a function which takes a `PathBuf` and\n-/// returns `true` iff path belongs to the source root\n-struct RootData {\n-    path: PathBuf,\n-    // result of `root.canonicalize()` if that differs from `root`; `None` otherwise.\n-    canonical_path: Option<PathBuf>,\n-    excluded_dirs: Vec<RelativePathBuf>,\n-}\n-\n-pub(crate) struct Roots {\n-    roots: Vec<RootData>,\n-}\n-\n-impl Roots {\n-    pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n-        let mut roots = Vec::new();\n-        // A hack to make nesting work.\n-        paths.sort_by_key(|it| std::cmp::Reverse(it.as_os_str().len()));\n-        paths.dedup();\n-        for (i, path) in paths.iter().enumerate() {\n-            let nested_roots =\n-                paths[..i].iter().filter_map(|it| rel_path(path, it)).collect::<Vec<_>>();\n-\n-            roots.push(RootData::new(path.clone(), nested_roots));\n-        }\n-        Roots { roots }\n-    }\n-    pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n-        self.iter().find_map(|root| {\n-            let rel_path = self.contains(root, path)?;\n-            Some((root, rel_path))\n-        })\n-    }\n-    pub(crate) fn len(&self) -> usize {\n-        self.roots.len()\n-    }\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = VfsRoot> + 'a {\n-        (0..self.roots.len()).into_iter().map(|idx| VfsRoot(idx as u32))\n-    }\n-    pub(crate) fn path(&self, root: VfsRoot) -> &Path {\n-        self.root(root).path.as_path()\n-    }\n-    /// Checks if root contains a path and returns a root-relative path.\n-    pub(crate) fn contains(&self, root: VfsRoot, path: &Path) -> Option<RelativePathBuf> {\n-        let data = self.root(root);\n-        iter::once(&data.path)\n-            .chain(data.canonical_path.as_ref().into_iter())\n-            .find_map(|base| rel_path(base, path))\n-            .filter(|path| !data.excluded_dirs.contains(path))\n-            .filter(|path| !data.is_excluded(path))\n-    }\n-\n-    fn root(&self, root: VfsRoot) -> &RootData {\n-        &self.roots[root.0 as usize]\n-    }\n-}\n-\n-impl RootData {\n-    fn new(path: PathBuf, excluded_dirs: Vec<RelativePathBuf>) -> RootData {\n-        let mut canonical_path = path.canonicalize().ok();\n-        if Some(&path) == canonical_path.as_ref() {\n-            canonical_path = None;\n-        }\n-        RootData { path, canonical_path, excluded_dirs }\n-    }\n-\n-    fn is_excluded(&self, path: &RelativePath) -> bool {\n-        if self.excluded_dirs.iter().any(|it| it == path) {\n-            return true;\n-        }\n-        // Ignore some common directories.\n-        //\n-        // FIXME: don't hard-code, specify at source-root creation time using\n-        // gitignore\n-        for (i, c) in path.components().enumerate() {\n-            if let relative_path::Component::Normal(c) = c {\n-                if (i == 0 && c == \"target\") || c == \".git\" || c == \"node_modules\" {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        match path.extension() {\n-            None | Some(\"rs\") => false,\n-            _ => true,\n-        }\n-    }\n-}\n-\n-fn rel_path(base: &Path, path: &Path) -> Option<RelativePathBuf> {\n-    let path = path.strip_prefix(base).ok()?;\n-    let path = RelativePathBuf::from_path(path).unwrap();\n-    Some(path)\n-}"}, {"sha": "200a03e54bb1621c63a777321a01678774ff8aad", "filename": "crates/ra_vfs/tests/vfs.rs", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Ftests%2Fvfs.rs?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -1,222 +0,0 @@\n-use std::{collections::HashSet, fs, time::Duration};\n-\n-// use flexi_logger::Logger;\n-use crossbeam_channel::RecvTimeoutError;\n-use ra_vfs::{Vfs, VfsChange};\n-use tempfile::tempdir;\n-\n-/// Processes exactly `num_tasks` events waiting in the `vfs` message queue.\n-///\n-/// Panics if there are not exactly that many tasks enqueued for processing.\n-fn process_tasks(vfs: &mut Vfs, num_tasks: u32) {\n-    process_tasks_in_range(vfs, num_tasks, num_tasks);\n-}\n-\n-/// Processes up to `max_count` events waiting in the `vfs` message queue.\n-///\n-/// Panics if it cannot process at least `min_count` events.\n-/// Panics if more than `max_count` events are enqueued for processing.\n-fn process_tasks_in_range(vfs: &mut Vfs, min_count: u32, max_count: u32) {\n-    for i in 0..max_count {\n-        let task = match vfs.task_receiver().recv_timeout(Duration::from_secs(3)) {\n-            Err(RecvTimeoutError::Timeout) if i >= min_count => return,\n-            otherwise => otherwise.unwrap(),\n-        };\n-        log::debug!(\"{:?}\", task);\n-        vfs.handle_task(task);\n-    }\n-    assert!(vfs.task_receiver().is_empty());\n-}\n-\n-macro_rules! assert_match {\n-    ($x:expr, $pat:pat) => {\n-        assert_match!($x, $pat, ())\n-    };\n-    ($x:expr, $pat:pat, $assert:expr) => {\n-        match $x {\n-            $pat => $assert,\n-            x => assert!(false, \"Expected {}, got {:?}\", stringify!($pat), x),\n-        };\n-    };\n-}\n-\n-#[test]\n-fn test_vfs_works() -> std::io::Result<()> {\n-    // Logger::with_str(\"vfs=debug,ra_vfs=debug\").start().unwrap();\n-\n-    let files = [(\"a/foo.rs\", \"hello\"), (\"a/bar.rs\", \"world\"), (\"a/b/baz.rs\", \"nested hello\")];\n-\n-    let dir = tempdir().unwrap();\n-    for (path, text) in files.iter() {\n-        let file_path = dir.path().join(path);\n-        fs::create_dir_all(file_path.parent().unwrap()).unwrap();\n-        fs::write(file_path, text)?\n-    }\n-\n-    let a_root = dir.path().join(\"a\");\n-    let b_root = dir.path().join(\"a/b\");\n-\n-    let (mut vfs, _) = Vfs::new(vec![a_root, b_root]);\n-    process_tasks(&mut vfs, 2);\n-    {\n-        let files = vfs\n-            .commit_changes()\n-            .into_iter()\n-            .flat_map(|change| {\n-                let files = match change {\n-                    VfsChange::AddRoot { files, .. } => files,\n-                    _ => panic!(\"unexpected change\"),\n-                };\n-                files.into_iter().map(|(_id, path, text)| {\n-                    let text: String = (&*text).clone();\n-                    (format!(\"{}\", path.display()), text)\n-                })\n-            })\n-            .collect::<HashSet<_>>();\n-\n-        let expected_files = [(\"foo.rs\", \"hello\"), (\"bar.rs\", \"world\"), (\"baz.rs\", \"nested hello\")]\n-            .iter()\n-            .map(|(path, text)| (path.to_string(), text.to_string()))\n-            .collect::<HashSet<_>>();\n-\n-        assert_eq!(files, expected_files);\n-    }\n-\n-    // rust-analyzer#734: fsevents has a bunch of events still sitting around.\n-    process_tasks_in_range(&mut vfs, 0, if cfg!(target_os = \"macos\") { 7 } else { 0 });\n-    match vfs.commit_changes().as_slice() {\n-        [] => {}\n-\n-        // This arises on fsevents (unless we wait 30 seconds before\n-        // calling `Vfs::new` above). We need to churn through these\n-        // events so that we can focus on the event that arises from\n-        // the `fs::write` below.\n-        [VfsChange::ChangeFile { .. }, // hello\n-         VfsChange::ChangeFile { .. }, // world\n-         VfsChange::AddFile { .. }, // b/baz.rs, nested hello\n-         VfsChange::ChangeFile { .. }, // hello\n-         VfsChange::ChangeFile { .. }, // world\n-         VfsChange::ChangeFile { .. }, // nested hello\n-         VfsChange::ChangeFile { .. }, // nested hello\n-        ] => {}\n-\n-        changes => panic!(\"Expected events for setting up initial files, got: {GOT:?}\",\n-                          GOT=changes),\n-    }\n-\n-    fs::write(&dir.path().join(\"a/b/baz.rs\"), \"quux\").unwrap();\n-    process_tasks(&mut vfs, 1);\n-    assert_match!(\n-        vfs.commit_changes().as_slice(),\n-        [VfsChange::ChangeFile { text, .. }],\n-        assert_eq!(text.as_str(), \"quux\")\n-    );\n-\n-    vfs.add_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"m\".to_string());\n-    assert_match!(\n-        vfs.commit_changes().as_slice(),\n-        [VfsChange::ChangeFile { text, .. }],\n-        assert_eq!(text.as_str(), \"m\")\n-    );\n-\n-    // changing file on disk while overlayed doesn't generate a VfsChange\n-    fs::write(&dir.path().join(\"a/b/baz.rs\"), \"corge\").unwrap();\n-    process_tasks(&mut vfs, 1);\n-    assert_match!(vfs.commit_changes().as_slice(), []);\n-\n-    // removing overlay restores data on disk\n-    vfs.remove_file_overlay(&dir.path().join(\"a/b/baz.rs\"));\n-    assert_match!(\n-        vfs.commit_changes().as_slice(),\n-        [VfsChange::ChangeFile { text, .. }],\n-        assert_eq!(text.as_str(), \"corge\")\n-    );\n-\n-    vfs.add_file_overlay(&dir.path().join(\"a/b/spam.rs\"), \"spam\".to_string());\n-    assert_match!(vfs.commit_changes().as_slice(), [VfsChange::AddFile { text, path, .. }], {\n-        assert_eq!(text.as_str(), \"spam\");\n-        assert_eq!(path, \"spam.rs\");\n-    });\n-\n-    vfs.remove_file_overlay(&dir.path().join(\"a/b/spam.rs\"));\n-    assert_match!(\n-        vfs.commit_changes().as_slice(),\n-        [VfsChange::RemoveFile { path, .. }],\n-        assert_eq!(path, \"spam.rs\")\n-    );\n-\n-    fs::create_dir_all(dir.path().join(\"a/sub1/sub2\")).unwrap();\n-    fs::write(dir.path().join(\"a/sub1/sub2/new.rs\"), \"new hello\").unwrap();\n-    process_tasks(&mut vfs, 1);\n-    assert_match!(vfs.commit_changes().as_slice(), [VfsChange::AddFile { text, path, .. }], {\n-        assert_eq!(text.as_str(), \"new hello\");\n-        assert_eq!(path, \"sub1/sub2/new.rs\");\n-    });\n-\n-    fs::rename(&dir.path().join(\"a/sub1/sub2/new.rs\"), &dir.path().join(\"a/sub1/sub2/new1.rs\"))\n-        .unwrap();\n-\n-    // rust-analyzer#734: For testing purposes, work-around\n-    // passcod/notify#181 by processing either 1 or 2 events. (In\n-    // particular, Mac can hand back either 1 or 2 events in a\n-    // timing-dependent fashion.)\n-    //\n-    // rust-analyzer#827: Windows generates extra `Write` events when\n-    // renaming? meaning we have extra tasks to process.\n-    process_tasks_in_range(&mut vfs, 1, if cfg!(windows) { 4 } else { 2 });\n-    match vfs.commit_changes().as_slice() {\n-        [VfsChange::RemoveFile { path: removed_path, .. }, VfsChange::AddFile { text, path: added_path, .. }] =>\n-        {\n-            assert_eq!(removed_path, \"sub1/sub2/new.rs\");\n-            assert_eq!(added_path, \"sub1/sub2/new1.rs\");\n-            assert_eq!(text.as_str(), \"new hello\");\n-        }\n-\n-        // Hopefully passcod/notify#181 will be addressed in some\n-        // manner that will reliably emit an event mentioning\n-        // `sub1/sub2/new.rs`. But until then, must accept that\n-        // debouncing loses information unrecoverably.\n-        [VfsChange::AddFile { text, path: added_path, .. }] => {\n-            assert_eq!(added_path, \"sub1/sub2/new1.rs\");\n-            assert_eq!(text.as_str(), \"new hello\");\n-        }\n-\n-        changes => panic!(\n-            \"Expected events for rename of {OLD} to {NEW}, got: {GOT:?}\",\n-            OLD = \"sub1/sub2/new.rs\",\n-            NEW = \"sub1/sub2/new1.rs\",\n-            GOT = changes\n-        ),\n-    }\n-\n-    fs::remove_file(&dir.path().join(\"a/sub1/sub2/new1.rs\")).unwrap();\n-    process_tasks(&mut vfs, 1);\n-    assert_match!(\n-        vfs.commit_changes().as_slice(),\n-        [VfsChange::RemoveFile { path, .. }],\n-        assert_eq!(path, \"sub1/sub2/new1.rs\")\n-    );\n-\n-    {\n-        vfs.add_file_overlay(&dir.path().join(\"a/memfile.rs\"), \"memfile\".to_string());\n-        assert_match!(\n-            vfs.commit_changes().as_slice(),\n-            [VfsChange::AddFile { text, .. }],\n-            assert_eq!(text.as_str(), \"memfile\")\n-        );\n-        fs::write(&dir.path().join(\"a/memfile.rs\"), \"ignore me\").unwrap();\n-        process_tasks(&mut vfs, 1);\n-        assert_match!(vfs.commit_changes().as_slice(), []);\n-    }\n-\n-    // should be ignored\n-    fs::create_dir_all(dir.path().join(\"a/target\")).unwrap();\n-    fs::write(&dir.path().join(\"a/target/new.rs\"), \"ignore me\").unwrap();\n-\n-    assert_match!(\n-        vfs.task_receiver().recv_timeout(Duration::from_millis(300)), // slightly more than watcher debounce delay\n-        Err(RecvTimeoutError::Timeout)\n-    );\n-\n-    Ok(())\n-}"}]}