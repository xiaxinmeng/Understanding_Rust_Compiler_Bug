{"sha": "5cbde9f531e6afb315ac71f679a0f3c469088137", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYmRlOWY1MzFlNmFmYjMxNWFjNzFmNjc5YTBmM2M0NjkwODgxMzc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-23T16:49:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-23T16:49:08Z"}, "message": "Merge #8591 #8638\n\n8591: Remove SyntaxRewriter usage in insert_use in favor of mutable syntax trees r=matklad a=Veykril\n\nUnfortunately changing `insert_use` to not use `SyntaxRewriter` creates a lot of changes since so much relies on that. But on the other hand this should be the biggest usage of `SyntaxRewriter` I believe.\n\n8638: Remove SyntaxRewriter::from_fn r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "9f80fa75fa44146518a46237f0fa29e15eb2d6c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f80fa75fa44146518a46237f0fa29e15eb2d6c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cbde9f531e6afb315ac71f679a0f3c469088137", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJggvqECRBK7hj4Ov3rIwAAWl4IAEtblAPkQ2F1HYhsp+/P4bwL\nl/KCqVPorPVFBahNv86AUx6NJZxHG9Xzkrwc+TM/OG+SV0swGTWC/STtrSVB29S0\nu6mhiWJB00cuHqqRoQI/o0YP9ENrdisWBZKA8lxJnij7wZhuy/6zn5DFAYV6BXum\nLaH8TsZ5vcTphFMdtynKjRYlrrY6fvXfjXbTtysWKd84PhALIn1nKl/wnpg9JiEK\nH5oHt6gY2yihJSJfsQlYt+P248+fIlglD1Qdl2Lr3BGCmyUqiQejHKkwB29hdAXL\nfsXb/I7K+xSayqbKQkJxyXkn8xTG3NVDuKcHhj//VwIpK3CWoxifjz2XVeDLpXg=\n=8ykl\n-----END PGP SIGNATURE-----\n", "payload": "tree 9f80fa75fa44146518a46237f0fa29e15eb2d6c3\nparent 20f82191a038b05ead5c4d666fcd75f053a2dc6c\nparent d5c9de65c555235d7a27dc4617858b7a24be4935\nparent e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1619196548 +0000\ncommitter GitHub <noreply@github.com> 1619196548 +0000\n\nMerge #8591 #8638\n\n8591: Remove SyntaxRewriter usage in insert_use in favor of mutable syntax trees r=matklad a=Veykril\n\nUnfortunately changing `insert_use` to not use `SyntaxRewriter` creates a lot of changes since so much relies on that. But on the other hand this should be the biggest usage of `SyntaxRewriter` I believe.\n\n8638: Remove SyntaxRewriter::from_fn r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cbde9f531e6afb315ac71f679a0f3c469088137", "html_url": "https://github.com/rust-lang/rust/commit/5cbde9f531e6afb315ac71f679a0f3c469088137", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cbde9f531e6afb315ac71f679a0f3c469088137/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20f82191a038b05ead5c4d666fcd75f053a2dc6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/20f82191a038b05ead5c4d666fcd75f053a2dc6c", "html_url": "https://github.com/rust-lang/rust/commit/20f82191a038b05ead5c4d666fcd75f053a2dc6c"}, {"sha": "d5c9de65c555235d7a27dc4617858b7a24be4935", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c9de65c555235d7a27dc4617858b7a24be4935", "html_url": "https://github.com/rust-lang/rust/commit/d5c9de65c555235d7a27dc4617858b7a24be4935"}, {"sha": "e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8", "html_url": "https://github.com/rust-lang/rust/commit/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8"}], "stats": {"total": 686, "additions": 331, "deletions": 355}, "files": [{"sha": "e5ae718c9fd148292bb2b62ad9a0a244e2e90a11", "filename": "crates/ide_assists/src/ast_transform.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fast_transform.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -3,20 +3,27 @@ use hir::{HirDisplay, PathResolution, SemanticsScope};\n use ide_db::helpers::mod_path_to_ast;\n use rustc_hash::FxHashMap;\n use syntax::{\n-    algo::SyntaxRewriter,\n     ast::{self, AstNode},\n-    SyntaxNode,\n+    ted, SyntaxNode,\n };\n \n-pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n-    SyntaxRewriter::from_fn(|element| match element {\n-        syntax::SyntaxElement::Node(n) => {\n-            let replacement = transformer.get_substitution(&n, transformer)?;\n-            Some(replacement.into())\n+pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: &N) {\n+    let mut skip_to = None;\n+    for event in node.syntax().preorder() {\n+        match event {\n+            syntax::WalkEvent::Enter(node) if skip_to.is_none() => {\n+                skip_to = transformer.get_substitution(&node, transformer).zip(Some(node));\n+            }\n+            syntax::WalkEvent::Enter(_) => (),\n+            syntax::WalkEvent::Leave(node) => match &skip_to {\n+                Some((replacement, skip_target)) if *skip_target == node => {\n+                    ted::replace(node, replacement.clone_for_update());\n+                    skip_to.take();\n+                }\n+                _ => (),\n+            },\n         }\n-        _ => None,\n-    })\n-    .rewrite_ast(&node)\n+    }\n }\n \n /// `AstTransform` helps with applying bulk transformations to syntax nodes.\n@@ -191,11 +198,9 @@ impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n                 let found_path = from.find_use_path(self.source_scope.db.upcast(), def)?;\n                 let mut path = mod_path_to_ast(&found_path);\n \n-                let type_args = p\n-                    .segment()\n-                    .and_then(|s| s.generic_arg_list())\n-                    .map(|arg_list| apply(recur, arg_list));\n+                let type_args = p.segment().and_then(|s| s.generic_arg_list());\n                 if let Some(type_args) = type_args {\n+                    apply(recur, &type_args);\n                     let last_segment = path.segment().unwrap();\n                     path = path.with_segment(last_segment.with_generic_args(type_args))\n                 }"}, {"sha": "a454a2af3291508c49708e352ae3f97b38d30ff7", "filename": "crates/ide_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -93,17 +93,19 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     let range = ctx.sema.original_range(&syntax_under_caret).range;\n     let group_label = group_label(import_assets.import_candidate());\n-    let scope = ImportScope::find_insert_use_container(&syntax_under_caret, &ctx.sema)?;\n+    let scope = ImportScope::find_insert_use_container_with_macros(&syntax_under_caret, &ctx.sema)?;\n     for import in proposed_imports {\n         acc.add_group(\n             &group_label,\n             AssistId(\"auto_import\", AssistKind::QuickFix),\n             format!(\"Import `{}`\", import.import_path),\n             range,\n             |builder| {\n-                let rewriter =\n-                    insert_use(&scope, mod_path_to_ast(&import.import_path), ctx.config.insert_use);\n-                builder.rewrite(rewriter);\n+                let scope = match scope.clone() {\n+                    ImportScope::File(it) => ImportScope::File(builder.make_ast_mut(it)),\n+                    ImportScope::Module(it) => ImportScope::Module(builder.make_ast_mut(it)),\n+                };\n+                insert_use(&scope, mod_path_to_ast(&import.import_path), ctx.config.insert_use);\n             },\n         );\n     }"}, {"sha": "66f274fa78c1398a4bf3c23d0c517502f0d38dad", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 110, "deletions": 98, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -5,17 +5,17 @@ use hir::{Module, ModuleDef, Name, Variant};\n use ide_db::{\n     defs::Definition,\n     helpers::{\n-        insert_use::{insert_use, ImportScope},\n+        insert_use::{insert_use, ImportScope, InsertUseConfig},\n         mod_path_to_ast,\n     },\n     search::FileReference,\n     RootDatabase,\n };\n use rustc_hash::FxHashSet;\n use syntax::{\n-    algo::{find_node_at_offset, SyntaxRewriter},\n-    ast::{self, edit::IndentLevel, make, AstNode, NameOwner, VisibilityOwner},\n-    SourceFile, SyntaxElement, SyntaxNode, T,\n+    algo::find_node_at_offset,\n+    ast::{self, make, AstNode, NameOwner, VisibilityOwner},\n+    ted, SyntaxNode, T,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -62,40 +62,50 @@ pub(crate) fn extract_struct_from_enum_variant(\n             let mut visited_modules_set = FxHashSet::default();\n             let current_module = enum_hir.module(ctx.db());\n             visited_modules_set.insert(current_module);\n-            let mut def_rewriter = None;\n+            // record file references of the file the def resides in, we only want to swap to the edited file in the builder once\n+            let mut def_file_references = None;\n             for (file_id, references) in usages {\n-                let mut rewriter = SyntaxRewriter::default();\n-                let source_file = ctx.sema.parse(file_id);\n-                for reference in references {\n-                    update_reference(\n-                        ctx,\n-                        &mut rewriter,\n-                        reference,\n-                        &source_file,\n-                        &enum_module_def,\n-                        &variant_hir_name,\n-                        &mut visited_modules_set,\n-                    );\n-                }\n                 if file_id == ctx.frange.file_id {\n-                    def_rewriter = Some(rewriter);\n+                    def_file_references = Some(references);\n                     continue;\n                 }\n                 builder.edit_file(file_id);\n-                builder.rewrite(rewriter);\n+                let source_file = builder.make_ast_mut(ctx.sema.parse(file_id));\n+                let processed = process_references(\n+                    ctx,\n+                    &mut visited_modules_set,\n+                    source_file.syntax(),\n+                    &enum_module_def,\n+                    &variant_hir_name,\n+                    references,\n+                );\n+                processed.into_iter().for_each(|(path, node, import)| {\n+                    apply_references(ctx.config.insert_use, path, node, import)\n+                });\n             }\n-            let mut rewriter = def_rewriter.unwrap_or_default();\n-            update_variant(&mut rewriter, &variant);\n-            extract_struct_def(\n-                &mut rewriter,\n-                &enum_ast,\n-                variant_name.clone(),\n-                &field_list,\n-                &variant.parent_enum().syntax().clone().into(),\n-                enum_ast.visibility(),\n-            );\n             builder.edit_file(ctx.frange.file_id);\n-            builder.rewrite(rewriter);\n+            let source_file = builder.make_ast_mut(ctx.sema.parse(ctx.frange.file_id));\n+            let variant = builder.make_ast_mut(variant.clone());\n+            if let Some(references) = def_file_references {\n+                let processed = process_references(\n+                    ctx,\n+                    &mut visited_modules_set,\n+                    source_file.syntax(),\n+                    &enum_module_def,\n+                    &variant_hir_name,\n+                    references,\n+                );\n+                processed.into_iter().for_each(|(path, node, import)| {\n+                    apply_references(ctx.config.insert_use, path, node, import)\n+                });\n+            }\n+\n+            let def = create_struct_def(variant_name.clone(), &field_list, enum_ast.visibility());\n+            let start_offset = &variant.parent_enum().syntax().clone();\n+            ted::insert_raw(ted::Position::before(start_offset), def.syntax());\n+            ted::insert_raw(ted::Position::before(start_offset), &make::tokens::blank_line());\n+\n+            update_variant(&variant);\n         },\n     )\n }\n@@ -136,34 +146,11 @@ fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Va\n         .any(|(name, _)| name.to_string() == variant_name.to_string())\n }\n \n-fn insert_import(\n-    ctx: &AssistContext,\n-    rewriter: &mut SyntaxRewriter,\n-    scope_node: &SyntaxNode,\n-    module: &Module,\n-    enum_module_def: &ModuleDef,\n-    variant_hir_name: &Name,\n-) -> Option<()> {\n-    let db = ctx.db();\n-    let mod_path =\n-        module.find_use_path_prefixed(db, *enum_module_def, ctx.config.insert_use.prefix_kind);\n-    if let Some(mut mod_path) = mod_path {\n-        mod_path.pop_segment();\n-        mod_path.push_segment(variant_hir_name.clone());\n-        let scope = ImportScope::find_insert_use_container(scope_node, &ctx.sema)?;\n-        *rewriter += insert_use(&scope, mod_path_to_ast(&mod_path), ctx.config.insert_use);\n-    }\n-    Some(())\n-}\n-\n-fn extract_struct_def(\n-    rewriter: &mut SyntaxRewriter,\n-    enum_: &ast::Enum,\n+fn create_struct_def(\n     variant_name: ast::Name,\n     field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n-    start_offset: &SyntaxElement,\n     visibility: Option<ast::Visibility>,\n-) -> Option<()> {\n+) -> ast::Struct {\n     let pub_vis = Some(make::visibility_pub());\n     let field_list = match field_list {\n         Either::Left(field_list) => {\n@@ -180,65 +167,90 @@ fn extract_struct_def(\n         .into(),\n     };\n \n-    rewriter.insert_before(\n-        start_offset,\n-        make::struct_(visibility, variant_name, None, field_list).syntax(),\n-    );\n-    rewriter.insert_before(start_offset, &make::tokens::blank_line());\n-\n-    if let indent_level @ 1..=usize::MAX = IndentLevel::from_node(enum_.syntax()).0 as usize {\n-        rewriter\n-            .insert_before(start_offset, &make::tokens::whitespace(&\" \".repeat(4 * indent_level)));\n-    }\n-    Some(())\n+    make::struct_(visibility, variant_name, None, field_list).clone_for_update()\n }\n \n-fn update_variant(rewriter: &mut SyntaxRewriter, variant: &ast::Variant) -> Option<()> {\n+fn update_variant(variant: &ast::Variant) -> Option<()> {\n     let name = variant.name()?;\n     let tuple_field = make::tuple_field(None, make::ty(&name.text()));\n     let replacement = make::variant(\n         name,\n         Some(ast::FieldList::TupleFieldList(make::tuple_field_list(iter::once(tuple_field)))),\n-    );\n-    rewriter.replace(variant.syntax(), replacement.syntax());\n+    )\n+    .clone_for_update();\n+    ted::replace(variant.syntax(), replacement.syntax());\n     Some(())\n }\n \n-fn update_reference(\n+fn apply_references(\n+    insert_use_cfg: InsertUseConfig,\n+    segment: ast::PathSegment,\n+    node: SyntaxNode,\n+    import: Option<(ImportScope, hir::ModPath)>,\n+) {\n+    if let Some((scope, path)) = import {\n+        insert_use(&scope, mod_path_to_ast(&path), insert_use_cfg);\n+    }\n+    ted::insert_raw(\n+        ted::Position::before(segment.syntax()),\n+        make::path_from_text(&format!(\"{}\", segment)).clone_for_update().syntax(),\n+    );\n+    ted::insert_raw(ted::Position::before(segment.syntax()), make::token(T!['(']));\n+    ted::insert_raw(ted::Position::after(&node), make::token(T![')']));\n+}\n+\n+fn process_references(\n     ctx: &AssistContext,\n-    rewriter: &mut SyntaxRewriter,\n-    reference: FileReference,\n-    source_file: &SourceFile,\n+    visited_modules: &mut FxHashSet<Module>,\n+    source_file: &SyntaxNode,\n     enum_module_def: &ModuleDef,\n     variant_hir_name: &Name,\n-    visited_modules_set: &mut FxHashSet<Module>,\n-) -> Option<()> {\n+    refs: Vec<FileReference>,\n+) -> Vec<(ast::PathSegment, SyntaxNode, Option<(ImportScope, hir::ModPath)>)> {\n+    // we have to recollect here eagerly as we are about to edit the tree we need to calculate the changes\n+    // and corresponding nodes up front\n+    refs.into_iter()\n+        .flat_map(|reference| {\n+            let (segment, scope_node, module) =\n+                reference_to_node(&ctx.sema, source_file, reference)?;\n+            if !visited_modules.contains(&module) {\n+                let mod_path = module.find_use_path_prefixed(\n+                    ctx.sema.db,\n+                    *enum_module_def,\n+                    ctx.config.insert_use.prefix_kind,\n+                );\n+                if let Some(mut mod_path) = mod_path {\n+                    mod_path.pop_segment();\n+                    mod_path.push_segment(variant_hir_name.clone());\n+                    let scope = ImportScope::find_insert_use_container(&scope_node)?;\n+                    visited_modules.insert(module);\n+                    return Some((segment, scope_node, Some((scope, mod_path))));\n+                }\n+            }\n+            Some((segment, scope_node, None))\n+        })\n+        .collect()\n+}\n+\n+fn reference_to_node(\n+    sema: &hir::Semantics<RootDatabase>,\n+    source_file: &SyntaxNode,\n+    reference: FileReference,\n+) -> Option<(ast::PathSegment, SyntaxNode, hir::Module)> {\n     let offset = reference.range.start();\n-    let (segment, expr) = if let Some(path_expr) =\n-        find_node_at_offset::<ast::PathExpr>(source_file.syntax(), offset)\n-    {\n+    if let Some(path_expr) = find_node_at_offset::<ast::PathExpr>(source_file, offset) {\n         // tuple variant\n-        (path_expr.path()?.segment()?, path_expr.syntax().parent()?)\n-    } else if let Some(record_expr) =\n-        find_node_at_offset::<ast::RecordExpr>(source_file.syntax(), offset)\n-    {\n+        Some((path_expr.path()?.segment()?, path_expr.syntax().parent()?))\n+    } else if let Some(record_expr) = find_node_at_offset::<ast::RecordExpr>(source_file, offset) {\n         // record variant\n-        (record_expr.path()?.segment()?, record_expr.syntax().clone())\n+        Some((record_expr.path()?.segment()?, record_expr.syntax().clone()))\n     } else {\n-        return None;\n-    };\n-\n-    let module = ctx.sema.scope(&expr).module()?;\n-    if !visited_modules_set.contains(&module) {\n-        if insert_import(ctx, rewriter, &expr, &module, enum_module_def, variant_hir_name).is_some()\n-        {\n-            visited_modules_set.insert(module);\n-        }\n+        None\n     }\n-    rewriter.insert_after(segment.syntax(), &make::token(T!['(']));\n-    rewriter.insert_after(segment.syntax(), segment.syntax());\n-    rewriter.insert_after(&expr, &make::token(T![')']));\n-    Some(())\n+    .and_then(|(segment, expr)| {\n+        let module = sema.scope(&expr).module()?;\n+        Some((segment, expr, module))\n+    })\n }\n \n #[cfg(test)]\n@@ -345,7 +357,7 @@ mod my_mod {\n \n         pub struct MyField(pub u8, pub u8);\n \n-        pub enum MyEnum {\n+pub enum MyEnum {\n             MyField(MyField),\n         }\n     }"}, {"sha": "e90bbdbcf2678ca87f818ab772bda0dc7dc1028c", "filename": "crates/ide_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -83,11 +83,9 @@ fn replace<T: AstNode + PartialEq>(\n     fields: impl Iterator<Item = T>,\n     sorted_fields: impl IntoIterator<Item = T>,\n ) {\n-    fields.zip(sorted_fields).filter(|(field, sorted)| field != sorted).for_each(\n-        |(field, sorted_field)| {\n-            ted::replace(field.syntax(), sorted_field.syntax().clone_for_update());\n-        },\n-    );\n+    fields.zip(sorted_fields).for_each(|(field, sorted_field)| {\n+        ted::replace(field.syntax(), sorted_field.syntax().clone_for_update())\n+    });\n }\n \n fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap<String, usize>> {"}, {"sha": "72d8892481c87b77306b0a4398b97b9499ada0cd", "filename": "crates/ide_assists/src/handlers/reorder_impl.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -4,9 +4,8 @@ use rustc_hash::FxHashMap;\n use hir::{PathResolution, Semantics};\n use ide_db::RootDatabase;\n use syntax::{\n-    algo,\n     ast::{self, NameOwner},\n-    AstNode,\n+    ted, AstNode,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -75,13 +74,16 @@ pub(crate) fn reorder_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     }\n \n     let target = items.syntax().text_range();\n-    acc.add(AssistId(\"reorder_impl\", AssistKind::RefactorRewrite), \"Sort methods\", target, |edit| {\n-        let mut rewriter = algo::SyntaxRewriter::default();\n-        for (old, new) in methods.iter().zip(&sorted) {\n-            rewriter.replace(old.syntax(), new.syntax());\n-        }\n-        edit.rewrite(rewriter);\n-    })\n+    acc.add(\n+        AssistId(\"reorder_impl\", AssistKind::RefactorRewrite),\n+        \"Sort methods\",\n+        target,\n+        |builder| {\n+            methods.into_iter().zip(sorted).for_each(|(old, new)| {\n+                ted::replace(builder.make_ast_mut(old).syntax(), new.clone_for_update().syntax())\n+            });\n+        },\n+    )\n }\n \n fn compute_method_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap<String, usize>> {"}, {"sha": "99ba798606bbb9aff8b3c7e3e602857017747925", "filename": "crates/ide_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -1,5 +1,5 @@\n use ide_db::helpers::insert_use::{insert_use, ImportScope};\n-use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SyntaxNode};\n+use syntax::{ast, match_ast, ted, AstNode, SyntaxNode};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -31,7 +31,7 @@ pub(crate) fn replace_qualified_name_with_use(\n     }\n \n     let target = path.syntax().text_range();\n-    let scope = ImportScope::find_insert_use_container(path.syntax(), &ctx.sema)?;\n+    let scope = ImportScope::find_insert_use_container_with_macros(path.syntax(), &ctx.sema)?;\n     let syntax = scope.as_syntax_node();\n     acc.add(\n         AssistId(\"replace_qualified_name_with_use\", AssistKind::RefactorRewrite),\n@@ -40,18 +40,17 @@ pub(crate) fn replace_qualified_name_with_use(\n         |builder| {\n             // Now that we've brought the name into scope, re-qualify all paths that could be\n             // affected (that is, all paths inside the node we added the `use` to).\n-            let mut rewriter = SyntaxRewriter::default();\n-            shorten_paths(&mut rewriter, syntax.clone(), &path);\n+            let syntax = builder.make_mut(syntax.clone());\n             if let Some(ref import_scope) = ImportScope::from(syntax.clone()) {\n-                rewriter += insert_use(import_scope, path, ctx.config.insert_use);\n-                builder.rewrite(rewriter);\n+                shorten_paths(&syntax, &path.clone_for_update());\n+                insert_use(import_scope, path, ctx.config.insert_use);\n             }\n         },\n     )\n }\n \n /// Adds replacements to `re` that shorten `path` in all descendants of `node`.\n-fn shorten_paths(rewriter: &mut SyntaxRewriter<'static>, node: SyntaxNode, path: &ast::Path) {\n+fn shorten_paths(node: &SyntaxNode, path: &ast::Path) {\n     for child in node.children() {\n         match_ast! {\n             match child {\n@@ -60,34 +59,26 @@ fn shorten_paths(rewriter: &mut SyntaxRewriter<'static>, node: SyntaxNode, path:\n                 ast::Use(_it) => continue,\n                 // Don't descend into submodules, they don't have the same `use` items in scope.\n                 ast::Module(_it) => continue,\n-\n-                ast::Path(p) => {\n-                    match maybe_replace_path(rewriter, p.clone(), path.clone()) {\n-                        Some(()) => {},\n-                        None => shorten_paths(rewriter, p.syntax().clone(), path),\n-                    }\n+                ast::Path(p) => if maybe_replace_path(p.clone(), path.clone()).is_none() {\n+                    shorten_paths(p.syntax(), path);\n                 },\n-                _ => shorten_paths(rewriter, child, path),\n+                _ => shorten_paths(&child, path),\n             }\n         }\n     }\n }\n \n-fn maybe_replace_path(\n-    rewriter: &mut SyntaxRewriter<'static>,\n-    path: ast::Path,\n-    target: ast::Path,\n-) -> Option<()> {\n+fn maybe_replace_path(path: ast::Path, target: ast::Path) -> Option<()> {\n     if !path_eq(path.clone(), target) {\n         return None;\n     }\n \n     // Shorten `path`, leaving only its last segment.\n     if let Some(parent) = path.qualifier() {\n-        rewriter.delete(parent.syntax());\n+        ted::remove(parent.syntax());\n     }\n     if let Some(double_colon) = path.coloncolon_token() {\n-        rewriter.delete(&double_colon);\n+        ted::remove(&double_colon);\n     }\n \n     Some(())\n@@ -150,6 +141,7 @@ Debug\n     \",\n         );\n     }\n+\n     #[test]\n     fn test_replace_add_use_no_anchor_with_item_below() {\n         check_assist("}, {"sha": "5a90ad715b16d29f85bce9b5c16bf82e8a5c9c80", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -140,7 +140,8 @@ pub fn add_trait_assoc_items_to_impl(\n \n     let items = items\n         .into_iter()\n-        .map(|it| ast_transform::apply(&*ast_transform, it))\n+        .map(|it| it.clone_for_update())\n+        .inspect(|it| ast_transform::apply(&*ast_transform, it))\n         .map(|it| match it {\n             ast::AssocItem::Fn(def) => ast::AssocItem::Fn(add_body(def)),\n             ast::AssocItem::TypeAlias(def) => ast::AssocItem::TypeAlias(def.remove_bounds()),"}, {"sha": "9d5b61562a083618523b8147eb88bec8a758963a", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -132,7 +132,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n \n     let user_input_lowercased = potential_import_name.to_lowercase();\n     let import_assets = import_assets(ctx, potential_import_name)?;\n-    let import_scope = ImportScope::find_insert_use_container(\n+    let import_scope = ImportScope::find_insert_use_container_with_macros(\n         position_for_import(ctx, Some(import_assets.import_candidate()))?,\n         &ctx.sema,\n     )?;"}, {"sha": "99edb94992020e2914582d3ac4d52a66c0be5dd4", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -377,11 +377,11 @@ impl ImportEdit {\n     pub fn to_text_edit(&self, cfg: InsertUseConfig) -> Option<TextEdit> {\n         let _p = profile::span(\"ImportEdit::to_text_edit\");\n \n-        let rewriter =\n-            insert_use::insert_use(&self.scope, mod_path_to_ast(&self.import.import_path), cfg);\n-        let old_ast = rewriter.rewrite_root()?;\n+        let new_ast = self.scope.clone_for_update();\n+        insert_use::insert_use(&new_ast, mod_path_to_ast(&self.import.import_path), cfg);\n         let mut import_insert = TextEdit::builder();\n-        algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut import_insert);\n+        algo::diff(self.scope.as_syntax_node(), new_ast.as_syntax_node())\n+            .into_text_edit(&mut import_insert);\n \n         Some(import_insert.finish())\n     }"}, {"sha": "e32633565400659246b697853ffd3f157ae0653d", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -179,7 +179,7 @@ pub fn resolve_completion_edits(\n ) -> Option<Vec<TextEdit>> {\n     let ctx = CompletionContext::new(db, position, config)?;\n     let position_for_import = position_for_import(&ctx, None)?;\n-    let scope = ImportScope::find_insert_use_container(position_for_import, &ctx.sema)?;\n+    let scope = ImportScope::find_insert_use_container_with_macros(position_for_import, &ctx.sema)?;\n \n     let current_module = ctx.sema.scope(position_for_import).module()?;\n     let current_crate = current_module.krate();"}, {"sha": "a43504a275817cf7323c751b3fad86abbe151a06", "filename": "crates/ide_db/src/helpers/insert_use.rs", "status": "modified", "additions": 113, "deletions": 166, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -4,13 +4,9 @@ use std::{cmp::Ordering, iter::successors};\n use hir::Semantics;\n use itertools::{EitherOrBoth, Itertools};\n use syntax::{\n-    algo::SyntaxRewriter,\n-    ast::{\n-        self,\n-        edit::{AstNodeEdit, IndentLevel},\n-        make, AstNode, AttrsOwner, PathSegmentKind, VisibilityOwner,\n-    },\n-    AstToken, InsertPosition, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxToken,\n+    algo,\n+    ast::{self, edit::AstNodeEdit, make, AstNode, AttrsOwner, PathSegmentKind, VisibilityOwner},\n+    ted, AstToken, Direction, NodeOrToken, SyntaxNode, SyntaxToken,\n };\n \n use crate::RootDatabase;\n@@ -42,141 +38,51 @@ impl ImportScope {\n     }\n \n     /// Determines the containing syntax node in which to insert a `use` statement affecting `position`.\n-    pub fn find_insert_use_container(\n+    pub fn find_insert_use_container_with_macros(\n         position: &SyntaxNode,\n         sema: &Semantics<'_, RootDatabase>,\n     ) -> Option<Self> {\n         sema.ancestors_with_macros(position.clone()).find_map(Self::from)\n     }\n \n+    /// Determines the containing syntax node in which to insert a `use` statement affecting `position`.\n+    pub fn find_insert_use_container(position: &SyntaxNode) -> Option<Self> {\n+        std::iter::successors(Some(position.clone()), SyntaxNode::parent).find_map(Self::from)\n+    }\n+\n     pub fn as_syntax_node(&self) -> &SyntaxNode {\n         match self {\n             ImportScope::File(file) => file.syntax(),\n             ImportScope::Module(item_list) => item_list.syntax(),\n         }\n     }\n \n-    fn indent_level(&self) -> IndentLevel {\n-        match self {\n-            ImportScope::File(file) => file.indent_level(),\n-            ImportScope::Module(item_list) => item_list.indent_level() + 1,\n-        }\n-    }\n-\n-    fn first_insert_pos(&self) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n+    pub fn clone_for_update(&self) -> Self {\n         match self {\n-            ImportScope::File(_) => (InsertPosition::First, AddBlankLine::AfterTwice),\n-            // don't insert the imports before the item list's opening curly brace\n-            ImportScope::Module(item_list) => item_list\n-                .l_curly_token()\n-                .map(|b| (InsertPosition::After(b.into()), AddBlankLine::Around))\n-                .unwrap_or((InsertPosition::First, AddBlankLine::AfterTwice)),\n+            ImportScope::File(file) => ImportScope::File(file.clone_for_update()),\n+            ImportScope::Module(item_list) => ImportScope::Module(item_list.clone_for_update()),\n         }\n     }\n-\n-    fn insert_pos_after_last_inner_element(&self) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n-        self.as_syntax_node()\n-            .children_with_tokens()\n-            .filter(|child| match child {\n-                NodeOrToken::Node(node) => is_inner_attribute(node.clone()),\n-                NodeOrToken::Token(token) => is_inner_comment(token.clone()),\n-            })\n-            .last()\n-            .map(|last_inner_element| {\n-                (InsertPosition::After(last_inner_element), AddBlankLine::BeforeTwice)\n-            })\n-            .unwrap_or_else(|| self.first_insert_pos())\n-    }\n-}\n-\n-fn is_inner_attribute(node: SyntaxNode) -> bool {\n-    ast::Attr::cast(node).map(|attr| attr.kind()) == Some(ast::AttrKind::Inner)\n-}\n-\n-fn is_inner_comment(token: SyntaxToken) -> bool {\n-    ast::Comment::cast(token).and_then(|comment| comment.kind().doc)\n-        == Some(ast::CommentPlacement::Inner)\n }\n \n /// Insert an import path into the given file/node. A `merge` value of none indicates that no import merging is allowed to occur.\n-pub fn insert_use<'a>(\n-    scope: &ImportScope,\n-    path: ast::Path,\n-    cfg: InsertUseConfig,\n-) -> SyntaxRewriter<'a> {\n+pub fn insert_use<'a>(scope: &ImportScope, path: ast::Path, cfg: InsertUseConfig) {\n     let _p = profile::span(\"insert_use\");\n-    let mut rewriter = SyntaxRewriter::default();\n-    let use_item = make::use_(None, make::use_tree(path.clone(), None, None, false));\n+    let use_item =\n+        make::use_(None, make::use_tree(path.clone(), None, None, false)).clone_for_update();\n     // merge into existing imports if possible\n     if let Some(mb) = cfg.merge {\n         for existing_use in scope.as_syntax_node().children().filter_map(ast::Use::cast) {\n             if let Some(merged) = try_merge_imports(&existing_use, &use_item, mb) {\n-                rewriter.replace(existing_use.syntax(), merged.syntax());\n-                return rewriter;\n+                ted::replace(existing_use.syntax(), merged.syntax());\n+                return;\n             }\n         }\n     }\n \n     // either we weren't allowed to merge or there is no import that fits the merge conditions\n     // so look for the place we have to insert to\n-    let (insert_position, add_blank) = find_insert_position(scope, path, cfg.group);\n-\n-    let indent = if let ident_level @ 1..=usize::MAX = scope.indent_level().0 as usize {\n-        Some(make::tokens::whitespace(&\" \".repeat(4 * ident_level)).into())\n-    } else {\n-        None\n-    };\n-\n-    let to_insert: Vec<SyntaxElement> = {\n-        let mut buf = Vec::new();\n-\n-        match add_blank {\n-            AddBlankLine::Before | AddBlankLine::Around => {\n-                buf.push(make::tokens::single_newline().into())\n-            }\n-            AddBlankLine::BeforeTwice => buf.push(make::tokens::blank_line().into()),\n-            _ => (),\n-        }\n-\n-        if add_blank.has_before() {\n-            if let Some(indent) = indent.clone() {\n-                cov_mark::hit!(insert_use_indent_before);\n-                buf.push(indent);\n-            }\n-        }\n-\n-        buf.push(use_item.syntax().clone().into());\n-\n-        match add_blank {\n-            AddBlankLine::After | AddBlankLine::Around => {\n-                buf.push(make::tokens::single_newline().into())\n-            }\n-            AddBlankLine::AfterTwice => buf.push(make::tokens::blank_line().into()),\n-            _ => (),\n-        }\n-\n-        // only add indentation *after* our stuff if there's another node directly after it\n-        if add_blank.has_after() && matches!(insert_position, InsertPosition::Before(_)) {\n-            if let Some(indent) = indent {\n-                cov_mark::hit!(insert_use_indent_after);\n-                buf.push(indent);\n-            }\n-        } else if add_blank.has_after() && matches!(insert_position, InsertPosition::After(_)) {\n-            cov_mark::hit!(insert_use_no_indent_after);\n-        }\n-\n-        buf\n-    };\n-\n-    match insert_position {\n-        InsertPosition::First => {\n-            rewriter.insert_many_as_first_children(scope.as_syntax_node(), to_insert)\n-        }\n-        InsertPosition::Last => return rewriter, // actually unreachable\n-        InsertPosition::Before(anchor) => rewriter.insert_many_before(&anchor, to_insert),\n-        InsertPosition::After(anchor) => rewriter.insert_many_after(&anchor, to_insert),\n-    }\n-    rewriter\n+    insert_use_(scope, path, cfg.group, use_item);\n }\n \n fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n@@ -235,7 +141,7 @@ pub fn try_merge_trees(\n     } else {\n         (lhs.split_prefix(&lhs_prefix), rhs.split_prefix(&rhs_prefix))\n     };\n-    recursive_merge(&lhs, &rhs, merge).map(|it| it.clone_for_update())\n+    recursive_merge(&lhs, &rhs, merge)\n }\n \n /// Recursively \"zips\" together lhs and rhs.\n@@ -334,7 +240,12 @@ fn recursive_merge(\n             }\n         }\n     }\n-    Some(lhs.with_use_tree_list(make::use_tree_list(use_trees)))\n+\n+    Some(if let Some(old) = lhs.use_tree_list() {\n+        lhs.replace_descendant(old, make::use_tree_list(use_trees)).clone_for_update()\n+    } else {\n+        lhs.clone()\n+    })\n }\n \n /// Traverses both paths until they differ, returning the common prefix of both.\n@@ -520,32 +431,15 @@ impl ImportGroup {\n     }\n }\n \n-#[derive(PartialEq, Eq)]\n-enum AddBlankLine {\n-    Before,\n-    BeforeTwice,\n-    Around,\n-    After,\n-    AfterTwice,\n-}\n-\n-impl AddBlankLine {\n-    fn has_before(&self) -> bool {\n-        matches!(self, AddBlankLine::Before | AddBlankLine::BeforeTwice | AddBlankLine::Around)\n-    }\n-    fn has_after(&self) -> bool {\n-        matches!(self, AddBlankLine::After | AddBlankLine::AfterTwice | AddBlankLine::Around)\n-    }\n-}\n-\n-fn find_insert_position(\n+fn insert_use_(\n     scope: &ImportScope,\n     insert_path: ast::Path,\n     group_imports: bool,\n-) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n+    use_item: ast::Use,\n+) {\n+    let scope_syntax = scope.as_syntax_node();\n     let group = ImportGroup::new(&insert_path);\n-    let path_node_iter = scope\n-        .as_syntax_node()\n+    let path_node_iter = scope_syntax\n         .children()\n         .filter_map(|node| ast::Use::cast(node.clone()).zip(Some(node)))\n         .flat_map(|(use_, node)| {\n@@ -557,9 +451,14 @@ fn find_insert_position(\n \n     if !group_imports {\n         if let Some((_, _, node)) = path_node_iter.last() {\n-            return (InsertPosition::After(node.into()), AddBlankLine::Before);\n+            cov_mark::hit!(insert_no_grouping_last);\n+            ted::insert(ted::Position::after(node), use_item.syntax());\n+        } else {\n+            cov_mark::hit!(insert_no_grouping_last2);\n+            ted::insert(ted::Position::first_child_of(scope_syntax), make::tokens::blank_line());\n+            ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax());\n         }\n-        return (InsertPosition::First, AddBlankLine::AfterTwice);\n+        return;\n     }\n \n     // Iterator that discards anything thats not in the required grouping\n@@ -572,43 +471,91 @@ fn find_insert_position(\n     // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n     let mut last = None;\n     // find the element that would come directly after our new import\n-    let post_insert = group_iter.inspect(|(.., node)| last = Some(node.clone())).find(\n-        |&(ref path, has_tl, _)| {\n+    let post_insert: Option<(_, _, SyntaxNode)> = group_iter\n+        .inspect(|(.., node)| last = Some(node.clone()))\n+        .find(|&(ref path, has_tl, _)| {\n             use_tree_path_cmp(&insert_path, false, path, has_tl) != Ordering::Greater\n-        },\n-    );\n+        });\n \n-    match post_insert {\n+    if let Some((.., node)) = post_insert {\n+        cov_mark::hit!(insert_group);\n         // insert our import before that element\n-        Some((.., node)) => (InsertPosition::Before(node.into()), AddBlankLine::After),\n+        return ted::insert(ted::Position::before(node), use_item.syntax());\n+    }\n+    if let Some(node) = last {\n+        cov_mark::hit!(insert_group_last);\n         // there is no element after our new import, so append it to the end of the group\n-        None => match last {\n-            Some(node) => (InsertPosition::After(node.into()), AddBlankLine::Before),\n-            // the group we were looking for actually doesnt exist, so insert\n+        return ted::insert(ted::Position::after(node), use_item.syntax());\n+    }\n+\n+    // the group we were looking for actually doesn't exist, so insert\n+\n+    let mut last = None;\n+    // find the group that comes after where we want to insert\n+    let post_group = path_node_iter\n+        .inspect(|(.., node)| last = Some(node.clone()))\n+        .find(|(p, ..)| ImportGroup::new(p) > group);\n+    if let Some((.., node)) = post_group {\n+        cov_mark::hit!(insert_group_new_group);\n+        ted::insert(ted::Position::before(&node), use_item.syntax());\n+        if let Some(node) = algo::non_trivia_sibling(node.into(), Direction::Prev) {\n+            ted::insert(ted::Position::after(node), make::tokens::single_newline());\n+        }\n+        return;\n+    }\n+    // there is no such group, so append after the last one\n+    if let Some(node) = last {\n+        cov_mark::hit!(insert_group_no_group);\n+        ted::insert(ted::Position::after(&node), use_item.syntax());\n+        ted::insert(ted::Position::after(node), make::tokens::single_newline());\n+        return;\n+    }\n+    // there are no imports in this file at all\n+    if let Some(last_inner_element) = scope_syntax\n+        .children_with_tokens()\n+        .filter(|child| match child {\n+            NodeOrToken::Node(node) => is_inner_attribute(node.clone()),\n+            NodeOrToken::Token(token) => is_inner_comment(token.clone()),\n+        })\n+        .last()\n+    {\n+        cov_mark::hit!(insert_group_empty_inner_attr);\n+        ted::insert(ted::Position::after(&last_inner_element), use_item.syntax());\n+        ted::insert(ted::Position::after(last_inner_element), make::tokens::single_newline());\n+        return;\n+    }\n+    match scope {\n+        ImportScope::File(_) => {\n+            cov_mark::hit!(insert_group_empty_file);\n+            ted::insert(ted::Position::first_child_of(scope_syntax), make::tokens::blank_line());\n+            ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax())\n+        }\n+        // don't insert the imports before the item list's opening curly brace\n+        ImportScope::Module(item_list) => match item_list.l_curly_token() {\n+            Some(b) => {\n+                cov_mark::hit!(insert_group_empty_module);\n+                ted::insert(ted::Position::after(&b), make::tokens::single_newline());\n+                ted::insert(ted::Position::after(&b), use_item.syntax());\n+            }\n             None => {\n-                // similar concept here to the `last` from above\n-                let mut last = None;\n-                // find the group that comes after where we want to insert\n-                let post_group = path_node_iter\n-                    .inspect(|(.., node)| last = Some(node.clone()))\n-                    .find(|(p, ..)| ImportGroup::new(p) > group);\n-                match post_group {\n-                    Some((.., node)) => {\n-                        (InsertPosition::Before(node.into()), AddBlankLine::AfterTwice)\n-                    }\n-                    // there is no such group, so append after the last one\n-                    None => match last {\n-                        Some(node) => {\n-                            (InsertPosition::After(node.into()), AddBlankLine::BeforeTwice)\n-                        }\n-                        // there are no imports in this file at all\n-                        None => scope.insert_pos_after_last_inner_element(),\n-                    },\n-                }\n+                // This should never happens, broken module syntax node\n+                ted::insert(\n+                    ted::Position::first_child_of(scope_syntax),\n+                    make::tokens::blank_line(),\n+                );\n+                ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax());\n             }\n         },\n     }\n }\n \n+fn is_inner_attribute(node: SyntaxNode) -> bool {\n+    ast::Attr::cast(node).map(|attr| attr.kind()) == Some(ast::AttrKind::Inner)\n+}\n+\n+fn is_inner_comment(token: SyntaxToken) -> bool {\n+    ast::Comment::cast(token).and_then(|comment| comment.kind().doc)\n+        == Some(ast::CommentPlacement::Inner)\n+}\n #[cfg(test)]\n mod tests;"}, {"sha": "048c213e229ef76d0509c3232e2e2fc2f1ae7ebe", "filename": "crates/ide_db/src/helpers/insert_use/tests.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -5,6 +5,7 @@ use test_utils::assert_eq_text;\n \n #[test]\n fn insert_not_group() {\n+    cov_mark::check!(insert_no_grouping_last);\n     check(\n         \"use external_crate2::bar::A\",\n         r\"\n@@ -26,6 +27,21 @@ use external_crate2::bar::A;\",\n     );\n }\n \n+#[test]\n+fn insert_not_group_empty() {\n+    cov_mark::check!(insert_no_grouping_last2);\n+    check(\n+        \"use external_crate2::bar::A\",\n+        r\"\",\n+        r\"use external_crate2::bar::A;\n+\n+\",\n+        None,\n+        false,\n+        false,\n+    );\n+}\n+\n #[test]\n fn insert_existing() {\n     check_full(\"std::fs\", \"use std::fs;\", \"use std::fs;\")\n@@ -51,21 +67,21 @@ use std::bar::G;\",\n \n #[test]\n fn insert_start_indent() {\n-    cov_mark::check!(insert_use_indent_after);\n     check_none(\n         \"std::bar::AA\",\n         r\"\n     use std::bar::B;\n-    use std::bar::D;\",\n+    use std::bar::C;\",\n         r\"\n     use std::bar::AA;\n     use std::bar::B;\n-    use std::bar::D;\",\n-    )\n+    use std::bar::C;\",\n+    );\n }\n \n #[test]\n fn insert_middle() {\n+    cov_mark::check!(insert_group);\n     check_none(\n         \"std::bar::EE\",\n         r\"\n@@ -102,6 +118,7 @@ fn insert_middle_indent() {\n \n #[test]\n fn insert_end() {\n+    cov_mark::check!(insert_group_last);\n     check_none(\n         \"std::bar::ZZ\",\n         r\"\n@@ -120,7 +137,6 @@ use std::bar::ZZ;\",\n \n #[test]\n fn insert_end_indent() {\n-    cov_mark::check!(insert_use_indent_before);\n     check_none(\n         \"std::bar::ZZ\",\n         r\"\n@@ -201,6 +217,7 @@ fn insert_first_matching_group() {\n \n #[test]\n fn insert_missing_group_std() {\n+    cov_mark::check!(insert_group_new_group);\n     check_none(\n         \"std::fmt\",\n         r\"\n@@ -216,6 +233,7 @@ fn insert_missing_group_std() {\n \n #[test]\n fn insert_missing_group_self() {\n+    cov_mark::check!(insert_group_no_group);\n     check_none(\n         \"self::fmt\",\n         r\"\n@@ -242,6 +260,7 @@ fn main() {}\",\n \n #[test]\n fn insert_empty_file() {\n+    cov_mark::check!(insert_group_empty_file);\n     // empty files will get two trailing newlines\n     // this is due to the test case insert_no_imports above\n     check_full(\n@@ -255,7 +274,7 @@ fn insert_empty_file() {\n \n #[test]\n fn insert_empty_module() {\n-    cov_mark::check!(insert_use_no_indent_after);\n+    cov_mark::check!(insert_group_empty_module);\n     check(\n         \"foo::bar\",\n         \"mod x {}\",\n@@ -270,6 +289,7 @@ fn insert_empty_module() {\n \n #[test]\n fn insert_after_inner_attr() {\n+    cov_mark::check!(insert_group_empty_inner_attr);\n     check_full(\n         \"foo::bar\",\n         r\"#![allow(unused_imports)]\",\n@@ -615,20 +635,16 @@ fn check(\n     if module {\n         syntax = syntax.descendants().find_map(ast::Module::cast).unwrap().syntax().clone();\n     }\n-    let file = super::ImportScope::from(syntax).unwrap();\n+    let file = super::ImportScope::from(syntax.clone_for_update()).unwrap();\n     let path = ast::SourceFile::parse(&format!(\"use {};\", path))\n         .tree()\n         .syntax()\n         .descendants()\n         .find_map(ast::Path::cast)\n         .unwrap();\n \n-    let rewriter = insert_use(\n-        &file,\n-        path,\n-        InsertUseConfig { merge: mb, prefix_kind: PrefixKind::Plain, group },\n-    );\n-    let result = rewriter.rewrite(file.as_syntax_node()).to_string();\n+    insert_use(&file, path, InsertUseConfig { merge: mb, prefix_kind: PrefixKind::Plain, group });\n+    let result = file.as_syntax_node().to_string();\n     assert_eq_text!(ra_fixture_after, &result);\n }\n "}, {"sha": "c9229c4e07dabfa7e943740bdf3e18355c1bef22", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -342,10 +342,10 @@ enum InsertPos {\n \n #[derive(Default)]\n pub struct SyntaxRewriter<'a> {\n-    f: Option<Box<dyn Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a>>,\n     //FIXME: add debug_assertions that all elements are in fact from the same file.\n     replacements: FxHashMap<SyntaxElement, Replacement>,\n     insertions: IndexMap<InsertPos, Vec<SyntaxElement>>,\n+    _pd: std::marker::PhantomData<&'a ()>,\n }\n \n impl fmt::Debug for SyntaxRewriter<'_> {\n@@ -357,14 +357,7 @@ impl fmt::Debug for SyntaxRewriter<'_> {\n     }\n }\n \n-impl<'a> SyntaxRewriter<'a> {\n-    pub fn from_fn(f: impl Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a) -> SyntaxRewriter<'a> {\n-        SyntaxRewriter {\n-            f: Some(Box::new(f)),\n-            replacements: FxHashMap::default(),\n-            insertions: IndexMap::default(),\n-        }\n-    }\n+impl SyntaxRewriter<'_> {\n     pub fn delete<T: Clone + Into<SyntaxElement>>(&mut self, what: &T) {\n         let what = what.clone().into();\n         let replacement = Replacement::Delete;\n@@ -470,7 +463,7 @@ impl<'a> SyntaxRewriter<'a> {\n     pub fn rewrite(&self, node: &SyntaxNode) -> SyntaxNode {\n         let _p = profile::span(\"rewrite\");\n \n-        if self.f.is_none() && self.replacements.is_empty() && self.insertions.is_empty() {\n+        if self.replacements.is_empty() && self.insertions.is_empty() {\n             return node.clone();\n         }\n         let green = self.rewrite_children(node);\n@@ -495,7 +488,6 @@ impl<'a> SyntaxRewriter<'a> {\n             }\n         }\n \n-        assert!(self.f.is_none());\n         self.replacements\n             .keys()\n             .filter_map(element_to_node_or_parent)\n@@ -510,10 +502,6 @@ impl<'a> SyntaxRewriter<'a> {\n     }\n \n     fn replacement(&self, element: &SyntaxElement) -> Option<Replacement> {\n-        if let Some(f) = &self.f {\n-            assert!(self.replacements.is_empty());\n-            return f(element).map(Replacement::Single);\n-        }\n         self.replacements.get(element).cloned()\n     }\n \n@@ -574,7 +562,6 @@ fn element_to_green(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, row\n \n impl ops::AddAssign for SyntaxRewriter<'_> {\n     fn add_assign(&mut self, rhs: SyntaxRewriter) {\n-        assert!(rhs.f.is_none());\n         self.replacements.extend(rhs.replacements);\n         for (pos, insertions) in rhs.insertions.into_iter() {\n             match self.insertions.entry(pos) {"}, {"sha": "42da0960615c4dadee55b34248ce56b775f9457f", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -632,6 +632,7 @@ pub mod tokens {\n         SOURCE_FILE\n             .tree()\n             .syntax()\n+            .clone_for_update()\n             .descendants_with_tokens()\n             .filter_map(|it| it.into_token())\n             .find(|it| it.kind() == WHITESPACE && it.text() == \"\\n\\n\")"}, {"sha": "91a06101f5984548d1558b94e1b17adc6185067f", "filename": "crates/syntax/src/ted.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fsyntax%2Fsrc%2Fted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbde9f531e6afb315ac71f679a0f3c469088137/crates%2Fsyntax%2Fsrc%2Fted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fted.rs?ref=5cbde9f531e6afb315ac71f679a0f3c469088137", "patch": "@@ -7,7 +7,7 @@ use std::{mem, ops::RangeInclusive};\n use parser::T;\n \n use crate::{\n-    ast::{edit::IndentLevel, make},\n+    ast::{self, edit::IndentLevel, make, AstNode},\n     SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n \n@@ -147,6 +147,16 @@ pub fn append_child_raw(node: &(impl Into<SyntaxNode> + Clone), child: impl Elem\n fn ws_before(position: &Position, new: &SyntaxElement) -> Option<SyntaxToken> {\n     let prev = match &position.repr {\n         PositionRepr::FirstChild(_) => return None,\n+        PositionRepr::After(it) if it.kind() == SyntaxKind::L_CURLY => {\n+            if new.kind() == SyntaxKind::USE {\n+                if let Some(item_list) = it.parent().and_then(ast::ItemList::cast) {\n+                    let mut indent = IndentLevel::from_element(&item_list.syntax().clone().into());\n+                    indent.0 += 1;\n+                    return Some(make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n+                }\n+            }\n+            it\n+        }\n         PositionRepr::After(it) => it,\n     };\n     ws_between(prev, new)\n@@ -173,7 +183,10 @@ fn ws_between(left: &SyntaxElement, right: &SyntaxElement) -> Option<SyntaxToken\n     }\n \n     if right.kind() == SyntaxKind::USE {\n-        let indent = IndentLevel::from_element(left);\n+        let mut indent = IndentLevel::from_element(left);\n+        if left.kind() == SyntaxKind::USE {\n+            indent.0 = IndentLevel::from_element(right).0.max(indent.0);\n+        }\n         return Some(make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n     }\n     Some(make::tokens::single_space())"}]}