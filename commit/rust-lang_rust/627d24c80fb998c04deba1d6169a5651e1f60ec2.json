{"sha": "627d24c80fb998c04deba1d6169a5651e1f60ec2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyN2QyNGM4MGZiOTk4YzA0ZGViYTFkNjE2OWE1NjUxZTFmNjBlYzI=", "commit": {"author": {"name": "sinkuu", "email": "sinkuupump@gmail.com", "date": "2017-02-20T09:18:31Z"}, "committer": {"name": "sinkuu", "email": "sinkuupump@gmail.com", "date": "2017-02-20T15:27:12Z"}, "message": "Fix suggestion for `let <pat>`", "tree": {"sha": "1f98a4ba6188f16120745715797b73ab6dea49f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f98a4ba6188f16120745715797b73ab6dea49f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/627d24c80fb998c04deba1d6169a5651e1f60ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/627d24c80fb998c04deba1d6169a5651e1f60ec2", "html_url": "https://github.com/rust-lang/rust/commit/627d24c80fb998c04deba1d6169a5651e1f60ec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/627d24c80fb998c04deba1d6169a5651e1f60ec2/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "263e60ce0b0e1c8199f715d6208538ddfea64b46", "url": "https://api.github.com/repos/rust-lang/rust/commits/263e60ce0b0e1c8199f715d6208538ddfea64b46", "html_url": "https://github.com/rust-lang/rust/commit/263e60ce0b0e1c8199f715d6208538ddfea64b46"}], "stats": {"total": 178, "additions": 109, "deletions": 69}, "files": [{"sha": "ff19700a41f4dcfa521f0a3d02b3c749ca5743a1", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 89, "deletions": 62, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/627d24c80fb998c04deba1d6169a5651e1f60ec2/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627d24c80fb998c04deba1d6169a5651e1f60ec2/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=627d24c80fb998c04deba1d6169a5651e1f60ec2", "patch": "@@ -8,6 +8,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use syntax::ast::NodeId;\n use syntax_pos::Span;\n+use syntax::errors::DiagnosticBuilder;\n use utils::{in_macro, is_self, is_copy, implements_trait, get_trait_def_id, match_type, snippet, span_lint_and_then,\n             paths};\n use std::collections::{HashSet, HashMap};\n@@ -59,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             return;\n         }\n \n-        // These are usually passed by value and only used by reference\n+        // Allows these to be passed by value.\n         let fn_trait = cx.tcx.lang_items.fn_trait().expect(\"failed to find `Fn` trait\");\n         let asref_trait = get_trait_def_id(cx, &paths::ASREF_TRAIT).expect(\"failed to find `AsRef` trait\");\n         let borrow_trait = get_trait_def_id(cx, &paths::BORROW_TRAIT).expect(\"failed to find `Borrow` trait\");\n@@ -71,8 +72,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 .collect()\n         };\n \n-        // Collect moved variables and non-moving usages at `match`es from the function body\n-        let MovedVariablesCtxt { moved_vars, non_moving_matches, .. } = {\n+        // Collect moved variables and spans which will need dereferencings from the function body.\n+        let MovedVariablesCtxt { moved_vars, spans_need_deref, .. } = {\n             let mut ctx = MovedVariablesCtxt::new(cx);\n             let infcx = cx.tcx.borrowck_fake_infer_ctxt(body.id());\n             {\n@@ -119,11 +120,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     continue;\n                 }\n \n-                span_lint_and_then(cx,\n-                          NEEDLESS_PASS_BY_VALUE,\n-                          input.span,\n-                          \"this argument is passed by value, but not consumed in the function body\",\n-                          |db| {\n+                // Suggestion logic\n+                let sugg = |db: &mut DiagnosticBuilder| {\n                     if_let_chain! {[\n                         match_type(cx, ty, &paths::VEC),\n                         let TyPath(QPath::Resolved(_, ref path)) = input.node,\n@@ -148,24 +146,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                                            format!(\"&{}\", snippet(cx, input.span, \"_\")));\n                     }\n \n-                    // For non-moving consumption at `match`es,\n-                    // suggests adding `*` to dereference the added reference.\n-                    // e.g. `match x { Some(_) => 1, None => 2 }`\n-                    //   -> `match *x { .. }`\n-                    if let Some(matches) = non_moving_matches.get(&defid) {\n-                        for (i, m) in matches.iter().enumerate() {\n-                            if let ExprMatch(ref e, ..) = cx.tcx.hir.expect_expr(*m).node {\n-                                db.span_suggestion(e.span,\n-                                                   if i == 0 {\n-                                                       \"...and dereference it here\"\n-                                                   } else {\n-                                                       \"...and here\"\n-                                                   },\n-                                                   format!(\"*{}\", snippet(cx, e.span, \"<expr>\")));\n-                            }\n+                    // Suggests adding `*` to dereference the added reference.\n+                    if let Some(spans) = spans_need_deref.get(&defid) {\n+                        let mut spans: Vec<_> = spans.iter().cloned().collect();\n+                        spans.sort();\n+                        for (i, span) in spans.into_iter().enumerate() {\n+                            db.span_suggestion(span,\n+                                                if i == 0 {\n+                                                    \"...and dereference it here\"\n+                                                } else {\n+                                                    \"...and here\"\n+                                                },\n+                                                format!(\"*{}\", snippet(cx, span, \"<expr>\")));\n                         }\n                     }\n-                });\n+                };\n+\n+                span_lint_and_then(cx,\n+                          NEEDLESS_PASS_BY_VALUE,\n+                          input.span,\n+                          \"this argument is passed by value, but not consumed in the function body\",\n+                          sugg);\n             }}\n         }\n     }\n@@ -174,15 +175,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     moved_vars: HashSet<DefId>,\n-    non_moving_matches: HashMap<DefId, HashSet<NodeId>>,\n+    /// Spans which need to be prefixed with `*` for dereferencing the suggested additional\n+    /// reference.\n+    spans_need_deref: HashMap<DefId, HashSet<Span>>,\n }\n \n impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n         MovedVariablesCtxt {\n             cx: cx,\n             moved_vars: HashSet::new(),\n-            non_moving_matches: HashMap::new(),\n+            spans_need_deref: HashMap::new(),\n         }\n     }\n \n@@ -196,6 +199,57 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n                 self.moved_vars.insert(def_id);\n         }}\n     }\n+\n+    fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt<'tcx>) {\n+        let cmt = unwrap_downcast_or_interior(cmt);\n+\n+        if_let_chain! {[\n+            let mc::Categorization::Local(vid) = cmt.cat,\n+            let Some(def_id) = self.cx.tcx.hir.opt_local_def_id(vid),\n+        ], {\n+            let mut id = matched_pat.id;\n+            loop {\n+                let parent = self.cx.tcx.hir.get_parent_node(id);\n+                if id == parent {\n+                    // no parent\n+                    return;\n+                }\n+                id = parent;\n+\n+                if let Some(node) = self.cx.tcx.hir.find(id) {\n+                    match node {\n+                        map::Node::NodeExpr(e) => {\n+                            // `match` and `if let`\n+                            if let ExprMatch(ref c, ..) = e.node {\n+                                self.spans_need_deref\n+                                    .entry(def_id)\n+                                    .or_insert_with(HashSet::new)\n+                                    .insert(c.span);\n+                            }\n+                        }\n+\n+                        map::Node::NodeStmt(s) => {\n+                            // `let <pat> = x;`\n+                            if_let_chain! {[\n+                                let StmtDecl(ref decl, _) = s.node,\n+                                let DeclLocal(ref local) = decl.node,\n+                            ], {\n+                                self.spans_need_deref\n+                                    .entry(def_id)\n+                                    .or_insert_with(HashSet::new)\n+                                    .insert(local.init\n+                                        .as_ref()\n+                                        .map(|e| e.span)\n+                                        .expect(\"`let` stmt without init aren't caught by match_pat\"));\n+                            }}\n+                        }\n+\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }}\n+    }\n }\n \n impl<'a, 'tcx: 'a> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n@@ -209,27 +263,7 @@ impl<'a, 'tcx: 'a> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n         if let euv::MatchMode::MovingMatch = mode {\n             self.move_common(matched_pat.id, matched_pat.span, cmt);\n         } else {\n-            let cmt = unwrap_downcast_or_interior(cmt);\n-\n-            if_let_chain! {[\n-                let mc::Categorization::Local(vid) = cmt.cat,\n-                let Some(def_id) = self.cx.tcx.hir.opt_local_def_id(vid),\n-            ], {\n-                // Find the `ExprMatch` which contains this pattern\n-                let mut match_id = matched_pat.id;\n-                loop {\n-                    match_id = self.cx.tcx.hir.get_parent_node(match_id);\n-                    if_let_chain! {[\n-                        let Some(map::Node::NodeExpr(e)) = self.cx.tcx.hir.find(match_id),\n-                        let ExprMatch(..) = e.node,\n-                    ], {\n-                        break;\n-                    }}\n-                }\n-\n-                self.non_moving_matches.entry(def_id).or_insert_with(HashSet::new)\n-                    .insert(match_id);\n-            }}\n+            self.non_moving_pat(matched_pat, cmt);\n         }\n     }\n \n@@ -241,25 +275,18 @@ impl<'a, 'tcx: 'a> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n \n     fn borrow(\n         &mut self,\n-        _borrow_id: NodeId,\n-        _borrow_span: Span,\n-        _cmt: mc::cmt<'tcx>,\n-        _loan_region: &'tcx ty::Region,\n-        _bk: ty::BorrowKind,\n-        _loan_cause: euv::LoanCause\n+        _: NodeId,\n+        _: Span,\n+        _: mc::cmt<'tcx>,\n+        _: &'tcx ty::Region,\n+        _: ty::BorrowKind,\n+        _: euv::LoanCause\n     ) {\n     }\n \n-    fn mutate(\n-        &mut self,\n-        _assignment_id: NodeId,\n-        _assignment_span: Span,\n-        _assignee_cmt: mc::cmt<'tcx>,\n-        _mode: euv::MutateMode\n-    ) {\n-    }\n+    fn mutate(&mut self, _: NodeId, _: Span, _: mc::cmt<'tcx>, _: euv::MutateMode) {}\n \n-    fn decl_without_init(&mut self, _id: NodeId, _span: Span) {}\n+    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n }\n \n "}, {"sha": "fbfd3c517f9fe7ecc93c5b5dd743a4885bc89d45", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/627d24c80fb998c04deba1d6169a5651e1f60ec2/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627d24c80fb998c04deba1d6169a5651e1f60ec2/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=627d24c80fb998c04deba1d6169a5651e1f60ec2", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #![deny(needless_pass_by_value)]\n-#![allow(dead_code, single_match)]\n+#![allow(dead_code, single_match, if_let_redundant_pattern_matching, many_single_char_names)]\n \n // `v` should be warned\n // `w`, `x` and `y` are allowed (moved or mutated)\n@@ -49,10 +49,12 @@ fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n     };\n }\n \n-// x should be warned, but y is ok\n-fn test_destructure(x: Wrapper, y: Wrapper) {\n-    let Wrapper(s) = y; // moved\n+// x and y should be warned, but z is ok\n+fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n+    let Wrapper(s) = z; // moved\n+    let Wrapper(ref t) = y; // not moved\n     assert_eq!(x.0.len(), s.len());\n+    println!(\"{}\", t);\n }\n \n fn main() {}"}, {"sha": "08df6b976ae6d2c2cc941d7cd3ca095543779e4b", "filename": "tests/ui/needless_pass_by_value.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/627d24c80fb998c04deba1d6169a5651e1f60ec2/tests%2Fui%2Fneedless_pass_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/627d24c80fb998c04deba1d6169a5651e1f60ec2/tests%2Fui%2Fneedless_pass_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.stderr?ref=627d24c80fb998c04deba1d6169a5651e1f60ec2", "patch": "@@ -53,11 +53,22 @@ help: ...and dereference it here\n error: this argument is passed by value, but not consumed in the function body\n   --> $DIR/needless_pass_by_value.rs:53:24\n    |\n-53 | fn test_destructure(x: Wrapper, y: Wrapper) {\n+53 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n    |                        ^^^^^^^\n    |\n help: consider taking a reference instead\n-   | fn test_destructure(x: &Wrapper, y: Wrapper) {\n+   | fn test_destructure(x: &Wrapper, y: Wrapper, z: Wrapper) {\n \n-error: aborting due to 6 previous errors\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:53:36\n+   |\n+53 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n+   |                                    ^^^^^^^\n+   |\n+help: consider taking a reference instead\n+   | fn test_destructure(x: Wrapper, y: &Wrapper, z: Wrapper) {\n+help: ...and dereference it here\n+   |     let Wrapper(ref t) = *y; // not moved\n+\n+error: aborting due to 7 previous errors\n "}]}