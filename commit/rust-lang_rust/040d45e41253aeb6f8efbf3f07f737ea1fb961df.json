{"sha": "040d45e41253aeb6f8efbf3f07f737ea1fb961df", "node_id": "C_kwDOAAsO6NoAKDA0MGQ0NWU0MTI1M2FlYjZmOGVmYmYzZjA3ZjczN2VhMWZiOTYxZGY", "commit": {"author": {"name": "kyoto7250", "email": "50972773+kyoto7250@users.noreply.github.com", "date": "2022-06-18T09:24:39Z"}, "committer": {"name": "kyoto7250", "email": "50972773+kyoto7250@users.noreply.github.com", "date": "2022-06-18T09:24:39Z"}, "message": "check macro in eq_block", "tree": {"sha": "7b89b1266d14d0411cd40fef1f91cad5e20c075f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b89b1266d14d0411cd40fef1f91cad5e20c075f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/040d45e41253aeb6f8efbf3f07f737ea1fb961df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/040d45e41253aeb6f8efbf3f07f737ea1fb961df", "html_url": "https://github.com/rust-lang/rust/commit/040d45e41253aeb6f8efbf3f07f737ea1fb961df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/040d45e41253aeb6f8efbf3f07f737ea1fb961df/comments", "author": {"login": "kyoto7250", "id": 50972773, "node_id": "MDQ6VXNlcjUwOTcyNzcz", "avatar_url": "https://avatars.githubusercontent.com/u/50972773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kyoto7250", "html_url": "https://github.com/kyoto7250", "followers_url": "https://api.github.com/users/kyoto7250/followers", "following_url": "https://api.github.com/users/kyoto7250/following{/other_user}", "gists_url": "https://api.github.com/users/kyoto7250/gists{/gist_id}", "starred_url": "https://api.github.com/users/kyoto7250/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kyoto7250/subscriptions", "organizations_url": "https://api.github.com/users/kyoto7250/orgs", "repos_url": "https://api.github.com/users/kyoto7250/repos", "events_url": "https://api.github.com/users/kyoto7250/events{/privacy}", "received_events_url": "https://api.github.com/users/kyoto7250/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kyoto7250", "id": 50972773, "node_id": "MDQ6VXNlcjUwOTcyNzcz", "avatar_url": "https://avatars.githubusercontent.com/u/50972773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kyoto7250", "html_url": "https://github.com/kyoto7250", "followers_url": "https://api.github.com/users/kyoto7250/followers", "following_url": "https://api.github.com/users/kyoto7250/following{/other_user}", "gists_url": "https://api.github.com/users/kyoto7250/gists{/gist_id}", "starred_url": "https://api.github.com/users/kyoto7250/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kyoto7250/subscriptions", "organizations_url": "https://api.github.com/users/kyoto7250/orgs", "repos_url": "https://api.github.com/users/kyoto7250/repos", "events_url": "https://api.github.com/users/kyoto7250/events{/privacy}", "received_events_url": "https://api.github.com/users/kyoto7250/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a83809c8c63b135bf5d2d1c9e42d0a94ea5c5ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a83809c8c63b135bf5d2d1c9e42d0a94ea5c5ad", "html_url": "https://github.com/rust-lang/rust/commit/7a83809c8c63b135bf5d2d1c9e42d0a94ea5c5ad"}], "stats": {"total": 72, "additions": 38, "deletions": 34}, "files": [{"sha": "f6e4d9a4f5cf8655fa821223ef8d658d4ab6f9db", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/040d45e41253aeb6f8efbf3f07f737ea1fb961df/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040d45e41253aeb6f8efbf3f07f737ea1fb961df/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=040d45e41253aeb6f8efbf3f07f737ea1fb961df", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n-use clippy_utils::macros::macro_backtrace;\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n use clippy_utils::{\n     eq_expr_value, get_enclosing_block, hash_expr, hash_stmt, if_sequence, is_else_clause, is_lint_allowed,\n@@ -13,7 +12,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::walk_chain;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{sym, BytePos, Span, Symbol};\n+use rustc_span::{BytePos, Span, Symbol};\n use std::borrow::Cow;\n \n declare_clippy_lint! {\n@@ -197,8 +196,6 @@ fn lint_if_same_then_else(cx: &LateContext<'_>, conds: &[&Expr<'_>], blocks: &[&\n         .enumerate()\n         .fold(true, |all_eq, (i, &[lhs, rhs])| {\n             if eq.eq_block(lhs, rhs)\n-                && !contains_acceptable_macro(cx, lhs)\n-                && !contains_acceptable_macro(cx, rhs)\n                 && !contains_let(conds[i])\n                 && conds.get(i + 1).map_or(true, |e| !contains_let(e))\n             {\n@@ -371,37 +368,9 @@ fn eq_stmts(\n         .all(|b| get_stmt(b).map_or(false, |s| eq.eq_stmt(s, stmt)))\n }\n \n-fn contains_acceptable_macro(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n-    if block.stmts.first().map_or(false, |stmt|\n-        matches!(\n-            stmt.kind,\n-            StmtKind::Semi(semi_expr) if acceptable_macro(cx, semi_expr)\n-        )\n-    ) {\n-        return true;\n-    }\n-\n-    if let Some(block_expr) = block.expr\n-        && acceptable_macro(cx, block_expr)\n-    {\n-        return true\n-    }\n \n-    false\n-}\n \n-fn acceptable_macro(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if macro_backtrace(expr.span).last().map_or(false, |macro_call|\n-        matches!(\n-            &cx.tcx.get_diagnostic_name(macro_call.def_id),\n-            Some(sym::todo_macro | sym::unimplemented_macro)\n-        )\n-    ) {\n-        return true;\n-    }\n \n-    false\n-}\n \n fn scan_block_for_eq(cx: &LateContext<'_>, _conds: &[&Expr<'_>], block: &Block<'_>, blocks: &[&Block<'_>]) -> BlockEq {\n     let mut eq = SpanlessEq::new(cx);"}, {"sha": "f21098f95f7a006ad90cd0eed3a705e553700158", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/040d45e41253aeb6f8efbf3f07f737ea1fb961df/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040d45e41253aeb6f8efbf3f07f737ea1fb961df/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=040d45e41253aeb6f8efbf3f07f737ea1fb961df", "patch": "@@ -1,5 +1,6 @@\n use crate::consts::constant_simple;\n use crate::source::snippet_opt;\n+use crate::macros::macro_backtrace;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHasher;\n use rustc_hir::def::Res;\n@@ -12,7 +13,7 @@ use rustc_hir::{\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::TypeckResults;\n-use rustc_span::Symbol;\n+use rustc_span::{sym, Symbol};\n use std::hash::{Hash, Hasher};\n \n /// Type used to check whether two ast are the same. This is different from the\n@@ -65,7 +66,9 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     pub fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n-        self.inter_expr().eq_block(left, right)\n+        !self.cannot_be_compared_block(left)\n+            && !self.cannot_be_compared_block(right)\n+            && self.inter_expr().eq_block(left, right)\n     }\n \n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n@@ -83,6 +86,38 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn eq_path_segments(&mut self, left: &[PathSegment<'_>], right: &[PathSegment<'_>]) -> bool {\n         self.inter_expr().eq_path_segments(left, right)\n     }\n+\n+    fn cannot_be_compared_block(&mut self, block: &Block<'_>) -> bool {\n+        if block.stmts.first().map_or(false, |stmt|\n+            matches!(\n+                stmt.kind,\n+                StmtKind::Semi(semi_expr) if self.should_ignore(semi_expr)\n+            )\n+        ) {\n+            return true;\n+        }\n+\n+        if let Some(block_expr) = block.expr\n+            && self.should_ignore(block_expr)\n+        {\n+            return true\n+        }\n+\n+        false\n+    }\n+\n+    fn should_ignore(&mut self, expr: &Expr<'_>) -> bool {\n+        if macro_backtrace(expr.span).last().map_or(false, |macro_call|\n+            matches!(\n+                &self.cx.tcx.get_diagnostic_name(macro_call.def_id),\n+                Some(sym::todo_macro | sym::unimplemented_macro)\n+            )\n+        ) {\n+            return true;\n+        }\n+\n+        false\n+    }\n }\n \n pub struct HirEqInterExpr<'a, 'b, 'tcx> {"}]}