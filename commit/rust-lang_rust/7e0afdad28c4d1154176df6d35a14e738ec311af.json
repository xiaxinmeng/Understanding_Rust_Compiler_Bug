{"sha": "7e0afdad28c4d1154176df6d35a14e738ec311af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMGFmZGFkMjhjNGQxMTU0MTc2ZGY2ZDM1YTE0ZTczOGVjMzExYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-27T06:18:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-27T06:18:24Z"}, "message": "Auto merge of #63940 - Centril:rollup-47qe9gn, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #62600 (libtest: add --show-output flag to print stdout of successful tests)\n - #63698 (Fixed floating point issue with asinh function)\n - #63761 (Propagate spans and attributes from proc macro definitions)\n - #63917 (Error when generator trait is not found)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "db371f782f0f0a0170f0ce86d9da66b10276fd14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db371f782f0f0a0170f0ce86d9da66b10276fd14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e0afdad28c4d1154176df6d35a14e738ec311af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0afdad28c4d1154176df6d35a14e738ec311af", "html_url": "https://github.com/rust-lang/rust/commit/7e0afdad28c4d1154176df6d35a14e738ec311af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e0afdad28c4d1154176df6d35a14e738ec311af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0444b9f66acb5da23dc816e0d8eb59623ba9ea50", "url": "https://api.github.com/repos/rust-lang/rust/commits/0444b9f66acb5da23dc816e0d8eb59623ba9ea50", "html_url": "https://github.com/rust-lang/rust/commit/0444b9f66acb5da23dc816e0d8eb59623ba9ea50"}, {"sha": "23116baff042880209c06e78a1fb48fb2b06c76a", "url": "https://api.github.com/repos/rust-lang/rust/commits/23116baff042880209c06e78a1fb48fb2b06c76a", "html_url": "https://github.com/rust-lang/rust/commit/23116baff042880209c06e78a1fb48fb2b06c76a"}], "stats": {"total": 708, "additions": 468, "deletions": 240}, "files": [{"sha": "d408fef75153e2f83c597d9bfa6547b66585b1e2", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -19,12 +19,15 @@\n \n #![feature(nll)]\n #![feature(staged_api)]\n+#![feature(allow_internal_unstable)]\n #![feature(const_fn)]\n+#![feature(decl_macro)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n #![feature(mem_take)]\n #![feature(non_exhaustive)]\n+#![feature(rustc_attrs)]\n #![feature(specialization)]\n \n #![recursion_limit=\"256\"]\n@@ -222,11 +225,10 @@ pub mod token_stream {\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n-///\n-/// This is a dummy macro, the actual implementation is in `quote::quote`.`\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n-#[macro_export]\n-macro_rules! quote { () => {} }\n+#[allow_internal_unstable(proc_macro_def_site)]\n+#[cfg_attr(not(bootstrap), rustc_builtin_macro)]\n+pub macro quote ($($t:tt)*) { /* compiler built-in */ }\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]"}, {"sha": "144e2d6bac43bb3061ecbb3c785965732e56c7e5", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -57,9 +57,9 @@ macro_rules! quote {\n }\n \n /// Quote a `TokenStream` into a `TokenStream`.\n-/// This is the actual `quote!()` proc macro.\n+/// This is the actual implementation of the `quote!()` proc macro.\n ///\n-/// It is manually loaded in `CStore::load_macro_untracked`.\n+/// It is loaded by the compiler in `register_builtin_macros`.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub fn quote(stream: TokenStream) -> TokenStream {\n     if stream.is_empty() {"}, {"sha": "5bf4067431f24a6b73a8e08ee4c2df3895377021", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -95,11 +95,6 @@ pub struct CrateMetadata {\n     pub raw_proc_macros: Option<&'static [ProcMacro]>,\n }\n \n-pub struct FullProcMacro {\n-    pub name: ast::Name,\n-    pub ext: Lrc<SyntaxExtension>\n-}\n-\n pub struct CStore {\n     metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n@@ -109,7 +104,7 @@ pub struct CStore {\n \n pub enum LoadedMacro {\n     MacroDef(ast::Item),\n-    ProcMacro(Lrc<SyntaxExtension>),\n+    ProcMacro(SyntaxExtension),\n }\n \n impl CStore {"}, {"sha": "5bfb315da473fa8b03bde89fda3cfc7d92e51d6d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -30,11 +30,9 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n-use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -436,15 +434,7 @@ impl cstore::CStore {\n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n         if data.is_proc_macro_crate() {\n-            return LoadedMacro::ProcMacro(data.get_proc_macro(id.index, sess).ext);\n-        } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n-            let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n-            let ext = SyntaxExtension {\n-                allow_internal_unstable: Some([sym::proc_macro_def_site][..].into()),\n-                ..SyntaxExtension::default(kind, data.root.edition)\n-            };\n-            return LoadedMacro::ProcMacro(Lrc::new(ext));\n+            return LoadedMacro::ProcMacro(data.load_proc_macro(id.index, sess));\n         }\n \n         let def = data.get_macro(id.index);"}, {"sha": "c777b5ea409a4315f45d103d4464c71314fda646", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -1,6 +1,6 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule, FullProcMacro};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n use crate::schema::*;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -512,27 +512,8 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(index).span.decode((self, sess))\n     }\n \n-\n-    pub fn get_proc_macro(&self, id: DefIndex, sess: &Session) -> FullProcMacro {\n-        if sess.opts.debugging_opts.dual_proc_macros {\n-            let host_lib = self.host_lib.as_ref().unwrap();\n-            self.load_proc_macro(\n-                &host_lib.metadata.get_root(),\n-                id,\n-                sess\n-            )\n-        } else {\n-            self.load_proc_macro(&self.root, id, sess)\n-        }\n-    }\n-\n-    fn load_proc_macro(&self, root: &CrateRoot<'_>,\n-                        id: DefIndex,\n-                        sess: &Session)\n-                        -> FullProcMacro {\n-\n-        let raw_macro = self.raw_proc_macro(id);\n-        let (name, kind, helper_attrs) = match *raw_macro {\n+    crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n+        let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n                     attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n@@ -551,17 +532,21 @@ impl<'a, 'tcx> CrateMetadata {\n                 name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n             )\n         };\n+        let edition = if sess.opts.debugging_opts.dual_proc_macros {\n+            self.host_lib.as_ref().unwrap().metadata.get_root().edition\n+        } else {\n+            self.root.edition\n+        };\n \n-        let span = self.get_span(id, sess);\n-\n-        FullProcMacro {\n-            name: Symbol::intern(name),\n-            ext: Lrc::new(SyntaxExtension {\n-                span,\n-                helper_attrs,\n-                ..SyntaxExtension::default(kind, root.edition)\n-            })\n-        }\n+        SyntaxExtension::new(\n+            &sess.parse_sess,\n+            kind,\n+            self.get_span(id, sess),\n+            helper_attrs,\n+            edition,\n+            Symbol::intern(name),\n+            &self.get_attributes(&self.entry(id), sess),\n+        )\n     }\n \n     pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {"}, {"sha": "165a4c707bb6db54bf3e156fa719fd52ce9ae9ce", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -150,12 +150,12 @@ impl<'a> Resolver<'a> {\n             return Some(ext.clone());\n         }\n \n-        let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n-            LoadedMacro::MacroDef(macro_def) => macro_def,\n-            LoadedMacro::ProcMacro(ext) => return Some(ext),\n-        };\n+        let ext = Lrc::new(match self.cstore.load_macro_untracked(def_id, &self.session) {\n+            LoadedMacro::MacroDef(item) =>\n+                self.compile_macro(&item, self.cstore.crate_edition_untracked(def_id.krate)),\n+            LoadedMacro::ProcMacro(ext) => ext,\n+        });\n \n-        let ext = self.compile_macro(&macro_def, self.cstore.crate_edition_untracked(def_id.krate));\n         self.macro_map.insert(def_id, ext.clone());\n         Some(ext)\n     }\n@@ -1104,7 +1104,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let expansion = parent_scope.expansion;\n         let (ext, ident, span, is_legacy) = match &item.node {\n             ItemKind::MacroDef(def) => {\n-                let ext = self.r.compile_macro(item, self.r.session.edition());\n+                let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n                 (ext, item.ident, item.span, def.legacy)\n             }\n             ItemKind::Fn(..) => match Self::proc_macro_stub(item) {"}, {"sha": "cc78e928380a85a98dfc3662dd8c07bd43c4fc64", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -800,7 +800,7 @@ impl<'a> Resolver<'a> {\n \n     /// Compile the macro into a `SyntaxExtension` and possibly replace it with a pre-defined\n     /// extension partially or entirely for built-in macros and legacy plugin macros.\n-    crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> Lrc<SyntaxExtension> {\n+    crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> SyntaxExtension {\n         let mut result = macro_rules::compile(\n             &self.session.parse_sess, self.session.features_untracked(), item, edition\n         );\n@@ -822,6 +822,6 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        Lrc::new(result)\n+        result\n     }\n }"}, {"sha": "06b1e7bfd4eaf20c95dd1bded840ad3bdb47e91a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -3,7 +3,7 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use crate::astconv::AstConv;\n-use crate::middle::region;\n+use crate::middle::{lang_items, region};\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;\n@@ -266,7 +266,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n         let is_fn = tcx.lang_items().fn_trait_kind(trait_ref.def_id()).is_some();\n-        let gen_trait = tcx.lang_items().gen_trait().unwrap();\n+        let gen_trait = tcx.require_lang_item(lang_items::GeneratorTraitLangItem);\n         let is_gen = gen_trait == trait_ref.def_id();\n         if !is_fn && !is_gen {\n             debug!(\"deduce_sig_from_projection: not fn or generator\");"}, {"sha": "e735a9779c924c2070898905069bf46d1c9a135c", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -154,6 +154,6 @@ pub fn test(mut options: Options, diag: &errors::Handler) -> i32 {\n \n     options.test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&options.test_args, collector.tests,\n-                       testing::Options::new().display_output(options.display_warnings));\n+                       Some(testing::Options::new().display_output(options.display_warnings)));\n     0\n }"}, {"sha": "959587e7f53c6b9681677f17dd9f05c6f3acecf1", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -120,7 +120,7 @@ pub fn run(options: Options) -> i32 {\n     testing::test_main(\n         &test_args,\n         tests,\n-        testing::Options::new().display_output(display_warnings)\n+        Some(testing::Options::new().display_output(display_warnings))\n     );\n \n     0"}, {"sha": "795830a52c5451a3e190c238c5d8f3615cd319c5", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -910,7 +910,7 @@ impl f32 {\n         if self == NEG_INFINITY {\n             NEG_INFINITY\n         } else {\n-            (self + ((self * self) + 1.0).sqrt()).ln()\n+            (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n         }\n     }\n \n@@ -931,9 +931,10 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f32 {\n-        match self {\n-            x if x < 1.0 => crate::f32::NAN,\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n+        if self < 1.0 {\n+            crate::f32::NAN\n+        } else {\n+            (self + ((self * self) - 1.0).sqrt()).ln()\n         }\n     }\n \n@@ -1487,6 +1488,7 @@ mod tests {\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n+        assert!((-0.0f32).asinh().is_sign_negative()); // issue 63271\n         assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n         assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n     }"}, {"sha": "44d25f1b476575b5bbe713d9cac9a4743bec4007", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -244,7 +244,7 @@ impl f64 {\n     pub fn div_euclid(self, rhs: f64) -> f64 {\n         let q = (self / rhs).trunc();\n         if self % rhs < 0.0 {\n-            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n+            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 };\n         }\n         q\n     }\n@@ -437,9 +437,9 @@ impl f64 {\n     pub fn log2(self) -> f64 {\n         self.log_wrapper(|n| {\n             #[cfg(target_os = \"android\")]\n-            return crate::sys::android::log2f64(n);\n+                return crate::sys::android::log2f64(n);\n             #[cfg(not(target_os = \"android\"))]\n-            return unsafe { intrinsics::log2f64(n) };\n+                return unsafe { intrinsics::log2f64(n) };\n         })\n     }\n \n@@ -481,16 +481,16 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     #[rustc_deprecated(since = \"1.10.0\",\n-                       reason = \"you probably meant `(self - other).abs()`: \\\n+    reason = \"you probably meant `(self - other).abs()`: \\\n                                  this operation is `(self - other).max(0.0)` \\\n                                  except that `abs_sub` also propagates NaNs (also \\\n                                  known as `fdim` in C). If you truly need the positive \\\n                                  difference, consider using that expression or the C function \\\n                                  `fdim`, depending on how you wish to handle NaN (please consider \\\n                                  filing an issue describing your use-case too).\")]\n-     pub fn abs_sub(self, other: f64) -> f64 {\n-         unsafe { cmath::fdim(self, other) }\n-     }\n+    pub fn abs_sub(self, other: f64) -> f64 {\n+        unsafe { cmath::fdim(self, other) }\n+    }\n \n     /// Takes the cubic root of a number.\n     ///\n@@ -833,7 +833,7 @@ impl f64 {\n         if self == NEG_INFINITY {\n             NEG_INFINITY\n         } else {\n-            (self + ((self * self) + 1.0).sqrt()).ln()\n+            (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n         }\n     }\n \n@@ -852,9 +852,10 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f64 {\n-        match self {\n-            x if x < 1.0 => NAN,\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n+        if self < 1.0 {\n+            NAN\n+        } else {\n+            (self + ((self * self) - 1.0).sqrt()).ln()\n         }\n     }\n \n@@ -1187,7 +1188,7 @@ mod tests {\n         assert_eq!((-0f64).abs(), 0f64);\n         assert_eq!((-1f64).abs(), 1f64);\n         assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f64/NEG_INFINITY).abs(), 0f64);\n+        assert_eq!((1f64 / NEG_INFINITY).abs(), 0f64);\n         assert!(NAN.abs().is_nan());\n     }\n \n@@ -1199,7 +1200,7 @@ mod tests {\n         assert_eq!((-0f64).signum(), -1f64);\n         assert_eq!((-1f64).signum(), -1f64);\n         assert_eq!(NEG_INFINITY.signum(), -1f64);\n-        assert_eq!((1f64/NEG_INFINITY).signum(), -1f64);\n+        assert_eq!((1f64 / NEG_INFINITY).signum(), -1f64);\n         assert!(NAN.signum().is_nan());\n     }\n \n@@ -1211,7 +1212,7 @@ mod tests {\n         assert!(!(-0f64).is_sign_positive());\n         assert!(!(-1f64).is_sign_positive());\n         assert!(!NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f64/NEG_INFINITY).is_sign_positive());\n+        assert!(!(1f64 / NEG_INFINITY).is_sign_positive());\n         assert!(NAN.is_sign_positive());\n         assert!(!(-NAN).is_sign_positive());\n     }\n@@ -1224,7 +1225,7 @@ mod tests {\n         assert!((-0f64).is_sign_negative());\n         assert!((-1f64).is_sign_negative());\n         assert!(NEG_INFINITY.is_sign_negative());\n-        assert!((1f64/NEG_INFINITY).is_sign_negative());\n+        assert!((1f64 / NEG_INFINITY).is_sign_negative());\n         assert!(!NAN.is_sign_negative());\n         assert!((-NAN).is_sign_negative());\n     }\n@@ -1433,6 +1434,8 @@ mod tests {\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n+        assert!((-0.0f64).asinh().is_sign_negative());\n+        // issue 63271\n         assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n         assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n     }"}, {"sha": "10ff1b17285fe0247f57f9330b44f387cf141171", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -1,11 +1,11 @@\n use crate::ast::{self, NodeId, Attribute, Name, PatKind};\n-use crate::attr::{HasAttrs, Stability, Deprecation};\n+use crate::attr::{self, HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n use crate::ext::hygiene::{ExpnId, Transparency};\n use crate::mut_visit::{self, MutVisitor};\n-use crate::parse::{self, parser, DirectoryOwnership};\n+use crate::parse::{self, parser, ParseSess, DirectoryOwnership};\n use crate::parse::token;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n@@ -601,6 +601,69 @@ impl SyntaxExtension {\n         }\n     }\n \n+    /// Constructs a syntax extension with the given properties\n+    /// and other properties converted from attributes.\n+    pub fn new(\n+        sess: &ParseSess,\n+        kind: SyntaxExtensionKind,\n+        span: Span,\n+        helper_attrs: Vec<Symbol>,\n+        edition: Edition,\n+        name: Name,\n+        attrs: &[ast::Attribute],\n+    ) -> SyntaxExtension {\n+        let allow_internal_unstable =\n+            attr::find_by_name(attrs, sym::allow_internal_unstable).map(|attr| {\n+                attr.meta_item_list()\n+                    .map(|list| {\n+                        list.iter()\n+                            .filter_map(|it| {\n+                                let name = it.ident().map(|ident| ident.name);\n+                                if name.is_none() {\n+                                    sess.span_diagnostic.span_err(\n+                                        it.span(), \"allow internal unstable expects feature names\"\n+                                    )\n+                                }\n+                                name\n+                            })\n+                            .collect::<Vec<Symbol>>()\n+                            .into()\n+                    })\n+                    .unwrap_or_else(|| {\n+                        sess.span_diagnostic.span_warn(\n+                            attr.span,\n+                            \"allow_internal_unstable expects list of feature names. In the future \\\n+                             this will become a hard error. Please use `allow_internal_unstable(\\\n+                             foo, bar)` to only allow the `foo` and `bar` features\",\n+                        );\n+                        vec![sym::allow_internal_unstable_backcompat_hack].into()\n+                    })\n+            });\n+\n+        let mut local_inner_macros = false;\n+        if let Some(macro_export) = attr::find_by_name(attrs, sym::macro_export) {\n+            if let Some(l) = macro_export.meta_item_list() {\n+                local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n+            }\n+        }\n+\n+        let is_builtin = attr::contains_name(attrs, sym::rustc_builtin_macro);\n+\n+        SyntaxExtension {\n+            kind,\n+            span,\n+            allow_internal_unstable,\n+            allow_internal_unsafe: attr::contains_name(attrs, sym::allow_internal_unsafe),\n+            local_inner_macros,\n+            stability: attr::find_stability(&sess, attrs, span),\n+            deprecation: attr::find_deprecation(&sess, attrs, span),\n+            helper_attrs,\n+            edition,\n+            is_builtin,\n+            is_derive_copy: is_builtin && name == sym::Copy,\n+        }\n+    }\n+\n     pub fn dummy_bang(edition: Edition) -> SyntaxExtension {\n         fn expander<'cx>(_: &'cx mut ExtCtxt<'_>, span: Span, _: &[TokenTree])\n                          -> Box<dyn MacResult + 'cx> {"}, {"sha": "1a26b17dac782fae18ee1ff86c3b872e17162a33", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -360,12 +360,11 @@ pub(crate) struct Rustc<'a> {\n \n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n-        // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.id.expn_data().call_site;\n+        let expn_data = cx.current_expansion.id.expn_data();\n         Rustc {\n             sess: cx.parse_sess,\n-            def_site: cx.with_def_site_ctxt(location),\n-            call_site: cx.with_call_site_ctxt(location),\n+            def_site: cx.with_def_site_ctxt(expn_data.def_site),\n+            call_site: cx.with_call_site_ctxt(expn_data.call_site),\n         }\n     }\n "}, {"sha": "46ffa52f7f5725a1f652948151f23f94ffcd3a49", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 13, "deletions": 57, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -1,3 +1,5 @@\n+use crate::ast;\n+use crate::attr::{self, TransparencyError};\n use crate::edition::Edition;\n use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n@@ -15,7 +17,6 @@ use crate::parse::token::{self, NtTT, Token};\n use crate::parse::{Directory, ParseSess};\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n-use crate::{ast, attr, attr::TransparencyError};\n \n use errors::{DiagnosticBuilder, FatalError};\n use log::debug;\n@@ -290,6 +291,7 @@ pub fn compile(\n     def: &ast::Item,\n     edition: Edition,\n ) -> SyntaxExtension {\n+    let diag = &sess.span_diagnostic;\n     let lhs_nm = ast::Ident::new(sym::lhs, def.span);\n     let rhs_nm = ast::Ident::new(sym::rhs, def.span);\n     let tt_spec = ast::Ident::new(sym::tt, def.span);\n@@ -423,71 +425,25 @@ pub fn compile(\n     let (transparency, transparency_error) = attr::find_transparency(&def.attrs, body.legacy);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) =>\n-            sess.span_diagnostic.span_err(\n-                span, &format!(\"unknown macro transparency: `{}`\", value)\n-            ),\n+            diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value)),\n         Some(TransparencyError::MultipleTransparencyAttrs(old_span, new_span)) =>\n-            sess.span_diagnostic.span_err(\n-                vec![old_span, new_span], \"multiple macro transparency attributes\"\n-            ),\n+            diag.span_err(vec![old_span, new_span], \"multiple macro transparency attributes\"),\n         None => {}\n     }\n \n     let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident, span: def.span, transparency, lhses, rhses, valid\n     });\n \n-    let allow_internal_unstable =\n-        attr::find_by_name(&def.attrs, sym::allow_internal_unstable).map(|attr| {\n-            attr.meta_item_list()\n-                .map(|list| {\n-                    list.iter()\n-                        .filter_map(|it| {\n-                            let name = it.ident().map(|ident| ident.name);\n-                            if name.is_none() {\n-                                sess.span_diagnostic.span_err(\n-                                    it.span(),\n-                                    \"allow internal unstable expects feature names\",\n-                                )\n-                            }\n-                            name\n-                        })\n-                        .collect::<Vec<Symbol>>()\n-                        .into()\n-                })\n-                .unwrap_or_else(|| {\n-                    sess.span_diagnostic.span_warn(\n-                        attr.span,\n-                        \"allow_internal_unstable expects list of feature names. In the \\\n-                         future this will become a hard error. Please use `allow_internal_unstable(\\\n-                         foo, bar)` to only allow the `foo` and `bar` features\",\n-                    );\n-                    vec![sym::allow_internal_unstable_backcompat_hack].into()\n-                })\n-        });\n-\n-    let mut local_inner_macros = false;\n-    if let Some(macro_export) = attr::find_by_name(&def.attrs, sym::macro_export) {\n-        if let Some(l) = macro_export.meta_item_list() {\n-            local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n-        }\n-    }\n-\n-    let is_builtin = attr::contains_name(&def.attrs, sym::rustc_builtin_macro);\n-\n-    SyntaxExtension {\n-        kind: SyntaxExtensionKind::LegacyBang(expander),\n-        span: def.span,\n-        allow_internal_unstable,\n-        allow_internal_unsafe: attr::contains_name(&def.attrs, sym::allow_internal_unsafe),\n-        local_inner_macros,\n-        stability: attr::find_stability(&sess, &def.attrs, def.span),\n-        deprecation: attr::find_deprecation(&sess, &def.attrs, def.span),\n-        helper_attrs: Vec::new(),\n+    SyntaxExtension::new(\n+        sess,\n+        SyntaxExtensionKind::LegacyBang(expander),\n+        def.span,\n+        Vec::new(),\n         edition,\n-        is_builtin,\n-        is_derive_copy: is_builtin && def.ident.name == sym::Copy,\n-    }\n+        def.ident.name,\n+        &def.attrs,\n+    )\n }\n \n fn check_lhs_nt_follows("}, {"sha": "2b20cb88796c383141aedbba250dc4c1e010f935", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -375,10 +375,11 @@ impl<'a> Parser<'a> {\n         if let Some(directory) = directory {\n             parser.directory = directory;\n         } else if !parser.token.span.is_dummy() {\n-            if let FileName::Real(mut path) =\n-                    sess.source_map().span_to_unmapped_path(parser.token.span) {\n-                path.pop();\n-                parser.directory.path = Cow::from(path);\n+            if let Some(FileName::Real(path)) =\n+                    &sess.source_map().lookup_char_pos(parser.token.span.lo()).file.unmapped_path {\n+                if let Some(directory_path) = path.parent() {\n+                    parser.directory.path = Cow::from(directory_path.to_path_buf());\n+                }\n             }\n         }\n "}, {"sha": "1a6176916623b1017b3c2438c34e1d8eb03072c0", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -7,13 +7,18 @@\n #![feature(decl_macro)]\n #![feature(mem_take)]\n #![feature(nll)]\n+#![feature(proc_macro_internals)]\n+#![feature(proc_macro_quote)]\n #![feature(rustc_diagnostic_macros)]\n \n+extern crate proc_macro;\n+\n use crate::deriving::*;\n \n use syntax::ast::Ident;\n use syntax::edition::Edition;\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, MacroExpanderFn};\n+use syntax::ext::proc_macro::BangProcMacro;\n use syntax::symbol::sym;\n \n mod error_codes;\n@@ -100,4 +105,7 @@ pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, e\n         RustcDecodable: decodable::expand_deriving_rustc_decodable,\n         RustcEncodable: encodable::expand_deriving_rustc_encodable,\n     }\n+\n+    let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n+    register(sym::quote, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })));\n }"}, {"sha": "e0bea4ce54530111ec900e689b5b472e5571ecc0", "filename": "src/libtest/formatters/json.rs", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -9,44 +9,57 @@ impl<T: Write> JsonFormatter<T> {\n         Self { out }\n     }\n \n-    fn write_message(&mut self, s: &str) -> io::Result<()> {\n+    fn writeln_message(&mut self, s: &str) -> io::Result<()> {\n         assert!(!s.contains('\\n'));\n \n         self.out.write_all(s.as_ref())?;\n         self.out.write_all(b\"\\n\")\n     }\n \n+    fn write_message(&mut self, s: &str) -> io::Result<()> {\n+        assert!(!s.contains('\\n'));\n+\n+        self.out.write_all(s.as_ref())\n+    }\n+\n     fn write_event(\n         &mut self,\n         ty: &str,\n         name: &str,\n         evt: &str,\n-        extra: Option<String>,\n+        stdout: Option<Cow<'_, str>>,\n+        extra: Option<&str>,\n     ) -> io::Result<()> {\n-        if let Some(extras) = extra {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\"\"#,\n+            ty, name, evt\n+        ))?;\n+        if let Some(stdout) = stdout {\n             self.write_message(&*format!(\n-                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n-                ty, name, evt, extras\n-            ))\n-        } else {\n+                r#\", \"stdout\": \"{}\"\"#,\n+                EscapedString(stdout)\n+            ))?;\n+        }\n+        if let Some(extra) = extra {\n             self.write_message(&*format!(\n-                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n-                ty, name, evt\n-            ))\n+                r#\", {}\"#,\n+                extra\n+            ))?;\n         }\n+        self.writeln_message(\" }\")\n     }\n }\n \n impl<T: Write> OutputFormatter for JsonFormatter<T> {\n     fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n-        self.write_message(&*format!(\n+        self.writeln_message(&*format!(\n             r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {} }}\"#,\n             test_count\n         ))\n     }\n \n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_message(&*format!(\n+        self.writeln_message(&*format!(\n             r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n             desc.name\n         ))\n@@ -57,34 +70,30 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n         desc: &TestDesc,\n         result: &TestResult,\n         stdout: &[u8],\n+        state: &ConsoleTestState,\n     ) -> io::Result<()> {\n+        let stdout = if (state.options.display_output || *result != TrOk) && stdout.len() > 0 {\n+            Some(String::from_utf8_lossy(stdout))\n+        } else {\n+            None\n+        };\n         match *result {\n-            TrOk => self.write_event(\"test\", desc.name.as_slice(), \"ok\", None),\n-\n-            TrFailed => {\n-                let extra_data = if stdout.len() > 0 {\n-                    Some(format!(\n-                        r#\"\"stdout\": \"{}\"\"#,\n-                        EscapedString(String::from_utf8_lossy(stdout))\n-                    ))\n-                } else {\n-                    None\n-                };\n+            TrOk => self.write_event(\"test\", desc.name.as_slice(), \"ok\", stdout, None),\n \n-                self.write_event(\"test\", desc.name.as_slice(), \"failed\", extra_data)\n-            }\n+            TrFailed => self.write_event(\"test\", desc.name.as_slice(), \"failed\", stdout, None),\n \n             TrFailedMsg(ref m) => self.write_event(\n                 \"test\",\n                 desc.name.as_slice(),\n                 \"failed\",\n-                Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n+                stdout,\n+                Some(&*format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n             ),\n \n-            TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None),\n+            TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", stdout, None),\n \n             TrAllowedFail => {\n-                self.write_event(\"test\", desc.name.as_slice(), \"allowed_failure\", None)\n+                self.write_event(\"test\", desc.name.as_slice(), \"allowed_failure\", stdout, None)\n             }\n \n             TrBench(ref bs) => {\n@@ -105,20 +114,20 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                     desc.name, median, deviation, mbps\n                 );\n \n-                self.write_message(&*line)\n+                self.writeln_message(&*line)\n             }\n         }\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_message(&*format!(\n+        self.writeln_message(&*format!(\n             r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n             desc.name\n         ))\n     }\n \n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n-        self.write_message(&*format!(\n+        self.writeln_message(&*format!(\n             \"{{ \\\"type\\\": \\\"suite\\\", \\\n              \\\"event\\\": \\\"{}\\\", \\\n              \\\"passed\\\": {}, \\"}, {"sha": "cc30b06e5ec38f1fd178a1fbed4f35079a0a2209", "filename": "src/libtest/formatters/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -17,6 +17,7 @@ pub(crate) trait OutputFormatter {\n         desc: &TestDesc,\n         result: &TestResult,\n         stdout: &[u8],\n+        state: &ConsoleTestState,\n     ) -> io::Result<()>;\n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n }"}, {"sha": "88331406a64d0dcd501ca2dba520e346c9cf93c8", "filename": "src/libtest/formatters/pretty.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -162,7 +162,13 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         Ok(())\n     }\n \n-    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        _: &[u8],\n+        _: &ConsoleTestState,\n+    ) -> io::Result<()> {\n         if self.is_multithreaded {\n             self.write_test_name(desc)?;\n         }"}, {"sha": "d10b0c5807d57406c21be671bc355875eace8d38", "filename": "src/libtest/formatters/terse.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -170,7 +170,13 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n         Ok(())\n     }\n \n-    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        _: &[u8],\n+        _: &ConsoleTestState,\n+    ) -> io::Result<()> {\n         match *result {\n             TrOk => self.write_ok(),\n             TrFailed | TrFailedMsg(_) => self.write_failed(),"}, {"sha": "09d5fcc89520e4bb75866ee019d4a8986e792e82", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -274,7 +274,7 @@ impl Options {\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n-pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n+pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Options>) {\n     let mut opts = match parse_opts(args) {\n         Some(Ok(o)) => o,\n         Some(Err(msg)) => {\n@@ -283,8 +283,9 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n         }\n         None => return,\n     };\n-\n-    opts.options = options;\n+    if let Some(options) = options {\n+        opts.options = options;\n+    }\n     if opts.list {\n         if let Err(e) = list_tests_console(&opts, tests) {\n             eprintln!(\"error: io error when listing tests: {:?}\", e);\n@@ -325,7 +326,7 @@ pub fn test_main_static(tests: &[&TestDescAndFn]) {\n             _ => panic!(\"non-static tests passed to test::test_main_static\"),\n         })\n         .collect();\n-    test_main(&args, owned_tests, Options::new())\n+    test_main(&args, owned_tests, None)\n }\n \n /// Invoked when unit tests terminate. Should panic if the unit\n@@ -448,6 +449,11 @@ fn optgroups() -> getopts::Options {\n             json   = Output a json document\",\n             \"pretty|terse|json\",\n         )\n+        .optflag(\n+            \"\",\n+            \"show-output\",\n+            \"Show captured stdout of successful tests\"\n+        )\n         .optopt(\n             \"Z\",\n             \"\",\n@@ -647,7 +653,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         format,\n         test_threads,\n         skip: matches.opt_strs(\"skip\"),\n-        options: Options::new(),\n+        options: Options::new().display_output(matches.opt_present(\"show-output\")),\n     };\n \n     Some(Ok(test_opts))\n@@ -880,7 +886,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n             TeTimeout(ref test) => out.write_timeout(test),\n             TeResult(test, result, stdout) => {\n                 st.write_log_result(&test, &result)?;\n-                out.write_result(&test, &result, &*stdout)?;\n+                out.write_result(&test, &result, &*stdout, &st)?;\n                 match result {\n                     TrOk => {\n                         st.passed += 1;"}, {"sha": "afc4217ec1ba24a5019963a7b729a6cbf2444f05", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -180,6 +180,17 @@ fn parse_ignored_flag() {\n     assert_eq!(opts.run_ignored, RunIgnored::Only);\n }\n \n+#[test]\n+fn parse_show_output_flag() {\n+    let args = vec![\n+        \"progname\".to_string(),\n+        \"filter\".to_string(),\n+        \"--show-output\".to_string(),\n+    ];\n+    let opts = parse_opts(&args).unwrap().unwrap();\n+    assert!(opts.options.display_output);\n+}\n+\n #[test]\n fn parse_include_ignored_flag() {\n     let args = vec!["}, {"sha": "8339e230bbe9259493965dcff4e1ba2e9fde3476", "filename": "src/test/run-make-fulldeps/libtest-json/Makefile", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2FMakefile?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -2,13 +2,17 @@\n \n # Test expected libtest's JSON output\n \n-OUTPUT_FILE := $(TMPDIR)/libtest-json-output.json\n+OUTPUT_FILE_DEFAULT := $(TMPDIR)/libtest-json-output-default.json\n+OUTPUT_FILE_STDOUT_SUCCESS := $(TMPDIR)/libtest-json-output-stdout-success.json\n \n all:\n \t$(RUSTC) --test f.rs\n-\tRUST_BACKTRACE=0 $(call RUN,f) -Z unstable-options --test-threads=1 --format=json > $(OUTPUT_FILE) || true\n+\tRUST_BACKTRACE=0 $(call RUN,f) -Z unstable-options --test-threads=1 --format=json > $(OUTPUT_FILE_DEFAULT) || true\n+\tRUST_BACKTRACE=0 $(call RUN,f) -Z unstable-options --test-threads=1 --format=json --show-output > $(OUTPUT_FILE_STDOUT_SUCCESS) || true\n \n-\tcat $(OUTPUT_FILE) | \"$(PYTHON)\" validate_json.py\n+\tcat $(OUTPUT_FILE_DEFAULT) | \"$(PYTHON)\" validate_json.py\n+\tcat $(OUTPUT_FILE_STDOUT_SUCCESS) | \"$(PYTHON)\" validate_json.py\n \n \t# Compare to output file\n-\tdiff output.json $(OUTPUT_FILE)\n+\tdiff output-default.json $(OUTPUT_FILE_DEFAULT)\n+\tdiff output-stdout-success.json $(OUTPUT_FILE_STDOUT_SUCCESS)"}, {"sha": "95ff36bd764ec40afb19495ad8844dda458e42f6", "filename": "src/test/run-make-fulldeps/libtest-json/f.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Ff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Ff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Ff.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -1,11 +1,12 @@\n #[test]\n fn a() {\n+    println!(\"print from successful test\");\n     // Should pass\n }\n \n #[test]\n fn b() {\n-    assert!(false)\n+    assert!(false);\n }\n \n #[test]"}, {"sha": "8046d722217036ee89595f9bedf7249d917fe948", "filename": "src/test/run-make-fulldeps/libtest-json/output-default.json", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-default.json", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-default.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-default.json?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -2,7 +2,7 @@\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n-{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:8:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\\n\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n { \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }", "previous_filename": "src/test/run-make-fulldeps/libtest-json/output.json"}, {"sha": "303316278d8aba04a055c45840cc7614622563ba", "filename": "src/test/run-make-fulldeps/libtest-json/output-stdout-success.json", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-stdout-success.json", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-stdout-success.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-stdout-success.json?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -0,0 +1,10 @@\n+{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": 4 }\n+{ \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n+{ \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\", \"stdout\": \"print from successful test\\n\" }\n+{ \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\\n\" }\n+{ \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n+{ \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:15:5\\n\" }\n+{ \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }\n+{ \"type\": \"test\", \"name\": \"d\", \"event\": \"ignored\" }\n+{ \"type\": \"suite\", \"event\": \"failed\", \"passed\": 2, \"failed\": 1, \"allowed_fail\": 0, \"ignored\": 1, \"measured\": 0, \"filtered_out\": 0 }"}, {"sha": "2819541bf6966127d538908cf0e18879f5a30433", "filename": "src/test/ui/auxiliary/cond_plugin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fcond_plugin.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -3,6 +3,7 @@\n \n #![crate_type = \"proc-macro\"]\n #![feature(proc_macro_hygiene)]\n+#![feature(proc_macro_quote)]\n \n extern crate proc_macro;\n "}, {"sha": "49cfb5518ba9c88bf1ef27959be5905127f8ea00", "filename": "src/test/ui/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fproc_macro_def.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -3,6 +3,7 @@\n \n #![crate_type = \"proc-macro\"]\n #![feature(proc_macro_hygiene)]\n+#![feature(proc_macro_quote)]\n \n extern crate proc_macro;\n "}, {"sha": "0c329542928c559adf4f00c268a2b989269476de", "filename": "src/test/ui/lang-item-missing-generator.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Flang-item-missing-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Flang-item-missing-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-item-missing-generator.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -0,0 +1,19 @@\n+// error-pattern: requires `generator` lang_item\n+#![feature(no_core, lang_items, unboxed_closures)]\n+#![no_core]\n+\n+#[lang = \"sized\"] pub trait Sized { }\n+\n+#[lang = \"fn_once\"]\n+#[rustc_paren_sugar]\n+pub trait FnOnce<Args> {\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+pub fn abc() -> impl FnOnce(f32) {\n+    |_| {}\n+}\n+\n+fn main() {}"}, {"sha": "d0cc4b81be6853d603f7a0c95e5276190a932f40", "filename": "src/test/ui/lang-item-missing-generator.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Flang-item-missing-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Flang-item-missing-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-item-missing-generator.stderr?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -0,0 +1,4 @@\n+error: requires `generator` lang_item\n+\n+error: aborting due to previous error\n+"}, {"sha": "c460db36f1aa3592be38a0fd71b3b0cd69c10fee", "filename": "src/test/ui/macros/auxiliary/proc_macro_sequence.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -6,7 +6,7 @@\n \n extern crate proc_macro;\n \n-use proc_macro::{quote, Span, TokenStream};\n+use proc_macro::{quote, Span, TokenStream, TokenTree};\n \n fn assert_same_span(a: Span, b: Span) {\n     assert_eq!(a.start(), b.start());\n@@ -24,12 +24,22 @@ pub fn make_foo(_: TokenStream) -> TokenStream {\n     };\n \n     // Check that all spans are equal.\n-    let mut span = None;\n+    // FIXME: `quote!` gives def-site spans to idents and literals,\n+    // but leaves (default) call-site spans on groups and punctuation.\n+    let mut span_call = None;\n+    let mut span_def = None;\n     for tt in result.clone() {\n-        match span {\n-            None => span = Some(tt.span()),\n-            Some(span) => assert_same_span(tt.span(), span),\n+        match tt {\n+            TokenTree::Ident(..) | TokenTree::Literal(..) => match span_def {\n+                None => span_def = Some(tt.span()),\n+                Some(span) => assert_same_span(tt.span(), span),\n+            }\n+            TokenTree::Punct(..) | TokenTree::Group(..) => match span_call {\n+                None => span_call = Some(tt.span()),\n+                Some(span) => assert_same_span(tt.span(), span),\n+            }\n         }\n+\n     }\n \n     result"}, {"sha": "0eef4a2a678b6b7bb51d8f3932e9e3d03e8bfab5", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -17,11 +17,15 @@ LL |                $(= $z:tt)*\n error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n   --> $DIR/same-sequence-span.rs:20:1\n    |\n-LL | proc_macro_sequence::make_foo!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |   proc_macro_sequence::make_foo!();\n+   |   ^--------------------------------\n+   |   |\n+   |  _in this macro invocation\n    | |\n-   | not allowed after `expr` fragments\n-   | in this macro invocation\n+LL | |\n+LL | |\n+LL | | fn main() {}\n+...  |\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n "}, {"sha": "055781d2c6048c01d4769f96695cc1224daae3ba", "filename": "src/test/ui/proc-macro/attributes-on-definitions.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+// aux-build:attributes-on-definitions.rs\n+\n+#![forbid(unsafe_code)]\n+\n+extern crate attributes_on_definitions;\n+\n+attributes_on_definitions::with_attrs!();\n+//~^ WARN use of deprecated item\n+// No errors about the use of unstable and unsafe code inside the macro.\n+\n+fn main() {}"}, {"sha": "c61e043b229713a03dcc03cad43fd0e250f41af3", "filename": "src/test/ui/proc-macro/attributes-on-definitions.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.stderr?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -0,0 +1,8 @@\n+warning: use of deprecated item 'attributes_on_definitions::with_attrs': test\n+  --> $DIR/attributes-on-definitions.rs:8:1\n+   |\n+LL | attributes_on_definitions::with_attrs!();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+"}, {"sha": "93a339840d6211e514a1a054783a69b17ff3aa31", "filename": "src/test/ui/proc-macro/auxiliary/attributes-on-definitions.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattributes-on-definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattributes-on-definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattributes-on-definitions.rs?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -0,0 +1,23 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(allow_internal_unsafe)]\n+#![feature(allow_internal_unstable)]\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+#[allow_internal_unstable(proc_macro_internals)]\n+#[allow_internal_unsafe]\n+#[deprecated(since = \"1.0.0\", note = \"test\")]\n+pub fn with_attrs(_: TokenStream) -> TokenStream {\n+    \"\n+    extern crate proc_macro;\n+    use ::proc_macro::bridge;\n+\n+    fn contains_unsafe() { unsafe {} }\n+    \".parse().unwrap()\n+}"}, {"sha": "e7f705c7feb67142afd56c93d908df98d53e420f", "filename": "src/test/ui/proc-macro/multispan.stderr", "status": "modified", "additions": 105, "deletions": 28, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -1,8 +1,19 @@\n error: hello to you, too!\n-  --> $DIR/multispan.rs:14:5\n-   |\n-LL |     hello!(hi);\n-   |     ^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:14:5\n+   |\n+LL |       hello!(hi);\n+   |       ----------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:14:12\n@@ -11,10 +22,21 @@ LL |     hello!(hi);\n    |            ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:17:5\n-   |\n-LL |     hello!(hi hi);\n-   |     ^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:17:5\n+   |\n+LL |       hello!(hi hi);\n+   |       -------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:17:12\n@@ -23,10 +45,21 @@ LL |     hello!(hi hi);\n    |            ^^ ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:20:5\n-   |\n-LL |     hello!(hi hi hi);\n-   |     ^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:20:5\n+   |\n+LL |       hello!(hi hi hi);\n+   |       ----------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:20:12\n@@ -35,10 +68,21 @@ LL |     hello!(hi hi hi);\n    |            ^^ ^^ ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:23:5\n-   |\n-LL |     hello!(hi hey hi yo hi beep beep hi hi);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:23:5\n+   |\n+LL |       hello!(hi hey hi yo hi beep beep hi hi);\n+   |       ---------------------------------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:23:12\n@@ -47,10 +91,21 @@ LL |     hello!(hi hey hi yo hi beep beep hi hi);\n    |            ^^     ^^    ^^           ^^ ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:24:5\n-   |\n-LL |     hello!(hi there, hi how are you? hi... hi.);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:24:5\n+   |\n+LL |       hello!(hi there, hi how are you? hi... hi.);\n+   |       -------------------------------------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:24:12\n@@ -59,10 +114,21 @@ LL |     hello!(hi there, hi how are you? hi... hi.);\n    |            ^^        ^^              ^^    ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:25:5\n-   |\n-LL |     hello!(whoah. hi di hi di ho);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:25:5\n+   |\n+LL |       hello!(whoah. hi di hi di ho);\n+   |       ------------------------------ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:25:19\n@@ -71,10 +137,21 @@ LL |     hello!(whoah. hi di hi di ho);\n    |                   ^^    ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:26:5\n-   |\n-LL |     hello!(hi good hi and good bye);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:26:5\n+   |\n+LL |       hello!(hi good hi and good bye);\n+   |       -------------------------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:26:12"}, {"sha": "0698b0f47542409f6b8d638c964e429d9786d8c3", "filename": "src/test/ui/proc-macro/three-equals.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e0afdad28c4d1154176df6d35a14e738ec311af/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr?ref=7e0afdad28c4d1154176df6d35a14e738ec311af", "patch": "@@ -1,8 +1,19 @@\n error: found 2 equal signs, need exactly 3\n-  --> $DIR/three-equals.rs:15:5\n-   |\n-LL |     three_equals!(==);\n-   |     ^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/three-equals.rs:42:1\n+   |\n+LL | / pub fn three_equals(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |         return TokenStream::new();\n+...  |\n+LL | |     \"3\".parse().unwrap()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/three-equals.rs:15:5\n+   |\n+LL |       three_equals!(==);\n+   |       ------------------ in this macro invocation\n    |\n    = help: input must be: `===`\n "}]}