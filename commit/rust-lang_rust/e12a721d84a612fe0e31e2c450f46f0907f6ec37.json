{"sha": "e12a721d84a612fe0e31e2c450f46f0907f6ec37", "node_id": "C_kwDOAAsO6NoAKGUxMmE3MjFkODRhNjEyZmUwZTMxZTJjNDUwZjQ2ZjA5MDdmNmVjMzc", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T11:42:08Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T11:42:56Z"}, "message": "no need for an exhaustive enum of subcommands", "tree": {"sha": "f024aac80088ab55fb1a138093e08fbd01fa06e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f024aac80088ab55fb1a138093e08fbd01fa06e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e12a721d84a612fe0e31e2c450f46f0907f6ec37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e12a721d84a612fe0e31e2c450f46f0907f6ec37", "html_url": "https://github.com/rust-lang/rust/commit/e12a721d84a612fe0e31e2c450f46f0907f6ec37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e12a721d84a612fe0e31e2c450f46f0907f6ec37/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebda1deb7bbe962638f500fc772d8d005cfed01c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebda1deb7bbe962638f500fc772d8d005cfed01c", "html_url": "https://github.com/rust-lang/rust/commit/ebda1deb7bbe962638f500fc772d8d005cfed01c"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "2ab854b906a4f0fd27e2bbd8badbcb41d064bd95", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e12a721d84a612fe0e31e2c450f46f0907f6ec37/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12a721d84a612fe0e31e2c450f46f0907f6ec37/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=e12a721d84a612fe0e31e2c450f46f0907f6ec37", "patch": "@@ -1,3 +1,4 @@\n+#![feature(let_else)]\n #![allow(clippy::useless_format, clippy::derive_partial_eq_without_eq)]\n \n mod version;\n@@ -34,11 +35,12 @@ Examples:\n     cargo miri test -- test-suite-filter\n \"#;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug)]\n enum MiriCommand {\n-    Run,\n-    Test,\n+    /// Our own special 'setup' command.\n     Setup,\n+    /// A command to be forwarded to cargo.\n+    Forward(String),\n }\n \n /// The information to run a crate with the given environment.\n@@ -339,17 +341,18 @@ fn write_to_file(filename: &Path, content: &str) {\n /// Performs the setup required to make `cargo miri` work: Getting a custom-built libstd. Then sets\n /// `MIRI_SYSROOT`. Skipped if `MIRI_SYSROOT` is already set, in which case we expect the user has\n /// done all this already.\n-fn setup(subcommand: MiriCommand) {\n+fn setup(subcommand: &MiriCommand) {\n+    let only_setup = matches!(subcommand, MiriCommand::Setup);\n     if std::env::var_os(\"MIRI_SYSROOT\").is_some() {\n-        if subcommand == MiriCommand::Setup {\n+        if only_setup {\n             println!(\"WARNING: MIRI_SYSROOT already set, not doing anything.\")\n         }\n         return;\n     }\n \n     // Subcommands other than `setup` will do a setup if necessary, but\n     // interactively confirm first.\n-    let ask_user = subcommand != MiriCommand::Setup;\n+    let ask_user = !only_setup;\n \n     // First, we need xargo.\n     if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n@@ -495,11 +498,11 @@ path = \"lib.rs\"\n     let sysroot = if target == &host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n     std::env::set_var(\"MIRI_SYSROOT\", &sysroot); // pass the env var to the processes we spawn, which will turn it into \"--sysroot\" flags\n     // Figure out what to print.\n-    let print_sysroot = subcommand == MiriCommand::Setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n+    let print_sysroot = only_setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n     if print_sysroot {\n         // Print just the sysroot and nothing else; this way we do not need any escaping.\n         println!(\"{}\", sysroot.display());\n-    } else if subcommand == MiriCommand::Setup {\n+    } else if only_setup {\n         println!(\"A libstd for Miri is now available in `{}`.\", sysroot.display());\n     }\n }\n@@ -573,10 +576,12 @@ fn phase_cargo_miri(mut args: env::Args) {\n     // Require a subcommand before any flags.\n     // We cannot know which of those flags take arguments and which do not,\n     // so we cannot detect subcommands later.\n-    let subcommand = match args.next().as_deref() {\n-        Some(\"test\" | \"t\") => MiriCommand::Test,\n-        Some(\"run\" | \"r\") => MiriCommand::Run,\n-        Some(\"setup\") => MiriCommand::Setup,\n+    let Some(subcommand) = args.next() else {\n+        show_error(format!(\"`cargo miri` needs to be called with a subcommand (`run`, `test`)\"));\n+    };\n+    let subcommand = match &*subcommand {\n+        \"setup\" => MiriCommand::Setup,\n+        \"test\" | \"t\" | \"run\" | \"r\" => MiriCommand::Forward(subcommand),\n         // Invalid command.\n         _ =>\n             show_error(format!(\n@@ -586,7 +591,7 @@ fn phase_cargo_miri(mut args: env::Args) {\n     let verbose = has_arg_flag(\"-v\");\n \n     // We always setup.\n-    setup(subcommand);\n+    setup(&subcommand);\n \n     // Invoke actual cargo for the job, but with different flags.\n     // We re-use `cargo test` and `cargo run`, which makes target and binary handling very easy but\n@@ -596,8 +601,7 @@ fn phase_cargo_miri(mut args: env::Args) {\n     // harder.\n     let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n     let cargo_cmd = match subcommand {\n-        MiriCommand::Test => \"test\",\n-        MiriCommand::Run => \"run\",\n+        MiriCommand::Forward(s) => s,\n         MiriCommand::Setup => return, // `cargo miri setup` stops here.\n     };\n     let mut cmd = cargo();"}]}