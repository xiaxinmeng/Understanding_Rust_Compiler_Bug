{"sha": "1da73ff12642182c9049630c3625f44f718c6c2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYTczZmYxMjY0MjE4MmM5MDQ5NjMwYzM2MjVmNDRmNzE4YzZjMmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-28T11:13:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-28T12:18:21Z"}, "message": "Avoid O(n^2) performance by reconsidering the full set of obligations only when we are about to report an error (#18208). I found it is still important to consider the full set in order to make tests like `let x: Vec<_> = obligations.iter().collect()` work.", "tree": {"sha": "ba01801e6378f78adff361bd09b84734c9738a6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba01801e6378f78adff361bd09b84734c9738a6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1da73ff12642182c9049630c3625f44f718c6c2f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1da73ff12642182c9049630c3625f44f718c6c2f", "html_url": "https://github.com/rust-lang/rust/commit/1da73ff12642182c9049630c3625f44f718c6c2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1da73ff12642182c9049630c3625f44f718c6c2f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faed6489dacf334a84fa890b385363bca0d865da", "url": "https://api.github.com/repos/rust-lang/rust/commits/faed6489dacf334a84fa890b385363bca0d865da", "html_url": "https://github.com/rust-lang/rust/commit/faed6489dacf334a84fa890b385363bca0d865da"}], "stats": {"total": 169, "additions": 128, "deletions": 41}, "files": [{"sha": "6baf4e6c048903f9b517b4933e9f37a936f3588b", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 75, "deletions": 21, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1da73ff12642182c9049630c3625f44f718c6c2f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da73ff12642182c9049630c3625f44f718c6c2f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=1da73ff12642182c9049630c3625f44f718c6c2f", "patch": "@@ -35,12 +35,18 @@ pub struct FulfillmentContext {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     trait_obligations: Vec<Obligation>,\n+\n+    // Remembers the count of trait obligations that we have already\n+    // attempted to select. This is used to avoid repeating work\n+    // when `select_new_obligations` is called.\n+    attempted_mark: uint,\n }\n \n impl FulfillmentContext {\n     pub fn new() -> FulfillmentContext {\n         FulfillmentContext {\n             trait_obligations: Vec::new(),\n+            attempted_mark: 0,\n         }\n     }\n \n@@ -74,18 +80,49 @@ impl FulfillmentContext {\n         }\n     }\n \n+    pub fn select_new_obligations<'a,'tcx>(&mut self,\n+                                           infcx: &InferCtxt<'a,'tcx>,\n+                                           param_env: &ty::ParameterEnvironment,\n+                                           typer: &Typer<'tcx>)\n+                                           -> Result<(),Vec<FulfillmentError>>\n+    {\n+        /*!\n+         * Attempts to select obligations that were registered since\n+         * the call to a selection routine. This is used by the type checker\n+         * to eagerly attempt to resolve obligations in hopes of gaining\n+         * type information. It'd be equally valid to use `select_where_possible`\n+         * but it results in `O(n^2)` performance (#18208).\n+         */\n+\n+        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+        self.select(&mut selcx, true)\n+    }\n+\n     pub fn select_where_possible<'a,'tcx>(&mut self,\n                                           infcx: &InferCtxt<'a,'tcx>,\n                                           param_env: &ty::ParameterEnvironment,\n                                           typer: &Typer<'tcx>)\n                                           -> Result<(),Vec<FulfillmentError>>\n     {\n-        let tcx = infcx.tcx;\n         let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+        self.select(&mut selcx, false)\n+    }\n \n-        debug!(\"select_where_possible({} obligations) start\",\n-               self.trait_obligations.len());\n+    fn select(&mut self,\n+              selcx: &mut SelectionContext,\n+              only_new_obligations: bool)\n+              -> Result<(),Vec<FulfillmentError>>\n+    {\n+        /*!\n+         * Attempts to select obligations using `selcx`. If\n+         * `only_new_obligations` is true, then it only attempts to\n+         * select obligations that haven't been seen before.\n+         */\n+        debug!(\"select({} obligations, only_new_obligations={}) start\",\n+               self.trait_obligations.len(),\n+               only_new_obligations);\n \n+        let tcx = selcx.tcx();\n         let mut errors = Vec::new();\n \n         loop {\n@@ -96,30 +133,47 @@ impl FulfillmentContext {\n \n             let mut selections = Vec::new();\n \n+            // If we are only attempting obligations we haven't seen yet,\n+            // then set `skip` to the number of obligations we've already\n+            // seen.\n+            let mut skip = if only_new_obligations {\n+                self.attempted_mark\n+            } else {\n+                0\n+            };\n+\n             // First pass: walk each obligation, retaining\n             // only those that we cannot yet process.\n             self.trait_obligations.retain(|obligation| {\n-                match selcx.select(obligation) {\n-                    Ok(None) => {\n-                        true\n-                    }\n-                    Ok(Some(s)) => {\n-                        selections.push(s);\n-                        false\n-                    }\n-                    Err(selection_err) => {\n-                        debug!(\"obligation: {} error: {}\",\n-                               obligation.repr(tcx),\n-                               selection_err.repr(tcx));\n-\n-                        errors.push(FulfillmentError::new(\n-                            (*obligation).clone(),\n-                            CodeSelectionError(selection_err)));\n-                        false\n+                // Hack: Retain does not pass in the index, but we want\n+                // to avoid processing the first `start_count` entries.\n+                if skip > 0 {\n+                    skip -= 1;\n+                    true\n+                } else {\n+                    match selcx.select(obligation) {\n+                        Ok(None) => {\n+                            true\n+                        }\n+                        Ok(Some(s)) => {\n+                            selections.push(s);\n+                            false\n+                        }\n+                        Err(selection_err) => {\n+                            debug!(\"obligation: {} error: {}\",\n+                                   obligation.repr(tcx),\n+                                   selection_err.repr(tcx));\n+                            errors.push(FulfillmentError::new(\n+                                (*obligation).clone(),\n+                                CodeSelectionError(selection_err)));\n+                            false\n+                        }\n                     }\n                 }\n             });\n \n+            self.attempted_mark = self.trait_obligations.len();\n+\n             if self.trait_obligations.len() == count {\n                 // Nothing changed.\n                 break;\n@@ -133,7 +187,7 @@ impl FulfillmentContext {\n             }\n         }\n \n-        debug!(\"select_where_possible({} obligations, {} errors) done\",\n+        debug!(\"select({} obligations, {} errors) done\",\n                self.trait_obligations.len(),\n                errors.len());\n "}, {"sha": "82a3d1a523d3979ab6cc878ba46364900d5caf7c", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1da73ff12642182c9049630c3625f44f718c6c2f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da73ff12642182c9049630c3625f44f718c6c2f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1da73ff12642182c9049630c3625f44f718c6c2f", "patch": "@@ -88,7 +88,7 @@ use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n use middle::typeck::check::{impl_self_ty};\n-use middle::typeck::check::vtable::select_fcx_obligations_where_possible;\n+use middle::typeck::check::vtable::select_new_fcx_obligations;\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::{MethodCall, MethodCallee};\n@@ -1302,7 +1302,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // the `Self` trait).\n         let callee = self.confirm_candidate(rcvr_ty, &candidate);\n \n-        select_fcx_obligations_where_possible(self.fcx);\n+        select_new_fcx_obligations(self.fcx);\n \n         Some(Ok(callee))\n     }"}, {"sha": "53a4a8141e65c489e25d33de4aedd29a01c37328", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1da73ff12642182c9049630c3625f44f718c6c2f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da73ff12642182c9049630c3625f44f718c6c2f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1da73ff12642182c9049630c3625f44f718c6c2f", "patch": "@@ -101,7 +101,6 @@ use middle::typeck::check::method::{AutoderefReceiver};\n use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::CrateCtxt;\n-use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n use middle::typeck::rscope::RegionScope;\n use middle::typeck::{lookup_def_ccx};\n@@ -1412,7 +1411,7 @@ fn check_cast(fcx: &FnCtxt,\n         }\n         // casts from C-like enums are allowed\n     } else if t_1_is_char {\n-        let t_e = fcx.infcx().resolve_type_vars_if_possible(t_e);\n+        let t_e = fcx.infcx().shallow_resolve(t_e);\n         if ty::get(t_e).sty != ty::ty_uint(ast::TyU8) {\n             fcx.type_error_message(span, |actual| {\n                 format!(\"only `u8` can be cast as \\\n@@ -2564,7 +2563,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n         // an \"opportunistic\" vtable resolution of any trait\n         // bounds on the call.\n         if check_blocks {\n-            vtable::select_fcx_obligations_where_possible(fcx);\n+            vtable::select_new_fcx_obligations(fcx);\n         }\n \n         // For variadic functions, we don't have a declared type for all of\n@@ -2988,9 +2987,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // 'else' branch.\n         let expected = match expected.only_has_type() {\n             ExpectHasType(ety) => {\n-                match infer::resolve_type(fcx.infcx(), Some(sp), ety, force_tvar) {\n-                    Ok(rty) if !ty::type_is_ty_var(rty) => ExpectHasType(rty),\n-                    _ => NoExpectation\n+                let ety = fcx.infcx().shallow_resolve(ety);\n+                if !ty::type_is_ty_var(ety) {\n+                    ExpectHasType(ety)\n+                } else {\n+                    NoExpectation\n                 }\n             }\n             _ => NoExpectation\n@@ -4037,7 +4038,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n         check_expr(fcx, &**head);\n         let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n-        vtable::select_fcx_obligations_where_possible(fcx);\n+        vtable::select_new_fcx_obligations(fcx);\n \n         let pcx = pat_ctxt {\n             fcx: fcx,\n@@ -5393,18 +5394,32 @@ pub fn instantiate_path(fcx: &FnCtxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, tp: ty::t) -> ty::t {\n-    match infer::resolve_type(fcx.infcx(), Some(sp), tp, force_tvar) {\n-        Ok(t_s) if !ty::type_is_ty_var(t_s) => t_s,\n-        _ => {\n-            fcx.type_error_message(sp, |_actual| {\n-                \"the type of this value must be known in this \\\n-                 context\".to_string()\n-            }, tp, None);\n-            demand::suptype(fcx, sp, ty::mk_err(), tp);\n-            tp\n-        }\n+pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, mut ty: ty::t) -> ty::t {\n+    // If `ty` is a type variable, see whether we already know what it is.\n+    ty = fcx.infcx().shallow_resolve(ty);\n+\n+    // If not, try resolve pending fcx obligations. Those can shed light.\n+    //\n+    // FIXME(#18391) -- This current strategy can lead to bad performance in\n+    // extreme cases.  We probably ought to smarter in general about\n+    // only resolving when we need help and only resolving obligations\n+    // will actually help.\n+    if ty::type_is_ty_var(ty) {\n+        vtable::select_fcx_obligations_where_possible(fcx);\n+        ty = fcx.infcx().shallow_resolve(ty);\n     }\n+\n+    // If not, error.\n+    if ty::type_is_ty_var(ty) {\n+        fcx.type_error_message(sp, |_actual| {\n+            \"the type of this value must be known in this \\\n+             context\".to_string()\n+        }, ty, None);\n+        demand::suptype(fcx, sp, ty::mk_err(), ty);\n+        ty = ty::mk_err();\n+    }\n+\n+    ty\n }\n \n // Returns the one-level-deep structure of the given type."}, {"sha": "08a1e95fd90a1fd7aea5aa1a72c7487d59443b38", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1da73ff12642182c9049630c3625f44f718c6c2f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da73ff12642182c9049630c3625f44f718c6c2f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1da73ff12642182c9049630c3625f44f718c6c2f", "patch": "@@ -339,6 +339,24 @@ pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt) {\n     }\n }\n \n+pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n+    /*!\n+     * Try to select any fcx obligation that we haven't tried yet,\n+     * in an effort to improve inference. You could just call\n+     * `select_fcx_obligations_where_possible` except that it leads\n+     * to repeated work.\n+     */\n+\n+    match\n+        fcx.inh.fulfillment_cx\n+        .borrow_mut()\n+        .select_new_obligations(fcx.infcx(), &fcx.inh.param_env, fcx)\n+    {\n+        Ok(()) => { }\n+        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n+    }\n+}\n+\n fn note_obligation_cause(fcx: &FnCtxt,\n                          obligation: &Obligation) {\n     let tcx = fcx.tcx();"}]}