{"sha": "de9e964e4ac21897bd48adbe37f379d74422919f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlOWU5NjRlNGFjMjE4OTdiZDQ4YWRiZTM3ZjM3OWQ3NDQyMjkxOWY=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-25T16:42:12Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-25T16:42:12Z"}, "message": "Track import type outside of , use enum rather than bool to improve readability", "tree": {"sha": "75749d75444e360b89b3161623934e2f255ff643", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75749d75444e360b89b3161623934e2f255ff643"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de9e964e4ac21897bd48adbe37f379d74422919f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de9e964e4ac21897bd48adbe37f379d74422919f", "html_url": "https://github.com/rust-lang/rust/commit/de9e964e4ac21897bd48adbe37f379d74422919f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de9e964e4ac21897bd48adbe37f379d74422919f/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "html_url": "https://github.com/rust-lang/rust/commit/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf"}], "stats": {"total": 113, "additions": 73, "deletions": 40}, "files": [{"sha": "d749c828da018cade41d4240e3d2d47cd453df14", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de9e964e4ac21897bd48adbe37f379d74422919f/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9e964e4ac21897bd48adbe37f379d74422919f/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=de9e964e4ac21897bd48adbe37f379d74422919f", "patch": "@@ -26,7 +26,7 @@ use crate::{\n         dummy_expr_id, ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal,\n         LogicOp, MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n     },\n-    item_scope::BuiltinShadowMode,\n+    item_scope::{BuiltinShadowMode, ImportType},\n     item_tree::{FileItemTreeId, ItemTree, ItemTreeNode},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n@@ -81,6 +81,7 @@ pub(super) fn lower(\n             map\n         },\n         expander,\n+        import_types: FxHashMap::default(),\n     }\n     .collect(params, body)\n }\n@@ -93,6 +94,7 @@ struct ExprCollector<'a> {\n     source_map: BodySourceMap,\n \n     item_trees: FxHashMap<HirFileId, Arc<ItemTree>>,\n+    import_types: FxHashMap<Name, ImportType>,\n }\n \n impl ExprCollector<'_> {\n@@ -711,8 +713,10 @@ impl ExprCollector<'_> {\n                     _ => true,\n                 };\n                 self.body.item_scope.push_res(\n+                    &mut self.import_types,\n                     name.as_name(),\n                     crate::per_ns::PerNs::from_def(def, vis, has_constructor),\n+                    ImportType::Named,\n                 );\n             }\n         }"}, {"sha": "511c08a8d78bee5e369b714493c60651a6173241", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/de9e964e4ac21897bd48adbe37f379d74422919f/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9e964e4ac21897bd48adbe37f379d74422919f/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=de9e964e4ac21897bd48adbe37f379d74422919f", "patch": "@@ -12,6 +12,28 @@ use crate::{\n     Lookup, MacroDefId, ModuleDefId, TraitId,\n };\n \n+#[derive(Copy, Clone)]\n+pub(crate) enum ImportType {\n+    Glob,\n+    Named,\n+}\n+\n+impl ImportType {\n+    fn is_glob(&self) -> bool {\n+        match self {\n+            ImportType::Glob => true,\n+            ImportType::Named => false,\n+        }\n+    }\n+\n+    fn is_named(&self) -> bool {\n+        match self {\n+            ImportType::Glob => false,\n+            ImportType::Named => true,\n+        }\n+    }\n+}\n+\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n     visible: FxHashMap<Name, PerNs>,\n@@ -123,23 +145,30 @@ impl ItemScope {\n         self.legacy_macros.insert(name, mac);\n     }\n \n-    pub(crate) fn push_res(&mut self, name: Name, def: PerNs) -> bool {\n+    pub(crate) fn push_res(\n+        &mut self,\n+        existing_import_map: &mut FxHashMap<Name, ImportType>,\n+        name: Name,\n+        def: PerNs,\n+        def_import_type: ImportType,\n+    ) -> bool {\n         let mut changed = false;\n-        let existing = self.visible.entry(name).or_default();\n+        let existing = self.visible.entry(name.clone()).or_default();\n+        let existing_import_type = existing_import_map.entry(name).or_insert(def_import_type);\n \n         macro_rules! check_changed {\n-            ($changed:ident, ($existing:ident/$def:ident).$field:ident) => {\n+            ($changed:ident, ($existing:ident/$def:ident).$field:ident, $existing_import_type:ident, $def_import_type:ident) => {\n                 match ($existing.$field, $def.$field) {\n                     (None, Some(_)) => {\n-                        $existing.from_glob = $def.from_glob;\n+                        *existing_import_type = $def_import_type;\n                         $existing.$field = $def.$field;\n                         $changed = true;\n                     }\n-                    // Only update if the new def came from a specific import and the existing\n-                    // import came from a glob import.\n-                    (Some(_), Some(_)) if $existing.from_glob && !$def.from_glob => {\n+                    (Some(_), Some(_))\n+                        if $existing_import_type.is_glob() && $def_import_type.is_named() =>\n+                    {\n                         mark::hit!(import_shadowed);\n-                        $existing.from_glob = $def.from_glob;\n+                        *$existing_import_type = $def_import_type;\n                         $existing.$field = $def.$field;\n                         $changed = true;\n                     }\n@@ -148,9 +177,9 @@ impl ItemScope {\n             };\n         }\n \n-        check_changed!(changed, (existing / def).types);\n-        check_changed!(changed, (existing / def).values);\n-        check_changed!(changed, (existing / def).macros);\n+        check_changed!(changed, (existing / def).types, existing_import_type, def_import_type);\n+        check_changed!(changed, (existing / def).values, existing_import_type, def_import_type);\n+        check_changed!(changed, (existing / def).macros, existing_import_type, def_import_type);\n \n         changed\n     }"}, {"sha": "f7b99e0bef7b345746a7443b17acbc119926a540", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/de9e964e4ac21897bd48adbe37f379d74422919f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9e964e4ac21897bd48adbe37f379d74422919f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=de9e964e4ac21897bd48adbe37f379d74422919f", "patch": "@@ -20,6 +20,7 @@ use test_utils::mark;\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n+    item_scope::ImportType,\n     item_tree::{\n         self, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, Mod, ModItem, ModKind, StructDefKind,\n     },\n@@ -80,6 +81,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: CrateDefMap) -> Cr\n         mod_dirs: FxHashMap::default(),\n         cfg_options,\n         proc_macros,\n+        import_types: FxHashMap::default(),\n     };\n     collector.collect();\n     collector.finish()\n@@ -186,6 +188,7 @@ struct DefCollector<'a> {\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n     cfg_options: &'a CfgOptions,\n     proc_macros: Vec<(Name, ProcMacroExpander)>,\n+    import_types: FxHashMap<Name, ImportType>,\n }\n \n impl DefCollector<'_> {\n@@ -305,7 +308,7 @@ impl DefCollector<'_> {\n                 self.def_map.root,\n                 &[(name, PerNs::macros(macro_, Visibility::Public))],\n                 Visibility::Public,\n-                false,\n+                ImportType::Named,\n             );\n         }\n     }\n@@ -331,7 +334,7 @@ impl DefCollector<'_> {\n             self.def_map.root,\n             &[(name, PerNs::macros(macro_, Visibility::Public))],\n             Visibility::Public,\n-            false,\n+            ImportType::Named,\n         );\n     }\n \n@@ -478,7 +481,7 @@ impl DefCollector<'_> {\n                             .filter(|(_, res)| !res.is_none())\n                             .collect::<Vec<_>>();\n \n-                        self.update(module_id, &items, vis, true);\n+                        self.update(module_id, &items, vis, ImportType::Glob);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n@@ -500,7 +503,7 @@ impl DefCollector<'_> {\n                             .filter(|(_, res)| !res.is_none())\n                             .collect::<Vec<_>>();\n \n-                        self.update(module_id, &items, vis, true);\n+                        self.update(module_id, &items, vis, ImportType::Glob);\n                         // record the glob import in case we add further items\n                         let glob = self.glob_imports.entry(m.local_id).or_default();\n                         if !glob.iter().any(|(mid, _)| *mid == module_id) {\n@@ -530,7 +533,7 @@ impl DefCollector<'_> {\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, &resolutions, vis, true);\n+                    self.update(module_id, &resolutions, vis, ImportType::Glob);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -556,7 +559,7 @@ impl DefCollector<'_> {\n                         }\n                     }\n \n-                    self.update(module_id, &[(name, def)], vis, false);\n+                    self.update(module_id, &[(name, def)], vis, ImportType::Named);\n                 }\n                 None => mark::hit!(bogus_paths),\n             }\n@@ -568,9 +571,9 @@ impl DefCollector<'_> {\n         module_id: LocalModuleId,\n         resolutions: &[(Name, PerNs)],\n         vis: Visibility,\n-        is_from_glob: bool,\n+        import_type: ImportType,\n     ) {\n-        self.update_recursive(module_id, resolutions, vis, is_from_glob, 0)\n+        self.update_recursive(module_id, resolutions, vis, import_type, 0)\n     }\n \n     fn update_recursive(\n@@ -582,7 +585,7 @@ impl DefCollector<'_> {\n         vis: Visibility,\n         // All resolutions are imported with this glob status; the glob status\n         // in the `PerNs` values are ignored and overwritten\n-        is_from_glob: bool,\n+        import_type: ImportType,\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -592,8 +595,12 @@ impl DefCollector<'_> {\n         let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            changed |=\n-                scope.push_res(name.clone(), res.with_visibility(vis).from_glob(is_from_glob));\n+            changed |= scope.push_res(\n+                &mut self.import_types,\n+                name.clone(),\n+                res.with_visibility(vis),\n+                import_type,\n+            );\n         }\n \n         if !changed {\n@@ -616,7 +623,7 @@ impl DefCollector<'_> {\n                 glob_importing_module,\n                 resolutions,\n                 glob_import_vis,\n-                true,\n+                ImportType::Glob,\n                 depth + 1,\n             );\n         }\n@@ -940,7 +947,7 @@ impl ModCollector<'_, '_> {\n                         self.module_id,\n                         &[(name.clone(), PerNs::from_def(id, vis, has_constructor))],\n                         vis,\n-                        false,\n+                        ImportType::Named,\n                     )\n                 }\n             }\n@@ -1047,7 +1054,7 @@ impl ModCollector<'_, '_> {\n             self.module_id,\n             &[(name, PerNs::from_def(def, vis, false))],\n             vis,\n-            false,\n+            ImportType::Named,\n         );\n         res\n     }\n@@ -1177,6 +1184,7 @@ mod tests {\n             mod_dirs: FxHashMap::default(),\n             cfg_options: &CfgOptions::default(),\n             proc_macros: Default::default(),\n+            import_types: FxHashMap::default(),\n         };\n         collector.collect();\n         collector.def_map"}, {"sha": "74665c58851c909417bbd2efe9a24b180b1a39dc", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de9e964e4ac21897bd48adbe37f379d74422919f/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9e964e4ac21897bd48adbe37f379d74422919f/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=de9e964e4ac21897bd48adbe37f379d74422919f", "patch": "@@ -9,37 +9,36 @@ use crate::{item_scope::ItemInNs, visibility::Visibility, ModuleDefId};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct PerNs {\n-    pub from_glob: bool,\n     pub types: Option<(ModuleDefId, Visibility)>,\n     pub values: Option<(ModuleDefId, Visibility)>,\n     pub macros: Option<(MacroDefId, Visibility)>,\n }\n \n impl Default for PerNs {\n     fn default() -> Self {\n-        PerNs { from_glob: false, types: None, values: None, macros: None }\n+        PerNs { types: None, values: None, macros: None }\n     }\n }\n \n impl PerNs {\n     pub fn none() -> PerNs {\n-        PerNs { from_glob: false, types: None, values: None, macros: None }\n+        PerNs { types: None, values: None, macros: None }\n     }\n \n     pub fn values(t: ModuleDefId, v: Visibility) -> PerNs {\n-        PerNs { from_glob: false, types: None, values: Some((t, v)), macros: None }\n+        PerNs { types: None, values: Some((t, v)), macros: None }\n     }\n \n     pub fn types(t: ModuleDefId, v: Visibility) -> PerNs {\n-        PerNs { from_glob: false, types: Some((t, v)), values: None, macros: None }\n+        PerNs { types: Some((t, v)), values: None, macros: None }\n     }\n \n     pub fn both(types: ModuleDefId, values: ModuleDefId, v: Visibility) -> PerNs {\n-        PerNs { from_glob: false, types: Some((types, v)), values: Some((values, v)), macros: None }\n+        PerNs { types: Some((types, v)), values: Some((values, v)), macros: None }\n     }\n \n     pub fn macros(macro_: MacroDefId, v: Visibility) -> PerNs {\n-        PerNs { from_glob: false, types: None, values: None, macros: Some((macro_, v)) }\n+        PerNs { types: None, values: None, macros: Some((macro_, v)) }\n     }\n \n     pub fn is_none(&self) -> bool {\n@@ -64,7 +63,6 @@ impl PerNs {\n \n     pub fn filter_visibility(self, mut f: impl FnMut(Visibility) -> bool) -> PerNs {\n         PerNs {\n-            from_glob: self.from_glob,\n             types: self.types.filter(|(_, v)| f(*v)),\n             values: self.values.filter(|(_, v)| f(*v)),\n             macros: self.macros.filter(|(_, v)| f(*v)),\n@@ -73,7 +71,6 @@ impl PerNs {\n \n     pub fn with_visibility(self, vis: Visibility) -> PerNs {\n         PerNs {\n-            from_glob: self.from_glob,\n             types: self.types.map(|(it, _)| (it, vis)),\n             values: self.values.map(|(it, _)| (it, vis)),\n             macros: self.macros.map(|(it, _)| (it, vis)),\n@@ -82,7 +79,6 @@ impl PerNs {\n \n     pub fn or(self, other: PerNs) -> PerNs {\n         PerNs {\n-            from_glob: self.from_glob,\n             types: self.types.or(other.types),\n             values: self.values.or(other.values),\n             macros: self.macros.or(other.macros),\n@@ -96,8 +92,4 @@ impl PerNs {\n             .chain(self.values.map(|it| ItemInNs::Values(it.0)).into_iter())\n             .chain(self.macros.map(|it| ItemInNs::Macros(it.0)).into_iter())\n     }\n-\n-    pub fn from_glob(self, from_glob: bool) -> PerNs {\n-        PerNs { from_glob, ..self }\n-    }\n }"}]}