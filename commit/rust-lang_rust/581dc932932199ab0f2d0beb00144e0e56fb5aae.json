{"sha": "581dc932932199ab0f2d0beb00144e0e56fb5aae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MWRjOTMyOTMyMTk5YWIwZjJkMGJlYjAwMTQ0ZTBlNTZmYjVhYWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-30T16:11:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-30T16:11:09Z"}, "message": "Rollup merge of #44044 - mattico:string-splice-return, r=dtolnay\n\nRemove Splice struct return value from String::splice\n\nThe implementation is now almost identical to the one in the RFC.\n\nFixes #44038\ncc #32310", "tree": {"sha": "3b6aa580769ff61fcaeec354acbb36bffdb50398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b6aa580769ff61fcaeec354acbb36bffdb50398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/581dc932932199ab0f2d0beb00144e0e56fb5aae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/581dc932932199ab0f2d0beb00144e0e56fb5aae", "html_url": "https://github.com/rust-lang/rust/commit/581dc932932199ab0f2d0beb00144e0e56fb5aae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/581dc932932199ab0f2d0beb00144e0e56fb5aae/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca9cf3594ab25d2809ac576dfc9defb8e87b45b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca9cf3594ab25d2809ac576dfc9defb8e87b45b8", "html_url": "https://github.com/rust-lang/rust/commit/ca9cf3594ab25d2809ac576dfc9defb8e87b45b8"}, {"sha": "0c3c43c8005555f910b678b861ff4660c874199d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c3c43c8005555f910b678b861ff4660c874199d", "html_url": "https://github.com/rust-lang/rust/commit/0c3c43c8005555f910b678b861ff4660c874199d"}], "stats": {"total": 134, "additions": 25, "deletions": 109}, "files": [{"sha": "dae4475257a02988aafad92413e0eeb97f02c21d", "filename": "src/doc/unstable-book/src/library-features/splice.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/581dc932932199ab0f2d0beb00144e0e56fb5aae/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "raw_url": "https://github.com/rust-lang/rust/raw/581dc932932199ab0f2d0beb00144e0e56fb5aae/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md?ref=581dc932932199ab0f2d0beb00144e0e56fb5aae", "patch": "@@ -18,7 +18,6 @@ let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n \n // Replace the range up until the \u03b2 from the string\n-let t: String = s.splice(..beta_offset, \"\u0391 is capital alpha; \").collect();\n-assert_eq!(t, \"\u03b1 is alpha, \");\n+s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n ```\n\\ No newline at end of file"}, {"sha": "ddb23b2ef37bf0898d72db4e213d96b4fa70e5a5", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 19, "deletions": 90, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/581dc932932199ab0f2d0beb00144e0e56fb5aae/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/581dc932932199ab0f2d0beb00144e0e56fb5aae/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=581dc932932199ab0f2d0beb00144e0e56fb5aae", "patch": "@@ -1392,19 +1392,19 @@ impl String {\n     }\n \n     /// Creates a splicing iterator that removes the specified range in the string,\n-    /// replaces with the given string, and yields the removed chars.\n-    /// The given string doesn\u2019t need to be the same length as the range.\n+    /// and replaces it with the given string.\n+    /// The given string doesn't need to be the same length as the range.\n     ///\n-    /// Note: The element range is removed when the [`Splice`] is dropped,\n-    /// even if the iterator is not consumed until the end.\n+    /// Note: Unlike [`Vec::splice`], the replacement happens eagerly, and this\n+    /// method does not return the removed chars.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n     /// [`char`]: ../../std/primitive.char.html\n-    /// [`Splice`]: ../../std/string/struct.Splice.html\n+    /// [`Vec::splice`]: ../../std/vec/struct.Vec.html#method.splice\n     ///\n     /// # Examples\n     ///\n@@ -1416,45 +1416,32 @@ impl String {\n     /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n     ///\n     /// // Replace the range up until the \u03b2 from the string\n-    /// let t: String = s.splice(..beta_offset, \"\u0391 is capital alpha; \").collect();\n-    /// assert_eq!(t, \"\u03b1 is alpha, \");\n+    /// s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n     /// assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n     /// ```\n     #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-    pub fn splice<'a, 'b, R>(&'a mut self, range: R, replace_with: &'b str) -> Splice<'a, 'b>\n+    pub fn splice<R>(&mut self, range: R, replace_with: &str)\n         where R: RangeArgument<usize>\n     {\n         // Memory safety\n         //\n         // The String version of Splice does not have the memory safety issues\n         // of the vector version. The data is just plain bytes.\n-        // Because the range removal happens in Drop, if the Splice iterator is leaked,\n-        // the removal will not happen.\n-        let len = self.len();\n-        let start = match range.start() {\n-             Included(&n) => n,\n-             Excluded(&n) => n + 1,\n-             Unbounded => 0,\n+\n+        match range.start() {\n+             Included(&n) => assert!(self.is_char_boundary(n)),\n+             Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n+             Unbounded => {},\n         };\n-        let end = match range.end() {\n-             Included(&n) => n + 1,\n-             Excluded(&n) => n,\n-             Unbounded => len,\n+        match range.end() {\n+             Included(&n) => assert!(self.is_char_boundary(n + 1)),\n+             Excluded(&n) => assert!(self.is_char_boundary(n)),\n+             Unbounded => {},\n         };\n \n-        // Take out two simultaneous borrows. The &mut String won't be accessed\n-        // until iteration is over, in Drop.\n-        let self_ptr = self as *mut _;\n-        // slicing does the appropriate bounds checks\n-        let chars_iter = self[start..end].chars();\n-\n-        Splice {\n-            start,\n-            end,\n-            iter: chars_iter,\n-            string: self_ptr,\n-            replace_with,\n-        }\n+        unsafe {\n+            self.as_mut_vec()\n+        }.splice(range, replace_with.bytes());\n     }\n \n     /// Converts this `String` into a [`Box`]`<`[`str`]`>`.\n@@ -2241,61 +2228,3 @@ impl<'a> DoubleEndedIterator for Drain<'a> {\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a> FusedIterator for Drain<'a> {}\n-\n-/// A splicing iterator for `String`.\n-///\n-/// This struct is created by the [`splice()`] method on [`String`]. See its\n-/// documentation for more.\n-///\n-/// [`splice()`]: struct.String.html#method.splice\n-/// [`String`]: struct.String.html\n-#[derive(Debug)]\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-pub struct Splice<'a, 'b> {\n-    /// Will be used as &'a mut String in the destructor\n-    string: *mut String,\n-    /// Start of part to remove\n-    start: usize,\n-    /// End of part to remove\n-    end: usize,\n-    /// Current remaining range to remove\n-    iter: Chars<'a>,\n-    replace_with: &'b str,\n-}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-unsafe impl<'a, 'b> Sync for Splice<'a, 'b> {}\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-unsafe impl<'a, 'b> Send for Splice<'a, 'b> {}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-impl<'a, 'b> Drop for Splice<'a, 'b> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let vec = (*self.string).as_mut_vec();\n-            vec.splice(self.start..self.end, self.replace_with.bytes());\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-impl<'a, 'b> Iterator for Splice<'a, 'b> {\n-    type Item = char;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        self.iter.next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-impl<'a, 'b> DoubleEndedIterator for Splice<'a, 'b> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<char> {\n-        self.iter.next_back()\n-    }\n-}"}, {"sha": "6aba18ddf49ffe072f63a3641fa91140070d3f47", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/581dc932932199ab0f2d0beb00144e0e56fb5aae/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/581dc932932199ab0f2d0beb00144e0e56fb5aae/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=581dc932932199ab0f2d0beb00144e0e56fb5aae", "patch": "@@ -442,9 +442,8 @@ fn test_drain() {\n #[test]\n fn test_splice() {\n     let mut s = \"Hello, world!\".to_owned();\n-    let t: String = s.splice(7..12, \"\u4e16\u754c\").collect();\n+    s.splice(7..12, \"\u4e16\u754c\");\n     assert_eq!(s, \"Hello, \u4e16\u754c!\");\n-    assert_eq!(t, \"world\");\n }\n \n #[test]\n@@ -457,12 +456,10 @@ fn test_splice_char_boundary() {\n #[test]\n fn test_splice_inclusive_range() {\n     let mut v = String::from(\"12345\");\n-    let t: String = v.splice(2...3, \"789\").collect();\n+    v.splice(2...3, \"789\");\n     assert_eq!(v, \"127895\");\n-    assert_eq!(t, \"34\");\n-    let t2: String = v.splice(1...2, \"A\").collect();\n+    v.splice(1...2, \"A\");\n     assert_eq!(v, \"1A895\");\n-    assert_eq!(t2, \"27\");\n }\n \n #[test]\n@@ -482,24 +479,15 @@ fn test_splice_inclusive_out_of_bounds() {\n #[test]\n fn test_splice_empty() {\n     let mut s = String::from(\"12345\");\n-    let t: String = s.splice(1..2, \"\").collect();\n+    s.splice(1..2, \"\");\n     assert_eq!(s, \"1345\");\n-    assert_eq!(t, \"2\");\n }\n \n #[test]\n fn test_splice_unbounded() {\n     let mut s = String::from(\"12345\");\n-    let t: String = s.splice(.., \"\").collect();\n+    s.splice(.., \"\");\n     assert_eq!(s, \"\");\n-    assert_eq!(t, \"12345\");\n-}\n-\n-#[test]\n-fn test_splice_forget() {\n-    let mut s = String::from(\"12345\");\n-    ::std::mem::forget(s.splice(2..4, \"789\"));\n-    assert_eq!(s, \"12345\");\n }\n \n #[test]"}]}