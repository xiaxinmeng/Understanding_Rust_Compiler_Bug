{"sha": "bad3bf622bded50a97c0a54e29350eada2a3a169", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZDNiZjYyMmJkZWQ1MGE5N2MwYTU0ZTI5MzUwZWFkYTJhM2ExNjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-09T17:31:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-09T17:31:08Z"}, "message": "Auto merge of #72041 - RalfJung:rollup-xivrvy2, r=RalfJung\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #69406 (upgrade chalk and use chalk-solve/chalk-ir/chalk-rust-ir)\n - #71185 (Move tests from `test/run-fail` to UI)\n - #71234 (rustllvm: Use .init_array rather than .ctors)\n - #71508 (Simplify the `tcx.alloc_map` API)\n - #71555 (Remove ast::{Ident, Name} reexports.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0cfa645b6a4e35b9c1bd6d435f44ecc1f4e2ed19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cfa645b6a4e35b9c1bd6d435f44ecc1f4e2ed19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bad3bf622bded50a97c0a54e29350eada2a3a169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bad3bf622bded50a97c0a54e29350eada2a3a169", "html_url": "https://github.com/rust-lang/rust/commit/bad3bf622bded50a97c0a54e29350eada2a3a169", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bad3bf622bded50a97c0a54e29350eada2a3a169/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "html_url": "https://github.com/rust-lang/rust/commit/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3"}, {"sha": "366c1786e61d14a89cebd354b78ce6a68202b699", "url": "https://api.github.com/repos/rust-lang/rust/commits/366c1786e61d14a89cebd354b78ce6a68202b699", "html_url": "https://github.com/rust-lang/rust/commit/366c1786e61d14a89cebd354b78ce6a68202b699"}], "stats": {"total": 4985, "additions": 4111, "deletions": 874}, "files": [{"sha": "34d83e0d339a300276e3f4ac63ce0ee0203b7166", "filename": "Cargo.lock", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -429,6 +429,77 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"chalk-derive\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8d4620afad4d4d9e63f915cfa10c930b7a3c9c3ca5cd88dd771ff8e5bf04ea10\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n+ \"synstructure 0.12.1\",\n+]\n+\n+[[package]]\n+name = \"chalk-engine\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6ca6e5cef10197789da0b4ec310eda58da4c55530613b2323432642a97372735\"\n+dependencies = [\n+ \"chalk-macros\",\n+ \"rustc-hash\",\n+]\n+\n+[[package]]\n+name = \"chalk-ir\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d45df5fb6328527f976e8a32c9e1c9970084d937ebe93d0d34f5bbf4231cb956\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-engine\",\n+ \"chalk-macros\",\n+]\n+\n+[[package]]\n+name = \"chalk-macros\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9e4782d108e420a1fcf94d8a919cf248db33c5071678e87d9c2d4f20ed1feb32\"\n+dependencies = [\n+ \"lazy_static 1.4.0\",\n+]\n+\n+[[package]]\n+name = \"chalk-rust-ir\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a0ec96dbe0ab5fdbadfca4179ec2e1d35f0439c3b53a74988b1aec239c63eb08\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-engine\",\n+ \"chalk-ir\",\n+ \"chalk-macros\",\n+]\n+\n+[[package]]\n+name = \"chalk-solve\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dfb99fa9530f0e101475fb60adc931f51bdea05b4642a48928b814d7f0141a6b\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-engine\",\n+ \"chalk-ir\",\n+ \"chalk-macros\",\n+ \"chalk-rust-ir\",\n+ \"ena 0.13.1\",\n+ \"itertools 0.9.0\",\n+ \"petgraph\",\n+ \"rustc-hash\",\n+]\n+\n [[package]]\n name = \"chrono\"\n version = \"0.4.6\"\n@@ -1102,6 +1173,12 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"fixedbitset\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n+\n [[package]]\n name = \"flate2\"\n version = \"1.0.12\"\n@@ -2328,6 +2405,12 @@ dependencies = [\n  \"vcpkg\",\n ]\n \n+[[package]]\n+name = \"ordermap\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n+\n [[package]]\n name = \"ordslice\"\n version = \"0.3.0\"\n@@ -2496,6 +2579,16 @@ dependencies = [\n  \"sha-1\",\n ]\n \n+[[package]]\n+name = \"petgraph\"\n+version = \"0.4.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c3659d1ee90221741f65dd128d9998311b0e40c5d3c23a62445938214abce4f\"\n+dependencies = [\n+ \"fixedbitset\",\n+ \"ordermap\",\n+]\n+\n [[package]]\n name = \"phf\"\n version = \"0.7.24\"\n@@ -4002,6 +4095,7 @@ dependencies = [\n  \"arena\",\n  \"bitflags\",\n  \"byteorder\",\n+ \"chalk-ir\",\n  \"log\",\n  \"measureme\",\n  \"polonius-engine\",\n@@ -4132,7 +4226,6 @@ name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -4301,10 +4394,14 @@ dependencies = [\n name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n+ \"chalk-ir\",\n+ \"chalk-rust-ir\",\n+ \"chalk-solve\",\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_middle\",\n  \"rustc_span\","}, {"sha": "b0e06731330a182c16e78fb2497c412053315938", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -359,7 +359,6 @@ impl<'a> Builder<'a> {\n                 test::Tidy,\n                 test::Ui,\n                 test::CompileFail,\n-                test::RunFail,\n                 test::RunPassValgrind,\n                 test::MirOpt,\n                 test::Codegen,\n@@ -370,7 +369,6 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n-                test::RunFailPretty,\n                 test::RunPassValgrindPretty,\n                 test::Crate,\n                 test::CrateLibrustc,"}, {"sha": "d8c97fc741478fefa7556c54950ad569ed23a834", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -48,7 +48,6 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\\n \t\t$(AUX_ARGS) \\\n \t\t$(BOOTSTRAP_ARGS)"}, {"sha": "ad3fd0d64a307fcc6fc300481ea9dbe3b0403720", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -898,8 +898,6 @@ default_test!(CompileFail {\n     suite: \"compile-fail\"\n });\n \n-default_test!(RunFail { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" });\n-\n default_test!(RunPassValgrind {\n     path: \"src/test/run-pass-valgrind\",\n     mode: \"run-pass-valgrind\",\n@@ -929,13 +927,6 @@ host_test!(UiFullDeps { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-ful\n host_test!(Rustdoc { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" });\n \n host_test!(Pretty { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" });\n-test!(RunFailPretty {\n-    path: \"src/test/run-fail/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-fail\",\n-    default: false,\n-    host: true\n-});\n test!(RunPassValgrindPretty {\n     path: \"src/test/run-pass-valgrind/pretty\",\n     mode: \"pretty\","}, {"sha": "15bf4b70e2fdcb8c732f9bfb1b91bd3ce6840236", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -22,8 +22,6 @@ pub use crate::util::parser::ExprPrecedence;\n pub use GenericArgs::*;\n pub use UnsafeSource::*;\n \n-pub use rustc_span::symbol::{Ident, Symbol as Name};\n-\n use crate::ptr::P;\n use crate::token::{self, DelimToken};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n@@ -34,7 +32,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{self, Decoder, Encoder};\n use rustc_span::source_map::{respan, Spanned};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n use std::convert::TryFrom;\n@@ -2451,7 +2449,7 @@ pub enum ItemKind {\n     /// An `extern crate` item, with the optional *original* crate name if the crate was renamed.\n     ///\n     /// E.g., `extern crate foo` or `extern crate foo_bar as foo`.\n-    ExternCrate(Option<Name>),\n+    ExternCrate(Option<Symbol>),\n     /// A use declaration item (`use`).\n     ///\n     /// E.g., `use foo;`, `use foo::bar;` or `use foo::bar as FooBar;`."}, {"sha": "b812f2dadf6d40321e22740da1c7dad7047c3471", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,8 +3,8 @@\n use crate::ast;\n use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n use crate::ast::{Expr, GenericParam, Item, Lit, LitKind, Local, Stmt, StmtKind};\n-use crate::ast::{Ident, Name, Path, PathSegment};\n use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n+use crate::ast::{Path, PathSegment};\n use crate::mut_visit::visit_clobber;\n use crate::ptr::P;\n use crate::token::{self, Token};\n@@ -14,7 +14,7 @@ use rustc_data_structures::sync::Lock;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::edition::{Edition, DEFAULT_EDITION};\n use rustc_span::source_map::{BytePos, Spanned};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n use log::debug;\n@@ -113,7 +113,7 @@ impl NestedMetaItem {\n     }\n \n     /// Returns a name and single literal value tuple of the `MetaItem`.\n-    pub fn name_value_literal(&self) -> Option<(Name, &Lit)> {\n+    pub fn name_value_literal(&self) -> Option<(Symbol, &Lit)> {\n         self.meta_item().and_then(|meta_item| {\n             meta_item.meta_item_list().and_then(|meta_item_list| {\n                 if meta_item_list.len() == 1 {"}, {"sha": "d533aecf2df6b04d9ef91f04c4f7cf5c7adf648b", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -15,6 +15,7 @@ use crate::tokenstream::*;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::sync::Lrc;\n use rustc_span::source_map::{respan, Spanned};\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n use smallvec::{smallvec, Array, SmallVec};"}, {"sha": "a5b9c2a95bbea14074f4fbf7d03257bf65432cde", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n use rustc_span::symbol::kw;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::{fmt, mem};\n@@ -145,7 +145,7 @@ impl Lit {\n     }\n }\n \n-pub fn ident_can_begin_expr(name: ast::Name, span: Span, is_raw: bool) -> bool {\n+pub fn ident_can_begin_expr(name: Symbol, span: Span, is_raw: bool) -> bool {\n     let ident_token = Token::new(Ident(name, is_raw), span);\n \n     !ident_token.is_reserved_ident()\n@@ -173,7 +173,7 @@ pub fn ident_can_begin_expr(name: ast::Name, span: Span, is_raw: bool) -> bool {\n         .contains(&name)\n }\n \n-fn ident_can_begin_type(name: ast::Name, span: Span, is_raw: bool) -> bool {\n+fn ident_can_begin_type(name: Symbol, span: Span, is_raw: bool) -> bool {\n     let ident_token = Token::new(Ident(name, is_raw), span);\n \n     !ident_token.is_reserved_ident()\n@@ -229,18 +229,18 @@ pub enum TokenKind {\n     /// Do not forget about `NtIdent` when you want to match on identifiers.\n     /// It's recommended to use `Token::(ident,uninterpolate,uninterpolated_span)` to\n     /// treat regular and interpolated identifiers in the same way.\n-    Ident(ast::Name, /* is_raw */ bool),\n+    Ident(Symbol, /* is_raw */ bool),\n     /// Lifetime identifier token.\n     /// Do not forget about `NtLifetime` when you want to match on lifetime identifiers.\n     /// It's recommended to use `Token::(lifetime,uninterpolate,uninterpolated_span)` to\n     /// treat regular and interpolated lifetime identifiers in the same way.\n-    Lifetime(ast::Name),\n+    Lifetime(Symbol),\n \n     Interpolated(Lrc<Nonterminal>),\n \n     // Can be expanded into several tokens.\n     /// A doc comment.\n-    DocComment(ast::Name),\n+    DocComment(Symbol),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for\n@@ -249,9 +249,9 @@ pub enum TokenKind {\n     Whitespace,\n     /// A comment.\n     Comment,\n-    Shebang(ast::Name),\n+    Shebang(Symbol),\n     /// A completely invalid token which should be skipped.\n-    Unknown(ast::Name),\n+    Unknown(Symbol),\n \n     Eof,\n }\n@@ -325,8 +325,8 @@ impl Token {\n         Token::new(TokenKind::Whitespace, DUMMY_SP)\n     }\n \n-    /// Recovers a `Token` from an `ast::Ident`. This creates a raw identifier if necessary.\n-    pub fn from_ast_ident(ident: ast::Ident) -> Self {\n+    /// Recovers a `Token` from an `Ident`. This creates a raw identifier if necessary.\n+    pub fn from_ast_ident(ident: Ident) -> Self {\n         Token::new(Ident(ident.name, ident.is_raw_guess()), ident.span)\n     }\n \n@@ -488,19 +488,19 @@ impl Token {\n     }\n \n     /// Returns an identifier if this token is an identifier.\n-    pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n+    pub fn ident(&self) -> Option<(Ident, /* is_raw */ bool)> {\n         let token = self.uninterpolate();\n         match token.kind {\n-            Ident(name, is_raw) => Some((ast::Ident::new(name, token.span), is_raw)),\n+            Ident(name, is_raw) => Some((Ident::new(name, token.span), is_raw)),\n             _ => None,\n         }\n     }\n \n     /// Returns a lifetime identifier if this token is a lifetime.\n-    pub fn lifetime(&self) -> Option<ast::Ident> {\n+    pub fn lifetime(&self) -> Option<Ident> {\n         let token = self.uninterpolate();\n         match token.kind {\n-            Lifetime(name) => Some(ast::Ident::new(name, token.span)),\n+            Lifetime(name) => Some(Ident::new(name, token.span)),\n             _ => None,\n         }\n     }\n@@ -577,28 +577,28 @@ impl Token {\n     }\n \n     pub fn is_path_segment_keyword(&self) -> bool {\n-        self.is_non_raw_ident_where(ast::Ident::is_path_segment_keyword)\n+        self.is_non_raw_ident_where(Ident::is_path_segment_keyword)\n     }\n \n     // Returns true for reserved identifiers used internally for elided lifetimes,\n     // unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special_ident(&self) -> bool {\n-        self.is_non_raw_ident_where(ast::Ident::is_special)\n+        self.is_non_raw_ident_where(Ident::is_special)\n     }\n \n     /// Returns `true` if the token is a keyword used in the language.\n     pub fn is_used_keyword(&self) -> bool {\n-        self.is_non_raw_ident_where(ast::Ident::is_used_keyword)\n+        self.is_non_raw_ident_where(Ident::is_used_keyword)\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_unused_keyword(&self) -> bool {\n-        self.is_non_raw_ident_where(ast::Ident::is_unused_keyword)\n+        self.is_non_raw_ident_where(Ident::is_unused_keyword)\n     }\n \n     /// Returns `true` if the token is either a special identifier or a keyword.\n     pub fn is_reserved_ident(&self) -> bool {\n-        self.is_non_raw_ident_where(ast::Ident::is_reserved)\n+        self.is_non_raw_ident_where(Ident::is_reserved)\n     }\n \n     /// Returns `true` if the token is the identifier `true` or `false`.\n@@ -607,7 +607,7 @@ impl Token {\n     }\n \n     /// Returns `true` if the token is a non-raw identifier for which `pred` holds.\n-    pub fn is_non_raw_ident_where(&self, pred: impl FnOnce(ast::Ident) -> bool) -> bool {\n+    pub fn is_non_raw_ident_where(&self, pred: impl FnOnce(Ident) -> bool) -> bool {\n         match self.ident() {\n             Some((id, false)) => pred(id),\n             _ => false,\n@@ -746,8 +746,8 @@ pub enum Nonterminal {\n     NtPat(P<ast::Pat>),\n     NtExpr(P<ast::Expr>),\n     NtTy(P<ast::Ty>),\n-    NtIdent(ast::Ident, /* is_raw */ bool),\n-    NtLifetime(ast::Ident),\n+    NtIdent(Ident, /* is_raw */ bool),\n+    NtLifetime(Ident),\n     NtLiteral(P<ast::Expr>),\n     /// Stuff inside brackets for attributes\n     NtMeta(P<ast::AttrItem>),"}, {"sha": "63f483663bfa6a24b2cb309167fddc34cb88bb4d", "filename": "src/librustc_ast/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fvisit.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -17,6 +17,7 @@ use crate::ast::*;\n use crate::token::Token;\n use crate::tokenstream::{TokenStream, TokenTree};\n \n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -74,7 +75,7 @@ impl<'a> FnKind<'a> {\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'ast>: Sized {\n-    fn visit_name(&mut self, _span: Span, _name: Name) {\n+    fn visit_name(&mut self, _span: Span, _name: Symbol) {\n         // Nothing to do.\n     }\n     fn visit_ident(&mut self, ident: Ident) {"}, {"sha": "8da3aa633b85fb0c4b058c88e16a268bde194873", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -9,7 +9,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {"}, {"sha": "eced17c9245f2480dc67ca0b76f89dc960ad5066", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -12,7 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::LocalDefId;\n use rustc_span::source_map::{respan, DesugaringKind};\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n "}, {"sha": "7e6dfbf00f591e41a76a9909bd425f09bb085e7b", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -63,7 +63,7 @@ use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n use log::{debug, trace};"}, {"sha": "496e401d06124f789eb0fcb3866e4a7e70d14fd2", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -5,6 +5,7 @@ use rustc_ast::ptr::P;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n+use rustc_span::symbol::Ident;\n use rustc_span::{source_map::Spanned, Span};\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {"}, {"sha": "e5ce51f8d2d1f45152badd12dc5915d52fefd8dc", "filename": "src/librustc_ast_lowering/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -9,6 +9,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n use rustc_session::lint::builtin::ELIDED_LIFETIMES_IN_PATHS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n use log::debug;"}, {"sha": "46c415413e92b687f826147bb56445e717719a94", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -20,7 +20,7 @@ use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY;\n use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use std::mem;\n use std::ops::DerefMut;"}, {"sha": "ffd741a7b37b02888675d7eed26ccebdfeaee2aa", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -7,7 +7,7 @@ use rustc_feature::{AttributeGate, BUILTIN_ATTRIBUTE_MAP};\n use rustc_feature::{Features, GateIssue, UnstableFeatures};\n use rustc_session::parse::{feature_err, feature_err_issue, ParseSess};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n use log::debug;\n@@ -252,7 +252,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n+    fn visit_name(&mut self, sp: Span, name: Symbol) {\n         if !name.as_str().is_ascii() {\n             gate_feature_post!(\n                 &self,"}, {"sha": "3cf562b927e2e4b0199c7eec229159da0aa827dc", "filename": "src/librustc_ast_passes/node_count.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_passes%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_passes%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fnode_count.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2,6 +2,7 @@\n \n use rustc_ast::ast::*;\n use rustc_ast::visit::*;\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n pub struct NodeCounter {"}, {"sha": "e6803fdd7f1578046256ec3611320000aa690d70", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::util::{classify, comments};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n-use rustc_span::symbol::{kw, sym, IdentPrinter};\n+use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n use rustc_span::{BytePos, FileName, Span};\n \n use std::borrow::Cow;\n@@ -26,8 +26,8 @@ pub enum MacHeader<'a> {\n }\n \n pub enum AnnNode<'a> {\n-    Ident(&'a ast::Ident),\n-    Name(&'a ast::Name),\n+    Ident(&'a Ident),\n+    Name(&'a Symbol),\n     Block(&'a ast::Block),\n     Item(&'a ast::Item),\n     SubItem(ast::NodeId),\n@@ -118,16 +118,16 @@ pub fn print_crate<'a>(\n         // of the feature gate, so we fake them up here.\n \n         // `#![feature(prelude_import)]`\n-        let pi_nested = attr::mk_nested_word_item(ast::Ident::with_dummy_span(sym::prelude_import));\n-        let list = attr::mk_list_item(ast::Ident::with_dummy_span(sym::feature), vec![pi_nested]);\n+        let pi_nested = attr::mk_nested_word_item(Ident::with_dummy_span(sym::prelude_import));\n+        let list = attr::mk_list_item(Ident::with_dummy_span(sym::feature), vec![pi_nested]);\n         let fake_attr = attr::mk_attr_inner(list);\n         s.print_attribute(&fake_attr);\n \n         // Currently, in Rust 2018 we don't have `extern crate std;` at the crate\n         // root, so this is not needed, and actually breaks things.\n         if edition == Edition::Edition2015 {\n             // `#![no_std]`\n-            let no_std_meta = attr::mk_word_item(ast::Ident::with_dummy_span(sym::no_std));\n+            let no_std_meta = attr::mk_word_item(Ident::with_dummy_span(sym::no_std));\n             let fake_attr = attr::mk_attr_inner(no_std_meta);\n             s.print_attribute(&fake_attr);\n         }\n@@ -389,7 +389,7 @@ impl std::ops::DerefMut for State<'_> {\n \n pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::DerefMut {\n     fn comments(&mut self) -> &mut Option<Comments<'a>>;\n-    fn print_ident(&mut self, ident: ast::Ident);\n+    fn print_ident(&mut self, ident: Ident);\n     fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool);\n \n     fn strsep<T, F>(\n@@ -671,7 +671,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         &mut self,\n         header: Option<MacHeader<'_>>,\n         has_bang: bool,\n-        ident: Option<ast::Ident>,\n+        ident: Option<Ident>,\n         delim: DelimToken,\n         tts: TokenStream,\n         convert_dollar_crate: bool,\n@@ -782,7 +782,7 @@ impl<'a> PrintState<'a> for State<'a> {\n         &mut self.comments\n     }\n \n-    fn print_ident(&mut self, ident: ast::Ident) {\n+    fn print_ident(&mut self, ident: Ident) {\n         self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n@@ -1001,7 +1001,7 @@ impl<'a> State<'a> {\n \n     fn print_item_const(\n         &mut self,\n-        ident: ast::Ident,\n+        ident: Ident,\n         mutbl: Option<ast::Mutability>,\n         ty: &ast::Ty,\n         body: Option<&ast::Expr>,\n@@ -1032,7 +1032,7 @@ impl<'a> State<'a> {\n \n     fn print_associated_type(\n         &mut self,\n-        ident: ast::Ident,\n+        ident: Ident,\n         generics: &ast::Generics,\n         bounds: &ast::GenericBounds,\n         ty: Option<&ast::Ty>,\n@@ -1281,7 +1281,7 @@ impl<'a> State<'a> {\n         &mut self,\n         enum_definition: &ast::EnumDef,\n         generics: &ast::Generics,\n-        ident: ast::Ident,\n+        ident: Ident,\n         span: rustc_span::Span,\n         visibility: &ast::Visibility,\n     ) {\n@@ -1337,7 +1337,7 @@ impl<'a> State<'a> {\n         &mut self,\n         struct_def: &ast::VariantData,\n         generics: &ast::Generics,\n-        ident: ast::Ident,\n+        ident: Ident,\n         span: rustc_span::Span,\n         print_finalizer: bool,\n     ) {\n@@ -2116,7 +2116,7 @@ impl<'a> State<'a> {\n         self.s.word(i.to_string())\n     }\n \n-    crate fn print_name(&mut self, name: ast::Name) {\n+    crate fn print_name(&mut self, name: Symbol) {\n         self.s.word(name.to_string());\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n@@ -2322,7 +2322,7 @@ impl<'a> State<'a> {\n     fn print_fn_full(\n         &mut self,\n         sig: &ast::FnSig,\n-        name: ast::Ident,\n+        name: Ident,\n         generics: &ast::Generics,\n         vis: &ast::Visibility,\n         defaultness: ast::Defaultness,\n@@ -2347,7 +2347,7 @@ impl<'a> State<'a> {\n         &mut self,\n         decl: &ast::FnDecl,\n         header: ast::FnHeader,\n-        name: Option<ast::Ident>,\n+        name: Option<Ident>,\n         generics: &ast::Generics,\n     ) {\n         self.print_fn_header_info(header);\n@@ -2614,7 +2614,7 @@ impl<'a> State<'a> {\n         ext: ast::Extern,\n         unsafety: ast::Unsafe,\n         decl: &ast::FnDecl,\n-        name: Option<ast::Ident>,\n+        name: Option<Ident>,\n         generic_params: &[ast::GenericParam],\n     ) {\n         self.ibox(INDENT_UNIT);"}, {"sha": "f51439f89ffbe9a5f2cfcba73294339095e0eb0b", "filename": "src/librustc_ast_pretty/pprust/tests.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -4,11 +4,12 @@ use rustc_ast::ast;\n use rustc_ast::with_default_globals;\n use rustc_span;\n use rustc_span::source_map::respan;\n+use rustc_span::symbol::Ident;\n \n fn fun_to_string(\n     decl: &ast::FnDecl,\n     header: ast::FnHeader,\n-    name: ast::Ident,\n+    name: Ident,\n     generics: &ast::Generics,\n ) -> String {\n     to_string(|s| {\n@@ -26,7 +27,7 @@ fn variant_to_string(var: &ast::Variant) -> String {\n #[test]\n fn test_fun_to_string() {\n     with_default_globals(|| {\n-        let abba_ident = ast::Ident::from_str(\"abba\");\n+        let abba_ident = Ident::from_str(\"abba\");\n \n         let decl =\n             ast::FnDecl { inputs: Vec::new(), output: ast::FnRetTy::Default(rustc_span::DUMMY_SP) };\n@@ -41,7 +42,7 @@ fn test_fun_to_string() {\n #[test]\n fn test_variant_to_string() {\n     with_default_globals(|| {\n-        let ident = ast::Ident::from_str(\"principal_skinner\");\n+        let ident = Ident::from_str(\"principal_skinner\");\n \n         let var = ast::Variant {\n             ident,"}, {"sha": "166cd628350304720538dd74c9202585502095bf", "filename": "src/librustc_builtin_macros/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fassert.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::*;\n use rustc_parse::parser::Parser;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n pub fn expand_assert<'cx>("}, {"sha": "8a1741c0654660347b40fc71607b3db784d3f8b2", "filename": "src/librustc_builtin_macros/concat_idents.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fconcat_idents.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_expand::base::{self, *};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_concat_idents<'cx>(\n@@ -39,10 +39,10 @@ pub fn expand_concat_idents<'cx>(\n         }\n     }\n \n-    let ident = ast::Ident::new(Symbol::intern(&res_str), cx.with_call_site_ctxt(sp));\n+    let ident = Ident::new(Symbol::intern(&res_str), cx.with_call_site_ctxt(sp));\n \n     struct ConcatIdentsResult {\n-        ident: ast::Ident,\n+        ident: Ident,\n     }\n \n     impl base::MacResult for ConcatIdentsResult {"}, {"sha": "5dbf3825ce6930139a38e0163f274682350f39f2", "filename": "src/librustc_builtin_macros/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -5,7 +5,7 @@ use crate::deriving::path_std;\n use rustc_ast::ast::{self, Expr, GenericArg, Generics, ItemKind, MetaItem, VariantData};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_clone(\n@@ -135,8 +135,7 @@ fn cs_clone_shallow(\n     let mut stmts = Vec::new();\n     if is_union {\n         // let _: AssertParamIsCopy<Self>;\n-        let self_ty =\n-            cx.ty_path(cx.path_ident(trait_span, ast::Ident::with_dummy_span(kw::SelfUpper)));\n+        let self_ty = cx.ty_path(cx.path_ident(trait_span, Ident::with_dummy_span(kw::SelfUpper)));\n         assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n     } else {\n         match *substr.fields {"}, {"sha": "b3b15b897828a6adfa9846f2d8ecbae6edc6d6a3", "filename": "src/librustc_builtin_macros/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2,10 +2,10 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ast::{self, Expr, GenericArg, Ident, MetaItem};\n+use rustc_ast::ast::{self, Expr, GenericArg, MetaItem};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_eq("}, {"sha": "030d2c837428ba915bb3710eba7513ea86b0b511", "filename": "src/librustc_builtin_macros/deriving/cmp/ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -5,7 +5,7 @@ use crate::deriving::path_std;\n use rustc_ast::ast::{self, Expr, MetaItem};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n pub fn expand_deriving_ord(\n@@ -45,15 +45,15 @@ pub fn expand_deriving_ord(\n pub fn ordering_collapsed(\n     cx: &mut ExtCtxt<'_>,\n     span: Span,\n-    self_arg_tags: &[ast::Ident],\n+    self_arg_tags: &[Ident],\n ) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    cx.expr_method_call(span, lft, ast::Ident::new(sym::cmp, span), vec![rgt])\n+    cx.expr_method_call(span, lft, Ident::new(sym::cmp, span), vec![rgt])\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let test_id = ast::Ident::new(sym::cmp, span);\n+    let test_id = Ident::new(sym::cmp, span);\n     let equals_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n \n     let cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);"}, {"sha": "f29f91e82312befde7d93c190d569e1caa421b26", "filename": "src/librustc_builtin_macros/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -7,7 +7,7 @@ use crate::deriving::{path_local, path_std, pathvec_std};\n use rustc_ast::ast::{self, BinOpKind, Expr, MetaItem};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_partial_ord(\n@@ -104,7 +104,7 @@ pub fn some_ordering_collapsed(\n     cx: &mut ExtCtxt<'_>,\n     span: Span,\n     op: OrderingOp,\n-    self_arg_tags: &[ast::Ident],\n+    self_arg_tags: &[Ident],\n ) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n@@ -119,7 +119,7 @@ pub fn some_ordering_collapsed(\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let test_id = ast::Ident::new(sym::cmp, span);\n+    let test_id = Ident::new(sym::cmp, span);\n     let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n     let equals_expr = cx.expr_some(span, ordering_expr);"}, {"sha": "99c2b6f8a4eac38dfba90b50d999f303c342fd80", "filename": "src/librustc_builtin_macros/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2,11 +2,11 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ast::{self, Ident};\n+use rustc_ast::ast;\n use rustc_ast::ast::{Expr, MetaItem};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n \n pub fn expand_deriving_debug("}, {"sha": "0ba9df08383a4ab70d0d09386f0878584a58b5f2", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -181,15 +181,15 @@ use std::cell::RefCell;\n use std::iter;\n use std::vec;\n \n-use rustc_ast::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n+use rustc_ast::ast::{self, BinOpKind, EnumDef, Expr, Generics, PatKind};\n use rustc_ast::ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_ast::ptr::P;\n use rustc_attr as attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::respan;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n use ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n@@ -222,7 +222,7 @@ pub struct TraitDef<'a> {\n \n     pub methods: Vec<MethodDef<'a>>,\n \n-    pub associated_types: Vec<(ast::Ident, Ty<'a>)>,\n+    pub associated_types: Vec<(Ident, Ty<'a>)>,\n }\n \n pub struct MethodDef<'a> {\n@@ -336,14 +336,14 @@ pub fn combine_substructure(\n /// is not global and starts with `T`, or a `TyQPath`.\n fn find_type_parameters(\n     ty: &ast::Ty,\n-    ty_param_names: &[ast::Name],\n+    ty_param_names: &[Symbol],\n     cx: &ExtCtxt<'_>,\n ) -> Vec<P<ast::Ty>> {\n     use rustc_ast::visit;\n \n     struct Visitor<'a, 'b> {\n         cx: &'a ExtCtxt<'b>,\n-        ty_param_names: &'a [ast::Name],\n+        ty_param_names: &'a [Symbol],\n         types: Vec<P<ast::Ty>>,\n     }\n \n@@ -620,7 +620,7 @@ impl<'a> TraitDef<'a> {\n                 .peekable();\n \n             if ty_params.peek().is_some() {\n-                let ty_param_names: Vec<ast::Name> =\n+                let ty_param_names: Vec<Symbol> =\n                     ty_params.map(|ty_param| ty_param.ident.name).collect();\n \n                 for field_ty in field_tys {\n@@ -1223,7 +1223,7 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<String>>();\n \n         let self_arg_idents =\n-            self_arg_names.iter().map(|name| cx.ident_of(name, sp)).collect::<Vec<ast::Ident>>();\n+            self_arg_names.iter().map(|name| cx.ident_of(name, sp)).collect::<Vec<Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to an int\n@@ -1234,7 +1234,7 @@ impl<'a> MethodDef<'a> {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n                 cx.ident_of(&vi_suffix[..], trait_.span)\n             })\n-            .collect::<Vec<ast::Ident>>();\n+            .collect::<Vec<Ident>>();\n \n         // Builds, via callback to call_substructure_method, the\n         // delegated expression that handles the catch-all case,\n@@ -1598,7 +1598,7 @@ impl<'a> TraitDef<'a> {\n     fn create_subpatterns(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        field_paths: Vec<ast::Ident>,\n+        field_paths: Vec<Ident>,\n         mutbl: ast::Mutability,\n         use_temporaries: bool,\n     ) -> Vec<P<ast::Pat>> {\n@@ -1670,7 +1670,7 @@ impl<'a> TraitDef<'a> {\n     fn create_enum_variant_pattern(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        enum_ident: ast::Ident,\n+        enum_ident: Ident,\n         variant: &'a ast::Variant,\n         prefix: &str,\n         mutbl: ast::Mutability,"}, {"sha": "62cbdb19a8894e0700b66cefdef55af657b28a0f", "filename": "src/librustc_builtin_macros/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -4,11 +4,11 @@\n pub use PtrTy::*;\n pub use Ty::*;\n \n-use rustc_ast::ast::{self, Expr, GenericArg, GenericParamKind, Generics, Ident, SelfKind};\n+use rustc_ast::ast::{self, Expr, GenericArg, GenericParamKind, Generics, SelfKind};\n use rustc_ast::ptr::P;\n use rustc_expand::base::ExtCtxt;\n use rustc_span::source_map::{respan, DUMMY_SP};\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n /// The types of pointers"}, {"sha": "9660cade3824115cd58565a4e29564fc6eb82b60", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,7 +3,7 @@\n use rustc_ast::ast::{self, ItemKind, MetaItem};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n macro path_local($x:ident) {\n@@ -154,7 +154,7 @@ fn inject_impl_of_structural_trait(\n \n     let newitem = cx.item(\n         span,\n-        ast::Ident::invalid(),\n+        Ident::invalid(),\n         attrs,\n         ItemKind::Impl {\n             unsafety: ast::Unsafe::No,"}, {"sha": "21e1889513b01457049ba6287c2e25fa9c117a23", "filename": "src/librustc_builtin_macros/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fenv.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,10 +3,10 @@\n // interface.\n //\n \n-use rustc_ast::ast::{self, GenericArg, Ident};\n+use rustc_ast::ast::{self, GenericArg};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_expand::base::{self, *};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n use std::env;"}, {"sha": "efce62881985ef68e760241f327a59661fdaeeed", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -10,7 +10,7 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, Applicability, DiagnosticBuilder};\n use rustc_expand::base::{self, *};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span};\n \n use std::borrow::Cow;\n@@ -535,7 +535,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.count_args_index_offset = sofar;\n     }\n \n-    fn rtpath(ecx: &ExtCtxt<'_>, s: &str) -> Vec<ast::Ident> {\n+    fn rtpath(ecx: &ExtCtxt<'_>, s: &str) -> Vec<Ident> {\n         ecx.std_path(&[sym::fmt, sym::rt, sym::v1, Symbol::intern(s)])\n     }\n \n@@ -794,7 +794,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         macsp: Span,\n         mut sp: Span,\n         ty: &ArgumentType,\n-        arg: ast::Ident,\n+        arg: Ident,\n     ) -> P<ast::Expr> {\n         sp = ecx.with_def_site_ctxt(sp);\n         let arg = ecx.expr_ident(sp, arg);"}, {"sha": "feda17c1812cb2a5baa280b2912cb3822dccc878", "filename": "src/librustc_builtin_macros/global_allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,13 +1,13 @@\n use crate::util::check_builtin_macro_attribute;\n \n-use rustc_ast::ast::{self, Attribute, Expr, FnHeader, FnSig, Generics, Ident, Param};\n+use rustc_ast::ast::{self, Attribute, Expr, FnHeader, FnSig, Generics, Param};\n use rustc_ast::ast::{ItemKind, Mutability, Stmt, Ty, TyKind, Unsafe};\n use rustc_ast::expand::allocator::{\n     AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS,\n };\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand("}, {"sha": "2729239f62b9086953bb62f541eb9c478674cee5", "filename": "src/librustc_builtin_macros/global_asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_asm.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -15,6 +15,7 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_errors::DiagnosticBuilder;\n use rustc_expand::base::{self, *};\n use rustc_span::source_map::respan;\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use smallvec::smallvec;\n \n@@ -25,7 +26,7 @@ pub fn expand_global_asm<'cx>(\n ) -> Box<dyn base::MacResult + 'cx> {\n     match parse_global_asm(cx, sp, tts) {\n         Ok(Some(global_asm)) => MacEager::items(smallvec![P(ast::Item {\n-            ident: ast::Ident::invalid(),\n+            ident: Ident::invalid(),\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n             kind: ast::ItemKind::GlobalAsm(P(global_asm)),"}, {"sha": "cc77bb73c5ae14fb6afd1b1cc173ad86043669bb", "filename": "src/librustc_builtin_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Flib.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -14,11 +14,10 @@ extern crate proc_macro;\n \n use crate::deriving::*;\n \n-use rustc_ast::ast::Ident;\n use rustc_expand::base::{MacroExpanderFn, Resolver, SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::BangProcMacro;\n use rustc_span::edition::Edition;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Ident};\n \n mod assert;\n mod cfg;"}, {"sha": "adaf5f03079eb061096323c8bb36679d4be6ff3c", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-use rustc_ast::ast::{self, Ident, NodeId};\n+use rustc_ast::ast::{self, NodeId};\n use rustc_ast::attr;\n use rustc_ast::expand::is_proc_macro_attr;\n use rustc_ast::ptr::P;\n@@ -11,17 +11,17 @@ use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_session::parse::ParseSess;\n use rustc_span::hygiene::AstPass;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::smallvec;\n use std::cell::RefCell;\n \n struct ProcMacroDerive {\n     id: NodeId,\n-    trait_name: ast::Name,\n+    trait_name: Symbol,\n     function_name: Ident,\n     span: Span,\n-    attrs: Vec<ast::Name>,\n+    attrs: Vec<Symbol>,\n }\n \n enum ProcMacroDefType {\n@@ -480,7 +480,7 @@ fn mk_decls(\n \n     let anon_constant = cx.item_const(\n         span,\n-        ast::Ident::new(kw::Underscore, span),\n+        Ident::new(kw::Underscore, span),\n         cx.ty(span, ast::TyKind::Tup(Vec::new())),\n         block,\n     );"}, {"sha": "cd3773c76c483ec5dcfaa968f81a5f4b9a9ef3f2", "filename": "src/librustc_builtin_macros/standard_library_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -60,17 +60,17 @@ pub fn inject(\n     let name = names[0];\n \n     let import_path = if rust_2018 {\n-        [name, sym::prelude, sym::v1].iter().map(|symbol| ast::Ident::new(*symbol, span)).collect()\n+        [name, sym::prelude, sym::v1].iter().map(|symbol| Ident::new(*symbol, span)).collect()\n     } else {\n         [kw::PathRoot, name, sym::prelude, sym::v1]\n             .iter()\n-            .map(|symbol| ast::Ident::new(*symbol, span))\n+            .map(|symbol| Ident::new(*symbol, span))\n             .collect()\n     };\n \n     let use_item = cx.item(\n         span,\n-        ast::Ident::invalid(),\n+        Ident::invalid(),\n         vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n         ast::ItemKind::Use(P(ast::UseTree {\n             prefix: cx.path(span, import_path),"}, {"sha": "d62f34bab1a31e41685071989d2a4160de90b709", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::attr;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::*;\n use rustc_span::source_map::respan;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n use std::iter;\n@@ -105,7 +105,7 @@ pub fn expand_test_or_bench(\n \n     let (sp, attr_sp) = (cx.with_def_site_ctxt(item.span), cx.with_def_site_ctxt(attr_sp));\n \n-    let test_id = ast::Ident::new(sym::test, attr_sp);\n+    let test_id = Ident::new(sym::test, attr_sp);\n \n     // creates test::$name\n     let test_path = |name| cx.path(sp, vec![test_id, cx.ident_of(name, sp)]);\n@@ -172,12 +172,12 @@ pub fn expand_test_or_bench(\n \n     let mut test_const = cx.item(\n         sp,\n-        ast::Ident::new(item.ident.name, sp),\n+        Ident::new(item.ident.name, sp),\n         vec![\n             // #[cfg(test)]\n             cx.attribute(attr::mk_list_item(\n-                ast::Ident::new(sym::cfg, attr_sp),\n-                vec![attr::mk_nested_word_item(ast::Ident::new(sym::test, attr_sp))],\n+                Ident::new(sym::cfg, attr_sp),\n+                vec![attr::mk_nested_word_item(Ident::new(sym::test, attr_sp))],\n             )),\n             // #[rustc_test_marker]\n             cx.attribute(cx.meta_word(attr_sp, sym::rustc_test_marker)),\n@@ -288,7 +288,7 @@ pub fn expand_test_or_bench(\n     ]\n }\n \n-fn item_path(mod_path: &[ast::Ident], item_ident: &ast::Ident) -> String {\n+fn item_path(mod_path: &[Ident], item_ident: &Ident) -> String {\n     mod_path\n         .iter()\n         .chain(iter::once(item_ident))"}, {"sha": "34ed4c800e04ff62d0deefb960a2defc83546bd3", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,7 +1,7 @@\n // Code that generates a test runner to run all the tests in a crate\n \n use log::debug;\n-use rustc_ast::ast::{self, Ident};\n+use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_ast::entry::{self, EntryPointType};\n use rustc_ast::mut_visit::{ExpectOne, *};\n@@ -12,7 +12,7 @@ use rustc_feature::Features;\n use rustc_session::parse::ParseSess;\n use rustc_span::hygiene::{AstPass, SyntaxContext, Transparency};\n use rustc_span::source_map::respan;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::PanicStrategy;\n use smallvec::{smallvec, SmallVec};"}, {"sha": "dd9ada0b95daa6f8684f3bcac650d9415f152411", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -165,6 +165,13 @@ pub fn target_machine_factory(\n \n     let asm_comments = sess.asm_comments();\n     let relax_elf_relocations = sess.target.target.options.relax_elf_relocations;\n+\n+    let use_init_array = !sess\n+        .opts\n+        .debugging_opts\n+        .use_ctors_section\n+        .unwrap_or(sess.target.target.options.use_ctors_section);\n+\n     Arc::new(move || {\n         let tm = unsafe {\n             llvm::LLVMRustCreateTargetMachine(\n@@ -184,6 +191,7 @@ pub fn target_machine_factory(\n                 asm_comments,\n                 emit_stack_size_section,\n                 relax_elf_relocations,\n+                use_init_array,\n             )\n         };\n "}, {"sha": "856f989bc10a12802f0a755315785704ab92fb46", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -244,9 +244,8 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 }\n             }\n             Scalar::Ptr(ptr) => {\n-                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                let base_addr = match alloc_kind {\n-                    Some(GlobalAlloc::Memory(alloc)) => {\n+                let base_addr = match self.tcx.global_alloc(ptr.alloc_id) {\n+                    GlobalAlloc::Memory(alloc) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         let value = match alloc.mutability {\n                             Mutability::Mut => self.static_addr_of_mut(init, alloc.align, None),\n@@ -257,12 +256,11 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         }\n                         value\n                     }\n-                    Some(GlobalAlloc::Function(fn_instance)) => self.get_fn_addr(fn_instance),\n-                    Some(GlobalAlloc::Static(def_id)) => {\n+                    GlobalAlloc::Function(fn_instance) => self.get_fn_addr(fn_instance),\n+                    GlobalAlloc::Static(def_id) => {\n                         assert!(self.tcx.is_static(def_id));\n                         self.get_static(def_id)\n                     }\n-                    None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n                 };\n                 let llval = unsafe {\n                     llvm::LLVMConstInBoundsGEP("}, {"sha": "fb9a27ed001f43bd4ad1a03d6b82037b7304d011", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -19,7 +19,6 @@ use crate::llvm::debuginfo::{\n use crate::value::Value;\n \n use log::debug;\n-use rustc_ast::ast;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -93,7 +92,7 @@ pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n pub const NO_SCOPE_METADATA: Option<&DIScope> = None;\n \n #[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n-pub struct UniqueTypeId(ast::Name);\n+pub struct UniqueTypeId(Symbol);\n \n /// The `TypeMap` is where the `CrateDebugContext` holds the type metadata nodes\n /// created so far. The metadata nodes are indexed by `UniqueTypeId`, and, for\n@@ -1300,7 +1299,7 @@ fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n fn generator_layout_and_saved_local_names(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<ast::Name>>) {\n+) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<Symbol>>) {\n     let body = tcx.optimized_mir(def_id);\n     let generator_layout = body.generator_layout.as_ref().unwrap();\n     let mut generator_saved_local_names = IndexVec::from_elem(None, &generator_layout.field_tys);\n@@ -1656,7 +1655,7 @@ enum VariantInfo<'a, 'tcx> {\n     Generator {\n         substs: SubstsRef<'tcx>,\n         generator_layout: &'tcx GeneratorLayout<'tcx>,\n-        generator_saved_local_names: &'a IndexVec<mir::GeneratorSavedLocal, Option<ast::Name>>,\n+        generator_saved_local_names: &'a IndexVec<mir::GeneratorSavedLocal, Option<Symbol>>,\n         variant_index: VariantIdx,\n     },\n }"}, {"sha": "8c9a2c09c272c41558fda7dae7c57f609ae2ed09", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -17,7 +17,6 @@ use crate::llvm::debuginfo::{\n };\n use crate::value::Value;\n \n-use rustc_ast::ast;\n use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, VariableKind};\n use rustc_codegen_ssa::traits::*;\n@@ -529,7 +528,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn create_dbg_var(\n         &self,\n         dbg_context: &FunctionDebugContext<&'ll DIScope>,\n-        variable_name: ast::Name,\n+        variable_name: Symbol,\n         variable_type: Ty<'tcx>,\n         scope_metadata: &'ll DIScope,\n         variable_kind: VariableKind,"}, {"sha": "0d466c2cd745aa00f870a307aef17616070b5daa", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1956,6 +1956,7 @@ extern \"C\" {\n         AsmComments: bool,\n         EmitStackSizeSection: bool,\n         RelaxELFRelocations: bool,\n+        UseInitArray: bool,\n     ) -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n     pub fn LLVMRustAddBuilderLibraryInfo("}, {"sha": "937c7457c63bb29e874cdd1de751f0528b3b127f", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout),\n                 };\n                 let a = Scalar::from(Pointer::new(\n-                    bx.tcx().alloc_map.lock().create_memory_alloc(data),\n+                    bx.tcx().create_memory_alloc(data),\n                     Size::from_bytes(start),\n                 ));\n                 let a_llval = bx.scalar_to_backend("}, {"sha": "1ee0f489ffc104ef2daefa3ec07834790190744e", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,10 +1,9 @@\n use super::BackendTypes;\n use crate::mir::debuginfo::{FunctionDebugContext, VariableKind};\n-use rustc_ast::ast::Name;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::mir;\n use rustc_middle::ty::{Instance, Ty};\n-use rustc_span::{SourceFile, Span};\n+use rustc_span::{SourceFile, Span, Symbol};\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::Size;\n \n@@ -36,7 +35,7 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n     fn create_dbg_var(\n         &self,\n         dbg_context: &FunctionDebugContext<Self::DIScope>,\n-        variable_name: Name,\n+        variable_name: Symbol,\n         variable_type: Ty<'tcx>,\n         scope_metadata: Self::DIScope,\n         variable_kind: VariableKind,"}, {"sha": "a443b8f464f1c08fb1b4edd1ece6b25d317ce56f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -11,6 +11,7 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_mir::util::{write_mir_graphviz, write_mir_pretty};\n use rustc_session::config::{Input, PpMode, PpSourceMode};\n use rustc_session::Session;\n+use rustc_span::symbol::Ident;\n use rustc_span::FileName;\n \n use std::cell::Cell;\n@@ -284,7 +285,7 @@ impl<'a> PrinterSupport for HygieneAnnotation<'a> {\n impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n         match node {\n-            pprust::AnnNode::Ident(&ast::Ident { name, span }) => {\n+            pprust::AnnNode::Ident(&Ident { name, span }) => {\n                 s.s.space();\n                 s.synth_comment(format!(\"{}{:?}\", name.as_u32(), span.ctxt()))\n             }"}, {"sha": "fe5bf6f82c6d38b44a9cf9177f30079feba1a06a", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,7 +1,7 @@\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirectoryOwnership;\n \n-use rustc_ast::ast::{self, Attribute, Name, NodeId, PatKind};\n+use rustc_ast::ast::{self, Attribute, NodeId, PatKind};\n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n@@ -796,7 +796,7 @@ impl SyntaxExtension {\n         span: Span,\n         helper_attrs: Vec<Symbol>,\n         edition: Edition,\n-        name: Name,\n+        name: Symbol,\n         attrs: &[ast::Attribute],\n     ) -> SyntaxExtension {\n         let allow_internal_unstable = attr::allow_internal_unstable(&attrs, &sess.span_diagnostic)\n@@ -885,7 +885,7 @@ pub trait Resolver {\n \n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment);\n-    fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n+    fn register_builtin_macro(&mut self, ident: Ident, ext: SyntaxExtension);\n \n     fn expansion_for_ast_pass(\n         &mut self,\n@@ -913,7 +913,7 @@ pub trait Resolver {\n \n #[derive(Clone)]\n pub struct ModuleData {\n-    pub mod_path: Vec<ast::Ident>,\n+    pub mod_path: Vec<Ident>,\n     pub directory: PathBuf,\n }\n \n@@ -1052,16 +1052,16 @@ impl<'a> ExtCtxt<'a> {\n     pub fn set_trace_macros(&mut self, x: bool) {\n         self.ecfg.trace_mac = x\n     }\n-    pub fn ident_of(&self, st: &str, sp: Span) -> ast::Ident {\n-        ast::Ident::from_str_and_span(st, sp)\n+    pub fn ident_of(&self, st: &str, sp: Span) -> Ident {\n+        Ident::from_str_and_span(st, sp)\n     }\n-    pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n+    pub fn std_path(&self, components: &[Symbol]) -> Vec<Ident> {\n         let def_site = self.with_def_site_ctxt(DUMMY_SP);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n             .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()\n     }\n-    pub fn name_of(&self, st: &str) -> ast::Name {\n+    pub fn name_of(&self, st: &str) -> Symbol {\n         Symbol::intern(st)\n     }\n "}, {"sha": "be2c52a85eb2ac5c6c7e00b14cf0ce02f9ed54f1", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,28 +1,28 @@\n use crate::base::ExtCtxt;\n \n-use rustc_ast::ast::{self, AttrVec, BlockCheckMode, Expr, Ident, PatKind, UnOp};\n+use rustc_ast::ast::{self, AttrVec, BlockCheckMode, Expr, PatKind, UnOp};\n use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_span::source_map::{respan, Spanned};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n \n use rustc_span::Span;\n \n impl<'a> ExtCtxt<'a> {\n-    pub fn path(&self, span: Span, strs: Vec<ast::Ident>) -> ast::Path {\n+    pub fn path(&self, span: Span, strs: Vec<Ident>) -> ast::Path {\n         self.path_all(span, false, strs, vec![])\n     }\n-    pub fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n+    pub fn path_ident(&self, span: Span, id: Ident) -> ast::Path {\n         self.path(span, vec![id])\n     }\n-    pub fn path_global(&self, span: Span, strs: Vec<ast::Ident>) -> ast::Path {\n+    pub fn path_global(&self, span: Span, strs: Vec<Ident>) -> ast::Path {\n         self.path_all(span, true, strs, vec![])\n     }\n     pub fn path_all(\n         &self,\n         span: Span,\n         global: bool,\n-        mut idents: Vec<ast::Ident>,\n+        mut idents: Vec<Ident>,\n         args: Vec<ast::GenericArg>,\n     ) -> ast::Path {\n         assert!(!idents.is_empty());\n@@ -63,7 +63,7 @@ impl<'a> ExtCtxt<'a> {\n \n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n-    pub fn ty_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Ty> {\n+    pub fn ty_ident(&self, span: Span, ident: Ident) -> P<ast::Ty> {\n         self.ty_path(self.path_ident(span, ident))\n     }\n \n@@ -74,7 +74,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn const_ident(&self, span: Span, ident: ast::Ident) -> ast::AnonConst {\n+    pub fn const_ident(&self, span: Span, ident: Ident) -> ast::AnonConst {\n         self.anon_const(span, ast::ExprKind::Path(None, self.path_ident(span, ident)))\n     }\n \n@@ -95,7 +95,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn typaram(\n         &self,\n         span: Span,\n-        ident: ast::Ident,\n+        ident: Ident,\n         attrs: Vec<ast::Attribute>,\n         bounds: ast::GenericBounds,\n         default: Option<P<ast::Ty>>,\n@@ -129,14 +129,14 @@ impl<'a> ExtCtxt<'a> {\n         )\n     }\n \n-    pub fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime {\n+    pub fn lifetime(&self, span: Span, ident: Ident) -> ast::Lifetime {\n         ast::Lifetime { id: ast::DUMMY_NODE_ID, ident: ident.with_span_pos(span) }\n     }\n \n     pub fn lifetime_def(\n         &self,\n         span: Span,\n-        ident: ast::Ident,\n+        ident: Ident,\n         attrs: Vec<ast::Attribute>,\n         bounds: ast::GenericBounds,\n     ) -> ast::GenericParam {\n@@ -155,13 +155,7 @@ impl<'a> ExtCtxt<'a> {\n         ast::Stmt { id: ast::DUMMY_NODE_ID, span: expr.span, kind: ast::StmtKind::Expr(expr) }\n     }\n \n-    pub fn stmt_let(\n-        &self,\n-        sp: Span,\n-        mutbl: bool,\n-        ident: ast::Ident,\n-        ex: P<ast::Expr>,\n-    ) -> ast::Stmt {\n+    pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: Ident, ex: P<ast::Expr>) -> ast::Stmt {\n         let pat = if mutbl {\n             let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mut);\n             self.pat_ident_binding_mode(sp, ident, binding_mode)\n@@ -218,7 +212,7 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(path.span, ast::ExprKind::Path(None, path))\n     }\n \n-    pub fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n+    pub fn expr_ident(&self, span: Span, id: Ident) -> P<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     pub fn expr_self(&self, span: Span) -> P<ast::Expr> {\n@@ -251,18 +245,13 @@ impl<'a> ExtCtxt<'a> {\n     ) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(expr, args))\n     }\n-    pub fn expr_call_ident(\n-        &self,\n-        span: Span,\n-        id: ast::Ident,\n-        args: Vec<P<ast::Expr>>,\n-    ) -> P<ast::Expr> {\n+    pub fn expr_call_ident(&self, span: Span, id: Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(self.expr_ident(span, id), args))\n     }\n     pub fn expr_call_global(\n         &self,\n         sp: Span,\n-        fn_path: Vec<ast::Ident>,\n+        fn_path: Vec<Ident>,\n         args: Vec<P<ast::Expr>>,\n     ) -> P<ast::Expr> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n@@ -272,7 +261,7 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         expr: P<ast::Expr>,\n-        ident: ast::Ident,\n+        ident: Ident,\n         mut args: Vec<P<ast::Expr>>,\n     ) -> P<ast::Expr> {\n         args.insert(0, expr);\n@@ -304,7 +293,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn expr_struct_ident(\n         &self,\n         span: Span,\n-        id: ast::Ident,\n+        id: Ident,\n         fields: Vec<ast::Field>,\n     ) -> P<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n@@ -405,15 +394,15 @@ impl<'a> ExtCtxt<'a> {\n     pub fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Lit(expr))\n     }\n-    pub fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> {\n+    pub fn pat_ident(&self, span: Span, ident: Ident) -> P<ast::Pat> {\n         let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Not);\n         self.pat_ident_binding_mode(span, ident, binding_mode)\n     }\n \n     pub fn pat_ident_binding_mode(\n         &self,\n         span: Span,\n-        ident: ast::Ident,\n+        ident: Ident,\n         bm: ast::BindingMode,\n     ) -> P<ast::Pat> {\n         let pat = PatKind::Ident(bm, ident.with_span_pos(span), None);\n@@ -517,7 +506,7 @@ impl<'a> ExtCtxt<'a> {\n         )\n     }\n \n-    pub fn lambda(&self, span: Span, ids: Vec<ast::Ident>, body: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn lambda(&self, span: Span, ids: Vec<Ident>, body: P<ast::Expr>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.param(span, *id, self.ty(span, ast::TyKind::Infer))).collect(),\n             ast::FnRetTy::Default(span),\n@@ -544,20 +533,15 @@ impl<'a> ExtCtxt<'a> {\n         self.lambda(span, Vec::new(), body)\n     }\n \n-    pub fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n+    pub fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: Ident) -> P<ast::Expr> {\n         self.lambda(span, vec![ident], body)\n     }\n \n-    pub fn lambda_stmts_1(\n-        &self,\n-        span: Span,\n-        stmts: Vec<ast::Stmt>,\n-        ident: ast::Ident,\n-    ) -> P<ast::Expr> {\n+    pub fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>, ident: Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n     }\n \n-    pub fn param(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Param {\n+    pub fn param(&self, span: Span, ident: Ident, ty: P<ast::Ty>) -> ast::Param {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::Param {\n             attrs: AttrVec::default(),\n@@ -653,7 +637,7 @@ impl<'a> ExtCtxt<'a> {\n         attr::mk_attr_outer(mi)\n     }\n \n-    pub fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem {\n+    pub fn meta_word(&self, sp: Span, w: Symbol) -> ast::MetaItem {\n         attr::mk_word_item(Ident::new(w, sp))\n     }\n }"}, {"sha": "427d04d3a9753472b6ce0414f8c2ae1f255710c4", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -7,7 +7,7 @@ use crate::module::{parse_external_mod, push_directory, Directory, DirectoryOwne\n use crate::placeholders::{placeholder, PlaceholderExpander};\n use crate::proc_macro::collect_derives;\n \n-use rustc_ast::ast::{self, AttrItem, Block, Ident, LitKind, NodeId, PatKind, Path};\n+use rustc_ast::ast::{self, AttrItem, Block, LitKind, NodeId, PatKind, Path};\n use rustc_ast::ast::{ItemKind, MacArgs, MacStmtStyle, StmtKind};\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n@@ -25,7 +25,7 @@ use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n use rustc_span::source_map::respan;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{FileName, Span, DUMMY_SP};\n \n use smallvec::{smallvec, SmallVec};"}, {"sha": "a728261d711a72464f99b078f6003854bbb20a35", "filename": "src/librustc_expand/mbe.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -9,10 +9,10 @@ crate mod macro_rules;\n crate mod quoted;\n crate mod transcribe;\n \n-use rustc_ast::ast;\n use rustc_ast::token::{self, Token, TokenKind};\n use rustc_ast::tokenstream::DelimSpan;\n \n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n use rustc_data_structures::sync::Lrc;\n@@ -82,13 +82,9 @@ enum TokenTree {\n     /// A kleene-style repetition sequence\n     Sequence(DelimSpan, Lrc<SequenceRepetition>),\n     /// e.g., `$var`\n-    MetaVar(Span, ast::Ident),\n+    MetaVar(Span, Ident),\n     /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n-    MetaVarDecl(\n-        Span,\n-        ast::Ident, /* name to bind */\n-        ast::Ident, /* kind of nonterminal */\n-    ),\n+    MetaVarDecl(Span, Ident /* name to bind */, Ident /* kind of nonterminal */),\n }\n \n impl TokenTree {"}, {"sha": "0cf092d912bcf5c0aa365ad85664785f80bff366", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -76,7 +76,6 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::mbe::{self, TokenTree};\n \n-use rustc_ast::ast::Name;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n use rustc_ast_pretty::pprust;\n@@ -766,7 +765,7 @@ fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n ///\n /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n /// token. Be conservative (return true) if not sure.\n-fn may_begin_with(token: &Token, name: Name) -> bool {\n+fn may_begin_with(token: &Token, name: Symbol) -> bool {\n     /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n     fn may_be_ident(nt: &token::Nonterminal) -> bool {\n         match *nt {"}, {"sha": "ecadf320f87c4101f557460209677e25f214c701", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -21,7 +21,7 @@ use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n use rustc_span::Span;\n \n use log::debug;\n@@ -39,7 +39,7 @@ crate struct ParserAnyMacro<'a> {\n     /// Span of the expansion site of the macro this parser is for\n     site_span: Span,\n     /// The ident of the macro we're parsing\n-    macro_ident: ast::Ident,\n+    macro_ident: Ident,\n     arm_span: Span,\n }\n \n@@ -88,7 +88,7 @@ fn emit_frag_parse_err(\n     parser: &Parser<'_>,\n     orig_parser: &mut Parser<'_>,\n     site_span: Span,\n-    macro_ident: ast::Ident,\n+    macro_ident: Ident,\n     arm_span: Span,\n     kind: AstFragmentKind,\n ) {\n@@ -166,7 +166,7 @@ impl<'a> ParserAnyMacro<'a> {\n }\n \n struct MacroRulesMacroExpander {\n-    name: ast::Ident,\n+    name: Ident,\n     span: Span,\n     transparency: Transparency,\n     lhses: Vec<mbe::TokenTree>,\n@@ -215,7 +215,7 @@ fn generic_extension<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n     def_span: Span,\n-    name: ast::Ident,\n+    name: Ident,\n     transparency: Transparency,\n     arg: TokenStream,\n     lhses: &[mbe::TokenTree],\n@@ -400,9 +400,9 @@ pub fn compile_declarative_macro(\n     };\n \n     let diag = &sess.span_diagnostic;\n-    let lhs_nm = ast::Ident::new(sym::lhs, def.span);\n-    let rhs_nm = ast::Ident::new(sym::rhs, def.span);\n-    let tt_spec = ast::Ident::new(sym::tt, def.span);\n+    let lhs_nm = Ident::new(sym::lhs, def.span);\n+    let rhs_nm = Ident::new(sym::rhs, def.span);\n+    let tt_spec = Ident::new(sym::tt, def.span);\n \n     // Parse the macro_rules! invocation\n     let (macro_rules, body) = match &def.kind {"}, {"sha": "3295f5b392d6dfb8a902f653bb51984823cef317", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,12 +1,11 @@\n use crate::mbe::macro_parser;\n use crate::mbe::{Delimited, KleeneOp, KleeneToken, SequenceRepetition, TokenTree};\n \n-use rustc_ast::ast;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream;\n use rustc_ast_pretty::pprust;\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Ident};\n \n use rustc_span::Span;\n \n@@ -67,7 +66,7 @@ pub(super) fn parse(\n                     tree => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(start_sp),\n                 };\n                 sess.missing_fragment_specifiers.borrow_mut().insert(span);\n-                result.push(TokenTree::MetaVarDecl(span, ident, ast::Ident::invalid()));\n+                result.push(TokenTree::MetaVarDecl(span, ident, Ident::invalid()));\n             }\n \n             // Not a metavar or no matchers allowed, so just return the tree\n@@ -145,7 +144,7 @@ fn parse_tree(\n                 let msg =\n                     format!(\"expected identifier, found `{}`\", pprust::token_to_string(&token),);\n                 sess.span_diagnostic.span_err(token.span, &msg);\n-                TokenTree::MetaVar(token.span, ast::Ident::invalid())\n+                TokenTree::MetaVar(token.span, Ident::invalid())\n             }\n \n             // There are no more tokens. Just return the `$` we already have."}, {"sha": "9bb2b57b7f591ff509e238bf2a5684afe286a217", "filename": "src/librustc_expand/module.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmodule.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,10 +1,10 @@\n-use rustc_ast::ast::{self, Attribute, Ident, Mod};\n+use rustc_ast::ast::{Attribute, Mod};\n use rustc_ast::{attr, token};\n use rustc_errors::{struct_span_err, PResult};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{FileName, Span};\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Ident};\n \n use std::path::{self, Path, PathBuf};\n \n@@ -18,7 +18,7 @@ pub struct Directory {\n pub enum DirectoryOwnership {\n     Owned {\n         // None if `mod.rs`, `Some(\"foo\")` if we're in `foo.rs`.\n-        relative: Option<ast::Ident>,\n+        relative: Option<Ident>,\n     },\n     UnownedViaBlock,\n     UnownedViaMod,\n@@ -40,7 +40,7 @@ pub struct ModulePathSuccess {\n \n crate fn parse_external_mod(\n     sess: &ParseSess,\n-    id: ast::Ident,\n+    id: Ident,\n     span: Span, // The span to blame on errors.\n     Directory { mut ownership, path }: Directory,\n     attrs: &mut Vec<Attribute>,\n@@ -125,7 +125,7 @@ crate fn push_directory(\n \n fn submod_path<'a>(\n     sess: &'a ParseSess,\n-    id: ast::Ident,\n+    id: Ident,\n     span: Span,\n     attrs: &[Attribute],\n     ownership: DirectoryOwnership,\n@@ -236,9 +236,9 @@ pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<Pat\n // Public for rustfmt usage.\n pub fn default_submod_path<'a>(\n     sess: &'a ParseSess,\n-    id: ast::Ident,\n+    id: Ident,\n     span: Span,\n-    relative: Option<ast::Ident>,\n+    relative: Option<Ident>,\n     dir_path: &Path,\n ) -> ModulePath<'a> {\n     // If we're in a foo.rs file instead of a mod.rs file,"}, {"sha": "48da1a3ccc420a41c70ca975cf02b2ab529983a8", "filename": "src/librustc_expand/mut_visit/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmut_visit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fmut_visit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmut_visit%2Ftests.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,9 +1,10 @@\n use crate::tests::{matches_codepattern, string_to_crate};\n \n-use rustc_ast::ast::{self, Ident};\n+use rustc_ast::ast;\n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::with_default_globals;\n use rustc_ast_pretty::pprust;\n+use rustc_span::symbol::Ident;\n \n // This version doesn't care about getting comments or doc-strings in.\n fn fake_print_crate(s: &mut pprust::State<'_>, krate: &ast::Crate) {\n@@ -14,7 +15,7 @@ fn fake_print_crate(s: &mut pprust::State<'_>, krate: &ast::Crate) {\n struct ToZzIdentMutVisitor;\n \n impl MutVisitor for ToZzIdentMutVisitor {\n-    fn visit_ident(&mut self, ident: &mut ast::Ident) {\n+    fn visit_ident(&mut self, ident: &mut Ident) {\n         *ident = Ident::from_str(\"zz\");\n     }\n     fn visit_mac(&mut self, mac: &mut ast::MacCall) {"}, {"sha": "437f6e62d7d330473b209b68a15f080bf5699aca", "filename": "src/librustc_expand/parse/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fparse%2Ftests.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,6 @@\n use crate::tests::{matches_codepattern, string_to_stream, with_error_checking_parse};\n \n-use rustc_ast::ast::{self, Name, PatKind};\n+use rustc_ast::ast::{self, PatKind};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n@@ -100,12 +100,12 @@ fn string_to_tts_1() {\n \n         let expected = TokenStream::new(vec![\n             TokenTree::token(token::Ident(kw::Fn, false), sp(0, 2)).into(),\n-            TokenTree::token(token::Ident(Name::intern(\"a\"), false), sp(3, 4)).into(),\n+            TokenTree::token(token::Ident(Symbol::intern(\"a\"), false), sp(3, 4)).into(),\n             TokenTree::Delimited(\n                 DelimSpan::from_pair(sp(5, 6), sp(13, 14)),\n                 token::DelimToken::Paren,\n                 TokenStream::new(vec![\n-                    TokenTree::token(token::Ident(Name::intern(\"b\"), false), sp(6, 7)).into(),\n+                    TokenTree::token(token::Ident(Symbol::intern(\"b\"), false), sp(6, 7)).into(),\n                     TokenTree::token(token::Colon, sp(8, 9)).into(),\n                     TokenTree::token(token::Ident(sym::i32, false), sp(10, 13)).into(),\n                 ])\n@@ -116,7 +116,7 @@ fn string_to_tts_1() {\n                 DelimSpan::from_pair(sp(15, 16), sp(20, 21)),\n                 token::DelimToken::Brace,\n                 TokenStream::new(vec![\n-                    TokenTree::token(token::Ident(Name::intern(\"b\"), false), sp(17, 18)).into(),\n+                    TokenTree::token(token::Ident(Symbol::intern(\"b\"), false), sp(17, 18)).into(),\n                     TokenTree::token(token::Semi, sp(18, 19)).into(),\n                 ])\n                 .into(),"}, {"sha": "23f7a5b28fe80109558277d22d6ebc96e919e9db", "filename": "src/librustc_expand/placeholders.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fplaceholders.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -5,6 +5,7 @@ use rustc_ast::ast;\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_span::source_map::{dummy_spanned, DUMMY_SP};\n+use rustc_span::symbol::Ident;\n \n use smallvec::{smallvec, SmallVec};\n \n@@ -23,7 +24,7 @@ pub fn placeholder(\n         }\n     }\n \n-    let ident = ast::Ident::invalid();\n+    let ident = Ident::invalid();\n     let attrs = Vec::new();\n     let vis = vis.unwrap_or_else(|| dummy_spanned(ast::VisibilityKind::Inherited));\n     let span = DUMMY_SP;"}, {"sha": "afc6dc36eb43017516a9a8632ff3ae437c7be5cd", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -10,7 +10,7 @@ use rustc_errors::Diagnostic;\n use rustc_parse::lexer::nfc_normalize;\n use rustc_parse::{nt_to_tokenstream, parse_stream_from_source_str};\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{self, kw, sym, Symbol};\n use rustc_span::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n \n use pm::bridge::{server, TokenTree};\n@@ -143,7 +143,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n             Ident(name, false) if name == kw::DollarCrate => tt!(Ident::dollar_crate()),\n             Ident(name, is_raw) => tt!(Ident::new(sess, name, is_raw)),\n             Lifetime(name) => {\n-                let ident = ast::Ident::new(name, span).without_first_quote();\n+                let ident = symbol::Ident::new(name, span).without_first_quote();\n                 stack.push(tt!(Ident::new(sess, ident.name, false)));\n                 tt!(Punct::new('\\'', true))\n             }"}, {"sha": "caaa08df499812105d4e654f0a8e2fbd97cbd93e", "filename": "src/librustc_expand/tokenstream/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_expand%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Ftokenstream%2Ftests.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,10 +1,9 @@\n use crate::tests::string_to_stream;\n \n-use rustc_ast::ast::Name;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{TokenStream, TokenStreamBuilder, TokenTree};\n use rustc_ast::with_default_globals;\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, Span, Symbol};\n use smallvec::smallvec;\n \n fn string_to_ts(string: &str) -> TokenStream {\n@@ -87,7 +86,7 @@ fn test_is_empty() {\n     with_default_globals(|| {\n         let test0: TokenStream = Vec::<TokenTree>::new().into_iter().collect();\n         let test1: TokenStream =\n-            TokenTree::token(token::Ident(Name::intern(\"a\"), false), sp(0, 1)).into();\n+            TokenTree::token(token::Ident(Symbol::intern(\"a\"), false), sp(0, 1)).into();\n         let test2 = string_to_ts(\"foo(bar::baz)\");\n \n         assert_eq!(test0.is_empty(), true);"}, {"sha": "eafff6705ba6c0ace74f5c40dc5f89f25862e4ac", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,7 +3,7 @@ use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n use crate::itemlikevisit;\n \n-use rustc_ast::ast::{self, CrateSugar, Ident, LlvmAsmDialect, Name};\n+use rustc_ast::ast::{self, CrateSugar, LlvmAsmDialect};\n use rustc_ast::ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n pub use rustc_ast::ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use rustc_ast::ast::{CaptureBy, Movability, Mutability};\n@@ -13,7 +13,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_macros::HashStable_Generic;\n use rustc_span::source_map::{SourceMap, Spanned};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n \n@@ -2443,7 +2443,7 @@ pub enum ItemKind<'hir> {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n     /// E.g., `extern crate foo` or `extern crate foo_bar as foo`.\n-    ExternCrate(Option<Name>),\n+    ExternCrate(Option<Symbol>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n     ///\n@@ -2611,7 +2611,7 @@ pub type TraitMap<ID = HirId> = NodeMap<Vec<TraitCandidate<ID>>>;\n \n // Map from the NodeId of a glob import to a list of items which are actually\n // imported.\n-pub type GlobMap = NodeMap<FxHashSet<Name>>;\n+pub type GlobMap = NodeMap<FxHashSet<Symbol>>;\n \n #[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum Node<'hir> {"}, {"sha": "0270d0de5c7d750e16a3033ea1ab8ef0baa07874", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -34,8 +34,9 @@\n use crate::hir::*;\n use crate::hir_id::CRATE_HIR_ID;\n use crate::itemlikevisit::{ItemLikeVisitor, ParItemLikeVisitor};\n-use rustc_ast::ast::{Attribute, Ident, Label, Name};\n+use rustc_ast::ast::{Attribute, Label};\n use rustc_ast::walk_list;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n pub struct DeepVisitor<'v, V> {\n@@ -317,7 +318,7 @@ pub trait Visitor<'v>: Sized {\n     fn visit_id(&mut self, _hir_id: HirId) {\n         // Nothing to do.\n     }\n-    fn visit_name(&mut self, _span: Span, _name: Name) {\n+    fn visit_name(&mut self, _span: Span, _name: Symbol) {\n         // Nothing to do.\n     }\n     fn visit_ident(&mut self, ident: Ident) {\n@@ -395,7 +396,7 @@ pub trait Visitor<'v>: Sized {\n     fn visit_variant_data(\n         &mut self,\n         s: &'v VariantData<'v>,\n-        _: Name,\n+        _: Symbol,\n         _: &'v Generics<'v>,\n         _parent_id: HirId,\n         _: Span,"}, {"sha": "2f1b5da8e13a0e39a9927baf56b5523c54325fc8", "filename": "src/librustc_hir/pat_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_hir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_hir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fpat_util.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,7 +1,7 @@\n use crate::def::{CtorOf, DefKind, Res};\n use crate::def_id::DefId;\n use crate::hir::{self, HirId, PatKind};\n-use rustc_ast::ast;\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n use std::iter::{Enumerate, ExactSizeIterator};\n@@ -79,7 +79,7 @@ impl hir::Pat<'_> {\n \n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n-    pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident)) {\n+    pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, Ident)) {\n         self.walk_always(|p| {\n             if let PatKind::Binding(binding_mode, _, ident, _) = p.kind {\n                 f(binding_mode, p.hir_id, p.span, ident);\n@@ -93,7 +93,7 @@ impl hir::Pat<'_> {\n     /// When encountering an or-pattern `p_0 | ... | p_n` only `p_0` will be visited.\n     pub fn each_binding_or_first(\n         &self,\n-        f: &mut impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n+        f: &mut impl FnMut(hir::BindingAnnotation, HirId, Span, Ident),\n     ) {\n         self.walk(|p| match &p.kind {\n             PatKind::Or(ps) => {\n@@ -140,7 +140,7 @@ impl hir::Pat<'_> {\n         satisfies\n     }\n \n-    pub fn simple_ident(&self) -> Option<ast::Ident> {\n+    pub fn simple_ident(&self) -> Option<Ident> {\n         match self.kind {\n             PatKind::Binding(\n                 hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,"}, {"sha": "f8a42376d146a115991a9e1ea458a855ecbf489f", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -10,7 +10,7 @@ use rustc_hir as hir;\n use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::{SourceMap, Spanned};\n-use rustc_span::symbol::{kw, IdentPrinter};\n+use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n use rustc_span::{self, BytePos, FileName};\n use rustc_target::spec::abi::Abi;\n \n@@ -23,7 +23,7 @@ pub fn id_to_string(map: &dyn rustc_hir::intravisit::Map<'_>, hir_id: hir::HirId\n }\n \n pub enum AnnNode<'a> {\n-    Name(&'a ast::Name),\n+    Name(&'a Symbol),\n     Block(&'a hir::Block<'a>),\n     Item(&'a hir::Item<'a>),\n     SubItem(hir::HirId),\n@@ -145,7 +145,7 @@ impl<'a> PrintState<'a> for State<'a> {\n         &mut self.comments\n     }\n \n-    fn print_ident(&mut self, ident: ast::Ident) {\n+    fn print_ident(&mut self, ident: Ident) {\n         self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Name(&ident.name))\n     }\n@@ -453,7 +453,7 @@ impl<'a> State<'a> {\n \n     fn print_associated_const(\n         &mut self,\n-        ident: ast::Ident,\n+        ident: Ident,\n         ty: &hir::Ty<'_>,\n         default: Option<hir::BodyId>,\n         vis: &hir::Visibility<'_>,\n@@ -473,7 +473,7 @@ impl<'a> State<'a> {\n \n     fn print_associated_type(\n         &mut self,\n-        ident: ast::Ident,\n+        ident: Ident,\n         generics: &hir::Generics<'_>,\n         bounds: Option<hir::GenericBounds<'_>>,\n         ty: Option<&hir::Ty<'_>>,\n@@ -768,7 +768,7 @@ impl<'a> State<'a> {\n         &mut self,\n         enum_definition: &hir::EnumDef<'_>,\n         generics: &hir::Generics<'_>,\n-        name: ast::Name,\n+        name: Symbol,\n         span: rustc_span::Span,\n         visibility: &hir::Visibility<'_>,\n     ) {\n@@ -827,7 +827,7 @@ impl<'a> State<'a> {\n         &mut self,\n         struct_def: &hir::VariantData<'_>,\n         generics: &hir::Generics<'_>,\n-        name: ast::Name,\n+        name: Symbol,\n         span: rustc_span::Span,\n         print_finalizer: bool,\n     ) {\n@@ -886,11 +886,11 @@ impl<'a> State<'a> {\n     }\n     pub fn print_method_sig(\n         &mut self,\n-        ident: ast::Ident,\n+        ident: Ident,\n         m: &hir::FnSig<'_>,\n         generics: &hir::Generics<'_>,\n         vis: &hir::Visibility<'_>,\n-        arg_names: &[ast::Ident],\n+        arg_names: &[Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n         self.print_fn(&m.decl, m.header, Some(ident.name), generics, vis, arg_names, body_id)\n@@ -1297,7 +1297,7 @@ impl<'a> State<'a> {\n                 self.bopen();\n \n                 // Print `let _t = $init;`:\n-                let temp = ast::Ident::from_str(\"_t\");\n+                let temp = Ident::from_str(\"_t\");\n                 self.print_local(Some(init), |this| this.print_ident(temp));\n                 self.s.word(\";\");\n \n@@ -1496,8 +1496,8 @@ impl<'a> State<'a> {\n         self.s.word(i.to_string())\n     }\n \n-    pub fn print_name(&mut self, name: ast::Name) {\n-        self.print_ident(ast::Ident::with_dummy_span(name))\n+    pub fn print_name(&mut self, name: Symbol) {\n+        self.print_ident(Ident::with_dummy_span(name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &hir::Local<'_>, coll: &hir::Expr<'_>) {\n@@ -1888,10 +1888,10 @@ impl<'a> State<'a> {\n         &mut self,\n         decl: &hir::FnDecl<'_>,\n         header: hir::FnHeader,\n-        name: Option<ast::Name>,\n+        name: Option<Symbol>,\n         generics: &hir::Generics<'_>,\n         vis: &hir::Visibility<'_>,\n-        arg_names: &[ast::Ident],\n+        arg_names: &[Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n         self.print_fn_header_info(header, vis);\n@@ -2154,9 +2154,9 @@ impl<'a> State<'a> {\n         abi: Abi,\n         unsafety: hir::Unsafety,\n         decl: &hir::FnDecl<'_>,\n-        name: Option<ast::Name>,\n+        name: Option<Symbol>,\n         generic_params: &[hir::GenericParam<'_>],\n-        arg_names: &[ast::Ident],\n+        arg_names: &[Ident],\n     ) {\n         self.ibox(INDENT_UNIT);\n         if !generic_params.is_empty() {"}, {"sha": "807ae586348e9785309911ea596c49cb014b81e4", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -44,7 +44,7 @@ use rustc_middle::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n use rustc_middle::dep_graph::{DepGraphQuery, DepKind, DepNode, DepNodeExt};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n use std::env;\n@@ -89,7 +89,7 @@ pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n }\n \n type Sources = Vec<(Span, DefId, DepNode)>;\n-type Targets = Vec<(Span, ast::Name, hir::HirId, DepNode)>;\n+type Targets = Vec<(Span, Symbol, hir::HirId, DepNode)>;\n \n struct IfThisChanged<'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -98,7 +98,7 @@ struct IfThisChanged<'tcx> {\n }\n \n impl IfThisChanged<'tcx> {\n-    fn argument(&self, attr: &ast::Attribute) -> Option<ast::Name> {\n+    fn argument(&self, attr: &ast::Attribute) -> Option<Symbol> {\n         let mut value = None;\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n             match list_item.ident() {"}, {"sha": "eee6e73ed10734860b3f4135b684c2cf52b7b1f8", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -147,7 +147,7 @@ impl AssertModuleSource<'tcx> {\n         );\n     }\n \n-    fn field(&self, attr: &ast::Attribute, name: Symbol) -> ast::Name {\n+    fn field(&self, attr: &ast::Attribute, name: Symbol) -> Symbol {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {"}, {"sha": "9bf992537dfaff9af04540da6621f10465c07f02", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -499,7 +499,7 @@ fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n     }\n }\n \n-fn expect_associated_value(tcx: TyCtxt<'_>, item: &NestedMetaItem) -> ast::Name {\n+fn expect_associated_value(tcx: TyCtxt<'_>, item: &NestedMetaItem) -> Symbol {\n     if let Some(value) = item.value_str() {\n         value\n     } else {"}, {"sha": "a0b5dd45a0e2aa01df20ea40999bdb4cbbc44c85", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -353,8 +353,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     // `TyVar(vid)` is unresolved, track its universe index in the canonicalized\n                     // result.\n                     Err(mut ui) => {\n-                        // FIXME: perf problem described in #55921.\n-                        ui = ty::UniverseIndex::ROOT;\n+                        if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n+                            // FIXME: perf problem described in #55921.\n+                            ui = ty::UniverseIndex::ROOT;\n+                        }\n                         self.canonicalize_ty_var(\n                             CanonicalVarInfo {\n                                 kind: CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n@@ -439,8 +441,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     // `ConstVar(vid)` is unresolved, track its universe index in the\n                     // canonicalized result\n                     Err(mut ui) => {\n-                        // FIXME: perf problem described in #55921.\n-                        ui = ty::UniverseIndex::ROOT;\n+                        if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n+                            // FIXME: perf problem described in #55921.\n+                            ui = ty::UniverseIndex::ROOT;\n+                        }\n                         return self.canonicalize_const_var(\n                             CanonicalVarInfo { kind: CanonicalVarKind::Const(ui) },\n                             ct,"}, {"sha": "67632a97df792889436da53beaad639b164f553f", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -10,7 +10,6 @@ pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n \n-use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::Rollback;\n@@ -457,7 +456,7 @@ pub enum SubregionOrigin<'tcx> {\n     /// the containing trait.\n     CompareImplMethodObligation {\n         span: Span,\n-        item_name: ast::Name,\n+        item_name: Symbol,\n         impl_item_def_id: DefId,\n         trait_item_def_id: DefId,\n     },\n@@ -519,7 +518,7 @@ pub enum RegionVariableOrigin {\n \n     UpvarRegion(ty::UpvarId, Span),\n \n-    BoundRegionInCoherence(ast::Name),\n+    BoundRegionInCoherence(Symbol),\n \n     /// This origin is used for the inference variables that we create\n     /// during NLL region processing."}, {"sha": "f873358ff9fdd81a0a7cd2a8622dab31292324a5", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,20 +1,20 @@\n use super::ObjectSafetyViolation;\n \n use crate::infer::InferCtxt;\n-use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n+use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use std::fmt;\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_extra_impl_obligation(\n         &self,\n         error_span: Span,\n-        item_name: ast::Name,\n+        item_name: Symbol,\n         _impl_item_def_id: DefId,\n         trait_item_def_id: DefId,\n         requirement: &dyn fmt::Display,"}, {"sha": "de304bcec236126eff494c59b4cad965ceef321b", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -525,6 +525,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(always_encode_mir, true);\n     tracked!(asm_comments, true);\n     tracked!(binary_dep_depinfo, true);\n+    tracked!(chalk, true);\n     tracked!(codegen_backend, Some(\"abc\".to_string()));\n     tracked!(crate_attr, vec![\"abc\".to_string()]);\n     tracked!(debug_macros, true);\n@@ -570,6 +571,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(tls_model, Some(TlsModel::GeneralDynamic));\n     tracked!(treat_err_as_bug, Some(1));\n     tracked!(unleash_the_miri_inside_of_you, true);\n+    tracked!(use_ctors_section, Some(true));\n     tracked!(verify_llvm_ir, true);\n }\n "}, {"sha": "7d5289cd46f5b678aebc66e16e8932aceaae05c2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -41,7 +41,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n@@ -1428,7 +1428,7 @@ impl KeywordIdents {\n         &mut self,\n         cx: &EarlyContext<'_>,\n         UnderMacro(under_macro): UnderMacro,\n-        ident: ast::Ident,\n+        ident: Ident,\n     ) {\n         let next_edition = match cx.sess.edition() {\n             Edition::Edition2015 => {\n@@ -1482,7 +1482,7 @@ impl EarlyLintPass for KeywordIdents {\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::MacCall) {\n         self.check_tokens(cx, mac.args.inner_tokens());\n     }\n-    fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: ast::Ident) {\n+    fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         self.check_ident_token(cx, UnderMacro(false), ident);\n     }\n }"}, {"sha": "06987ffa3d569c77588fb7b1b2ba884e0d38da76", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -20,6 +20,7 @@ use rustc_ast::ast;\n use rustc_ast::visit as ast_visit;\n use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n use rustc_session::Session;\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n use log::debug;\n@@ -159,7 +160,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         ast_visit::walk_ty(self, t);\n     }\n \n-    fn visit_ident(&mut self, ident: ast::Ident) {\n+    fn visit_ident(&mut self, ident: Ident) {\n         run_early_pass!(self, check_ident, ident);\n     }\n "}, {"sha": "12b7459e88dc32ec100c22abeef1b2d2a9d7893b", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2,13 +2,13 @@\n //! Clippy.\n \n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n-use rustc_ast::ast::{Ident, Item, ItemKind};\n+use rustc_ast::ast::{Item, ItemKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::{GenericArg, HirId, MutTy, Mutability, Path, PathSegment, QPath, Ty, TyKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n \n declare_tool_lint! {\n     pub rustc::DEFAULT_HASH_TYPES,"}, {"sha": "c8f827b1f5cedf23681e876a2e8bff4a4551c4d2", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -25,6 +25,7 @@ use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::LintPass;\n+use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n use log::debug;\n@@ -192,7 +193,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n     fn visit_variant_data(\n         &mut self,\n         s: &'tcx hir::VariantData<'tcx>,\n-        _: ast::Name,\n+        _: Symbol,\n         _: &'tcx hir::Generics<'tcx>,\n         _: hir::HirId,\n         _: Span,\n@@ -227,7 +228,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         hir_visit::walk_ty(self, t);\n     }\n \n-    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n+    fn visit_name(&mut self, sp: Span, name: Symbol) {\n         lint_callback!(self, check_name, sp, name);\n     }\n "}, {"sha": "b791d313fc4f438a47e0e850da80401770ab3a6b", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -64,6 +64,7 @@ use rustc_session::lint::builtin::{\n     INTRA_DOC_LINK_RESOLUTION_FAILURE, INVALID_CODEBLOCK_ATTRIBUTE, MISSING_DOC_CODE_EXAMPLES,\n     PRIVATE_DOC_TESTS,\n };\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n use array_into_iter::ArrayIntoIter;"}, {"sha": "ad02b2637d22f1da7b6832aa08c9008271d8a689", "filename": "src/librustc_lint/non_ascii_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnon_ascii_idents.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,7 +1,7 @@\n use crate::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_span::symbol::SymbolStr;\n+use rustc_span::symbol::{Ident, SymbolStr};\n use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n \n@@ -155,7 +155,7 @@ impl EarlyLintPass for NonAsciiIdents {\n                 .or_insert((symbol_str, sp));\n         }\n     }\n-    fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: ast::Ident) {\n+    fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         use unicode_security::GeneralSecurityProfile;\n         let name_str = ident.name.as_str();\n         if name_str.is_ascii() {"}, {"sha": "04a398a29ba7b916c63a675158f617fb6689a584", "filename": "src/librustc_lint/passes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_lint%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fpasses.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -5,6 +5,7 @@ use rustc_data_structures::sync;\n use rustc_hir as hir;\n use rustc_session::lint::builtin::HardwiredLints;\n use rustc_session::lint::LintPass;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n #[macro_export]\n@@ -14,7 +15,7 @@ macro_rules! late_lint_methods {\n             fn check_param(a: &$hir hir::Param<$hir>);\n             fn check_body(a: &$hir hir::Body<$hir>);\n             fn check_body_post(a: &$hir hir::Body<$hir>);\n-            fn check_name(a: Span, b: ast::Name);\n+            fn check_name(a: Span, b: Symbol);\n             fn check_crate(a: &$hir hir::Crate<$hir>);\n             fn check_crate_post(a: &$hir hir::Crate<$hir>);\n             fn check_mod(a: &$hir hir::Mod<$hir>, b: Span, c: hir::HirId);\n@@ -155,7 +156,7 @@ macro_rules! early_lint_methods {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n             fn check_param(a: &ast::Param);\n-            fn check_ident(a: ast::Ident);\n+            fn check_ident(a: Ident);\n             fn check_crate(a: &ast::Crate);\n             fn check_crate_post(a: &ast::Crate);\n             fn check_mod(a: &ast::Mod, b: Span, c: ast::NodeId);"}, {"sha": "32149c0afd597f7445e3f54455270e73ef9cd989", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -4,7 +4,7 @@ use crate::creader::CrateMetadataRef;\n use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n-use rustc_ast::ast::{self, Ident};\n+use rustc_ast::ast;\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -33,7 +33,7 @@ use rustc_middle::util::common::record_time;\n use rustc_serialize::{opaque, Decodable, Decoder, SpecializedDecoder};\n use rustc_session::Session;\n use rustc_span::source_map::{respan, Spanned};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, hygiene::MacroKind, BytePos, Pos, Span, DUMMY_SP};\n \n use log::debug;\n@@ -917,7 +917,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n+    fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Option<Symbol>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root.lib_features.decode(self))\n@@ -1205,7 +1205,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .collect::<Vec<_>>()\n     }\n \n-    fn get_struct_field_names(&self, id: DefIndex, sess: &Session) -> Vec<Spanned<ast::Name>> {\n+    fn get_struct_field_names(&self, id: DefIndex, sess: &Session) -> Vec<Spanned<Symbol>> {\n         self.root\n             .tables\n             .children\n@@ -1317,7 +1317,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [ast::Name] {\n+    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Symbol] {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) | EntryKind::ForeignFn(data) => data.decode(self).param_names,\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.param_names,"}, {"sha": "b18272675c0b25a87a27fb8eca209b00514450dd", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::query::QueryConfig;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::{CrateDisambiguator, Session};\n use rustc_span::source_map::{self, Span, Spanned};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n \n use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n@@ -419,7 +419,7 @@ impl CStore {\n             .disambiguated_data\n             .data\n             .get_opt_name()\n-            .map(ast::Ident::with_dummy_span) // FIXME: cross-crate hygiene\n+            .map(Ident::with_dummy_span) // FIXME: cross-crate hygiene\n             .expect(\"no name in load_macro\");\n \n         LoadedMacro::MacroDef("}, {"sha": "2589e162dffe21c2ea416f0ed093790aa855c6a1", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2,7 +2,7 @@ use crate::rmeta::table::FixedSizeEncoding;\n use crate::rmeta::*;\n \n use log::{debug, trace};\n-use rustc_ast::ast::{self, Ident};\n+use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -32,7 +32,7 @@ use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n use rustc_session::config::CrateType;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n use rustc_target::abi::VariantIdx;\n use std::hash::Hash;\n@@ -989,7 +989,7 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[ast::Name]> {\n+    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[Symbol]> {\n         self.tcx.dep_graph.with_ignore(|| {\n             let body = self.tcx.hir().body(body_id);\n             self.lazy(body.params.iter().map(|arg| match arg.pat.kind {\n@@ -999,7 +999,7 @@ impl EncodeContext<'tcx> {\n         })\n     }\n \n-    fn encode_fn_param_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n+    fn encode_fn_param_names(&mut self, param_names: &[Ident]) -> Lazy<[Symbol]> {\n         self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n@@ -1410,7 +1410,7 @@ impl EncodeContext<'tcx> {\n         self.lazy(deps.iter().map(|&(_, ref dep)| dep))\n     }\n \n-    fn encode_lib_features(&mut self) -> Lazy<[(ast::Name, Option<ast::Name>)]> {\n+    fn encode_lib_features(&mut self) -> Lazy<[(Symbol, Option<Symbol>)]> {\n         let tcx = self.tcx;\n         let lib_features = tcx.lib_features();\n         self.lazy(lib_features.to_vec())"}, {"sha": "669307612055ae51636459a63c038e0b2c304cfc", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -215,7 +215,7 @@ crate struct CrateRoot<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct CrateDep {\n-    pub name: ast::Name,\n+    pub name: Symbol,\n     pub hash: Svh,\n     pub host_hash: Option<Svh>,\n     pub kind: DepKind,\n@@ -327,7 +327,7 @@ struct ModData {\n struct FnData {\n     asyncness: hir::IsAsync,\n     constness: hir::Constness,\n-    param_names: Lazy<[ast::Name]>,\n+    param_names: Lazy<[Symbol]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "8a1317ba2893f2ffda394c98eda9ff453c4b1989", "filename": "src/librustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FCargo.toml?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -31,6 +31,7 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n byteorder = { version = \"1.3\" }\n+chalk-ir = \"0.10.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "a97db3134dc9e97fcd7be67da34bb7a563448649", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -65,7 +65,7 @@ macro_rules! arena_types {\n             [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation,\n             [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>,\n             [] attribute: rustc_ast::ast::Attribute,\n-            [] name_set: rustc_data_structures::fx::FxHashSet<rustc_ast::ast::Name>,\n+            [] name_set: rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>,\n             [] hir_id_set: rustc_hir::HirIdSet,\n \n             // Interned types"}, {"sha": "330379008801057ffd765b411d3219ceb080ed0a", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -51,6 +51,7 @@\n \n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n+use crate::traits;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,"}, {"sha": "83baf6cc433452668259366ebfeda2d951cf95e2", "filename": "src/librustc_middle/hir/exports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fexports.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,9 +1,9 @@\n use crate::ty;\n \n-use rustc_ast::ast;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::DefIdMap;\n use rustc_macros::HashStable;\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n use std::fmt::Debug;\n@@ -15,7 +15,7 @@ pub type ExportMap<Id> = DefIdMap<Vec<Export<Id>>>;\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Export<Id> {\n     /// The name of the target.\n-    pub ident: ast::Ident,\n+    pub ident: Ident,\n     /// The resolution of the target.\n     pub res: Res<Id>,\n     /// The span of the target."}, {"sha": "a2e4372f017cedb150da24e24b54e8537380a1a3", "filename": "src/librustc_middle/hir/map/blocks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fblocks.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -12,10 +12,11 @@\n //! for the `Code` associated with a particular NodeId.\n \n use crate::hir::map::Map;\n-use rustc_ast::ast::{Attribute, Ident};\n+use rustc_ast::ast::Attribute;\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Expr, FnDecl, Node};\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n /// An FnLikeNode is a Node that is like a fn, in that it has a decl"}, {"sha": "de0373c138497bd54fc39f03ee8c6ca6cf230539", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,7 +3,7 @@ use self::collector::NodeCollector;\n use crate::hir::{Owner, OwnerNodes};\n use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n-use rustc_ast::ast::{self, Name, NodeId};\n+use rustc_ast::ast::{self, NodeId};\n use rustc_data_structures::svh::Svh;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -14,7 +14,7 @@ use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n@@ -452,7 +452,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn ty_param_name(&self, id: HirId) -> Name {\n+    pub fn ty_param_name(&self, id: HirId) -> Symbol {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => {\n                 kw::SelfUpper\n@@ -824,7 +824,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn opt_name(&self, id: HirId) -> Option<Name> {\n+    pub fn opt_name(&self, id: HirId) -> Option<Symbol> {\n         Some(match self.get(id) {\n             Node::Item(i) => i.ident.name,\n             Node::ForeignItem(fi) => fi.ident.name,\n@@ -840,7 +840,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn name(&self, id: HirId) -> Name {\n+    pub fn name(&self, id: HirId) -> Symbol {\n         match self.opt_name(id) {\n             Some(name) => name,\n             None => bug!(\"no name for {}\", self.node_to_string(id)),\n@@ -952,42 +952,42 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n }\n \n trait Named {\n-    fn name(&self) -> Name;\n+    fn name(&self) -> Symbol;\n }\n \n impl<T: Named> Named for Spanned<T> {\n-    fn name(&self) -> Name {\n+    fn name(&self) -> Symbol {\n         self.node.name()\n     }\n }\n \n impl Named for Item<'_> {\n-    fn name(&self) -> Name {\n+    fn name(&self) -> Symbol {\n         self.ident.name\n     }\n }\n impl Named for ForeignItem<'_> {\n-    fn name(&self) -> Name {\n+    fn name(&self) -> Symbol {\n         self.ident.name\n     }\n }\n impl Named for Variant<'_> {\n-    fn name(&self) -> Name {\n+    fn name(&self) -> Symbol {\n         self.ident.name\n     }\n }\n impl Named for StructField<'_> {\n-    fn name(&self) -> Name {\n+    fn name(&self) -> Symbol {\n         self.ident.name\n     }\n }\n impl Named for TraitItem<'_> {\n-    fn name(&self) -> Name {\n+    fn name(&self) -> Symbol {\n         self.ident.name\n     }\n }\n impl Named for ImplItem<'_> {\n-    fn name(&self) -> Name {\n+    fn name(&self) -> Symbol {\n         self.ident.name\n     }\n }"}, {"sha": "377c8661cbd4169771bfb5dd18870d004f16f47f", "filename": "src/librustc_middle/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -136,8 +136,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            let alloc_kind = tcx.alloc_map.lock().get(*self);\n-            alloc_kind.hash_stable(hcx, hasher);\n+            tcx.get_global_alloc(*self).hash_stable(hcx, hasher);\n         });\n     }\n }"}, {"sha": "b17a77e0f6fa79d8edb13303a16243b45c5ed53b", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -42,6 +42,7 @@\n #![feature(or_patterns)]\n #![feature(range_is_empty)]\n #![feature(specialization)]\n+#![feature(track_caller)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "71adb2fa477ad00d1a5c3c4c8e88cd7db39bf1c2", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 70, "deletions": 46, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -197,9 +197,7 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc: GlobalAlloc<'tcx> =\n-        tcx.alloc_map.lock().get(alloc_id).expect(\"no value for given alloc ID\");\n-    match alloc {\n+    match tcx.global_alloc(alloc_id) {\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             AllocDiscriminant::Alloc.encode(encoder)?;\n@@ -294,7 +292,7 @@ impl<'s> AllocDecodingSession<'s> {\n                         AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n                             // `AllocId` so we can decode cyclic graphs.\n-                            let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n+                            let alloc_id = decoder.tcx().reserve_alloc_id();\n                             *entry =\n                                 State::InProgress(TinyList::new_single(self.session_id), alloc_id);\n                             Some(alloc_id)\n@@ -338,23 +336,23 @@ impl<'s> AllocDecodingSession<'s> {\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n-                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, alloc);\n+                    decoder.tcx().set_alloc_id_same_memory(alloc_id, alloc);\n                     Ok(alloc_id)\n                 }\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc ID\");\n                     let instance = ty::Instance::decode(decoder)?;\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                    let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n+                    let alloc_id = decoder.tcx().create_fn_alloc(instance);\n                     Ok(alloc_id)\n                 }\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n                     let did = DefId::decode(decoder)?;\n                     trace!(\"decoded static def-ID: {:?}\", did);\n-                    let alloc_id = decoder.tcx().alloc_map.lock().create_static_alloc(did);\n+                    let alloc_id = decoder.tcx().create_static_alloc(did);\n                     Ok(alloc_id)\n                 }\n             }\n@@ -381,7 +379,29 @@ pub enum GlobalAlloc<'tcx> {\n     Memory(&'tcx Allocation),\n }\n \n-pub struct AllocMap<'tcx> {\n+impl GlobalAlloc<'tcx> {\n+    /// Panics if the `GlobalAlloc` does not refer to an `GlobalAlloc::Memory`\n+    #[track_caller]\n+    #[inline]\n+    pub fn unwrap_memory(&self) -> &'tcx Allocation {\n+        match *self {\n+            GlobalAlloc::Memory(mem) => mem,\n+            _ => bug!(\"expected memory, got {:?}\", self),\n+        }\n+    }\n+\n+    /// Panics if the `GlobalAlloc` is not `GlobalAlloc::Function`\n+    #[track_caller]\n+    #[inline]\n+    pub fn unwrap_fn(&self) -> Instance<'tcx> {\n+        match *self {\n+            GlobalAlloc::Function(instance) => instance,\n+            _ => bug!(\"expected function, got {:?}\", self),\n+        }\n+    }\n+}\n+\n+crate struct AllocMap<'tcx> {\n     /// Maps `AllocId`s to their corresponding allocations.\n     alloc_map: FxHashMap<AllocId, GlobalAlloc<'tcx>>,\n \n@@ -397,16 +417,10 @@ pub struct AllocMap<'tcx> {\n }\n \n impl<'tcx> AllocMap<'tcx> {\n-    pub fn new() -> Self {\n+    crate fn new() -> Self {\n         AllocMap { alloc_map: Default::default(), dedup: Default::default(), next_id: AllocId(0) }\n     }\n-\n-    /// Obtains a new allocation ID that can be referenced but does not\n-    /// yet have an allocation backing it.\n-    ///\n-    /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n-    /// an `AllocId` from a query.\n-    pub fn reserve(&mut self) -> AllocId {\n+    fn reserve(&mut self) -> AllocId {\n         let next = self.next_id;\n         self.next_id.0 = self.next_id.0.checked_add(1).expect(\n             \"You overflowed a u64 by incrementing by 1... \\\n@@ -415,34 +429,46 @@ impl<'tcx> AllocMap<'tcx> {\n         );\n         next\n     }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// Obtains a new allocation ID that can be referenced but does not\n+    /// yet have an allocation backing it.\n+    ///\n+    /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n+    /// an `AllocId` from a query.\n+    pub fn reserve_alloc_id(&self) -> AllocId {\n+        self.alloc_map.lock().reserve()\n+    }\n \n     /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n     /// Should only be used for function pointers and statics, we don't want\n     /// to dedup IDs for \"real\" memory!\n-    fn reserve_and_set_dedup(&mut self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n+    fn reserve_and_set_dedup(&self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n+        let mut alloc_map = self.alloc_map.lock();\n         match alloc {\n             GlobalAlloc::Function(..) | GlobalAlloc::Static(..) => {}\n             GlobalAlloc::Memory(..) => bug!(\"Trying to dedup-reserve memory with real data!\"),\n         }\n-        if let Some(&alloc_id) = self.dedup.get(&alloc) {\n+        if let Some(&alloc_id) = alloc_map.dedup.get(&alloc) {\n             return alloc_id;\n         }\n-        let id = self.reserve();\n+        let id = alloc_map.reserve();\n         debug!(\"creating alloc {:?} with id {}\", alloc, id);\n-        self.alloc_map.insert(id, alloc.clone());\n-        self.dedup.insert(alloc, id);\n+        alloc_map.alloc_map.insert(id, alloc.clone());\n+        alloc_map.dedup.insert(alloc, id);\n         id\n     }\n \n     /// Generates an `AllocId` for a static or return a cached one in case this function has been\n     /// called on the same static before.\n-    pub fn create_static_alloc(&mut self, static_id: DefId) -> AllocId {\n+    pub fn create_static_alloc(&self, static_id: DefId) -> AllocId {\n         self.reserve_and_set_dedup(GlobalAlloc::Static(static_id))\n     }\n \n     /// Generates an `AllocId` for a function.  Depending on the function type,\n     /// this might get deduplicated or assigned a new ID each time.\n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n+    pub fn create_fn_alloc(&self, instance: Instance<'tcx>) -> AllocId {\n         // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n         // by the linker (we set the \"unnamed_addr\" attribute for LLVM) and functions can be\n         // duplicated across crates.\n@@ -456,8 +482,9 @@ impl<'tcx> AllocMap<'tcx> {\n         });\n         if is_generic {\n             // Get a fresh ID.\n-            let id = self.reserve();\n-            self.alloc_map.insert(id, GlobalAlloc::Function(instance));\n+            let mut alloc_map = self.alloc_map.lock();\n+            let id = alloc_map.reserve();\n+            alloc_map.alloc_map.insert(id, GlobalAlloc::Function(instance));\n             id\n         } else {\n             // Deduplicate.\n@@ -470,8 +497,8 @@ impl<'tcx> AllocMap<'tcx> {\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n     /// their data will be deduplicated through `Allocation` interning -- but they\n     /// are different places in memory and as such need different IDs.\n-    pub fn create_memory_alloc(&mut self, mem: &'tcx Allocation) -> AllocId {\n-        let id = self.reserve();\n+    pub fn create_memory_alloc(&self, mem: &'tcx Allocation) -> AllocId {\n+        let id = self.reserve_alloc_id();\n         self.set_alloc_id_memory(id, mem);\n         id\n     }\n@@ -482,38 +509,35 @@ impl<'tcx> AllocMap<'tcx> {\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n     #[inline]\n-    pub fn get(&self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n-        self.alloc_map.get(&id).cloned()\n-    }\n-\n-    /// Panics if the `AllocId` does not refer to an `Allocation`\n-    pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n-        match self.get(id) {\n-            Some(GlobalAlloc::Memory(mem)) => mem,\n-            _ => bug!(\"expected allocation ID {} to point to memory\", id),\n-        }\n+    pub fn get_global_alloc(&self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n+        self.alloc_map.lock().alloc_map.get(&id).cloned()\n     }\n \n-    /// Panics if the `AllocId` does not refer to a function\n-    pub fn unwrap_fn(&self, id: AllocId) -> Instance<'tcx> {\n-        match self.get(id) {\n-            Some(GlobalAlloc::Function(instance)) => instance,\n-            _ => bug!(\"expected allocation ID {} to point to a function\", id),\n+    #[inline]\n+    #[track_caller]\n+    /// Panics in case the `AllocId` is dangling. Since that is impossible for `AllocId`s in\n+    /// constants (as all constants must pass interning and validation that check for dangling\n+    /// ids), this function is frequently used throughout rustc, but should not be used within\n+    /// the miri engine.\n+    pub fn global_alloc(&self, id: AllocId) -> GlobalAlloc<'tcx> {\n+        match self.get_global_alloc(id) {\n+            Some(alloc) => alloc,\n+            None => bug!(\"could not find allocation for {}\", id),\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n-    pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        if let Some(old) = self.alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n+    pub fn set_alloc_id_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+        if let Some(old) = self.alloc_map.lock().alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n             bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n-    fn set_alloc_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        self.alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n+    fn set_alloc_id_same_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+        self.alloc_map.lock().alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n     }\n }\n "}, {"sha": "62e6e1249818a36dce9ecae470ea96f821764914", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -19,7 +19,6 @@ use rustc_target::abi::VariantIdx;\n \n use polonius_engine::Atom;\n pub use rustc_ast::ast::Mutability;\n-use rustc_ast::ast::Name;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors};\n@@ -968,7 +967,7 @@ impl<'tcx> LocalDecl<'tcx> {\n /// Debug information pertaining to a user variable.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub struct VarDebugInfo<'tcx> {\n-    pub name: Name,\n+    pub name: Symbol,\n \n     /// Source info of the user variable, including the scope\n     /// within which the variable is visible (to debuginfo)\n@@ -2404,13 +2403,9 @@ pub struct Constant<'tcx> {\n impl Constant<'tcx> {\n     pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n         match self.literal.val.try_to_scalar() {\n-            Some(Scalar::Ptr(ptr)) => match tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                Some(GlobalAlloc::Static(def_id)) => Some(def_id),\n-                Some(_) => None,\n-                None => {\n-                    tcx.sess.delay_span_bug(DUMMY_SP, \"MIR cannot contain dangling const pointers\");\n-                    None\n-                }\n+            Some(Scalar::Ptr(ptr)) => match tcx.global_alloc(ptr.alloc_id) {\n+                GlobalAlloc::Static(def_id) => Some(def_id),\n+                _ => None,\n             },\n             _ => None,\n         }"}, {"sha": "2ceba51949420dc6501f25a3b229ee0758b5d9e3", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,7 @@\n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n+use crate::traits;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n@@ -639,7 +640,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query fn_arg_names(_: DefId) -> &'tcx [ast::Name] {}\n+        query fn_arg_names(_: DefId) -> &'tcx [Symbol] {}\n         /// Gets the rendered value of the specified constant or associated constant.\n         /// Used by rustdoc.\n         query rendered_const(_: DefId) -> String {}\n@@ -1052,7 +1053,7 @@ rustc_queries! {\n             desc { \"looking up all possibly unused extern crates\" }\n         }\n         query names_imported_by_glob_use(def_id: LocalDefId)\n-            -> &'tcx FxHashSet<ast::Name> {\n+            -> &'tcx FxHashSet<Symbol> {\n             eval_always\n             desc { |tcx| \"names_imported_by_glob_use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n         }\n@@ -1154,6 +1155,15 @@ rustc_queries! {\n             desc { \"evaluating trait selection obligation `{}`\", goal.value.value }\n         }\n \n+        query evaluate_goal(\n+            goal: traits::ChalkCanonicalGoal<'tcx>\n+        ) -> Result<\n+            &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n+            NoSolution\n+        > {\n+            desc { \"evaluating trait selection obligation `{}`\", goal.value }\n+        }\n+\n         /// Do not call this query directly: part of the `Eq` type-op\n         query type_op_ascribe_user_type(\n             goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>"}, {"sha": "b963af96f5027cd5b96207353c02e1f8f386908e", "filename": "src/librustc_middle/traits/chalk.rs", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,366 @@\n+//! Types required for Chalk-related queries\n+//!\n+//! The primary purpose of this file is defining an implementation for the\n+//! `chalk_ir::interner::Interner` trait. The primary purpose of this trait, as\n+//! its name suggest, is to provide an abstraction boundary for creating\n+//! interned Chalk types.\n+\n+use chalk_ir::{GoalData, Parameter};\n+\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+use rustc_hir::def_id::DefId;\n+\n+use smallvec::SmallVec;\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::hash::{Hash, Hasher};\n+\n+/// Since Chalk doesn't have full support for all Rust builtin types yet, we\n+/// need to use an enum here, rather than just `DefId`.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum RustDefId {\n+    Adt(DefId),\n+    Str,\n+    Never,\n+    Slice,\n+    Array,\n+    Ref(Mutability),\n+    RawPtr,\n+\n+    Trait(DefId),\n+\n+    Impl(DefId),\n+\n+    FnDef(DefId),\n+\n+    AssocTy(DefId),\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct RustInterner<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> Hash for RustInterner<'tcx> {\n+    fn hash<H: Hasher>(&self, _state: &mut H) {}\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> Ord for RustInterner<'tcx> {\n+    fn cmp(&self, _other: &Self) -> Ordering {\n+        Ordering::Equal\n+    }\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> PartialOrd for RustInterner<'tcx> {\n+    fn partial_cmp(&self, _other: &Self) -> Option<Ordering> {\n+        None\n+    }\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> PartialEq for RustInterner<'tcx> {\n+    fn eq(&self, _other: &Self) -> bool {\n+        false\n+    }\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> Eq for RustInterner<'tcx> {}\n+\n+impl fmt::Debug for RustInterner<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"RustInterner\")\n+    }\n+}\n+\n+// Right now, there is no interning at all. I was running into problems with\n+// adding interning in `ty/context.rs` for Chalk types with\n+// `parallel-compiler = true`. -jackh726\n+impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n+    type InternedType = Box<chalk_ir::TyData<Self>>;\n+    type InternedLifetime = Box<chalk_ir::LifetimeData<Self>>;\n+    type InternedParameter = Box<chalk_ir::ParameterData<Self>>;\n+    type InternedGoal = Box<chalk_ir::GoalData<Self>>;\n+    type InternedGoals = Vec<chalk_ir::Goal<Self>>;\n+    type InternedSubstitution = Vec<chalk_ir::Parameter<Self>>;\n+    type InternedProgramClause = Box<chalk_ir::ProgramClauseData<Self>>;\n+    type InternedProgramClauses = Vec<chalk_ir::ProgramClause<Self>>;\n+    type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n+    type InternedParameterKinds = Vec<chalk_ir::ParameterKind<()>>;\n+    type InternedCanonicalVarKinds = Vec<chalk_ir::ParameterKind<chalk_ir::UniverseIndex>>;\n+    type DefId = RustDefId;\n+    type Identifier = ();\n+\n+    fn debug_program_clause_implication(\n+        pci: &chalk_ir::ProgramClauseImplication<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        let mut write = || {\n+            write!(fmt, \"{:?}\", pci.consequence)?;\n+\n+            let conditions = pci.conditions.interned();\n+\n+            let conds = conditions.len();\n+            if conds == 0 {\n+                return Ok(());\n+            }\n+\n+            write!(fmt, \" :- \")?;\n+            for cond in &conditions[..conds - 1] {\n+                write!(fmt, \"{:?}, \", cond)?;\n+            }\n+            write!(fmt, \"{:?}\", conditions[conds - 1])?;\n+            Ok(())\n+        };\n+        Some(write())\n+    }\n+\n+    fn debug_application_ty(\n+        application_ty: &chalk_ir::ApplicationTy<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n+        Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n+    }\n+\n+    fn debug_substitution(\n+        substitution: &chalk_ir::Substitution<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", substitution.interned()))\n+    }\n+\n+    fn debug_separator_trait_ref(\n+        separator_trait_ref: &chalk_ir::SeparatorTraitRef<'_, Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        let substitution = &separator_trait_ref.trait_ref.substitution;\n+        let parameters = substitution.interned();\n+        Some(write!(\n+            fmt,\n+            \"{:?}{}{:?}{:?}\",\n+            parameters[0],\n+            separator_trait_ref.separator,\n+            separator_trait_ref.trait_ref.trait_id,\n+            chalk_ir::debug::Angle(&parameters[1..])\n+        ))\n+    }\n+\n+    fn debug_quantified_where_clauses(\n+        clauses: &chalk_ir::QuantifiedWhereClauses<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", clauses.interned()))\n+    }\n+\n+    fn debug_alias(\n+        alias_ty: &chalk_ir::AliasTy<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        match alias_ty {\n+            chalk_ir::AliasTy::Projection(projection_ty) => {\n+                Self::debug_projection_ty(projection_ty, fmt)\n+            }\n+            chalk_ir::AliasTy::Opaque(opaque_ty) => Self::debug_opaque_ty(opaque_ty, fmt),\n+        }\n+    }\n+\n+    fn debug_projection_ty(\n+        projection_ty: &chalk_ir::ProjectionTy<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(\n+            fmt,\n+            \"projection: {:?} {:?}\",\n+            projection_ty.associated_ty_id, projection_ty.substitution,\n+        ))\n+    }\n+\n+    fn debug_opaque_ty(\n+        opaque_ty: &chalk_ir::OpaqueTy<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", opaque_ty.opaque_ty_id))\n+    }\n+\n+    fn intern_ty(&self, ty: chalk_ir::TyData<Self>) -> Self::InternedType {\n+        Box::new(ty)\n+    }\n+\n+    fn ty_data<'a>(&self, ty: &'a Self::InternedType) -> &'a chalk_ir::TyData<Self> {\n+        ty\n+    }\n+\n+    fn intern_lifetime(&self, lifetime: chalk_ir::LifetimeData<Self>) -> Self::InternedLifetime {\n+        Box::new(lifetime)\n+    }\n+\n+    fn lifetime_data<'a>(\n+        &self,\n+        lifetime: &'a Self::InternedLifetime,\n+    ) -> &'a chalk_ir::LifetimeData<Self> {\n+        &lifetime\n+    }\n+\n+    fn intern_parameter(\n+        &self,\n+        parameter: chalk_ir::ParameterData<Self>,\n+    ) -> Self::InternedParameter {\n+        Box::new(parameter)\n+    }\n+\n+    fn parameter_data<'a>(\n+        &self,\n+        parameter: &'a Self::InternedParameter,\n+    ) -> &'a chalk_ir::ParameterData<Self> {\n+        &parameter\n+    }\n+\n+    fn intern_goal(&self, goal: GoalData<Self>) -> Self::InternedGoal {\n+        Box::new(goal)\n+    }\n+\n+    fn goal_data<'a>(&self, goal: &'a Self::InternedGoal) -> &'a GoalData<Self> {\n+        &goal\n+    }\n+\n+    fn intern_goals<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::Goal<Self>, E>>,\n+    ) -> Result<Self::InternedGoals, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn goals_data<'a>(&self, goals: &'a Self::InternedGoals) -> &'a [chalk_ir::Goal<Self>] {\n+        goals\n+    }\n+\n+    fn intern_substitution<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::Parameter<Self>, E>>,\n+    ) -> Result<Self::InternedSubstitution, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn substitution_data<'a>(\n+        &self,\n+        substitution: &'a Self::InternedSubstitution,\n+    ) -> &'a [Parameter<Self>] {\n+        substitution\n+    }\n+\n+    fn intern_program_clause(\n+        &self,\n+        data: chalk_ir::ProgramClauseData<Self>,\n+    ) -> Self::InternedProgramClause {\n+        Box::new(data)\n+    }\n+\n+    fn program_clause_data<'a>(\n+        &self,\n+        clause: &'a Self::InternedProgramClause,\n+    ) -> &'a chalk_ir::ProgramClauseData<Self> {\n+        &clause\n+    }\n+\n+    fn intern_program_clauses<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::ProgramClause<Self>, E>>,\n+    ) -> Result<Self::InternedProgramClauses, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn program_clauses_data<'a>(\n+        &self,\n+        clauses: &'a Self::InternedProgramClauses,\n+    ) -> &'a [chalk_ir::ProgramClause<Self>] {\n+        clauses\n+    }\n+\n+    fn intern_quantified_where_clauses<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::QuantifiedWhereClause<Self>, E>>,\n+    ) -> Result<Self::InternedQuantifiedWhereClauses, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn quantified_where_clauses_data<'a>(\n+        &self,\n+        clauses: &'a Self::InternedQuantifiedWhereClauses,\n+    ) -> &'a [chalk_ir::QuantifiedWhereClause<Self>] {\n+        clauses\n+    }\n+\n+    fn intern_parameter_kinds<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::ParameterKind<()>, E>>,\n+    ) -> Result<Self::InternedParameterKinds, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn parameter_kinds_data<'a>(\n+        &self,\n+        parameter_kinds: &'a Self::InternedParameterKinds,\n+    ) -> &'a [chalk_ir::ParameterKind<()>] {\n+        parameter_kinds\n+    }\n+\n+    fn intern_canonical_var_kinds<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::ParameterKind<chalk_ir::UniverseIndex>, E>>,\n+    ) -> Result<Self::InternedCanonicalVarKinds, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn canonical_var_kinds_data<'a>(\n+        &self,\n+        canonical_var_kinds: &'a Self::InternedCanonicalVarKinds,\n+    ) -> &'a [chalk_ir::ParameterKind<chalk_ir::UniverseIndex>] {\n+        canonical_var_kinds\n+    }\n+}\n+\n+impl<'tcx> chalk_ir::interner::HasInterner for RustInterner<'tcx> {\n+    type Interner = Self;\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub enum ChalkEnvironmentClause<'tcx> {\n+    /// A normal rust `ty::Predicate` in the environment.\n+    Predicate(ty::Predicate<'tcx>),\n+    /// A special clause in the environment that gets lowered to\n+    /// `chalk_ir::FromEnv::Ty`.\n+    TypeFromEnv(Ty<'tcx>),\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ChalkEnvironmentClause<'tcx>> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+        folder.tcx().intern_chalk_environment_clause_list(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+/// We have to elaborate the environment of a chalk goal *before*\n+/// canonicalization. This type wraps the predicate and the elaborated\n+/// environment.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct ChalkEnvironmentAndGoal<'tcx> {\n+    pub environment: &'tcx ty::List<ChalkEnvironmentClause<'tcx>>,\n+    pub goal: ty::Predicate<'tcx>,\n+}\n+\n+impl<'tcx> fmt::Display for ChalkEnvironmentAndGoal<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"environment: {:?}, goal: {}\", self.environment, self.goal)\n+    }\n+}"}, {"sha": "1254174a7a5f9690d782ac4739bf8b518a7434fe", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2,18 +2,20 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/resolution.html\n \n+mod chalk;\n pub mod query;\n pub mod select;\n pub mod specialization_graph;\n mod structural_impls;\n \n+use crate::infer::canonical::Canonical;\n use crate::mir::interpret::ErrorHandled;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n \n-use rustc_ast::ast;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::SmallVec;\n \n@@ -23,10 +25,17 @@ use std::rc::Rc;\n \n pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n \n+pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx>>;\n+\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n pub use self::Vtable::*;\n \n+pub use self::chalk::{\n+    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustDefId as ChalkRustDefId,\n+    RustInterner as ChalkRustInterner,\n+};\n+\n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n@@ -198,14 +207,14 @@ pub enum ObligationCauseCode<'tcx> {\n \n     /// Error derived when matching traits/impls; see ObligationCause for more details\n     CompareImplMethodObligation {\n-        item_name: ast::Name,\n+        item_name: Symbol,\n         impl_item_def_id: DefId,\n         trait_item_def_id: DefId,\n     },\n \n     /// Error derived when matching traits/impls; see ObligationCause for more details\n     CompareImplTypeObligation {\n-        item_name: ast::Name,\n+        item_name: Symbol,\n         impl_item_def_id: DefId,\n         trait_item_def_id: DefId,\n     },\n@@ -566,10 +575,10 @@ pub enum ObjectSafetyViolation {\n     SupertraitSelf(SmallVec<[Span; 1]>),\n \n     /// Method has something illegal.\n-    Method(ast::Name, MethodViolationCode, Span),\n+    Method(Symbol, MethodViolationCode, Span),\n \n     /// Associated const.\n-    AssocConst(ast::Name, Span),\n+    AssocConst(Symbol, Span),\n }\n \n impl ObjectSafetyViolation {"}, {"sha": "4f02aaa96acd3026421407e741175f272f250288", "filename": "src/librustc_middle/traits/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,11 +1,11 @@\n use crate::ich::{self, StableHashingContext};\n use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::{self, TyCtxt};\n-use rustc_ast::ast::Ident;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::{DefId, DefIdMap};\n+use rustc_span::symbol::Ident;\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes"}, {"sha": "86b740b8503b81cff91aaae03a57d191b931a292", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -93,6 +93,8 @@ pub struct CtxtInterners<'tcx> {\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n+\n+    chalk_environment_clause_list: InternedSet<'tcx, List<traits::ChalkEnvironmentClause<'tcx>>>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -109,6 +111,8 @@ impl<'tcx> CtxtInterners<'tcx> {\n             projs: Default::default(),\n             place_elems: Default::default(),\n             const_: Default::default(),\n+\n+            chalk_environment_clause_list: Default::default(),\n         }\n     }\n \n@@ -376,7 +380,7 @@ pub struct TypeckTables<'tcx> {\n \n     /// Records the reasons that we picked the kind of each closure;\n     /// not all closures are present in the map.\n-    closure_kind_origins: ItemLocalMap<(Span, ast::Name)>,\n+    closure_kind_origins: ItemLocalMap<(Span, Symbol)>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n@@ -621,11 +625,11 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n \n-    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, ast::Name)> {\n+    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, Symbol)> {\n         LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n     }\n \n-    pub fn closure_kind_origins_mut(&mut self) -> LocalTableInContextMut<'_, (Span, ast::Name)> {\n+    pub fn closure_kind_origins_mut(&mut self) -> LocalTableInContextMut<'_, (Span, Symbol)> {\n         LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n     }\n \n@@ -941,10 +945,10 @@ pub struct GlobalCtxt<'tcx> {\n     maybe_unused_extern_crates: Vec<(DefId, Span)>,\n     /// A map of glob use to a set of names it actually imports. Currently only\n     /// used in save-analysis.\n-    glob_map: FxHashMap<LocalDefId, FxHashSet<ast::Name>>,\n+    glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n     /// Extern prelude entries. The value is `true` if the entry was introduced\n     /// via `extern crate` item and not `--extern` option or compiler built-in.\n-    pub extern_prelude: FxHashMap<ast::Name, bool>,\n+    pub extern_prelude: FxHashMap<Symbol, bool>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -975,7 +979,7 @@ pub struct GlobalCtxt<'tcx> {\n     allocation_interner: ShardedHashMap<&'tcx Allocation, ()>,\n \n     /// Stores memory for globals (statics/consts).\n-    pub alloc_map: Lock<interpret::AllocMap<'tcx>>,\n+    pub(crate) alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n     layout_interner: ShardedHashMap<&'tcx Layout, ()>,\n \n@@ -1013,7 +1017,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Create an allocation that just contains these bytes.\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n-        self.alloc_map.lock().create_memory_alloc(alloc)\n+        self.create_memory_alloc(alloc)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {\n@@ -1997,6 +2001,14 @@ impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n     }\n }\n \n+impl<'tcx> Borrow<[traits::ChalkEnvironmentClause<'tcx>]>\n+    for Interned<'tcx, List<traits::ChalkEnvironmentClause<'tcx>>>\n+{\n+    fn borrow<'a>(&'a self) -> &'a [traits::ChalkEnvironmentClause<'tcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n macro_rules! direct_interners {\n     ($($name:ident: $method:ident($ty:ty)),+) => {\n         $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n@@ -2044,7 +2056,9 @@ slice_interners!(\n     existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n     predicates: _intern_predicates(Predicate<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n-    place_elems: _intern_place_elems(PlaceElem<'tcx>)\n+    place_elems: _intern_place_elems(PlaceElem<'tcx>),\n+    chalk_environment_clause_list:\n+        _intern_chalk_environment_clause_list(traits::ChalkEnvironmentClause<'tcx>)\n );\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -2430,6 +2444,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { List::empty() } else { self._intern_canonical_var_infos(ts) }\n     }\n \n+    pub fn intern_chalk_environment_clause_list(\n+        self,\n+        ts: &[traits::ChalkEnvironmentClause<'tcx>],\n+    ) -> &'tcx List<traits::ChalkEnvironmentClause<'tcx>> {\n+        if ts.is_empty() { List::empty() } else { self._intern_chalk_environment_clause_list(ts) }\n+    }\n+\n     pub fn mk_fn_sig<I>(\n         self,\n         inputs: I,\n@@ -2487,6 +2508,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n     }\n \n+    pub fn mk_chalk_environment_clause_list<\n+        I: InternAs<\n+            [traits::ChalkEnvironmentClause<'tcx>],\n+            &'tcx List<traits::ChalkEnvironmentClause<'tcx>>,\n+        >,\n+    >(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n+        iter.intern_with(|xs| self.intern_chalk_environment_clause_list(xs))\n+    }\n+\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {"}, {"sha": "7c4e4d095bc5d95e3c3d09c5e87231059e1df473", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -4,13 +4,14 @@ use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n use crate::ty::subst::Subst;\n use crate::ty::{self, subst::SubstsRef, ReprOptions, Ty, TyCtxt, TypeFoldable};\n \n-use rustc_ast::ast::{self, Ident, IntTy, UintTy};\n+use rustc_ast::ast::{self, IntTy, UintTy};\n use rustc_attr as attr;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_session::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{\n     ArgAbi, ArgAttribute, ArgAttributes, Conv, FnAbi, PassMode, Reg, RegKind,\n@@ -1628,9 +1629,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let adt_kind = adt_def.adt_kind();\n         let adt_packed = adt_def.repr.pack.is_some();\n \n-        let build_variant_info = |n: Option<Ident>,\n-                                  flds: &[ast::Name],\n-                                  layout: TyAndLayout<'tcx>| {\n+        let build_variant_info = |n: Option<Ident>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n             let mut min_size = Size::ZERO;\n             let field_info: Vec<_> = flds\n                 .iter()"}, {"sha": "02fe7adcd07389718c8694d260559a651c79f306", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -17,7 +17,7 @@ use crate::traits::{self, Reveal};\n use crate::ty;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n-use rustc_ast::ast::{self, Ident, Name};\n+use rustc_ast::ast;\n use rustc_ast::node_id::{NodeId, NodeMap, NodeSet};\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n@@ -38,7 +38,7 @@ use rustc_macros::HashStable;\n use rustc_serialize::{self, Encodable, Encoder};\n use rustc_session::DataTypeKind;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::{Align, VariantIdx};\n \n@@ -128,7 +128,7 @@ pub struct ResolverOutputs {\n     pub glob_map: GlobMap,\n     /// Extern prelude entries. The value is `true` if the entry was introduced\n     /// via `extern crate` item and not `--extern` option or compiler built-in.\n-    pub extern_prelude: FxHashMap<Name, bool>,\n+    pub extern_prelude: FxHashMap<Symbol, bool>,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable)]"}, {"sha": "2684492a40695ddb398d2b5876ac90b98c6baa56", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -12,7 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Namespace};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_target::abi::{Integer, Size};\n use rustc_target::spec::abi::Abi;\n \n@@ -956,9 +956,8 @@ pub trait PrettyPrinter<'tcx>:\n             ) => {\n                 let byte_str = self\n                     .tcx()\n-                    .alloc_map\n-                    .lock()\n-                    .unwrap_memory(ptr.alloc_id)\n+                    .global_alloc(ptr.alloc_id)\n+                    .unwrap_memory()\n                     .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n                     .unwrap();\n                 p!(pretty_print_byte_str(byte_str));\n@@ -1021,10 +1020,7 @@ pub trait PrettyPrinter<'tcx>:\n                 )?;\n             }\n             (Scalar::Ptr(ptr), ty::FnPtr(_)) => {\n-                let instance = {\n-                    let alloc_map = self.tcx().alloc_map.lock();\n-                    alloc_map.unwrap_fn(ptr.alloc_id)\n-                };\n+                let instance = self.tcx().global_alloc(ptr.alloc_id).unwrap_fn();\n                 self = self.typed_value(\n                     |this| this.print_value_path(instance.def_id(), instance.substs),\n                     |this| this.print_type(ty),\n@@ -1456,7 +1452,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n             if !self.empty_path {\n                 write!(self, \"::\")?;\n             }\n-            if ast::Ident::from_str(&name).is_raw_guess() {\n+            if Ident::from_str(&name).is_raw_guess() {\n                 write!(self, \"r#\")?;\n             }\n             write!(self, \"{}\", name)?;"}, {"sha": "71c2c24cc0a9ff8b7d7139f5a5fb43e0ded3163e", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -4,7 +4,6 @@ use crate::mir::{self, interpret};\n use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n-use rustc_ast::ast::Ident;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, Once};\n@@ -20,6 +19,7 @@ use rustc_serialize::{\n use rustc_session::{CrateDisambiguator, Session};\n use rustc_span::hygiene::{ExpnId, SyntaxContext};\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n+use rustc_span::symbol::Ident;\n use rustc_span::CachingSourceMapView;\n use rustc_span::{BytePos, SourceFile, Span, DUMMY_SP};\n use std::mem;"}, {"sha": "9c198dd556ac3b8a70855de75d114a0b7b885e3d", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -549,9 +549,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                     if a_val == b_val {\n                         Ok(ConstValue::Scalar(a_val))\n                     } else if let ty::FnPtr(_) = a.ty.kind {\n-                        let alloc_map = tcx.alloc_map.lock();\n-                        let a_instance = alloc_map.unwrap_fn(a_val.assert_ptr().alloc_id);\n-                        let b_instance = alloc_map.unwrap_fn(b_val.assert_ptr().alloc_id);\n+                        let a_instance = tcx.global_alloc(a_val.assert_ptr().alloc_id).unwrap_fn();\n+                        let b_instance = tcx.global_alloc(b_val.assert_ptr().alloc_id).unwrap_fn();\n                         if a_instance == b_instance {\n                             Ok(ConstValue::Scalar(a_val))\n                         } else {"}, {"sha": "a6cf3b7e2ee74537a233c38ec3d1d5415a60b97a", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -16,14 +16,14 @@ use crate::ty::{\n };\n use crate::ty::{List, ParamEnv, ParamEnvAnd, TyS};\n use polonius_engine::Atom;\n-use rustc_ast::ast::{self, Ident};\n+use rustc_ast::ast;\n use rustc_data_structures::captures::Captures;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_target::abi::{Size, VariantIdx};\n use rustc_target::spec::abi;\n use std::borrow::Cow;"}, {"sha": "d3ab7df817b38c9713f7b9c8c433a180422efe60", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,5 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use rustc_ast::ast::Name;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n@@ -22,7 +21,7 @@ use rustc_middle::mir::{Terminator, TerminatorKind};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT, UNUSED_MUT};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{Span, Symbol, DUMMY_SP};\n \n use either::Either;\n use smallvec::SmallVec;\n@@ -77,7 +76,7 @@ crate use region_infer::RegionInferenceContext;\n // FIXME(eddyb) perhaps move this somewhere more centrally.\n #[derive(Debug)]\n crate struct Upvar {\n-    name: Name,\n+    name: Symbol,\n \n     var_hir_id: HirId,\n \n@@ -534,7 +533,7 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     upvars: Vec<Upvar>,\n \n     /// Names of local (user) variables (extracted from `var_debug_info`).\n-    local_names: IndexVec<Local, Option<Name>>,\n+    local_names: IndexVec<Local, Option<Symbol>>,\n \n     /// Record the region names generated for each region in the given\n     /// MIR def so that we can reuse them later in help/error messages."}, {"sha": "b6c635fb22ab5e674cd17cd332413e65effac7d5", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -130,7 +130,7 @@ pub(super) fn op_to_const<'tcx>(\n \n     let to_const_value = |mplace: MPlaceTy<'_>| match mplace.ptr {\n         Scalar::Ptr(ptr) => {\n-            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+            let alloc = ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory();\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n         Scalar::Raw { data, .. } => {\n@@ -155,7 +155,7 @@ pub(super) fn op_to_const<'tcx>(\n             Immediate::ScalarPair(a, b) => {\n                 let (data, start) = match a.not_undef().unwrap() {\n                     Scalar::Ptr(ptr) => {\n-                        (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n+                        (ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(), ptr.offset.bytes())\n                     }\n                     Scalar::Raw { .. } => (\n                         ecx.tcx\n@@ -203,7 +203,7 @@ fn validate_and_turn_into_const<'tcx>(\n         if is_static || cid.promoted.is_some() {\n             let ptr = mplace.ptr.assert_ptr();\n             Ok(ConstValue::ByRef {\n-                alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                alloc: ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(),\n                 offset: ptr.offset,\n             })\n         } else {"}, {"sha": "1c44101595d4f26f3c835d3c4fb59f1b09697ad1", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -91,7 +91,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n             // If the pointer is dangling (neither in local nor global memory), we leave it\n             // to validation to error. The `delay_span_bug` ensures that we don't forget such\n             // a check in validation.\n-            if tcx.alloc_map.lock().get(alloc_id).is_none() {\n+            if tcx.get_global_alloc(alloc_id).is_none() {\n                 tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n             }\n             // treat dangling pointers like other statics\n@@ -134,7 +134,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     // link the alloc id to the actual allocation\n     let alloc = tcx.intern_const_alloc(alloc);\n     leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n-    tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+    tcx.set_alloc_id_memory(alloc_id, alloc);\n     Ok(None)\n }\n \n@@ -389,7 +389,7 @@ where\n                 }\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n-            tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+            tcx.set_alloc_id_memory(alloc_id, alloc);\n             for &(_, ((), reloc)) in alloc.relocations().iter() {\n                 if leftover_allocations.insert(reloc) {\n                     todo.push(reloc);\n@@ -398,7 +398,7 @@ where\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n             throw_ub_format!(\"encountered dangling pointer in final constant\")\n-        } else if ecx.tcx.alloc_map.lock().get(alloc_id).is_none() {\n+        } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n             // as dangling by local memory.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);"}, {"sha": "61c365644c7f2d10a09daf5caa73b116c03cefa6", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -153,10 +153,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n     ) -> Pointer<M::PointerTag> {\n         let id = match fn_val {\n-            FnVal::Instance(instance) => self.tcx.alloc_map.lock().create_fn_alloc(instance),\n+            FnVal::Instance(instance) => self.tcx.create_fn_alloc(instance),\n             FnVal::Other(extra) => {\n                 // FIXME(RalfJung): Should we have a cache here?\n-                let id = self.tcx.alloc_map.lock().reserve();\n+                let id = self.tcx.reserve_alloc_id();\n                 let old = self.extra_fn_ptr_map.insert(id, extra);\n                 assert!(old.is_none());\n                 id\n@@ -189,7 +189,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n-        let id = self.tcx.alloc_map.lock().reserve();\n+        let id = self.tcx.reserve_alloc_id();\n         debug_assert_ne!(\n             Some(kind),\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n@@ -260,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating global memory -- always an error\n-                return Err(match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                return Err(match self.tcx.get_global_alloc(ptr.alloc_id) {\n                     Some(GlobalAlloc::Function(..)) => err_ub_format!(\"deallocating a function\"),\n                     Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n                         err_ub_format!(\"deallocating static memory\")\n@@ -429,8 +429,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n-        let alloc = tcx.alloc_map.lock().get(id);\n-        let (alloc, def_id) = match alloc {\n+        let (alloc, def_id) = match tcx.get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n                 (mem, None)\n@@ -468,7 +467,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     })?;\n                 // Make sure we use the ID of the resolved memory, not the lazy one!\n                 let id = raw_const.alloc_id;\n-                let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n+                let allocation = tcx.global_alloc(id).unwrap_memory();\n \n                 (allocation, Some(def_id))\n             }\n@@ -591,8 +590,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // # Statics\n         // Can't do this in the match argument, we may get cycle errors since the lock would\n         // be held throughout the match.\n-        let alloc = self.tcx.alloc_map.lock().get(id);\n-        match alloc {\n+        match self.tcx.get_global_alloc(id) {\n             Some(GlobalAlloc::Static(did)) => {\n                 // Use size and align of the type.\n                 let ty = self.tcx.type_of(did);\n@@ -627,7 +625,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n         } else {\n-            match self.tcx.alloc_map.lock().get(id) {\n+            match self.tcx.get_global_alloc(id) {\n                 Some(GlobalAlloc::Function(instance)) => Some(FnVal::Instance(instance)),\n                 _ => None,\n             }\n@@ -695,7 +693,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 }\n                 None => {\n                     // global alloc\n-                    match self.tcx.alloc_map.lock().get(id) {\n+                    match self.tcx.get_global_alloc(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             eprint!(\" (unchanged global, \");\n                             write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);"}, {"sha": "a3caa2048a1e74a0d9a3e6fc6021e858bf62ef83", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -549,7 +549,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n-                let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n+                let id = self.tcx.create_memory_alloc(alloc);\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.tag_global_base_pointer(Pointer::new(id, offset));\n@@ -560,7 +560,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen.\n                 let ptr = Pointer::new(\n-                    self.tcx.alloc_map.lock().create_memory_alloc(data),\n+                    self.tcx.create_memory_alloc(data),\n                     Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice("}, {"sha": "6dadb8e4c67f4204d311c6a2d903a4716f95682b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1101,7 +1101,7 @@ where\n         raw: RawConst<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n-        assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n+        let _ = self.tcx.global_alloc(raw.alloc_id);\n         let ptr = self.tag_global_base_pointer(Pointer::from(raw.alloc_id));\n         let layout = self.layout_of(raw.ty)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))"}, {"sha": "4f90f83b735d1e8c50adf02415ed26c17ecf6b0e", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -416,7 +416,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             if let Some(ptr) = ptr {\n                 // not a ZST\n                 // Skip validation entirely for some external statics\n-                let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                let alloc_kind = self.ecx.tcx.get_global_alloc(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     // See const_eval::machine::MemoryExtra::can_access_statics for why\n                     // this check is so important."}, {"sha": "4648100e3b701ac529ac6a772389655ba3d9e235", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1136,30 +1136,28 @@ fn create_mono_items_for_default_impls<'tcx>(\n \n /// Scans the miri alloc in order to find function calls, closures, and drop-glue.\n fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<MonoItem<'tcx>>) {\n-    let alloc_kind = tcx.alloc_map.lock().get(alloc_id);\n-    match alloc_kind {\n-        Some(GlobalAlloc::Static(def_id)) => {\n+    match tcx.global_alloc(alloc_id) {\n+        GlobalAlloc::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n             if should_monomorphize_locally(tcx, &instance) {\n                 trace!(\"collecting static {:?}\", def_id);\n                 output.push(MonoItem::Static(def_id));\n             }\n         }\n-        Some(GlobalAlloc::Memory(alloc)) => {\n+        GlobalAlloc::Memory(alloc) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n             for &((), inner) in alloc.relocations().values() {\n                 rustc_data_structures::stack::ensure_sufficient_stack(|| {\n                     collect_miri(tcx, inner, output);\n                 });\n             }\n         }\n-        Some(GlobalAlloc::Function(fn_instance)) => {\n+        GlobalAlloc::Function(fn_instance) => {\n             if should_monomorphize_locally(tcx, &fn_instance) {\n                 trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n                 output.push(create_fn_mono_item(fn_instance));\n             }\n         }\n-        None => bug!(\"alloc id without corresponding allocation: {}\", alloc_id),\n     }\n }\n "}, {"sha": "220691c1570d22b94e90b16d57e2d01ee2aa86c8", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,5 @@\n use crate::{shim, util};\n use required_consts::RequiredConstsVisitor;\n-use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n@@ -11,7 +10,7 @@ use rustc_middle::mir::{traversal, Body, ConstQualifs, MirPhase, Promoted};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::steal::Steal;\n use rustc_middle::ty::{InstanceDef, TyCtxt, TypeFoldable};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use std::borrow::Cow;\n \n pub mod add_call_guards;\n@@ -78,7 +77,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> FxHashSet<LocalDefId> {\n         fn visit_variant_data(\n             &mut self,\n             v: &'tcx hir::VariantData<'tcx>,\n-            _: ast::Name,\n+            _: Symbol,\n             _: &'tcx hir::Generics<'tcx>,\n             _: hir::HirId,\n             _: Span,"}, {"sha": "ff386cb218304bd25460b6a163bec9336266b621", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -588,8 +588,7 @@ pub fn write_allocations<'tcx>(\n                 write_allocation(tcx, alloc, w)\n             };\n         write!(w, \"\\n{}\", id)?;\n-        let alloc = tcx.alloc_map.lock().get(id);\n-        match alloc {\n+        match tcx.get_global_alloc(id) {\n             // This can't really happen unless there are bugs, but it doesn't cost us anything to\n             // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n             None => write!(w, \" (deallocated)\")?,"}, {"sha": "43e9f305245cfef69cf8c641234713de0e4e91a7", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -10,14 +10,14 @@ use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n-use rustc_ast::ast::Name;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc_span::Span;\n+use rustc_span::symbol::Symbol;\n use rustc_target::abi::VariantIdx;\n use smallvec::{smallvec, SmallVec};\n \n@@ -570,7 +570,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         f: &mut impl FnMut(\n             &mut Self,\n             Mutability,\n-            Name,\n+            Symbol,\n             BindingMode,\n             HirId,\n             Span,\n@@ -737,7 +737,7 @@ fn traverse_candidate<'pat, 'tcx: 'pat, C, T, I>(\n struct Binding<'tcx> {\n     span: Span,\n     source: Place<'tcx>,\n-    name: Name,\n+    name: Symbol,\n     var_id: HirId,\n     var_ty: Ty<'tcx>,\n     mutability: Mutability,\n@@ -1924,7 +1924,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         source_info: SourceInfo,\n         visibility_scope: SourceScope,\n         mutability: Mutability,\n-        name: Name,\n+        name: Symbol,\n         mode: BindingMode,\n         var_id: HirId,\n         var_ty: Ty<'tcx>,"}, {"sha": "8d572465d62c19f7fe8a3025ac7694bb69a7b69b", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -740,7 +740,7 @@ fn convert_path_expr<'a, 'tcx>(\n         // a constant reference (or constant raw pointer for `static mut`) in MIR\n         Res::Def(DefKind::Static, id) => {\n             let ty = cx.tcx.static_ptr_ty(id);\n-            let ptr = cx.tcx.alloc_map.lock().create_static_alloc(id);\n+            let ptr = cx.tcx.create_static_alloc(id);\n             let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n             ExprKind::Deref {\n                 arg: Expr {"}, {"sha": "f6941d3293b5c0bbfd35342a6508b35a3942e28b", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -286,7 +286,7 @@ impl<'tcx> LiteralExpander<'tcx> {\n             (ConstValue::Scalar(p), x, y) if x == y => {\n                 match p {\n                     Scalar::Ptr(p) => {\n-                        let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n+                        let alloc = self.tcx.global_alloc(p.alloc_id).unwrap_memory();\n                         ConstValue::ByRef { alloc, offset: p.offset }\n                     }\n                     Scalar::Raw { .. } => {\n@@ -305,7 +305,7 @@ impl<'tcx> LiteralExpander<'tcx> {\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n                 ConstValue::Slice {\n-                    data: self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n+                    data: self.tcx.global_alloc(p.alloc_id).unwrap_memory(),\n                     start: p.offset.bytes().try_into().unwrap(),\n                     end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n                 }"}, {"sha": "f38471da94ee2dcf12a78ffef02fdcd7b0898e38", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -24,7 +24,7 @@ use rustc_middle::ty::{self, AdtDef, DefIdTree, Region, Ty, TyCtxt, UserType};\n use rustc_middle::ty::{\n     CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n };\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{Span, Symbol, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n \n use std::cmp::Ordering;\n@@ -128,7 +128,7 @@ crate enum PatKind<'tcx> {\n     /// `x`, `ref x`, `x @ P`, etc.\n     Binding {\n         mutability: Mutability,\n-        name: ast::Name,\n+        name: Symbol,\n         mode: BindingMode,\n         var: hir::HirId,\n         ty: Ty<'tcx>,\n@@ -932,7 +932,7 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls! { <'tcx>\n-    Span, Field, Mutability, ast::Name, hir::HirId, usize, ty::Const<'tcx>,\n+    Span, Field, Mutability, Symbol, hir::HirId, usize, ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode, &'tcx AdtDef,\n     SubstsRef<'tcx>, &'tcx GenericArg<'tcx>, UserType<'tcx>,\n     UserTypeProjection, PatTyProj<'tcx>"}, {"sha": "437d0ffa1196d6ed100050974fb01c4594c08c39", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,9 +1,7 @@\n use super::ty::AllowPlus;\n use super::{BlockMode, Parser, PathStyle, SemiColonMode, SeqSep, TokenExpectType, TokenType};\n \n-use rustc_ast::ast::{\n-    self, BinOpKind, BindingMode, BlockCheckMode, Expr, ExprKind, Ident, Item, Param,\n-};\n+use rustc_ast::ast::{self, BinOpKind, BindingMode, BlockCheckMode, Expr, ExprKind, Item, Param};\n use rustc_ast::ast::{AttrVec, ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Lit, LitKind, TokenKind};\n@@ -13,7 +11,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err};\n use rustc_errors::{Applicability, DiagnosticBuilder, Handler, PResult};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n \n use log::{debug, trace};"}, {"sha": "ca497a3b06f4a712f2f4b7d06d98418d42d969d6", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -4,7 +4,7 @@ use super::{BlockMode, Parser, PathStyle, Restrictions, TokenType};\n use super::{SemiColonMode, SeqSep, TokenExpectType};\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n-use rustc_ast::ast::{self, AttrStyle, AttrVec, CaptureBy, Field, Ident, Lit, UnOp, DUMMY_NODE_ID};\n+use rustc_ast::ast::{self, AttrStyle, AttrVec, CaptureBy, Field, Lit, UnOp, DUMMY_NODE_ID};\n use rustc_ast::ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty, TyKind};\n use rustc_ast::ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast::ptr::P;\n@@ -15,7 +15,7 @@ use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, DiagnosticBuilder, PResult};\n use rustc_span::source_map::{self, Span, Spanned};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use std::mem;\n \n /// Possibly accepts an `token::Interpolated` expression (a pre-parsed expression"}, {"sha": "4fe0453e9c87f5a544788df15acf8c89380e8de9", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -4,7 +4,7 @@ use super::{FollowedByType, Parser, PathStyle};\n \n use crate::maybe_whole;\n \n-use rustc_ast::ast::{self, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n+use rustc_ast::ast::{self, AttrStyle, AttrVec, Attribute, DUMMY_NODE_ID};\n use rustc_ast::ast::{AssocItem, AssocItemKind, ForeignItemKind, Item, ItemKind, Mod};\n use rustc_ast::ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree, UseTreeKind};\n use rustc_ast::ast::{BindingMode, Block, FnDecl, FnSig, Param, SelfKind};\n@@ -18,7 +18,7 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, PResult, StashKey};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{self, Span};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n \n use log::debug;\n use std::convert::TryFrom;\n@@ -804,7 +804,7 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(kw::As) { self.parse_ident_or_underscore().map(Some) } else { Ok(None) }\n     }\n \n-    fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n+    fn parse_ident_or_underscore(&mut self) -> PResult<'a, Ident> {\n         match self.token.ident() {\n             Some((ident @ Ident { name: kw::Underscore, .. }, false)) => {\n                 self.bump();\n@@ -834,7 +834,7 @@ impl<'a> Parser<'a> {\n         Ok((item_name, ItemKind::ExternCrate(orig_name)))\n     }\n \n-    fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, ast::Ident> {\n+    fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, Ident> {\n         let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n         let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n                               in the code\";"}, {"sha": "bdb4d7c9df6be3c494ef64622aefcbd85594dd62", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -14,7 +14,7 @@ use crate::lexer::UnmatchedBrace;\n \n use log::debug;\n use rustc_ast::ast::DUMMY_NODE_ID;\n-use rustc_ast::ast::{self, AttrStyle, AttrVec, Const, CrateSugar, Extern, Ident, Unsafe};\n+use rustc_ast::ast::{self, AttrStyle, AttrVec, Const, CrateSugar, Extern, Unsafe};\n use rustc_ast::ast::{\n     Async, MacArgs, MacDelimiter, Mutability, StrLit, Visibility, VisibilityKind,\n };\n@@ -26,7 +26,7 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, FatalError, PResult};\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{respan, Span, DUMMY_SP};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n \n use std::{cmp, mem, slice};\n \n@@ -424,11 +424,11 @@ impl<'a> Parser<'a> {\n     }\n \n     // Public for rustfmt usage.\n-    pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n+    pub fn parse_ident(&mut self) -> PResult<'a, Ident> {\n         self.parse_ident_common(true)\n     }\n \n-    fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n+    fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, Ident> {\n         match self.token.ident() {\n             Some((ident, is_raw)) => {\n                 if !is_raw && ident.is_reserved() {"}, {"sha": "6603d0afc0248d6cf52ad3d147c3cf8a05d95d7d", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,14 +1,14 @@\n use super::{Parser, PathStyle};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::ast::{self, AttrVec, Attribute, FieldPat, MacCall, Pat, PatKind, RangeEnd};\n-use rustc_ast::ast::{BindingMode, Expr, ExprKind, Ident, Mutability, Path, QSelf, RangeSyntax};\n+use rustc_ast::ast::{BindingMode, Expr, ExprKind, Mutability, Path, QSelf, RangeSyntax};\n use rustc_ast::mut_visit::{noop_visit_mac, noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult};\n use rustc_span::source_map::{respan, Span, Spanned};\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n \n type Expected = Option<&'static str>;\n "}, {"sha": "5210614548da394ad1be004206084660ce8b343a", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,12 +3,12 @@ use super::{Parser, TokenType};\n use crate::maybe_whole;\n use rustc_ast::ast::{self, AngleBracketedArg, AngleBracketedArgs, GenericArg, ParenthesizedArgs};\n use rustc_ast::ast::{AnonConst, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n-use rustc_ast::ast::{Ident, Path, PathSegment, QSelf};\n+use rustc_ast::ast::{Path, PathSegment, QSelf};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n use rustc_errors::{pluralize, Applicability, PResult};\n use rustc_span::source_map::{BytePos, Span};\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n \n use log::debug;\n use std::mem;"}, {"sha": "1dcf0e7c7a98a233e85dbeb260a8a12247e0a245", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::lint;\n \n use rustc_ast::{ast, attr};\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live Node::Item that is a\n@@ -229,7 +229,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_variant_data(\n         &mut self,\n         def: &'tcx hir::VariantData<'tcx>,\n-        _: ast::Name,\n+        _: Symbol,\n         _: &hir::Generics<'_>,\n         _: hir::HirId,\n         _: rustc_span::Span,\n@@ -551,7 +551,7 @@ impl DeadVisitor<'tcx> {\n         &mut self,\n         id: hir::HirId,\n         span: rustc_span::Span,\n-        name: ast::Name,\n+        name: Symbol,\n         participle: &str,\n     ) {\n         if !name.as_str().starts_with('_') {"}, {"sha": "75ac8e731b5dab5978b17a25e87a197a22498858", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -96,7 +96,6 @@\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n-use rustc_ast::ast;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -108,7 +107,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n use std::collections::VecDeque;\n@@ -245,13 +244,13 @@ struct CaptureInfo {\n #[derive(Copy, Clone, Debug)]\n struct LocalInfo {\n     id: HirId,\n-    name: ast::Name,\n+    name: Symbol,\n     is_shorthand: bool,\n }\n \n #[derive(Copy, Clone, Debug)]\n enum VarKind {\n-    Param(HirId, ast::Name),\n+    Param(HirId, Symbol),\n     Local(LocalInfo),\n     CleanExit,\n }"}, {"sha": "c3a60166968888c41799308ce85c4b98d9529b39", "filename": "src/librustc_plugin_impl/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_plugin_impl%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_plugin_impl%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fload.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,12 +1,12 @@\n //! Used by `rustc` when loading a plugin.\n \n use crate::Registry;\n-use rustc_ast::ast::{Crate, Ident};\n+use rustc_ast::ast::Crate;\n use rustc_errors::struct_span_err;\n use rustc_metadata::locator;\n use rustc_middle::middle::cstore::MetadataLoader;\n use rustc_session::Session;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n use std::borrow::ToOwned;"}, {"sha": "6110d2ef7fc9a18baca9d23afbc0b0761770a451", "filename": "src/librustc_privacy/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2FCargo.toml?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -15,7 +15,6 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_session = { path = \"../librustc_session\" }\n-rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n log = \"0.4\""}, {"sha": "917e2f548302f59b56d3927a6eea5193c15f1fc3", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -4,7 +4,6 @@\n #![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n-use rustc_ast::ast::Ident;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n@@ -22,7 +21,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, GenericParamDefKind, TraitRef, Ty, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n \n use std::marker::PhantomData;"}, {"sha": "d0eb1cfc222e66e7e7fb36c46b403e5a25c181c2", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -17,7 +17,6 @@ use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segmen\n \n use rustc_ast::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use rustc_ast::ast::{AssocItem, AssocItemKind, MetaItemKind, StmtKind};\n-use rustc_ast::ast::{Ident, Name};\n use rustc_ast::token::{self, Token};\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_attr as attr;\n@@ -34,7 +33,7 @@ use rustc_middle::middle::cstore::CrateStore;\n use rustc_middle::ty;\n use rustc_span::hygiene::{ExpnId, MacroKind};\n use rustc_span::source_map::{respan, Spanned};\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n use log::debug;\n@@ -293,7 +292,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         self.insert_field_names(def_id, field_names);\n     }\n \n-    fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Spanned<Name>>) {\n+    fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Spanned<Symbol>>) {\n         if !field_names.is_empty() {\n             self.r.field_names.insert(def_id, field_names);\n         }\n@@ -953,7 +952,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     fn add_macro_use_binding(\n         &mut self,\n-        name: ast::Name,\n+        name: Symbol,\n         binding: &'a NameBinding<'a>,\n         span: Span,\n         allow_shadowing: bool,"}, {"sha": "c66e9a6040669659428bf3d537d239522020ba50", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2,7 +2,7 @@ use std::cmp::Reverse;\n use std::ptr;\n \n use log::debug;\n-use rustc_ast::ast::{self, Ident, Path};\n+use rustc_ast::ast::{self, Path};\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -16,7 +16,7 @@ use rustc_middle::ty::{self, DefIdTree};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span};\n \n use crate::imports::{Import, ImportKind, ImportResolver};"}, {"sha": "a1e05d21b58d524bebabc187d44f5663661c6822", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -9,7 +9,7 @@ use crate::{BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n use crate::{CrateLint, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet, Weak};\n use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBinding};\n \n-use rustc_ast::ast::{Ident, Name, NodeId};\n+use rustc_ast::ast::NodeId;\n use rustc_ast::unwrap_or;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashSet;\n@@ -24,7 +24,7 @@ use rustc_session::lint::builtin::{PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPOR\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::DiagnosticMessageId;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{MultiSpan, Span};\n \n use log::*;\n@@ -57,7 +57,7 @@ pub enum ImportKind<'a> {\n                                        // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n     },\n     ExternCrate {\n-        source: Option<Name>,\n+        source: Option<Symbol>,\n         target: Ident,\n     },\n     MacroUse,"}, {"sha": "e541920e89ed451ed96d93bdf9a07f126c6a4274", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -24,7 +24,7 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::TraitCandidate;\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n@@ -1194,7 +1194,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     fn check_trait_item<F>(&mut self, ident: Ident, ns: Namespace, span: Span, err: F)\n     where\n-        F: FnOnce(Name, &str) -> ResolutionError<'_>,\n+        F: FnOnce(Symbol, &str) -> ResolutionError<'_>,\n     {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait."}, {"sha": "dc92b465c2bc1ef9469ce291151cd301906c3f3d", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -5,7 +5,7 @@ use crate::path_names_to_string;\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n-use rustc_ast::ast::{self, Expr, ExprKind, Ident, Item, ItemKind, NodeId, Path, Ty, TyKind};\n+use rustc_ast::ast::{self, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n@@ -16,7 +16,7 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::PrimTy;\n use rustc_session::config::nightly_options;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n \n use log::debug;\n@@ -1047,7 +1047,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         count: usize,\n-        lifetime_names: &FxHashSet<ast::Ident>,\n+        lifetime_names: &FxHashSet<Ident>,\n         params: &[ElisionFailureInfo],\n     ) {\n         let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();"}, {"sha": "a3fbb28f22a56745a330c5fc7ecfbbc605462e89", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -6,7 +6,6 @@\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n-use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_ast::walk_list;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -22,7 +21,7 @@ use rustc_middle::middle::resolve_lifetime::*;\n use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -175,7 +174,7 @@ crate struct LifetimeContext<'a, 'tcx> {\n     is_in_fn_syntax: bool,\n \n     /// List of labels in the function/method currently under analysis.\n-    labels_in_fn: Vec<ast::Ident>,\n+    labels_in_fn: Vec<Ident>,\n \n     /// Cache for cross-crate per-definition object lifetime defaults.\n     xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n@@ -1064,7 +1063,7 @@ fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_>, params: &[hir::Generic\n     }\n }\n \n-fn signal_shadowing_problem(tcx: TyCtxt<'_>, name: ast::Name, orig: Original, shadower: Shadower) {\n+fn signal_shadowing_problem(tcx: TyCtxt<'_>, name: Symbol, orig: Original, shadower: Shadower) {\n     let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n         // lifetime/lifetime shadowing is an error\n         struct_span_err!(\n@@ -1102,7 +1101,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n     struct GatherLabels<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         scope: ScopeRef<'a>,\n-        labels_in_fn: &'a mut Vec<ast::Ident>,\n+        labels_in_fn: &'a mut Vec<Ident>,\n     }\n \n     let mut gather =\n@@ -1138,15 +1137,11 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n         }\n     }\n \n-    fn expression_label(ex: &hir::Expr<'_>) -> Option<ast::Ident> {\n+    fn expression_label(ex: &hir::Expr<'_>) -> Option<Ident> {\n         if let hir::ExprKind::Loop(_, Some(label), _) = ex.kind { Some(label.ident) } else { None }\n     }\n \n-    fn check_if_label_shadows_lifetime(\n-        tcx: TyCtxt<'_>,\n-        mut scope: ScopeRef<'_>,\n-        label: ast::Ident,\n-    ) {\n+    fn check_if_label_shadows_lifetime(tcx: TyCtxt<'_>, mut scope: ScopeRef<'_>, label: Ident) {\n         loop {\n             match *scope {\n                 Scope::Body { s, .. }\n@@ -1360,11 +1355,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     /// helper method to determine the span to remove when suggesting the\n     /// deletion of a lifetime\n-    fn lifetime_deletion_span(\n-        &self,\n-        name: ast::Ident,\n-        generics: &hir::Generics<'_>,\n-    ) -> Option<Span> {\n+    fn lifetime_deletion_span(&self, name: Ident, generics: &hir::Generics<'_>) -> Option<Span> {\n         generics.params.iter().enumerate().find_map(|(i, param)| {\n             if param.name.ident() == name {\n                 let mut in_band = false;\n@@ -2394,7 +2385,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if let Some(params) = error {\n             // If there's no lifetime available, suggest `'static`.\n             if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(ast::Ident::from_str(\"'static\"));\n+                lifetime_names.insert(Ident::from_str(\"'static\"));\n             }\n         }\n         self.add_missing_lifetime_specifiers_label("}, {"sha": "2031b7868c0d089539768279dd1e1be61ff86aff", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -17,7 +17,7 @@ pub use rustc_hir::def::{Namespace, PerNS};\n \n use Determinacy::*;\n \n-use rustc_ast::ast::{self, FloatTy, Ident, IntTy, Name, NodeId, UintTy};\n+use rustc_ast::ast::{self, FloatTy, IntTy, NodeId, UintTy};\n use rustc_ast::ast::{Crate, CRATE_NODE_ID};\n use rustc_ast::ast::{ItemKind, Path};\n use rustc_ast::attr;\n@@ -47,7 +47,7 @@ use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, ExpnKind, MacroKind, SyntaxContext, Transparency};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n use log::debug;\n@@ -147,7 +147,7 @@ impl<'a> ParentScope<'a> {\n \n #[derive(Eq)]\n struct BindingError {\n-    name: Name,\n+    name: Symbol,\n     origin: BTreeSet<Span>,\n     target: BTreeSet<Span>,\n     could_be_path: bool,\n@@ -176,23 +176,23 @@ enum ResolutionError<'a> {\n     GenericParamsFromOuterFunction(Res, HasGenericParams),\n     /// Error E0403: the name is already used for a type or const parameter in this generic\n     /// parameter list.\n-    NameAlreadyUsedInParameterList(Name, Span),\n+    NameAlreadyUsedInParameterList(Symbol, Span),\n     /// Error E0407: method is not a member of trait.\n-    MethodNotMemberOfTrait(Name, &'a str),\n+    MethodNotMemberOfTrait(Symbol, &'a str),\n     /// Error E0437: type is not a member of trait.\n-    TypeNotMemberOfTrait(Name, &'a str),\n+    TypeNotMemberOfTrait(Symbol, &'a str),\n     /// Error E0438: const is not a member of trait.\n-    ConstNotMemberOfTrait(Name, &'a str),\n+    ConstNotMemberOfTrait(Symbol, &'a str),\n     /// Error E0408: variable `{}` is not bound in all patterns.\n     VariableNotBoundInPattern(&'a BindingError),\n     /// Error E0409: variable `{}` is bound in inconsistent ways within the same match arm.\n-    VariableBoundWithDifferentMode(Name, Span),\n+    VariableBoundWithDifferentMode(Symbol, Span),\n     /// Error E0415: identifier is bound more than once in this parameter list.\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// Error E0416: identifier is bound more than once in the same pattern.\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n     /// Error E0426: use of undeclared label.\n-    UndeclaredLabel(&'a str, Option<Name>),\n+    UndeclaredLabel(&'a str, Option<Symbol>),\n     /// Error E0429: `self` imports are only allowed within a `{ }` list.\n     SelfImportsOnlyAllowedWithin,\n     /// Error E0430: `self` import can only appear once in the list.\n@@ -206,7 +206,7 @@ enum ResolutionError<'a> {\n     /// Error E0435: attempt to use a non-constant value in a constant.\n     AttemptToUseNonConstantValueInConstant,\n     /// Error E0530: `X` bindings cannot shadow `Y`s.\n-    BindingShadowsSomethingUnacceptable(&'a str, Name, &'a NameBinding<'a>),\n+    BindingShadowsSomethingUnacceptable(&'a str, Symbol, &'a NameBinding<'a>),\n     /// Error E0128: type parameters with a default cannot use forward-declared identifiers.\n     ForwardDeclaredTyParam, // FIXME(const_generics:defaults)\n     /// Error E0735: type parameters with a default cannot use `Self`\n@@ -406,12 +406,12 @@ enum ModuleKind {\n     /// * A normal module \u2012 either `mod from_file;` or `mod from_block { }`.\n     /// * A trait or an enum (it implicitly contains associated types, methods and variant\n     ///   constructors).\n-    Def(DefKind, DefId, Name),\n+    Def(DefKind, DefId, Symbol),\n }\n \n impl ModuleKind {\n     /// Get name of the module.\n-    pub fn name(&self) -> Option<Name> {\n+    pub fn name(&self) -> Option<Symbol> {\n         match self {\n             ModuleKind::Block(..) => None,\n             ModuleKind::Def(.., name) => Some(*name),\n@@ -786,7 +786,7 @@ impl<'a> NameBinding<'a> {\n /// All other types are defined somewhere and possibly imported, but the primitive ones need\n /// special handling, since they have no place of origin.\n struct PrimitiveTypeTable {\n-    primitive_types: FxHashMap<Name, PrimTy>,\n+    primitive_types: FxHashMap<Symbol, PrimTy>,\n }\n \n impl PrimitiveTypeTable {\n@@ -838,7 +838,7 @@ pub struct Resolver<'a> {\n \n     /// Names of fields of an item `DefId` accessible with dot syntax.\n     /// Used for hints during error reporting.\n-    field_names: FxHashMap<DefId, Vec<Spanned<Name>>>,\n+    field_names: FxHashMap<DefId, Vec<Spanned<Symbol>>>,\n \n     /// All imports known to succeed or fail.\n     determined_imports: Vec<&'a Import<'a>>,\n@@ -913,11 +913,11 @@ pub struct Resolver<'a> {\n \n     crate_loader: CrateLoader<'a>,\n     macro_names: FxHashSet<Ident>,\n-    builtin_macros: FxHashMap<Name, SyntaxExtension>,\n+    builtin_macros: FxHashMap<Symbol, SyntaxExtension>,\n     registered_attrs: FxHashSet<Ident>,\n     registered_tools: FxHashSet<Ident>,\n-    macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n-    all_macros: FxHashMap<Name, Res>,\n+    macro_use_prelude: FxHashMap<Symbol, &'a NameBinding<'a>>,\n+    all_macros: FxHashMap<Symbol, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n@@ -947,7 +947,7 @@ pub struct Resolver<'a> {\n     helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n-    name_already_seen: FxHashMap<Name, Span>,\n+    name_already_seen: FxHashMap<Symbol, Span>,\n \n     potentially_unused_imports: Vec<&'a Import<'a>>,\n \n@@ -956,7 +956,7 @@ pub struct Resolver<'a> {\n     struct_constructors: DefIdMap<(Res, ty::Visibility)>,\n \n     /// Features enabled for this crate.\n-    active_features: FxHashSet<Name>,\n+    active_features: FxHashSet<Symbol>,\n \n     /// Stores enum visibilities to properly build a reduced graph\n     /// when visiting the correspondent variants.\n@@ -1044,8 +1044,8 @@ impl rustc_ast_lowering::Resolver for Resolver<'_> {\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n-        crate_root: Option<Name>,\n-        components: &[Name],\n+        crate_root: Option<Symbol>,\n+        components: &[Symbol],\n         ns: Namespace,\n     ) -> (ast::Path, Res) {\n         let root = if crate_root.is_some() { kw::PathRoot } else { kw::Crate };\n@@ -2678,7 +2678,7 @@ impl<'a> Resolver<'a> {\n     fn add_suggestion_for_rename_of_use(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        name: Name,\n+        name: Symbol,\n         import: &Import<'_>,\n         binding_span: Span,\n     ) {\n@@ -2914,12 +2914,12 @@ impl<'a> Resolver<'a> {\n     }\n \n     // For rustdoc.\n-    pub fn all_macros(&self) -> &FxHashMap<Name, Res> {\n+    pub fn all_macros(&self) -> &FxHashMap<Symbol, Res> {\n         &self.all_macros\n     }\n }\n \n-fn names_to_string(names: &[Name]) -> String {\n+fn names_to_string(names: &[Symbol]) -> String {\n     let mut result = String::new();\n     for (i, name) in names.iter().filter(|name| **name != kw::PathRoot).enumerate() {\n         if i > 0 {\n@@ -2941,14 +2941,14 @@ fn path_names_to_string(path: &Path) -> String {\n fn module_to_string(module: Module<'_>) -> Option<String> {\n     let mut names = Vec::new();\n \n-    fn collect_mod(names: &mut Vec<Name>, module: Module<'_>) {\n+    fn collect_mod(names: &mut Vec<Symbol>, module: Module<'_>) {\n         if let ModuleKind::Def(.., name) = module.kind {\n             if let Some(parent) = module.parent {\n                 names.push(name);\n                 collect_mod(names, parent);\n             }\n         } else {\n-            names.push(Name::intern(\"<opaque>\"));\n+            names.push(Symbol::intern(\"<opaque>\"));\n             collect_mod(names, module.parent.unwrap());\n         }\n     }"}, {"sha": "1b6268dc8cbcfbb6b3a84190fca9d4bf9568971b", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -6,7 +6,7 @@ use crate::Namespace::*;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy};\n use crate::{CrateLint, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n-use rustc_ast::ast::{self, Ident, NodeId};\n+use rustc_ast::ast::{self, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, StabilityLevel};\n use rustc_data_structures::fx::FxHashSet;\n@@ -23,7 +23,7 @@ use rustc_session::lint::builtin::UNUSED_MACROS;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{self, ExpnData, ExpnId, ExpnKind};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n use rustc_data_structures::sync::Lrc;\n@@ -165,7 +165,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n \n-    fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n+    fn register_builtin_macro(&mut self, ident: Ident, ext: SyntaxExtension) {\n         if self.builtin_macros.insert(ident.name, ext).is_some() {\n             self.session\n                 .span_err(ident.span, &format!(\"built-in macro `{}` was already defined\", ident));"}, {"sha": "534fe172bef9c64b41e1efdd86fa6014cb6f1330", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -26,6 +26,7 @@ use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::Input;\n use rustc_span::source_map::{respan, DUMMY_SP};\n+use rustc_span::symbol::Ident;\n use rustc_span::*;\n \n use std::env;\n@@ -264,7 +265,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         sig: &'l ast::FnSig,\n         body: Option<&'l ast::Block>,\n         id: ast::NodeId,\n-        ident: ast::Ident,\n+        ident: Ident,\n         generics: &'l ast::Generics,\n         vis: ast::Visibility,\n         span: Span,\n@@ -419,7 +420,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_assoc_const(\n         &mut self,\n         id: ast::NodeId,\n-        ident: ast::Ident,\n+        ident: Ident,\n         typ: &'l ast::Ty,\n         expr: Option<&'l ast::Expr>,\n         parent_id: DefId,"}, {"sha": "8ae6853210f18d29d247c19c4c85d0c9139e31a9", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -24,6 +24,7 @@ use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CrateType, Input, OutputType};\n use rustc_session::output::{filename_for_metadata, out_filename};\n use rustc_span::source_map::Spanned;\n+use rustc_span::symbol::Ident;\n use rustc_span::*;\n \n use std::cell::Cell;\n@@ -405,7 +406,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, id: ast::NodeId, ident: ast::Ident, span: Span) -> Option<Def> {\n+    pub fn get_method_data(&self, id: ast::NodeId, ident: Ident, span: Span) -> Option<Def> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let (qualname, parent_scope, decl_id, docs, attributes) = match self\n@@ -914,7 +915,7 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n // variables (idents) from patterns.\n struct PathCollector<'l> {\n     collected_paths: Vec<(NodeId, &'l ast::Path)>,\n-    collected_idents: Vec<(NodeId, ast::Ident, ast::Mutability)>,\n+    collected_idents: Vec<(NodeId, Ident, ast::Mutability)>,\n }\n \n impl<'l> PathCollector<'l> {"}, {"sha": "bda9ff93b02ef0f19494dc90d0b935300168b044", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -32,6 +32,7 @@ use rls_data::{SigElement, Signature};\n use rustc_ast::ast::{self, Extern, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_hir::def::{DefKind, Res};\n+use rustc_span::symbol::{Ident, Symbol};\n \n pub fn item_signature(item: &ast::Item, scx: &SaveContext<'_, '_>) -> Option<Signature> {\n     if !scx.config.signatures {\n@@ -69,7 +70,7 @@ pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext<'_, '_>) -> O\n \n pub fn method_signature(\n     id: NodeId,\n-    ident: ast::Ident,\n+    ident: Ident,\n     generics: &ast::Generics,\n     m: &ast::FnSig,\n     scx: &SaveContext<'_, '_>,\n@@ -82,7 +83,7 @@ pub fn method_signature(\n \n pub fn assoc_const_signature(\n     id: NodeId,\n-    ident: ast::Name,\n+    ident: Symbol,\n     ty: &ast::Ty,\n     default: Option<&ast::Expr>,\n     scx: &SaveContext<'_, '_>,\n@@ -95,7 +96,7 @@ pub fn assoc_const_signature(\n \n pub fn assoc_type_signature(\n     id: NodeId,\n-    ident: ast::Ident,\n+    ident: Ident,\n     bounds: Option<&ast::GenericBounds>,\n     default: Option<&ast::Ty>,\n     scx: &SaveContext<'_, '_>,\n@@ -803,7 +804,7 @@ fn name_and_generics(\n     offset: usize,\n     generics: &ast::Generics,\n     id: NodeId,\n-    name: ast::Ident,\n+    name: Ident,\n     scx: &SaveContext<'_, '_>,\n ) -> Result {\n     let name = name.to_string();\n@@ -821,7 +822,7 @@ fn name_and_generics(\n \n fn make_assoc_type_signature(\n     id: NodeId,\n-    ident: ast::Ident,\n+    ident: Ident,\n     bounds: Option<&ast::GenericBounds>,\n     default: Option<&ast::Ty>,\n     scx: &SaveContext<'_, '_>,\n@@ -853,7 +854,7 @@ fn make_assoc_type_signature(\n \n fn make_assoc_const_signature(\n     id: NodeId,\n-    ident: ast::Name,\n+    ident: Symbol,\n     ty: &ast::Ty,\n     default: Option<&ast::Expr>,\n     scx: &SaveContext<'_, '_>,\n@@ -884,7 +885,7 @@ fn make_assoc_const_signature(\n \n fn make_method_signature(\n     id: NodeId,\n-    ident: ast::Ident,\n+    ident: Ident,\n     generics: &ast::Generics,\n     m: &ast::FnSig,\n     scx: &SaveContext<'_, '_>,"}, {"sha": "4eabb55e6dfe7523ddea78ee8b1ca845585fb32d", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -768,6 +768,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"select which borrowck is used (`mir` or `migrate`) (default: `migrate`)\"),\n     borrowck_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather borrowck statistics (default: no)\"),\n+    chalk: bool = (false, parse_bool, [TRACKED],\n+        \"enable the experimental Chalk-based trait solving engine\"),\n     codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"the backend to use\"),\n     control_flow_guard: CFGuard = (CFGuard::Disabled, parse_cfguard, [UNTRACKED],\n@@ -1008,6 +1010,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\"),\n     unstable_options: bool = (false, parse_bool, [UNTRACKED],\n         \"adds unstable command line options to rustc interface (default: no)\"),\n+    use_ctors_section: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"use legacy .ctors section for initializers rather than .init_array\"),\n     verbose: bool = (false, parse_bool, [UNTRACKED],\n         \"in general, enable more debug printouts (default: no)\"),\n     verify_llvm_ir: bool = (false, parse_bool, [TRACKED],"}, {"sha": "477161dc658d92a925a3ea1632f7dcf9c7210bb2", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -882,6 +882,10 @@ pub struct TargetOptions {\n \n     /// Additional arguments to pass to LLVM, similar to the `-C llvm-args` codegen option.\n     pub llvm_args: Vec<String>,\n+\n+    /// Whether to use legacy .ctors initialization hooks rather than .init_array. Defaults\n+    /// to false (uses .init_array).\n+    pub use_ctors_section: bool,\n }\n \n impl Default for TargetOptions {\n@@ -972,6 +976,7 @@ impl Default for TargetOptions {\n             llvm_abiname: \"\".to_string(),\n             relax_elf_relocations: false,\n             llvm_args: vec![],\n+            use_ctors_section: false,\n         }\n     }\n }\n@@ -1312,6 +1317,7 @@ impl Target {\n         key!(llvm_abiname);\n         key!(relax_elf_relocations, bool);\n         key!(llvm_args, list);\n+        key!(use_ctors_section, bool);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -1541,6 +1547,7 @@ impl ToJson for Target {\n         target_option_val!(llvm_abiname);\n         target_option_val!(relax_elf_relocations);\n         target_option_val!(llvm_args);\n+        target_option_val!(use_ctors_section);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert("}, {"sha": "988346af2d72c8f9068fe63a511002b932ecc6db", "filename": "src/librustc_target/spec/netbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_target%2Fspec%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_target%2Fspec%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fnetbsd_base.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -23,6 +23,7 @@ pub fn opts() -> TargetOptions {\n         pre_link_args: args,\n         position_independent_executables: true,\n         relro_level: RelroLevel::Full,\n+        use_ctors_section: true,\n         ..Default::default()\n     }\n }"}, {"sha": "115e4a0e629695e13e241beb6ba0570043f93b15", "filename": "src/librustc_trait_selection/traits/chalk_fulfill.rs", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,262 @@\n+//! Defines a Chalk-based `TraitEngine`\n+\n+use crate::infer::canonical::OriginalQueryValues;\n+use crate::infer::InferCtxt;\n+use crate::traits::query::NoSolution;\n+use crate::traits::{\n+    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, FulfillmentError, FulfillmentErrorCode,\n+    ObligationCause, PredicateObligation, SelectionError, TraitEngine,\n+};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+pub struct FulfillmentContext<'tcx> {\n+    obligations: FxHashSet<PredicateObligation<'tcx>>,\n+}\n+\n+impl FulfillmentContext<'tcx> {\n+    crate fn new() -> Self {\n+        FulfillmentContext { obligations: FxHashSet::default() }\n+    }\n+}\n+\n+fn environment<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> &'tcx ty::List<ChalkEnvironmentClause<'tcx>> {\n+    use rustc_hir::{ForeignItemKind, ImplItemKind, ItemKind, Node, TraitItemKind};\n+    use rustc_middle::ty::subst::GenericArgKind;\n+\n+    debug!(\"environment(def_id = {:?})\", def_id);\n+\n+    // The environment of an impl Trait type is its defining function's environment.\n+    if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n+        return environment(tcx, parent);\n+    }\n+\n+    // Compute the bounds on `Self` and the type parameters.\n+    let ty::InstantiatedPredicates { predicates, .. } =\n+        tcx.predicates_of(def_id).instantiate_identity(tcx);\n+\n+    let clauses = predicates.into_iter().map(|pred| ChalkEnvironmentClause::Predicate(pred));\n+\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let node = tcx.hir().get(hir_id);\n+\n+    enum NodeKind {\n+        TraitImpl,\n+        InherentImpl,\n+        Fn,\n+        Other,\n+    };\n+\n+    let node_kind = match node {\n+        Node::TraitItem(item) => match item.kind {\n+            TraitItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n+        },\n+\n+        Node::ImplItem(item) => match item.kind {\n+            ImplItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n+        },\n+\n+        Node::Item(item) => match item.kind {\n+            ItemKind::Impl { of_trait: Some(_), .. } => NodeKind::TraitImpl,\n+            ItemKind::Impl { of_trait: None, .. } => NodeKind::InherentImpl,\n+            ItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n+        },\n+\n+        Node::ForeignItem(item) => match item.kind {\n+            ForeignItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n+        },\n+\n+        // FIXME: closures?\n+        _ => NodeKind::Other,\n+    };\n+\n+    // FIXME(eddyb) isn't the unordered nature of this a hazard?\n+    let mut inputs = FxHashSet::default();\n+\n+    match node_kind {\n+        // In a trait impl, we assume that the header trait ref and all its\n+        // constituents are well-formed.\n+        NodeKind::TraitImpl => {\n+            let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+\n+            inputs.extend(trait_ref.substs.iter().flat_map(|&arg| arg.walk()));\n+        }\n+\n+        // In an inherent impl, we assume that the receiver type and all its\n+        // constituents are well-formed.\n+        NodeKind::InherentImpl => {\n+            let self_ty = tcx.type_of(def_id);\n+            inputs.extend(self_ty.walk());\n+        }\n+\n+        // In an fn, we assume that the arguments and all their constituents are\n+        // well-formed.\n+        NodeKind::Fn => {\n+            let fn_sig = tcx.fn_sig(def_id);\n+            let fn_sig = tcx.liberate_late_bound_regions(def_id, &fn_sig);\n+\n+            inputs.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk()));\n+        }\n+\n+        NodeKind::Other => (),\n+    }\n+    let input_clauses = inputs.into_iter().filter_map(|arg| {\n+        match arg.unpack() {\n+            GenericArgKind::Type(ty) => Some(ChalkEnvironmentClause::TypeFromEnv(ty)),\n+\n+            // FIXME(eddyb) no WF conditions from lifetimes?\n+            GenericArgKind::Lifetime(_) => None,\n+\n+            // FIXME(eddyb) support const generics in Chalk\n+            GenericArgKind::Const(_) => None,\n+        }\n+    });\n+\n+    tcx.mk_chalk_environment_clause_list(clauses.chain(input_clauses))\n+}\n+\n+/// We need to wrap a `ty::Predicate` in an elaborated environment *before* we\n+/// canonicalize. This is due to the fact that we insert extra clauses into the\n+/// environment for all input types (`FromEnv`).\n+fn in_environment(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    obligation: &PredicateObligation<'tcx>,\n+) -> ChalkEnvironmentAndGoal<'tcx> {\n+    assert!(!infcx.is_in_snapshot());\n+    let obligation = infcx.resolve_vars_if_possible(obligation);\n+\n+    let environment = match obligation.param_env.def_id {\n+        Some(def_id) => environment(infcx.tcx, def_id),\n+        None if obligation.param_env.caller_bounds.is_empty() => ty::List::empty(),\n+        _ => bug!(\"non-empty `ParamEnv` with no def-id\"),\n+    };\n+\n+    ChalkEnvironmentAndGoal { environment, goal: obligation.predicate }\n+}\n+\n+impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n+    fn normalize_projection_type(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        _param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        _cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx> {\n+        infcx.tcx.mk_ty(ty::Projection(projection_ty))\n+    }\n+\n+    fn register_predicate_obligation(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    ) {\n+        assert!(!infcx.is_in_snapshot());\n+        let obligation = infcx.resolve_vars_if_possible(&obligation);\n+\n+        self.obligations.insert(obligation);\n+    }\n+\n+    fn select_all_or_error(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        self.select_where_possible(infcx)?;\n+\n+        if self.obligations.is_empty() {\n+            Ok(())\n+        } else {\n+            let errors = self\n+                .obligations\n+                .iter()\n+                .map(|obligation| FulfillmentError {\n+                    obligation: obligation.clone(),\n+                    code: FulfillmentErrorCode::CodeAmbiguity,\n+                    points_at_arg_span: false,\n+                })\n+                .collect();\n+            Err(errors)\n+        }\n+    }\n+\n+    fn select_where_possible(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        let mut errors = Vec::new();\n+        let mut next_round = FxHashSet::default();\n+        let mut making_progress;\n+\n+        loop {\n+            making_progress = false;\n+\n+            // We iterate over all obligations, and record if we are able\n+            // to unambiguously prove at least one obligation.\n+            for obligation in self.obligations.drain() {\n+                let goal_in_environment = in_environment(infcx, &obligation);\n+                let mut orig_values = OriginalQueryValues::default();\n+                let canonical_goal =\n+                    infcx.canonicalize_query(&goal_in_environment, &mut orig_values);\n+\n+                match infcx.tcx.evaluate_goal(canonical_goal) {\n+                    Ok(response) => {\n+                        if response.is_proven() {\n+                            making_progress = true;\n+\n+                            match infcx.instantiate_query_response_and_region_obligations(\n+                                &obligation.cause,\n+                                obligation.param_env,\n+                                &orig_values,\n+                                &response,\n+                            ) {\n+                                Ok(infer_ok) => next_round.extend(\n+                                    infer_ok.obligations.into_iter().map(|obligation| {\n+                                        assert!(!infcx.is_in_snapshot());\n+                                        infcx.resolve_vars_if_possible(&obligation)\n+                                    }),\n+                                ),\n+\n+                                Err(_err) => errors.push(FulfillmentError {\n+                                    obligation: obligation,\n+                                    code: FulfillmentErrorCode::CodeSelectionError(\n+                                        SelectionError::Unimplemented,\n+                                    ),\n+                                    points_at_arg_span: false,\n+                                }),\n+                            }\n+                        } else {\n+                            // Ambiguous: retry at next round.\n+                            next_round.insert(obligation);\n+                        }\n+                    }\n+\n+                    Err(NoSolution) => errors.push(FulfillmentError {\n+                        obligation: obligation,\n+                        code: FulfillmentErrorCode::CodeSelectionError(\n+                            SelectionError::Unimplemented,\n+                        ),\n+                        points_at_arg_span: false,\n+                    }),\n+                }\n+            }\n+            next_round = std::mem::replace(&mut self.obligations, next_round);\n+\n+            if !making_progress {\n+                break;\n+            }\n+        }\n+\n+        if errors.is_empty() { Ok(()) } else { Err(errors) }\n+    }\n+\n+    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n+        self.obligations.iter().map(|obligation| obligation.clone()).collect()\n+    }\n+}"}, {"sha": "4d4778869794b9bab6bd09157c4316a24d1bc0b7", "filename": "src/librustc_trait_selection/traits/engine.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,14 +1,18 @@\n use rustc_middle::ty::TyCtxt;\n \n-use super::FulfillmentContext;\n use super::TraitEngine;\n+use super::{ChalkFulfillmentContext, FulfillmentContext};\n \n pub trait TraitEngineExt<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n }\n \n impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n-    fn new(_tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        Box::new(FulfillmentContext::new())\n+    fn new(tcx: TyCtxt<'tcx>) -> Box<Self> {\n+        if tcx.sess.opts.debugging_opts.chalk {\n+            Box::new(ChalkFulfillmentContext::new())\n+        } else {\n+            Box::new(FulfillmentContext::new())\n+        }\n     }\n }"}, {"sha": "405c656bad56283fe8884a7cab10f8943518364f", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -570,12 +570,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::Predicate::WellFormed(ty) => {\n-                        // WF predicates cannot themselves make\n-                        // errors. They can only block due to\n-                        // ambiguity; otherwise, they always\n-                        // degenerate into other obligations\n-                        // (which may fail).\n-                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        if !self.tcx.sess.opts.debugging_opts.chalk {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        } else {\n+                            // FIXME: we'll need a better message which takes into account\n+                            // which bounds actually failed to hold.\n+                            self.tcx.sess.struct_span_err(\n+                                span,\n+                                &format!(\"the type `{}` is not well-formed (chalk)\", ty),\n+                            )\n+                        }\n                     }\n \n                     ty::Predicate::ConstEvaluatable(..) => {"}, {"sha": "778430fc2ca9cba87be0366571e2cffb583a261a", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -4,6 +4,7 @@\n \n #[allow(dead_code)]\n pub mod auto_trait;\n+mod chalk_fulfill;\n pub mod codegen;\n mod coherence;\n mod engine;\n@@ -69,6 +70,8 @@ pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n };\n \n+pub use self::chalk_fulfill::FulfillmentContext as ChalkFulfillmentContext;\n+\n pub use rustc_infer::traits::*;\n \n /// Whether to skip the leak check, as part of a future compatibility warning step."}, {"sha": "47df82690e07d82599c8de1676e319627a7b96a4", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -17,14 +17,13 @@ use super::{VtableClosureData, VtableFnPointerData, VtableGeneratorData, VtableI\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::traits::error_reporting::InferCtxtExt;\n-use rustc_ast::ast::Ident;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::DUMMY_SP;\n \n pub use rustc_middle::traits::Reveal;"}, {"sha": "b595f77e4d6f2404cd13b88b788f61df19c097cc", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2877,11 +2877,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             trait_ref,\n         )?);\n \n-        obligations.push(Obligation::new(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n-        ));\n+        // FIXME: Chalk\n+\n+        if !self.tcx().sess.opts.debugging_opts.chalk {\n+            obligations.push(Obligation::new(\n+                obligation.cause.clone(),\n+                obligation.param_env,\n+                ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n+            ));\n+        }\n \n         Ok(VtableClosureData { closure_def_id, substs, nested: obligations })\n     }"}, {"sha": "e485bc2929bdb9feee7287acb626c05703cf048c", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -13,8 +13,12 @@ log = { version = \"0.4\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_index = { path = \"../librustc_index\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n+chalk-ir = \"0.10.0\"\n+chalk-rust-ir = \"0.10.0\"\n+chalk-solve = \"0.10.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../librustc_infer\" }\n rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "0cec583bb566e0e79e4a33316e0d59682a58335d", "filename": "src/librustc_traits/chalk/db.rs", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fdb.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,521 @@\n+//! Provides the `RustIrDatabase` implementation for `chalk-solve`\n+//!\n+//! The purpose of the `chalk_solve::RustIrDatabase` is to get data about\n+//! specific types, such as bounds, where clauses, or fields. This file contains\n+//! the minimal logic to assemble the types for `chalk-solve` by calling out to\n+//! either the `TyCtxt` (for information about types) or\n+//! `crate::chalk::lowering` (to lower rustc types into Chalk types).\n+\n+use rustc_middle::traits::{ChalkRustDefId as RustDefId, ChalkRustInterner as RustInterner};\n+use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use rustc_middle::ty::{self, AssocItemContainer, AssocKind, TyCtxt};\n+\n+use rustc_hir::def_id::DefId;\n+\n+use rustc_span::symbol::sym;\n+\n+use std::fmt;\n+use std::sync::Arc;\n+\n+use crate::chalk::lowering::LowerInto;\n+\n+pub struct RustIrDatabase<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub interner: RustInterner<'tcx>,\n+}\n+\n+impl fmt::Debug for RustIrDatabase<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"RustIrDatabase\")\n+    }\n+}\n+\n+impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'tcx> {\n+    fn interner(&self) -> &RustInterner<'tcx> {\n+        &self.interner\n+    }\n+\n+    fn associated_ty_data(\n+        &self,\n+        assoc_type_id: chalk_ir::AssocTypeId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<RustInterner<'tcx>>> {\n+        let def_id = match assoc_type_id.0 {\n+            RustDefId::AssocTy(def_id) => def_id,\n+            _ => bug!(\"Did not use `AssocTy` variant when expecting associated type.\"),\n+        };\n+        let assoc_item = self.tcx.associated_item(def_id);\n+        let trait_def_id = match assoc_item.container {\n+            AssocItemContainer::TraitContainer(def_id) => def_id,\n+            _ => unimplemented!(\"Not possible??\"),\n+        };\n+        match assoc_item.kind {\n+            AssocKind::Type => {}\n+            _ => unimplemented!(\"Not possible??\"),\n+        }\n+        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let binders = binders_for(&self.interner, bound_vars);\n+        // FIXME(chalk): this really isn't right I don't think. The functions\n+        // for GATs are a bit hard to figure out. Are these supposed to be where\n+        // clauses or bounds?\n+        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n+        let where_clauses: Vec<_> = predicates\n+            .into_iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n+        Arc::new(chalk_rust_ir::AssociatedTyDatum {\n+            trait_id: chalk_ir::TraitId(RustDefId::Trait(trait_def_id)),\n+            id: assoc_type_id,\n+            name: (),\n+            binders: chalk_ir::Binders::new(\n+                binders,\n+                chalk_rust_ir::AssociatedTyDatumBound { bounds: vec![], where_clauses },\n+            ),\n+        })\n+    }\n+\n+    fn trait_datum(\n+        &self,\n+        trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::TraitDatum<RustInterner<'tcx>>> {\n+        let def_id = match trait_id.0 {\n+            RustDefId::Trait(def_id) => def_id,\n+            _ => bug!(\"Did not use `Trait` variant when expecting trait.\"),\n+        };\n+        let trait_def = self.tcx.trait_def(def_id);\n+\n+        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let binders = binders_for(&self.interner, bound_vars);\n+        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n+        let where_clauses: Vec<_> = predicates\n+            .into_iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n+        let well_known =\n+            if self.tcx.lang_items().sized_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_rust_ir::WellKnownTrait::SizedTrait)\n+            } else if self.tcx.lang_items().copy_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_rust_ir::WellKnownTrait::CopyTrait)\n+            } else if self.tcx.lang_items().clone_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_rust_ir::WellKnownTrait::CloneTrait)\n+            } else {\n+                None\n+            };\n+        Arc::new(chalk_rust_ir::TraitDatum {\n+            id: trait_id,\n+            binders: chalk_ir::Binders::new(\n+                binders,\n+                chalk_rust_ir::TraitDatumBound { where_clauses },\n+            ),\n+            flags: chalk_rust_ir::TraitFlags {\n+                auto: trait_def.has_auto_impl,\n+                marker: trait_def.is_marker,\n+                upstream: !def_id.is_local(),\n+                fundamental: self.tcx.has_attr(def_id, sym::fundamental),\n+                non_enumerable: true,\n+                coinductive: false,\n+            },\n+            associated_ty_ids: vec![],\n+            well_known,\n+        })\n+    }\n+\n+    fn struct_datum(\n+        &self,\n+        struct_id: chalk_ir::StructId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::StructDatum<RustInterner<'tcx>>> {\n+        match struct_id.0 {\n+            RustDefId::Adt(adt_def_id) => {\n+                let adt_def = self.tcx.adt_def(adt_def_id);\n+\n+                let bound_vars = bound_vars_for_item(self.tcx, adt_def_id);\n+                let binders = binders_for(&self.interner, bound_vars);\n+\n+                let predicates = self.tcx.predicates_of(adt_def_id).predicates;\n+                let where_clauses: Vec<_> = predicates\n+                    .into_iter()\n+                    .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n+                    .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner))\n+                    .collect();\n+                let fields = match adt_def.adt_kind() {\n+                    ty::AdtKind::Struct | ty::AdtKind::Union => {\n+                        let variant = adt_def.non_enum_variant();\n+                        variant\n+                            .fields\n+                            .iter()\n+                            .map(|field| {\n+                                self.tcx\n+                                    .type_of(field.did)\n+                                    .subst(self.tcx, bound_vars)\n+                                    .lower_into(&self.interner)\n+                            })\n+                            .collect()\n+                    }\n+                    // FIXME(chalk): handle enums; force_impl_for requires this\n+                    ty::AdtKind::Enum => vec![],\n+                };\n+                let struct_datum = Arc::new(chalk_rust_ir::StructDatum {\n+                    id: struct_id,\n+                    binders: chalk_ir::Binders::new(\n+                        binders,\n+                        chalk_rust_ir::StructDatumBound { fields, where_clauses },\n+                    ),\n+                    flags: chalk_rust_ir::StructFlags {\n+                        upstream: !adt_def_id.is_local(),\n+                        fundamental: adt_def.is_fundamental(),\n+                    },\n+                });\n+                return struct_datum;\n+            }\n+            RustDefId::Ref(_) => {\n+                return Arc::new(chalk_rust_ir::StructDatum {\n+                    id: struct_id,\n+                    binders: chalk_ir::Binders::new(\n+                        chalk_ir::ParameterKinds::from(\n+                            &self.interner,\n+                            vec![\n+                                chalk_ir::ParameterKind::Lifetime(()),\n+                                chalk_ir::ParameterKind::Ty(()),\n+                            ],\n+                        ),\n+                        chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+                    ),\n+                    flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n+                });\n+            }\n+            RustDefId::Array | RustDefId::Slice => {\n+                return Arc::new(chalk_rust_ir::StructDatum {\n+                    id: struct_id,\n+                    binders: chalk_ir::Binders::new(\n+                        chalk_ir::ParameterKinds::from(\n+                            &self.interner,\n+                            Some(chalk_ir::ParameterKind::Ty(())),\n+                        ),\n+                        chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+                    ),\n+                    flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n+                });\n+            }\n+            RustDefId::Str | RustDefId::Never | RustDefId::FnDef(_) => {\n+                return Arc::new(chalk_rust_ir::StructDatum {\n+                    id: struct_id,\n+                    binders: chalk_ir::Binders::new(\n+                        chalk_ir::ParameterKinds::new(&self.interner),\n+                        chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+                    ),\n+                    flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n+                });\n+            }\n+\n+            _ => bug!(\"Used not struct variant when expecting struct variant.\"),\n+        }\n+    }\n+\n+    fn impl_datum(\n+        &self,\n+        impl_id: chalk_ir::ImplId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::ImplDatum<RustInterner<'tcx>>> {\n+        let def_id = match impl_id.0 {\n+            RustDefId::Impl(def_id) => def_id,\n+            _ => bug!(\"Did not use `Impl` variant when expecting impl.\"),\n+        };\n+        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let binders = binders_for(&self.interner, bound_vars);\n+\n+        let trait_ref = self.tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+        let trait_ref = trait_ref.subst(self.tcx, bound_vars);\n+\n+        let predicates = self.tcx.predicates_of(def_id).predicates;\n+        let where_clauses: Vec<_> = predicates\n+            .into_iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n+        let value = chalk_rust_ir::ImplDatumBound {\n+            trait_ref: trait_ref.lower_into(&self.interner),\n+            where_clauses,\n+        };\n+\n+        Arc::new(chalk_rust_ir::ImplDatum {\n+            polarity: chalk_rust_ir::Polarity::Positive,\n+            binders: chalk_ir::Binders::new(binders, value),\n+            impl_type: chalk_rust_ir::ImplType::Local,\n+            associated_ty_value_ids: vec![],\n+        })\n+    }\n+\n+    fn impls_for_trait(\n+        &self,\n+        trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n+        parameters: &[chalk_ir::Parameter<RustInterner<'tcx>>],\n+    ) -> Vec<chalk_ir::ImplId<RustInterner<'tcx>>> {\n+        let def_id: DefId = match trait_id.0 {\n+            RustDefId::Trait(def_id) => def_id,\n+            _ => bug!(\"Did not use `Trait` variant when expecting trait.\"),\n+        };\n+\n+        // FIXME(chalk): use TraitDef::for_each_relevant_impl, but that will\n+        // require us to be able to interconvert `Ty<'tcx>`, and we're\n+        // not there yet.\n+\n+        let all_impls = self.tcx.all_impls(def_id);\n+        let matched_impls = all_impls.into_iter().filter(|impl_def_id| {\n+            use chalk_ir::could_match::CouldMatch;\n+            let trait_ref = self.tcx.impl_trait_ref(*impl_def_id).unwrap();\n+            let bound_vars = bound_vars_for_item(self.tcx, *impl_def_id);\n+\n+            let self_ty = trait_ref.self_ty();\n+            let self_ty = self_ty.subst(self.tcx, bound_vars);\n+            let lowered_ty = self_ty.lower_into(&self.interner);\n+\n+            parameters[0].assert_ty_ref(&self.interner).could_match(&self.interner, &lowered_ty)\n+        });\n+\n+        let impls = matched_impls\n+            .map(|matched_impl| chalk_ir::ImplId(RustDefId::Impl(matched_impl)))\n+            .collect();\n+        impls\n+    }\n+\n+    fn impl_provided_for(\n+        &self,\n+        auto_trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n+        struct_id: chalk_ir::StructId<RustInterner<'tcx>>,\n+    ) -> bool {\n+        let trait_def_id: DefId = match auto_trait_id.0 {\n+            RustDefId::Trait(def_id) => def_id,\n+            _ => bug!(\"Did not use `Trait` variant when expecting trait.\"),\n+        };\n+        let adt_def_id: DefId = match struct_id.0 {\n+            RustDefId::Adt(def_id) => def_id,\n+            _ => bug!(\"Did not use `Adt` variant when expecting adt.\"),\n+        };\n+        let all_impls = self.tcx.all_impls(trait_def_id);\n+        for impl_def_id in all_impls {\n+            let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n+            let self_ty = trait_ref.self_ty();\n+            match self_ty.kind {\n+                ty::Adt(adt_def, _) => {\n+                    if adt_def.did == adt_def_id {\n+                        return true;\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        return false;\n+    }\n+\n+    fn associated_ty_value(\n+        &self,\n+        associated_ty_id: chalk_rust_ir::AssociatedTyValueId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n+        let def_id = match associated_ty_id.0 {\n+            RustDefId::AssocTy(def_id) => def_id,\n+            _ => bug!(\"Did not use `AssocTy` variant when expecting associated type.\"),\n+        };\n+        let assoc_item = self.tcx.associated_item(def_id);\n+        let impl_id = match assoc_item.container {\n+            AssocItemContainer::TraitContainer(def_id) => def_id,\n+            _ => unimplemented!(\"Not possible??\"),\n+        };\n+        match assoc_item.kind {\n+            AssocKind::Type => {}\n+            _ => unimplemented!(\"Not possible??\"),\n+        }\n+        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let binders = binders_for(&self.interner, bound_vars);\n+        let ty = self.tcx.type_of(def_id);\n+\n+        Arc::new(chalk_rust_ir::AssociatedTyValue {\n+            impl_id: chalk_ir::ImplId(RustDefId::Impl(impl_id)),\n+            associated_ty_id: chalk_ir::AssocTypeId(RustDefId::AssocTy(def_id)),\n+            value: chalk_ir::Binders::new(\n+                binders,\n+                chalk_rust_ir::AssociatedTyValueBound { ty: ty.lower_into(&self.interner) },\n+            ),\n+        })\n+    }\n+\n+    fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<RustInterner<'tcx>>> {\n+        vec![]\n+    }\n+\n+    fn local_impls_to_coherence_check(\n+        &self,\n+        _trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n+    ) -> Vec<chalk_ir::ImplId<RustInterner<'tcx>>> {\n+        unimplemented!()\n+    }\n+\n+    fn opaque_ty_data(\n+        &self,\n+        _id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n+        unimplemented!()\n+    }\n+\n+    /// Since Chalk can't handle all Rust types currently, we have to handle\n+    /// some specially for now. Over time, these `Some` returns will change to\n+    /// `None` and eventually this function will be removed.\n+    fn force_impl_for(\n+        &self,\n+        well_known: chalk_rust_ir::WellKnownTrait,\n+        ty: &chalk_ir::TyData<RustInterner<'tcx>>,\n+    ) -> Option<bool> {\n+        use chalk_ir::TyData::*;\n+        match well_known {\n+            chalk_rust_ir::WellKnownTrait::SizedTrait => match ty {\n+                Apply(apply) => match apply.name {\n+                    chalk_ir::TypeName::Struct(chalk_ir::StructId(rust_def_id)) => {\n+                        use rustc_middle::traits::ChalkRustDefId::*;\n+                        match rust_def_id {\n+                            Never | Array | RawPtr | FnDef(_) | Ref(_) => Some(true),\n+\n+                            Adt(adt_def_id) => {\n+                                let adt_def = self.tcx.adt_def(adt_def_id);\n+                                match adt_def.adt_kind() {\n+                                    ty::AdtKind::Struct | ty::AdtKind::Union => None,\n+                                    ty::AdtKind::Enum => {\n+                                        let constraint = self.tcx.adt_sized_constraint(adt_def_id);\n+                                        if constraint.0.len() > 0 {\n+                                            unimplemented!()\n+                                        } else {\n+                                            Some(true)\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            Str | Slice => Some(false),\n+\n+                            Trait(_) | Impl(_) | AssocTy(_) => panic!(),\n+                        }\n+                    }\n+                    _ => None,\n+                },\n+                Dyn(_) | Alias(_) | Placeholder(_) | Function(_) | InferenceVar(_)\n+                | BoundVar(_) => None,\n+            },\n+            chalk_rust_ir::WellKnownTrait::CopyTrait\n+            | chalk_rust_ir::WellKnownTrait::CloneTrait => match ty {\n+                Apply(apply) => match apply.name {\n+                    chalk_ir::TypeName::Struct(chalk_ir::StructId(rust_def_id)) => {\n+                        use rustc_middle::traits::ChalkRustDefId::*;\n+                        match rust_def_id {\n+                            Never | RawPtr | Ref(_) | Str | Slice => Some(false),\n+                            FnDef(_) | Array => Some(true),\n+                            Adt(adt_def_id) => {\n+                                let adt_def = self.tcx.adt_def(adt_def_id);\n+                                match adt_def.adt_kind() {\n+                                    ty::AdtKind::Struct | ty::AdtKind::Union => None,\n+                                    ty::AdtKind::Enum => {\n+                                        let constraint = self.tcx.adt_sized_constraint(adt_def_id);\n+                                        if constraint.0.len() > 0 {\n+                                            unimplemented!()\n+                                        } else {\n+                                            Some(true)\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            Trait(_) | Impl(_) | AssocTy(_) => panic!(),\n+                        }\n+                    }\n+                    _ => None,\n+                },\n+                Dyn(_) | Alias(_) | Placeholder(_) | Function(_) | InferenceVar(_)\n+                | BoundVar(_) => None,\n+            },\n+            chalk_rust_ir::WellKnownTrait::DropTrait => None,\n+        }\n+    }\n+\n+    fn program_clauses_for_env(\n+        &self,\n+        environment: &chalk_ir::Environment<RustInterner<'tcx>>,\n+    ) -> chalk_ir::ProgramClauses<RustInterner<'tcx>> {\n+        chalk_solve::program_clauses_for_env(self, environment)\n+    }\n+\n+    fn well_known_trait_id(\n+        &self,\n+        well_known_trait: chalk_rust_ir::WellKnownTrait,\n+    ) -> Option<chalk_ir::TraitId<RustInterner<'tcx>>> {\n+        use chalk_rust_ir::WellKnownTrait::*;\n+        let t = match well_known_trait {\n+            SizedTrait => self\n+                .tcx\n+                .lang_items()\n+                .sized_trait()\n+                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n+                .unwrap(),\n+            CopyTrait => self\n+                .tcx\n+                .lang_items()\n+                .copy_trait()\n+                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n+                .unwrap(),\n+            CloneTrait => self\n+                .tcx\n+                .lang_items()\n+                .clone_trait()\n+                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n+                .unwrap(),\n+            DropTrait => self\n+                .tcx\n+                .lang_items()\n+                .drop_trait()\n+                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n+                .unwrap(),\n+        };\n+        Some(t)\n+    }\n+}\n+\n+/// Creates a `InternalSubsts` that maps each generic parameter to a higher-ranked\n+/// var bound at index `0`. For types, we use a `BoundVar` index equal to\n+/// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n+/// variant (which has a `DefId`).\n+fn bound_vars_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n+    InternalSubsts::for_item(tcx, def_id, |param, substs| match param.kind {\n+        ty::GenericParamDefKind::Type { .. } => tcx\n+            .mk_ty(ty::Bound(\n+                ty::INNERMOST,\n+                ty::BoundTy {\n+                    var: ty::BoundVar::from(param.index),\n+                    kind: ty::BoundTyKind::Param(param.name),\n+                },\n+            ))\n+            .into(),\n+\n+        ty::GenericParamDefKind::Lifetime => tcx\n+            .mk_region(ty::RegionKind::ReLateBound(\n+                ty::INNERMOST,\n+                ty::BoundRegion::BrAnon(substs.len() as u32),\n+            ))\n+            .into(),\n+\n+        ty::GenericParamDefKind::Const => tcx\n+            .mk_const(ty::Const {\n+                val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n+                ty: tcx.type_of(param.def_id),\n+            })\n+            .into(),\n+    })\n+}\n+\n+fn binders_for<'tcx>(\n+    interner: &RustInterner<'tcx>,\n+    bound_vars: SubstsRef<'tcx>,\n+) -> chalk_ir::ParameterKinds<RustInterner<'tcx>> {\n+    chalk_ir::ParameterKinds::from(\n+        interner,\n+        bound_vars.iter().map(|arg| match arg.unpack() {\n+            ty::subst::GenericArgKind::Lifetime(_re) => chalk_ir::ParameterKind::Lifetime(()),\n+            ty::subst::GenericArgKind::Type(_ty) => chalk_ir::ParameterKind::Ty(()),\n+            ty::subst::GenericArgKind::Const(_const) => chalk_ir::ParameterKind::Ty(()),\n+        }),\n+    )\n+}"}, {"sha": "4dc15a6b2b65f453f0bf893974f3029018160cd6", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "added", "additions": 722, "deletions": 0, "changes": 722, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,722 @@\n+//! Contains the logic to lower rustc types into Chalk types\n+//!\n+//! In many cases there is a 1:1 relationship between a rustc type and a Chalk type.\n+//! For example, a `SubstsRef` maps almost directly to a `Substitution`. In some\n+//! other cases, such as `Param`s, there is no Chalk type, so we have to handle\n+//! accordingly.\n+//!\n+//! ## `Ty` lowering\n+//! Much of the `Ty` lowering is 1:1 with Chalk. (Or will be eventually). A\n+//! helpful table for what types lower to what can be found in the\n+//! [Chalk book](http://rust-lang.github.io/chalk/book/types/rust_types.html).\n+//! The most notable difference lies with `Param`s. To convert from rustc to\n+//! Chalk, we eagerly and deeply convert `Param`s to placeholders (in goals) or\n+//! bound variables (for clause generation through functions in `db`).\n+//!\n+//! ## `Region` lowering\n+//! Regions are handled in rustc and Chalk is quite differently. In rustc, there\n+//! is a difference between \"early bound\" and \"late bound\" regions, where only\n+//! the late bound regions have a `DebruijnIndex`. Moreover, in Chalk all\n+//! regions (Lifetimes) have an associated index. In rustc, only `BrAnon`s have\n+//! an index, whereas `BrNamed` don't. In order to lower regions to Chalk, we\n+//! convert all regions into `BrAnon` late-bound regions.\n+//!\n+//! ## `Const` lowering\n+//! Chalk doesn't handle consts currently, so consts are currently lowered to\n+//! an empty tuple.\n+//!\n+//! ## Bound variable collection\n+//! Another difference between rustc and Chalk lies in the handling of binders.\n+//! Chalk requires that we store the bound parameter kinds, whereas rustc does\n+//! not. To lower anything wrapped in a `Binder`, we first deeply find any bound\n+//! variables from the current `Binder`.\n+\n+use rustc_middle::traits::{\n+    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, ChalkRustDefId as RustDefId,\n+    ChalkRustInterner as RustInterner,\n+};\n+use rustc_middle::ty::fold::TypeFolder;\n+use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n+use rustc_middle::ty::{\n+    self, Binder, BoundRegion, Predicate, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable,\n+    TypeVisitor,\n+};\n+use rustc_span::def_id::DefId;\n+\n+use std::collections::btree_map::{BTreeMap, Entry};\n+\n+/// Essentially an `Into` with a `&RustInterner` parameter\n+crate trait LowerInto<'tcx, T> {\n+    /// Lower a rustc construct (e.g., `ty::TraitPredicate`) to a chalk type, consuming `self`.\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> T;\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Substitution<RustInterner<'tcx>>> for SubstsRef<'tcx> {\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> chalk_ir::Substitution<RustInterner<'tcx>> {\n+        chalk_ir::Substitution::from(interner, self.iter().map(|s| s.lower_into(interner)))\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::AliasTy<RustInterner<'tcx>>> for ty::ProjectionTy<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::AliasTy<RustInterner<'tcx>> {\n+        chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n+            associated_ty_id: chalk_ir::AssocTypeId(RustDefId::AssocTy(self.item_def_id)),\n+            substitution: self.substs.lower_into(interner),\n+        })\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>>>\n+    for ChalkEnvironmentAndGoal<'tcx>\n+{\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n+        let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n+            ChalkEnvironmentClause::Predicate(predicate) => {\n+                match predicate {\n+                    ty::Predicate::Trait(predicate, _) => {\n+                        let (predicate, binders, _named_regions) =\n+                            collect_bound_vars(interner, interner.tcx, predicate);\n+\n+                        Some(\n+                            chalk_ir::ProgramClauseData::ForAll(chalk_ir::Binders::new(\n+                                binders,\n+                                chalk_ir::ProgramClauseImplication {\n+                                    consequence: chalk_ir::DomainGoal::FromEnv(\n+                                        chalk_ir::FromEnv::Trait(\n+                                            predicate.trait_ref.lower_into(interner),\n+                                        ),\n+                                    ),\n+                                    conditions: chalk_ir::Goals::new(interner),\n+                                    priority: chalk_ir::ClausePriority::High,\n+                                },\n+                            ))\n+                            .intern(interner),\n+                        )\n+                    }\n+                    // FIXME(chalk): need to add RegionOutlives/TypeOutlives\n+                    ty::Predicate::RegionOutlives(_) => None,\n+                    ty::Predicate::TypeOutlives(_) => None,\n+                    ty::Predicate::Projection(predicate) => {\n+                        let (predicate, binders, _named_regions) =\n+                            collect_bound_vars(interner, interner.tcx, predicate);\n+\n+                        Some(\n+                            chalk_ir::ProgramClauseData::ForAll(chalk_ir::Binders::new(\n+                                binders,\n+                                chalk_ir::ProgramClauseImplication {\n+                                    consequence: chalk_ir::DomainGoal::Holds(\n+                                        chalk_ir::WhereClause::AliasEq(\n+                                            predicate.lower_into(interner),\n+                                        ),\n+                                    ),\n+                                    conditions: chalk_ir::Goals::new(interner),\n+                                    priority: chalk_ir::ClausePriority::High,\n+                                },\n+                            ))\n+                            .intern(interner),\n+                        )\n+                    }\n+                    ty::Predicate::WellFormed(..)\n+                    | ty::Predicate::ObjectSafe(..)\n+                    | ty::Predicate::ClosureKind(..)\n+                    | ty::Predicate::Subtype(..)\n+                    | ty::Predicate::ConstEvaluatable(..) => {\n+                        bug!(\"unexpected predicate {}\", predicate)\n+                    }\n+                }\n+            }\n+            ChalkEnvironmentClause::TypeFromEnv(ty) => Some(\n+                chalk_ir::ProgramClauseData::Implies(chalk_ir::ProgramClauseImplication {\n+                    consequence: chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(\n+                        ty.lower_into(interner),\n+                    )),\n+                    conditions: chalk_ir::Goals::new(interner),\n+                    priority: chalk_ir::ClausePriority::High,\n+                })\n+                .intern(interner),\n+            ),\n+        });\n+\n+        let goal: chalk_ir::GoalData<RustInterner<'tcx>> = self.goal.lower_into(&interner);\n+        chalk_ir::InEnvironment {\n+            environment: chalk_ir::Environment {\n+                clauses: chalk_ir::ProgramClauses::from(&interner, clauses),\n+            },\n+            goal: goal.intern(&interner),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n+        match self {\n+            Predicate::Trait(predicate, _) => predicate.lower_into(interner),\n+            // FIXME(chalk): we need to register constraints.\n+            Predicate::RegionOutlives(_predicate) => {\n+                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            }\n+            Predicate::TypeOutlives(_predicate) => {\n+                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            }\n+            Predicate::Projection(predicate) => predicate.lower_into(interner),\n+            Predicate::WellFormed(ty) => match ty.kind {\n+                // These types are always WF.\n+                ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n+                    chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+                }\n+\n+                // FIXME(chalk): Well-formed only if ref lifetime outlives type\n+                ty::Ref(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n+\n+                ty::Param(..) => panic!(\"No Params expected.\"),\n+\n+                // FIXME(chalk) -- ultimately I think this is what we\n+                // want to do, and we just have rules for how to prove\n+                // `WellFormed` for everything above, instead of\n+                // inlining a bit the rules of the proof here.\n+                _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n+                    chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n+                )),\n+            },\n+\n+            // FIXME(chalk): other predicates\n+            //\n+            // We can defer this, but ultimately we'll want to express\n+            // some of these in terms of chalk operations.\n+            Predicate::ObjectSafe(..)\n+            | Predicate::ClosureKind(..)\n+            | Predicate::Subtype(..)\n+            | Predicate::ConstEvaluatable(..) => {\n+                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::TraitRef<RustInterner<'tcx>>>\n+    for rustc_middle::ty::TraitRef<'tcx>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::TraitRef<RustInterner<'tcx>> {\n+        chalk_ir::TraitRef {\n+            trait_id: chalk_ir::TraitId(RustDefId::Trait(self.def_id)),\n+            substitution: self.substs.lower_into(interner),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>>\n+    for ty::PolyTraitPredicate<'tcx>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n+        let (ty, binders, _named_regions) = collect_bound_vars(interner, interner.tcx, &self);\n+\n+        chalk_ir::GoalData::Quantified(\n+            chalk_ir::QuantifierKind::ForAll,\n+            chalk_ir::Binders::new(\n+                binders,\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::Implemented(ty.trait_ref.lower_into(interner)),\n+                ))\n+                .intern(interner),\n+            ),\n+        )\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n+    for rustc_middle::ty::ProjectionPredicate<'tcx>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::AliasEq<RustInterner<'tcx>> {\n+        chalk_ir::AliasEq {\n+            ty: self.ty.lower_into(interner),\n+            alias: self.projection_ty.lower_into(interner),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>>\n+    for ty::PolyProjectionPredicate<'tcx>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n+        let (ty, binders, _named_regions) = collect_bound_vars(interner, interner.tcx, &self);\n+\n+        chalk_ir::GoalData::Quantified(\n+            chalk_ir::QuantifierKind::ForAll,\n+            chalk_ir::Binders::new(\n+                binders,\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::AliasEq(ty.lower_into(interner)),\n+                ))\n+                .intern(interner),\n+            ),\n+        )\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n+        use chalk_ir::TyData;\n+        use rustc_ast::ast;\n+        use TyKind::*;\n+\n+        let empty = || chalk_ir::Substitution::empty(interner);\n+        let struct_ty = |def_id| chalk_ir::TypeName::Struct(chalk_ir::StructId(def_id));\n+        let apply = |name, substitution| {\n+            TyData::Apply(chalk_ir::ApplicationTy { name, substitution }).intern(interner)\n+        };\n+        let int = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Int(i)), empty());\n+        let uint = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Uint(i)), empty());\n+        let float = |f| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Float(f)), empty());\n+\n+        return match self.kind {\n+            Bool => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Bool), empty()),\n+            Char => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Char), empty()),\n+            Int(ty) => match ty {\n+                ast::IntTy::Isize => int(chalk_ir::IntTy::Isize),\n+                ast::IntTy::I8 => int(chalk_ir::IntTy::I8),\n+                ast::IntTy::I16 => int(chalk_ir::IntTy::I16),\n+                ast::IntTy::I32 => int(chalk_ir::IntTy::I32),\n+                ast::IntTy::I64 => int(chalk_ir::IntTy::I64),\n+                ast::IntTy::I128 => int(chalk_ir::IntTy::I128),\n+            },\n+            Uint(ty) => match ty {\n+                ast::UintTy::Usize => uint(chalk_ir::UintTy::Usize),\n+                ast::UintTy::U8 => uint(chalk_ir::UintTy::U8),\n+                ast::UintTy::U16 => uint(chalk_ir::UintTy::U16),\n+                ast::UintTy::U32 => uint(chalk_ir::UintTy::U32),\n+                ast::UintTy::U64 => uint(chalk_ir::UintTy::U64),\n+                ast::UintTy::U128 => uint(chalk_ir::UintTy::U128),\n+            },\n+            Float(ty) => match ty {\n+                ast::FloatTy::F32 => float(chalk_ir::FloatTy::F32),\n+                ast::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n+            },\n+            Adt(def, substs) => {\n+                apply(struct_ty(RustDefId::Adt(def.did)), substs.lower_into(interner))\n+            }\n+            Foreign(_def_id) => unimplemented!(),\n+            Str => apply(struct_ty(RustDefId::Str), empty()),\n+            Array(ty, _) => apply(\n+                struct_ty(RustDefId::Array),\n+                chalk_ir::Substitution::from1(\n+                    interner,\n+                    chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner),\n+                ),\n+            ),\n+            Slice(ty) => apply(\n+                struct_ty(RustDefId::Slice),\n+                chalk_ir::Substitution::from1(\n+                    interner,\n+                    chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner),\n+                ),\n+            ),\n+            RawPtr(_) => apply(struct_ty(RustDefId::RawPtr), empty()),\n+            Ref(region, ty, mutability) => apply(\n+                struct_ty(RustDefId::Ref(mutability)),\n+                chalk_ir::Substitution::from(\n+                    interner,\n+                    [\n+                        chalk_ir::ParameterKind::Lifetime(region.lower_into(interner))\n+                            .intern(interner),\n+                        chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner),\n+                    ]\n+                    .iter(),\n+                ),\n+            ),\n+            FnDef(def_id, _) => apply(struct_ty(RustDefId::FnDef(def_id)), empty()),\n+            FnPtr(sig) => {\n+                let (inputs_and_outputs, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, &sig.inputs_and_output());\n+                TyData::Function(chalk_ir::Fn {\n+                    num_binders: binders.len(interner),\n+                    substitution: chalk_ir::Substitution::from(\n+                        interner,\n+                        inputs_and_outputs.iter().map(|ty| {\n+                            chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner)\n+                        }),\n+                    ),\n+                })\n+                .intern(interner)\n+            }\n+            Dynamic(_, _) => unimplemented!(),\n+            Closure(_def_id, _) => unimplemented!(),\n+            Generator(_def_id, _substs, _) => unimplemented!(),\n+            GeneratorWitness(_) => unimplemented!(),\n+            Never => apply(struct_ty(RustDefId::Never), empty()),\n+            Tuple(substs) => {\n+                apply(chalk_ir::TypeName::Tuple(substs.len()), substs.lower_into(interner))\n+            }\n+            Projection(proj) => TyData::Alias(proj.lower_into(interner)).intern(interner),\n+            UnnormalizedProjection(_proj) => unimplemented!(),\n+            Opaque(_def_id, _substs) => unimplemented!(),\n+            // This should have been done eagerly prior to this, and all Params\n+            // should have been substituted to placeholders\n+            Param(_) => panic!(\"Lowering Param when not expected.\"),\n+            Bound(db, bound) => TyData::BoundVar(chalk_ir::BoundVar::new(\n+                chalk_ir::DebruijnIndex::new(db.as_u32()),\n+                bound.var.index(),\n+            ))\n+            .intern(interner),\n+            Placeholder(_placeholder) => TyData::Placeholder(chalk_ir::PlaceholderIndex {\n+                ui: chalk_ir::UniverseIndex { counter: _placeholder.universe.as_usize() },\n+                idx: _placeholder.name.as_usize(),\n+            })\n+            .intern(interner),\n+            Infer(_infer) => unimplemented!(),\n+            Error => unimplemented!(),\n+        };\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Lifetime<RustInterner<'tcx>> {\n+        use rustc_middle::ty::RegionKind::*;\n+\n+        match self {\n+            ReEarlyBound(_) => {\n+                panic!(\"Should have already been substituted.\");\n+            }\n+            ReLateBound(db, br) => match br {\n+                ty::BoundRegion::BrAnon(var) => {\n+                    chalk_ir::LifetimeData::BoundVar(chalk_ir::BoundVar::new(\n+                        chalk_ir::DebruijnIndex::new(db.as_u32()),\n+                        *var as usize,\n+                    ))\n+                    .intern(interner)\n+                }\n+                ty::BoundRegion::BrNamed(_def_id, _name) => unimplemented!(),\n+                ty::BrEnv => unimplemented!(),\n+            },\n+            ReFree(_) => unimplemented!(),\n+            ReScope(_) => unimplemented!(),\n+            ReStatic => unimplemented!(),\n+            ReVar(_) => unimplemented!(),\n+            RePlaceholder(placeholder_region) => {\n+                chalk_ir::LifetimeData::Placeholder(chalk_ir::PlaceholderIndex {\n+                    ui: chalk_ir::UniverseIndex { counter: placeholder_region.universe.index() },\n+                    idx: 0,\n+                })\n+                .intern(interner)\n+            }\n+            ReEmpty(_) => unimplemented!(),\n+            ReErased => unimplemented!(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Parameter<RustInterner<'tcx>>> for GenericArg<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Parameter<RustInterner<'tcx>> {\n+        match self.unpack() {\n+            ty::subst::GenericArgKind::Type(ty) => {\n+                chalk_ir::ParameterKind::Ty(ty.lower_into(interner))\n+            }\n+            ty::subst::GenericArgKind::Lifetime(lifetime) => {\n+                chalk_ir::ParameterKind::Lifetime(lifetime.lower_into(interner))\n+            }\n+            ty::subst::GenericArgKind::Const(_) => chalk_ir::ParameterKind::Ty(\n+                chalk_ir::TyData::Apply(chalk_ir::ApplicationTy {\n+                    name: chalk_ir::TypeName::Tuple(0),\n+                    substitution: chalk_ir::Substitution::empty(interner),\n+                })\n+                .intern(interner),\n+            ),\n+        }\n+        .intern(interner)\n+    }\n+}\n+\n+// We lower into an Option here since there are some predicates which Chalk\n+// doesn't have a representation for yet (as a `WhereClause`), but are so common\n+// that we just are accepting the unsoundness for now. The `Option` will\n+// eventually be removed.\n+impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>\n+    for ty::Predicate<'tcx>\n+{\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n+        match &self {\n+            Predicate::Trait(predicate, _) => {\n+                let (predicate, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, predicate);\n+\n+                Some(chalk_ir::Binders::new(\n+                    binders,\n+                    chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n+                ))\n+            }\n+            Predicate::RegionOutlives(_predicate) => None,\n+            Predicate::TypeOutlives(_predicate) => None,\n+            Predicate::Projection(_predicate) => None,\n+            Predicate::WellFormed(_ty) => None,\n+\n+            Predicate::ObjectSafe(..)\n+            | Predicate::ClosureKind(..)\n+            | Predicate::Subtype(..)\n+            | Predicate::ConstEvaluatable(..) => bug!(\"unexpected predicate {}\", &self),\n+        }\n+    }\n+}\n+\n+/// To collect bound vars, we have to do two passes. In the first pass, we\n+/// collect all `BoundRegion`s and `ty::Bound`s. In the second pass, we then\n+/// replace `BrNamed` into `BrAnon`. The two separate passes are important,\n+/// since we can only replace `BrNamed` with `BrAnon`s with indices *after* all\n+/// \"real\" `BrAnon`s.\n+///\n+/// It's important to note that because of prior substitution, we may have\n+/// late-bound regions, even outside of fn contexts, since this is the best way\n+/// to prep types for chalk lowering.\n+crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n+    interner: &RustInterner<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    ty: &'a Binder<T>,\n+) -> (T, chalk_ir::ParameterKinds<RustInterner<'tcx>>, BTreeMap<DefId, u32>) {\n+    let mut bound_vars_collector = BoundVarsCollector::new();\n+    ty.skip_binder().visit_with(&mut bound_vars_collector);\n+    let mut parameters = bound_vars_collector.parameters;\n+    let named_parameters: BTreeMap<DefId, u32> = bound_vars_collector\n+        .named_parameters\n+        .into_iter()\n+        .enumerate()\n+        .map(|(i, def_id)| (def_id, (i + parameters.len()) as u32))\n+        .collect();\n+\n+    let mut bound_var_substitutor = NamedBoundVarSubstitutor::new(tcx, &named_parameters);\n+    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor);\n+\n+    for var in named_parameters.values() {\n+        parameters.insert(*var, chalk_ir::ParameterKind::Lifetime(()));\n+    }\n+\n+    (0..parameters.len()).for_each(|i| {\n+        parameters.get(&(i as u32)).expect(\"Skipped bound var index.\");\n+    });\n+\n+    let binders = chalk_ir::ParameterKinds::from(interner, parameters.into_iter().map(|(_, v)| v));\n+\n+    (new_ty, binders, named_parameters)\n+}\n+\n+crate struct BoundVarsCollector {\n+    binder_index: ty::DebruijnIndex,\n+    crate parameters: BTreeMap<u32, chalk_ir::ParameterKind<()>>,\n+    crate named_parameters: Vec<DefId>,\n+}\n+\n+impl BoundVarsCollector {\n+    crate fn new() -> Self {\n+        BoundVarsCollector {\n+            binder_index: ty::INNERMOST,\n+            parameters: BTreeMap::new(),\n+            named_parameters: vec![],\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        match t.kind {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                match self.parameters.entry(bound_ty.var.as_u32()) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(chalk_ir::ParameterKind::Ty(()));\n+                    }\n+                    Entry::Occupied(entry) => {\n+                        entry.get().assert_ty_ref();\n+                    }\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: Region<'tcx>) -> bool {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n+                ty::BoundRegion::BrNamed(def_id, _name) => {\n+                    if self.named_parameters.iter().find(|d| *d == def_id).is_none() {\n+                        self.named_parameters.push(*def_id);\n+                    }\n+                }\n+\n+                ty::BoundRegion::BrAnon(var) => match self.parameters.entry(*var) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(chalk_ir::ParameterKind::Lifetime(()));\n+                    }\n+                    Entry::Occupied(entry) => {\n+                        entry.get().assert_lifetime_ref();\n+                    }\n+                },\n+\n+                ty::BrEnv => unimplemented!(),\n+            },\n+\n+            ty::ReEarlyBound(_re) => {\n+                // FIXME(chalk): jackh726 - I think we should always have already\n+                // substituted away `ReEarlyBound`s for `ReLateBound`s, but need to confirm.\n+                unimplemented!();\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+/// This is used to replace `BoundRegion::BrNamed` with `BoundRegion::BrAnon`.\n+/// Note: we assume that we will always have room for more bound vars. (i.e. we\n+/// won't ever hit the `u32` limit in `BrAnon`s).\n+struct NamedBoundVarSubstitutor<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    binder_index: ty::DebruijnIndex,\n+    named_parameters: &'a BTreeMap<DefId, u32>,\n+}\n+\n+impl<'a, 'tcx> NamedBoundVarSubstitutor<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, named_parameters: &'a BTreeMap<DefId, u32>) -> Self {\n+        NamedBoundVarSubstitutor { tcx, binder_index: ty::INNERMOST, named_parameters }\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> Binder<T> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_fold_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        t.super_fold_with(self)\n+    }\n+\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n+                ty::BoundRegion::BrNamed(def_id, _name) => {\n+                    match self.named_parameters.get(def_id) {\n+                        Some(idx) => {\n+                            return self.tcx.mk_region(RegionKind::ReLateBound(\n+                                *index,\n+                                BoundRegion::BrAnon(*idx),\n+                            ));\n+                        }\n+                        None => panic!(\"Missing `BrNamed`.\"),\n+                    }\n+                }\n+                ty::BrEnv => unimplemented!(),\n+                ty::BoundRegion::BrAnon(_) => {}\n+            },\n+            _ => (),\n+        };\n+\n+        r.super_fold_with(self)\n+    }\n+}\n+\n+/// Used to substitute `Param`s with placeholders. We do this since Chalk\n+/// have a notion of `Param`s.\n+crate struct ParamsSubstitutor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    binder_index: ty::DebruijnIndex,\n+    list: Vec<rustc_middle::ty::ParamTy>,\n+    crate params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n+    crate named_regions: BTreeMap<DefId, u32>,\n+}\n+\n+impl<'tcx> ParamsSubstitutor<'tcx> {\n+    crate fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        ParamsSubstitutor {\n+            tcx,\n+            binder_index: ty::INNERMOST,\n+            list: vec![],\n+            params: rustc_data_structures::fx::FxHashMap::default(),\n+            named_regions: BTreeMap::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> Binder<T> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_fold_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.kind {\n+            // FIXME(chalk): currently we convert params to placeholders starting at\n+            // index `0`. To support placeholders, we'll actually need to do a\n+            // first pass to collect placeholders. Then we can insert params after.\n+            ty::Placeholder(_) => unimplemented!(),\n+            ty::Param(param) => match self.list.iter().position(|r| r == &param) {\n+                Some(_idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                    universe: ty::UniverseIndex::from_usize(0),\n+                    name: ty::BoundVar::from_usize(_idx),\n+                })),\n+                None => {\n+                    self.list.push(param);\n+                    let idx = self.list.len() - 1;\n+                    self.params.insert(idx, param);\n+                    self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                        universe: ty::UniverseIndex::from_usize(0),\n+                        name: ty::BoundVar::from_usize(idx),\n+                    }))\n+                }\n+            },\n+\n+            _ => t.super_fold_with(self),\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+        match r {\n+            // FIXME(chalk) - jackh726 - this currently isn't hit in any tests.\n+            // This covers any region variables in a goal, right?\n+            ty::ReEarlyBound(_re) => match self.named_regions.get(&_re.def_id) {\n+                Some(idx) => self.tcx.mk_region(RegionKind::ReLateBound(\n+                    self.binder_index,\n+                    BoundRegion::BrAnon(*idx),\n+                )),\n+                None => {\n+                    let idx = self.named_regions.len() as u32;\n+                    self.named_regions.insert(_re.def_id, idx);\n+                    self.tcx.mk_region(RegionKind::ReLateBound(\n+                        self.binder_index,\n+                        BoundRegion::BrAnon(idx),\n+                    ))\n+                }\n+            },\n+\n+            _ => r.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "4e635b9db0901b49d9c772bbea39f8045f3a5fe3", "filename": "src/librustc_traits/chalk/mod.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,227 @@\n+//! Calls `chalk-solve` to solve a `ty::Predicate`\n+//!\n+//! In order to call `chalk-solve`, this file must convert a\n+//! `ChalkCanonicalGoal` into a Chalk ucanonical goal. It then calls Chalk, and\n+//! converts the answer back into rustc solution.\n+\n+crate mod db;\n+crate mod lowering;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use rustc_index::vec::IndexVec;\n+\n+use rustc_middle::infer::canonical::{CanonicalTyVarKind, CanonicalVarKind};\n+use rustc_middle::traits::ChalkRustInterner;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::subst::GenericArg;\n+use rustc_middle::ty::{\n+    self, Bound, BoundVar, ParamTy, Region, RegionKind, Ty, TyCtxt, TypeFoldable,\n+};\n+\n+use rustc_infer::infer::canonical::{\n+    Canonical, CanonicalVarValues, Certainty, QueryRegionConstraints, QueryResponse,\n+};\n+use rustc_infer::traits::{self, ChalkCanonicalGoal, ChalkRustDefId as RustDefId};\n+\n+use crate::chalk::db::RustIrDatabase as ChalkRustIrDatabase;\n+use crate::chalk::lowering::{LowerInto, ParamsSubstitutor};\n+\n+use chalk_solve::Solution;\n+\n+crate fn provide(p: &mut Providers<'_>) {\n+    *p = Providers { evaluate_goal, ..*p };\n+}\n+\n+crate fn evaluate_goal<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    obligation: ChalkCanonicalGoal<'tcx>,\n+) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, traits::query::NoSolution> {\n+    let interner = ChalkRustInterner { tcx };\n+\n+    // Chalk doesn't have a notion of `Params`, so instead we use placeholders.\n+    let mut params_substitutor = ParamsSubstitutor::new(tcx);\n+    let obligation = obligation.fold_with(&mut params_substitutor);\n+    let _params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n+    let max_universe = obligation.max_universe.index();\n+\n+    let _lowered_goal: chalk_ir::UCanonical<\n+        chalk_ir::InEnvironment<chalk_ir::Goal<ChalkRustInterner<'tcx>>>,\n+    > = chalk_ir::UCanonical {\n+        canonical: chalk_ir::Canonical {\n+            binders: chalk_ir::CanonicalVarKinds::from(\n+                &interner,\n+                obligation.variables.iter().map(|v| match v.kind {\n+                    CanonicalVarKind::PlaceholderTy(_ty) => unimplemented!(),\n+                    CanonicalVarKind::PlaceholderRegion(_ui) => unimplemented!(),\n+                    CanonicalVarKind::Ty(ty) => match ty {\n+                        CanonicalTyVarKind::General(ui) => {\n+                            chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex {\n+                                counter: ui.index(),\n+                            })\n+                        }\n+                        CanonicalTyVarKind::Int | CanonicalTyVarKind::Float => {\n+                            // FIXME(chalk) - this is actually really important\n+                            // These variable kinds put some limits on the\n+                            // types that can be substituted (floats or ints).\n+                            // While it's unclear exactly the design here, we\n+                            // probably want some way to \"register\" these.\n+                            chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::root())\n+                        }\n+                    },\n+                    CanonicalVarKind::Region(ui) => {\n+                        chalk_ir::ParameterKind::Lifetime(chalk_ir::UniverseIndex {\n+                            counter: ui.index(),\n+                        })\n+                    }\n+                    CanonicalVarKind::Const(_ui) => unimplemented!(),\n+                    CanonicalVarKind::PlaceholderConst(_pc) => unimplemented!(),\n+                }),\n+            ),\n+            value: obligation.value.lower_into(&interner),\n+        },\n+        universes: max_universe + 1,\n+    };\n+\n+    let solver_choice = chalk_solve::SolverChoice::SLG { max_size: 32, expected_answers: None };\n+    let mut solver = solver_choice.into_solver::<ChalkRustInterner<'tcx>>();\n+\n+    let db = ChalkRustIrDatabase { tcx, interner };\n+    let solution = solver.solve(&db, &_lowered_goal);\n+\n+    // Ideally, the code to convert *back* to rustc types would live close to\n+    // the code to convert *from* rustc types. Right now though, we don't\n+    // really need this and so it's really minimal.\n+    // Right now, we also treat a `Unique` solution the same as\n+    // `Ambig(Definite)`. This really isn't right.\n+    let make_solution = |_subst: chalk_ir::Substitution<_>| {\n+        let mut var_values: IndexVec<BoundVar, GenericArg<'tcx>> = IndexVec::new();\n+        _subst.parameters(&interner).iter().for_each(|p| {\n+            // FIXME(chalk): we should move this elsewhere, since this is\n+            // essentially inverse of lowering a `GenericArg`.\n+            let _data = p.data(&interner);\n+            match _data {\n+                chalk_ir::ParameterKind::Ty(_t) => {\n+                    use chalk_ir::TyData;\n+                    use rustc_ast::ast;\n+\n+                    let _data = _t.data(&interner);\n+                    let kind = match _data {\n+                        TyData::Apply(_application_ty) => match _application_ty.name {\n+                            chalk_ir::TypeName::Struct(_struct_id) => match _struct_id.0 {\n+                                RustDefId::Array => unimplemented!(),\n+                                RustDefId::Slice => unimplemented!(),\n+                                _ => unimplemented!(),\n+                            },\n+                            chalk_ir::TypeName::Scalar(scalar) => match scalar {\n+                                chalk_ir::Scalar::Bool => ty::Bool,\n+                                chalk_ir::Scalar::Char => ty::Char,\n+                                chalk_ir::Scalar::Int(int_ty) => match int_ty {\n+                                    chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n+                                    chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n+                                    chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n+                                    chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n+                                    chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n+                                    chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n+                                },\n+                                chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n+                                    chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n+                                    chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n+                                    chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n+                                    chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n+                                    chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n+                                    chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n+                                },\n+                                chalk_ir::Scalar::Float(float_ty) => match float_ty {\n+                                    chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n+                                    chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n+                                },\n+                            },\n+                            chalk_ir::TypeName::Tuple(_size) => unimplemented!(),\n+                            chalk_ir::TypeName::OpaqueType(_ty) => unimplemented!(),\n+                            chalk_ir::TypeName::AssociatedType(_assoc_ty) => unimplemented!(),\n+                            chalk_ir::TypeName::Error => unimplemented!(),\n+                        },\n+                        TyData::Placeholder(_placeholder) => {\n+                            unimplemented!();\n+                        }\n+                        TyData::Alias(_alias_ty) => unimplemented!(),\n+                        TyData::Function(_quantified_ty) => unimplemented!(),\n+                        TyData::BoundVar(_bound) => Bound(\n+                            ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n+                            ty::BoundTy {\n+                                var: ty::BoundVar::from_usize(_bound.index),\n+                                kind: ty::BoundTyKind::Anon,\n+                            },\n+                        ),\n+                        TyData::InferenceVar(_) => unimplemented!(),\n+                        TyData::Dyn(_) => unimplemented!(),\n+                    };\n+                    let _ty: Ty<'_> = tcx.mk_ty(kind);\n+                    let _arg: GenericArg<'_> = _ty.into();\n+                    var_values.push(_arg);\n+                }\n+                chalk_ir::ParameterKind::Lifetime(_l) => {\n+                    let _data = _l.data(&interner);\n+                    let _lifetime: Region<'_> = match _data {\n+                        chalk_ir::LifetimeData::BoundVar(_var) => {\n+                            tcx.mk_region(RegionKind::ReLateBound(\n+                                rustc_middle::ty::DebruijnIndex::from_usize(\n+                                    _var.debruijn.depth() as usize\n+                                ),\n+                                rustc_middle::ty::BoundRegion::BrAnon(_var.index as u32),\n+                            ))\n+                        }\n+                        chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n+                        chalk_ir::LifetimeData::Placeholder(_index) => unimplemented!(),\n+                        chalk_ir::LifetimeData::Phantom(_, _) => unimplemented!(),\n+                    };\n+                    let _arg: GenericArg<'_> = _lifetime.into();\n+                    var_values.push(_arg);\n+                }\n+            }\n+        });\n+        let sol = Canonical {\n+            max_universe: ty::UniverseIndex::from_usize(0),\n+            variables: obligation.variables.clone(),\n+            value: QueryResponse {\n+                var_values: CanonicalVarValues { var_values },\n+                region_constraints: QueryRegionConstraints::default(),\n+                certainty: Certainty::Proven,\n+                value: (),\n+            },\n+        };\n+        &*tcx.arena.alloc(sol)\n+    };\n+    solution\n+        .map(|s| match s {\n+            Solution::Unique(_subst) => {\n+                // FIXME(chalk): handle constraints\n+                assert!(_subst.value.constraints.is_empty());\n+                make_solution(_subst.value.subst)\n+            }\n+            Solution::Ambig(_guidance) => {\n+                match _guidance {\n+                    chalk_solve::Guidance::Definite(_subst) => make_solution(_subst.value),\n+                    chalk_solve::Guidance::Suggested(_) => unimplemented!(),\n+                    chalk_solve::Guidance::Unknown => {\n+                        // chalk_fulfill doesn't use the var_values here, so\n+                        // let's just ignore that\n+                        let sol = Canonical {\n+                            max_universe: ty::UniverseIndex::from_usize(0),\n+                            variables: obligation.variables.clone(),\n+                            value: QueryResponse {\n+                                var_values: CanonicalVarValues { var_values: IndexVec::new() }\n+                                    .make_identity(tcx),\n+                                region_constraints: QueryRegionConstraints::default(),\n+                                certainty: Certainty::Ambiguous,\n+                                value: (),\n+                            },\n+                        };\n+                        &*tcx.arena.alloc(sol)\n+                    }\n+                }\n+            }\n+        })\n+        .ok_or(traits::query::NoSolution)\n+}"}, {"sha": "f3dfdffda41910aa227b6b39a692103133e01c29", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -12,6 +12,7 @@ extern crate log;\n #[macro_use]\n extern crate rustc_middle;\n \n+mod chalk;\n mod dropck_outlives;\n mod evaluate_obligation;\n mod implied_outlives_bounds;\n@@ -25,6 +26,7 @@ pub fn provide(p: &mut Providers<'_>) {\n     dropck_outlives::provide(p);\n     evaluate_obligation::provide(p);\n     implied_outlives_bounds::provide(p);\n+    chalk::provide(p);\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);\n     type_op::provide(p);"}, {"sha": "6add099e75bd6ea47e9f1088bf4ea1e6d1e0a92c", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -262,8 +262,11 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // are any errors at that point, so after type checking you can be\n     // sure that this will succeed without errors anyway.\n \n-    let unnormalized_env =\n-        ty::ParamEnv::new(tcx.intern_predicates(&predicates), traits::Reveal::UserFacing, None);\n+    let unnormalized_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        traits::Reveal::UserFacing,\n+        tcx.sess.opts.debugging_opts.chalk.then_some(def_id),\n+    );\n \n     let body_id = def_id\n         .as_local()"}, {"sha": "6529d784ad45293af55465bf511f16e42cb6015e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -8,7 +8,6 @@\n use crate::collect::PlaceholderHirTyCollector;\n use crate::middle::resolve_lifetime as rl;\n use crate::require_c_abi_if_c_variadic;\n-use rustc_ast::ast;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::ErrorReported;\n@@ -27,7 +26,7 @@ use rustc_middle::ty::{GenericParamDef, GenericParamDefKind};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, LATE_BOUND_LIFETIME_ARGUMENTS};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n@@ -114,7 +113,7 @@ pub enum SizedByDefault {\n }\n \n struct ConvertedBinding<'a, 'tcx> {\n-    item_name: ast::Ident,\n+    item_name: Ident,\n     kind: ConvertedBindingKind<'a, 'tcx>,\n     span: Span,\n }\n@@ -1183,11 +1182,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         )\n     }\n \n-    fn trait_defines_associated_type_named(\n-        &self,\n-        trait_def_id: DefId,\n-        assoc_name: ast::Ident,\n-    ) -> bool {\n+    fn trait_defines_associated_type_named(&self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n         self.tcx()\n             .associated_items(trait_def_id)\n             .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Type, trait_def_id)\n@@ -1938,7 +1933,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         type_str: &str,\n         trait_str: &str,\n-        name: ast::Name,\n+        name: Symbol,\n     ) {\n         let mut err = struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\");\n         if let (Some(_), Ok(snippet)) = (\n@@ -1969,7 +1964,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn find_bound_for_assoc_item(\n         &self,\n         ty_param_def_id: LocalDefId,\n-        assoc_name: ast::Ident,\n+        assoc_name: Ident,\n         span: Span,\n     ) -> Result<ty::PolyTraitRef<'tcx>, ErrorReported> {\n         let tcx = self.tcx();\n@@ -2006,7 +2001,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         all_candidates: impl Fn() -> I,\n         ty_param_name: impl Fn() -> String,\n-        assoc_name: ast::Ident,\n+        assoc_name: Ident,\n         span: Span,\n         is_equality: impl Fn() -> Option<String>,\n     ) -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n@@ -2124,7 +2119,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         all_candidates: impl Fn() -> I,\n         ty_param_name: &str,\n-        assoc_name: ast::Ident,\n+        assoc_name: Ident,\n         span: Span,\n     ) where\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,"}, {"sha": "ae6c1738da77dce1b742e250671057ace0d3c46d", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,14 +1,14 @@\n use super::method::MethodCallee;\n use super::{FnCtxt, Needs, PlaceOp};\n \n-use rustc_ast::ast::Ident;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_infer::infer::{InferCtxt, InferOk};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n use rustc_middle::ty::{ToPredicate, TypeFoldable};\n use rustc_session::DiagnosticMessageId;\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{self, TraitEngine};"}, {"sha": "52ddacc1c4b1a537f2d10286176e3b7ec772f16e", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,7 +3,6 @@ use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n-use rustc_ast::ast::Ident;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -15,6 +14,7 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n "}, {"sha": "71e1b32aeaa90e9a668cde56b66d61b70bc48724", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -37,7 +37,7 @@ use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n use std::fmt::Display;\n@@ -1411,7 +1411,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         find_best_match_for_name(names, field, None)\n     }\n \n-    fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n+    fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<Symbol> {\n         variant\n             .fields\n             .iter()\n@@ -1426,7 +1426,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    fn name_series_display(&self, names: Vec<ast::Name>) -> String {\n+    fn name_series_display(&self, names: Vec<Symbol>) -> String {\n         // dynamic limit, to never omit just one field\n         let limit = if names.len() == 6 { 6 } else { 5 };\n         let mut display =\n@@ -1443,7 +1443,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n         needs: Needs,\n         base: &'tcx hir::Expr<'tcx>,\n-        field: ast::Ident,\n+        field: Ident,\n     ) -> Ty<'tcx> {\n         let expr_t = self.check_expr_with_needs(base, needs);\n         let expr_t = self.structurally_resolved_type(base.span, expr_t);\n@@ -1522,7 +1522,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn ban_nonexisting_field(\n         &self,\n-        field: ast::Ident,\n+        field: Ident,\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n         expr_t: Ty<'tcx>,\n@@ -1560,7 +1560,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr<'_>,\n         expr_t: Ty<'tcx>,\n-        field: ast::Ident,\n+        field: Ident,\n         base_did: DefId,\n     ) {\n         let struct_path = self.tcx().def_path_str(base_did);\n@@ -1589,7 +1589,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn ban_take_value_of_method(&self, expr: &hir::Expr<'_>, expr_t: Ty<'tcx>, field: ast::Ident) {\n+    fn ban_take_value_of_method(&self, expr: &hir::Expr<'_>, expr_t: Ty<'tcx>, field: Ident) {\n         let mut err = type_error_struct!(\n             self.tcx().sess,\n             field.span,\n@@ -1636,7 +1636,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         def: &'tcx ty::AdtDef,\n-        field: ast::Ident,\n+        field: Ident,\n     ) {\n         if let Some(suggested_field_name) =\n             Self::suggest_field_name(def.non_enum_variant(), &field.as_str(), vec![])\n@@ -1665,7 +1665,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,\n         base: &hir::Expr<'_>,\n-        field: ast::Ident,\n+        field: Ident,\n         len: &ty::Const<'tcx>,\n     ) {\n         if let (Some(len), Ok(user_index)) =\n@@ -1689,7 +1689,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,\n         base: &hir::Expr<'_>,\n-        field: ast::Ident,\n+        field: Ident,\n     ) {\n         if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n             let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);"}, {"sha": "a254aecf07bab3248d08701dc126e67c9a224261", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -11,7 +11,6 @@ pub use self::CandidateSource::*;\n pub use self::MethodError::*;\n \n use crate::check::FnCtxt;\n-use rustc_ast::ast;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -22,6 +21,7 @@ use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TypeFoldable, WithConstness};\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n     pub fn method_exists(\n         &self,\n-        method_name: ast::Ident,\n+        method_name: Ident,\n         self_ty: Ty<'tcx>,\n         call_expr_id: hir::HirId,\n         allow_private: bool,\n@@ -133,7 +133,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'a>,\n         msg: &str,\n-        method_name: ast::Ident,\n+        method_name: Ident,\n         self_ty: Ty<'tcx>,\n         call_expr: &hir::Expr<'_>,\n     ) {\n@@ -260,7 +260,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn lookup_probe(\n         &self,\n         span: Span,\n-        method_name: ast::Ident,\n+        method_name: Ident,\n         self_ty: Ty<'tcx>,\n         call_expr: &'tcx hir::Expr<'tcx>,\n         scope: ProbeScope,\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn lookup_method_in_trait(\n         &self,\n         span: Span,\n-        m_name: ast::Ident,\n+        m_name: Ident,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n@@ -414,7 +414,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn resolve_ufcs(\n         &self,\n         span: Span,\n-        method_name: ast::Ident,\n+        method_name: Ident,\n         self_ty: Ty<'tcx>,\n         expr_id: hir::HirId,\n     ) -> Result<(DefKind, DefId), MethodError<'tcx>> {\n@@ -478,7 +478,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn associated_item(\n         &self,\n         def_id: DefId,\n-        item_name: ast::Ident,\n+        item_name: Ident,\n         ns: Namespace,\n     ) -> Option<ty::AssocItem> {\n         self.tcx"}, {"sha": "7f1d77e5b97d871dfc61377596b31f4c734e4c1d", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -28,7 +28,7 @@ use rustc_middle::ty::{\n };\n use rustc_session::config::nightly_options;\n use rustc_session::lint;\n-use rustc_span::{symbol::Symbol, Span, DUMMY_SP};\n+use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n use rustc_trait_selection::traits::query::method_autoderef::{\n@@ -55,7 +55,7 @@ struct ProbeContext<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    method_name: Option<ast::Ident>,\n+    method_name: Option<Ident>,\n     return_type: Option<Ty<'tcx>>,\n \n     /// This is the OriginalQueryValues for the steps queries\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         mode: Mode,\n-        item_name: ast::Ident,\n+        item_name: Ident,\n         is_suggestion: IsSuggestion,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &'a self,\n         span: Span,\n         mode: Mode,\n-        method_name: Option<ast::Ident>,\n+        method_name: Option<Ident>,\n         return_type: Option<Ty<'tcx>>,\n         is_suggestion: IsSuggestion,\n         self_ty: Ty<'tcx>,\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         fcx: &'a FnCtxt<'a, 'tcx>,\n         span: Span,\n         mode: Mode,\n-        method_name: Option<ast::Ident>,\n+        method_name: Option<Ident>,\n         return_type: Option<Ty<'tcx>>,\n         orig_steps_var_values: OriginalQueryValues<'tcx>,\n         steps: Lrc<Vec<CandidateStep<'tcx>>>,\n@@ -978,7 +978,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn candidate_method_names(&self) -> Vec<ast::Ident> {\n+    fn candidate_method_names(&self) -> Vec<Ident> {\n         let mut set = FxHashSet::default();\n         let mut names: Vec<_> = self\n             .inherent_candidates"}, {"sha": "cf26c94418e2d2d10235ccd770d0fc8176c136b7", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2,7 +2,6 @@\n //! found or is otherwise invalid.\n \n use crate::check::FnCtxt;\n-use rustc_ast::ast;\n use rustc_ast::util::lev_distance;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n@@ -18,7 +17,7 @@ use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::{\n     self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::{source_map, FileName, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::Obligation;\n@@ -72,7 +71,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n-        item_name: ast::Ident,\n+        item_name: Ident,\n         source: SelfSource<'b>,\n         error: MethodError<'tcx>,\n         args: Option<&'tcx [hir::Expr<'tcx>]>,\n@@ -923,7 +922,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n-        item_name: ast::Ident,\n+        item_name: Ident,\n         source: SelfSource<'b>,\n         valid_out_of_scope_traits: Vec<DefId>,\n         unsatisfied_predicates: &[(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)],\n@@ -1378,7 +1377,7 @@ impl intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n }\n \n fn print_disambiguation_help(\n-    item_name: ast::Ident,\n+    item_name: Ident,\n     args: Option<&'tcx [hir::Expr<'tcx>]>,\n     err: &mut DiagnosticBuilder<'_>,\n     trait_name: String,"}, {"sha": "956e09ec52b4a35db8c1afb84c21516a178bec5d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3718,14 +3718,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n-    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, ast::Ident) {\n+    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, Ident) {\n         let (tr, name) = match (op, is_mut) {\n             (PlaceOp::Deref, false) => (self.tcx.lang_items().deref_trait(), sym::deref),\n             (PlaceOp::Deref, true) => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n             (PlaceOp::Index, false) => (self.tcx.lang_items().index_trait(), sym::index),\n             (PlaceOp::Index, true) => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n         };\n-        (tr, ast::Ident::with_dummy_span(name))\n+        (tr, Ident::with_dummy_span(name))\n     }\n \n     fn try_overloaded_place_op(\n@@ -4824,19 +4824,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_parent_fn_decl(\n-        &self,\n-        blk_id: hir::HirId,\n-    ) -> Option<(&'tcx hir::FnDecl<'tcx>, ast::Ident)> {\n+    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident)> {\n         let parent = self.tcx.hir().get(self.tcx.hir().get_parent_item(blk_id));\n         self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n     }\n \n     /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_node_fn_decl(\n-        &self,\n-        node: Node<'tcx>,\n-    ) -> Option<(&'tcx hir::FnDecl<'tcx>, ast::Ident, bool)> {\n+    fn get_node_fn_decl(&self, node: Node<'tcx>) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident, bool)> {\n         match node {\n             Node::Item(&hir::Item { ident, kind: hir::ItemKind::Fn(ref sig, ..), .. }) => {\n                 // This is less than ideal, it will not suggest a return type span on any"}, {"sha": "00ff2af82e30356f6af2420a2289314022acae97", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -2,7 +2,6 @@\n \n use super::method::MethodCallee;\n use super::{FnCtxt, Needs};\n-use rustc_ast::ast::Ident;\n use rustc_errors::{self, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -11,6 +10,7 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n use rustc_middle::ty::{self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable};\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n "}, {"sha": "8a10427260eee23ff71213ced558a099747476d8", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::{self, BindingMode, Ty, TypeFoldable};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::symbol::Ident;\n use rustc_trait_selection::traits::{ObligationCause, Pattern};\n \n use std::cmp;\n@@ -1133,7 +1134,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn error_field_already_bound(&self, span: Span, ident: ast::Ident, other_field: Span) {\n+    fn error_field_already_bound(&self, span: Span, ident: Ident, other_field: Span) {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -1149,8 +1150,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn error_inexistent_fields(\n         &self,\n         kind_name: &str,\n-        inexistent_fields: &[ast::Ident],\n-        unmentioned_fields: &mut Vec<ast::Ident>,\n+        inexistent_fields: &[Ident],\n+        unmentioned_fields: &mut Vec<Ident>,\n         variant: &ty::VariantDef,\n     ) {\n         let tcx = self.tcx;\n@@ -1225,7 +1226,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn error_unmentioned_fields(\n         &self,\n         span: Span,\n-        unmentioned_fields: &[ast::Ident],\n+        unmentioned_fields: &[Ident],\n         variant: &ty::VariantDef,\n     ) {\n         let field_names = if unmentioned_fields.len() == 1 {"}, {"sha": "6aa8242193d5fce87d9a22a4ae2c1f9e6023b30e", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -35,15 +35,14 @@ use super::FnCtxt;\n use crate::expr_use_visitor as euv;\n use crate::mem_categorization as mc;\n use crate::mem_categorization::PlaceBase;\n-use rustc_ast::ast;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n@@ -261,7 +260,7 @@ struct InferBorrowKind<'a, 'tcx> {\n \n     // If we modified `current_closure_kind`, this field contains a `Some()` with the\n     // variable access that caused us to do so.\n-    current_origin: Option<(Span, ast::Name)>,\n+    current_origin: Option<(Span, Symbol)>,\n \n     // For each upvar that we access, we track the minimal kind of\n     // access we need (ref, ref mut, move, etc).\n@@ -415,7 +414,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         closure_id: LocalDefId,\n         new_kind: ty::ClosureKind,\n         upvar_span: Span,\n-        var_name: ast::Name,\n+        var_name: Symbol,\n     ) {\n         debug!(\n             \"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n@@ -480,6 +479,6 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n-fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> ast::Name {\n+fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }"}, {"sha": "b79ac50da8fa33c8f8647f18e1be076d0b690b67", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{\n     self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_session::parse::feature_err;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use rustc_trait_selection::opaque_types::may_define_opaque_type;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -1226,7 +1226,7 @@ fn check_variances_for_type_defn<'tcx>(\n     }\n }\n \n-fn report_bivariance(tcx: TyCtxt<'_>, span: Span, param_name: ast::Name) {\n+fn report_bivariance(tcx: TyCtxt<'_>, span: Span, param_name: Symbol) {\n     let mut err = error_392(tcx, span, param_name);\n \n     let suggested_marker_id = tcx.lang_items().phantom_data();\n@@ -1368,7 +1368,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-fn error_392(tcx: TyCtxt<'_>, span: Span, param_name: ast::Name) -> DiagnosticBuilder<'_> {\n+fn error_392(tcx: TyCtxt<'_>, span: Span, param_name: Symbol) -> DiagnosticBuilder<'_> {\n     let mut err =\n         struct_span_err!(tcx.sess, span, E0392, \"parameter `{}` is never used\", param_name);\n     err.span_label(span, \"unused parameter\");"}, {"sha": "dfe86aecbf727c41d00b12e69912e201e8cb5c83", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,12 +1,11 @@\n-use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint;\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n     let mut used_trait_imports = DefIdSet::default();\n@@ -202,7 +201,7 @@ struct ExternCrateToLint {\n     /// if `Some`, then this is renamed (`extern crate orig_name as\n     /// crate_name`), and -- perhaps surprisingly -- this stores the\n     /// *original* name (`item.name` will contain the new name)\n-    orig_name: Option<ast::Name>,\n+    orig_name: Option<Symbol>,\n \n     /// if `false`, the original name started with `_`, so we shouldn't lint\n     /// about it going unused (but we should still emit idiom lints)."}, {"sha": "854bd03b2648679237144d5980f852b8bddf43c3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -19,7 +19,7 @@ use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::constrained_generic_params as cgp;\n use crate::middle::resolve_lifetime as rl;\n use rustc_ast::ast;\n-use rustc_ast::ast::{Ident, MetaItemKind};\n+use rustc_ast::ast::MetaItemKind;\n use rustc_attr::{list_contains_name, mark_used, InlineAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -42,7 +42,7 @@ use rustc_middle::ty::{self, AdtKind, Const, ToPolyTraitRef, Ty, TyCtxt};\n use rustc_middle::ty::{ReprOptions, ToPredicate, WithConstness};\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n@@ -813,7 +813,7 @@ fn convert_variant(\n     adt_kind: ty::AdtKind,\n     parent_did: LocalDefId,\n ) -> ty::VariantDef {\n-    let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n+    let mut seen_fields: FxHashMap<Ident, Span> = Default::default();\n     let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did));\n     let fields = def\n         .fields()"}, {"sha": "716263393ba8d69173936f7c21197dce3244f686", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,7 +3,7 @@ use super::*;\n use rustc_ast::ast::*;\n use rustc_ast::attr;\n use rustc_ast::with_default_globals;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n \n fn word_cfg(s: &str) -> Cfg {"}, {"sha": "4bf3649dcc2e259c2138b0cd79d9f93f561a4154", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -12,6 +12,7 @@ use rustc_metadata::creader::LoadedMacro;\n use rustc_middle::ty;\n use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n+use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n use crate::clean::{self, GetDefId, ToSource, TypeKind};\n@@ -37,7 +38,7 @@ type Attrs<'hir> = rustc_middle::ty::Attributes<'hir>;\n pub fn try_inline(\n     cx: &DocContext<'_>,\n     res: Res,\n-    name: ast::Name,\n+    name: Symbol,\n     attrs: Option<Attrs<'_>>,\n     visited: &mut FxHashSet<DefId>,\n ) -> Option<Vec<clean::Item>> {\n@@ -515,7 +516,7 @@ fn build_static(cx: &DocContext<'_>, did: DefId, mutable: bool) -> clean::Static\n     }\n }\n \n-fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemEnum {\n+fn build_macro(cx: &DocContext<'_>, did: DefId, name: Symbol) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n         LoadedMacro::MacroDef(def, _) => {"}, {"sha": "8cd9ab41aa40a7a4193c700b532c955e776a47e7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -9,7 +9,7 @@ mod simplify;\n pub mod types;\n pub mod utils;\n \n-use rustc_ast::ast::{self, Ident};\n+use rustc_ast::ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n@@ -24,7 +24,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, AdtKind, Lift, Ty, TyCtxt};\n use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, Pos};\n use rustc_typeck::hir_ty_to_ty;\n \n@@ -921,7 +921,7 @@ impl Clean<Item> for doctree::Function<'_> {\n     }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [ast::Ident]) {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n     fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         Arguments {\n             values: self\n@@ -2006,7 +2006,7 @@ impl Clean<String> for Ident {\n     }\n }\n \n-impl Clean<String> for ast::Name {\n+impl Clean<String> for Symbol {\n     #[inline]\n     fn clean(&self, _: &DocContext<'_>) -> String {\n         self.to_string()"}, {"sha": "8bf811877a6a86aec8ff8174e970ac268d5f9ee1", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -8,7 +8,7 @@ use std::rc::Rc;\n use std::sync::Arc;\n use std::{slice, vec};\n \n-use rustc_ast::ast::{self, AttrStyle, Ident};\n+use rustc_ast::ast::{self, AttrStyle};\n use rustc_ast::attr;\n use rustc_ast::util::comments::strip_doc_comment_decoration;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -21,7 +21,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::middle::stability;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, FileName};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;"}, {"sha": "5b13832742770fd2f5b927ba45c11a44e111baeb", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -3,15 +3,14 @@\n pub use self::StructType::*;\n \n use rustc_ast::ast;\n-use rustc_ast::ast::Name;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::{self, Span};\n+use rustc_span::{self, Span, Symbol};\n \n use rustc_hir as hir;\n use rustc_hir::def_id::CrateNum;\n \n pub struct Module<'hir> {\n-    pub name: Option<Name>,\n+    pub name: Option<Symbol>,\n     pub attrs: &'hir [ast::Attribute],\n     pub where_outer: Span,\n     pub where_inner: Span,\n@@ -39,7 +38,7 @@ pub struct Module<'hir> {\n \n impl Module<'hir> {\n     pub fn new(\n-        name: Option<Name>,\n+        name: Option<Symbol>,\n         attrs: &'hir [ast::Attribute],\n         vis: &'hir hir::Visibility<'hir>,\n     ) -> Module<'hir> {\n@@ -86,7 +85,7 @@ pub struct Struct<'hir> {\n     pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n-    pub name: Name,\n+    pub name: Symbol,\n     pub generics: &'hir hir::Generics<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField<'hir>],\n@@ -97,7 +96,7 @@ pub struct Union<'hir> {\n     pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n-    pub name: Name,\n+    pub name: Symbol,\n     pub generics: &'hir hir::Generics<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField<'hir>],\n@@ -111,11 +110,11 @@ pub struct Enum<'hir> {\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n-    pub name: Name,\n+    pub name: Symbol,\n }\n \n pub struct Variant<'hir> {\n-    pub name: Name,\n+    pub name: Symbol,\n     pub id: hir::HirId,\n     pub attrs: &'hir [ast::Attribute],\n     pub def: &'hir hir::VariantData<'hir>,\n@@ -126,7 +125,7 @@ pub struct Function<'hir> {\n     pub decl: &'hir hir::FnDecl<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n-    pub name: Name,\n+    pub name: Symbol,\n     pub vis: &'hir hir::Visibility<'hir>,\n     pub header: hir::FnHeader,\n     pub whence: Span,\n@@ -137,7 +136,7 @@ pub struct Function<'hir> {\n pub struct Typedef<'hir> {\n     pub ty: &'hir hir::Ty<'hir>,\n     pub gen: &'hir hir::Generics<'hir>,\n-    pub name: Name,\n+    pub name: Symbol,\n     pub id: hir::HirId,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n@@ -146,7 +145,7 @@ pub struct Typedef<'hir> {\n \n pub struct OpaqueTy<'hir> {\n     pub opaque_ty: &'hir hir::OpaqueTy<'hir>,\n-    pub name: Name,\n+    pub name: Symbol,\n     pub id: hir::HirId,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n@@ -158,7 +157,7 @@ pub struct Static<'hir> {\n     pub type_: &'hir hir::Ty<'hir>,\n     pub mutability: hir::Mutability,\n     pub expr: hir::BodyId,\n-    pub name: Name,\n+    pub name: Symbol,\n     pub attrs: &'hir [ast::Attribute],\n     pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n@@ -168,7 +167,7 @@ pub struct Static<'hir> {\n pub struct Constant<'hir> {\n     pub type_: &'hir hir::Ty<'hir>,\n     pub expr: hir::BodyId,\n-    pub name: Name,\n+    pub name: Symbol,\n     pub attrs: &'hir [ast::Attribute],\n     pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n@@ -178,7 +177,7 @@ pub struct Constant<'hir> {\n pub struct Trait<'hir> {\n     pub is_auto: hir::IsAuto,\n     pub unsafety: hir::Unsafety,\n-    pub name: Name,\n+    pub name: Symbol,\n     pub items: Vec<&'hir hir::TraitItem<'hir>>,\n     pub generics: &'hir hir::Generics<'hir>,\n     pub bounds: &'hir [hir::GenericBound<'hir>],\n@@ -189,7 +188,7 @@ pub struct Trait<'hir> {\n }\n \n pub struct TraitAlias<'hir> {\n-    pub name: Name,\n+    pub name: Symbol,\n     pub generics: &'hir hir::Generics<'hir>,\n     pub bounds: &'hir [hir::GenericBound<'hir>],\n     pub attrs: &'hir [ast::Attribute],\n@@ -217,7 +216,7 @@ pub struct Impl<'hir> {\n pub struct ForeignItem<'hir> {\n     pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n-    pub name: Name,\n+    pub name: Symbol,\n     pub kind: &'hir hir::ForeignItemKind<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n@@ -226,17 +225,17 @@ pub struct ForeignItem<'hir> {\n // For Macro we store the DefId instead of the NodeId, since we also create\n // these imported macro_rules (which only have a DUMMY_NODE_ID).\n pub struct Macro<'hir> {\n-    pub name: Name,\n+    pub name: Symbol,\n     pub hid: hir::HirId,\n     pub def_id: hir::def_id::DefId,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub matchers: Vec<Span>,\n-    pub imported_from: Option<Name>,\n+    pub imported_from: Option<Symbol>,\n }\n \n pub struct ExternCrate<'hir> {\n-    pub name: Name,\n+    pub name: Symbol,\n     pub cnum: CrateNum,\n     pub path: Option<String>,\n     pub vis: &'hir hir::Visibility<'hir>,\n@@ -245,7 +244,7 @@ pub struct ExternCrate<'hir> {\n }\n \n pub struct Import<'hir> {\n-    pub name: Name,\n+    pub name: Symbol,\n     pub id: hir::HirId,\n     pub vis: &'hir hir::Visibility<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n@@ -255,10 +254,10 @@ pub struct Import<'hir> {\n }\n \n pub struct ProcMacro<'hir> {\n-    pub name: Name,\n+    pub name: Symbol,\n     pub id: hir::HirId,\n     pub kind: MacroKind,\n-    pub helpers: Vec<Name>,\n+    pub helpers: Vec<Symbol>,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }"}, {"sha": "fbdb538cd874cc62f338a4a9c69787108a720c2c", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::ast::{self, Ident};\n+use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_expand::base::SyntaxExtensionKind;\n use rustc_feature::UnstableFeatures;\n@@ -12,7 +12,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty;\n use rustc_resolve::ParentScope;\n use rustc_session::lint;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n \n use std::ops::Range;"}, {"sha": "d2a950027cf877981574e461b04a3dd1ba150884", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::middle::privacy::AccessLevel;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, Span};\n \n use std::mem;\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     fn visit_variant_data(\n         &mut self,\n         item: &'tcx hir::Item,\n-        name: ast::Name,\n+        name: Symbol,\n         sd: &'tcx hir::VariantData,\n         generics: &'tcx hir::Generics,\n     ) -> Struct<'tcx> {\n@@ -106,7 +106,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     fn visit_union_data(\n         &mut self,\n         item: &'tcx hir::Item,\n-        name: ast::Name,\n+        name: Symbol,\n         sd: &'tcx hir::VariantData,\n         generics: &'tcx hir::Generics,\n     ) -> Union<'tcx> {\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     fn visit_enum_def(\n         &mut self,\n         it: &'tcx hir::Item,\n-        name: ast::Name,\n+        name: Symbol,\n         def: &'tcx hir::EnumDef,\n         generics: &'tcx hir::Generics,\n     ) -> Enum<'tcx> {\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         &mut self,\n         om: &mut Module<'tcx>,\n         item: &'tcx hir::Item,\n-        name: ast::Name,\n+        name: Symbol,\n         decl: &'tcx hir::FnDecl,\n         header: hir::FnHeader,\n         generics: &'tcx hir::Generics,\n@@ -234,7 +234,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         vis: &'tcx hir::Visibility,\n         id: hir::HirId,\n         m: &'tcx hir::Mod<'tcx>,\n-        name: Option<ast::Name>,\n+        name: Option<Symbol>,\n     ) -> Module<'tcx> {\n         let mut om = Module::new(name, attrs, vis);\n         om.where_outer = span;\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         &mut self,\n         id: hir::HirId,\n         res: Res,\n-        renamed: Option<ast::Ident>,\n+        renamed: Option<Ident>,\n         glob: bool,\n         om: &mut Module<'tcx>,\n         please_inline: bool,\n@@ -375,12 +375,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         ret\n     }\n \n-    fn visit_item(\n-        &mut self,\n-        item: &'tcx hir::Item,\n-        renamed: Option<ast::Ident>,\n-        om: &mut Module<'tcx>,\n-    ) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item, renamed: Option<Ident>, om: &mut Module<'tcx>) {\n         debug!(\"visiting item {:?}\", item);\n         let ident = renamed.unwrap_or(item.ident);\n \n@@ -593,7 +588,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     fn visit_foreign_item(\n         &mut self,\n         item: &'tcx hir::ForeignItem,\n-        renamed: Option<ast::Ident>,\n+        renamed: Option<Ident>,\n         om: &mut Module<'tcx>,\n     ) {\n         // If inlining we only want to include public functions.\n@@ -612,11 +607,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     // Convert each `exported_macro` into a doc item.\n-    fn visit_local_macro(\n-        &self,\n-        def: &'tcx hir::MacroDef,\n-        renamed: Option<ast::Name>,\n-    ) -> Macro<'tcx> {\n+    fn visit_local_macro(&self, def: &'tcx hir::MacroDef, renamed: Option<Symbol>) -> Macro<'tcx> {\n         debug!(\"visit_local_macro: {}\", def.ident);\n         let tts = def.ast.body.inner_tokens().trees().collect::<Vec<_>>();\n         // Extract the spans of all matchers. They represent the \"interface\" of the macro."}, {"sha": "84bde9a52f7ced3da105e993b3962d7f4ea78952", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -447,7 +447,8 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     bool Singlethread,\n     bool AsmComments,\n     bool EmitStackSizeSection,\n-    bool RelaxELFRelocations) {\n+    bool RelaxELFRelocations,\n+    bool UseInitArray) {\n \n   auto OptLevel = fromRust(RustOptLevel);\n   auto RM = fromRust(RustReloc);\n@@ -473,6 +474,7 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   Options.MCOptions.PreserveAsmComments = AsmComments;\n   Options.MCOptions.ABIName = ABIStr;\n   Options.RelaxELFRelocations = RelaxELFRelocations;\n+  Options.UseInitArray = UseInitArray;\n \n   if (TrapUnreachable) {\n     // Tell LLVM to codegen `unreachable` into an explicit trap instruction."}, {"sha": "e36ec0f59010bb33b4205d3c8ed2bf8e8bf8129f", "filename": "src/test/run-fail/bug-811.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,24 +0,0 @@\n-// error-pattern:quux\n-\n-use std::marker::PhantomData;\n-\n-fn test00_start(ch: chan_t<isize>, message: isize) {\n-    send(ch, message);\n-}\n-\n-type task_id = isize;\n-type port_id = isize;\n-\n-struct chan_t<T> {\n-    task: task_id,\n-    port: port_id,\n-    marker: PhantomData<*mut T>,\n-}\n-\n-fn send<T: Send>(_ch: chan_t<T>, _data: T) {\n-    panic!();\n-}\n-\n-fn main() {\n-    panic!(\"quux\");\n-}"}, {"sha": "977cfea0fe05dbd13ea851cf8057f621781c0bb2", "filename": "src/test/run-fail/overflowing-lsh-1.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,9 +0,0 @@\n-// error-pattern:thread 'main' panicked at 'attempt to shift left with overflow'\n-// compile-flags: -C debug-assertions\n-\n-#![warn(arithmetic_overflow)]\n-#![warn(const_err)]\n-\n-fn main() {\n-    let _x = 1_i32 << 32;\n-}"}, {"sha": "3517dacde3aa31fe51098466c56eae8cbe426c8b", "filename": "src/test/run-fail/overflowing-lsh-2.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,9 +0,0 @@\n-// error-pattern:thread 'main' panicked at 'attempt to shift left with overflow'\n-// compile-flags: -C debug-assertions\n-\n-#![warn(arithmetic_overflow)]\n-#![warn(const_err)]\n-\n-fn main() {\n-    let _x = 1 << -1;\n-}"}, {"sha": "4a575c3fa7f6a07b8dc7cea36dea130266c03b7b", "filename": "src/test/run-fail/overflowing-lsh-3.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,9 +0,0 @@\n-// error-pattern:thread 'main' panicked at 'attempt to shift left with overflow'\n-// compile-flags: -C debug-assertions\n-\n-#![warn(arithmetic_overflow)]\n-#![warn(const_err)]\n-\n-fn main() {\n-    let _x = 1_u64 << 64;\n-}"}, {"sha": "4592b2b6260bd1889809ac9854e94d071f72023b", "filename": "src/test/run-fail/overflowing-rsh-1.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,9 +0,0 @@\n-// error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n-// compile-flags: -C debug-assertions\n-\n-#![warn(arithmetic_overflow)]\n-#![warn(const_err)]\n-\n-fn main() {\n-    let _x = -1_i32 >> 32;\n-}"}, {"sha": "066267b770db23f119fb657f747aa840459eada7", "filename": "src/test/run-fail/overflowing-rsh-2.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,9 +0,0 @@\n-// error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n-// compile-flags: -C debug-assertions\n-\n-#![warn(arithmetic_overflow)]\n-#![warn(const_err)]\n-\n-fn main() {\n-    let _x = -1_i32 >> -1;\n-}"}, {"sha": "67e78482866cbbd536efdfb3b6272392cf490fb7", "filename": "src/test/run-fail/overflowing-rsh-3.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,9 +0,0 @@\n-// error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n-// compile-flags: -C debug-assertions\n-\n-#![warn(arithmetic_overflow)]\n-#![warn(const_err)]\n-\n-fn main() {\n-    let _x = -1_i64 >> 64;\n-}"}, {"sha": "20ef324a82aeb54048586fea5918529049b77529", "filename": "src/test/run-fail/overflowing-rsh-5.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,9 +0,0 @@\n-// error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n-// compile-flags: -C debug-assertions\n-\n-#![warn(arithmetic_overflow)]\n-#![warn(const_err)]\n-\n-fn main() {\n-    let _n = 1i64 >> [64][0];\n-}"}, {"sha": "589a98bab0401e535dcb91ffc04f438f58c8eef0", "filename": "src/test/run-fail/overflowing-rsh-6.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,10 +0,0 @@\n-// error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n-// compile-flags: -C debug-assertions\n-\n-#![warn(arithmetic_overflow)]\n-#![warn(const_err)]\n-#![feature(const_indexing)]\n-\n-fn main() {\n-    let _n = 1i64 >> [64][0];\n-}"}, {"sha": "72d42e5b799cd665f7170848495bd6795fa48164", "filename": "src/test/run-fail/panic-macro-any.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Fpanic-macro-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Fpanic-macro-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-macro-any.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:panicked at 'Box<Any>'\n-\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    panic!(box 413 as Box<::std::any::Any + Send>);\n-}"}, {"sha": "7b761faad95343e9fd1ef15ec45aeb66b21e6f0c", "filename": "src/test/run-fail/unwind-unique.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Funwind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3/src%2Ftest%2Frun-fail%2Funwind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-unique.rs?ref=7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "patch": "@@ -1,10 +0,0 @@\n-// error-pattern:fail\n-\n-fn failfn() {\n-    panic!();\n-}\n-\n-fn main() {\n-    Box::new(0);\n-    failfn();\n-}"}, {"sha": "a3d31d257748d9e340d931a43be31a718d79cf2d", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -32,6 +32,7 @@ use rustc_parse::new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{Spanned, DUMMY_SP, FileName};\n use rustc_span::source_map::FilePathMapping;\n+use rustc_span::symbol::Ident;\n use rustc_ast::ast::*;\n use rustc_ast::mut_visit::{self, MutVisitor, visit_clobber};\n use rustc_ast::ptr::P;"}, {"sha": "3caf5f44995221bf3e1edaa3ddc24c80b2244811", "filename": "src/test/ui/array-slice-vec/bounds-check-no-overflow.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Farray-slice-vec%2Fbounds-check-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Farray-slice-vec%2Fbounds-check-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fbounds-check-no-overflow.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:index out of bounds\n+// ignore-emscripten no processes\n \n use std::usize;\n use std::mem::size_of;", "previous_filename": "src/test/run-fail/bounds-check-no-overflow.rs"}, {"sha": "371d16f093a7434fe8a002e371e23e44c9e63461", "filename": "src/test/ui/array-slice-vec/dst-raw-slice.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Farray-slice-vec%2Fdst-raw-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Farray-slice-vec%2Fdst-raw-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fdst-raw-slice.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,5 +1,9 @@\n // Test bounds checking for DST raw slices\n+\n+// run-fail\n // error-pattern:index out of bounds\n+// ignore-emscripten no processes\n+\n #[allow(unconditional_panic)]\n fn main() {\n     let a: *const [_] = &[1, 2, 3];", "previous_filename": "src/test/run-fail/dst-raw-slice.rs"}, {"sha": "49f635e0c11d6de43bbd4dcbdd494584de1ba333", "filename": "src/test/ui/binop/binop-fail-3.rs", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fbinop%2Fbinop-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fbinop%2Fbinop-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-fail-3.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,9 +1,11 @@\n+// run-fail\n // error-pattern:quux\n+// ignore-emscripten no processes\n+\n fn foo() -> ! {\n     panic!(\"quux\");\n }\n \n-#[allow(resolve_trait_on_defaulted_unit)]\n fn main() {\n     foo() == foo(); // these types wind up being defaulted to ()\n }", "previous_filename": "src/test/run-fail/binop-fail-3.rs"}, {"sha": "44cdfffeeb7a7fd4b22e1a0c5408799bf9121962", "filename": "src/test/ui/binop/binop-panic.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fbinop%2Fbinop-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fbinop%2Fbinop-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,8 +1,12 @@\n+// run-fail\n // error-pattern:quux\n+// ignore-emscripten no processes\n+\n fn my_err(s: String) -> ! {\n     println!(\"{}\", s);\n     panic!(\"quux\");\n }\n+\n fn main() {\n     3_usize == my_err(\"bye\".to_string());\n }", "previous_filename": "src/test/run-fail/binop-panic.rs"}, {"sha": "ea4589338c46f7157e7af18f88c56bf59d305faf", "filename": "src/test/ui/borrowck/borrowck-local-borrow.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-local-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-local-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-local-borrow.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:panic 1\n+// ignore-emscripten no processes\n \n // revisions: migrate mir\n //[mir]compile-flags: -Z borrowck=mir", "previous_filename": "src/test/run-fail/borrowck-local-borrow.rs"}, {"sha": "dbd60fc8bb1ff1d9bb5b7d146c57f8f445d102c0", "filename": "src/test/ui/chalkify/basic.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fbasic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo {}\n+\n+struct Bar {}\n+\n+impl Foo for Bar {}\n+\n+fn main() -> () {\n+    let _ = Bar {};\n+}"}, {"sha": "d403514b553b079d4ac6c1cb782c6e6742a9dadc", "filename": "src/test/ui/chalkify/builtin-copy-clone.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fbuiltin-copy-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fbuiltin-copy-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fbuiltin-copy-clone.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,44 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+// Test that `Clone` is correctly implemented for builtin types.\n+\n+#[derive(Copy, Clone)]\n+struct S(i32);\n+\n+fn test_clone<T: Clone>(arg: T) {\n+    let _ = arg.clone();\n+}\n+\n+fn test_copy<T: Copy>(arg: T) {\n+    let _ = arg;\n+    let _ = arg;\n+}\n+\n+fn test_copy_clone<T: Copy + Clone>(arg: T) {\n+    test_copy(arg);\n+    test_clone(arg);\n+}\n+\n+fn foo() { }\n+\n+fn main() {\n+    test_copy_clone(foo);\n+    let f: fn() = foo;\n+    test_copy_clone(f);\n+    // FIXME: add closures when they're considered WF\n+    test_copy_clone([1; 56]);\n+    test_copy_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n+    test_copy_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, true, 'a', 1.1));\n+    test_copy_clone(());\n+    test_copy_clone(((1, 1), (1, 1, 1), (1.1, 1, 1, 'a'), ()));\n+\n+    let a = (\n+        (S(1), S(0)),\n+        (\n+            (S(0), S(0), S(1)),\n+            S(0)\n+        )\n+    );\n+    test_copy_clone(a);\n+}"}, {"sha": "df25bad622b3d09e83d3d6090f176f5cf914e887", "filename": "src/test/ui/chalkify/chalk_initial_program.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl Foo for i32 { }\n+\n+impl Foo for u32 { }\n+\n+fn gimme<F: Foo>() { }\n+\n+// Note: this also tests that `std::process::Termination` is implemented for `()`.\n+fn main() {\n+    gimme::<i32>();\n+    gimme::<u32>();\n+    gimme::<f32>(); //~ERROR the trait bound `f32: Foo` is not satisfied\n+}"}, {"sha": "f2e13a6a46904316a29b8fd44b4bdfa8a4a1882f", "filename": "src/test/ui/chalkify/chalk_initial_program.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `f32: Foo` is not satisfied\n+  --> $DIR/chalk_initial_program.rs:15:13\n+   |\n+LL | fn gimme<F: Foo>() { }\n+   |             --- required by this bound in `gimme`\n+...\n+LL |     gimme::<f32>();\n+   |             ^^^ the trait `Foo` is not implemented for `f32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d70c6f8055ddf92adfd332a3d1963888ed08ce93", "filename": "src/test/ui/chalkify/generic_impls.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl<T> Foo for (T, u32) { }\n+\n+fn gimme<F: Foo>() { }\n+\n+fn foo<T>() {\n+    gimme::<(T, u32)>();\n+    gimme::<(Option<T>, u32)>();\n+    gimme::<(Option<T>, f32)>(); //~ ERROR\n+}\n+\n+fn main() {\n+    gimme::<(i32, u32)>();\n+    gimme::<(i32, f32)>(); //~ ERROR\n+}"}, {"sha": "4ac57a2f13fd15920ca92d8987a2d4b72bdf948a", "filename": "src/test/ui/chalkify/generic_impls.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,27 @@\n+error[E0277]: the trait bound `(std::option::Option<T>, f32): Foo` is not satisfied\n+  --> $DIR/generic_impls.rs:12:13\n+   |\n+LL | fn gimme<F: Foo>() { }\n+   |             --- required by this bound in `gimme`\n+...\n+LL |     gimme::<(Option<T>, f32)>();\n+   |             ^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `(std::option::Option<T>, f32)`\n+   |\n+   = help: the following implementations were found:\n+             <(T, u32) as Foo>\n+\n+error[E0277]: the trait bound `(i32, f32): Foo` is not satisfied\n+  --> $DIR/generic_impls.rs:17:13\n+   |\n+LL | fn gimme<F: Foo>() { }\n+   |             --- required by this bound in `gimme`\n+...\n+LL |     gimme::<(i32, f32)>();\n+   |             ^^^^^^^^^^ the trait `Foo` is not implemented for `(i32, f32)`\n+   |\n+   = help: the following implementations were found:\n+             <(T, u32) as Foo>\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8aa876422924d3e96ff0a38ec2d0e7633c0ac45d", "filename": "src/test/ui/chalkify/impl_wf.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,47 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo: Sized { }\n+\n+trait Bar {\n+    type Item: Foo;\n+}\n+\n+impl Foo for i32 { }\n+\n+// FIXME(chalk): blocked on better handling of builtin traits for non-struct\n+// application types (or a workaround)\n+/*\n+impl Foo for str { }\n+//^ ERROR the size for values of type `str` cannot be known at compilation time\n+*/\n+\n+// Implicit `T: Sized` bound.\n+impl<T> Foo for Option<T> { }\n+\n+impl Bar for () {\n+    type Item = i32;\n+}\n+\n+impl<T> Bar for Option<T> {\n+    type Item = Option<T>;\n+}\n+\n+// FIXME(chalk): the ordering of these two errors differs between CI and local\n+// We need to figure out why its non-deterministic\n+/*\n+impl Bar for f32 {\n+//^ ERROR the trait bound `f32: Foo` is not satisfied\n+    type Item = f32;\n+    //^ ERROR the trait bound `f32: Foo` is not satisfied\n+}\n+*/\n+\n+trait Baz<U: ?Sized> where U: Foo { }\n+\n+impl Baz<i32> for i32 { }\n+\n+impl Baz<f32> for f32 { }\n+//~^ ERROR the trait bound `f32: Foo` is not satisfied\n+\n+fn main() {\n+}"}, {"sha": "befd688741c80ca4e77fe8ed684e1ad7da408c4e", "filename": "src/test/ui/chalkify/impl_wf.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `f32: Foo` is not satisfied\n+  --> $DIR/impl_wf.rs:43:6\n+   |\n+LL | trait Baz<U: ?Sized> where U: Foo { }\n+   |                               --- required by this bound in `Baz`\n+...\n+LL | impl Baz<f32> for f32 { }\n+   |      ^^^^^^^^ the trait `Foo` is not implemented for `f32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "44e120c1eebbaabfd4bd162118ff3943199b5303", "filename": "src/test/ui/chalkify/inherent_impl.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,42 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl Foo for i32 { }\n+\n+struct S<T: Foo> {\n+    x: T,\n+}\n+\n+fn only_foo<T: Foo>(_x: &T) { }\n+\n+impl<T> S<T> {\n+    // Test that we have the correct environment inside an inherent method.\n+    fn dummy_foo(&self) {\n+        only_foo(&self.x)\n+    }\n+}\n+\n+trait Bar { }\n+impl Bar for u32 { }\n+\n+fn only_bar<T: Bar>() { }\n+\n+impl<T> S<T> {\n+    // Test that the environment of `dummy_bar` adds up with the environment\n+    // of the inherent impl.\n+    fn dummy_bar<U: Bar>(&self) {\n+        only_foo(&self.x);\n+        only_bar::<U>();\n+    }\n+}\n+\n+fn main() {\n+    let s = S {\n+        x: 5,\n+    };\n+\n+    s.dummy_foo();\n+    s.dummy_bar::<u32>();\n+}"}, {"sha": "774c46e401ca30260f86e73dc4f27f26f9f573a9", "filename": "src/test/ui/chalkify/inherent_impl_min.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl_min.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl_min.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl_min.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl Foo for i32 { }\n+\n+struct S<T: Foo> {\n+    x: T,\n+}\n+\n+fn only_foo<T: Foo>(_x: &T) { }\n+\n+impl<T> S<T> {\n+    // Test that we have the correct environment inside an inherent method.\n+    fn dummy_foo(&self) {\n+        only_foo(&self.x)\n+    }\n+}\n+\n+fn main() {\n+    let s = S {\n+        x: 5,\n+    };\n+\n+    s.dummy_foo();\n+}"}, {"sha": "e3c7569592149d236215c06570469ddf1e120f6e", "filename": "src/test/ui/chalkify/lower_env1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+#![allow(dead_code)]\n+\n+trait Foo { }\n+\n+trait Bar where Self: Foo { }\n+\n+fn bar<T: Bar + ?Sized>() {\n+}\n+\n+fn main() {\n+}"}, {"sha": "b5432ce0e307bb9e2bf5c024a4dda0f0906aff28", "filename": "src/test/ui/chalkify/lower_env2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+#![allow(dead_code)]\n+\n+trait Foo { }\n+\n+struct S<'a, T: ?Sized> where T: Foo {\n+    data: &'a T,\n+}\n+\n+fn bar<T: Foo>(_x: S<'_, T>) { // note that we have an implicit `T: Sized` bound\n+}\n+\n+fn main() {\n+}"}, {"sha": "673f08d78abd0ee08102294a9ed6634b04ac4e46", "filename": "src/test/ui/chalkify/lower_env3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+#![allow(dead_code)]\n+\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+impl<T> Foo for T where T: Clone {\n+    fn foo(&self) {\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "f586cf083915debc7986e0d2e59d5a69f4149cac", "filename": "src/test/ui/chalkify/lower_impl.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl<T: 'static> Foo for T where T: Iterator<Item = i32> { }\n+\n+trait Bar {\n+    type Assoc;\n+}\n+\n+impl<T> Bar for T where T: Iterator<Item = i32> {\n+    type Assoc = Vec<T>;\n+}\n+\n+fn main() {\n+}"}, {"sha": "94a0716d383546c2f307cac7232cd2f3a1543fd1", "filename": "src/test/ui/chalkify/lower_struct.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,8 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+struct Foo<'a, T> where Box<T>: Clone {\n+    _x: std::marker::PhantomData<&'a T>,\n+}\n+\n+fn main() { }"}, {"sha": "d8f6180ceb315ab07a41346ca0d9904f9a131478", "filename": "src/test/ui/chalkify/lower_trait.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Bar { }\n+\n+trait Foo<S, T: ?Sized> {\n+    type Assoc: Bar + ?Sized;\n+}\n+\n+fn main() {\n+}"}, {"sha": "a48979491a10de7144a331e911d39a55923ff2d0", "filename": "src/test/ui/chalkify/lower_trait_higher_rank.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo<F: ?Sized> where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8\n+{\n+}\n+\n+fn main() {\n+}"}, {"sha": "19cff8db7cb4ad59c792a43f2ed000a8986d5bda", "filename": "src/test/ui/chalkify/lower_trait_where_clause.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+use std::borrow::Borrow;\n+\n+trait Foo<'a, 'b, T, U>\n+where\n+    T: Borrow<U> + ?Sized,\n+    U: ?Sized + 'b,\n+    'a: 'b,\n+    Box<T>:, // NOTE(#53696) this checks an empty list of bounds.\n+{\n+}\n+\n+fn main() {\n+}"}, {"sha": "cf36aef8afaf3d0c9963229d64099c941e820af4", "filename": "src/test/ui/chalkify/println.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fprintln.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fprintln.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fprintln.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+fn main() {\n+    // FIXME(chalk): Require `RegionOutlives`/`TypeOutlives`/`Subtype` support\n+    //println!(\"hello\");\n+}"}, {"sha": "d6a8dd7a4a20317ddadfd00f2659683b1cd8bbae", "filename": "src/test/ui/chalkify/projection.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fprojection.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,25 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+trait Bar {\n+    type Item: Foo;\n+}\n+\n+impl Foo for i32 { }\n+impl Bar for i32 {\n+    type Item = i32;\n+}\n+\n+fn only_foo<T: Foo>() { }\n+\n+fn only_bar<T: Bar>() {\n+    // `T` implements `Bar` hence `<T as Bar>::Item` must also implement `Bar`\n+    only_foo::<T::Item>()\n+}\n+\n+fn main() {\n+    only_bar::<i32>();\n+    only_foo::<<i32 as Bar>::Item>();\n+}"}, {"sha": "6ee13f5e7a104da2aab05de447f6074fd4584ab5", "filename": "src/test/ui/chalkify/recursive_where_clause_on_type.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,35 @@\n+// FIXME(chalk): should fail, see comments\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+#![feature(trivial_bounds)]\n+\n+trait Bar {\n+    fn foo();\n+}\n+trait Foo: Bar { }\n+\n+struct S where S: Foo;\n+//~^ WARN Trait bound S: Foo does not depend on any type or lifetime parameters\n+\n+impl Foo for S {\n+}\n+\n+fn bar<T: Bar>() {\n+    T::foo();\n+}\n+\n+fn foo<T: Foo>() {\n+    bar::<T>()\n+}\n+\n+fn main() {\n+    // For some reason, the error is duplicated...\n+\n+    // FIXME(chalk): this order of this duplicate error seems non-determistic\n+    // and causes test to fail\n+    /*\n+    foo::<S>() // ERROR the type `S` is not well-formed (chalk)\n+    //^ ERROR the type `S` is not well-formed (chalk)\n+    */\n+}"}, {"sha": "a5b7ef7fdb2e37b920130c2a875577f2d6a6375c", "filename": "src/test/ui/chalkify/recursive_where_clause_on_type.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,10 @@\n+warning: Trait bound S: Foo does not depend on any type or lifetime parameters\n+  --> $DIR/recursive_where_clause_on_type.rs:12:19\n+   |\n+LL | struct S where S: Foo;\n+   |                   ^^^\n+   |\n+   = note: `#[warn(trivial_bounds)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "eeff9fd9b80a36098d7f90944fab6d08f56ab092", "filename": "src/test/ui/chalkify/super_trait.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fsuper_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Fsuper_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fsuper_trait.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+trait Bar: Foo { }\n+\n+impl Foo for i32 { }\n+impl Bar for i32 { }\n+\n+fn only_foo<T: Foo>() { }\n+\n+fn only_bar<T: Bar>() {\n+    // `T` implements `Bar` hence `T` must also implement `Foo`\n+    only_foo::<T>()\n+}\n+\n+fn main() {\n+    only_bar::<i32>()\n+}"}, {"sha": "8a2e1cf599008acd80bcb98765711110013d3642", "filename": "src/test/ui/chalkify/trait_implied_bound.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftrait_implied_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftrait_implied_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftrait_implied_bound.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+trait Bar<U> where U: Foo { }\n+\n+impl Foo for i32 { }\n+impl Bar<i32> for i32 { }\n+\n+fn only_foo<T: Foo>() { }\n+\n+fn only_bar<U, T: Bar<U>>() {\n+    only_foo::<U>()\n+}\n+\n+fn main() {\n+    only_bar::<i32, i32>()\n+}"}, {"sha": "8673f5319bdf05c55bf580eb1fb33967590b1ed6", "filename": "src/test/ui/chalkify/type_implied_bound.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftype_implied_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftype_implied_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_implied_bound.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,29 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Eq { }\n+trait Hash: Eq { }\n+\n+impl Eq for i32 { }\n+impl Hash for i32 { }\n+\n+struct Set<T: Hash> {\n+    _x: T,\n+}\n+\n+fn only_eq<T: Eq>() { }\n+\n+fn take_a_set<T>(_: &Set<T>) {\n+    // `Set<T>` is an input type of `take_a_set`, hence we know that\n+    // `T` must implement `Hash`, and we know in turn that `T` must\n+    // implement `Eq`.\n+    only_eq::<T>()\n+}\n+\n+fn main() {\n+    let set = Set {\n+        _x: 5,\n+    };\n+\n+    take_a_set(&set);\n+}"}, {"sha": "5175c5d062a6e37ffb5e4a0f790da6d5fefd997c", "filename": "src/test/ui/chalkify/type_inference.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,28 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+impl Foo for i32 { }\n+\n+trait Bar { }\n+impl Bar for i32 { }\n+impl Bar for u32 { }\n+\n+fn only_foo<T: Foo>(_x: T) { }\n+\n+fn only_bar<T: Bar>(_x: T) { }\n+\n+fn main() {\n+    let x = 5.0;\n+\n+    // The only type which implements `Foo` is `i32`, so the chalk trait solver\n+    // is expecting a variable of type `i32`. This behavior differs from the\n+    // old-style trait solver. I guess this will change, that's why I'm\n+    // adding that test.\n+    // FIXME(chalk): partially blocked on float/int special casing\n+    only_foo(x); //~ ERROR the trait bound `f64: Foo` is not satisfied\n+\n+    // Here we have two solutions so we get back the behavior of the old-style\n+    // trait solver.\n+    // FIXME(chalk): blocked on float/int special casing\n+    //only_bar(x); // ERROR the trait bound `{float}: Bar` is not satisfied\n+}"}, {"sha": "ee9e67c6c78849d43095e8efa28ceffeae4ef7d2", "filename": "src/test/ui/chalkify/type_inference.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `f64: Foo` is not satisfied\n+  --> $DIR/type_inference.rs:22:5\n+   |\n+LL | fn only_foo<T: Foo>(_x: T) { }\n+   |                --- required by this bound in `only_foo`\n+...\n+LL |     only_foo(x);\n+   |     ^^^^^^^^ the trait `Foo` is not implemented for `f64`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "396baf814a0b040c5379657fc9671890bf69e4fe", "filename": "src/test/ui/chalkify/type_wf.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,32 @@\n+// FIXME(chalk): should have an error, see below\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+struct S<T: Foo> {\n+    x: T,\n+}\n+\n+impl Foo for i32 { }\n+impl<T> Foo for Option<T> { }\n+\n+fn main() {\n+    let s = S {\n+       x: 5,\n+    };\n+\n+    // FIXME(chalk): blocked on float/int special handling. Needs to know that {float}: !i32\n+    /*\n+    let s = S { // ERROR the trait bound `{float}: Foo` is not satisfied\n+        x: 5.0,\n+    };\n+    */\n+\n+    // FIXME(chalk): blocked on float/int special handling. Needs to know that {float}: Sized\n+    /*\n+    let s = S {\n+        x: Some(5.0),\n+    };\n+    */\n+}"}, {"sha": "1213a883ef0a3cfed01004f851786e593cd31771", "filename": "src/test/ui/closures/diverging-closure.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fclosures%2Fdiverging-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fclosures%2Fdiverging-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fdiverging-closure.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:oops\n+// ignore-emscripten no processes\n \n fn main() {\n     let func = || -> ! {", "previous_filename": "src/test/run-fail/diverging-closure.rs"}, {"sha": "b4503f691ffd95fe2ea31d178260fb4f551ced64", "filename": "src/test/ui/consts/promoted_div_by_zero.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fconsts%2Fpromoted_div_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fconsts%2Fpromoted_div_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromoted_div_by_zero.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,8 @@\n #![allow(unconditional_panic, const_err)]\n \n+// run-fail\n // error-pattern: attempt to divide by zero\n+// ignore-emscripten no processes\n \n fn main() {\n     let x = &(1 / (1 - 1));", "previous_filename": "src/test/run-fail/promoted_div_by_zero.rs"}, {"sha": "123b57f97a4ecbdd9609b82833427028b4a9eb3a", "filename": "src/test/ui/fn/expr-fn-panic.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Ffn%2Fexpr-fn-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Ffn%2Fexpr-fn-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fexpr-fn-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n fn f() -> ! {\n     panic!()", "previous_filename": "src/test/run-fail/expr-fn-panic.rs"}, {"sha": "55704f40e9f2b81a94dcd3fc3ab7c2f908c8891b", "filename": "src/test/ui/generator/generator-resume-after-panic.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-resume-after-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-resume-after-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-resume-after-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:generator resumed after panicking\n+// ignore-emscripten no processes\n \n // Test that we get the correct message for resuming a panicked generator.\n ", "previous_filename": "src/test/run-fail/generator-resume-after-panic.rs"}, {"sha": "5f88683f4adfcbdb242e705d5fb007c251c6b859", "filename": "src/test/ui/hashmap/hashmap-capacity-overflow.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-capacity-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-capacity-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-capacity-overflow.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:capacity overflow\n+// ignore-emscripten no processes\n \n use std::collections::hash_map::HashMap;\n use std::usize;", "previous_filename": "src/test/run-fail/hashmap-capacity-overflow.rs"}, {"sha": "312a91adca6785f7803940278ce731e65ba8e48f", "filename": "src/test/ui/hashmap/hashmap-iter-value-lifetime.nll.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-iter-value-lifetime.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-iter-value-lifetime.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-iter-value-lifetime.nll.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "previous_filename": "src/test/ui/hashmap-iter-value-lifetime.nll.stderr"}, {"sha": "260ea8c7ae15f860e871c5f665f724e665ed1e61", "filename": "src/test/ui/hashmap/hashmap-iter-value-lifetime.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-iter-value-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-iter-value-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-iter-value-lifetime.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "previous_filename": "src/test/ui/hashmap-iter-value-lifetime.rs"}, {"sha": "f7626b13bad3640c325c95c86c24ddf9f0d1c14b", "filename": "src/test/ui/hashmap/hashmap-iter-value-lifetime.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-iter-value-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-iter-value-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-iter-value-lifetime.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "previous_filename": "src/test/ui/hashmap-iter-value-lifetime.stderr"}, {"sha": "aa8e890c168dc3fdcfacdad7b8bbbdbd64bcee04", "filename": "src/test/ui/hashmap/hashmap-lifetimes.nll.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-lifetimes.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-lifetimes.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-lifetimes.nll.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "previous_filename": "src/test/ui/hashmap-lifetimes.nll.stderr"}, {"sha": "295bf3b0e663156cdb0d83ed5456e9015def9fd5", "filename": "src/test/ui/hashmap/hashmap-lifetimes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-lifetimes.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "previous_filename": "src/test/ui/hashmap-lifetimes.rs"}, {"sha": "497c7d1216cd961b7ec1885c094cc633f9666f9b", "filename": "src/test/ui/hashmap/hashmap-lifetimes.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-lifetimes.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "previous_filename": "src/test/ui/hashmap-lifetimes.stderr"}, {"sha": "3129eb0da82f9a5f89528be675b5e796b5363fdf", "filename": "src/test/ui/hashmap/hashmap-memory.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-memory.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "previous_filename": "src/test/ui/hashmap-memory.rs"}, {"sha": "36e49785a49d0445f6b056261e4fc857bc77afd5", "filename": "src/test/ui/if/expr-if-panic-fn.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fif%2Fexpr-if-panic-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fif%2Fexpr-if-panic-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fexpr-if-panic-fn.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n fn f() -> ! {\n     panic!()", "previous_filename": "src/test/run-fail/expr-if-panic-fn.rs"}, {"sha": "520ee0870ee15b95a9ac9f4b081d71b3137aab25", "filename": "src/test/ui/if/expr-if-panic.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fif%2Fexpr-if-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fif%2Fexpr-if-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fexpr-if-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n fn main() {\n     let _x = if false {", "previous_filename": "src/test/run-fail/expr-if-panic.rs"}, {"sha": "037cd427ccf368b9568a37be027d0a01b5a99788", "filename": "src/test/ui/if/if-check-panic.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fif%2Fif-check-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fif%2Fif-check-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-check-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:Number is odd\n+// ignore-emscripten no processes\n+\n fn even(x: usize) -> bool {\n     if x < 2 {\n         return false;", "previous_filename": "src/test/run-fail/if-check-panic.rs"}, {"sha": "bcd114678528cc2e4df749d114262488d385a79a", "filename": "src/test/ui/if/if-cond-bot.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fif%2Fif-cond-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fif%2Fif-cond-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-cond-bot.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,8 +1,12 @@\n+// run-fail\n // error-pattern:quux\n+// ignore-emscripten no processes\n+\n fn my_err(s: String) -> ! {\n     println!(\"{}\", s);\n     panic!(\"quux\");\n }\n+\n fn main() {\n     if my_err(\"bye\".to_string()) {\n     }", "previous_filename": "src/test/run-fail/if-cond-bot.rs"}, {"sha": "ef06cc570d5579baf17f50e2b96c6871b160ddb4", "filename": "src/test/ui/imports/glob-use-std.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fimports%2Fglob-use-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fimports%2Fglob-use-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-use-std.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,8 @@\n // Issue #7580\n \n+// run-fail\n // error-pattern:panic works\n+// ignore-emscripten no processes\n \n use std::*;\n ", "previous_filename": "src/test/run-fail/glob-use-std.rs"}, {"sha": "a0cfea055be2bfb4f620c44c64ca7280f645f522", "filename": "src/test/ui/issues/issue-12920.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-12920.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-12920.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12920.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n pub fn main() {\n     panic!();", "previous_filename": "src/test/run-fail/issue-12920.rs"}, {"sha": "16debb5b6c4a6df7a3e0fc8afda8fe0377b940a7", "filename": "src/test/ui/issues/issue-13202.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-13202.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-13202.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13202.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:bad input\n+// ignore-emscripten no processes\n \n fn main() {\n     Some(\"foo\").unwrap_or(panic!(\"bad input\")).to_string();", "previous_filename": "src/test/run-fail/issue-13202.rs"}, {"sha": "389cf108b05eeddb5e4ce3f39c26cff600ef80c9", "filename": "src/test/ui/issues/issue-18576.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-18576.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-18576.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18576.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:stop\n+// ignore-emscripten no processes\n \n // #18576\n // Make sure that calling an extern function pointer in an unreachable\n@@ -10,4 +12,5 @@ fn main() {\n     let pointer = other;\n     pointer();\n }\n+\n extern \"C\" fn other() {}", "previous_filename": "src/test/run-fail/issue-18576.rs"}, {"sha": "2e10418178c427615ba150b787c4f1f52481b206", "filename": "src/test/ui/issues/issue-20971.rs", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-20971.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-20971.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20971.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,8 @@\n // Regression test for Issue #20971.\n \n+// run-fail\n // error-pattern:Hello, world!\n+// ignore-emscripten no processes\n \n pub trait Parser {\n     type Input;\n@@ -12,7 +14,7 @@ impl Parser for () {\n     fn parse(&mut self, input: ()) {}\n }\n \n-pub fn many() -> Box<Parser<Input = <() as Parser>::Input> + 'static> {\n+pub fn many() -> Box<dyn Parser<Input = <() as Parser>::Input> + 'static> {\n     panic!(\"Hello, world!\")\n }\n ", "previous_filename": "src/test/run-fail/issue-20971.rs"}, {"sha": "c291d8a5eaf3d743b73fafd89610cb3e4b974229", "filename": "src/test/ui/issues/issue-23354-2.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-23354-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-23354-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23354-2.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:panic evaluated\n+// ignore-emscripten no processes\n \n #[allow(unused_variables)]\n fn main() {", "previous_filename": "src/test/run-fail/issue-23354-2.rs"}, {"sha": "8b7c2eef2fc1be798ae32565d1f07e76f93646e6", "filename": "src/test/ui/issues/issue-23354.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-23354.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-23354.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23354.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:panic evaluated\n+// ignore-emscripten no processes\n \n #[allow(unused_variables)]\n fn main() {", "previous_filename": "src/test/run-fail/issue-23354.rs"}, {"sha": "ac0d0506a342df101cff27a9b178dd2dc62ac669", "filename": "src/test/ui/issues/issue-2444.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-2444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-2444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2444.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,12 +1,14 @@\n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n use std::sync::Arc;\n \n-enum e<T> {\n-    ee(Arc<T>),\n+enum Err<T> {\n+    Errr(Arc<T>),\n }\n \n-fn foo() -> e<isize> {\n+fn foo() -> Err<isize> {\n     panic!();\n }\n ", "previous_filename": "src/test/run-fail/issue-2444.rs"}, {"sha": "f0e8e185e5633e69ecc28403700c7fad01b9fe2b", "filename": "src/test/ui/issues/issue-2470-bounds-check-overflow.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2470-bounds-check-overflow.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:index out of bounds\n+// ignore-emscripten no processes\n \n use std::mem;\n ", "previous_filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs"}, {"sha": "3ba098abbe65a840d4cb0369f9946a9165e5d0d1", "filename": "src/test/ui/issues/issue-2761.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-2761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-2761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2761.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:custom message\n+// ignore-emscripten no processes\n \n fn main() {\n     assert!(false, \"custom message\");", "previous_filename": "src/test/run-fail/issue-2761.rs"}, {"sha": "1e48878f632e569a75989da8fbc217540846196d", "filename": "src/test/ui/issues/issue-28934.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-28934.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-28934.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28934.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,7 +1,9 @@\n // Regression test: issue had to do with \"givens\" in region inference,\n // which were not being considered during the contraction phase.\n \n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n struct Parser<'i: 't, 't>(&'i u8, &'t u8);\n ", "previous_filename": "src/test/run-fail/issue-28934.rs"}, {"sha": "5eff5d1915bad5130c63916e1714025a5204d74d", "filename": "src/test/ui/issues/issue-29798.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-29798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-29798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29798.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:index out of bounds: the len is 5 but the index is 5\n+// ignore-emscripten no processes\n \n const fn test(x: usize) -> i32 {\n     [42;5][x]", "previous_filename": "src/test/run-fail/issue-29798.rs"}, {"sha": "a5d30960a4cdb84833265e57a38125553a60734e", "filename": "src/test/ui/issues/issue-3029.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3029.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,9 +1,11 @@\n+// run-fail\n+// error-pattern:so long\n+// ignore-emscripten no processes\n+\n #![allow(unused_allocation)]\n #![allow(unreachable_code)]\n #![allow(unused_variables)]\n \n-\n-// error-pattern:so long\n fn main() {\n     let mut x = Vec::new();\n     let y = vec![3];", "previous_filename": "src/test/run-fail/issue-3029.rs"}, {"sha": "48b329c5de1489f706515cb5b5fbbac613ec1fea", "filename": "src/test/ui/issues/issue-30380.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-30380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-30380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30380.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,7 +1,9 @@\n // check that panics in destructors during assignment do not leave\n // destroyed values lying around for other destructors to observe.\n \n+// run-fail\n // error-pattern:panicking destructors ftw!\n+// ignore-emscripten no processes\n \n struct Observer<'a>(&'a mut FilledOnDrop);\n ", "previous_filename": "src/test/run-fail/issue-30380.rs"}, {"sha": "c2f3598f645bb826e228ed2625fd060b58aac78e", "filename": "src/test/ui/issues/issue-44216-add-instant.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-instant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-instant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-instant.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:overflow\n+// ignore-emscripten no processes\n \n use std::time::{Instant, Duration};\n ", "previous_filename": "src/test/run-fail/issue-44216-add-instant.rs"}, {"sha": "9a88cb7c189168bb57e3c1f0f746e0281a986adb", "filename": "src/test/ui/issues/issue-44216-add-system-time.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-system-time.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-system-time.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-system-time.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:overflow\n+// ignore-emscripten no processes\n \n use std::time::{Duration, SystemTime};\n ", "previous_filename": "src/test/run-fail/issue-44216-add-system-time.rs"}, {"sha": "2decd88bbc06b7033df0d6485bf4ac2c77eaa93a", "filename": "src/test/ui/issues/issue-44216-sub-instant.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-instant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-instant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-instant.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:overflow\n+// ignore-emscripten no processes\n \n use std::time::{Instant, Duration};\n ", "previous_filename": "src/test/run-fail/issue-44216-sub-instant.rs"}, {"sha": "e58a31a41a5e9c285825212ccd9c1ad025050165", "filename": "src/test/ui/issues/issue-44216-sub-system-time.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-system-time.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-system-time.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-system-time.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:overflow\n+// ignore-emscripten no processes\n \n use std::time::{Duration, SystemTime};\n ", "previous_filename": "src/test/run-fail/issue-44216-sub-system-time.rs"}, {"sha": "52f342a85005e19ebffc07f2cbd6f7b4bdc5449d", "filename": "src/test/ui/issues/issue-51345-2.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-51345-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-51345-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51345-2.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern: thread 'main' panicked at 'explicit panic'\n+// ignore-emscripten no processes\n \n fn main() {\n     let mut vec = vec![];", "previous_filename": "src/test/run-fail/issue-51345.rs"}, {"sha": "184e4832b90b02c737b82f7401fe167498d5ee31", "filename": "src/test/ui/issues/issue-6458-1.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-6458-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-6458-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458-1.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n fn foo<T>(t: T) {}\n fn main() {", "previous_filename": "src/test/run-fail/issue-6458-1.rs"}, {"sha": "f929d388819a901f598465395a17e38f2a50e76e", "filename": "src/test/ui/issues/issue-811.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-811.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,26 @@\n+// run-fail\n+// error-pattern:quux\n+// ignore-emscripten no processes\n+\n+use std::marker::PhantomData;\n+\n+fn test00_start(ch: Chan<isize>, message: isize) {\n+    send(ch, message);\n+}\n+\n+type TaskId = isize;\n+type PortId = isize;\n+\n+struct Chan<T> {\n+    task: TaskId,\n+    port: PortId,\n+    marker: PhantomData<*mut T>,\n+}\n+\n+fn send<T: Send>(_ch: Chan<T>, _data: T) {\n+    panic!();\n+}\n+\n+fn main() {\n+    panic!(\"quux\");\n+}"}, {"sha": "b9bbeb3951e4750dd52e787583f3e7c5da6e5699", "filename": "src/test/ui/issues/issue-948.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-948.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fissues%2Fissue-948.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-948.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:beep boop\n+// ignore-emscripten no processes\n \n #![allow(unused_variables)]\n ", "previous_filename": "src/test/run-fail/issue-948.rs"}, {"sha": "5156999f4db9c0d8ada08717d1c22a13d6a6ca66", "filename": "src/test/ui/loops/for-each-loop-panic.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Floops%2Ffor-each-loop-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Floops%2Ffor-each-loop-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Ffor-each-loop-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:moop\n+// ignore-emscripten no processes\n \n fn main() {\n     for _ in 0_usize..10_usize {", "previous_filename": "src/test/run-fail/for-each-loop-panic.rs"}, {"sha": "23c0548081333300bd7e37d1855ade50d907e387", "filename": "src/test/ui/macros/assert-as-macro.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-as-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-as-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-as-macro.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:assertion failed: 1 == 2\n+// ignore-emscripten no processes\n \n fn main() {\n     assert!(1 == 2);", "previous_filename": "src/test/run-fail/assert-as-macro.rs"}, {"sha": "5e505c30b350398e1236d8e9bfa87345f4464f29", "filename": "src/test/ui/macros/assert-eq-macro-panic.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-eq-macro-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-eq-macro-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-eq-macro-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,8 @@\n+// run-fail\n // error-pattern:assertion failed: `(left == right)`\n // error-pattern: left: `14`\n // error-pattern:right: `15`\n+// ignore-emscripten no processes\n \n fn main() {\n     assert_eq!(14, 15);", "previous_filename": "src/test/run-fail/assert-eq-macro-panic.rs"}, {"sha": "578ef5632780f35dcc158799625e6c36603d1756", "filename": "src/test/ui/macros/assert-macro-explicit.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-explicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-explicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-explicit.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:panicked at 'assertion failed: false'\n+// ignore-emscripten no processes\n \n fn main() {\n     assert!(false);", "previous_filename": "src/test/run-fail/assert-macro-explicit.rs"}, {"sha": "b8d319d85f4044d93cbd3d2c41e566bb3821d368", "filename": "src/test/ui/macros/assert-macro-fmt.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-fmt.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:panicked at 'test-assert-fmt 42 rust'\n+// ignore-emscripten no processes\n \n fn main() {\n     assert!(false, \"test-assert-fmt {} {}\", 42, \"rust\");", "previous_filename": "src/test/run-fail/assert-macro-fmt.rs"}, {"sha": "b50fe65c0150f2b432d7dec17ac0b179dc1ec5ac", "filename": "src/test/ui/macros/assert-macro-owned.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-owned.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:panicked at 'test-assert-owned'\n+// ignore-emscripten no processes\n \n fn main() {\n     assert!(false, \"test-assert-owned\".to_string());", "previous_filename": "src/test/run-fail/assert-macro-owned.rs"}, {"sha": "dc5274a7e88809303c1151e3c52fb707ab0ce001", "filename": "src/test/ui/macros/assert-macro-static.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-macro-static.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:panicked at 'test-assert-static'\n+// ignore-emscripten no processes\n \n fn main() {\n     assert!(false, \"test-assert-static\");", "previous_filename": "src/test/run-fail/assert-macro-static.rs"}, {"sha": "4f507d7b54d9947e0f1b0977b526ab6dd7f1dcc5", "filename": "src/test/ui/macros/assert-ne-macro-panic.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-ne-macro-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fassert-ne-macro-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-ne-macro-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,8 @@\n+// run-fail\n // error-pattern:assertion failed: `(left != right)`\n // error-pattern: left: `14`\n // error-pattern:right: `14`\n+// ignore-emscripten no processes\n \n fn main() {\n     assert_ne!(14, 14);", "previous_filename": "src/test/run-fail/assert-ne-macro-panic.rs"}, {"sha": "ebbce528a18fa76f3cee936dacd1153a1bcd7e39", "filename": "src/test/ui/macros/die-macro-2.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fdie-macro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fdie-macro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fdie-macro-2.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:test\n+// ignore-emscripten no processes\n \n fn main() {\n     panic!(\"test\");", "previous_filename": "src/test/run-fail/die-macro.rs"}, {"sha": "c4b5f68ddf9ffa8ce06d9b2ce58c1413d8403a0c", "filename": "src/test/ui/macros/die-macro-expr.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fdie-macro-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fdie-macro-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fdie-macro-expr.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:test\n+// ignore-emscripten no processes\n \n fn main() {\n     let __isize: isize = panic!(\"test\");", "previous_filename": "src/test/run-fail/die-macro-expr.rs"}, {"sha": "588fbe61b0e76fa0476e0b08657f37f93d666b5d", "filename": "src/test/ui/macros/die-macro-pure.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fdie-macro-pure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Fdie-macro-pure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fdie-macro-pure.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:test\n+// ignore-emscripten no processes\n \n fn f() {\n     panic!(\"test\");", "previous_filename": "src/test/run-fail/die-macro-pure.rs"}, {"sha": "e7169903f8ea56bbcc04f828e4d3c3f3c763f084", "filename": "src/test/ui/macros/unimplemented-macro-panic.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funimplemented-macro-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funimplemented-macro-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funimplemented-macro-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:not implemented\n+// ignore-emscripten no processes\n+\n fn main() {\n     unimplemented!()\n }", "previous_filename": "src/test/run-fail/unimplemented-macro-panic.rs"}, {"sha": "eb17ed92711c9593a23b260d9f4b1db6ca71952b", "filename": "src/test/ui/macros/unreachable-fmt-msg.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funreachable-fmt-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funreachable-fmt-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funreachable-fmt-msg.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:internal error: entered unreachable code: 6 is not prime\n+// ignore-emscripten no processes\n+\n fn main() {\n     unreachable!(\"{} is not {}\", 6u32, \"prime\");\n }", "previous_filename": "src/test/run-fail/unreachable-fmt-msg.rs"}, {"sha": "55e2102e2cc6fa1b35b3c64b61481a43f0d8f75c", "filename": "src/test/ui/macros/unreachable-macro-panic.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funreachable-macro-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funreachable-macro-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funreachable-macro-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:internal error: entered unreachable code\n+// ignore-emscripten no processes\n+\n fn main() {\n     unreachable!()\n }", "previous_filename": "src/test/run-fail/unreachable-macro-panic.rs"}, {"sha": "55edf3af7d9e5d8982f0d8728d1c6c72fc74c189", "filename": "src/test/ui/macros/unreachable-static-msg.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funreachable-static-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funreachable-static-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funreachable-static-msg.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:internal error: entered unreachable code: uhoh\n+// ignore-emscripten no processes\n+\n fn main() {\n     unreachable!(\"uhoh\")\n }", "previous_filename": "src/test/run-fail/unreachable-static-msg.rs"}, {"sha": "55e2102e2cc6fa1b35b3c64b61481a43f0d8f75c", "filename": "src/test/ui/macros/unreachable.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmacros%2Funreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funreachable.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:internal error: entered unreachable code\n+// ignore-emscripten no processes\n+\n fn main() {\n     unreachable!()\n }", "previous_filename": "src/test/run-fail/unreachable.rs"}, {"sha": "ea471717e883a9323d07fd392dd641fb32e98a9c", "filename": "src/test/ui/match/expr-match-panic-fn.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fexpr-match-panic-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fexpr-match-panic-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fexpr-match-panic-fn.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n fn f() -> ! {\n     panic!()", "previous_filename": "src/test/run-fail/expr-match-panic-fn.rs"}, {"sha": "53f8a8bd30ddbb6ea5fa0e4d833b0a70da3ad9fa", "filename": "src/test/ui/match/expr-match-panic.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fexpr-match-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fexpr-match-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fexpr-match-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n fn main() {\n     let _x = match true {", "previous_filename": "src/test/run-fail/expr-match-panic.rs"}, {"sha": "e4a6f6d6fe44a5bb2c42d60ff14d699be4626d71", "filename": "src/test/ui/match/match-bot-panic.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fmatch-bot-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fmatch-bot-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-bot-panic.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:explicit panic\n+// ignore-emscripten no processes\n \n #![allow(unreachable_code)]\n #![allow(unused_variables)]", "previous_filename": "src/test/run-fail/match-bot-panic.rs"}, {"sha": "18cfd5e23950b392bd2090f28c28977059d972a9", "filename": "src/test/ui/match/match-disc-bot.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fmatch-disc-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fmatch-disc-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-disc-bot.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:quux\n+// ignore-emscripten no processes\n+\n fn f() -> ! {\n     panic!(\"quux\")\n }", "previous_filename": "src/test/run-fail/match-disc-bot.rs"}, {"sha": "43f6e4913ac76fcb65c9b3a9ad9213dc4d1d601b", "filename": "src/test/ui/match/match-wildcards.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fmatch-wildcards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmatch%2Fmatch-wildcards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-wildcards.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:squirrelcupcake\n+// ignore-emscripten no processes\n+\n fn cmp() -> isize {\n     match (Some('a'), None::<char>) {\n         (Some(_), _) => {", "previous_filename": "src/test/run-fail/match-wildcards.rs"}, {"sha": "01f1518c1c6ed9f044e11adcb08bcb70fed5e18e", "filename": "src/test/ui/meta-revision-bad.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmeta-revision-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmeta-revision-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmeta-revision-bad.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,7 @@\n // Meta test for compiletest: check that when we give the wrong error\n // patterns, the test fails.\n \n+// run-fail\n // revisions: foo bar\n // should-fail\n //[foo] error-pattern:bar", "previous_filename": "src/test/run-fail/meta-revision-bad.rs"}, {"sha": "7df9a6ea48faebcfb5a1ca3d3f7b1699579b84ec", "filename": "src/test/ui/meta-revision-ok.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmeta-revision-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmeta-revision-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmeta-revision-ok.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,9 +1,11 @@\n // Meta test for compiletest: check that when we give the right error\n // patterns, the test passes. See all `meta-revision-bad.rs`.\n \n+// run-fail\n // revisions: foo bar\n //[foo] error-pattern:foo\n //[bar] error-pattern:bar\n+// ignore-emscripten no processes\n \n #[cfg(foo)]\n fn die() {", "previous_filename": "src/test/run-fail/meta-revision-ok.rs"}, {"sha": "b562f93081419f9835d65a538e9734af8d84431b", "filename": "src/test/ui/mir/mir_codegen_calls_converging_drops.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_converging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_converging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_converging_drops.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,8 @@\n+// run-fail\n // error-pattern:converging_fn called\n // error-pattern:0 dropped\n // error-pattern:exit\n+// ignore-emscripten no processes\n \n struct Droppable(u8);\n impl Drop for Droppable {", "previous_filename": "src/test/run-fail/mir_codegen_calls_converging_drops.rs"}, {"sha": "e9446da9e3911de93a01d358fc974e1f6ef6977f", "filename": "src/test/ui/mir/mir_codegen_calls_converging_drops_2.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_converging_drops_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_converging_drops_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_converging_drops_2.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,8 @@\n+// run-fail\n // error-pattern:complex called\n // error-pattern:dropped\n // error-pattern:exit\n+// ignore-emscripten no processes\n \n struct Droppable;\n impl Drop for Droppable {", "previous_filename": "src/test/run-fail/mir_codegen_calls_converging_drops_2.rs"}, {"sha": "736d580e2da18aacdcddbcb784a78b6d3e884b88", "filename": "src/test/ui/mir/mir_codegen_calls_diverging.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_diverging.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:diverging_fn called\n+// ignore-emscripten no processes\n \n fn diverging_fn() -> ! {\n     panic!(\"diverging_fn called\")", "previous_filename": "src/test/run-fail/mir_codegen_calls_diverging.rs"}, {"sha": "796d74477939170c985759032d04215bb459f50f", "filename": "src/test/ui/mir/mir_codegen_calls_diverging_drops.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_diverging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_diverging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_codegen_calls_diverging_drops.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,5 +1,7 @@\n+// run-fail\n // error-pattern:diverging_fn called\n // error-pattern:0 dropped\n+// ignore-emscripten no processes\n \n struct Droppable(u8);\n impl Drop for Droppable {", "previous_filename": "src/test/run-fail/mir_codegen_calls_diverging_drops.rs"}, {"sha": "bf269ee901b93682d73b30bc89063a0f81815a69", "filename": "src/test/ui/mir/mir_drop_panics.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_drop_panics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_drop_panics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_drop_panics.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,5 +1,7 @@\n+// run-fail\n // error-pattern:panic 1\n // error-pattern:drop 2\n+// ignore-emscripten no processes\n \n struct Droppable(u32);\n impl Drop for Droppable {", "previous_filename": "src/test/run-fail/mir_drop_panics.rs"}, {"sha": "a77b2368d3baa571821e1b746ec889733060ff4f", "filename": "src/test/ui/mir/mir_dynamic_drops_1.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_dynamic_drops_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_dynamic_drops_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_dynamic_drops_1.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,8 @@\n+// run-fail\n // error-pattern:drop 1\n // error-pattern:drop 2\n // ignore-cloudabi no std::process\n+// ignore-emscripten no processes\n \n /// Structure which will not allow to be dropped twice.\n struct Droppable<'a>(&'a mut bool, u32);", "previous_filename": "src/test/run-fail/mir_dynamic_drops_1.rs"}, {"sha": "088a16d338787c69db0cba7b837d4bbe4c591d25", "filename": "src/test/ui/mir/mir_dynamic_drops_2.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_dynamic_drops_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_dynamic_drops_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_dynamic_drops_2.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,5 +1,7 @@\n+// run-fail\n // error-pattern:drop 1\n // ignore-cloudabi no std::process\n+// ignore-emscripten no processes\n \n /// Structure which will not allow to be dropped twice.\n struct Droppable<'a>(&'a mut bool, u32);", "previous_filename": "src/test/run-fail/mir_dynamic_drops_2.rs"}, {"sha": "029bdcd9a15909109aa1825a43696942ec67930e", "filename": "src/test/ui/mir/mir_dynamic_drops_3.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_dynamic_drops_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_dynamic_drops_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_dynamic_drops_3.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,8 +1,10 @@\n+// run-fail\n // error-pattern:unwind happens\n // error-pattern:drop 3\n // error-pattern:drop 2\n // error-pattern:drop 1\n // ignore-cloudabi no std::process\n+// ignore-emscripten no processes\n \n /// Structure which will not allow to be dropped twice.\n struct Droppable<'a>(&'a mut bool, u32);", "previous_filename": "src/test/run-fail/mir_dynamic_drops_3.rs"}, {"sha": "6d769b6b23a847cd77f10111fb49680103d62131", "filename": "src/test/ui/mir/mir_indexing_oob_1.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_indexing_oob_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_indexing_oob_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_indexing_oob_1.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:index out of bounds: the len is 5 but the index is 10\n+// ignore-emscripten no processes\n \n const C: [u32; 5] = [0; 5];\n ", "previous_filename": "src/test/run-fail/mir_indexing_oob_1.rs"}, {"sha": "a9e85057015365be5dbb997476ddb708d74f93aa", "filename": "src/test/ui/mir/mir_indexing_oob_2.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_indexing_oob_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_indexing_oob_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_indexing_oob_2.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:index out of bounds: the len is 5 but the index is 10\n+// ignore-emscripten no processes\n \n const C: &'static [u8; 5] = b\"hello\";\n ", "previous_filename": "src/test/run-fail/mir_indexing_oob_2.rs"}, {"sha": "4f5cab59bfc6708d6d677c4e7b22417ac23790df", "filename": "src/test/ui/mir/mir_indexing_oob_3.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_indexing_oob_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fmir%2Fmir_indexing_oob_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_indexing_oob_3.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,6 @@\n+// run-fail\n // error-pattern:index out of bounds: the len is 5 but the index is 10\n+// ignore-emscripten no processes\n \n const C: &'static [u8; 5] = b\"hello\";\n ", "previous_filename": "src/test/run-fail/mir_indexing_oob_3.rs"}, {"sha": "d615940eff1f0bd0dfda84ca6071b008601173a3", "filename": "src/test/ui/never_type/return-never-coerce.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnever_type%2Freturn-never-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnever_type%2Freturn-never-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Freturn-never-coerce.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,6 +1,8 @@\n // Test that ! coerces to other types.\n \n+// run-fail\n // error-pattern:aah!\n+// ignore-emscripten no processes\n \n fn call_another_fn<T, F: FnOnce() -> T>(f: F) -> T {\n     f()", "previous_filename": "src/test/run-fail/return-never-coerce.rs"}, {"sha": "30e0e6c1bdd4c5e4ca46a58da3307f0dc59d6f73", "filename": "src/test/ui/numbers-arithmetic/divide-by-zero.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fdivide-by-zero.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:attempt to divide by zero\n+// ignore-emscripten no processes\n+\n #[allow(unconditional_panic)]\n fn main() {\n     let y = 0;", "previous_filename": "src/test/run-fail/divide-by-zero.rs"}, {"sha": "083716394124a8e0aa1a15dab2e907bda9f3444a", "filename": "src/test/ui/numbers-arithmetic/mod-zero.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fmod-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fmod-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fmod-zero.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,4 +1,7 @@\n+// run-fail\n // error-pattern:attempt to calculate the remainder with a divisor of zero\n+// ignore-emscripten no processes\n+\n #[allow(unconditional_panic)]\n fn main() {\n     let y = 0;", "previous_filename": "src/test/run-fail/mod-zero.rs"}, {"sha": "b0f22a74b4a8f129a39154b082fcb95e02e7cb84", "filename": "src/test/ui/numbers-arithmetic/overflowing-add.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-add.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -1,5 +1,7 @@\n+// run-fail\n // error-pattern:thread 'main' panicked at 'attempt to add with overflow'\n // compile-flags: -C debug-assertions\n+// ignore-emscripten no processes\n \n #![allow(arithmetic_overflow)]\n ", "previous_filename": "src/test/run-fail/overflowing-add.rs"}, {"sha": "e5ce80336397da9e6073c2dfadfea39bd8c40630", "filename": "src/test/ui/numbers-arithmetic/overflowing-lsh-1.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-1.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,9 @@\n+// build-fail\n+// compile-flags: -C debug-assertions\n+\n+#![deny(arithmetic_overflow, const_err)]\n+\n+fn main() {\n+    let _x = 1_i32 << 32;\n+    //~^ ERROR: this arithmetic operation will overflow\n+}"}, {"sha": "54008d33968bc7df658399d5abf8dae721d8e3f2", "filename": "src/test/ui/numbers-arithmetic/overflowing-lsh-1.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-1.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,14 @@\n+error: this arithmetic operation will overflow\n+  --> $DIR/overflowing-lsh-1.rs:7:14\n+   |\n+LL |     let _x = 1_i32 << 32;\n+   |              ^^^^^^^^^^^ attempt to shift left with overflow\n+   |\n+note: the lint level is defined here\n+  --> $DIR/overflowing-lsh-1.rs:4:9\n+   |\n+LL | #![deny(arithmetic_overflow, const_err)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7fd3407a056ef80161405cf7a387027fbae2764b", "filename": "src/test/ui/numbers-arithmetic/overflowing-lsh-2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-2.rs?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,9 @@\n+// build-fail\n+// compile-flags: -C debug-assertions\n+\n+#![deny(arithmetic_overflow, const_err)]\n+\n+fn main() {\n+    let _x = 1 << -1;\n+    //~^ ERROR: this arithmetic operation will overflow\n+}"}, {"sha": "872e71bb73796ce15b872ce508b21beb0ceba6aa", "filename": "src/test/ui/numbers-arithmetic/overflowing-lsh-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bad3bf622bded50a97c0a54e29350eada2a3a169/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Foverflowing-lsh-2.stderr?ref=bad3bf622bded50a97c0a54e29350eada2a3a169", "patch": "@@ -0,0 +1,14 @@\n+error: this arithmetic operation will overflow\n+  --> $DIR/overflowing-lsh-2.rs:7:14\n+   |\n+LL |     let _x = 1 << -1;\n+   |              ^^^^^^^ attempt to shift left with overflow\n+   |\n+note: the lint level is defined here\n+  --> $DIR/overflowing-lsh-2.rs:4:9\n+   |\n+LL | #![deny(arithmetic_overflow, const_err)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}