{"sha": "6c3ddcfa501060cff3a7f81c179f712ef072c808", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjM2RkY2ZhNTAxMDYwY2ZmM2E3ZjgxYzE3OWY3MTJlZjA3MmM4MDg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-22T14:37:07Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-22T14:37:53Z"}, "message": "Simplify", "tree": {"sha": "513bb8b0a4ecb487dc1cf7be4bbc05c84ce9a975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/513bb8b0a4ecb487dc1cf7be4bbc05c84ce9a975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c3ddcfa501060cff3a7f81c179f712ef072c808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c3ddcfa501060cff3a7f81c179f712ef072c808", "html_url": "https://github.com/rust-lang/rust/commit/6c3ddcfa501060cff3a7f81c179f712ef072c808", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c3ddcfa501060cff3a7f81c179f712ef072c808/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8da7d4061960844502e3064c33eef4a0dc3828e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8da7d4061960844502e3064c33eef4a0dc3828e", "html_url": "https://github.com/rust-lang/rust/commit/e8da7d4061960844502e3064c33eef4a0dc3828e"}], "stats": {"total": 99, "additions": 41, "deletions": 58}, "files": [{"sha": "bcfc0d03eca920dc1d42c37a52e7a602276f587e", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=6c3ddcfa501060cff3a7f81c179f712ef072c808", "patch": "@@ -184,7 +184,7 @@ impl Module {\n         db.crate_def_map(self.id.krate)[self.id.local_id]\n             .scope\n             .entries()\n-            .map(|(name, res)| (name.clone(), res.def.into()))\n+            .map(|(name, def)| (name.clone(), def.into()))\n             .collect()\n     }\n "}, {"sha": "a6355232750a46e8acac4e2f83362581ef0a9359", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=6c3ddcfa501060cff3a7f81c179f712ef072c808", "patch": "@@ -183,8 +183,8 @@ mod tests {\n         let crate_def_map = db.crate_def_map(krate);\n \n         let module = crate_def_map.modules_for_file(file_id).next().unwrap();\n-        let (_, res) = crate_def_map[module].scope.entries().next().unwrap();\n-        match res.def.take_values().unwrap() {\n+        let (_, def) = crate_def_map[module].scope.entries().next().unwrap();\n+        match def.take_values().unwrap() {\n             ModuleDefId::FunctionId(it) => it,\n             _ => panic!(),\n         }"}, {"sha": "f1adc3b58ceba703280805088f5c1f3bc8198589", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=6c3ddcfa501060cff3a7f81c179f712ef072c808", "patch": "@@ -9,7 +9,7 @@ use crate::{per_ns::PerNs, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId,\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n-    visible: FxHashMap<Name, Resolution>,\n+    visible: FxHashMap<Name, PerNs>,\n     defs: Vec<ModuleDefId>,\n     impls: Vec<ImplId>,\n     /// Macros visible in current module in legacy textual scope\n@@ -27,10 +27,10 @@ pub struct ItemScope {\n     legacy_macros: FxHashMap<Name, MacroDefId>,\n }\n \n-static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n+static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n     BuiltinType::ALL\n         .iter()\n-        .map(|(name, ty)| (name.clone(), Resolution { def: PerNs::types(ty.clone().into()) }))\n+        .map(|(name, ty)| (name.clone(), PerNs::types(ty.clone().into())))\n         .collect()\n });\n \n@@ -46,9 +46,9 @@ pub(crate) enum BuiltinShadowMode {\n /// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n /// Other methods will only resolve values, types and module scoped macros only.\n impl ItemScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n         //FIXME: shadowing\n-        self.visible.iter().chain(BUILTIN_SCOPE.iter())\n+        self.visible.iter().chain(BUILTIN_SCOPE.iter()).map(|(n, def)| (n, *def))\n     }\n \n     pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n@@ -61,9 +61,7 @@ impl ItemScope {\n \n     /// Iterate over all module scoped macros\n     pub(crate) fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.visible\n-            .iter()\n-            .filter_map(|(name, res)| res.def.take_macros().map(|macro_| (name, macro_)))\n+        self.visible.iter().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n     }\n \n     /// Iterate over all legacy textual scoped macros visible at the end of the module\n@@ -72,13 +70,13 @@ impl ItemScope {\n     }\n \n     /// Get a name from current module scope, legacy macros are not included\n-    pub(crate) fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> Option<&Resolution> {\n+    pub(crate) fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> Option<&PerNs> {\n         match shadow {\n             BuiltinShadowMode::Module => self.visible.get(name).or_else(|| BUILTIN_SCOPE.get(name)),\n             BuiltinShadowMode::Other => {\n                 let item = self.visible.get(name);\n-                if let Some(res) = item {\n-                    if let Some(ModuleDefId::ModuleId(_)) = res.def.take_types() {\n+                if let Some(def) = item {\n+                    if let Some(ModuleDefId::ModuleId(_)) = def.take_types() {\n                         return BUILTIN_SCOPE.get(name).or(item);\n                     }\n                 }\n@@ -89,7 +87,7 @@ impl ItemScope {\n     }\n \n     pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n-        self.visible.values().filter_map(|r| match r.def.take_types() {\n+        self.visible.values().filter_map(|def| match def.take_types() {\n             Some(ModuleDefId::TraitId(t)) => Some(t),\n             _ => None,\n         })\n@@ -111,27 +109,27 @@ impl ItemScope {\n         self.legacy_macros.insert(name, mac);\n     }\n \n-    pub(crate) fn push_res(&mut self, name: Name, res: &Resolution) -> bool {\n+    pub(crate) fn push_res(&mut self, name: Name, def: &PerNs) -> bool {\n         let mut changed = false;\n         let existing = self.visible.entry(name.clone()).or_default();\n \n-        if existing.def.types.is_none() && res.def.types.is_some() {\n-            existing.def.types = res.def.types;\n+        if existing.types.is_none() && def.types.is_some() {\n+            existing.types = def.types;\n             changed = true;\n         }\n-        if existing.def.values.is_none() && res.def.values.is_some() {\n-            existing.def.values = res.def.values;\n+        if existing.values.is_none() && def.values.is_some() {\n+            existing.values = def.values;\n             changed = true;\n         }\n-        if existing.def.macros.is_none() && res.def.macros.is_some() {\n-            existing.def.macros = res.def.macros;\n+        if existing.macros.is_none() && def.macros.is_some() {\n+            existing.macros = def.macros;\n             changed = true;\n         }\n \n         changed\n     }\n \n-    pub(crate) fn collect_resolutions(&self) -> Vec<(Name, Resolution)> {\n+    pub(crate) fn collect_resolutions(&self) -> Vec<(Name, PerNs)> {\n         self.visible.iter().map(|(name, res)| (name.clone(), res.clone())).collect()\n     }\n \n@@ -140,12 +138,6 @@ impl ItemScope {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Default)]\n-pub struct Resolution {\n-    /// None for unresolved\n-    pub def: PerNs,\n-}\n-\n impl From<ModuleDefId> for PerNs {\n     fn from(def: ModuleDefId) -> PerNs {\n         match def {"}, {"sha": "4f1fd480181ea1c239ce3b7053650bca97fb61dc", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=6c3ddcfa501060cff3a7f81c179f712ef072c808", "patch": "@@ -18,7 +18,6 @@ use test_utils::tested_by;\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    item_scope::Resolution,\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n         raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n@@ -215,7 +214,7 @@ where\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            self.update(self.def_map.root, &[(name, Resolution { def: PerNs::macros(macro_) })]);\n+            self.update(self.def_map.root, &[(name, PerNs::macros(macro_))]);\n         }\n     }\n \n@@ -397,8 +396,7 @@ where\n                         .map(|(local_id, variant_data)| {\n                             let name = variant_data.name.clone();\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            let res =\n-                                Resolution { def: PerNs::both(variant.into(), variant.into()) };\n+                            let res = PerNs::both(variant.into(), variant.into());\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n@@ -424,22 +422,21 @@ where\n                         }\n                     }\n \n-                    let resolution = Resolution { def };\n-                    self.update(module_id, &[(name, resolution)]);\n+                    self.update(module_id, &[(name, def)]);\n                 }\n                 None => tested_by!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, Resolution)]) {\n+    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, PerNs)]) {\n         self.update_recursive(module_id, resolutions, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n         module_id: LocalModuleId,\n-        resolutions: &[(Name, Resolution)],\n+        resolutions: &[(Name, PerNs)],\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -705,8 +702,7 @@ where\n         let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: res };\n         let def: ModuleDefId = module.into();\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        let resolution = Resolution { def: def.into() };\n-        self.def_collector.update(self.module_id, &[(name, resolution)]);\n+        self.def_collector.update(self.module_id, &[(name, def.into())]);\n         res\n     }\n \n@@ -765,8 +761,7 @@ where\n             .into(),\n         };\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        let resolution = Resolution { def: def.into() };\n-        self.def_collector.update(self.module_id, &[(name, resolution)])\n+        self.def_collector.update(self.module_id, &[(name, def.into())])\n     }\n \n     fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {"}, {"sha": "378d49455527abbc9ce2cef59b9a480e0804f64c", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=6c3ddcfa501060cff3a7f81c179f712ef072c808", "patch": "@@ -181,7 +181,7 @@ impl CrateDefMap {\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n                     match self[module.local_id].scope.get(&segment, prefer_module(i)) {\n-                        Some(res) => res.def,\n+                        Some(def) => *def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment);\n                             return ResolvePathResult::empty(ReachedFixedPoint::No);\n@@ -243,8 +243,7 @@ impl CrateDefMap {\n         //  - std prelude\n         let from_legacy_macro =\n             self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n-        let from_scope =\n-            self[module].scope.get(name, shadow).map_or_else(PerNs::none, |res| res.def);\n+        let from_scope = self[module].scope.get(name, shadow).copied().unwrap_or_else(PerNs::none);\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n         let from_prelude = self.resolve_in_prelude(db, name, shadow);\n@@ -258,7 +257,7 @@ impl CrateDefMap {\n         shadow: BuiltinShadowMode,\n     ) -> PerNs {\n         let from_crate_root =\n-            self[self.root].scope.get(name, shadow).map_or_else(PerNs::none, |res| res.def);\n+            self[self.root].scope.get(name, shadow).copied().unwrap_or_else(PerNs::none);\n         let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n         from_crate_root.or(from_extern_prelude)\n@@ -279,10 +278,7 @@ impl CrateDefMap {\n                 keep = db.crate_def_map(prelude.krate);\n                 &keep\n             };\n-            def_map[prelude.local_id]\n-                .scope\n-                .get(name, shadow)\n-                .map_or_else(PerNs::none, |res| res.def)\n+            def_map[prelude.local_id].scope.get(name, shadow).copied().unwrap_or_else(PerNs::none)\n         } else {\n             PerNs::none()\n         }"}, {"sha": "ff474b53b01eee6669bcbadf6ffd4ef9b2cf9c63", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=6c3ddcfa501060cff3a7f81c179f712ef072c808", "patch": "@@ -35,19 +35,19 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n         let mut entries = map.modules[module].scope.collect_resolutions();\n         entries.sort_by_key(|(name, _)| name.clone());\n \n-        for (name, res) in entries {\n+        for (name, def) in entries {\n             *buf += &format!(\"{}:\", name);\n \n-            if res.def.types.is_some() {\n+            if def.types.is_some() {\n                 *buf += \" t\";\n             }\n-            if res.def.values.is_some() {\n+            if def.values.is_some() {\n                 *buf += \" v\";\n             }\n-            if res.def.macros.is_some() {\n+            if def.macros.is_some() {\n                 *buf += \" m\";\n             }\n-            if res.def.is_none() {\n+            if def.is_none() {\n                 *buf += \" _\";\n             }\n "}, {"sha": "e70049617dda5e32eb5a29ca16d935643e2a3e56", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3ddcfa501060cff3a7f81c179f712ef072c808/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=6c3ddcfa501060cff3a7f81c179f712ef072c808", "patch": "@@ -413,8 +413,8 @@ impl Scope {\n                 //         def: m.module.into(),\n                 //     }),\n                 // );\n-                m.crate_def_map[m.module_id].scope.entries().for_each(|(name, res)| {\n-                    f(name.clone(), ScopeDef::PerNs(res.def));\n+                m.crate_def_map[m.module_id].scope.entries().for_each(|(name, def)| {\n+                    f(name.clone(), ScopeDef::PerNs(def));\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n                     f(name.clone(), ScopeDef::PerNs(PerNs::macros(macro_)));\n@@ -424,8 +424,8 @@ impl Scope {\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    prelude_def_map[prelude.local_id].scope.entries().for_each(|(name, res)| {\n-                        f(name.clone(), ScopeDef::PerNs(res.def));\n+                    prelude_def_map[prelude.local_id].scope.entries().for_each(|(name, def)| {\n+                        f(name.clone(), ScopeDef::PerNs(def));\n                     });\n                 }\n             }"}]}