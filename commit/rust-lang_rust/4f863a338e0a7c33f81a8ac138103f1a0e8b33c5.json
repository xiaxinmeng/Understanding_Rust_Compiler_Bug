{"sha": "4f863a338e0a7c33f81a8ac138103f1a0e8b33c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmODYzYTMzOGUwYTdjMzNmODFhOGFjMTM4MTAzZjFhMGU4YjMzYzU=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-18T04:50:16Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-30T20:02:22Z"}, "message": "Second pass stabilization: slice\n\nThis commit takes a second pass through the `slice` module to\nstabilize its API. The changes are as follows:\n\n**Stable**:\n\n* `as_mut_slice`\n* `as_ptr`, `as_mut_ptr`\n* `binary_search_by` (was: `binary_search`)\n* `binary_search` (was: `binary_search_elem`)\n* `chunks`, `chunks_mut`\n* `contains`\n* `ends_with`\n* `first`, `first_mut` (was: `head`)\n* `get_unchecked`, `get_unchecked_mut` (was: `unsafe_get`)\n* `get`\n* `is_empty`\n* `iter`, `iter_mut`\n* `len`\n* `reverse`\n* `sort_by`\n* `sort`\n* `split_at`, `split_at_mut`\n* `split_mut`, `splitn_mut`, `rsplitn_mut`\n* `split`, `splitn`, `rsplitn`\n* `starts_with`\n* `swap`\n* `to_vec`\n* `windows`\n\n**Deprecated**:\n\n* `head`, `head_mut` (renamed as above)\n* `unsafe_get`, `unsafe_mut` (renamed as above)\n* `binary_search_elem` (renamed as above)\n* `partitioned`, deprecated in favor of a new, more\n  general iterator consumer called `partition`.\n* `BinarySearchResult`, deprecated in favor of `Result<uint, uint>`\n\n[breaking-change]", "tree": {"sha": "d4c5e6fa5c8cf9468d24b8927b94307425b1a2c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4c5e6fa5c8cf9468d24b8927b94307425b1a2c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f863a338e0a7c33f81a8ac138103f1a0e8b33c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f863a338e0a7c33f81a8ac138103f1a0e8b33c5", "html_url": "https://github.com/rust-lang/rust/commit/4f863a338e0a7c33f81a8ac138103f1a0e8b33c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f863a338e0a7c33f81a8ac138103f1a0e8b33c5/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d919d2302b5df42e3bf8979560e0da21f4b2bad", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d919d2302b5df42e3bf8979560e0da21f4b2bad", "html_url": "https://github.com/rust-lang/rust/commit/9d919d2302b5df42e3bf8979560e0da21f4b2bad"}], "stats": {"total": 2406, "additions": 1235, "deletions": 1171}, "files": [{"sha": "ec522ae9e5aed9a48a993cf15a55cf7f7401218c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1065, "deletions": 1011, "changes": 2076, "blob_url": "https://github.com/rust-lang/rust/blob/4f863a338e0a7c33f81a8ac138103f1a0e8b33c5/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f863a338e0a7c33f81a8ac138103f1a0e8b33c5/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=4f863a338e0a7c33f81a8ac138103f1a0e8b33c5", "patch": "@@ -96,1245 +96,1299 @@ use core::mem::size_of;\n use core::mem;\n use core::ops::{FnMut,SliceMut};\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n-use core::prelude::{Ord, Ordering, PtrExt, Some, range};\n+use core::prelude::{Ord, Ordering, RawPtr, Some, range, IteratorCloneExt, Result};\n use core::ptr;\n use core::slice as core_slice;\n use self::Direction::*;\n \n use vec::Vec;\n \n-pub use core::slice::{Chunks, AsSlice, SplitsN, Windows};\n+pub use core::slice::{Chunks, AsSlice, SplitN, Windows};\n pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n-pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n-pub use core::slice::{MutSplits, MutChunks, Splits};\n+pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n+pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n-pub use core::slice::{from_raw_buf, from_raw_mut_buf, BinarySearchResult};\n+pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n \n-// Functional utilities\n+////////////////////////////////////////////////////////////////////////////////\n+// Basic slice extension methods\n+////////////////////////////////////////////////////////////////////////////////\n \n-#[allow(missing_docs)]\n-pub trait VectorVector<T> for Sized? {\n-    // FIXME #5898: calling these .concat and .connect conflicts with\n-    // StrVector::con{cat,nect}, since they have generic contents.\n-    /// Flattens a vector of vectors of `T` into a single `Vec<T>`.\n-    fn concat_vec(&self) -> Vec<T>;\n+/// Allocating extension methods for slices.\n+#[unstable = \"needs associated types, may merge with other traits\"]\n+pub trait SliceExt<T> for Sized? {\n+    /// Sorts the slice, in place, using `compare` to compare\n+    /// elements.\n+    ///\n+    /// This sort is `O(n log n)` worst-case and stable, but allocates\n+    /// approximately `2 * n`, where `n` is the length of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [5i, 4, 1, 3, 2];\n+    /// v.sort_by(|a, b| a.cmp(b));\n+    /// assert!(v == [1, 2, 3, 4, 5]);\n+    ///\n+    /// // reverse sorting\n+    /// v.sort_by(|a, b| b.cmp(a));\n+    /// assert!(v == [5, 4, 3, 2, 1]);\n+    /// ```\n+    #[stable]\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n \n-    /// Concatenate a vector of vectors, placing a given separator between each.\n-    fn connect_vec(&self, sep: &T) -> Vec<T>;\n-}\n+    /// Consumes `src` and moves as many elements as it can into `self`\n+    /// from the range [start,end).\n+    ///\n+    /// Returns the number of elements copied (the shorter of `self.len()`\n+    /// and `end - start`).\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A mutable vector of `T`\n+    /// * start - The index into `src` to start copying from\n+    /// * end - The index into `src` to stop copying from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut a = [1i, 2, 3, 4, 5];\n+    /// let b = vec![6i, 7, 8];\n+    /// let num_moved = a.move_from(b, 0, 3);\n+    /// assert_eq!(num_moved, 3);\n+    /// assert!(a == [6i, 7, 8, 4, 5]);\n+    /// ```\n+    #[experimental = \"uncertain about this API approach\"]\n+    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n \n-impl<'a, T: Clone, V: AsSlice<T>> VectorVector<T> for [V] {\n-    fn concat_vec(&self) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = Vec::with_capacity(size);\n-        for v in self.iter() {\n-            result.push_all(v.as_slice())\n-        }\n-        result\n-    }\n+    /// Returns a subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice(&self, start: uint, end: uint) -> &[T];\n \n-    fn connect_vec(&self, sep: &T) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = Vec::with_capacity(size + self.len());\n-        let mut first = true;\n-        for v in self.iter() {\n-            if first { first = false } else { result.push(sep.clone()) }\n-            result.push_all(v.as_slice())\n-        }\n-        result\n-    }\n-}\n+    /// Returns a subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_from(&self, start: uint) -> &[T];\n \n-/// An iterator that yields the element swaps needed to produce\n-/// a sequence of all possible permutations for an indexed sequence of\n-/// elements. Each permutation is only a single swap apart.\n-///\n-/// The Steinhaus-Johnson-Trotter algorithm is used.\n-///\n-/// Generates even and odd permutations alternately.\n-///\n-/// The last generated swap is always (0, 1), and it returns the\n-/// sequence to its initial order.\n-pub struct ElementSwaps {\n-    sdir: Vec<SizeDirection>,\n-    /// If `true`, emit the last swap that returns the sequence to initial\n-    /// state.\n-    emit_reset: bool,\n-    swaps_made : uint,\n-}\n+    /// Returns a subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_to(&self, end: uint) -> &[T];\n \n-impl ElementSwaps {\n-    /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    pub fn new(length: uint) -> ElementSwaps {\n-        // Initialize `sdir` with a direction that position should move in\n-        // (all negative at the beginning) and the `size` of the\n-        // element (equal to the original index).\n-        ElementSwaps{\n-            emit_reset: true,\n-            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n-            swaps_made: 0\n-        }\n-    }\n-}\n+    /// Divides one slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Panics if `mid > len`.\n+    #[stable]\n+    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n \n-#[deriving(Copy)]\n-enum Direction { Pos, Neg }\n+    /// Returns an iterator over the slice\n+    #[stable]\n+    fn iter(&self) -> Iter<T>;\n \n-/// An `Index` and `Direction` together.\n-#[deriving(Copy)]\n-struct SizeDirection {\n-    size: uint,\n-    dir: Direction,\n-}\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`.  The matched element is not contained in the subslices.\n+    #[stable]\n+    fn split<F>(&self, pred: F) -> Split<T, F>\n+                where F: FnMut(&T) -> bool;\n \n-impl Iterator<(uint, uint)> for ElementSwaps {\n-    #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n-        fn new_pos(i: uint, s: Direction) -> uint {\n-            i + match s { Pos => 1, Neg => -1 }\n-        }\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[stable]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n+                 where F: FnMut(&T) -> bool;\n \n-        // Find the index of the largest mobile element:\n-        // The direction should point into the vector, and the\n-        // swap should be with a smaller `size` element.\n-        let max = self.sdir.iter().map(|&x| x).enumerate()\n-                           .filter(|&(i, sd)|\n-                                new_pos(i, sd.dir) < self.sdir.len() &&\n-                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n-                           .max_by(|&(_, sd)| sd.size);\n-        match max {\n-            Some((i, sd)) => {\n-                let j = new_pos(i, sd.dir);\n-                self.sdir.swap(i, j);\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[stable]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n+                  where F: FnMut(&T) -> bool;\n \n-                // Swap the direction of each larger SizeDirection\n-                for x in self.sdir.iter_mut() {\n-                    if x.size > sd.size {\n-                        x.dir = match x.dir { Pos => Neg, Neg => Pos };\n-                    }\n-                }\n-                self.swaps_made += 1;\n-                Some((i, j))\n-            },\n-            None => if self.emit_reset {\n-                self.emit_reset = false;\n-                if self.sdir.len() > 1 {\n-                    // The last swap\n-                    self.swaps_made += 1;\n-                    Some((0, 1))\n-                } else {\n-                    // Vector is of the form [] or [x], and the only permutation is itself\n-                    self.swaps_made += 1;\n-                    Some((0,0))\n-                }\n-            } else { None }\n-        }\n-    }\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n+    /// `[3,4]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4];\n+    /// for win in v.windows(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[stable]\n+    fn windows(&self, size: uint) -> Windows<T>;\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        // For a vector of size n, there are exactly n! permutations.\n-        let n = range(2, self.sdir.len() + 1).product();\n-        (n - self.swaps_made, Some(n - self.swaps_made))\n-    }\n-}\n+    /// Returns an iterator over `size` elements of the slice at a\n+    /// time. The chunks do not overlap. If `size` does not divide the\n+    /// length of the slice, then the last chunk will not have length\n+    /// `size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the slice two elements at a time (i.e. `[1,2]`,\n+    /// `[3,4]`, `[5]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4, 5];\n+    /// for win in v.chunks(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[stable]\n+    fn chunks(&self, size: uint) -> Chunks<T>;\n \n-/// An iterator that uses `ElementSwaps` to iterate through\n-/// all possible permutations of a vector.\n-///\n-/// The first iteration yields a clone of the vector as it is,\n-/// then each successive element is the vector with one\n-/// swap applied.\n-///\n-/// Generates even and odd permutations alternately.\n-pub struct Permutations<T> {\n-    swaps: ElementSwaps,\n-    v: Vec<T>,\n-}\n+    /// Returns the element of a slice at the given index, or `None` if the\n+    /// index is out of bounds.\n+    #[stable]\n+    fn get(&self, index: uint) -> Option<&T>;\n \n-impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<Vec<T>> {\n-        match self.swaps.next() {\n-            None => None,\n-            Some((0,0)) => Some(self.v.clone()),\n-            Some((a, b)) => {\n-                let elt = self.v.clone();\n-                self.v.swap(a, b);\n-                Some(elt)\n-            }\n-        }\n-    }\n+    /// Returns the first element of a slice, or `None` if it is empty.\n+    #[stable]\n+    fn first(&self) -> Option<&T>;\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.swaps.size_hint()\n-    }\n-}\n+    /// Deprecated: renamed to `first`.\n+    #[deprecated = \"renamed to `first`\"]\n+    fn head(&self) -> Option<&T> { self.first() }\n \n-/// Extension methods for boxed slices.\n-pub trait BoxedSliceExt<T> {\n-    /// Convert `self` into a vector without clones or allocation.\n-    fn into_vec(self) -> Vec<T>;\n-}\n+    /// Returns all but the first element of a slice.\n+    #[experimental = \"likely to be renamed\"]\n+    fn tail(&self) -> &[T];\n+\n+    /// Returns all but the last element of a slice.\n+    #[experimental = \"likely to be renamed\"]\n+    fn init(&self) -> &[T];\n+\n+    /// Returns the last element of a slice, or `None` if it is empty.\n+    #[stable]\n+    fn last(&self) -> Option<&T>;\n \n-impl<T> BoxedSliceExt<T> for Box<[T]> {\n-    #[experimental]\n-    fn into_vec(mut self) -> Vec<T> {\n-        unsafe {\n-            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n-            mem::forget(self);\n-            xs\n-        }\n-    }\n-}\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[stable]\n+    unsafe fn get_unchecked(&self, index: uint) -> &T;\n \n-/// Allocating extension methods for slices containing `Clone` elements.\n-pub trait CloneSliceExt<T> for Sized? {\n-    /// Copies `self` into a new `Vec`.\n-    fn to_vec(&self) -> Vec<T>;\n+    /// Deprecated: renamed to `get_unchecked`.\n+    #[deprecated = \"renamed to get_unchecked\"]\n+    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+        self.get_unchecked(index)\n+    }\n \n-    /// Partitions the vector into two vectors `(a, b)`, where all\n-    /// elements of `a` satisfy `f` and all elements of `b` do not.\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n+    /// Returns an unsafe pointer to the slice's buffer\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[stable]\n+    fn as_ptr(&self) -> *const T;\n \n-    /// Creates an iterator that yields every possible permutation of the\n-    /// vector in succession.\n+    /// Binary search a sorted slice with a comparator function.\n     ///\n-    /// # Examples\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying slice, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n     ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n+    /// If a matching value is found then returns `Ok`, containing\n+    /// the index for the matched element; if no match is found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n     ///\n-    /// for p in perms {\n-    ///   println!(\"{}\", p);\n-    /// }\n-    /// ```\n+    /// # Example\n     ///\n-    /// Iterating through permutations one by one.\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n     ///\n     /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n     ///\n-    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n+    /// let seek = 13;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n+    /// let seek = 4;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n+    /// let seek = 100;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n+    /// let seek = 1;\n+    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    fn permutations(&self) -> Permutations<T>;\n+    #[stable]\n+    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+        F: FnMut(&T) -> Ordering;\n \n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n+    /// Return the number of elements in the slice\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n+    /// ```\n+    /// let a = [1i, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[stable]\n+    fn len(&self) -> uint;\n+\n+    /// Returns true if the slice has a length of 0\n     ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n+    /// # Example\n     ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    fn clone_from_slice(&mut self, &[T]) -> uint;\n-}\n-\n-impl<T: Clone> CloneSliceExt<T> for [T] {\n-    /// Returns a copy of `v`.\n+    /// let a = [1i, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n     #[inline]\n-    fn to_vec(&self) -> Vec<T> {\n-        let mut vector = Vec::with_capacity(self.len());\n-        vector.push_all(self);\n-        vector\n-    }\n+    #[stable]\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n+    /// Returns a mutable reference to the element at the given index,\n+    /// or `None` if the index is out of bounds\n+    #[stable]\n+    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n \n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    #[stable]\n+    fn as_mut_slice(&mut self) -> &mut [T];\n \n-    #[inline]\n-    fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        let mut lefts  = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.iter() {\n-            if f(elt) {\n-                lefts.push((*elt).clone());\n-            } else {\n-                rights.push((*elt).clone());\n-            }\n-        }\n+    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n \n-        (lefts, rights)\n-    }\n+    /// Returns a mutable subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n \n-    /// Returns an iterator over all permutations of a vector.\n-    fn permutations(&self) -> Permutations<T> {\n-        Permutations{\n-            swaps: ElementSwaps::new(self.len()),\n-            v: self.to_vec(),\n-        }\n-    }\n+    /// Returns a mutable subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n \n-    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n-        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    /// Returns an iterator that allows modifying each value\n+    #[stable]\n+    fn iter_mut(&mut self) -> IterMut<T>;\n+\n+    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n+    #[stable]\n+    fn first_mut(&mut self) -> Option<&mut T>;\n+\n+    /// Depreated: renamed to `first_mut`.\n+    #[deprecated = \"renamed to first_mut\"]\n+    fn head_mut(&mut self) -> Option<&mut T> {\n+        self.first_mut()\n     }\n-}\n \n-fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n-    let len = v.len() as int;\n-    let buf_v = v.as_mut_ptr();\n+    /// Returns all but the first element of a mutable slice\n+    #[experimental = \"likely to be renamed or removed\"]\n+    fn tail_mut(&mut self) -> &mut [T];\n \n-    // 1 <= i < len;\n-    for i in range(1, len) {\n-        // j satisfies: 0 <= j <= i;\n-        let mut j = i;\n-        unsafe {\n-            // `i` is in bounds.\n-            let read_ptr = buf_v.offset(i) as *const T;\n+    /// Returns all but the last element of a mutable slice\n+    #[experimental = \"likely to be renamed or removed\"]\n+    fn init_mut(&mut self) -> &mut [T];\n \n-            // find where to insert, we need to do strict <,\n-            // rather than <=, to maintain stability.\n+    /// Returns a mutable pointer to the last item in the slice.\n+    #[stable]\n+    fn last_mut(&mut self) -> Option<&mut T>;\n \n-            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n-            while j > 0 &&\n-                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n-                j -= 1;\n-            }\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`.  The matched element is not contained in the subslices.\n+    #[stable]\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+                    where F: FnMut(&T) -> bool;\n \n-            // shift everything to the right, to make space to\n-            // insert this value.\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[stable]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n+                     where F: FnMut(&T) -> bool;\n \n-            // j + 1 could be `len` (for the last `i`), but in\n-            // that case, `i == j` so we don't copy. The\n-            // `.offset(j)` is always in bounds.\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[stable]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n+                      where F: FnMut(&T) -> bool;\n \n-            if i != j {\n-                let tmp = ptr::read(read_ptr);\n-                ptr::copy_memory(buf_v.offset(j + 1),\n-                                 &*buf_v.offset(j),\n-                                 (i - j) as uint);\n-                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n-                                                &tmp as *const T,\n-                                                1);\n-                mem::forget(tmp);\n-            }\n-        }\n-    }\n-}\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    #[stable]\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T>;\n \n-fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n-    // warning: this wildly uses unsafe.\n-    static BASE_INSERTION: uint = 32;\n-    static LARGE_INSERTION: uint = 16;\n+    /// Swaps two elements in a slice.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `a` or `b` are out of bounds.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    #[stable]\n+    fn swap(&mut self, a: uint, b: uint);\n+\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.split_at_mut(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(2);\n+    ///     assert!(left == [1i, 2]);\n+    ///     assert!(right == [3i, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(6);\n+    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[stable]\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n \n-    // FIXME #12092: smaller insertion runs seems to make sorting\n-    // vectors of large elements a little faster on some platforms,\n-    // but hasn't been tested/tuned extensively\n-    let insertion = if size_of::<T>() <= 16 {\n-        BASE_INSERTION\n-    } else {\n-        LARGE_INSERTION\n-    };\n+    /// Reverse the order of elements in a slice, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3i, 2, 1]);\n+    /// ```\n+    #[stable]\n+    fn reverse(&mut self);\n \n-    let len = v.len();\n+    /// Returns an unsafe mutable pointer to the element in index\n+    #[stable]\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T;\n \n-    // short vectors get sorted in-place via insertion sort to avoid allocations\n-    if len <= insertion {\n-        insertion_sort(v, compare);\n-        return;\n+    /// Deprecated: renamed to `get_unchecked_mut`.\n+    #[deprecated = \"renamed to get_unchecked_mut\"]\n+    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut T {\n+        self.get_unchecked_mut(index)\n     }\n \n-    // allocate some memory to use as scratch memory, we keep the\n-    // length 0 so we can keep shallow copies of the contents of `v`\n-    // without risking the dtors running on an object twice if\n-    // `compare` panics.\n-    let mut working_space = Vec::with_capacity(2 * len);\n-    // these both are buffers of length `len`.\n-    let mut buf_dat = working_space.as_mut_ptr();\n-    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n-\n-    // length `len`.\n-    let buf_v = v.as_ptr();\n-\n-    // step 1. sort short runs with insertion sort. This takes the\n-    // values from `v` and sorts them into `buf_dat`, leaving that\n-    // with sorted runs of length INSERTION.\n+    /// Return an unsafe mutable pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    #[stable]\n+    fn as_mut_ptr(&mut self) -> *mut T;\n+}\n \n-    // We could hardcode the sorting comparisons here, and we could\n-    // manipulate/step the pointers themselves, rather than repeatedly\n-    // .offset-ing.\n-    for start in range_step(0, len, insertion) {\n-        // start <= i < len;\n-        for i in range(start, cmp::min(start + insertion, len)) {\n-            // j satisfies: start <= j <= i;\n-            let mut j = i as int;\n-            unsafe {\n-                // `i` is in bounds.\n-                let read_ptr = buf_v.offset(i as int);\n+#[unstable = \"trait is unstable\"]\n+impl<T> SliceExt<T> for [T] {\n+    #[inline]\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n+        merge_sort(self, compare)\n+    }\n \n-                // find where to insert, we need to do strict <,\n-                // rather than <=, to maintain stability.\n+    #[inline]\n+    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n+        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n+            mem::swap(a, b);\n+        }\n+        cmp::min(self.len(), end-start)\n+    }\n \n-                // start <= j - 1 < len, so .offset(j - 1) is in\n-                // bounds.\n-                while j > start as int &&\n-                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n-                    j -= 1;\n-                }\n+    #[inline]\n+    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice(self, start, end)\n+    }\n \n-                // shift everything to the right, to make space to\n-                // insert this value.\n+    #[inline]\n+    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_from(self, start)\n+    }\n \n-                // j + 1 could be `len` (for the last `i`), but in\n-                // that case, `i == j` so we don't copy. The\n-                // `.offset(j)` is always in bounds.\n-                ptr::copy_memory(buf_dat.offset(j + 1),\n-                                 &*buf_dat.offset(j),\n-                                 i - j as uint);\n-                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n-            }\n-        }\n+    #[inline]\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_to(self, end)\n     }\n \n-    // step 2. merge the sorted runs.\n-    let mut width = insertion;\n-    while width < len {\n-        // merge the sorted runs of length `width` in `buf_dat` two at\n-        // a time, placing the result in `buf_tmp`.\n+    #[inline]\n+    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n+        core_slice::SliceExt::split_at(self, mid)\n+    }\n \n-        // 0 <= start <= len.\n-        for start in range_step(0, len, 2 * width) {\n-            // manipulate pointers directly for speed (rather than\n-            // using a `for` loop with `range` and `.offset` inside\n-            // that loop).\n-            unsafe {\n-                // the end of the first run & start of the\n-                // second. Offset of `len` is defined, since this is\n-                // precisely one byte past the end of the object.\n-                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n-                // end of the second. Similar reasoning to the above re safety.\n-                let right_end_idx = cmp::min(start + 2 * width, len);\n-                let right_end = buf_dat.offset(right_end_idx as int);\n+    #[inline]\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        core_slice::SliceExt::iter(self)\n+    }\n \n-                // the pointers to the elements under consideration\n-                // from the two runs.\n+    #[inline]\n+    fn split<F>(&self, pred: F) -> Split<T, F>\n+                where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split(self, pred)\n+    }\n \n-                // both of these are in bounds.\n-                let mut left = buf_dat.offset(start as int);\n-                let mut right = right_start;\n+    #[inline]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n+                 where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn(self, n, pred)\n+    }\n \n-                // where we're putting the results, it is a run of\n-                // length `2*width`, so we step it once for each step\n-                // of either `left` or `right`.  `buf_tmp` has length\n-                // `len`, so these are in bounds.\n-                let mut out = buf_tmp.offset(start as int);\n-                let out_end = buf_tmp.offset(right_end_idx as int);\n+    #[inline]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n+                  where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn(self, n, pred)\n+    }\n \n-                while out < out_end {\n-                    // Either the left or the right run are exhausted,\n-                    // so just copy the remainder from the other run\n-                    // and move on; this gives a huge speed-up (order\n-                    // of 25%) for mostly sorted vectors (the best\n-                    // case).\n-                    if left == right_start {\n-                        // the number remaining in this run.\n-                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n-                        break;\n-                    } else if right == right_end {\n-                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n-                        break;\n-                    }\n+    #[inline]\n+    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n+        core_slice::SliceExt::windows(self, size)\n+    }\n \n-                    // check which side is smaller, and that's the\n-                    // next element for the new run.\n+    #[inline]\n+    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n+        core_slice::SliceExt::chunks(self, size)\n+    }\n \n-                    // `left < right_start` and `right < right_end`,\n-                    // so these are valid.\n-                    let to_copy = if compare(&*left, &*right) == Greater {\n-                        step(&mut right)\n-                    } else {\n-                        step(&mut left)\n-                    };\n-                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n-                    step(&mut out);\n-                }\n-            }\n-        }\n+    #[inline]\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n+        core_slice::SliceExt::get(self, index)\n+    }\n \n-        mem::swap(&mut buf_dat, &mut buf_tmp);\n+    #[inline]\n+    fn first<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::first(self)\n+    }\n \n-        width *= 2;\n+    #[inline]\n+    fn tail<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::tail(self)\n     }\n \n-    // write the result to `v` in one go, so that there are never two copies\n-    // of the same object in `v`.\n-    unsafe {\n-        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n+    #[inline]\n+    fn init<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::init(self)\n     }\n \n-    // increment the pointer, returning the old pointer.\n-    #[inline(always)]\n-    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n-        let old = *ptr;\n-        *ptr = ptr.offset(1);\n-        old\n+    #[inline]\n+    fn last<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::last(self)\n     }\n-}\n \n-/// Allocating extension methods for slices on Ord values.\n-#[experimental = \"likely to merge with other traits\"]\n-pub trait OrdSliceExt<T> for Sized? {\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [-5i, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5i, -3, 1, 2, 4]);\n-    /// ```\n-    #[experimental]\n-    fn sort(&mut self);\n+    #[inline]\n+    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T {\n+        core_slice::SliceExt::get_unchecked(self, index)\n+    }\n \n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Found` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `NotFound` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// use std::slice::BinarySearchResult::{Found, NotFound};\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// assert_eq!(s.binary_search_elem(&13),  Found(9));\n-    /// assert_eq!(s.binary_search_elem(&4),   NotFound(7));\n-    /// assert_eq!(s.binary_search_elem(&100), NotFound(13));\n-    /// let r = s.binary_search_elem(&1);\n-    /// assert!(match r { Found(1...4) => true, _ => false, });\n-    /// ```\n-    #[unstable = \"name likely to change\"]\n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n+    #[inline]\n+    fn as_ptr(&self) -> *const T {\n+        core_slice::SliceExt::as_ptr(self)\n+    }\n \n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[experimental]\n-    fn next_permutation(&mut self) -> bool;\n+    #[inline]\n+    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint>\n+                        where F: FnMut(&T) -> Ordering {\n+        core_slice::SliceExt::binary_search_by(self, f)\n+    }\n \n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[experimental]\n-    fn prev_permutation(&mut self) -> bool;\n-}\n+    #[inline]\n+    fn len(&self) -> uint {\n+        core_slice::SliceExt::len(self)\n+    }\n \n-impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[inline]\n-    fn sort(&mut self) {\n-        self.sort_by(|a, b| a.cmp(b))\n+    fn is_empty(&self) -> bool {\n+        core_slice::SliceExt::is_empty(self)\n     }\n \n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n-        core_slice::OrdSliceExt::binary_search_elem(self, x)\n+    #[inline]\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n+        core_slice::SliceExt::get_mut(self, index)\n     }\n \n-    fn next_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::next_permutation(self)\n+    #[inline]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::as_mut_slice(self)\n     }\n \n-    fn prev_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::prev_permutation(self)\n+    #[inline]\n+    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_mut(self, start, end)\n     }\n-}\n \n-/// Allocating extension methods for slices.\n-#[experimental = \"likely to merge with other traits\"]\n-pub trait SliceExt<T> for Sized? {\n-    /// Sorts the slice, in place, using `compare` to compare\n-    /// elements.\n-    ///\n-    /// This sort is `O(n log n)` worst-case and stable, but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [5i, 4, 1, 3, 2];\n-    /// v.sort_by(|a, b| a.cmp(b));\n-    /// assert!(v == [1, 2, 3, 4, 5]);\n-    ///\n-    /// // reverse sorting\n-    /// v.sort_by(|a, b| b.cmp(a));\n-    /// assert!(v == [5, 4, 3, 2, 1]);\n-    /// ```\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n+    #[inline]\n+    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_from_mut(self, start)\n+    }\n \n-    /// Consumes `src` and moves as many elements as it can into `self`\n-    /// from the range [start,end).\n-    ///\n-    /// Returns the number of elements copied (the shorter of `self.len()`\n-    /// and `end - start`).\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A mutable vector of `T`\n-    /// * start - The index into `src` to start copying from\n-    /// * end - The index into `src` to stop copying from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut a = [1i, 2, 3, 4, 5];\n-    /// let b = vec![6i, 7, 8];\n-    /// let num_moved = a.move_from(b, 0, 3);\n-    /// assert_eq!(num_moved, 3);\n-    /// assert!(a == [6i, 7, 8, 4, 5]);\n-    /// ```\n-    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n+    #[inline]\n+    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_to_mut(self, end)\n+    }\n \n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice(&self, start: uint, end: uint) -> &[T];\n+    #[inline]\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+        core_slice::SliceExt::iter_mut(self)\n+    }\n \n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice_from(&self, start: uint) -> &[T];\n+    #[inline]\n+    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::first_mut(self)\n+    }\n \n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice_to(&self, end: uint) -> &[T];\n+    #[inline]\n+    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::tail_mut(self)\n+    }\n \n-    /// Divides one slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Panics if `mid > len`.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n+    #[inline]\n+    fn init_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::init_mut(self)\n+    }\n \n-    /// Returns an iterator over the slice\n-    #[unstable = \"iterator type may change\"]\n-    fn iter(&self) -> Iter<T>;\n+    #[inline]\n+    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::last_mut(self)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`.  The matched element is not contained in the subslices.\n-    #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n-    fn split<F>(&self, pred: F) -> Splits<T, F>\n-                where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+                    where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split_mut(self, pred)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    #[unstable = \"iterator type may change\"]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                 where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n+                     where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn_mut(self, n, pred)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    #[unstable = \"iterator type may change\"]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                  where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n+                      where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n+    }\n \n-    /// Returns an iterator over all contiguous windows of length\n-    /// `size`. The windows overlap. If the slice is shorter than\n-    /// `size`, the iterator returns no values.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Example\n-    ///\n-    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n-    /// `[3,4]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1i, 2, 3, 4];\n-    /// for win in v.windows(2) {\n-    ///     println!(\"{}\", win);\n-    /// }\n-    /// ```\n-    #[unstable = \"iterator type may change\"]\n-    fn windows(&self, size: uint) -> Windows<T>;\n+    #[inline]\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T> {\n+        core_slice::SliceExt::chunks_mut(self, chunk_size)\n+    }\n \n-    /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks do not overlap. If `size` does not divide the\n-    /// length of the slice, then the last chunk will not have length\n-    /// `size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Example\n-    ///\n-    /// Print the slice two elements at a time (i.e. `[1,2]`,\n-    /// `[3,4]`, `[5]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1i, 2, 3, 4, 5];\n-    /// for win in v.chunks(2) {\n-    ///     println!(\"{}\", win);\n-    /// }\n-    /// ```\n-    #[unstable = \"iterator type may change\"]\n-    fn chunks(&self, size: uint) -> Chunks<T>;\n+    #[inline]\n+    fn swap(&mut self, a: uint, b: uint) {\n+        core_slice::SliceExt::swap(self, a, b)\n+    }\n \n-    /// Returns the element of a slice at the given index, or `None` if the\n-    /// index is out of bounds.\n-    #[unstable = \"waiting on final collection conventions\"]\n-    fn get(&self, index: uint) -> Option<&T>;\n+    #[inline]\n+    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+        core_slice::SliceExt::split_at_mut(self, mid)\n+    }\n \n-    /// Returns the first element of a slice, or `None` if it is empty.\n-    #[unstable = \"name may change\"]\n-    fn head(&self) -> Option<&T>;\n+    #[inline]\n+    fn reverse(&mut self) {\n+        core_slice::SliceExt::reverse(self)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+        core_slice::SliceExt::get_unchecked_mut(self, index)\n+    }\n+\n+    #[inline]\n+    fn as_mut_ptr(&mut self) -> *mut T {\n+        core_slice::SliceExt::as_mut_ptr(self)\n+    }\n+}\n \n-    /// Returns all but the first element of a slice.\n-    #[unstable = \"name may change\"]\n-    fn tail(&self) -> &[T];\n+////////////////////////////////////////////////////////////////////////////////\n+// Extension traits for slices over specifc kinds of data\n+////////////////////////////////////////////////////////////////////////////////\n \n-    /// Returns all but the last element of a slice.\n-    #[unstable = \"name may change\"]\n-    fn init(&self) -> &[T];\n+/// Extension methods for boxed slices.\n+#[experimental = \"likely to merge into SliceExt if it survives\"]\n+pub trait BoxedSliceExt<T> {\n+    /// Convert `self` into a vector without clones or allocation.\n+    #[experimental]\n+    fn into_vec(self) -> Vec<T>;\n+}\n \n-    /// Returns the last element of a slice, or `None` if it is empty.\n-    #[unstable = \"name may change\"]\n-    fn last(&self) -> Option<&T>;\n+#[experimental = \"trait is experimental\"]\n+impl<T> BoxedSliceExt<T> for Box<[T]> {\n+    fn into_vec(mut self) -> Vec<T> {\n+        unsafe {\n+            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n+            mem::forget(self);\n+            xs\n+        }\n+    }\n+}\n \n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    #[unstable]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T;\n+/// Allocating extension methods for slices containing `Clone` elements.\n+#[unstable = \"likely to be merged into SliceExt\"]\n+pub trait CloneSliceExt<T> for Sized? {\n+    /// Copies `self` into a new `Vec`.\n+    #[stable]\n+    fn to_vec(&self) -> Vec<T>;\n \n-    /// Returns an unsafe pointer to the slice's buffer\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[unstable]\n-    fn as_ptr(&self) -> *const T;\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n \n-    /// Binary search a sorted slice with a comparator function.\n+    /// Creates an iterator that yields every possible permutation of the\n+    /// vector in succession.\n     ///\n-    /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying slice, returning an\n-    /// order code that indicates whether its argument is `Less`,\n-    /// `Equal` or `Greater` the desired target.\n+    /// # Examples\n     ///\n-    /// If a matching value is found then returns `Found`, containing\n-    /// the index for the matched element; if no match is found then\n-    /// `NotFound` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n+    /// ```rust\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n     ///\n-    /// # Example\n+    /// for p in perms {\n+    ///   println!(\"{}\", p);\n+    /// }\n+    /// ```\n     ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n+    /// Iterating through permutations one by one.\n     ///\n     /// ```rust\n-    /// use std::slice::BinarySearchResult::{Found, NotFound};\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n     ///\n-    /// let seek = 13;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), Found(9));\n-    /// let seek = 4;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(7));\n-    /// let seek = 100;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(13));\n-    /// let seek = 1;\n-    /// let r = s.binary_search(|probe| probe.cmp(&seek));\n-    /// assert!(match r { Found(1...4) => true, _ => false, });\n+    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n+    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n+    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n-    #[unstable = \"waiting on unboxed closures\"]\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n-                        where F: FnMut(&T) -> Ordering;\n+    #[stable]\n+    fn permutations(&self) -> Permutations<T>;\n \n-    /// Return the number of elements in the slice\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n     ///\n     /// # Example\n     ///\n-    /// ```\n-    /// let a = [1i, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n-    /// ```\n-    #[experimental = \"not triaged yet\"]\n-    fn len(&self) -> uint;\n-\n-    /// Returns true if the slice has a length of 0\n+    /// ```rust\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n     ///\n-    /// # Example\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n     ///\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    /// let a = [1i, 2, 3];\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[experimental = \"not triaged yet\"]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n-    /// Returns a mutable reference to the element at the given index,\n-    /// or `None` if the index is out of bounds\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n-\n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    fn as_mut_slice(&mut self) -> &mut [T];\n-\n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n-\n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n-\n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n-\n-    /// Returns an iterator that allows modifying each value\n-    #[unstable = \"waiting on iterator type name conventions\"]\n-    fn iter_mut(&mut self) -> IterMut<T>;\n-\n-    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n-    #[unstable = \"name may change\"]\n-    fn head_mut(&mut self) -> Option<&mut T>;\n-\n-    /// Returns all but the first element of a mutable slice\n-    #[unstable = \"name may change\"]\n-    fn tail_mut(&mut self) -> &mut [T];\n+    #[experimental]\n+    fn clone_from_slice(&mut self, &[T]) -> uint;\n+}\n \n-    /// Returns all but the last element of a mutable slice\n-    #[unstable = \"name may change\"]\n-    fn init_mut(&mut self) -> &mut [T];\n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> CloneSliceExt<T> for [T] {\n+    /// Returns a copy of `v`.\n+    #[inline]\n+    fn to_vec(&self) -> Vec<T> {\n+        let mut vector = Vec::with_capacity(self.len());\n+        vector.push_all(self);\n+        vector\n+    }\n \n-    /// Returns a mutable pointer to the last item in the slice.\n-    #[unstable = \"name may change\"]\n-    fn last_mut(&mut self) -> Option<&mut T>;\n \n-    /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`.  The matched element is not contained in the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n-                    where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.iter().cloned().partition(f)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                     where F: FnMut(&T) -> bool;\n+    /// Returns an iterator over all permutations of a vector.\n+    fn permutations(&self) -> Permutations<T> {\n+        Permutations{\n+            swaps: ElementSwaps::new(self.len()),\n+            v: self.to_vec(),\n+        }\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                      where F: FnMut(&T) -> bool;\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n+        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    }\n+}\n \n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will not\n-    /// have length `chunk_size`.\n+/// Allocating extension methods for slices on Ord values.\n+#[unstable = \"likely to merge with SliceExt\"]\n+pub trait OrdSliceExt<T> for Sized? {\n+    /// Sorts the slice, in place.\n     ///\n-    /// # Panics\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n     ///\n-    /// Panics if `chunk_size` is 0.\n-    #[unstable = \"waiting on iterator type name conventions\"]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> MutChunks<T>;\n-\n-    /// Swaps two elements in a slice.\n+    /// # Examples\n     ///\n-    /// Panics if `a` or `b` are out of bounds.\n+    /// ```rust\n+    /// let mut v = [-5i, 4, 1, -3, 2];\n     ///\n-    /// # Arguments\n+    /// v.sort();\n+    /// assert!(v == [-5i, -3, 1, 2, 4]);\n+    /// ```\n+    #[stable]\n+    fn sort(&mut self);\n+\n+    /// Binary search a sorted slice for a given element.\n     ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n     ///\n     /// # Example\n     ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n     /// ```rust\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn swap(&mut self, a: uint, b: uint);\n+    #[stable]\n+    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n \n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    /// Deprecated: use `binary_search` instead.\n+    #[deprecated = \"use binary_search instead\"]\n+    fn binary_search_elem(&self, x: &T) -> Result<uint, uint> {\n+        self.binary_search(x)\n+    }\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n     ///\n-    /// Panics if `mid > len`.\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1i, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.split_at_mut(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1i, 2]);\n-    ///     assert!(right == [3i, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n-    /// }\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n     /// ```\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n+    #[stable]\n+    fn next_permutation(&mut self) -> bool;\n \n-    /// Reverse the order of elements in a slice, in place.\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1i, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3i, 2, 1]);\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n     /// ```\n-    #[experimental = \"may be moved to iterators instead\"]\n-    fn reverse(&mut self);\n-\n-    /// Returns an unsafe mutable pointer to the element in index\n-    #[experimental = \"waiting on unsafe conventions\"]\n-    unsafe fn unsafe_mut(&mut self, index: uint) -> &mut T;\n-\n-    /// Return an unsafe mutable pointer to the slice's buffer.\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[inline]\n-    #[unstable]\n-    fn as_mut_ptr(&mut self) -> *mut T;\n+    #[stable]\n+    fn prev_permutation(&mut self) -> bool;\n }\n \n-impl<T> SliceExt<T> for [T] {\n+#[unstable = \"trait is unstable\"]\n+impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[inline]\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n-        merge_sort(self, compare)\n+    fn sort(&mut self) {\n+        self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    #[inline]\n-    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n-            mem::swap(a, b);\n-        }\n-        cmp::min(self.len(), end-start)\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+        core_slice::OrdSliceExt::binary_search(self, x)\n     }\n \n-    #[inline]\n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice(self, start, end)\n+    fn next_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::next_permutation(self)\n     }\n \n-    #[inline]\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_from(self, start)\n+    fn prev_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::prev_permutation(self)\n     }\n+}\n \n-    #[inline]\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_to(self, end)\n-    }\n+#[allow(missing_docs)]\n+pub trait VectorVector<T> for Sized? {\n+    // FIXME #5898: calling these .concat and .connect conflicts with\n+    // StrVector::con{cat,nect}, since they have generic contents.\n+    /// Flattens a vector of vectors of `T` into a single `Vec<T>`.\n+    fn concat_vec(&self) -> Vec<T>;\n \n-    #[inline]\n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n-        core_slice::SliceExt::split_at(self, mid)\n-    }\n+    /// Concatenate a vector of vectors, placing a given separator between each.\n+    fn connect_vec(&self, sep: &T) -> Vec<T>;\n+}\n \n-    #[inline]\n-    fn iter<'a>(&'a self) -> Iter<'a, T> {\n-        core_slice::SliceExt::iter(self)\n+impl<'a, T: Clone, V: AsSlice<T>> VectorVector<T> for [V] {\n+    fn concat_vec(&self) -> Vec<T> {\n+        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let mut result = Vec::with_capacity(size);\n+        for v in self.iter() {\n+            result.push_all(v.as_slice())\n+        }\n+        result\n     }\n \n-    #[inline]\n-    fn split<F>(&self, pred: F) -> Splits<T, F>\n-                where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::split(self, pred)\n+    fn connect_vec(&self, sep: &T) -> Vec<T> {\n+        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let mut result = Vec::with_capacity(size + self.len());\n+        let mut first = true;\n+        for v in self.iter() {\n+            if first { first = false } else { result.push(sep.clone()) }\n+            result.push_all(v.as_slice())\n+        }\n+        result\n     }\n+}\n \n-    #[inline]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                 where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::splitn(self, n, pred)\n-    }\n+/// An iterator that yields the element swaps needed to produce\n+/// a sequence of all possible permutations for an indexed sequence of\n+/// elements. Each permutation is only a single swap apart.\n+///\n+/// The Steinhaus-Johnson-Trotter algorithm is used.\n+///\n+/// Generates even and odd permutations alternately.\n+///\n+/// The last generated swap is always (0, 1), and it returns the\n+/// sequence to its initial order.\n+#[experimental]\n+pub struct ElementSwaps {\n+    sdir: Vec<SizeDirection>,\n+    /// If `true`, emit the last swap that returns the sequence to initial\n+    /// state.\n+    emit_reset: bool,\n+    swaps_made : uint,\n+}\n \n-    #[inline]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                  where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::rsplitn(self, n, pred)\n+impl ElementSwaps {\n+    /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n+    #[experimental]\n+    pub fn new(length: uint) -> ElementSwaps {\n+        // Initialize `sdir` with a direction that position should move in\n+        // (all negative at the beginning) and the `size` of the\n+        // element (equal to the original index).\n+        ElementSwaps{\n+            emit_reset: true,\n+            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n+            swaps_made: 0\n+        }\n     }\n+}\n \n-    #[inline]\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n-        core_slice::SliceExt::windows(self, size)\n-    }\n+////////////////////////////////////////////////////////////////////////////////\n+// Standard trait implementations for slices\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFrom<Vec<T>> for [T] {\n+    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n+}\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFromMut<Vec<T>> for [T] {\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.as_mut_slice_() }\n+}\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> ToOwned<Vec<T>> for [T] {\n+    fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Iterators\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[deriving(Copy)]\n+enum Direction { Pos, Neg }\n+\n+/// An `Index` and `Direction` together.\n+#[deriving(Copy)]\n+struct SizeDirection {\n+    size: uint,\n+    dir: Direction,\n+}\n \n+impl Iterator<(uint, uint)> for ElementSwaps {\n     #[inline]\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n-        core_slice::SliceExt::chunks(self, size)\n+    fn next(&mut self) -> Option<(uint, uint)> {\n+        fn new_pos(i: uint, s: Direction) -> uint {\n+            i + match s { Pos => 1, Neg => -1 }\n+        }\n+\n+        // Find the index of the largest mobile element:\n+        // The direction should point into the vector, and the\n+        // swap should be with a smaller `size` element.\n+        let max = self.sdir.iter().map(|&x| x).enumerate()\n+                           .filter(|&(i, sd)|\n+                                new_pos(i, sd.dir) < self.sdir.len() &&\n+                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n+                           .max_by(|&(_, sd)| sd.size);\n+        match max {\n+            Some((i, sd)) => {\n+                let j = new_pos(i, sd.dir);\n+                self.sdir.swap(i, j);\n+\n+                // Swap the direction of each larger SizeDirection\n+                for x in self.sdir.iter_mut() {\n+                    if x.size > sd.size {\n+                        x.dir = match x.dir { Pos => Neg, Neg => Pos };\n+                    }\n+                }\n+                self.swaps_made += 1;\n+                Some((i, j))\n+            },\n+            None => if self.emit_reset {\n+                self.emit_reset = false;\n+                if self.sdir.len() > 1 {\n+                    // The last swap\n+                    self.swaps_made += 1;\n+                    Some((0, 1))\n+                } else {\n+                    // Vector is of the form [] or [x], and the only permutation is itself\n+                    self.swaps_made += 1;\n+                    Some((0,0))\n+                }\n+            } else { None }\n+        }\n     }\n \n     #[inline]\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n-        core_slice::SliceExt::get(self, index)\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        // For a vector of size n, there are exactly n! permutations.\n+        let n = range(2, self.sdir.len() + 1).product();\n+        (n - self.swaps_made, Some(n - self.swaps_made))\n     }\n+}\n+\n+/// An iterator that uses `ElementSwaps` to iterate through\n+/// all possible permutations of a vector.\n+///\n+/// The first iteration yields a clone of the vector as it is,\n+/// then each successive element is the vector with one\n+/// swap applied.\n+///\n+/// Generates even and odd permutations alternately.\n+#[stable]\n+pub struct Permutations<T> {\n+    swaps: ElementSwaps,\n+    v: Vec<T>,\n+}\n \n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n     #[inline]\n-    fn head<'a>(&'a self) -> Option<&'a T> {\n-        core_slice::SliceExt::head(self)\n+    fn next(&mut self) -> Option<Vec<T>> {\n+        match self.swaps.next() {\n+            None => None,\n+            Some((0,0)) => Some(self.v.clone()),\n+            Some((a, b)) => {\n+                let elt = self.v.clone();\n+                self.v.swap(a, b);\n+                Some(elt)\n+            }\n+        }\n     }\n \n     #[inline]\n-    fn tail<'a>(&'a self) -> &'a [T] {\n-        core_slice::SliceExt::tail(self)\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.swaps.size_hint()\n     }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Sorting\n+////////////////////////////////////////////////////////////////////////////////\n+\n+fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+    let len = v.len() as int;\n+    let buf_v = v.as_mut_ptr();\n+\n+    // 1 <= i < len;\n+    for i in range(1, len) {\n+        // j satisfies: 0 <= j <= i;\n+        let mut j = i;\n+        unsafe {\n+            // `i` is in bounds.\n+            let read_ptr = buf_v.offset(i) as *const T;\n+\n+            // find where to insert, we need to do strict <,\n+            // rather than <=, to maintain stability.\n+\n+            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n+            while j > 0 &&\n+                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n+                j -= 1;\n+            }\n \n-    #[inline]\n-    fn init<'a>(&'a self) -> &'a [T] {\n-        core_slice::SliceExt::init(self)\n-    }\n+            // shift everything to the right, to make space to\n+            // insert this value.\n \n-    #[inline]\n-    fn last<'a>(&'a self) -> Option<&'a T> {\n-        core_slice::SliceExt::last(self)\n-    }\n+            // j + 1 could be `len` (for the last `i`), but in\n+            // that case, `i == j` so we don't copy. The\n+            // `.offset(j)` is always in bounds.\n \n-    #[inline]\n-    unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T {\n-        core_slice::SliceExt::unsafe_get(self, index)\n+            if i != j {\n+                let tmp = ptr::read(read_ptr);\n+                ptr::copy_memory(buf_v.offset(j + 1),\n+                                 &*buf_v.offset(j),\n+                                 (i - j) as uint);\n+                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n+                                                &tmp as *const T,\n+                                                1);\n+                mem::forget(tmp);\n+            }\n+        }\n     }\n+}\n \n-    #[inline]\n-    fn as_ptr(&self) -> *const T {\n-        core_slice::SliceExt::as_ptr(self)\n-    }\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+    // warning: this wildly uses unsafe.\n+    static BASE_INSERTION: uint = 32;\n+    static LARGE_INSERTION: uint = 16;\n \n-    #[inline]\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n-                        where F: FnMut(&T) -> Ordering {\n-        core_slice::SliceExt::binary_search(self, f)\n-    }\n+    // FIXME #12092: smaller insertion runs seems to make sorting\n+    // vectors of large elements a little faster on some platforms,\n+    // but hasn't been tested/tuned extensively\n+    let insertion = if size_of::<T>() <= 16 {\n+        BASE_INSERTION\n+    } else {\n+        LARGE_INSERTION\n+    };\n \n-    #[inline]\n-    fn len(&self) -> uint {\n-        core_slice::SliceExt::len(self)\n-    }\n+    let len = v.len();\n \n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        core_slice::SliceExt::is_empty(self)\n+    // short vectors get sorted in-place via insertion sort to avoid allocations\n+    if len <= insertion {\n+        insertion_sort(v, compare);\n+        return;\n     }\n \n-    #[inline]\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n-        core_slice::SliceExt::get_mut(self, index)\n-    }\n+    // allocate some memory to use as scratch memory, we keep the\n+    // length 0 so we can keep shallow copies of the contents of `v`\n+    // without risking the dtors running on an object twice if\n+    // `compare` panics.\n+    let mut working_space = Vec::with_capacity(2 * len);\n+    // these both are buffers of length `len`.\n+    let mut buf_dat = working_space.as_mut_ptr();\n+    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n \n-    #[inline]\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        core_slice::SliceExt::as_mut_slice(self)\n-    }\n+    // length `len`.\n+    let buf_v = v.as_ptr();\n \n-    #[inline]\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_mut(self, start, end)\n-    }\n+    // step 1. sort short runs with insertion sort. This takes the\n+    // values from `v` and sorts them into `buf_dat`, leaving that\n+    // with sorted runs of length INSERTION.\n \n-    #[inline]\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_from_mut(self, start)\n-    }\n+    // We could hardcode the sorting comparisons here, and we could\n+    // manipulate/step the pointers themselves, rather than repeatedly\n+    // .offset-ing.\n+    for start in range_step(0, len, insertion) {\n+        // start <= i < len;\n+        for i in range(start, cmp::min(start + insertion, len)) {\n+            // j satisfies: start <= j <= i;\n+            let mut j = i as int;\n+            unsafe {\n+                // `i` is in bounds.\n+                let read_ptr = buf_v.offset(i as int);\n \n-    #[inline]\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_to_mut(self, end)\n-    }\n+                // find where to insert, we need to do strict <,\n+                // rather than <=, to maintain stability.\n \n-    #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n-        core_slice::SliceExt::iter_mut(self)\n-    }\n+                // start <= j - 1 < len, so .offset(j - 1) is in\n+                // bounds.\n+                while j > start as int &&\n+                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n+                    j -= 1;\n+                }\n \n-    #[inline]\n-    fn head_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        core_slice::SliceExt::head_mut(self)\n-    }\n+                // shift everything to the right, to make space to\n+                // insert this value.\n \n-    #[inline]\n-    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] {\n-        core_slice::SliceExt::tail_mut(self)\n+                // j + 1 could be `len` (for the last `i`), but in\n+                // that case, `i == j` so we don't copy. The\n+                // `.offset(j)` is always in bounds.\n+                ptr::copy_memory(buf_dat.offset(j + 1),\n+                                 &*buf_dat.offset(j),\n+                                 i - j as uint);\n+                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n+            }\n+        }\n     }\n \n-    #[inline]\n-    fn init_mut<'a>(&'a mut self) -> &'a mut [T] {\n-        core_slice::SliceExt::init_mut(self)\n-    }\n+    // step 2. merge the sorted runs.\n+    let mut width = insertion;\n+    while width < len {\n+        // merge the sorted runs of length `width` in `buf_dat` two at\n+        // a time, placing the result in `buf_tmp`.\n \n-    #[inline]\n-    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        core_slice::SliceExt::last_mut(self)\n-    }\n+        // 0 <= start <= len.\n+        for start in range_step(0, len, 2 * width) {\n+            // manipulate pointers directly for speed (rather than\n+            // using a `for` loop with `range` and `.offset` inside\n+            // that loop).\n+            unsafe {\n+                // the end of the first run & start of the\n+                // second. Offset of `len` is defined, since this is\n+                // precisely one byte past the end of the object.\n+                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n+                // end of the second. Similar reasoning to the above re safety.\n+                let right_end_idx = cmp::min(start + 2 * width, len);\n+                let right_end = buf_dat.offset(right_end_idx as int);\n \n-    #[inline]\n-    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n-                    where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::split_mut(self, pred)\n-    }\n+                // the pointers to the elements under consideration\n+                // from the two runs.\n \n-    #[inline]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                     where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::splitn_mut(self, n, pred)\n-    }\n+                // both of these are in bounds.\n+                let mut left = buf_dat.offset(start as int);\n+                let mut right = right_start;\n \n-    #[inline]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                      where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n-    }\n+                // where we're putting the results, it is a run of\n+                // length `2*width`, so we step it once for each step\n+                // of either `left` or `right`.  `buf_tmp` has length\n+                // `len`, so these are in bounds.\n+                let mut out = buf_tmp.offset(start as int);\n+                let out_end = buf_tmp.offset(right_end_idx as int);\n \n-    #[inline]\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T> {\n-        core_slice::SliceExt::chunks_mut(self, chunk_size)\n-    }\n+                while out < out_end {\n+                    // Either the left or the right run are exhausted,\n+                    // so just copy the remainder from the other run\n+                    // and move on; this gives a huge speed-up (order\n+                    // of 25%) for mostly sorted vectors (the best\n+                    // case).\n+                    if left == right_start {\n+                        // the number remaining in this run.\n+                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n+                        break;\n+                    } else if right == right_end {\n+                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n+                        break;\n+                    }\n \n-    #[inline]\n-    fn swap(&mut self, a: uint, b: uint) {\n-        core_slice::SliceExt::swap(self, a, b)\n-    }\n+                    // check which side is smaller, and that's the\n+                    // next element for the new run.\n \n-    #[inline]\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        core_slice::SliceExt::split_at_mut(self, mid)\n-    }\n+                    // `left < right_start` and `right < right_end`,\n+                    // so these are valid.\n+                    let to_copy = if compare(&*left, &*right) == Greater {\n+                        step(&mut right)\n+                    } else {\n+                        step(&mut left)\n+                    };\n+                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n+                    step(&mut out);\n+                }\n+            }\n+        }\n \n-    #[inline]\n-    fn reverse(&mut self) {\n-        core_slice::SliceExt::reverse(self)\n-    }\n+        mem::swap(&mut buf_dat, &mut buf_tmp);\n \n-    #[inline]\n-    unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n-        core_slice::SliceExt::unsafe_mut(self, index)\n+        width *= 2;\n     }\n \n-    #[inline]\n-    fn as_mut_ptr(&mut self) -> *mut T {\n-        core_slice::SliceExt::as_mut_ptr(self)\n+    // write the result to `v` in one go, so that there are never two copies\n+    // of the same object in `v`.\n+    unsafe {\n+        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n     }\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T> BorrowFrom<Vec<T>> for [T] {\n-    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.as_mut_slice_() }\n-}\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: Clone> ToOwned<Vec<T>> for [T] {\n-    fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+    // increment the pointer, returning the old pointer.\n+    #[inline(always)]\n+    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n+        let old = *ptr;\n+        *ptr = ptr.offset(1);\n+        old\n+    }\n }\n \n-/// Unsafe operations\n+/// Deprecated, unsafe operations\n+#[deprecated]\n pub mod raw {\n     pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};\n     pub use core::slice::raw::{shift_ptr, pop_ptr};"}, {"sha": "38d8977c0aa840730b4c1456a9bd07ff00c3a810", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 169, "deletions": 159, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/4f863a338e0a7c33f81a8ac138103f1a0e8b33c5/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f863a338e0a7c33f81a8ac138103f1a0e8b33c5/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=4f863a338e0a7c33f81a8ac138103f1a0e8b33c5", "patch": "@@ -68,23 +68,23 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n     fn iter<'a>(&'a self) -> Iter<'a, T>;\n-    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P>\n+    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P>\n                     where P: FnMut(&T) -> bool;\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P>\n                      where P: FnMut(&T) -> bool;\n-    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n+    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, T, P>\n                       where P: FnMut(&T) -> bool;\n     fn windows<'a>(&'a self, size: uint) -> Windows<'a, T>;\n     fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T>;\n     fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n-    fn head<'a>(&'a self) -> Option<&'a T>;\n+    fn first<'a>(&'a self) -> Option<&'a T>;\n     fn tail<'a>(&'a self) -> &'a [T];\n     fn init<'a>(&'a self) -> &'a [T];\n     fn last<'a>(&'a self) -> Option<&'a T>;\n-    unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T;\n+    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T;\n     fn as_ptr(&self) -> *const T;\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n-                        where F: FnMut(&T) -> Ordering;\n+    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+        F: FnMut(&T) -> Ordering;\n     fn len(&self) -> uint;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n@@ -93,21 +93,21 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>;\n-    fn head_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n+    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n     fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n     fn last_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P>\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P>\n                         where P: FnMut(&T) -> bool;\n-    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitsN<MutSplits<T, P>>\n+    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<T, P>\n                      where P: FnMut(&T) -> bool;\n-    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> SplitsN<MutSplits<T, P>>\n+    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<T, P>\n                       where P: FnMut(&T) -> bool;\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T>;\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T>;\n     fn swap(&mut self, a: uint, b: uint);\n     fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n     fn reverse(&mut self);\n-    unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n     fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n@@ -145,45 +145,49 @@ impl<T> SliceExt<T> for [T] {\n         unsafe {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n-                Iter{ptr: p,\n+                Iter {ptr: p,\n                       end: (p as uint + self.len()) as *const T,\n                       marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                Iter{ptr: p,\n+                Iter {ptr: p,\n                       end: p.offset(self.len() as int),\n                       marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n     }\n \n     #[inline]\n-    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P> where P: FnMut(&T) -> bool {\n-        Splits {\n+    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P> where P: FnMut(&T) -> bool {\n+        Split {\n             v: self,\n             pred: pred,\n             finished: false\n         }\n     }\n \n     #[inline]\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: false\n+        SplitN {\n+            inner: GenericSplitN {\n+                iter: self.split(pred),\n+                count: n,\n+                invert: false\n+            }\n         }\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> RSplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: true\n+        RSplitN {\n+            inner: GenericSplitN {\n+                iter: self.split(pred),\n+                count: n,\n+                invert: true\n+            }\n         }\n     }\n \n@@ -205,7 +209,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn head(&self) -> Option<&T> {\n+    fn first(&self) -> Option<&T> {\n         if self.len() == 0 { None } else { Some(&self[0]) }\n     }\n \n@@ -223,7 +227,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+    unsafe fn get_unchecked(&self, index: uint) -> &T {\n         transmute(self.repr().data.offset(index as int))\n     }\n \n@@ -233,14 +237,16 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[unstable]\n-    fn binary_search<F>(&self, mut f: F) -> BinarySearchResult where F: FnMut(&T) -> Ordering {\n+    fn binary_search_by<F>(&self, mut f: F) -> Result where\n+        F: FnMut(&T) -> Ordering\n+    {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n \n         while lim != 0 {\n             let ix = base + (lim >> 1);\n             match f(&self[ix]) {\n-                Equal => return BinarySearchResult::Found(ix),\n+                Equal => return Ok(ix),\n                 Less => {\n                     base = ix + 1;\n                     lim -= 1;\n@@ -249,7 +255,7 @@ impl<T> SliceExt<T> for [T] {\n             }\n             lim >>= 1;\n         }\n-        return BinarySearchResult::NotFound(base);\n+        Err(base);\n     }\n \n     #[inline]\n@@ -292,11 +298,11 @@ impl<T> SliceExt<T> for [T] {\n         unsafe {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n-                IterMut{ptr: p,\n+                IterMut {ptr: p,\n                          end: (p as uint + self.len()) as *mut T,\n                          marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                IterMut{ptr: p,\n+                IterMut {ptr: p,\n                          end: p.offset(self.len() as int),\n                          marker: marker::ContravariantLifetime::<'a>}\n             }\n@@ -311,7 +317,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn head_mut(&mut self) -> Option<&mut T> {\n+    fn first_mut(&mut self) -> Option<&mut T> {\n         if self.len() == 0 { None } else { Some(&mut self[0]) }\n     }\n \n@@ -327,36 +333,40 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n-        MutSplits { v: self, pred: pred, finished: false }\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+        SplitMut { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool\n     {\n-        SplitsN {\n-            iter: self.split_mut(pred),\n-            count: n,\n-            invert: false\n+        SplitNMut {\n+            inner: GenericSplitN {\n+                iter: self.split_mut(pred),\n+                count: n,\n+                invert: false\n+            }\n         }\n     }\n \n     #[inline]\n-    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> RSplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n-        SplitsN {\n-            iter: self.split_mut(pred),\n-            count: n,\n-            invert: true\n+        RSplitNMut {\n+            inner: GenericSplitN {\n+                iter: self.split_mut(pred),\n+                count: n,\n+                invert: true\n+            }\n         }\n    }\n \n     #[inline]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> MutChunks<T> {\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T> {\n         assert!(chunk_size > 0);\n-        MutChunks { v: self, chunk_size: chunk_size }\n+        ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n     fn swap(&mut self, a: uint, b: uint) {\n@@ -375,16 +385,16 @@ impl<T> SliceExt<T> for [T] {\n         while i < ln / 2 {\n             // Unsafe swap to avoid the bounds check in safe swap.\n             unsafe {\n-                let pa: *mut T = self.unsafe_mut(i);\n-                let pb: *mut T = self.unsafe_mut(ln - i - 1);\n+                let pa: *mut T = self.get_unchecked_mut(i);\n+                let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n                 ptr::swap(pa, pb);\n             }\n             i += 1;\n         }\n     }\n \n     #[inline]\n-    unsafe fn unsafe_mut(&mut self, index: uint) -> &mut T {\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T {\n         transmute((self.repr().data as *mut T).offset(index as int))\n     }\n \n@@ -468,21 +478,26 @@ impl<T> ops::SliceMut<uint, [T]> for [T] {\n }\n \n /// Extension methods for slices containing `PartialEq` elements.\n-#[unstable = \"may merge with other traits\"]\n+#[unstable = \"may merge with SliceExt\"]\n pub trait PartialEqSliceExt<T: PartialEq> for Sized? {\n     /// Find the first index containing a matching value.\n+    #[experimental]\n     fn position_elem(&self, t: &T) -> Option<uint>;\n \n     /// Find the last index containing a matching value.\n+    #[experimental]\n     fn rposition_elem(&self, t: &T) -> Option<uint>;\n \n     /// Return true if the slice contains an element with the given value.\n+    #[stable]\n     fn contains(&self, x: &T) -> bool;\n \n     /// Returns true if `needle` is a prefix of the slice.\n+    #[stable]\n     fn starts_with(&self, needle: &[T]) -> bool;\n \n     /// Returns true if `needle` is a suffix of the slice.\n+    #[stable]\n     fn ends_with(&self, needle: &[T]) -> bool;\n }\n \n@@ -520,19 +535,16 @@ impl<T: PartialEq> PartialEqSliceExt<T> for [T] {\n #[unstable = \"may merge with other traits\"]\n #[allow(missing_docs)] // docs in libcollections\n pub trait OrdSliceExt<T: Ord> for Sized? {\n-    #[unstable = \"name likely to change\"]\n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n-    #[experimental]\n+    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n     fn next_permutation(&mut self) -> bool;\n-    #[experimental]\n     fn prev_permutation(&mut self) -> bool;\n }\n \n #[unstable = \"trait is unstable\"]\n impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[unstable]\n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n-        self.binary_search(|p| p.cmp(x))\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+        self.binary_search_by(|p| p.cmp(x))\n     }\n \n     #[experimental]\n@@ -619,28 +631,30 @@ impl<T: Clone> CloneSliceExt<T> for [T] {\n     }\n }\n \n-//\n+////////////////////////////////////////////////////////////////////////////////\n // Common traits\n-//\n+////////////////////////////////////////////////////////////////////////////////\n \n /// Data that is viewable as a slice.\n-#[unstable = \"may merge with other traits\"]\n+#[experimental = \"will be replaced by slice syntax\"]\n pub trait AsSlice<T> for Sized? {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[experimental = \"trait is experimental\"]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n@@ -656,7 +670,7 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n-// The shared definition of the `Item` and `IterMut` iterators\n+// The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         #[experimental = \"needs review\"]\n@@ -736,9 +750,8 @@ macro_rules! make_slice {\n     }}\n }\n \n-\n /// Immutable slice iterator\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n@@ -813,7 +826,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n }\n \n /// Mutable slice iterator.\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n@@ -876,28 +889,28 @@ iterator!{struct IterMut -> *mut T, &'a mut T}\n #[experimental = \"needs review\"]\n impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n-/// An abstraction over the splitting iterators, so that splitn, splitn_mut etc\n-/// can be implemented once.\n-trait SplitsIter<E>: DoubleEndedIterator<E> {\n+/// An internal abstraction over the splitting iterators, so that\n+/// splitn, splitn_mut etc can be implemented once.\n+trait SplitIter<E>: DoubleEndedIterator<E> {\n     /// Mark the underlying iterator as complete, extracting the remaining\n     /// portion of the slice.\n     fn finish(&mut self) -> Option<E>;\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function.\n-#[experimental = \"needs review\"]\n-pub struct Splits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+#[stable]\n+pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a [T],\n     pred: P,\n     finished: bool\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n-impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n-    fn clone(&self) -> Splits<'a, T, P> {\n-        Splits {\n+impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n+    fn clone(&self) -> Split<'a, T, P> {\n+        Split {\n             v: self.v,\n             pred: self.pred.clone(),\n             finished: self.finished,\n@@ -906,7 +919,7 @@ impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -932,7 +945,7 @@ impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -948,7 +961,7 @@ impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(\n     }\n }\n \n-impl<'a, T, P> SplitsIter<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a [T]> {\n         if self.finished { None } else { self.finished = true; Some(self.v) }\n@@ -957,14 +970,14 @@ impl<'a, T, P> SplitsIter<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bo\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n-#[experimental = \"needs review\"]\n-pub struct MutSplits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+#[stable]\n+pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a mut [T],\n     pred: P,\n     finished: bool\n }\n \n-impl<'a, T, P> SplitsIter<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a mut [T]> {\n         if self.finished {\n@@ -977,7 +990,7 @@ impl<'a, T, P> SplitsIter<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -1010,7 +1023,7 @@ impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T)\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n+impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n     #[inline]\n@@ -1033,17 +1046,17 @@ impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n     }\n }\n \n-/// An iterator over subslices separated by elements that match a predicate\n-/// function, splitting at most a fixed number of times.\n-#[experimental = \"needs review\"]\n-pub struct SplitsN<I> {\n+/// An private iterator over subslices separated by elements that\n+/// match a predicate function, splitting at most a fixed number of\n+/// times.\n+struct GenericSplitN<I> {\n     iter: I,\n     count: uint,\n     invert: bool\n }\n \n #[experimental = \"needs review\"]\n-impl<E, I: SplitsIter<E>> Iterator<E> for SplitsN<I> {\n+impl<E, I: SplitIter<E>> Iterator<E> for GenericSplitN<I> {\n     #[inline]\n     fn next(&mut self) -> Option<E> {\n         if self.count == 0 {\n@@ -1061,6 +1074,55 @@ impl<E, I: SplitsIter<E>> Iterator<E> for SplitsN<I> {\n     }\n }\n \n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, limited to a given number of splits.\n+pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<Split<'a, T, P>>\n+}\n+\n+/// An iterator over subslices separated by elements that match a\n+/// predicate function, limited to a given number of splits, starting\n+/// from the end of the slice.\n+pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<Split<'a, T, P>>\n+}\n+\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, limited to a given number of splits.\n+pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<SplitMut<'a, T, P>>\n+}\n+\n+/// An iterator over subslices separated by elements that match a\n+/// predicate function, limited to a given number of splits, starting\n+/// from the end of the slice.\n+pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<SplitMut<'a, T, P>>\n+}\n+\n+macro_rules! forward_iterator {\n+    ($name:ident: $elem:ident, $iter_of:ty) => {\n+        impl<'a, $elem, P> Iterator<$iter_of> for $name<'a, $elem, P> where\n+            P: FnMut(&T) -> bool\n+        {\n+            #[inline]\n+            fn next(&mut self) -> Option<$iter_of> {\n+                self.inner.next()\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                self.inner.size_hint()\n+            }\n+        }\n+    }\n+}\n+\n+forward_iterator! { SplitN: T, &'a [T] }\n+forward_iterator! { RSplitN: T, &'a [T] }\n+forward_iterator! { SplitNMut: T, &'a mut [T] }\n+forward_iterator! { RSplitNMut: T, &'a mut [T] }\n+\n /// An iterator over overlapping subslices of length `size`.\n #[deriving(Clone)]\n #[experimental = \"needs review\"]\n@@ -1172,13 +1234,13 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n #[experimental = \"needs review\"]\n-pub struct MutChunks<'a, T:'a> {\n+pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n+impl<'a, T> Iterator<&'a mut [T]> for ChunksMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -1206,7 +1268,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -1224,59 +1286,20 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n }\n \n \n-\n-/// The result of calling `binary_search`.\n-///\n-/// `Found` means the search succeeded, and the contained value is the\n-/// index of the matching element. `NotFound` means the search\n-/// succeeded, and the contained value is an index where a matching\n-/// value could be inserted while maintaining sort order.\n-#[deriving(Copy, PartialEq, Show)]\n-#[experimental = \"needs review\"]\n-pub enum BinarySearchResult {\n-    /// The index of the found value.\n-    Found(uint),\n-    /// The index where the value should have been found.\n-    NotFound(uint)\n-}\n-\n-#[experimental = \"needs review\"]\n-impl BinarySearchResult {\n-    /// Converts a `Found` to `Some`, `NotFound` to `None`.\n-    /// Similar to `Result::ok`.\n-    pub fn found(&self) -> Option<uint> {\n-        match *self {\n-            BinarySearchResult::Found(i) => Some(i),\n-            BinarySearchResult::NotFound(_) => None\n-        }\n-    }\n-\n-    /// Convert a `Found` to `None`, `NotFound` to `Some`.\n-    /// Similar to `Result::err`.\n-    pub fn not_found(&self) -> Option<uint> {\n-        match *self {\n-            BinarySearchResult::Found(_) => None,\n-            BinarySearchResult::NotFound(i) => Some(i)\n-        }\n-    }\n-}\n-\n-\n-\n //\n // Free functions\n //\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable = \"waiting for DST\"]\n+#[unstable]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         transmute(RawSlice { data: s, len: 1 })\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable = \"waiting for DST\"]\n+#[unstable]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         let ptr: *const A = transmute(s);\n@@ -1310,7 +1333,7 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// }\n /// ```\n #[inline]\n-#[unstable = \"just renamed from `mod raw`\"]\n+#[unstable = \"should be renamed to from_raw_parts\"]\n pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1322,7 +1345,7 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable = \"just renamed from `mod raw`\"]\n+#[unstable = \"jshould be renamed to from_raw_parts_mut\"]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p as *const T, len: len })\n }\n@@ -1497,39 +1520,28 @@ impl<T: PartialOrd> PartialOrd for [T] {\n     }\n }\n \n-/// Extension methods for immutable slices containing integers.\n+/// Extension methods for slices containing integers.\n #[experimental]\n-pub trait ImmutableIntSlice<U, S> for Sized? {\n+pub trait IntSliceExt<U, S> for Sized? {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n     /// Converts the slice to an immutable slice of signed integers with the same width.\n     fn as_signed<'a>(&'a self) -> &'a [S];\n-}\n \n-/// Extension methods for mutable slices containing integers.\n-#[experimental]\n-pub trait MutableIntSlice<U, S> for Sized?: ImmutableIntSlice<U, S> {\n     /// Converts the slice to a mutable slice of unsigned integers with the same width.\n     fn as_unsigned_mut<'a>(&'a mut self) -> &'a mut [U];\n     /// Converts the slice to a mutable slice of signed integers with the same width.\n     fn as_signed_mut<'a>(&'a mut self) -> &'a mut [S];\n }\n \n-macro_rules! impl_immut_int_slice {\n+macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n         #[experimental]\n-        impl ImmutableIntSlice<$u, $s> for [$t] {\n+        impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }\n             #[inline]\n             fn as_signed(&self) -> &[$s] { unsafe { transmute(self) } }\n-        }\n-    }\n-}\n-macro_rules! impl_mut_int_slice {\n-    ($u:ty, $s:ty, $t:ty) => {\n-        #[experimental]\n-        impl MutableIntSlice<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned_mut(&mut self) -> &mut [$u] { unsafe { transmute(self) } }\n             #[inline]\n@@ -1538,17 +1550,15 @@ macro_rules! impl_mut_int_slice {\n     }\n }\n \n-macro_rules! impl_int_slice {\n+macro_rules! impl_int_slices {\n     ($u:ty, $s:ty) => {\n-        impl_immut_int_slice! { $u, $s, $u }\n-        impl_immut_int_slice! { $u, $s, $s }\n-        impl_mut_int_slice! { $u, $s, $u }\n-        impl_mut_int_slice! { $u, $s, $s }\n+        impl_int_slice! { $u, $s, $u }\n+        impl_int_slice! { $u, $s, $s }\n     }\n }\n \n-impl_int_slice! { u8,   i8 }\n-impl_int_slice! { u16,  i16 }\n-impl_int_slice! { u32,  i32 }\n-impl_int_slice! { u64,  i64 }\n-impl_int_slice! { uint, int }\n+impl_int_slices! { u8,   i8  }\n+impl_int_slices! { u16,  i16 }\n+impl_int_slices! { u32,  i32 }\n+impl_int_slices! { u64,  i64 }\n+impl_int_slices! { uint, int }"}, {"sha": "aed73472416064642911af790b25d57c9390b6c7", "filename": "src/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-installer?ref=4f863a338e0a7c33f81a8ac138103f1a0e8b33c5", "patch": "@@ -1 +1 @@\n-Subproject commit 3a37981744a5af2433fed551f742465c78c9af7f\n+Subproject commit aed73472416064642911af790b25d57c9390b6c7"}]}