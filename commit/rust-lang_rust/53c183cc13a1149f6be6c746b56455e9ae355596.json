{"sha": "53c183cc13a1149f6be6c746b56455e9ae355596", "node_id": "C_kwDOAAsO6NoAKDUzYzE4M2NjMTNhMTE0OWY2YmU2Yzc0NmI1NjQ1NWU5YWUzNTU1OTY", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-12-23T06:28:25Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-12-23T07:23:56Z"}, "message": "Remove network functions", "tree": {"sha": "0e233d7b8bb47696889476fd3e6156131d9e1957", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e233d7b8bb47696889476fd3e6156131d9e1957"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53c183cc13a1149f6be6c746b56455e9ae355596", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53c183cc13a1149f6be6c746b56455e9ae355596", "html_url": "https://github.com/rust-lang/rust/commit/53c183cc13a1149f6be6c746b56455e9ae355596", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53c183cc13a1149f6be6c746b56455e9ae355596/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5b4aa303731b7333b67906ff03311f5f3b6cd2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b4aa303731b7333b67906ff03311f5f3b6cd2f", "html_url": "https://github.com/rust-lang/rust/commit/d5b4aa303731b7333b67906ff03311f5f3b6cd2f"}], "stats": {"total": 228, "additions": 0, "deletions": 228}, "files": [{"sha": "bd1bb5f8a8a817500a569504826fcaf5cf6d54d1", "filename": "editors/code/src/net.ts", "status": "removed", "additions": 0, "deletions": 228, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/d5b4aa303731b7333b67906ff03311f5f3b6cd2f/editors%2Fcode%2Fsrc%2Fnet.ts", "raw_url": "https://github.com/rust-lang/rust/raw/d5b4aa303731b7333b67906ff03311f5f3b6cd2f/editors%2Fcode%2Fsrc%2Fnet.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fnet.ts?ref=d5b4aa303731b7333b67906ff03311f5f3b6cd2f", "patch": "@@ -1,228 +0,0 @@\n-import fetch from \"node-fetch\";\n-var HttpsProxyAgent = require('https-proxy-agent');\n-\n-import * as vscode from \"vscode\";\n-import * as stream from \"stream\";\n-import * as crypto from \"crypto\";\n-import * as fs from \"fs\";\n-import * as zlib from \"zlib\";\n-import * as util from \"util\";\n-import * as path from \"path\";\n-import { log, assert } from \"./util\";\n-import * as https from \"https\";\n-import { ProxySettings } from \"./config\";\n-\n-const pipeline = util.promisify(stream.pipeline);\n-\n-const GITHUB_API_ENDPOINT_URL = \"https://api.github.com\";\n-const OWNER = \"rust-analyzer\";\n-const REPO = \"rust-analyzer\";\n-\n-function makeHttpAgent(proxy: string | null | undefined, options?: https.AgentOptions) {\n-    if (proxy) {\n-        return new HttpsProxyAgent({ ...options, ...new URL(proxy) });\n-    } else {\n-        return new https.Agent(options);\n-    }\n-}\n-\n-export async function fetchRelease(\n-    releaseTag: string,\n-    githubToken: string | null | undefined,\n-    proxySettings: ProxySettings,\n-): Promise<GithubRelease> {\n-\n-    const apiEndpointPath = `/repos/${OWNER}/${REPO}/releases/tags/${releaseTag}`;\n-\n-    const requestUrl = GITHUB_API_ENDPOINT_URL + apiEndpointPath;\n-\n-    log.debug(\"Issuing request for released artifacts metadata to\", requestUrl);\n-\n-    const headers: Record<string, string> = { Accept: \"application/vnd.github.v3+json\" };\n-    if (githubToken != null) {\n-        headers.Authorization = \"token \" + githubToken;\n-    }\n-\n-    const response = await (() => {\n-        if (proxySettings.proxy) {\n-            log.debug(`Fetching release metadata via proxy: ${proxySettings.proxy}`);\n-        }\n-        const options: any = {};\n-        if (proxySettings.strictSSL) {\n-            options[\"rejectUnauthorized\"] = false;\n-        }\n-        const agent = makeHttpAgent(proxySettings.proxy, options);\n-        return fetch(requestUrl, { headers: headers, agent: agent });\n-    })();\n-\n-    if (!response.ok) {\n-        log.error(\"Error fetching artifact release info\", {\n-            requestUrl,\n-            releaseTag,\n-            response: {\n-                headers: response.headers,\n-                status: response.status,\n-                body: await response.text(),\n-            }\n-        });\n-\n-        throw new Error(\n-            `Got response ${response.status} when trying to fetch ` +\n-            `release info for ${releaseTag} release`\n-        );\n-    }\n-\n-    // We skip runtime type checks for simplicity (here we cast from `unknown` to `GithubRelease`)\n-    const release = await response.json() as GithubRelease;\n-    return release;\n-}\n-\n-// We omit declaration of tremendous amount of fields that we are not using here\n-export interface GithubRelease {\n-    name: string;\n-    id: number;\n-    // eslint-disable-next-line camelcase\n-    published_at: string;\n-    assets: Array<{\n-        name: string;\n-        // eslint-disable-next-line camelcase\n-        browser_download_url: vscode.Uri;\n-    }>;\n-}\n-\n-interface DownloadOpts {\n-    progressTitle: string;\n-    url: vscode.Uri;\n-    dest: vscode.Uri;\n-    mode?: number;\n-    gunzip?: boolean;\n-    proxySettings: ProxySettings;\n-}\n-\n-export async function download(opts: DownloadOpts) {\n-    // Put artifact into a temporary file (in the same dir for simplicity)\n-    // to prevent partially downloaded files when user kills vscode\n-    // This also avoids overwriting running executables\n-    const randomHex = crypto.randomBytes(5).toString(\"hex\");\n-    const rawDest = path.parse(opts.dest.fsPath);\n-    const oldServerPath = vscode.Uri.joinPath(vscode.Uri.file(rawDest.dir), `${rawDest.name}-stale-${randomHex}${rawDest.ext}`);\n-    const tempFilePath = vscode.Uri.joinPath(vscode.Uri.file(rawDest.dir), `${rawDest.name}${randomHex}`);\n-\n-    await vscode.window.withProgress(\n-        {\n-            location: vscode.ProgressLocation.Notification,\n-            cancellable: false,\n-            title: opts.progressTitle\n-        },\n-        async (progress, _cancellationToken) => {\n-            let lastPercentage = 0;\n-            await downloadFile(opts.url, tempFilePath, opts.mode, !!opts.gunzip, opts.proxySettings, (readBytes, totalBytes) => {\n-                const newPercentage = Math.round((readBytes / totalBytes) * 100);\n-                if (newPercentage !== lastPercentage) {\n-                    progress.report({\n-                        message: `${newPercentage.toFixed(0)}%`,\n-                        increment: newPercentage - lastPercentage\n-                    });\n-\n-                    lastPercentage = newPercentage;\n-                }\n-            });\n-        }\n-    );\n-\n-    // Try to rename a running server to avoid EPERM on Windows\n-    // NB: this can lead to issues if a running Code instance tries to restart the server.\n-    try {\n-        await vscode.workspace.fs.rename(opts.dest, oldServerPath, { overwrite: true });\n-        log.info(`Renamed old server binary ${opts.dest.fsPath} to ${oldServerPath.fsPath}`);\n-    } catch (err) {\n-        const fsErr = err as vscode.FileSystemError;\n-\n-        // This is supposed to return `FileNotFound` (spelled as `EntryNotFound`)\n-        // but instead `code` is `Unknown` and `name` is `EntryNotFound (FileSystemError) (FileSystemError)`.\n-        // https://github.com/rust-analyzer/rust-analyzer/pull/10222\n-        if (!fsErr.code || fsErr.code !== \"EntryNotFound\" && fsErr.name.indexOf(\"EntryNotFound\") === -1) {\n-            log.error(`Cannot rename existing server instance: ${err}\"`);\n-        }\n-    }\n-    try {\n-        await vscode.workspace.fs.rename(tempFilePath, opts.dest, { overwrite: true });\n-    } catch (err) {\n-        log.error(`Cannot update server binary: ${err}`);\n-    }\n-\n-    // Now try to remove any stale server binaries\n-    const serverDir = vscode.Uri.file(rawDest.dir);\n-    try {\n-        const entries = await vscode.workspace.fs.readDirectory(serverDir);\n-        for (const [entry, _] of entries) {\n-            try {\n-                if (entry.includes(`${rawDest.name}-stale-`)) {\n-                    const uri = vscode.Uri.joinPath(serverDir, entry);\n-                    try {\n-                        await vscode.workspace.fs.delete(uri);\n-                        log.info(`Removed old server binary ${uri.fsPath}`);\n-                    } catch (err) {\n-                        log.error(`Unable to remove old server binary ${uri.fsPath}`);\n-                    }\n-                }\n-            } catch (err) {\n-                log.error(`Unable to parse ${entry}`);\n-            }\n-        }\n-    } catch (err) {\n-        log.error(`Unable to enumerate contents of ${serverDir.fsPath}`);\n-    }\n-}\n-\n-async function downloadFile(\n-    url: vscode.Uri,\n-    destFilePath: vscode.Uri,\n-    mode: number | undefined,\n-    gunzip: boolean,\n-    proxySettings: ProxySettings,\n-    onProgress: (readBytes: number, totalBytes: number) => void\n-): Promise<void> {\n-    const urlString = url.toString();\n-\n-    const res = await (() => {\n-        if (proxySettings.proxy) {\n-            log.debug(`Downloading ${urlString} via proxy: ${proxySettings.proxy}`);\n-        }\n-        const options: any = {};\n-        if (proxySettings.strictSSL) {\n-            options[\"rejectUnauthorized\"] = false;\n-        }\n-        const agent = makeHttpAgent(proxySettings.proxy, options);\n-        return fetch(urlString, { agent: agent });\n-    })();\n-\n-    if (!res.ok) {\n-        log.error(\"Error\", res.status, \"while downloading file from\", urlString);\n-        log.error({ body: await res.text(), headers: res.headers });\n-\n-        throw new Error(`Got response ${res.status} when trying to download a file.`);\n-    }\n-\n-    if (!res.body) {\n-        log.error(\"Empty body while downloading file from\", urlString);\n-        log.error({ headers: res.headers });\n-        throw new Error(`Got empty body when trying to download a file.`);\n-    }\n-\n-    const totalBytes = Number(res.headers.get('content-length'));\n-    assert(!Number.isNaN(totalBytes), \"Sanity check of content-length protocol\");\n-\n-    log.debug(\"Downloading file of\", totalBytes, \"bytes size from\", urlString, \"to\", destFilePath.fsPath);\n-\n-    let readBytes = 0;\n-    res.body.on(\"data\", (chunk: Buffer) => {\n-        readBytes += chunk.length;\n-        onProgress(readBytes, totalBytes);\n-    });\n-\n-    const destFileStream = fs.createWriteStream(destFilePath.fsPath, { mode });\n-    const srcStream = gunzip ? res.body.pipe(zlib.createGunzip()) : res.body;\n-\n-    await pipeline(srcStream, destFileStream);\n-}"}]}