{"sha": "50166d5e5e82ca795306824decbe4ffabcc23d3d", "node_id": "C_kwDOAAsO6NoAKDUwMTY2ZDVlNWU4MmNhNzk1MzA2ODI0ZGVjYmU0ZmZhYmNjMjNkM2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T09:49:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T09:49:06Z"}, "message": "Auto merge of #98748 - saethlin:optimize-bufreader, r=Mark-Simulacrum\n\nRemove some redundant checks from BufReader\n\nThe implementation of BufReader contains a lot of redundant checks. While any one of these checks is not particularly expensive to execute, especially when taken together they dramatically inhibit LLVM's ability to make subsequent optimizations by confusing data flow increasing the code size of anything that uses BufReader.\n\nIn particular, these changes have a ~2x increase on the benchmark that this adds a `black_box` to. I'm adding that `black_box` here just in case LLVM gets clever enough to remove the reads entirely. Right now it can't, but these optimizations are really setting it up to do so.\n\nWe get this optimization by factoring all the actual buffer management and bounds-checking logic into a new module inside `bufreader` with a new `Buffer` type. This makes it much easier to ensure that we have correctly encapsulated the management of the region of the buffer that we have read bytes into, and it lets us provide a new faster way to do small reads. `Buffer::consume_with` lets a caller do a read from the buffer with a single bounds check, instead of the double-check that's required to use `buffer` + `consume`.\n\nUnfortunately I'm not aware of a lot of open-source usage of `BufReader` in perf-critical environments. Some time ago I tweaked this code because I saw `BufReader` in a profile at work, and I contributed some benchmarks to the `bincode` crate which exercise `BufReader::buffer`. These changes appear to help those benchmarks at little, but all these sorts of benchmarks are kind of fragile so I'm wary of quoting anything specific.", "tree": {"sha": "99732b65bc45d0ede0078d7f8a0fbe263bd2c741", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99732b65bc45d0ede0078d7f8a0fbe263bd2c741"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50166d5e5e82ca795306824decbe4ffabcc23d3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50166d5e5e82ca795306824decbe4ffabcc23d3d", "html_url": "https://github.com/rust-lang/rust/commit/50166d5e5e82ca795306824decbe4ffabcc23d3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50166d5e5e82ca795306824decbe4ffabcc23d3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff693dc7b8119a1761edf0d08156bb670708824a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff693dc7b8119a1761edf0d08156bb670708824a", "html_url": "https://github.com/rust-lang/rust/commit/ff693dc7b8119a1761edf0d08156bb670708824a"}, {"sha": "5fa19266348c4d52d444bf8289851e374e38887d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa19266348c4d52d444bf8289851e374e38887d", "html_url": "https://github.com/rust-lang/rust/commit/5fa19266348c4d52d444bf8289851e374e38887d"}], "stats": {"total": 187, "additions": 134, "deletions": 53}, "files": [{"sha": "f7fbaa9c27649dfc9230079c7e5be6c095510246", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 28, "deletions": 53, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/50166d5e5e82ca795306824decbe4ffabcc23d3d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50166d5e5e82ca795306824decbe4ffabcc23d3d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=50166d5e5e82ca795306824decbe4ffabcc23d3d", "patch": "@@ -1,9 +1,10 @@\n-use crate::cmp;\n+mod buffer;\n+\n use crate::fmt;\n use crate::io::{\n     self, BufRead, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n };\n-use crate::mem::MaybeUninit;\n+use buffer::Buffer;\n \n /// The `BufReader<R>` struct adds buffering to any reader.\n ///\n@@ -48,10 +49,7 @@ use crate::mem::MaybeUninit;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufReader<R> {\n     inner: R,\n-    buf: Box<[MaybeUninit<u8>]>,\n-    pos: usize,\n-    cap: usize,\n-    init: usize,\n+    buf: Buffer,\n }\n \n impl<R: Read> BufReader<R> {\n@@ -93,8 +91,7 @@ impl<R: Read> BufReader<R> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n-        let buf = Box::new_uninit_slice(capacity);\n-        BufReader { inner, buf, pos: 0, cap: 0, init: 0 }\n+        BufReader { inner, buf: Buffer::with_capacity(capacity) }\n     }\n }\n \n@@ -170,8 +167,7 @@ impl<R> BufReader<R> {\n     /// ```\n     #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n     pub fn buffer(&self) -> &[u8] {\n-        // SAFETY: self.cap is always <= self.init, so self.buf[self.pos..self.cap] is always init\n-        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[self.pos..self.cap]) }\n+        self.buf.buffer()\n     }\n \n     /// Returns the number of bytes the internal buffer can hold at once.\n@@ -194,7 +190,7 @@ impl<R> BufReader<R> {\n     /// ```\n     #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.buf.len()\n+        self.buf.capacity()\n     }\n \n     /// Unwraps this `BufReader<R>`, returning the underlying reader.\n@@ -224,8 +220,7 @@ impl<R> BufReader<R> {\n     /// Invalidates all data in the internal buffer.\n     #[inline]\n     fn discard_buffer(&mut self) {\n-        self.pos = 0;\n-        self.cap = 0;\n+        self.buf.discard_buffer()\n     }\n }\n \n@@ -236,15 +231,15 @@ impl<R: Seek> BufReader<R> {\n     /// must track this information themselves if it is required.\n     #[stable(feature = \"bufreader_seek_relative\", since = \"1.53.0\")]\n     pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n-        let pos = self.pos as u64;\n+        let pos = self.buf.pos() as u64;\n         if offset < 0 {\n-            if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n-                self.pos = new_pos as usize;\n+            if let Some(_) = pos.checked_sub((-offset) as u64) {\n+                self.buf.unconsume((-offset) as usize);\n                 return Ok(());\n             }\n         } else if let Some(new_pos) = pos.checked_add(offset as u64) {\n-            if new_pos <= self.cap as u64 {\n-                self.pos = new_pos as usize;\n+            if new_pos <= self.buf.filled() as u64 {\n+                self.buf.consume(offset as usize);\n                 return Ok(());\n             }\n         }\n@@ -259,7 +254,7 @@ impl<R: Read> Read for BufReader<R> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.pos == self.cap && buf.len() >= self.buf.len() {\n+        if self.buf.pos() == self.buf.filled() && buf.len() >= self.capacity() {\n             self.discard_buffer();\n             return self.inner.read(buf);\n         }\n@@ -275,7 +270,7 @@ impl<R: Read> Read for BufReader<R> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.pos == self.cap && buf.remaining() >= self.buf.len() {\n+        if self.buf.pos() == self.buf.filled() && buf.remaining() >= self.capacity() {\n             self.discard_buffer();\n             return self.inner.read_buf(buf);\n         }\n@@ -295,9 +290,7 @@ impl<R: Read> Read for BufReader<R> {\n     // generation for the common path where the buffer has enough bytes to fill the passed-in\n     // buffer.\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n-        if self.buffer().len() >= buf.len() {\n-            buf.copy_from_slice(&self.buffer()[..buf.len()]);\n-            self.consume(buf.len());\n+        if self.buf.consume_with(buf.len(), |claimed| buf.copy_from_slice(claimed)) {\n             return Ok(());\n         }\n \n@@ -306,7 +299,7 @@ impl<R: Read> Read for BufReader<R> {\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-        if self.pos == self.cap && total_len >= self.buf.len() {\n+        if self.buf.pos() == self.buf.filled() && total_len >= self.capacity() {\n             self.discard_buffer();\n             return self.inner.read_vectored(bufs);\n         }\n@@ -325,8 +318,9 @@ impl<R: Read> Read for BufReader<R> {\n     // The inner reader might have an optimized `read_to_end`. Drain our buffer and then\n     // delegate to the inner implementation.\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let nread = self.cap - self.pos;\n-        buf.extend_from_slice(&self.buffer());\n+        let inner_buf = self.buffer();\n+        buf.extend_from_slice(inner_buf);\n+        let nread = inner_buf.len();\n         self.discard_buffer();\n         Ok(nread + self.inner.read_to_end(buf)?)\n     }\n@@ -371,33 +365,11 @@ impl<R: Read> Read for BufReader<R> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R: Read> BufRead for BufReader<R> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> {\n-        // If we've reached the end of our internal buffer then we need to fetch\n-        // some more data from the underlying reader.\n-        // Branch using `>=` instead of the more correct `==`\n-        // to tell the compiler that the pos..cap slice is always valid.\n-        if self.pos >= self.cap {\n-            debug_assert!(self.pos == self.cap);\n-\n-            let mut readbuf = ReadBuf::uninit(&mut self.buf);\n-\n-            // SAFETY: `self.init` is either 0 or set to `readbuf.initialized_len()`\n-            // from the last time this function was called\n-            unsafe {\n-                readbuf.assume_init(self.init);\n-            }\n-\n-            self.inner.read_buf(&mut readbuf)?;\n-\n-            self.cap = readbuf.filled_len();\n-            self.init = readbuf.initialized_len();\n-\n-            self.pos = 0;\n-        }\n-        Ok(self.buffer())\n+        self.buf.fill_buf(&mut self.inner)\n     }\n \n     fn consume(&mut self, amt: usize) {\n-        self.pos = cmp::min(self.pos + amt, self.cap);\n+        self.buf.consume(amt)\n     }\n }\n \n@@ -409,7 +381,10 @@ where\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufReader\")\n             .field(\"reader\", &self.inner)\n-            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n+            .field(\n+                \"buffer\",\n+                &format_args!(\"{}/{}\", self.buf.filled() - self.buf.pos(), self.capacity()),\n+            )\n             .finish()\n     }\n }\n@@ -441,7 +416,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n         let result: u64;\n         if let SeekFrom::Current(n) = pos {\n-            let remainder = (self.cap - self.pos) as i64;\n+            let remainder = (self.buf.filled() - self.buf.pos()) as i64;\n             // it should be safe to assume that remainder fits within an i64 as the alternative\n             // means we managed to allocate 8 exbibytes and that's absurd.\n             // But it's not out of the realm of possibility for some weird underlying reader to\n@@ -499,7 +474,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     /// }\n     /// ```\n     fn stream_position(&mut self) -> io::Result<u64> {\n-        let remainder = (self.cap - self.pos) as u64;\n+        let remainder = (self.buf.filled() - self.buf.pos()) as u64;\n         self.inner.stream_position().map(|pos| {\n             pos.checked_sub(remainder).expect(\n                 \"overflow when subtracting remaining buffer size from inner stream position\","}, {"sha": "8ae01f3b0ad8ac44d184aa0c666bc12b77d875f8", "filename": "library/std/src/io/buffered/bufreader/buffer.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/50166d5e5e82ca795306824decbe4ffabcc23d3d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50166d5e5e82ca795306824decbe4ffabcc23d3d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs?ref=50166d5e5e82ca795306824decbe4ffabcc23d3d", "patch": "@@ -0,0 +1,105 @@\n+///! An encapsulation of `BufReader`'s buffer management logic.\n+///\n+/// This module factors out the basic functionality of `BufReader` in order to protect two core\n+/// invariants:\n+/// * `filled` bytes of `buf` are always initialized\n+/// * `pos` is always <= `filled`\n+/// Since this module encapsulates the buffer management logic, we can ensure that the range\n+/// `pos..filled` is always a valid index into the initialized region of the buffer. This means\n+/// that user code which wants to do reads from a `BufReader` via `buffer` + `consume` can do so\n+/// without encountering any runtime bounds checks.\n+use crate::cmp;\n+use crate::io::{self, Read, ReadBuf};\n+use crate::mem::MaybeUninit;\n+\n+pub struct Buffer {\n+    // The buffer.\n+    buf: Box<[MaybeUninit<u8>]>,\n+    // The current seek offset into `buf`, must always be <= `filled`.\n+    pos: usize,\n+    // Each call to `fill_buf` sets `filled` to indicate how many bytes at the start of `buf` are\n+    // initialized with bytes from a read.\n+    filled: usize,\n+}\n+\n+impl Buffer {\n+    #[inline]\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        let buf = Box::new_uninit_slice(capacity);\n+        Self { buf, pos: 0, filled: 0 }\n+    }\n+\n+    #[inline]\n+    pub fn buffer(&self) -> &[u8] {\n+        // SAFETY: self.pos and self.cap are valid, and self.cap => self.pos, and\n+        // that region is initialized because those are all invariants of this type.\n+        unsafe { MaybeUninit::slice_assume_init_ref(self.buf.get_unchecked(self.pos..self.filled)) }\n+    }\n+\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.buf.len()\n+    }\n+\n+    #[inline]\n+    pub fn filled(&self) -> usize {\n+        self.filled\n+    }\n+\n+    #[inline]\n+    pub fn pos(&self) -> usize {\n+        self.pos\n+    }\n+\n+    #[inline]\n+    pub fn discard_buffer(&mut self) {\n+        self.pos = 0;\n+        self.filled = 0;\n+    }\n+\n+    #[inline]\n+    pub fn consume(&mut self, amt: usize) {\n+        self.pos = cmp::min(self.pos + amt, self.filled);\n+    }\n+\n+    /// If there are `amt` bytes available in the buffer, pass a slice containing those bytes to\n+    /// `visitor` and return true. If there are not enough bytes available, return false.\n+    #[inline]\n+    pub fn consume_with<V>(&mut self, amt: usize, mut visitor: V) -> bool\n+    where\n+        V: FnMut(&[u8]),\n+    {\n+        if let Some(claimed) = self.buffer().get(..amt) {\n+            visitor(claimed);\n+            // If the indexing into self.buffer() succeeds, amt must be a valid increment.\n+            self.pos += amt;\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn unconsume(&mut self, amt: usize) {\n+        self.pos = self.pos.saturating_sub(amt);\n+    }\n+\n+    #[inline]\n+    pub fn fill_buf(&mut self, mut reader: impl Read) -> io::Result<&[u8]> {\n+        // If we've reached the end of our internal buffer then we need to fetch\n+        // some more data from the reader.\n+        // Branch using `>=` instead of the more correct `==`\n+        // to tell the compiler that the pos..cap slice is always valid.\n+        if self.pos >= self.filled {\n+            debug_assert!(self.pos == self.filled);\n+\n+            let mut readbuf = ReadBuf::uninit(&mut self.buf);\n+\n+            reader.read_buf(&mut readbuf)?;\n+\n+            self.filled = readbuf.filled_len();\n+            self.pos = 0;\n+        }\n+        Ok(self.buffer())\n+    }\n+}"}, {"sha": "fe45b1326384416239fd6c04ef767967698556fe", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50166d5e5e82ca795306824decbe4ffabcc23d3d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50166d5e5e82ca795306824decbe4ffabcc23d3d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=50166d5e5e82ca795306824decbe4ffabcc23d3d", "patch": "@@ -523,6 +523,7 @@ fn bench_buffered_reader_small_reads(b: &mut test::Bencher) {\n         let mut buf = [0u8; 4];\n         for _ in 0..1024 {\n             reader.read_exact(&mut buf).unwrap();\n+            core::hint::black_box(&buf);\n         }\n     });\n }"}]}