{"sha": "ac0bb4126c835ea89313cbb4f534c37bc14a2694", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMGJiNDEyNmM4MzVlYTg5MzEzY2JiNGY1MzRjMzdiYzE0YTI2OTQ=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-26T20:53:38Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-28T00:08:01Z"}, "message": "Improve markdown parsing for the doc lint", "tree": {"sha": "55622fb67c660006710af042312b7ff5375493c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55622fb67c660006710af042312b7ff5375493c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac0bb4126c835ea89313cbb4f534c37bc14a2694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac0bb4126c835ea89313cbb4f534c37bc14a2694", "html_url": "https://github.com/rust-lang/rust/commit/ac0bb4126c835ea89313cbb4f534c37bc14a2694", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac0bb4126c835ea89313cbb4f534c37bc14a2694/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71b41b6e01af2a68490f219a59a183873f5e1c64", "url": "https://api.github.com/repos/rust-lang/rust/commits/71b41b6e01af2a68490f219a59a183873f5e1c64", "html_url": "https://github.com/rust-lang/rust/commit/71b41b6e01af2a68490f219a59a183873f5e1c64"}], "stats": {"total": 205, "additions": 128, "deletions": 77}, "files": [{"sha": "fd4640c21584e399c3d99b38e64afa708a977772", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 121, "deletions": 77, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/ac0bb4126c835ea89313cbb4f534c37bc14a2694/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac0bb4126c835ea89313cbb4f534c37bc14a2694/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=ac0bb4126c835ea89313cbb4f534c37bc14a2694", "patch": "@@ -51,6 +51,8 @@ impl EarlyLintPass for Doc {\n }\n \n pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n+    let mut docs = vec![];\n+\n     let mut in_multiline = false;\n     for attr in attrs {\n         if attr.node.is_sugared_doc {\n@@ -66,37 +68,20 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n                         in_multiline = !in_multiline;\n                     }\n                     if !in_multiline {\n-                        check_doc(cx, valid_idents, real_doc, span);\n+                        docs.push((real_doc, span));\n                     }\n                 }\n             }\n         }\n     }\n-}\n-\n-macro_rules! jump_to {\n-    // Get the next character\u2019s first byte UTF-8 friendlyly.\n-    (@next_char, $chars: expr, $len: expr) => {{\n-        if let Some(&(pos, _)) = $chars.peek() {\n-            pos\n-        } else {\n-            $len\n-        }\n-    }};\n \n-    // Jump to the next `$c`. If no such character is found, give up.\n-    ($chars: expr, $c: expr, $len: expr) => {{\n-        if $chars.find(|&(_, c)| c == $c).is_some() {\n-            jump_to!(@next_char, $chars, $len)\n-        }\n-        else {\n-            return;\n-        }\n-    }};\n+    for (doc, span) in docs {\n+        let _ = check_doc(cx, valid_idents, doc, span);\n+    }\n }\n \n #[allow(while_let_loop)] // #362\n-pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Span) {\n+pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Span) -> Result<(), ()> {\n     // In markdown, `_` can be used to emphasize something, or, is a raw `_` depending on context.\n     // There really is no markdown specification that would disambiguate this properly. This is\n     // what GitHub and Rustdoc do:\n@@ -108,90 +93,149 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n     // (_baz_)             \u2192 (<em>baz</em>)\n     // foo _ bar _ baz     \u2192 foo _ bar _ baz\n \n-    /// Character that can appear in a word\n-    fn is_word_char(c: char) -> bool {\n+    /// Character that can appear in a path\n+    fn is_path_char(c: char) -> bool {\n         match c {\n             t if t.is_alphanumeric() => true,\n             ':' | '_' => true,\n             _ => false,\n         }\n     }\n \n-    #[allow(cast_possible_truncation)]\n-    fn word_span(mut span: Span, begin: usize, end: usize) -> Span {\n-        debug_assert_eq!(end as u32 as usize, end);\n-        debug_assert_eq!(begin as u32 as usize, begin);\n-        span.hi = span.lo + BytePos(end as u32);\n-        span.lo = span.lo + BytePos(begin as u32);\n-        span\n+    #[derive(Clone, Debug)]\n+    struct Parser<'a> {\n+        link: bool,\n+        line: &'a str,\n+        span: Span,\n+        current_word_begin: usize,\n+        new_line: bool,\n+        pos: usize,\n+    }\n+\n+    impl<'a> Parser<'a> {\n+        fn advance_begin(&mut self) {\n+            self.current_word_begin = self.pos;\n+        }\n+\n+        fn peek(&self) -> Option<char> {\n+            self.line[self.pos..].chars().next()\n+        }\n+\n+        fn jump_to(&mut self, n: char) -> Result<(), ()> {\n+            while let Some(c) = self.next() {\n+                if c == n {\n+                    self.advance_begin();\n+                    return Ok(());\n+                }\n+            }\n+\n+            return Err(());\n+        }\n+\n+        fn put_back(&mut self, c: char) {\n+            self.pos -= c.len_utf8();\n+        }\n+\n+        #[allow(cast_possible_truncation)]\n+        fn word(&self) -> (&'a str, Span) {\n+            let begin = self.current_word_begin;\n+            let end = self.pos;\n+\n+            debug_assert_eq!(end as u32 as usize, end);\n+            debug_assert_eq!(begin as u32 as usize, begin);\n+\n+            let mut span = self.span;\n+            span.hi = span.lo + BytePos(end as u32);\n+            span.lo = span.lo + BytePos(begin as u32);\n+\n+            (&self.line[begin..end], span)\n+        }\n+    }\n+\n+    impl<'a> Iterator for Parser<'a> {\n+        type Item = char;\n+\n+        fn next(&mut self) -> Option<char> {\n+            let mut chars = self.line[self.pos..].chars();\n+            let c = chars.next();\n+\n+            if let Some(c) = c {\n+                self.pos += c.len_utf8();\n+            } else {\n+                // TODO: new line\n+            }\n+\n+            c\n+        }\n     }\n \n-    let mut new_line = true;\n-    let len = doc.len();\n-    let mut chars = doc.char_indices().peekable();\n-    let mut current_word_begin = 0;\n+    let mut parser = Parser {\n+        link: false,\n+        line: doc,\n+        span: span,\n+        current_word_begin: 0,\n+        new_line: true,\n+        pos: 0,\n+    };\n+\n     loop {\n-        match chars.next() {\n-            Some((_, c)) => {\n+        match parser.next() {\n+            Some(c) => {\n                 match c {\n                     '#' if new_line => { // don\u2019t warn on titles\n-                        current_word_begin = jump_to!(chars, '\\n', len);\n+                        try!(parser.jump_to('\\n'));\n                     }\n                     '`' => {\n-                        current_word_begin = jump_to!(chars, '`', len);\n+                        try!(parser.jump_to('`'));\n                     }\n                     '[' => {\n-                        let end = jump_to!(chars, ']', len);\n-                        let link_text = &doc[current_word_begin + 1..end];\n-                        let word_span = word_span(span, current_word_begin + 1, end + 1);\n-\n-                        match chars.peek() {\n-                            Some(&(_, c)) => {\n-                                // Trying to parse a link. Let\u2019s ignore the link.\n-\n-                                // FIXME: how does markdown handles such link?\n-                                // https://en.wikipedia.org/w/index.php?title=)\n-                                match c {\n-                                    '(' => { // inline link\n-                                        current_word_begin = jump_to!(chars, ')', len);\n-                                        check_doc(cx, valid_idents, link_text, word_span);\n-                                    }\n-                                    '[' => { // reference link\n-                                        current_word_begin = jump_to!(chars, ']', len);\n-                                        check_doc(cx, valid_idents, link_text, word_span);\n-                                    }\n-                                    ':' => { // reference link\n-                                        current_word_begin = jump_to!(chars, '\\n', len);\n-                                    }\n-                                    _ => { // automatic reference link\n-                                        current_word_begin = jump_to!(@next_char, chars, len);\n-                                        check_doc(cx, valid_idents, link_text, word_span);\n-                                    }\n+                        // Check for a reference definition `[foo]:` at the beginning of a line\n+                        let mut link = true;\n+                        if parser.new_line {\n+                            let mut lookup_parser = parser.clone();\n+                            if let Some(_) = lookup_parser.find(|&c| c == ']') {\n+                                if let Some(':') = lookup_parser.next() {\n+                                    try!(lookup_parser.jump_to(')'));\n+                                    parser = lookup_parser;\n+                                    link = false;\n                                 }\n                             }\n-                            None => return,\n+                        }\n+\n+                        parser.advance_begin();\n+                        parser.link = link;\n+                    }\n+                    ']' if parser.link => {\n+                        parser.link = false;\n+\n+                        match parser.peek() {\n+                            Some('(') => try!(parser.jump_to(')')),\n+                            Some('[') => try!(parser.jump_to(']')),\n+                            Some(_) => continue,\n+                            None => return Err(()),\n                         }\n                     }\n-                    // anything that\u2019s neither alphanumeric nor '_' is not part of an ident anyway\n-                    c if !c.is_alphanumeric() && c != '_' => {\n-                        current_word_begin = jump_to!(@next_char, chars, len);\n+                    c if !is_path_char(c) => {\n+                        parser.advance_begin();\n                     }\n                     _ => {\n-                        let end = match chars.find(|&(_, c)| !is_word_char(c)) {\n-                            Some((end, _)) => end,\n-                            None => len,\n-                        };\n-                        let word_span = word_span(span, current_word_begin, end);\n-                        check_word(cx, valid_idents, &doc[current_word_begin..end], word_span);\n-                        current_word_begin = jump_to!(@next_char, chars, len);\n+                        if let Some(c) = parser.find(|&c| !is_path_char(c)) {\n+                            parser.put_back(c);\n+                        }\n+\n+                        let (word, span) = parser.word();\n+                        check_word(cx, valid_idents, word, span);\n+                        parser.advance_begin();\n                     }\n                 }\n \n-                new_line = c == '\\n' || (new_line && c.is_whitespace());\n+                parser.new_line = c == '\\n' || (parser.new_line && c.is_whitespace());\n             }\n             None => break,\n         }\n     }\n+\n+    Ok(())\n }\n \n fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span) {"}, {"sha": "f5c1e4768e9788de8d420ff94267a37cf78ec9ee", "filename": "tests/compile-fail/doc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac0bb4126c835ea89313cbb4f534c37bc14a2694/tests%2Fcompile-fail%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac0bb4126c835ea89313cbb4f534c37bc14a2694/tests%2Fcompile-fail%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdoc.rs?ref=ac0bb4126c835ea89313cbb4f534c37bc14a2694", "patch": "@@ -12,6 +12,8 @@\n /// Markdown is _weird_. I mean _really weird_.  This \\_ is ok. So is `_`. But not Foo::some_fun\n //~^ ERROR: you should put `Foo::some_fun` between ticks\n /// which should be reported only once despite being __doubly bad__.\n+/// Here be ::is::a::global:path.\n+//~^ ERROR: you should put `is::a::global:path` between ticks\n /// be_sure_we_got_to_the_end_of_it\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn foo_bar() {\n@@ -141,3 +143,8 @@ fn issue900() {\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn issue883() {\n }\n+\n+/// `foo_bar\n+/// baz_quz`\n+fn multiline() {\n+}"}]}