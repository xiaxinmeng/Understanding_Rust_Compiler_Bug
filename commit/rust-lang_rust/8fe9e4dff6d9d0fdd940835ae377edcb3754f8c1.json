{"sha": "8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZTllNGRmZjZkOWQwZmRkOTQwODM1YWUzNzdlZGNiMzc1NGY4YzE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-15T20:41:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-22T17:27:07Z"}, "message": "Insert coercions to fn pointer types required for the new types\npost-unboxed-closure-conversion. This requires a fair amount of\nannoying coercions because all the `map` etc types are defined\ngenerically over the `F`, so the automatic coercions don't propagate;\nthis is compounded by the need to use `let` and not `as` due to\nstage0. That said, this pattern is to a large extent temporary and\nunusual.", "tree": {"sha": "f6a8b3551df4061a76323418007569709e34dcdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6a8b3551df4061a76323418007569709e34dcdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "html_url": "https://github.com/rust-lang/rust/commit/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f6177e64627110e5b9776bd5304d65806081390", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f6177e64627110e5b9776bd5304d65806081390", "html_url": "https://github.com/rust-lang/rust/commit/7f6177e64627110e5b9776bd5304d65806081390"}], "stats": {"total": 35, "additions": 31, "deletions": 4}, "files": [{"sha": "778314f352c251c2a8be676c08de28648e11e373", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -1230,6 +1230,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n \n         Keys { inner: self.iter().map(first) }\n     }\n@@ -1251,6 +1252,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n \n         Values { inner: self.iter().map(second) }\n     }"}, {"sha": "4ab9c7a4fcdd902436abd3e7ded0861a53ac83d0", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -126,6 +126,7 @@ impl<T> BTreeSet<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveItems<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n \n         MoveItems { iter: self.map.into_iter().map(first) }\n     }"}, {"sha": "553eae4d896d16e7cc33e1ab7d60b78268a28a00", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -144,6 +144,7 @@ impl<V> VecMap<V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n \n         Keys { iter: self.iter().map(first) }\n     }\n@@ -153,6 +154,7 @@ impl<V> VecMap<V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n \n         Values { iter: self.iter().map(second) }\n     }\n@@ -239,6 +241,7 @@ impl<V> VecMap<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n         }\n+        let filter: fn((uint, Option<V>)) -> Option<(uint, V)> = filter; // coerce to fn ptr\n \n         let values = replace(&mut self.v, vec!());\n         MoveItems { iter: values.into_iter().enumerate().filter_map(filter) }"}, {"sha": "1cd4d7b89d6d66bd303b2bfd3f083b5d1375e42a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -2612,6 +2612,9 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n         val.clone()\n     }\n \n+    // coerce to a fn pointer\n+    let next: fn(&mut IterateState<T,F>) -> Option<T> = next;\n+\n     Unfold::new((f, Some(seed), true), next)\n }\n "}, {"sha": "1207c78fa37b99ee3689a0a8cd6cb3b9043304b3", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -2101,6 +2101,7 @@ impl StrPrelude for str {\n             else { line }\n         }\n \n+        let f: fn(&str) -> &str = f; // coerce to fn pointer\n         self.lines().map(f)\n     }\n "}, {"sha": "ab25343ff5fe0c46e4832c70fe7cf641eb11ba3f", "filename": "src/librustc_trans/trans/basic_block.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -37,7 +37,10 @@ impl BasicBlock {\n \n     pub fn pred_iter(self) -> Preds {\n         fn is_a_terminator_inst(user: &Value) -> bool { user.is_a_terminator_inst() }\n+        let is_a_terminator_inst: fn(&Value) -> bool = is_a_terminator_inst;\n+\n         fn get_parent(user: Value) -> BasicBlock { user.get_parent().unwrap() }\n+        let get_parent: fn(Value) -> BasicBlock = get_parent;\n \n         self.as_value().user_iter()\n             .filter(is_a_terminator_inst)"}, {"sha": "dc9fd289344705322b9a1408b0d0901dc48fc599", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -838,8 +838,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn keys(&self) -> Keys<K, V> {\n+    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n \n         Keys { inner: self.iter().map(first) }\n     }\n@@ -862,8 +863,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn values(&self) -> Values<K, V> {\n+    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n \n         Values { inner: self.iter().map(second) }\n     }\n@@ -938,6 +940,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n \n         MoveEntries {\n             inner: self.table.into_iter().map(last_two)\n@@ -1007,6 +1010,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn drain(&mut self) -> Drain<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two; // coerce to fn pointer\n \n         Drain {\n             inner: self.table.drain().map(last_two),"}, {"sha": "15ac3394d41765b8258f7f4d45beadf9e6378348", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -277,6 +277,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first;\n \n         IntoIter { iter: self.map.into_iter().map(first) }\n     }\n@@ -419,6 +420,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn drain(&mut self) -> Drain<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n+\n         Drain { iter: self.map.drain().map(first) }\n     }\n "}, {"sha": "0808b2a4f4258a24bc97c29408a5227824e90f29", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -390,6 +390,7 @@ impl Path {\n         let v = if self.repr[0] == SEP_BYTE {\n             self.repr[1..]\n         } else { self.repr.as_slice() };\n+        let is_sep_byte: fn(&u8) -> bool = is_sep_byte; // coerce to fn ptr\n         let mut ret = v.split(is_sep_byte);\n         if v.is_empty() {\n             // consume the empty \"\" component\n@@ -401,7 +402,8 @@ impl Path {\n     /// Returns an iterator that yields each component of the path as Option<&str>.\n     /// See components() for details.\n     pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n-        self.components().map(str::from_utf8)\n+        let from_utf8: fn(&[u8]) -> Option<&str> = str::from_utf8; // coerce to fn ptr\n+        self.components().map(from_utf8)\n     }\n }\n "}, {"sha": "4b8fb7fad6a389f7ca289fcf58d1a4ee9fa9aff3", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -655,7 +655,8 @@ impl Path {\n             None if repr.as_bytes()[0] == SEP_BYTE => repr.slice_from(1),\n             None => repr\n         };\n-        let ret = s.split_terminator(SEP).map(Some);\n+        let some: fn(&'a str) -> Option<&'a str> = Some; // coerce to fn ptr\n+        let ret = s.split_terminator(SEP).map(some);\n         ret\n     }\n \n@@ -666,6 +667,7 @@ impl Path {\n             #![inline]\n             x.unwrap().as_bytes()\n         }\n+        let convert: for<'b> fn(Option<&'b str>) -> &'b [u8] = convert; // coerce to fn ptr\n         self.str_components().map(convert)\n     }\n "}, {"sha": "88d87717ff3e86d0c56529a16827828b28c1dd5f", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=8fe9e4dff6d9d0fdd940835ae377edcb3754f8c1", "patch": "@@ -143,7 +143,10 @@ impl UnicodeStrPrelude for str {\n     #[inline]\n     fn words(&self) -> Words {\n         fn is_not_empty(s: &&str) -> bool { !s.is_empty() }\n+        let is_not_empty: fn(&&str) -> bool = is_not_empty; // coerce to fn pointer\n+\n         fn is_whitespace(c: char) -> bool { c.is_whitespace() }\n+        let is_whitespace: fn(char) -> bool = is_whitespace; // coerce to fn pointer\n \n         self.split(is_whitespace).filter(is_not_empty)\n     }"}]}