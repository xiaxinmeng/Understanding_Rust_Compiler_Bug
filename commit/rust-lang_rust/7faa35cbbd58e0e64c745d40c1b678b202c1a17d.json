{"sha": "7faa35cbbd58e0e64c745d40c1b678b202c1a17d", "node_id": "C_kwDOAAsO6NoAKDdmYWEzNWNiYmQ1OGUwZTY0Yzc0NWQ0MGMxYjY3OGIyMDJjMWExN2Q", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-04T13:16:13Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-04T13:16:13Z"}, "message": "Simplify", "tree": {"sha": "eeb0922d371cd067a04b68d6c77c61aeba80803e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeb0922d371cd067a04b68d6c77c61aeba80803e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7faa35cbbd58e0e64c745d40c1b678b202c1a17d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7faa35cbbd58e0e64c745d40c1b678b202c1a17d", "html_url": "https://github.com/rust-lang/rust/commit/7faa35cbbd58e0e64c745d40c1b678b202c1a17d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7faa35cbbd58e0e64c745d40c1b678b202c1a17d/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b7675fcc30d3e2c05eafc68a5724db66b58142c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b7675fcc30d3e2c05eafc68a5724db66b58142c", "html_url": "https://github.com/rust-lang/rust/commit/4b7675fcc30d3e2c05eafc68a5724db66b58142c"}], "stats": {"total": 201, "additions": 45, "deletions": 156}, "files": [{"sha": "55c49c2322866319968815f62d61a97c7418993b", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 38, "deletions": 150, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/7faa35cbbd58e0e64c745d40c1b678b202c1a17d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faa35cbbd58e0e64c745d40c1b678b202c1a17d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=7faa35cbbd58e0e64c745d40c1b678b202c1a17d", "patch": "@@ -53,24 +53,21 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(it) => it,\n         None => return,\n     };\n+\n+    let postfix_snippet = build_postfix_snippet_builder(ctx, cap, &dot_receiver);\n+\n     let try_enum = TryEnum::from_ty(&ctx.sema, &receiver_ty.strip_references());\n     if let Some(try_enum) = &try_enum {\n         match try_enum {\n             TryEnum::Result => {\n                 postfix_snippet(\n-                    ctx,\n-                    cap,\n-                    dot_receiver,\n                     \"ifl\",\n                     \"if let Ok {}\",\n                     &format!(\"if let Ok($1) = {} {{\\n    $0\\n}}\", receiver_text),\n                 )\n                 .add_to(acc);\n \n                 postfix_snippet(\n-                    ctx,\n-                    cap,\n-                    dot_receiver,\n                     \"while\",\n                     \"while let Ok {}\",\n                     &format!(\"while let Ok($1) = {} {{\\n    $0\\n}}\", receiver_text),\n@@ -79,19 +76,13 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n             }\n             TryEnum::Option => {\n                 postfix_snippet(\n-                    ctx,\n-                    cap,\n-                    dot_receiver,\n                     \"ifl\",\n                     \"if let Some {}\",\n                     &format!(\"if let Some($1) = {} {{\\n    $0\\n}}\", receiver_text),\n                 )\n                 .add_to(acc);\n \n                 postfix_snippet(\n-                    ctx,\n-                    cap,\n-                    dot_receiver,\n                     \"while\",\n                     \"while let Some {}\",\n                     &format!(\"while let Some($1) = {} {{\\n    $0\\n}}\", receiver_text),\n@@ -100,32 +91,18 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n             }\n         }\n     } else if receiver_ty.is_bool() || receiver_ty.is_unknown() {\n+        postfix_snippet(\"if\", \"if expr {}\", &format!(\"if {} {{\\n    $0\\n}}\", receiver_text))\n+            .add_to(acc);\n         postfix_snippet(\n-            ctx,\n-            cap,\n-            dot_receiver,\n-            \"if\",\n-            \"if expr {}\",\n-            &format!(\"if {} {{\\n    $0\\n}}\", receiver_text),\n-        )\n-        .add_to(acc);\n-        postfix_snippet(\n-            ctx,\n-            cap,\n-            dot_receiver,\n             \"while\",\n             \"while expr {}\",\n             &format!(\"while {} {{\\n    $0\\n}}\", receiver_text),\n         )\n         .add_to(acc);\n-        postfix_snippet(ctx, cap, dot_receiver, \"not\", \"!expr\", &format!(\"!{}\", receiver_text))\n-            .add_to(acc);\n+        postfix_snippet(\"not\", \"!expr\", &format!(\"!{}\", receiver_text)).add_to(acc);\n     } else if let Some(trait_) = FamousDefs(&ctx.sema, ctx.krate).core_iter_IntoIterator() {\n         if receiver_ty.impls_trait(ctx.db, trait_, &[]) {\n             postfix_snippet(\n-                ctx,\n-                cap,\n-                dot_receiver,\n                 \"for\",\n                 \"for ele in expr {}\",\n                 &format!(\"for ele in {} {{\\n    $0\\n}}\", receiver_text),\n@@ -134,30 +111,19 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n     }\n \n-    postfix_snippet(ctx, cap, dot_receiver, \"ref\", \"&expr\", &format!(\"&{}\", receiver_text))\n-        .add_to(acc);\n-    postfix_snippet(\n-        ctx,\n-        cap,\n-        dot_receiver,\n-        \"refm\",\n-        \"&mut expr\",\n-        &format!(\"&mut {}\", receiver_text),\n-    )\n-    .add_to(acc);\n+    postfix_snippet(\"ref\", \"&expr\", &format!(\"&{}\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"refm\", \"&mut expr\", &format!(\"&mut {}\", receiver_text)).add_to(acc);\n \n     // The rest of the postfix completions create an expression that moves an argument,\n     // so it's better to consider references now to avoid breaking the compilation\n     let dot_receiver = include_references(dot_receiver);\n     let receiver_text = get_receiver_text(&dot_receiver, receiver_is_ambiguous_float_literal);\n+    let postfix_snippet = build_postfix_snippet_builder(ctx, cap, &dot_receiver);\n \n     match try_enum {\n         Some(try_enum) => match try_enum {\n             TryEnum::Result => {\n                 postfix_snippet(\n-                    ctx,\n-                    cap,\n-                    &dot_receiver,\n                     \"match\",\n                     \"match expr {}\",\n                     &format!(\"match {} {{\\n    Ok(${{1:_}}) => {{$2}},\\n    Err(${{3:_}}) => {{$0}},\\n}}\", receiver_text),\n@@ -166,9 +132,6 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n             }\n             TryEnum::Option => {\n                 postfix_snippet(\n-                    ctx,\n-                    cap,\n-                    &dot_receiver,\n                     \"match\",\n                     \"match expr {}\",\n                     &format!(\n@@ -181,9 +144,6 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         },\n         None => {\n             postfix_snippet(\n-                ctx,\n-                cap,\n-                &dot_receiver,\n                 \"match\",\n                 \"match expr {}\",\n                 &format!(\"match {} {{\\n    ${{1:_}} => {{$0}},\\n}}\", receiver_text),\n@@ -192,89 +152,19 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n     }\n \n-    postfix_snippet(\n-        ctx,\n-        cap,\n-        &dot_receiver,\n-        \"box\",\n-        \"Box::new(expr)\",\n-        &format!(\"Box::new({})\", receiver_text),\n-    )\n-    .add_to(acc);\n-\n-    postfix_snippet(ctx, cap, &dot_receiver, \"ok\", \"Ok(expr)\", &format!(\"Ok({})\", receiver_text))\n-        .add_to(acc);\n-\n-    postfix_snippet(\n-        ctx,\n-        cap,\n-        &dot_receiver,\n-        \"err\",\n-        \"Err(expr)\",\n-        &format!(\"Err({})\", receiver_text),\n-    )\n-    .add_to(acc);\n-\n-    postfix_snippet(\n-        ctx,\n-        cap,\n-        &dot_receiver,\n-        \"some\",\n-        \"Some(expr)\",\n-        &format!(\"Some({})\", receiver_text),\n-    )\n-    .add_to(acc);\n-\n-    postfix_snippet(\n-        ctx,\n-        cap,\n-        &dot_receiver,\n-        \"dbg\",\n-        \"dbg!(expr)\",\n-        &format!(\"dbg!({})\", receiver_text),\n-    )\n-    .add_to(acc);\n-\n-    postfix_snippet(\n-        ctx,\n-        cap,\n-        &dot_receiver,\n-        \"dbgr\",\n-        \"dbg!(&expr)\",\n-        &format!(\"dbg!(&{})\", receiver_text),\n-    )\n-    .add_to(acc);\n-\n-    postfix_snippet(\n-        ctx,\n-        cap,\n-        &dot_receiver,\n-        \"call\",\n-        \"function(expr)\",\n-        &format!(\"${{1}}({})\", receiver_text),\n-    )\n-    .add_to(acc);\n+    postfix_snippet(\"box\", \"Box::new(expr)\", &format!(\"Box::new({})\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"ok\", \"Ok(expr)\", &format!(\"Ok({})\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"err\", \"Err(expr)\", &format!(\"Err({})\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"some\", \"Some(expr)\", &format!(\"Some({})\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"dbg\", \"dbg!(expr)\", &format!(\"dbg!({})\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"dbgr\", \"dbg!(&expr)\", &format!(\"dbg!(&{})\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"call\", \"function(expr)\", &format!(\"${{1}}({})\", receiver_text)).add_to(acc);\n \n     if let Some(parent) = dot_receiver.syntax().parent().and_then(|p| p.parent()) {\n         if matches!(parent.kind(), STMT_LIST | EXPR_STMT) {\n-            postfix_snippet(\n-                ctx,\n-                cap,\n-                &dot_receiver,\n-                \"let\",\n-                \"let\",\n-                &format!(\"let $0 = {};\", receiver_text),\n-            )\n-            .add_to(acc);\n-            postfix_snippet(\n-                ctx,\n-                cap,\n-                &dot_receiver,\n-                \"letm\",\n-                \"let mut\",\n-                &format!(\"let mut $0 = {};\", receiver_text),\n-            )\n-            .add_to(acc);\n+            postfix_snippet(\"let\", \"let\", &format!(\"let $0 = {};\", receiver_text)).add_to(acc);\n+            postfix_snippet(\"letm\", \"let mut\", &format!(\"let mut $0 = {};\", receiver_text))\n+                .add_to(acc);\n         }\n     }\n \n@@ -305,29 +195,27 @@ fn include_references(initial_element: &ast::Expr) -> ast::Expr {\n     resulting_element\n }\n \n-fn postfix_snippet(\n-    ctx: &CompletionContext,\n+fn build_postfix_snippet_builder<'a>(\n+    ctx: &'a CompletionContext,\n     cap: SnippetCap,\n-    receiver: &ast::Expr,\n-    label: &str,\n-    detail: &str,\n-    snippet: &str,\n-) -> Builder {\n-    let edit = {\n-        let receiver_syntax = receiver.syntax();\n-        let receiver_range = ctx.sema.original_range(receiver_syntax).range;\n-        let delete_range = TextRange::new(receiver_range.start(), ctx.source_range().end());\n-        TextEdit::replace(delete_range, snippet.to_string())\n-    };\n-    let mut item = CompletionItem::new(CompletionKind::Postfix, ctx.source_range(), label);\n-    item.detail(detail).kind(CompletionItemKind::Snippet).snippet_edit(cap, edit);\n-    if ctx.original_token.text() == label {\n-        let relevance =\n-            CompletionRelevance { exact_postfix_snippet_match: true, ..Default::default() };\n-        item.set_relevance(relevance);\n-    }\n+    receiver: &'a ast::Expr,\n+) -> impl Fn(&str, &str, &str) -> Builder + 'a {\n+    let receiver_syntax = receiver.syntax();\n+    let receiver_range = ctx.sema.original_range(receiver_syntax).range;\n+    let delete_range = TextRange::new(receiver_range.start(), ctx.source_range().end());\n+\n+    move |label, detail, snippet| {\n+        let edit = TextEdit::replace(delete_range, snippet.to_string());\n+        let mut item = CompletionItem::new(CompletionKind::Postfix, ctx.source_range(), label);\n+        item.detail(detail).kind(CompletionItemKind::Snippet).snippet_edit(cap, edit);\n+        if ctx.original_token.text() == label {\n+            let relevance =\n+                CompletionRelevance { exact_postfix_snippet_match: true, ..Default::default() };\n+            item.set_relevance(relevance);\n+        }\n \n-    item\n+        item\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "4fd8d038e75bbcf210428943f09e41a1259e6194", "filename": "crates/ide_completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7faa35cbbd58e0e64c745d40c1b678b202c1a17d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faa35cbbd58e0e64c745d40c1b678b202c1a17d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=7faa35cbbd58e0e64c745d40c1b678b202c1a17d", "patch": "@@ -19,7 +19,9 @@\n use ide_db::helpers::SnippetCap;\n use syntax::ast::{self, AstToken};\n \n-use crate::{completions::postfix::postfix_snippet, context::CompletionContext, Completions};\n+use crate::{\n+    completions::postfix::build_postfix_snippet_builder, context::CompletionContext, Completions,\n+};\n \n /// Mapping (\"postfix completion item\" => \"macro to use\")\n static KINDS: &[(&str, &str)] = &[\n@@ -47,13 +49,14 @@ pub(crate) fn add_format_like_completions(\n         None => return,\n     };\n \n+    let postfix_snippet = build_postfix_snippet_builder(ctx, cap, dot_receiver);\n     let mut parser = FormatStrParser::new(input);\n \n     if parser.parse().is_ok() {\n         for (label, macro_name) in KINDS {\n             let snippet = parser.to_suggestion(macro_name);\n \n-            postfix_snippet(ctx, cap, dot_receiver, label, macro_name, &snippet).add_to(acc);\n+            postfix_snippet(label, macro_name, &snippet).add_to(acc);\n         }\n     }\n }"}, {"sha": "5ea58b74fe304a8bb99ae4ad13757065b53e079c", "filename": "crates/ide_diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7faa35cbbd58e0e64c745d40c1b678b202c1a17d/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faa35cbbd58e0e64c745d40c1b678b202c1a17d/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=7faa35cbbd58e0e64c745d40c1b678b202c1a17d", "patch": "@@ -45,16 +45,14 @@ fn fixes(ctx: &DiagnosticsContext, file_id: FileId) -> Option<Vec<Assist>> {\n     // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n     let parent = our_path.parent()?;\n     let paths = {\n-        let temp;\n         let parent = if module_name == \"mod\" {\n             // for mod.rs we need to actually look up one higher\n             // and take the parent as our to be module name\n             let (name, _) = parent.name_and_extension()?;\n             module_name = name;\n-            temp = parent.parent()?;\n-            &temp\n+            parent.parent()?\n         } else {\n-            &parent\n+            parent\n         };\n         let mut paths =\n             vec![parent.join(\"mod.rs\")?, parent.join(\"lib.rs\")?, parent.join(\"main.rs\")?];"}]}