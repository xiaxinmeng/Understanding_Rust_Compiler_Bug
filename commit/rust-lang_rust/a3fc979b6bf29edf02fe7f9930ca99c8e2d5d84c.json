{"sha": "a3fc979b6bf29edf02fe7f9930ca99c8e2d5d84c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZmM5NzliNmJmMjllZGYwMmZlN2Y5OTMwY2E5OWM4ZTJkNWQ4NGM=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-07-03T09:30:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-03T09:30:59Z"}, "message": "Rollup merge of #51809 - drrlvn:rw_exact_all_at, r=alexcrichton\n\nAdd read_exact_at and write_all_at methods to FileExt on unix\n\nThis PR adds `FileExt::read_exact_at()` and `FileExt::write_all_at()`, which are to `read_at()` and `write_at()` as `read_exact()` and `write_all()` are to `read()` and `write()`. This allows the user to not have to deal with `ErrorKind::Interrupted` and calling the functions in a loop.\n\nI was unsure as to how to mark these new methods so I marked them `unstable`, please let me know if I should have done it differently.\n\nI asked in Discord and was told that as this change is small it does not require an RFC.", "tree": {"sha": "e26a80eddd5fb6abc64d23a7b0411071e52ef556", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e26a80eddd5fb6abc64d23a7b0411071e52ef556"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3fc979b6bf29edf02fe7f9930ca99c8e2d5d84c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbO0JTCRBK7hj4Ov3rIwAAdHIIAFzPgc2zaO9TVdVe36lVlbgz\nWJSEe3ATO6Us34fuvHfoJeKwhYSzX11aumRBHkkdXkVrDNj+uAOJK2NFFccwAqzm\nmo1gBJku18xkcDyyXLzO+wzsUAkEULb+cvPPOohISj3i7OyI0lA5GkqjvY287CYx\nwsU6M6Am+bDeW52m49eYoWHDxvKpOrvXErsH8HDvbIvxs42A/UQQDyjEImGHzJpj\nkmsacrzBC7b/zVGco/xgIhqlalDK88t4szC6/tS7QY/aYvgHlU1l8KLpIacqvwm2\niLKbVlXNgvp3e5ud3T7VZpC5FccX3iUSxRW6LS9etPOtk9QlnI/1lEbZXbRRQvA=\n=Vkjk\n-----END PGP SIGNATURE-----\n", "payload": "tree e26a80eddd5fb6abc64d23a7b0411071e52ef556\nparent 7fa03fb511a0ee8c5abbe2e3ea545d0df02f5e41\nparent 73166f751b7509dd95ce903ecdeab2dd5d89aa90\nauthor Pietro Albini <pietro@pietroalbini.org> 1530610259 +0200\ncommitter GitHub <noreply@github.com> 1530610259 +0200\n\nRollup merge of #51809 - drrlvn:rw_exact_all_at, r=alexcrichton\n\nAdd read_exact_at and write_all_at methods to FileExt on unix\n\nThis PR adds `FileExt::read_exact_at()` and `FileExt::write_all_at()`, which are to `read_at()` and `write_at()` as `read_exact()` and `write_all()` are to `read()` and `write()`. This allows the user to not have to deal with `ErrorKind::Interrupted` and calling the functions in a loop.\n\nI was unsure as to how to mark these new methods so I marked them `unstable`, please let me know if I should have done it differently.\n\nI asked in Discord and was told that as this change is small it does not require an RFC.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3fc979b6bf29edf02fe7f9930ca99c8e2d5d84c", "html_url": "https://github.com/rust-lang/rust/commit/a3fc979b6bf29edf02fe7f9930ca99c8e2d5d84c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3fc979b6bf29edf02fe7f9930ca99c8e2d5d84c/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fa03fb511a0ee8c5abbe2e3ea545d0df02f5e41", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fa03fb511a0ee8c5abbe2e3ea545d0df02f5e41", "html_url": "https://github.com/rust-lang/rust/commit/7fa03fb511a0ee8c5abbe2e3ea545d0df02f5e41"}, {"sha": "73166f751b7509dd95ce903ecdeab2dd5d89aa90", "url": "https://api.github.com/repos/rust-lang/rust/commits/73166f751b7509dd95ce903ecdeab2dd5d89aa90", "html_url": "https://github.com/rust-lang/rust/commit/73166f751b7509dd95ce903ecdeab2dd5d89aa90"}], "stats": {"total": 127, "additions": 127, "deletions": 0}, "files": [{"sha": "507e9d881717bbac63ce1a9082cfeadb71be7c0b", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/a3fc979b6bf29edf02fe7f9930ca99c8e2d5d84c/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fc979b6bf29edf02fe7f9930ca99c8e2d5d84c/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=a3fc979b6bf29edf02fe7f9930ca99c8e2d5d84c", "patch": "@@ -59,6 +59,78 @@ pub trait FileExt {\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n \n+    /// Reads the exact number of byte required to fill `buf` from the given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n+    ///\n+    /// [`Read::read_exact`]: ../../../../std/io/trait.Read.html#method.read_exact\n+    /// [`read_at`]: #tymethod.read_at\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind\n+    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n+    /// will continue.\n+    ///\n+    /// If this function encounters an \"end of file\" before completely filling\n+    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n+    /// The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns. The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If this function returns an error, it is unspecified how many bytes it\n+    /// has read, but it will never read more than would be necessary to\n+    /// completely fill the buffer.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`ErrorKind::UnexpectedEof`]: ../../../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(rw_exact_all_at)]\n+    /// use std::io;\n+    /// use std::fs::File;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut buf = [0u8; 8];\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now read exactly 8 bytes from the offset 10.\n+    ///     file.read_exact_at(&mut buf, 10)?;\n+    ///     println!(\"read {} bytes: {:?}\", buf.len(), buf);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"rw_exact_all_at\", issue = \"51984\")]\n+    fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.read_at(buf, offset) {\n+                Ok(0) => break,\n+                Ok(n) => {\n+                    let tmp = buf;\n+                    buf = &mut tmp[n..];\n+                    offset += n as u64;\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        if !buf.is_empty() {\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof,\n+                               \"failed to fill whole buffer\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Writes a number of bytes starting from a given offset.\n     ///\n     /// Returns the number of bytes written.\n@@ -93,6 +165,61 @@ pub trait FileExt {\n     /// ```\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n+\n+    /// Attempts to write an entire buffer starting from a given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// This method will continuously call [`write_at`] until there is no more data\n+    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n+    /// returned. This method will not return until the entire buffer has been\n+    /// successfully written or such an error occurs. The first error that is\n+    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n+    /// returned.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return the first error of\n+    /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`write_at`]: #tymethod.write_at\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(rw_exact_all_at)]\n+    /// use std::fs::File;\n+    /// use std::io;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now write at the offset 10.\n+    ///     file.write_all_at(b\"sushi\", 10)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"rw_exact_all_at\", issue = \"51984\")]\n+    fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.write_at(buf, offset) {\n+                Ok(0) => return Err(io::Error::new(io::ErrorKind::WriteZero,\n+                                                   \"failed to write whole buffer\")),\n+                Ok(n) => {\n+                    buf = &buf[n..];\n+                    offset += n as u64\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"file_offset\", since = \"1.15.0\")]"}]}