{"sha": "2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f", "node_id": "C_kwDOAAsO6NoAKDJkZDIxNmExODZiYzNiMGNlYTliMmFmZTg4OWY5OWFhOWYwYTVkOWY", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-04T19:20:27Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-04T19:28:27Z"}, "message": "Check for full equality in `type_repetition_in_bounds` rather than just equal hashes", "tree": {"sha": "4d4d13ead3e36742fa34acee50b21d49f2f1b827", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d4d13ead3e36742fa34acee50b21d49f2f1b827"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f", "html_url": "https://github.com/rust-lang/rust/commit/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ea77847fee93e51957e51a4480ef31a04602a7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea77847fee93e51957e51a4480ef31a04602a7a", "html_url": "https://github.com/rust-lang/rust/commit/3ea77847fee93e51957e51a4480ef31a04602a7a"}], "stats": {"total": 53, "additions": 41, "deletions": 12}, "files": [{"sha": "f2848ad3790936672f49ab70d02740b9036f02ec", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::SpanlessHash;\n+use clippy_utils::{SpanlessEq, SpanlessHash};\n+use core::hash::{Hash, Hasher};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::{def::Res, GenericBound, Generics, ParamName, Path, QPath, TyKind, WherePredicate};\n+use rustc_hir::{def::Res, GenericBound, Generics, ParamName, Path, QPath, Ty, TyKind, WherePredicate};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -94,24 +95,40 @@ fn get_trait_res_span_from_bound(bound: &GenericBound<'_>) -> Option<(Res, Span)\n }\n \n impl TraitBounds {\n-    fn check_type_repetition(self, cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n+    fn check_type_repetition<'tcx>(self, cx: &LateContext<'tcx>, gen: &'tcx Generics<'_>) {\n+        struct SpanlessTy<'cx, 'tcx> {\n+            ty: &'tcx Ty<'tcx>,\n+            cx: &'cx LateContext<'tcx>,\n+        }\n+        impl PartialEq for SpanlessTy<'_, '_> {\n+            fn eq(&self, other: &Self) -> bool {\n+                let mut eq = SpanlessEq::new(self.cx);\n+                eq.inter_expr().eq_ty(self.ty, other.ty)\n+            }\n+        }\n+        impl Hash for SpanlessTy<'_, '_> {\n+            fn hash<H: Hasher>(&self, h: &mut H) {\n+                let mut t = SpanlessHash::new(self.cx);\n+                t.hash_ty(self.ty);\n+                h.write_u64(t.finish());\n+            }\n+        }\n+        impl Eq for SpanlessTy<'_, '_> {}\n+\n         if gen.span.from_expansion() {\n             return;\n         }\n-        let hash = |ty| -> u64 {\n-            let mut hasher = SpanlessHash::new(cx);\n-            hasher.hash_ty(ty);\n-            hasher.finish()\n-        };\n-        let mut map: UnhashMap<u64, Vec<&GenericBound<'_>>> = UnhashMap::default();\n+        let mut map: UnhashMap<SpanlessTy<'_, '_>, Vec<&GenericBound<'_>>> = UnhashMap::default();\n         let mut applicability = Applicability::MaybeIncorrect;\n         for bound in gen.where_clause.predicates {\n             if_chain! {\n                 if let WherePredicate::BoundPredicate(ref p) = bound;\n                 if p.bounds.len() as u64 <= self.max_trait_bounds;\n                 if !p.span.from_expansion();\n-                let h = hash(p.bounded_ty);\n-                if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>());\n+                if let Some(ref v) = map.insert(\n+                    SpanlessTy { ty: p.bounded_ty, cx },\n+                    p.bounds.iter().collect::<Vec<_>>()\n+                );\n \n                 then {\n                     let mut hint_string = format!("}, {"sha": "9df296beb60c98734707551a24803a6f43da73ab", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f", "patch": "@@ -388,7 +388,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     #[allow(clippy::similar_names)]\n-    fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n+    pub fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&TyKind::Slice(l_vec), &TyKind::Slice(r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(lt, ref ll_id), &TyKind::Array(rt, ref rl_id)) => {\n@@ -845,6 +845,8 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn hash_path(&mut self, path: &Path<'_>) {\n         match path.res {\n             // constant hash since equality is dependant on inter-expression context\n+            // e.g. The expressions `if let Some(x) = foo() {}` and `if let Some(y) = foo() {}` are considered equal\n+            // even though the binding names are different and they have different `HirId`s.\n             Res::Local(_) => 1_usize.hash(&mut self.s),\n             _ => {\n                 for seg in path.segments {"}, {"sha": "fc740ee11d6ab7b815ab274dd283c76b44055da6", "filename": "tests/ui/type_repetition_in_bounds.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f/tests%2Fui%2Ftype_repetition_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f/tests%2Fui%2Ftype_repetition_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.rs?ref=2dd216a186bc3b0cea9b2afe889f99aa9f0a5d9f", "patch": "@@ -69,4 +69,14 @@ mod issue4326 {\n     }\n }\n \n+// Issue #7360\n+struct Foo<T, U>\n+where\n+    T: Clone,\n+    U: Clone,\n+{\n+    t: T,\n+    u: U,\n+}\n+\n fn main() {}"}]}