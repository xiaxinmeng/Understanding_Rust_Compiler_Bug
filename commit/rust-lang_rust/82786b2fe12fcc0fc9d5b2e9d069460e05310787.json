{"sha": "82786b2fe12fcc0fc9d5b2e9d069460e05310787", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNzg2YjJmZTEyZmNjMGZjOWQ1YjJlOWQwNjk0NjBlMDUzMTA3ODc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-11T23:31:30Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-30T08:11:59Z"}, "message": "emit validation for function calls and Ref", "tree": {"sha": "5a813ba56e5133c6e3a9b8c6a01797aa3e5815e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a813ba56e5133c6e3a9b8c6a01797aa3e5815e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82786b2fe12fcc0fc9d5b2e9d069460e05310787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82786b2fe12fcc0fc9d5b2e9d069460e05310787", "html_url": "https://github.com/rust-lang/rust/commit/82786b2fe12fcc0fc9d5b2e9d069460e05310787", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82786b2fe12fcc0fc9d5b2e9d069460e05310787/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33585f4fe11968ce652815c8a3debfdf97df6baa", "url": "https://api.github.com/repos/rust-lang/rust/commits/33585f4fe11968ce652815c8a3debfdf97df6baa", "html_url": "https://github.com/rust-lang/rust/commit/33585f4fe11968ce652815c8a3debfdf97df6baa"}], "stats": {"total": 93, "additions": 88, "deletions": 5}, "files": [{"sha": "0c9848de8fcaa6a0b87347de09c51b4d59514319", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 88, "deletions": 5, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/82786b2fe12fcc0fc9d5b2e9d069460e05310787/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82786b2fe12fcc0fc9d5b2e9d069460e05310787/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=82786b2fe12fcc0fc9d5b2e9d069460e05310787", "patch": "@@ -14,30 +14,113 @@\n //! of MIR building, and only after this pass we think of the program has having the\n //! normal MIR semantics.\n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{TyCtxt, RegionKind};\n use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource};\n \n pub struct AddValidation;\n \n impl MirPass for AddValidation {\n     fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        // Add an AcquireValid at the beginning of the start block\n+        // PART 1\n+        // Add an AcquireValid at the beginning of the start block.\n         if mir.arg_count > 0 {\n             let acquire_stmt = Statement {\n                 source_info: SourceInfo {\n                     scope: ARGUMENT_VISIBILITY_SCOPE,\n-                    span: mir.span,\n+                    span: mir.span, // TODO: Consider using just the span covering the function argument declaration\n                 },\n                 kind: StatementKind::Validate(ValidationOp::Acquire,\n                     // Skip return value, go over all the arguments\n                     mir.local_decls.iter_enumerated().skip(1).take(mir.arg_count)\n-                    .map(|(local, local_decl)| (local_decl.ty, Lvalue::Local(local))).collect())\n+                    .map(|(local, local_decl)| (local_decl.ty, Lvalue::Local(local))).collect()\n+                )\n             };\n             mir.basic_blocks_mut()[START_BLOCK].statements.insert(0, acquire_stmt);\n         }\n+\n+        // PART 2\n+        // Add ReleaseValid/AcquireValid around function call terminators.  We don't use a visitor because\n+        // we need to access the block that a Call jumps to.\n+        let mut returns : Vec<(SourceInfo, Lvalue<'tcx>, BasicBlock)> = Vec::new(); // Here we collect the destinations.\n+        let local_decls = mir.local_decls.clone(); // TODO: Find a way to get rid of this clone.\n+        for block_data in mir.basic_blocks_mut() {\n+            match block_data.terminator {\n+                Some(Terminator { kind: TerminatorKind::Call { ref args, ref destination, .. }, source_info }) => {\n+                    // Before the call: Release all arguments\n+                    let release_stmt = Statement {\n+                        source_info,\n+                        kind: StatementKind::Validate(ValidationOp::Release,\n+                            args.iter().filter_map(|op| {\n+                                match op {\n+                                    &Operand::Consume(ref lval) => {\n+                                        let ty = lval.ty(&local_decls, tcx).to_ty(tcx);\n+                                        Some((ty, lval.clone()))\n+                                    },\n+                                    &Operand::Constant(..) => { None },\n+                                }\n+                            }).collect())\n+                    };\n+                    block_data.statements.push(release_stmt);\n+                    // Remember the return destination for later\n+                    if let &Some(ref destination) = destination {\n+                        returns.push((source_info, destination.0.clone(), destination.1));\n+                    }\n+                }\n+                _ => {\n+                    // Not a block ending in a Call -> ignore.\n+                    // TODO: Handle drop.\n+                }\n+            }\n+        }\n+        // Now we go over the returns we collected to acquire the return values.\n+        for (source_info, dest_lval, dest_block) in returns {\n+            let ty = dest_lval.ty(&local_decls, tcx).to_ty(tcx);\n+            let acquire_stmt = Statement {\n+                source_info,\n+                kind: StatementKind::Validate(ValidationOp::Acquire, vec![(ty, dest_lval)])\n+            };\n+            mir.basic_blocks_mut()[dest_block].statements.insert(0, acquire_stmt);\n+        }\n+\n+        // PART 3\n+        // Add ReleaseValid/AcquireValid around Ref.  Again an iterator does not seem very suited as\n+        // we need to add new statements before and after each Ref.\n+        for block_data in mir.basic_blocks_mut() {\n+            // We want to insert statements around Ref commands as we iterate.  To this end, we iterate backwards\n+            // using indices.\n+            for i in (0..block_data.statements.len()).rev() {\n+                let (dest_lval, re, src_lval) = match block_data.statements[i].kind {\n+                    StatementKind::Assign(ref dest_lval, Rvalue::Ref(re, _, ref src_lval)) => {\n+                        (dest_lval.clone(), re, src_lval.clone())\n+                    },\n+                    _ => continue,\n+                };\n+                // So this is a ref, and we got all the data we wanted.\n+                let dest_ty = dest_lval.ty(&local_decls, tcx).to_ty(tcx);\n+                let acquire_stmt = Statement {\n+                    source_info: block_data.statements[i].source_info,\n+                    kind: StatementKind::Validate(ValidationOp::Acquire, vec![(dest_ty, dest_lval)]),\n+                };\n+                block_data.statements.insert(i+1, acquire_stmt);\n+\n+                // The source is released until the region of the borrow ends.\n+                // FIXME: We have to check whether the source path was writable.\n+                let src_ty = src_lval.ty(&local_decls, tcx).to_ty(tcx);\n+                let op = match re {\n+                    &RegionKind::ReScope(ce) => ValidationOp::Suspend(ce),\n+                    &RegionKind::ReErased => bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n+                    _ => ValidationOp::Release,\n+                };\n+                let release_stmt = Statement {\n+                    source_info: block_data.statements[i].source_info,\n+                    kind: StatementKind::Validate(op, vec![(src_ty, src_lval)]),\n+                };\n+                block_data.statements.insert(i, release_stmt);\n+            }\n+        }\n     }\n }"}]}