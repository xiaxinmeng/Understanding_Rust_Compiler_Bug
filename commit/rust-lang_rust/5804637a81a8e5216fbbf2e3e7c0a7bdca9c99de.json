{"sha": "5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MDQ2MzdhODFhOGU1MjE2ZmJiZjJlM2U3YzBhN2JkY2E5Yzk5ZGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T16:37:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-15T15:27:51Z"}, "message": "permit `ClosureOutlivesRequirement` to constrain regions or types", "tree": {"sha": "721b2b9e4e42cfa449b029ebf8ef8545f92971e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/721b2b9e4e42cfa449b029ebf8ef8545f92971e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "html_url": "https://github.com/rust-lang/rust/commit/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7cfa2367b0ad4aed16dff7ad3d8d3e9eea6540a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7cfa2367b0ad4aed16dff7ad3d8d3e9eea6540a", "html_url": "https://github.com/rust-lang/rust/commit/c7cfa2367b0ad4aed16dff7ad3d8d3e9eea6540a"}], "stats": {"total": 134, "additions": 96, "deletions": 38}, "files": [{"sha": "df67c3abbe86c79fe293f9a425ffb8d706e50951", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "patch": "@@ -536,14 +536,29 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n \n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n \n-impl_stable_hash_for!(struct mir::ClosureRegionRequirements {\n+impl_stable_hash_for!(struct mir::ClosureRegionRequirements<'tcx> {\n     num_external_vids,\n     outlives_requirements\n });\n \n-impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement {\n-    free_region,\n+impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement<'tcx> {\n+    subject,\n     outlived_free_region,\n     blame_span\n });\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::ClosureOutlivesSubject<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::ClosureOutlivesSubject::Ty(ref ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::ClosureOutlivesSubject::Region(ref region) => {\n+                region.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}"}, {"sha": "d7afce7de46c90437ffc2b1c9fde12faf85ede46", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "patch": "@@ -1832,7 +1832,7 @@ pub struct GeneratorLayout<'tcx> {\n /// can be extracted from its type and constrained to have the given\n /// outlives relationship.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct ClosureRegionRequirements {\n+pub struct ClosureRegionRequirements<'gcx> {\n     /// The number of external regions defined on the closure.  In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n     /// and `'2`. This is just used for a sanity check later on, to\n@@ -1842,15 +1842,15 @@ pub struct ClosureRegionRequirements {\n \n     /// Requirements between the various free regions defined in\n     /// indices.\n-    pub outlives_requirements: Vec<ClosureOutlivesRequirement>,\n+    pub outlives_requirements: Vec<ClosureOutlivesRequirement<'gcx>>,\n }\n \n-/// Indicates an outlives constraint between two free-regions declared\n-/// on the closure.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct ClosureOutlivesRequirement {\n-    // This region ...\n-    pub free_region: ty::RegionVid,\n+/// Indicates an outlives constraint between a type or between two\n+/// free-regions declared on the closure.\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct ClosureOutlivesRequirement<'tcx> {\n+    // This region or type ...\n+    pub subject: ClosureOutlivesSubject<'tcx>,\n \n     // .. must outlive this one.\n     pub outlived_free_region: ty::RegionVid,\n@@ -1859,6 +1859,23 @@ pub struct ClosureOutlivesRequirement {\n     pub blame_span: Span,\n }\n \n+/// The subject of a ClosureOutlivesRequirement -- that is, the thing\n+/// that must outlive some region.\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum ClosureOutlivesSubject<'tcx> {\n+    /// Subject is a type, typically a type parameter, but could also\n+    /// be a projection. Indicates a requirement like `T: 'a` being\n+    /// passed to the caller, where the type here is `T`.\n+    ///\n+    /// The type here is guaranteed not to contain any free regions at\n+    /// present.\n+    Ty(Ty<'tcx>),\n+\n+    /// Subject is a free region from the closure. Indicates a requirement\n+    /// like `'a: 'b` being passed to the caller; the region here is `'a`.\n+    Region(ty::RegionVid),\n+}\n+\n /*\n  * TypeFoldable implementations for MIR types\n  */"}, {"sha": "319f63dd7c84aa01a07b0adf2eaf912a3496f661", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "patch": "@@ -193,7 +193,7 @@ define_maps! { <'tcx>\n \n     /// Borrow checks the function body. If this is a closure, returns\n     /// additional requirements that the closure's creator must verify.\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements>,\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements<'tcx>>,\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence."}, {"sha": "e0b03aec69a3b3368404a1542948b3babd45834a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "patch": "@@ -65,7 +65,7 @@ pub fn provide(providers: &mut Providers) {\n fn mir_borrowck<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements> {\n+) -> Option<ClosureRegionRequirements<'tcx>> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n@@ -89,7 +89,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     input_mir: &Mir<'gcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements> {\n+) -> Option<ClosureRegionRequirements<'gcx>> {\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);"}, {"sha": "23fa2689053bfc1907148c58443474b3aaffb93c", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::{ClosureRegionRequirements, Mir};\n+use rustc::mir::{ClosureRegionRequirements, ClosureOutlivesSubject, Mir};\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n use std::collections::BTreeSet;\n+use std::fmt::Debug;\n use std::io;\n use transform::MirSource;\n use util::liveness::{LivenessResults, LocalSet};\n@@ -73,7 +74,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     move_data: &MoveData<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n-    Option<ClosureRegionRequirements>,\n+    Option<ClosureRegionRequirements<'gcx>>,\n ) {\n     // Run the MIR type-checker.\n     let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -263,9 +264,13 @@ fn for_each_region_constraint(\n     with_msg: &mut FnMut(&str) -> io::Result<()>,\n ) -> io::Result<()> {\n     for req in &closure_region_requirements.outlives_requirements {\n+        let subject: &Debug = match &req.subject {\n+            ClosureOutlivesSubject::Region(subject) => subject,\n+            ClosureOutlivesSubject::Ty(ty) => ty,\n+        };\n         with_msg(&format!(\n             \"where {:?}: {:?}\",\n-            req.free_region,\n+            subject,\n             req.outlived_free_region,\n         ))?;\n     }"}, {"sha": "4a1eca38bc7c6d9d6af82a28718c222cb7c078b9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "patch": "@@ -15,7 +15,8 @@ use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n-use rustc::mir::{ClosureOutlivesRequirement, ClosureRegionRequirements, Location, Mir};\n+use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n+                 Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt;\n@@ -339,12 +340,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Perform region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n-    pub(super) fn solve(\n+    pub(super) fn solve<'gcx>(\n         &mut self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n-    ) -> Option<ClosureRegionRequirements> {\n+    ) -> Option<ClosureRegionRequirements<'gcx>> {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n \n         self.propagate_constraints(mir);\n@@ -559,10 +560,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// If `propagated_outlives_requirements` is `Some`, then we will\n     /// push unsatisfied obligations into there. Otherwise, we'll\n     /// report them as errors.\n-    fn check_universal_regions(\n+    fn check_universal_regions<'gcx>(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement>>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n         // The universal regions are always found in a prefix of the\n         // full list.\n@@ -583,9 +584,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 propagated_outlives_requirements.extend(outlives_requirements.drain(..));\n             } else {\n                 for outlives_requirement in outlives_requirements.drain(..) {\n+                    let fr = match outlives_requirement.subject {\n+                        ClosureOutlivesSubject::Region(fr) => fr,\n+                        _ => span_bug!(\n+                            outlives_requirement.blame_span,\n+                            \"check_universal_region() produced requirement w/ non-region subject\"\n+                        ),\n+                    };\n+\n                     self.report_error(\n                         infcx,\n-                        outlives_requirement.free_region,\n+                        fr,\n                         outlives_requirement.outlived_free_region,\n                         outlives_requirement.blame_span,\n                     );\n@@ -602,11 +611,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Things that are to be propagated are accumulated into the\n     /// `outlives_requirements` vector.\n-    fn check_universal_region(\n+    fn check_universal_region<'gcx>(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         longer_fr: RegionVid,\n-        propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement>,\n+        propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n \n@@ -645,7 +654,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                 // Push the constraint `fr-: shorter_fr+`\n                 propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n-                    free_region: fr_minus,\n+                    subject: ClosureOutlivesSubject::Region(fr_minus),\n                     outlived_free_region: shorter_fr_plus,\n                     blame_span: blame_span,\n                 });\n@@ -773,7 +782,7 @@ pub trait ClosureRegionRequirementsExt {\n     );\n }\n \n-impl ClosureRegionRequirementsExt for ClosureRegionRequirements {\n+impl<'gcx> ClosureRegionRequirementsExt for ClosureRegionRequirements<'gcx> {\n     /// Given an instance T of the closure type, this method\n     /// instantiates the \"extra\" requirements that we computed for the\n     /// closure into the inference context. This has the effect of\n@@ -815,17 +824,29 @@ impl ClosureRegionRequirementsExt for ClosureRegionRequirements {\n \n         // Create the predicates.\n         for outlives_requirement in &self.outlives_requirements {\n-            let region = closure_mapping[outlives_requirement.free_region];\n             let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n-            debug!(\n-                \"apply_requirements: region={:?} outlived_region={:?} outlives_requirements={:?}\",\n-                region,\n-                outlived_region,\n-                outlives_requirement\n-            );\n+\n             // FIXME, this origin is not entirely suitable.\n             let origin = SubregionOrigin::CallRcvr(outlives_requirement.blame_span);\n-            infcx.sub_regions(origin, outlived_region, region);\n+\n+            match outlives_requirement.subject {\n+                ClosureOutlivesSubject::Region(region) => {\n+                    let region = closure_mapping[region];\n+                    debug!(\n+                        \"apply_requirements: region={:?} \\\n+                         outlived_region={:?} \\\n+                         outlives_requirements={:?}\",\n+                        region,\n+                        outlived_region,\n+                        outlives_requirement\n+                    );\n+                    infcx.sub_regions(origin, outlived_region, region);\n+                }\n+\n+                ClosureOutlivesSubject::Ty(_ty) => {\n+                    bug!(\"TODO not yet implemented -- closure outlives subject of a type\");\n+                }\n+            }\n         }\n     }\n }"}]}