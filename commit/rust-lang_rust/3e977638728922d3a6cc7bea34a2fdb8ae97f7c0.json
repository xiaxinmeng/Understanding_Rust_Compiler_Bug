{"sha": "3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "node_id": "C_kwDOAAsO6NoAKDNlOTc3NjM4NzI4OTIyZDNhNmNjN2JlYTM0YTJmZGI4YWU5N2Y3YzA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-26T12:44:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-26T12:44:47Z"}, "message": "Auto merge of #106745 - m-ou-se:format-args-ast, r=oli-obk\n\nMove format_args!() into AST (and expand it during AST lowering)\n\nImplements https://github.com/rust-lang/compiler-team/issues/541\n\nThis moves FormatArgs from rustc_builtin_macros to rustc_ast_lowering. For now, the end result is the same. But this allows for future changes to do smarter things with format_args!(). It also allows Clippy to directly access the ast::FormatArgs, making things a lot easier.\n\nThis change turns the format args types into lang items. The builtin macro used to refer to them by their path. After this change, the path is no longer relevant, making it easier to make changes in `core`.\n\nThis updates clippy to use the new language items, but this doesn't yet make clippy use the ast::FormatArgs structure that's now available. That should be done after this is merged.", "tree": {"sha": "ccf38bab26084eb37c133e60987ba7bd4318ec9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccf38bab26084eb37c133e60987ba7bd4318ec9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "html_url": "https://github.com/rust-lang/rust/commit/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "url": "https://api.github.com/repos/rust-lang/rust/commits/40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "html_url": "https://github.com/rust-lang/rust/commit/40fda7b3fe2b10c6e1a0568b59516f5e7f381886"}, {"sha": "db731e42b3c139587cd7a87acaa92cd82ab8a11c", "url": "https://api.github.com/repos/rust-lang/rust/commits/db731e42b3c139587cd7a87acaa92cd82ab8a11c", "html_url": "https://github.com/rust-lang/rust/commit/db731e42b3c139587cd7a87acaa92cd82ab8a11c"}], "stats": {"total": 1199, "additions": 750, "deletions": 449}, "files": [{"sha": "23b01f23c50ead984a31f4d34034968bdbfa29d2", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -3729,6 +3729,7 @@ name = \"rustc_ast_pretty\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n+ \"rustc_parse_format\",\n  \"rustc_span\",\n ]\n "}, {"sha": "8ad3270c5103ec24cbd11429b4f7cd7984fba6fd", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -18,6 +18,7 @@\n //! - [`Attribute`]: Metadata associated with item.\n //! - [`UnOp`], [`BinOp`], and [`BinOpKind`]: Unary and binary operators.\n \n+pub use crate::format::*;\n pub use crate::util::parser::ExprPrecedence;\n pub use GenericArgs::*;\n pub use UnsafeSource::*;\n@@ -1269,6 +1270,7 @@ impl Expr {\n             ExprKind::Try(..) => ExprPrecedence::Try,\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n             ExprKind::Yeet(..) => ExprPrecedence::Yeet,\n+            ExprKind::FormatArgs(..) => ExprPrecedence::FormatArgs,\n             ExprKind::Err => ExprPrecedence::Err,\n         }\n     }\n@@ -1499,6 +1501,9 @@ pub enum ExprKind {\n     /// with a `ByteStr` literal.\n     IncludedBytes(Lrc<[u8]>),\n \n+    /// A `format_args!()` expression.\n+    FormatArgs(P<FormatArgs>),\n+\n     /// Placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }"}, {"sha": "da05b09b37dccc6acde3b442eff635bf24284f80", "filename": "compiler/rustc_ast/src/format.rs", "status": "renamed", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fformat.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -1,5 +1,5 @@\n-use rustc_ast::ptr::P;\n-use rustc_ast::Expr;\n+use crate::ptr::P;\n+use crate::Expr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n@@ -39,7 +39,7 @@ use rustc_span::Span;\n /// Basically the \"AST\" for a complete `format_args!()`.\n ///\n /// E.g., `format_args!(\"hello {name}\");`.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FormatArgs {\n     pub span: Span,\n     pub template: Vec<FormatArgsPiece>,\n@@ -49,7 +49,7 @@ pub struct FormatArgs {\n /// A piece of a format template string.\n ///\n /// E.g. \"hello\" or \"{name}\".\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FormatArgsPiece {\n     Literal(Symbol),\n     Placeholder(FormatPlaceholder),\n@@ -59,14 +59,20 @@ pub enum FormatArgsPiece {\n ///\n /// E.g. `1, 2, name=\"ferris\", n=3`,\n /// but also implicit captured arguments like `x` in `format_args!(\"{x}\")`.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FormatArguments {\n     arguments: Vec<FormatArgument>,\n     num_unnamed_args: usize,\n     num_explicit_args: usize,\n     names: FxHashMap<Symbol, usize>,\n }\n \n+// FIXME: Rustdoc has trouble proving Send/Sync for this. See #106930.\n+#[cfg(parallel_compiler)]\n+unsafe impl Sync for FormatArguments {}\n+#[cfg(parallel_compiler)]\n+unsafe impl Send for FormatArguments {}\n+\n impl FormatArguments {\n     pub fn new() -> Self {\n         Self {\n@@ -121,18 +127,22 @@ impl FormatArguments {\n         &self.arguments[..self.num_explicit_args]\n     }\n \n-    pub fn into_vec(self) -> Vec<FormatArgument> {\n-        self.arguments\n+    pub fn all_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..]\n+    }\n+\n+    pub fn all_args_mut(&mut self) -> &mut [FormatArgument] {\n+        &mut self.arguments[..]\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FormatArgument {\n     pub kind: FormatArgumentKind,\n     pub expr: P<Expr>,\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FormatArgumentKind {\n     /// `format_args(\u2026, arg)`\n     Normal,\n@@ -152,7 +162,7 @@ impl FormatArgumentKind {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub struct FormatPlaceholder {\n     /// Index into [`FormatArgs::arguments`].\n     pub argument: FormatArgPosition,\n@@ -164,7 +174,7 @@ pub struct FormatPlaceholder {\n     pub format_options: FormatOptions,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub struct FormatArgPosition {\n     /// Which argument this position refers to (Ok),\n     /// or would've referred to if it existed (Err).\n@@ -175,7 +185,7 @@ pub struct FormatArgPosition {\n     pub span: Option<Span>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum FormatArgPositionKind {\n     /// `{}` or `{:.*}`\n     Implicit,\n@@ -185,7 +195,7 @@ pub enum FormatArgPositionKind {\n     Named,\n }\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq, Hash)]\n pub enum FormatTrait {\n     /// `{}`\n     Display,\n@@ -207,7 +217,7 @@ pub enum FormatTrait {\n     UpperHex,\n }\n \n-#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Default, Debug, PartialEq, Eq)]\n pub struct FormatOptions {\n     /// The width. E.g. `{:5}` or `{:width$}`.\n     pub width: Option<FormatCount>,\n@@ -221,7 +231,7 @@ pub struct FormatOptions {\n     pub flags: u32,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum FormatAlignment {\n     /// `{:<}`\n     Left,\n@@ -231,7 +241,7 @@ pub enum FormatAlignment {\n     Center,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum FormatCount {\n     /// `{:5}` or `{:.5}`\n     Literal(usize),", "previous_filename": "compiler/rustc_builtin_macros/src/format/ast.rs"}, {"sha": "0f8ebcfdc150844ad4d72751ac8619161bfbbed0", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -42,6 +42,7 @@ pub mod ast_traits;\n pub mod attr;\n pub mod entry;\n pub mod expand;\n+pub mod format;\n pub mod mut_visit;\n pub mod node_id;\n pub mod ptr;\n@@ -51,6 +52,7 @@ pub mod visit;\n \n pub use self::ast::*;\n pub use self::ast_traits::{AstDeref, AstNodeWrapper, HasAttrs, HasNodeId, HasSpan, HasTokens};\n+pub use self::format::*;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "1dd62626b8f5e33607a4e87a362b4875997128ef", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -297,6 +297,10 @@ pub trait MutVisitor: Sized {\n     fn visit_inline_asm_sym(&mut self, sym: &mut InlineAsmSym) {\n         noop_visit_inline_asm_sym(sym, self)\n     }\n+\n+    fn visit_format_args(&mut self, fmt: &mut FormatArgs) {\n+        noop_visit_format_args(fmt, self)\n+    }\n }\n \n /// Use a map-style function (`FnOnce(T) -> T`) to overwrite a `&mut T`. Useful\n@@ -1284,6 +1288,15 @@ pub fn noop_visit_inline_asm_sym<T: MutVisitor>(\n     vis.visit_path(path);\n }\n \n+pub fn noop_visit_format_args<T: MutVisitor>(fmt: &mut FormatArgs, vis: &mut T) {\n+    for arg in fmt.arguments.all_args_mut() {\n+        if let FormatArgumentKind::Named(name) = &mut arg.kind {\n+            vis.visit_ident(name);\n+        }\n+        vis.visit_expr(&mut arg.expr);\n+    }\n+}\n+\n pub fn noop_visit_expr<T: MutVisitor>(\n     Expr { kind, id, span, attrs, tokens }: &mut Expr,\n     vis: &mut T,\n@@ -1425,6 +1438,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n         ExprKind::InlineAsm(asm) => vis.visit_inline_asm(asm),\n+        ExprKind::FormatArgs(fmt) => vis.visit_format_args(fmt),\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(se) => {\n             let StructExpr { qself, path, fields, rest } = se.deref_mut();"}, {"sha": "81efdaa44b365a3979187d37a540640636784a4f", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -271,6 +271,7 @@ pub enum ExprPrecedence {\n     Try,\n     InlineAsm,\n     Mac,\n+    FormatArgs,\n \n     Array,\n     Repeat,\n@@ -335,7 +336,8 @@ impl ExprPrecedence {\n             | ExprPrecedence::Index\n             | ExprPrecedence::Try\n             | ExprPrecedence::InlineAsm\n-            | ExprPrecedence::Mac => PREC_POSTFIX,\n+            | ExprPrecedence::Mac\n+            | ExprPrecedence::FormatArgs => PREC_POSTFIX,\n \n             // Never need parens\n             ExprPrecedence::Array"}, {"sha": "e7b2e4b1cb4b072a4d300e0e20b978fa16fb2ee4", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -242,6 +242,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_inline_asm(&mut self, asm: &'ast InlineAsm) {\n         walk_inline_asm(self, asm)\n     }\n+    fn visit_format_args(&mut self, fmt: &'ast FormatArgs) {\n+        walk_format_args(self, fmt)\n+    }\n     fn visit_inline_asm_sym(&mut self, sym: &'ast InlineAsmSym) {\n         walk_inline_asm_sym(self, sym)\n     }\n@@ -756,6 +759,15 @@ pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineA\n     visitor.visit_path(&sym.path, sym.id);\n }\n \n+pub fn walk_format_args<'a, V: Visitor<'a>>(visitor: &mut V, fmt: &'a FormatArgs) {\n+    for arg in fmt.arguments.all_args() {\n+        if let FormatArgumentKind::Named(name) = arg.kind {\n+            visitor.visit_ident(name);\n+        }\n+        visitor.visit_expr(&arg.expr);\n+    }\n+}\n+\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n@@ -896,6 +908,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::MacCall(mac) => visitor.visit_mac_call(mac),\n         ExprKind::Paren(subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::InlineAsm(asm) => visitor.visit_inline_asm(asm),\n+        ExprKind::FormatArgs(f) => visitor.visit_format_args(f),\n         ExprKind::Yield(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }"}, {"sha": "cc523fe7d08f501b44b9c81e35d307ed179b0423", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 82, "deletions": 6, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n use thin_vec::thin_vec;\n \n@@ -294,6 +294,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::InlineAsm(asm) => {\n                     hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n                 }\n+                ExprKind::FormatArgs(fmt) => self.lower_format_args(e.span, fmt),\n                 ExprKind::Struct(se) => {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n@@ -1735,7 +1736,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(span, hir::ExprKind::DropTemps(expr))\n     }\n \n-    fn expr_match(\n+    pub(super) fn expr_match(\n         &mut self,\n         span: Span,\n         arg: &'hir hir::Expr<'hir>,\n@@ -1763,7 +1764,44 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[])))\n     }\n \n-    fn expr_call_mut(\n+    pub(super) fn expr_usize(&mut self, sp: Span, value: usize) -> hir::Expr<'hir> {\n+        self.expr(\n+            sp,\n+            hir::ExprKind::Lit(hir::Lit {\n+                span: sp,\n+                node: ast::LitKind::Int(\n+                    value as u128,\n+                    ast::LitIntType::Unsigned(ast::UintTy::Usize),\n+                ),\n+            }),\n+        )\n+    }\n+\n+    pub(super) fn expr_u32(&mut self, sp: Span, value: u32) -> hir::Expr<'hir> {\n+        self.expr(\n+            sp,\n+            hir::ExprKind::Lit(hir::Lit {\n+                span: sp,\n+                node: ast::LitKind::Int(value.into(), ast::LitIntType::Unsigned(ast::UintTy::U32)),\n+            }),\n+        )\n+    }\n+\n+    pub(super) fn expr_char(&mut self, sp: Span, value: char) -> hir::Expr<'hir> {\n+        self.expr(sp, hir::ExprKind::Lit(hir::Lit { span: sp, node: ast::LitKind::Char(value) }))\n+    }\n+\n+    pub(super) fn expr_str(&mut self, sp: Span, value: Symbol) -> hir::Expr<'hir> {\n+        self.expr(\n+            sp,\n+            hir::ExprKind::Lit(hir::Lit {\n+                span: sp,\n+                node: ast::LitKind::Str(value, ast::StrStyle::Cooked),\n+            }),\n+        )\n+    }\n+\n+    pub(super) fn expr_call_mut(\n         &mut self,\n         span: Span,\n         e: &'hir hir::Expr<'hir>,\n@@ -1772,7 +1810,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(span, hir::ExprKind::Call(e, args))\n     }\n \n-    fn expr_call(\n+    pub(super) fn expr_call(\n         &mut self,\n         span: Span,\n         e: &'hir hir::Expr<'hir>,\n@@ -1814,6 +1852,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         )\n     }\n \n+    /// `<LangItem>::name`\n+    pub(super) fn expr_lang_item_type_relative(\n+        &mut self,\n+        span: Span,\n+        lang_item: hir::LangItem,\n+        name: Symbol,\n+    ) -> hir::Expr<'hir> {\n+        let path = hir::ExprKind::Path(hir::QPath::TypeRelative(\n+            self.arena.alloc(self.ty(\n+                span,\n+                hir::TyKind::Path(hir::QPath::LangItem(lang_item, self.lower_span(span), None)),\n+            )),\n+            self.arena.alloc(hir::PathSegment::new(\n+                Ident::new(name, span),\n+                self.next_id(),\n+                Res::Err,\n+            )),\n+        ));\n+        self.expr(span, path)\n+    }\n+\n     pub(super) fn expr_ident(\n         &mut self,\n         sp: Span,\n@@ -1872,12 +1931,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(b.span, hir::ExprKind::Block(b, None))\n     }\n \n+    pub(super) fn expr_array_ref(\n+        &mut self,\n+        span: Span,\n+        elements: &'hir [hir::Expr<'hir>],\n+    ) -> hir::Expr<'hir> {\n+        let addrof = hir::ExprKind::AddrOf(\n+            hir::BorrowKind::Ref,\n+            hir::Mutability::Not,\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Array(elements))),\n+        );\n+        self.expr(span, addrof)\n+    }\n+\n     pub(super) fn expr(&mut self, span: Span, kind: hir::ExprKind<'hir>) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n         hir::Expr { hir_id, kind, span: self.lower_span(span) }\n     }\n \n-    fn expr_field(\n+    pub(super) fn expr_field(\n         &mut self,\n         ident: Ident,\n         expr: &'hir hir::Expr<'hir>,\n@@ -1892,7 +1964,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn arm(&mut self, pat: &'hir hir::Pat<'hir>, expr: &'hir hir::Expr<'hir>) -> hir::Arm<'hir> {\n+    pub(super) fn arm(\n+        &mut self,\n+        pat: &'hir hir::Pat<'hir>,\n+        expr: &'hir hir::Expr<'hir>,\n+    ) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             pat,"}, {"sha": "776b532b0de866dac35d9895dc856cc86f580691", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -0,0 +1,381 @@\n+use super::LoweringContext;\n+use rustc_ast as ast;\n+use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::*;\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_hir as hir;\n+use rustc_span::{\n+    sym,\n+    symbol::{kw, Ident},\n+    Span,\n+};\n+\n+impl<'hir> LoweringContext<'_, 'hir> {\n+    pub(crate) fn lower_format_args(&mut self, sp: Span, fmt: &FormatArgs) -> hir::ExprKind<'hir> {\n+        expand_format_args(self, sp, fmt)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+enum ArgumentType {\n+    Format(FormatTrait),\n+    Usize,\n+}\n+\n+/// Generate a hir expression representing an argument to a format_args invocation.\n+///\n+/// Generates:\n+///\n+/// ```text\n+///     <core::fmt::ArgumentV1>::new_\u2026(arg)\n+/// ```\n+fn make_argument<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    arg: &'hir hir::Expr<'hir>,\n+    ty: ArgumentType,\n+) -> hir::Expr<'hir> {\n+    use ArgumentType::*;\n+    use FormatTrait::*;\n+    let new_fn = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatArgument,\n+        match ty {\n+            Format(Display) => sym::new_display,\n+            Format(Debug) => sym::new_debug,\n+            Format(LowerExp) => sym::new_lower_exp,\n+            Format(UpperExp) => sym::new_upper_exp,\n+            Format(Octal) => sym::new_octal,\n+            Format(Pointer) => sym::new_pointer,\n+            Format(Binary) => sym::new_binary,\n+            Format(LowerHex) => sym::new_lower_hex,\n+            Format(UpperHex) => sym::new_upper_hex,\n+            Usize => sym::from_usize,\n+        },\n+    ));\n+    ctx.expr_call_mut(sp, new_fn, std::slice::from_ref(arg))\n+}\n+\n+/// Generate a hir expression for a format_args Count.\n+///\n+/// Generates:\n+///\n+/// ```text\n+///     <core::fmt::rt::v1::Count>::Is(\u2026)\n+/// ```\n+///\n+/// or\n+///\n+/// ```text\n+///     <core::fmt::rt::v1::Count>::Param(\u2026)\n+/// ```\n+///\n+/// or\n+///\n+/// ```text\n+///     <core::fmt::rt::v1::Count>::Implied\n+/// ```\n+fn make_count<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    count: &Option<FormatCount>,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> hir::Expr<'hir> {\n+    match count {\n+        Some(FormatCount::Literal(n)) => {\n+            let count_is = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+                sp,\n+                hir::LangItem::FormatCount,\n+                sym::Is,\n+            ));\n+            let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, *n)]);\n+            ctx.expr_call_mut(sp, count_is, value)\n+        }\n+        Some(FormatCount::Argument(arg)) => {\n+            if let Ok(arg_index) = arg.index {\n+                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n+                let count_param = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+                    sp,\n+                    hir::LangItem::FormatCount,\n+                    sym::Param,\n+                ));\n+                let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, i)]);\n+                ctx.expr_call_mut(sp, count_param, value)\n+            } else {\n+                ctx.expr(sp, hir::ExprKind::Err)\n+            }\n+        }\n+        None => ctx.expr_lang_item_type_relative(sp, hir::LangItem::FormatCount, sym::Implied),\n+    }\n+}\n+\n+/// Generate a hir expression for a format_args placeholder specification.\n+///\n+/// Generates\n+///\n+/// ```text\n+///     <core::fmt::rt::v1::Argument::new(\n+///         \u2026usize, // position\n+///         '\u2026', // fill\n+///         <core::fmt::rt::v1::Alignment>::\u2026, // alignment\n+///         \u2026u32, // flags\n+///         <core::fmt::rt::v1::Count::\u2026>, // width\n+///         <core::fmt::rt::v1::Count::\u2026>, // precision\n+///     )\n+/// ```\n+fn make_format_spec<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    placeholder: &FormatPlaceholder,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> hir::Expr<'hir> {\n+    let position = match placeholder.argument.index {\n+        Ok(arg_index) => {\n+            let (i, _) =\n+                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n+            ctx.expr_usize(sp, i)\n+        }\n+        Err(_) => ctx.expr(sp, hir::ExprKind::Err),\n+    };\n+    let fill = ctx.expr_char(sp, placeholder.format_options.fill.unwrap_or(' '));\n+    let align = ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatAlignment,\n+        match placeholder.format_options.alignment {\n+            Some(FormatAlignment::Left) => sym::Left,\n+            Some(FormatAlignment::Right) => sym::Right,\n+            Some(FormatAlignment::Center) => sym::Center,\n+            None => sym::Unknown,\n+        },\n+    );\n+    let flags = ctx.expr_u32(sp, placeholder.format_options.flags);\n+    let prec = make_count(ctx, sp, &placeholder.format_options.precision, argmap);\n+    let width = make_count(ctx, sp, &placeholder.format_options.width, argmap);\n+    let format_placeholder_new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatPlaceholder,\n+        sym::new,\n+    ));\n+    let args = ctx.arena.alloc_from_iter([position, fill, align, flags, prec, width]);\n+    ctx.expr_call_mut(sp, format_placeholder_new, args)\n+}\n+\n+fn expand_format_args<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    macsp: Span,\n+    fmt: &FormatArgs,\n+) -> hir::ExprKind<'hir> {\n+    let lit_pieces =\n+        ctx.arena.alloc_from_iter(fmt.template.iter().enumerate().filter_map(|(i, piece)| {\n+            match piece {\n+                &FormatArgsPiece::Literal(s) => Some(ctx.expr_str(fmt.span, s)),\n+                &FormatArgsPiece::Placeholder(_) => {\n+                    // Inject empty string before placeholders when not already preceded by a literal piece.\n+                    if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n+                        Some(ctx.expr_str(fmt.span, kw::Empty))\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        }));\n+    let lit_pieces = ctx.expr_array_ref(fmt.span, lit_pieces);\n+\n+    // Whether we'll use the `Arguments::new_v1_formatted` form (true),\n+    // or the `Arguments::new_v1` form (false).\n+    let mut use_format_options = false;\n+\n+    // Create a list of all _unique_ (argument, format trait) combinations.\n+    // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n+    let mut argmap = FxIndexSet::default();\n+    for piece in &fmt.template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if placeholder.format_options != Default::default() {\n+            // Can't use basic form if there's any formatting options.\n+            use_format_options = true;\n+        }\n+        if let Ok(index) = placeholder.argument.index {\n+            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n+                // Duplicate (argument, format trait) combination,\n+                // which we'll only put once in the args array.\n+                use_format_options = true;\n+            }\n+        }\n+    }\n+\n+    let format_options = use_format_options.then(|| {\n+        // Generate:\n+        //     &[format_spec_0, format_spec_1, format_spec_2]\n+        let elements: Vec<_> = fmt\n+            .template\n+            .iter()\n+            .filter_map(|piece| {\n+                let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n+                Some(make_format_spec(ctx, macsp, placeholder, &mut argmap))\n+            })\n+            .collect();\n+        ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n+    });\n+\n+    let arguments = fmt.arguments.all_args();\n+\n+    // If the args array contains exactly all the original arguments once,\n+    // in order, we can use a simple array instead of a `match` construction.\n+    // However, if there's a yield point in any argument except the first one,\n+    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n+    //\n+    // This is an optimization, speeding up compilation about 1-2% in some cases.\n+    // See https://github.com/rust-lang/rust/pull/106770#issuecomment-1380790609\n+    let use_simple_array = argmap.len() == arguments.len()\n+        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n+        && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n+\n+    let args = if use_simple_array {\n+        // Generate:\n+        //     &[\n+        //         <core::fmt::ArgumentV1>::new_display(&arg0),\n+        //         <core::fmt::ArgumentV1>::new_lower_hex(&arg1),\n+        //         <core::fmt::ArgumentV1>::new_debug(&arg2),\n+        //         \u2026\n+        //     ]\n+        let elements: Vec<_> = arguments\n+            .iter()\n+            .zip(argmap)\n+            .map(|(arg, (_, ty))| {\n+                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+                let arg = ctx.lower_expr(&arg.expr);\n+                let ref_arg = ctx.arena.alloc(ctx.expr(\n+                    sp,\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg),\n+                ));\n+                make_argument(ctx, sp, ref_arg, ty)\n+            })\n+            .collect();\n+        ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n+    } else {\n+        // Generate:\n+        //     &match (&arg0, &arg1, &\u2026) {\n+        //         args => [\n+        //             <core::fmt::ArgumentV1>::new_display(args.0),\n+        //             <core::fmt::ArgumentV1>::new_lower_hex(args.1),\n+        //             <core::fmt::ArgumentV1>::new_debug(args.0),\n+        //             \u2026\n+        //         ]\n+        //     }\n+        let args_ident = Ident::new(sym::args, macsp);\n+        let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n+        let args = ctx.arena.alloc_from_iter(argmap.iter().map(|&(arg_index, ty)| {\n+            if let Some(arg) = arguments.get(arg_index) {\n+                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+                let arg = ctx.arena.alloc(ctx.expr(\n+                    sp,\n+                    hir::ExprKind::Field(\n+                        args_ident_expr,\n+                        Ident::new(sym::integer(arg_index), macsp),\n+                    ),\n+                ));\n+                make_argument(ctx, sp, arg, ty)\n+            } else {\n+                ctx.expr(macsp, hir::ExprKind::Err)\n+            }\n+        }));\n+        let elements: Vec<_> = arguments\n+            .iter()\n+            .map(|arg| {\n+                let arg_expr = ctx.lower_expr(&arg.expr);\n+                ctx.expr(\n+                    arg.expr.span.with_ctxt(macsp.ctxt()),\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg_expr),\n+                )\n+            })\n+            .collect();\n+        let args_tuple = ctx\n+            .arena\n+            .alloc(ctx.expr(macsp, hir::ExprKind::Tup(ctx.arena.alloc_from_iter(elements))));\n+        let array = ctx.arena.alloc(ctx.expr(macsp, hir::ExprKind::Array(args)));\n+        let match_arms = ctx.arena.alloc_from_iter([ctx.arm(args_pat, array)]);\n+        let match_expr = ctx.arena.alloc(ctx.expr_match(\n+            macsp,\n+            args_tuple,\n+            match_arms,\n+            hir::MatchSource::FormatArgs,\n+        ));\n+        ctx.expr(\n+            macsp,\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, match_expr),\n+        )\n+    };\n+\n+    if let Some(format_options) = format_options {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_v1_formatted(\n+        //         lit_pieces,\n+        //         args,\n+        //         format_options,\n+        //         unsafe { ::core::fmt::UnsafeArg::new() }\n+        //     )\n+        let new_v1_formatted = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_v1_formatted,\n+        ));\n+        let unsafe_arg_new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatUnsafeArg,\n+            sym::new,\n+        ));\n+        let unsafe_arg_new_call = ctx.expr_call(macsp, unsafe_arg_new, &[]);\n+        let hir_id = ctx.next_id();\n+        let unsafe_arg = ctx.expr_block(ctx.arena.alloc(hir::Block {\n+            stmts: &[],\n+            expr: Some(unsafe_arg_new_call),\n+            hir_id,\n+            rules: hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::CompilerGenerated),\n+            span: macsp,\n+            targeted_by_break: false,\n+        }));\n+        let args = ctx.arena.alloc_from_iter([lit_pieces, args, format_options, unsafe_arg]);\n+        hir::ExprKind::Call(new_v1_formatted, args)\n+    } else {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_v1(\n+        //         lit_pieces,\n+        //         args,\n+        //     )\n+        let new_v1 = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_v1,\n+        ));\n+        let new_args = ctx.arena.alloc_from_iter([lit_pieces, args]);\n+        hir::ExprKind::Call(new_v1, new_args)\n+    }\n+}\n+\n+fn may_contain_yield_point(e: &ast::Expr) -> bool {\n+    struct MayContainYieldPoint(bool);\n+\n+    impl Visitor<'_> for MayContainYieldPoint {\n+        fn visit_expr(&mut self, e: &ast::Expr) {\n+            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n+                self.0 = true;\n+            } else {\n+                visit::walk_expr(self, e);\n+            }\n+        }\n+\n+        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n+            // Macros should be expanded at this point.\n+            unreachable!(\"unexpanded macro in ast lowering\");\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // Do not recurse into nested items.\n+        }\n+    }\n+\n+    let mut visitor = MayContainYieldPoint(false);\n+    visitor.visit_expr(e);\n+    visitor.0\n+}"}, {"sha": "ea0e971dbd6f303fd06624d6d41773a6fc3c1a0a", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -80,6 +80,7 @@ mod asm;\n mod block;\n mod errors;\n mod expr;\n+mod format;\n mod index;\n mod item;\n mod lifetime_collector;"}, {"sha": "b4900dc39a8af4d98913c75f26146923df617714", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -6,5 +6,6 @@ edition = \"2021\"\n [lib]\n \n [dependencies]\n-rustc_span = { path = \"../rustc_span\" }\n rustc_ast = { path = \"../rustc_ast\" }\n+rustc_parse_format = { path = \"../rustc_parse_format\" }\n+rustc_span = { path = \"../rustc_span\" }"}, {"sha": "99ffa19016f27e90891059d68262bfa9d05f21b5", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -6,6 +6,8 @@ use rustc_ast::token;\n use rustc_ast::util::literal::escape_byte_str_symbol;\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode};\n+use rustc_ast::{FormatAlignment, FormatArgPosition, FormatArgsPiece, FormatCount, FormatTrait};\n+use std::fmt::Write;\n \n impl<'a> State<'a> {\n     fn print_else(&mut self, els: Option<&ast::Expr>) {\n@@ -527,9 +529,23 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ExprKind::InlineAsm(a) => {\n+                // FIXME: This should have its own syntax, distinct from a macro invocation.\n                 self.word(\"asm!\");\n                 self.print_inline_asm(a);\n             }\n+            ast::ExprKind::FormatArgs(fmt) => {\n+                // FIXME: This should have its own syntax, distinct from a macro invocation.\n+                self.word(\"format_args!\");\n+                self.popen();\n+                self.rbox(0, Inconsistent);\n+                self.word(reconstruct_format_args_template_string(&fmt.template));\n+                for arg in fmt.arguments.all_args() {\n+                    self.word_space(\",\");\n+                    self.print_expr(&arg.expr);\n+                }\n+                self.end();\n+                self.pclose();\n+            }\n             ast::ExprKind::MacCall(m) => self.print_mac(m),\n             ast::ExprKind::Paren(e) => {\n                 self.popen();\n@@ -629,3 +645,91 @@ impl<'a> State<'a> {\n         }\n     }\n }\n+\n+pub fn reconstruct_format_args_template_string(pieces: &[FormatArgsPiece]) -> String {\n+    let mut template = \"\\\"\".to_string();\n+    for piece in pieces {\n+        match piece {\n+            FormatArgsPiece::Literal(s) => {\n+                for c in s.as_str().escape_debug() {\n+                    template.push(c);\n+                    if let '{' | '}' = c {\n+                        template.push(c);\n+                    }\n+                }\n+            }\n+            FormatArgsPiece::Placeholder(p) => {\n+                template.push('{');\n+                let (Ok(n) | Err(n)) = p.argument.index;\n+                write!(template, \"{n}\").unwrap();\n+                if p.format_options != Default::default() || p.format_trait != FormatTrait::Display\n+                {\n+                    template.push_str(\":\");\n+                }\n+                if let Some(fill) = p.format_options.fill {\n+                    template.push(fill);\n+                }\n+                match p.format_options.alignment {\n+                    Some(FormatAlignment::Left) => template.push_str(\"<\"),\n+                    Some(FormatAlignment::Right) => template.push_str(\">\"),\n+                    Some(FormatAlignment::Center) => template.push_str(\"^\"),\n+                    None => {}\n+                }\n+                let flags = p.format_options.flags;\n+                if flags >> (rustc_parse_format::FlagSignPlus as usize) & 1 != 0 {\n+                    template.push('+');\n+                }\n+                if flags >> (rustc_parse_format::FlagSignMinus as usize) & 1 != 0 {\n+                    template.push('-');\n+                }\n+                if flags >> (rustc_parse_format::FlagAlternate as usize) & 1 != 0 {\n+                    template.push('#');\n+                }\n+                if flags >> (rustc_parse_format::FlagSignAwareZeroPad as usize) & 1 != 0 {\n+                    template.push('0');\n+                }\n+                if let Some(width) = &p.format_options.width {\n+                    match width {\n+                        FormatCount::Literal(n) => write!(template, \"{n}\").unwrap(),\n+                        FormatCount::Argument(FormatArgPosition {\n+                            index: Ok(n) | Err(n), ..\n+                        }) => {\n+                            write!(template, \"{n}$\").unwrap();\n+                        }\n+                    }\n+                }\n+                if let Some(precision) = &p.format_options.precision {\n+                    template.push('.');\n+                    match precision {\n+                        FormatCount::Literal(n) => write!(template, \"{n}\").unwrap(),\n+                        FormatCount::Argument(FormatArgPosition {\n+                            index: Ok(n) | Err(n), ..\n+                        }) => {\n+                            write!(template, \"{n}$\").unwrap();\n+                        }\n+                    }\n+                }\n+                if flags >> (rustc_parse_format::FlagDebugLowerHex as usize) & 1 != 0 {\n+                    template.push('x');\n+                }\n+                if flags >> (rustc_parse_format::FlagDebugUpperHex as usize) & 1 != 0 {\n+                    template.push('X');\n+                }\n+                template.push_str(match p.format_trait {\n+                    FormatTrait::Display => \"\",\n+                    FormatTrait::Debug => \"?\",\n+                    FormatTrait::LowerExp => \"e\",\n+                    FormatTrait::UpperExp => \"E\",\n+                    FormatTrait::Octal => \"o\",\n+                    FormatTrait::Pointer => \"p\",\n+                    FormatTrait::Binary => \"b\",\n+                    FormatTrait::LowerHex => \"x\",\n+                    FormatTrait::UpperHex => \"X\",\n+                });\n+                template.push('}');\n+            }\n+        }\n+    }\n+    template.push('\"');\n+    template\n+}"}, {"sha": "342b1735661df9acd779fdf54fc6f7fc6154174c", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -297,6 +297,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::Continue(_)\n             | ExprKind::Err\n             | ExprKind::Field(_, _)\n+            | ExprKind::FormatArgs(_)\n             | ExprKind::ForLoop(_, _, _, _)\n             | ExprKind::If(_, _, _)\n             | ExprKind::IncludedBytes(..)"}, {"sha": "469f0dc130383cb17b87d1010b2439330e884b7a", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -1,7 +1,11 @@\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_ast::Expr;\n+use rustc_ast::{\n+    Expr, ExprKind, FormatAlignment, FormatArgPosition, FormatArgPositionKind, FormatArgs,\n+    FormatArgsPiece, FormatArgument, FormatArgumentKind, FormatArguments, FormatCount,\n+    FormatOptions, FormatPlaceholder, FormatTrait,\n+};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, Applicability, MultiSpan, PResult};\n use rustc_expand::base::{self, *};\n@@ -12,21 +16,15 @@ use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n \n-mod ast;\n-use ast::*;\n-\n-mod expand;\n-use expand::expand_parsed_format_args;\n-\n // The format_args!() macro is expanded in three steps:\n //  1. First, `parse_args` will parse the `(literal, arg, arg, name=arg, name=arg)` syntax,\n //     but doesn't parse the template (the literal) itself.\n //  2. Second, `make_format_args` will parse the template, the format options, resolve argument references,\n-//     produce diagnostics, and turn the whole thing into a `FormatArgs` structure.\n-//  3. Finally, `expand_parsed_format_args` will turn that `FormatArgs` structure\n-//     into the expression that the macro expands to.\n+//     produce diagnostics, and turn the whole thing into a `FormatArgs` AST node.\n+//  3. Much later, in AST lowering (rustc_ast_lowering), that `FormatArgs` structure will be turned\n+//     into the expression of type `core::fmt::Arguments`.\n \n-// See format/ast.rs for the FormatArgs structure and glossary.\n+// See rustc_ast/src/format.rs for the FormatArgs structure and glossary.\n \n // Only used in parse_args and report_invalid_references,\n // to indicate how a referred argument was used.\n@@ -850,7 +848,7 @@ fn expand_format_args_impl<'cx>(\n     match parse_args(ecx, sp, tts) {\n         Ok((efmt, args)) => {\n             if let Ok(format_args) = make_format_args(ecx, efmt, args, nl) {\n-                MacEager::expr(expand_parsed_format_args(ecx, format_args))\n+                MacEager::expr(ecx.expr(sp, ExprKind::FormatArgs(P(format_args))))\n             } else {\n                 MacEager::expr(DummyResult::raw_expr(sp, true))\n             }"}, {"sha": "9dde5efcb28b7611c514e8517fc0d769fcb4d126", "filename": "compiler/rustc_builtin_macros/src/format/expand.rs", "status": "removed", "additions": 0, "deletions": 353, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -1,353 +0,0 @@\n-use super::*;\n-use rustc_ast as ast;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{BlockCheckMode, UnsafeSource};\n-use rustc_data_structures::fx::FxIndexSet;\n-use rustc_span::{sym, symbol::kw};\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-enum ArgumentType {\n-    Format(FormatTrait),\n-    Usize,\n-}\n-\n-fn make_argument(ecx: &ExtCtxt<'_>, sp: Span, arg: P<ast::Expr>, ty: ArgumentType) -> P<ast::Expr> {\n-    // Generate:\n-    //     ::core::fmt::ArgumentV1::new_\u2026(arg)\n-    use ArgumentType::*;\n-    use FormatTrait::*;\n-    ecx.expr_call_global(\n-        sp,\n-        ecx.std_path(&[\n-            sym::fmt,\n-            sym::ArgumentV1,\n-            match ty {\n-                Format(Display) => sym::new_display,\n-                Format(Debug) => sym::new_debug,\n-                Format(LowerExp) => sym::new_lower_exp,\n-                Format(UpperExp) => sym::new_upper_exp,\n-                Format(Octal) => sym::new_octal,\n-                Format(Pointer) => sym::new_pointer,\n-                Format(Binary) => sym::new_binary,\n-                Format(LowerHex) => sym::new_lower_hex,\n-                Format(UpperHex) => sym::new_upper_hex,\n-                Usize => sym::from_usize,\n-            },\n-        ]),\n-        vec![arg],\n-    )\n-}\n-\n-fn make_count(\n-    ecx: &ExtCtxt<'_>,\n-    sp: Span,\n-    count: &Option<FormatCount>,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n-) -> P<ast::Expr> {\n-    // Generate:\n-    //     ::core::fmt::rt::v1::Count::\u2026(\u2026)\n-    match count {\n-        Some(FormatCount::Literal(n)) => ecx.expr_call_global(\n-            sp,\n-            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Is]),\n-            vec![ecx.expr_usize(sp, *n)],\n-        ),\n-        Some(FormatCount::Argument(arg)) => {\n-            if let Ok(arg_index) = arg.index {\n-                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n-                ecx.expr_call_global(\n-                    sp,\n-                    ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Param]),\n-                    vec![ecx.expr_usize(sp, i)],\n-                )\n-            } else {\n-                DummyResult::raw_expr(sp, true)\n-            }\n-        }\n-        None => ecx.expr_path(ecx.path_global(\n-            sp,\n-            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Implied]),\n-        )),\n-    }\n-}\n-\n-fn make_format_spec(\n-    ecx: &ExtCtxt<'_>,\n-    sp: Span,\n-    placeholder: &FormatPlaceholder,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n-) -> P<ast::Expr> {\n-    // Generate:\n-    //     ::core::fmt::rt::v1::Argument {\n-    //         position: 0usize,\n-    //         format: ::core::fmt::rt::v1::FormatSpec {\n-    //             fill: ' ',\n-    //             align: ::core::fmt::rt::v1::Alignment::Unknown,\n-    //             flags: 0u32,\n-    //             precision: ::core::fmt::rt::v1::Count::Implied,\n-    //             width: ::core::fmt::rt::v1::Count::Implied,\n-    //         },\n-    //     }\n-    let position = match placeholder.argument.index {\n-        Ok(arg_index) => {\n-            let (i, _) =\n-                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n-            ecx.expr_usize(sp, i)\n-        }\n-        Err(_) => DummyResult::raw_expr(sp, true),\n-    };\n-    let fill = ecx.expr_char(sp, placeholder.format_options.fill.unwrap_or(' '));\n-    let align = ecx.expr_path(ecx.path_global(\n-        sp,\n-        ecx.std_path(&[\n-            sym::fmt,\n-            sym::rt,\n-            sym::v1,\n-            sym::Alignment,\n-            match placeholder.format_options.alignment {\n-                Some(FormatAlignment::Left) => sym::Left,\n-                Some(FormatAlignment::Right) => sym::Right,\n-                Some(FormatAlignment::Center) => sym::Center,\n-                None => sym::Unknown,\n-            },\n-        ]),\n-    ));\n-    let flags = ecx.expr_u32(sp, placeholder.format_options.flags);\n-    let prec = make_count(ecx, sp, &placeholder.format_options.precision, argmap);\n-    let width = make_count(ecx, sp, &placeholder.format_options.width, argmap);\n-    ecx.expr_struct(\n-        sp,\n-        ecx.path_global(sp, ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Argument])),\n-        vec![\n-            ecx.field_imm(sp, Ident::new(sym::position, sp), position),\n-            ecx.field_imm(\n-                sp,\n-                Ident::new(sym::format, sp),\n-                ecx.expr_struct(\n-                    sp,\n-                    ecx.path_global(\n-                        sp,\n-                        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::FormatSpec]),\n-                    ),\n-                    vec![\n-                        ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n-                        ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n-                        ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n-                        ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n-                        ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n-                    ],\n-                ),\n-            ),\n-        ],\n-    )\n-}\n-\n-pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<ast::Expr> {\n-    let macsp = ecx.with_def_site_ctxt(ecx.call_site());\n-\n-    let lit_pieces = ecx.expr_array_ref(\n-        fmt.span,\n-        fmt.template\n-            .iter()\n-            .enumerate()\n-            .filter_map(|(i, piece)| match piece {\n-                &FormatArgsPiece::Literal(s) => Some(ecx.expr_str(fmt.span, s)),\n-                &FormatArgsPiece::Placeholder(_) => {\n-                    // Inject empty string before placeholders when not already preceded by a literal piece.\n-                    if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n-                        Some(ecx.expr_str(fmt.span, kw::Empty))\n-                    } else {\n-                        None\n-                    }\n-                }\n-            })\n-            .collect(),\n-    );\n-\n-    // Whether we'll use the `Arguments::new_v1_formatted` form (true),\n-    // or the `Arguments::new_v1` form (false).\n-    let mut use_format_options = false;\n-\n-    // Create a list of all _unique_ (argument, format trait) combinations.\n-    // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n-    let mut argmap = FxIndexSet::default();\n-    for piece in &fmt.template {\n-        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n-        if placeholder.format_options != Default::default() {\n-            // Can't use basic form if there's any formatting options.\n-            use_format_options = true;\n-        }\n-        if let Ok(index) = placeholder.argument.index {\n-            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n-                // Duplicate (argument, format trait) combination,\n-                // which we'll only put once in the args array.\n-                use_format_options = true;\n-            }\n-        }\n-    }\n-\n-    let format_options = use_format_options.then(|| {\n-        // Generate:\n-        //     &[format_spec_0, format_spec_1, format_spec_2]\n-        ecx.expr_array_ref(\n-            macsp,\n-            fmt.template\n-                .iter()\n-                .filter_map(|piece| {\n-                    let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n-                    Some(make_format_spec(ecx, macsp, placeholder, &mut argmap))\n-                })\n-                .collect(),\n-        )\n-    });\n-\n-    let arguments = fmt.arguments.into_vec();\n-\n-    // If the args array contains exactly all the original arguments once,\n-    // in order, we can use a simple array instead of a `match` construction.\n-    // However, if there's a yield point in any argument except the first one,\n-    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n-    let use_simple_array = argmap.len() == arguments.len()\n-        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n-        && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n-\n-    let args = if use_simple_array {\n-        // Generate:\n-        //     &[\n-        //         ::core::fmt::ArgumentV1::new_display(&arg0),\n-        //         ::core::fmt::ArgumentV1::new_lower_hex(&arg1),\n-        //         ::core::fmt::ArgumentV1::new_debug(&arg2),\n-        //     ]\n-        ecx.expr_array_ref(\n-            macsp,\n-            arguments\n-                .into_iter()\n-                .zip(argmap)\n-                .map(|(arg, (_, ty))| {\n-                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-                    make_argument(ecx, sp, ecx.expr_addr_of(sp, arg.expr), ty)\n-                })\n-                .collect(),\n-        )\n-    } else {\n-        // Generate:\n-        //     match (&arg0, &arg1, &arg2) {\n-        //         args => &[\n-        //             ::core::fmt::ArgumentV1::new_display(args.0),\n-        //             ::core::fmt::ArgumentV1::new_lower_hex(args.1),\n-        //             ::core::fmt::ArgumentV1::new_debug(args.0),\n-        //         ]\n-        //     }\n-        let args_ident = Ident::new(sym::args, macsp);\n-        let args = argmap\n-            .iter()\n-            .map(|&(arg_index, ty)| {\n-                if let Some(arg) = arguments.get(arg_index) {\n-                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-                    make_argument(\n-                        ecx,\n-                        sp,\n-                        ecx.expr_field(\n-                            sp,\n-                            ecx.expr_ident(macsp, args_ident),\n-                            Ident::new(sym::integer(arg_index), macsp),\n-                        ),\n-                        ty,\n-                    )\n-                } else {\n-                    DummyResult::raw_expr(macsp, true)\n-                }\n-            })\n-            .collect();\n-        ecx.expr_addr_of(\n-            macsp,\n-            ecx.expr_match(\n-                macsp,\n-                ecx.expr_tuple(\n-                    macsp,\n-                    arguments\n-                        .into_iter()\n-                        .map(|arg| {\n-                            ecx.expr_addr_of(arg.expr.span.with_ctxt(macsp.ctxt()), arg.expr)\n-                        })\n-                        .collect(),\n-                ),\n-                vec![ecx.arm(macsp, ecx.pat_ident(macsp, args_ident), ecx.expr_array(macsp, args))],\n-            ),\n-        )\n-    };\n-\n-    if let Some(format_options) = format_options {\n-        // Generate:\n-        //     ::core::fmt::Arguments::new_v1_formatted(\n-        //         lit_pieces,\n-        //         args,\n-        //         format_options,\n-        //         unsafe { ::core::fmt::UnsafeArg::new() }\n-        //     )\n-        ecx.expr_call_global(\n-            macsp,\n-            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1_formatted]),\n-            vec![\n-                lit_pieces,\n-                args,\n-                format_options,\n-                ecx.expr_block(P(ast::Block {\n-                    stmts: vec![ecx.stmt_expr(ecx.expr_call_global(\n-                        macsp,\n-                        ecx.std_path(&[sym::fmt, sym::UnsafeArg, sym::new]),\n-                        Vec::new(),\n-                    ))],\n-                    id: ast::DUMMY_NODE_ID,\n-                    rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n-                    span: macsp,\n-                    tokens: None,\n-                    could_be_bare_literal: false,\n-                })),\n-            ],\n-        )\n-    } else {\n-        // Generate:\n-        //     ::core::fmt::Arguments::new_v1(\n-        //         lit_pieces,\n-        //         args,\n-        //     )\n-        ecx.expr_call_global(\n-            macsp,\n-            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1]),\n-            vec![lit_pieces, args],\n-        )\n-    }\n-}\n-\n-fn may_contain_yield_point(e: &ast::Expr) -> bool {\n-    struct MayContainYieldPoint(bool);\n-\n-    impl Visitor<'_> for MayContainYieldPoint {\n-        fn visit_expr(&mut self, e: &ast::Expr) {\n-            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n-                self.0 = true;\n-            } else {\n-                visit::walk_expr(self, e);\n-            }\n-        }\n-\n-        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n-            self.0 = true;\n-        }\n-\n-        fn visit_attribute(&mut self, _: &ast::Attribute) {\n-            // Conservatively assume this may be a proc macro attribute in\n-            // expression position.\n-            self.0 = true;\n-        }\n-\n-        fn visit_item(&mut self, _: &ast::Item) {\n-            // Do not recurse into nested items.\n-        }\n-    }\n-\n-    let mut visitor = MayContainYieldPoint(false);\n-    visitor.visit_expr(e);\n-    visitor.0\n-}"}, {"sha": "5a620263e4299a2b51fb9f4c032196f22e597534", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -2117,6 +2117,8 @@ pub enum MatchSource {\n     TryDesugar,\n     /// A desugared `<expr>.await`.\n     AwaitDesugar,\n+    /// A desugared `format_args!()`.\n+    FormatArgs,\n }\n \n impl MatchSource {\n@@ -2128,6 +2130,7 @@ impl MatchSource {\n             ForLoopDesugar => \"for\",\n             TryDesugar => \"?\",\n             AwaitDesugar => \".await\",\n+            FormatArgs => \"format_args!()\",\n         }\n     }\n }"}, {"sha": "9158fc082471f8fbedaf7e915fa998d83243215d", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -244,6 +244,14 @@ language_item_table! {\n     /// libstd panic entry point. Necessary for const eval to be able to catch it\n     BeginPanic,              sym::begin_panic,         begin_panic_fn,             Target::Fn,             GenericRequirement::None;\n \n+    // Lang items needed for `format_args!()`.\n+    FormatAlignment,         sym::format_alignment,    format_alignment,           Target::Enum,           GenericRequirement::None;\n+    FormatArgument,          sym::format_argument,     format_argument,            Target::Struct,         GenericRequirement::None;\n+    FormatArguments,         sym::format_arguments,    format_arguments,           Target::Struct,         GenericRequirement::None;\n+    FormatCount,             sym::format_count,        format_count,               Target::Enum,           GenericRequirement::None;\n+    FormatPlaceholder,       sym::format_placeholder,  format_placeholder,         Target::Struct,         GenericRequirement::None;\n+    FormatUnsafeArg,         sym::format_unsafe_arg,   format_unsafe_arg,          Target::Struct,         GenericRequirement::None;\n+\n     ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n     BoxFree,                 sym::box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n     DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);"}, {"sha": "17e4ccb417902ca1774b115139ea2dce86949f4f", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -208,9 +208,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             // Don't report arm reachability of desugared `match $iter.into_iter() { iter => .. }`\n             // when the iterator is an uninhabited type. unreachable_code will trigger instead.\n             hir::MatchSource::ForLoopDesugar if arms.len() == 1 => {}\n-            hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                report_arm_reachability(&cx, &report)\n-            }\n+            hir::MatchSource::ForLoopDesugar\n+            | hir::MatchSource::Normal\n+            | hir::MatchSource::FormatArgs => report_arm_reachability(&cx, &report),\n             // Unreachable patterns in try and await expressions occur when one of\n             // the arms are an uninhabited type. Which is OK.\n             hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}"}, {"sha": "dd8c646a43c82e837b0393155f7660931147e0d1", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -48,7 +48,7 @@ impl NonConstExpr {\n             Self::Match(TryDesugar) => &[sym::const_try],\n \n             // All other expressions are allowed.\n-            Self::Loop(Loop | While) | Self::Match(Normal) => &[],\n+            Self::Loop(Loop | While) | Self::Match(Normal | FormatArgs) => &[],\n         };\n \n         Some(gates)"}, {"sha": "d1b896e940e6e7d6f054b22c2ac7bc0f98e8b592", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -567,7 +567,7 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n                 Box, Array, ConstBlock, Call, MethodCall, Tup, Binary, Unary, Lit, Cast, Type, Let,\n                 If, While, ForLoop, Loop, Match, Closure, Block, Async, Await, TryBlock, Assign,\n                 AssignOp, Field, Index, Range, Underscore, Path, AddrOf, Break, Continue, Ret,\n-                InlineAsm, MacCall, Struct, Repeat, Paren, Try, Yield, Yeet, IncludedBytes, Err\n+                InlineAsm, FormatArgs, MacCall, Struct, Repeat, Paren, Try, Yield, Yeet, IncludedBytes, Err\n             ]\n         );\n         ast_visit::walk_expr(self, e)"}, {"sha": "30ca0b8060d22b2bdfbd5668aafe03c41ff20109", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -724,11 +724,17 @@ symbols! {\n         forbid,\n         forget,\n         format,\n+        format_alignment,\n         format_args,\n         format_args_capture,\n         format_args_macro,\n         format_args_nl,\n+        format_argument,\n+        format_arguments,\n+        format_count,\n         format_macro,\n+        format_placeholder,\n+        format_unsafe_arg,\n         freeze,\n         freg,\n         frem_fast,"}, {"sha": "c9821bf8109a7f39c43601292327994065131898", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -267,6 +267,7 @@ extern \"C\" {\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n+#[cfg_attr(not(bootstrap), lang = \"format_argument\")]\n #[derive(Copy, Clone)]\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n@@ -279,6 +280,7 @@ pub struct ArgumentV1<'a> {\n /// This struct represents the unsafety of constructing an `Arguments`.\n /// It exists, rather than an unsafe function, in order to simplify the expansion\n /// of `format_args!(..)` and reduce the scope of the `unsafe` block.\n+#[cfg_attr(not(bootstrap), lang = \"format_unsafe_arg\")]\n #[allow(missing_debug_implementations)]\n #[doc(hidden)]\n #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n@@ -473,8 +475,8 @@ impl<'a> Arguments<'a> {\n /// ```\n ///\n /// [`format()`]: ../../std/fmt/fn.format.html\n+#[cfg_attr(not(bootstrap), lang = \"format_arguments\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"Arguments\")]\n #[derive(Copy, Clone)]\n pub struct Arguments<'a> {\n     // Format string pieces to print."}, {"sha": "11a50951a75dad1798ad15167388e895053f1ece", "filename": "library/core/src/fmt/rt/v1.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/library%2Fcore%2Fsrc%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/library%2Fcore%2Fsrc%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Frt%2Fv1.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -5,7 +5,9 @@\n //! these can be statically allocated and are slightly optimized for the runtime\n #![allow(missing_debug_implementations)]\n \n+#[cfg_attr(not(bootstrap), lang = \"format_placeholder\")]\n #[derive(Copy, Clone)]\n+// FIXME: Rename this to Placeholder\n pub struct Argument {\n     pub position: usize,\n     pub format: FormatSpec,\n@@ -20,7 +22,22 @@ pub struct FormatSpec {\n     pub width: Count,\n }\n \n+impl Argument {\n+    #[inline(always)]\n+    pub const fn new(\n+        position: usize,\n+        fill: char,\n+        align: Alignment,\n+        flags: u32,\n+        precision: Count,\n+        width: Count,\n+    ) -> Self {\n+        Self { position, format: FormatSpec { fill, align, flags, precision, width } }\n+    }\n+}\n+\n /// Possible alignments that can be requested as part of a formatting directive.\n+#[cfg_attr(not(bootstrap), lang = \"format_alignment\")]\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum Alignment {\n     /// Indication that contents should be left-aligned.\n@@ -34,6 +51,7 @@ pub enum Alignment {\n }\n \n /// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n+#[cfg_attr(not(bootstrap), lang = \"format_count\")]\n #[derive(Copy, Clone)]\n pub enum Count {\n     /// Specified with a literal number, stores the value"}, {"sha": "70a80d40f464bbbd5bbabac0b0be673742b557b3", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -7,14 +7,14 @@ use clippy_utils::macros::{\n };\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n+use clippy_utils::ty::{implements_trait, is_type_lang_item};\n use if_chain::if_chain;\n use itertools::Itertools;\n use rustc_errors::{\n     Applicability,\n     SuggestionStyle::{CompletelyHidden, ShowCode},\n };\n-use rustc_hir::{Expr, ExprKind, HirId, QPath};\n+use rustc_hir::{Expr, ExprKind, HirId, LangItem, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n@@ -237,7 +237,7 @@ fn check_unused_format_specifier(cx: &LateContext<'_>, arg: &FormatArg<'_>) {\n         );\n     }\n \n-    if is_type_diagnostic_item(cx, param_ty, sym::Arguments) && !arg.format.is_default_for_trait() {\n+    if is_type_lang_item(cx, param_ty, LangItem::FormatArguments) && !arg.format.is_default_for_trait() {\n         span_lint_and_then(\n             cx,\n             UNUSED_FORMAT_SPECS,"}, {"sha": "a8f8da67b51711807ba146c7577bb4a93870086b", "filename": "src/tools/clippy/clippy_utils/src/macros.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -1,14 +1,13 @@\n #![allow(clippy::similar_names)] // `expr` and `expn`\n \n-use crate::is_path_diagnostic_item;\n use crate::source::snippet_opt;\n use crate::visitors::{for_each_expr, Descend};\n \n use arrayvec::ArrayVec;\n use itertools::{izip, Either, Itertools};\n use rustc_ast::ast::LitKind;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{self as hir, Expr, ExprField, ExprKind, HirId, Node, QPath};\n+use rustc_hir::{self as hir, Expr, ExprField, ExprKind, HirId, LangItem, Node, QPath, TyKind};\n use rustc_lexer::unescape::unescape_literal;\n use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n use rustc_lint::LateContext;\n@@ -439,8 +438,7 @@ impl<'tcx> FormatArgsValues<'tcx> {\n                 // ArgumentV1::from_usize(<val>)\n                 if let ExprKind::Call(callee, [val]) = expr.kind\n                     && let ExprKind::Path(QPath::TypeRelative(ty, _)) = callee.kind\n-                    && let hir::TyKind::Path(QPath::Resolved(_, path)) = ty.kind\n-                    && path.segments.last().unwrap().ident.name == sym::ArgumentV1\n+                    && let TyKind::Path(QPath::LangItem(LangItem::FormatArgument, _, _)) = ty.kind\n                 {\n                     let val_idx = if val.span.ctxt() == expr.span.ctxt()\n                         && let ExprKind::Field(_, field) = val.kind\n@@ -486,20 +484,6 @@ struct ParamPosition {\n \n impl<'tcx> Visitor<'tcx> for ParamPosition {\n     fn visit_expr_field(&mut self, field: &'tcx ExprField<'tcx>) {\n-        fn parse_count(expr: &Expr<'_>) -> Option<usize> {\n-            // ::core::fmt::rt::v1::Count::Param(1usize),\n-            if let ExprKind::Call(ctor, [val]) = expr.kind\n-                && let ExprKind::Path(QPath::Resolved(_, path)) = ctor.kind\n-                && path.segments.last()?.ident.name == sym::Param\n-                && let ExprKind::Lit(lit) = &val.kind\n-                && let LitKind::Int(pos, _) = lit.node\n-            {\n-                Some(pos as usize)\n-            } else {\n-                None\n-            }\n-        }\n-\n         match field.ident.name {\n             sym::position => {\n                 if let ExprKind::Lit(lit) = &field.expr.kind\n@@ -519,15 +503,41 @@ impl<'tcx> Visitor<'tcx> for ParamPosition {\n     }\n }\n \n+fn parse_count(expr: &Expr<'_>) -> Option<usize> {\n+    // <::core::fmt::rt::v1::Count>::Param(1usize),\n+    if let ExprKind::Call(ctor, [val]) = expr.kind\n+        && let ExprKind::Path(QPath::TypeRelative(_, path)) = ctor.kind\n+            && path.ident.name == sym::Param\n+            && let ExprKind::Lit(lit) = &val.kind\n+            && let LitKind::Int(pos, _) = lit.node\n+    {\n+        Some(pos as usize)\n+    } else {\n+        None\n+    }\n+}\n+\n /// Parses the `fmt` arg of `Arguments::new_v1_formatted(pieces, args, fmt, _)`\n fn parse_rt_fmt<'tcx>(fmt_arg: &'tcx Expr<'tcx>) -> Option<impl Iterator<Item = ParamPosition> + 'tcx> {\n     if let ExprKind::AddrOf(.., array) = fmt_arg.kind\n         && let ExprKind::Array(specs) = array.kind\n     {\n         Some(specs.iter().map(|spec| {\n-            let mut position = ParamPosition::default();\n-            position.visit_expr(spec);\n-            position\n+            if let ExprKind::Call(f, args) = spec.kind\n+                && let ExprKind::Path(QPath::TypeRelative(ty, f)) = f.kind\n+                && let TyKind::Path(QPath::LangItem(LangItem::FormatPlaceholder, _, _)) = ty.kind\n+                && f.ident.name == sym::new\n+                && let [position, _fill, _align, _flags, precision, width] = args\n+                && let ExprKind::Lit(position) = &position.kind\n+                && let LitKind::Int(position, _) = position.node {\n+                    ParamPosition {\n+                        value: position as usize,\n+                        width: parse_count(width),\n+                        precision: parse_count(precision),\n+                    }\n+            } else {\n+                ParamPosition::default()\n+            }\n         }))\n     } else {\n         None\n@@ -890,7 +900,7 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n         // ::core::fmt::Arguments::new_v1_formatted(pieces, args, fmt, _unsafe_arg)\n         if let ExprKind::Call(callee, [pieces, args, rest @ ..]) = expr.kind\n             && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind\n-            && is_path_diagnostic_item(cx, ty, sym::Arguments)\n+            && let TyKind::Path(QPath::LangItem(LangItem::FormatArguments, _, _)) = ty.kind\n             && matches!(seg.ident.as_str(), \"new_v1\" | \"new_v1_formatted\")\n         {\n             let format_string = FormatString::new(cx, pieces)?;"}, {"sha": "2d1044af17e8c331c0a964cb6330ff5ea2290ad4", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -219,6 +219,7 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::Repeat(..)\n             | ast::ExprKind::Ret(..)\n             | ast::ExprKind::Yeet(..)\n+            | ast::ExprKind::FormatArgs(..)\n             | ast::ExprKind::Struct(..)\n             | ast::ExprKind::Try(..)\n             | ast::ExprKind::TryBlock(..)"}, {"sha": "3f0f217f8907d7beba609835f913806a4a542a44", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -400,7 +400,10 @@ pub(crate) fn format_expr(\n             }\n         }\n         ast::ExprKind::Underscore => Some(\"_\".to_owned()),\n-        ast::ExprKind::IncludedBytes(..) => unreachable!(),\n+        ast::ExprKind::FormatArgs(..) | ast::ExprKind::IncludedBytes(..) => {\n+            // These do not occur in the AST because macros aren't expanded.\n+            unreachable!()\n+        }\n         ast::ExprKind::Err => None,\n     };\n "}, {"sha": "1e89f3ae75f8167b7ebfb170a0731411a65220b7", "filename": "src/tools/rustfmt/src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -463,6 +463,7 @@ pub(crate) fn first_line_ends_with(s: &str, c: char) -> bool {\n pub(crate) fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.kind {\n         ast::ExprKind::MacCall(..)\n+        | ast::ExprKind::FormatArgs(..)\n         | ast::ExprKind::Call(..)\n         | ast::ExprKind::MethodCall(..)\n         | ast::ExprKind::Array(..)"}, {"sha": "60fddb630d964d72bfdcbb0b32c0bb768a192e54", "filename": "tests/pretty/dollar-crate.pp", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/tests%2Fpretty%2Fdollar-crate.pp", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/tests%2Fpretty%2Fdollar-crate.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpretty%2Fdollar-crate.pp?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -8,6 +8,4 @@\n // pretty-mode:expanded\n // pp-exact:dollar-crate.pp\n \n-fn main() {\n-    { ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"], &[])); };\n-}\n+fn main() { { ::std::io::_print(format_args!(\"rust\\n\")); }; }"}, {"sha": "44d21625a2d108a2e14e966d2e14328215adfa7b", "filename": "tests/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/tests%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/tests%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpretty%2Fissue-4264.pp?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -32,7 +32,7 @@\n         ({\n                 let res =\n                     ((::alloc::fmt::format as\n-                            for<'a> fn(Arguments<'a>) -> String {format})(((::core::fmt::Arguments::new_v1\n+                            for<'a> fn(Arguments<'a>) -> String {format})(((<#[lang = \"format_arguments\"]>::new_v1\n                                 as\n                                 fn(&[&'static str], &[ArgumentV1<'_>]) -> Arguments<'_> {Arguments::<'_>::new_v1})((&([(\"test\"\n                                             as &str)] as [&str; 1]) as &[&str; 1]),"}, {"sha": "aaa8b169583fd667d723ea93d733ccd262f66ee3", "filename": "tests/ui/attributes/key-value-expansion.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/tests%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/tests%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Fkey-value-expansion.stderr?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -15,12 +15,7 @@ LL | bug!();\n    |\n    = note: this error originates in the macro `bug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: unexpected expression: `{\n-               let res =\n-                   ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[\"\"],\n-                           &[::core::fmt::ArgumentV1::new_display(&\"u8\")]));\n-               res\n-           }.as_str()`\n+error: unexpected expression: `{ let res = ::alloc::fmt::format(format_args!(\"{0}\", \"u8\")); res }.as_str()`\n   --> $DIR/key-value-expansion.rs:48:23\n    |\n LL |         doc_comment! {format!(\"{coor}\", coor = stringify!($t1)).as_str()}"}, {"sha": "ad97f7a4a7540d08bc99643e5bb17f99d721d37b", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/non-consuming-methods-have-optimized-codegen.stdout", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout?ref=3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "patch": "@@ -25,8 +25,8 @@ fn arbitrary_consuming_method_for_demonstration_purposes() {\n \n \n                 {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem as usize\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                    ::std::rt::panic_fmt(format_args!(\"Assertion failed: elem as usize\\nWith captures:\\n  elem = {0:?}\\n\",\n+                            __capture0))\n                 }\n             }\n     };\n@@ -41,8 +41,8 @@ fn addr_of() {\n         if ::core::intrinsics::unlikely(!&*__local_bind0) {\n                 (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n                 {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: &elem\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                    ::std::rt::panic_fmt(format_args!(\"Assertion failed: &elem\\nWith captures:\\n  elem = {0:?}\\n\",\n+                            __capture0))\n                 }\n             }\n     };\n@@ -57,8 +57,8 @@ fn binary() {\n         if ::core::intrinsics::unlikely(!(*__local_bind0 == 1)) {\n                 (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n                 {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem == 1\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                    ::std::rt::panic_fmt(format_args!(\"Assertion failed: elem == 1\\nWith captures:\\n  elem = {0:?}\\n\",\n+                            __capture0))\n                 }\n             }\n     };\n@@ -70,8 +70,8 @@ fn binary() {\n         if ::core::intrinsics::unlikely(!(*__local_bind0 >= 1)) {\n                 (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n                 {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem >= 1\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                    ::std::rt::panic_fmt(format_args!(\"Assertion failed: elem >= 1\\nWith captures:\\n  elem = {0:?}\\n\",\n+                            __capture0))\n                 }\n             }\n     };\n@@ -83,8 +83,8 @@ fn binary() {\n         if ::core::intrinsics::unlikely(!(*__local_bind0 > 0)) {\n                 (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n                 {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem > 0\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                    ::std::rt::panic_fmt(format_args!(\"Assertion failed: elem > 0\\nWith captures:\\n  elem = {0:?}\\n\",\n+                            __capture0))\n                 }\n             }\n     };\n@@ -96,8 +96,8 @@ fn binary() {\n         if ::core::intrinsics::unlikely(!(*__local_bind0 < 3)) {\n                 (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n                 {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem < 3\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                    ::std::rt::panic_fmt(format_args!(\"Assertion failed: elem < 3\\nWith captures:\\n  elem = {0:?}\\n\",\n+                            __capture0))\n                 }\n             }\n     };\n@@ -109,8 +109,8 @@ fn binary() {\n         if ::core::intrinsics::unlikely(!(*__local_bind0 <= 3)) {\n                 (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n                 {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem <= 3\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                    ::std::rt::panic_fmt(format_args!(\"Assertion failed: elem <= 3\\nWith captures:\\n  elem = {0:?}\\n\",\n+                            __capture0))\n                 }\n             }\n     };\n@@ -122,8 +122,8 @@ fn binary() {\n         if ::core::intrinsics::unlikely(!(*__local_bind0 != 3)) {\n                 (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n                 {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem != 3\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                    ::std::rt::panic_fmt(format_args!(\"Assertion failed: elem != 3\\nWith captures:\\n  elem = {0:?}\\n\",\n+                            __capture0))\n                 }\n             }\n     };\n@@ -138,8 +138,8 @@ fn unary() {\n         if ::core::intrinsics::unlikely(!**__local_bind0) {\n                 (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n                 {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: *elem\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                    ::std::rt::panic_fmt(format_args!(\"Assertion failed: *elem\\nWith captures:\\n  elem = {0:?}\\n\",\n+                            __capture0))\n                 }\n             }\n     };"}]}