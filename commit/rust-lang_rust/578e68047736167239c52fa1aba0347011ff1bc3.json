{"sha": "578e68047736167239c52fa1aba0347011ff1bc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3OGU2ODA0NzczNjE2NzIzOWM1MmZhMWFiYTAzNDcwMTFmZjFiYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-28T02:35:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-28T02:35:44Z"}, "message": "auto merge of #8802 : pcwalton/rust/compile-speed, r=brson\n\nr? @brson", "tree": {"sha": "00dfacbcaf5bcc846757d37cbf7e9309df699cb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00dfacbcaf5bcc846757d37cbf7e9309df699cb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/578e68047736167239c52fa1aba0347011ff1bc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/578e68047736167239c52fa1aba0347011ff1bc3", "html_url": "https://github.com/rust-lang/rust/commit/578e68047736167239c52fa1aba0347011ff1bc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/578e68047736167239c52fa1aba0347011ff1bc3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32117132bdaf572bd4a156ec931579646e16d6f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/32117132bdaf572bd4a156ec931579646e16d6f0", "html_url": "https://github.com/rust-lang/rust/commit/32117132bdaf572bd4a156ec931579646e16d6f0"}, {"sha": "aac9d6eee9a1e0b254bf6e035e2e14e5106758bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/aac9d6eee9a1e0b254bf6e035e2e14e5106758bd", "html_url": "https://github.com/rust-lang/rust/commit/aac9d6eee9a1e0b254bf6e035e2e14e5106758bd"}], "stats": {"total": 4847, "additions": 3067, "deletions": 1780}, "files": [{"sha": "08c04c6c8887e9c046c0b9991073385eecbe187c", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -2230,7 +2230,7 @@ Some examples of call expressions:\n # fn add(x: int, y: int) -> int { 0 }\n \n let x: int = add(1, 2);\n-let pi = FromStr::from_str::<f32>(\"3.14\");\n+let pi: Option<f32> = FromStr::from_str(\"3.14\");\n ~~~~\n \n ### Lambda expressions"}, {"sha": "9516517d9f7bebdc361378b5ae77b6aa8dcb62a8", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -420,6 +420,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_add_bytes_to_bits_tuple_overflow2() {\n-        add_bytes_to_bits_tuple::<u64>((Bounded::max_value::<u64>() - 1, 0), 0x8000000000000000);\n+        let value: u64 = Bounded::max_value();\n+        add_bytes_to_bits_tuple::<u64>((value - 1, 0), 0x8000000000000000);\n     }\n }"}, {"sha": "8e641073637853e103c1c08e29f0fa465a21cf04", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -661,7 +661,7 @@ mod tests {\n \n     #[test]\n     fn test_basic() {\n-        let mut m = DList::new::<~int>();\n+        let mut m: DList<~int> = DList::new();\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n@@ -768,7 +768,7 @@ mod tests {\n \n     #[test]\n     fn test_rotate() {\n-        let mut n = DList::new::<int>();\n+        let mut n: DList<int> = DList::new();\n         n.rotate_backward(); check_links(&n);\n         assert_eq!(n.len(), 0);\n         n.rotate_forward(); check_links(&n);\n@@ -1033,7 +1033,7 @@ mod tests {\n \n     #[cfg(test)]\n     fn fuzz_test(sz: int) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         let mut v = ~[];\n         for i in range(0, sz) {\n             check_links(&m);\n@@ -1078,23 +1078,23 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         do b.iter {\n             m.push_front(0);\n         }\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         do b.iter {\n             m.push_back(0);\n         }\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         do b.iter {\n             m.push_back(0);\n             m.pop_back();\n@@ -1103,7 +1103,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_pop_front(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         do b.iter {\n             m.push_front(0);\n             m.pop_front();\n@@ -1112,7 +1112,7 @@ mod tests {\n \n     #[bench]\n     fn bench_rotate_forward(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         m.push_front(0);\n         m.push_front(1);\n         do b.iter {\n@@ -1122,7 +1122,7 @@ mod tests {\n \n     #[bench]\n     fn bench_rotate_backward(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         m.push_front(0);\n         m.push_front(1);\n         do b.iter {"}, {"sha": "65d4f79c640249e01008fd71e39b37f75cbf9998", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -25,13 +25,13 @@ pub mod rustrt {\n \n     #[link_name = \"rustrt\"]\n     extern {\n-        pub fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n+        pub fn tdefl_compress_mem_to_heap(psrc_buf: *c_void,\n                                           src_buf_len: size_t,\n                                           pout_len: *mut size_t,\n                                           flags: c_int)\n                                           -> *c_void;\n \n-        pub fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n+        pub fn tinfl_decompress_mem_to_heap(psrc_buf: *c_void,\n                                             src_buf_len: size_t,\n                                             pout_len: *mut size_t,\n                                             flags: c_int)"}, {"sha": "5fd9690d9b0b32dbe0b5d94611e1d4f24db6a506", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -359,7 +359,7 @@ impl Integer for BigUint {\n \n         fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut m = a;\n-            let mut d = Zero::zero::<BigUint>();\n+            let mut d: BigUint = Zero::zero();\n             let mut n = 1;\n             while m >= b {\n                 let (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n@@ -411,8 +411,9 @@ impl Integer for BigUint {\n             if shift == 0 {\n                 return (BigUint::new(d), One::one(), (*b).clone());\n             }\n+            let one: BigUint = One::one();\n             return (BigUint::from_slice(d).shl_unit(shift),\n-                    One::one::<BigUint>().shl_unit(shift),\n+                    one.shl_unit(shift),\n                     b.shl_unit(shift));\n         }\n     }\n@@ -1168,8 +1169,8 @@ mod biguint_tests {\n     #[test]\n     fn test_shl() {\n         fn check(s: &str, shift: uint, ans: &str) {\n-            let bu = (FromStrRadix::from_str_radix::<BigUint>(s, 16).unwrap() << shift)\n-                .to_str_radix(16);\n+            let opt_biguint: Option<BigUint> = FromStrRadix::from_str_radix(s, 16);\n+            let bu = (opt_biguint.unwrap() << shift).to_str_radix(16);\n             assert_eq!(bu.as_slice(), ans);\n         }\n \n@@ -1206,8 +1207,9 @@ mod biguint_tests {\n     #[test]\n     fn test_shr() {\n         fn check(s: &str, shift: uint, ans: &str) {\n-            let bu = (FromStrRadix::from_str_radix::<BigUint>(s, 16).unwrap() >> shift)\n-                .to_str_radix(16);\n+            let opt_biguint: Option<BigUint> =\n+                FromStrRadix::from_str_radix(s, 16);\n+            let bu = (opt_biguint.unwrap() >> shift).to_str_radix(16);\n             assert_eq!(bu.as_slice(), ans);\n         }\n \n@@ -1445,11 +1447,18 @@ mod biguint_tests {\n \n     #[test]\n     fn test_is_even() {\n-        assert!(FromStr::from_str::<BigUint>(\"1\").unwrap().is_odd());\n-        assert!(FromStr::from_str::<BigUint>(\"2\").unwrap().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000\").unwrap().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000000\").unwrap().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000001\").unwrap().is_odd());\n+        let one: Option<BigUint> = FromStr::from_str(\"1\");\n+        let two: Option<BigUint> = FromStr::from_str(\"2\");\n+        let thousand: Option<BigUint> = FromStr::from_str(\"1000\");\n+        let big: Option<BigUint> =\n+            FromStr::from_str(\"1000000000000000000000\");\n+        let bigger: Option<BigUint> =\n+            FromStr::from_str(\"1000000000000000000001\");\n+        assert!(one.unwrap().is_odd());\n+        assert!(two.unwrap().is_even());\n+        assert!(thousand.unwrap().is_even());\n+        assert!(big.unwrap().is_even());\n+        assert!(bigger.unwrap().is_odd());\n         assert!((BigUint::from_uint(1) << 64).is_even());\n         assert!(((BigUint::from_uint(1) << 64) + BigUint::from_uint(1)).is_odd());\n     }\n@@ -1534,15 +1543,19 @@ mod biguint_tests {\n             }\n         }\n \n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"Z\", 10), None);\n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"_\", 2), None);\n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"-1\", 10), None);\n+        let zed: Option<BigUint> = FromStrRadix::from_str_radix(\"Z\", 10);\n+        assert_eq!(zed, None);\n+        let blank: Option<BigUint> = FromStrRadix::from_str_radix(\"_\", 2);\n+        assert_eq!(blank, None);\n+        let minus_one: Option<BigUint> = FromStrRadix::from_str_radix(\"-1\",\n+                                                                      10);\n+        assert_eq!(minus_one, None);\n     }\n \n     #[test]\n     fn test_factor() {\n         fn factor(n: uint) -> BigUint {\n-            let mut f= One::one::<BigUint>();\n+            let mut f: BigUint = One::one();\n             for i in range(2, n + 1) {\n                 // FIXME(#6102): Assignment operator for BigInt causes ICE\n                 // f *= BigUint::from_uint(i);\n@@ -1939,17 +1952,24 @@ mod bigint_tests {\n \n     #[test]\n     fn test_abs_sub() {\n-        assert_eq!((-One::one::<BigInt>()).abs_sub(&One::one()), Zero::zero());\n-        assert_eq!(One::one::<BigInt>().abs_sub(&One::one()), Zero::zero());\n-        assert_eq!(One::one::<BigInt>().abs_sub(&Zero::zero()), One::one());\n-        assert_eq!(One::one::<BigInt>().abs_sub(&-One::one::<BigInt>()),\n-                   IntConvertible::from_int(2));\n+        let zero: BigInt = Zero::zero();\n+        let one: BigInt = One::one();\n+        assert_eq!((-one).abs_sub(&one), zero);\n+        let one: BigInt = One::one();\n+        let zero: BigInt = Zero::zero();\n+        assert_eq!(one.abs_sub(&one), zero);\n+        let one: BigInt = One::one();\n+        let zero: BigInt = Zero::zero();\n+        assert_eq!(one.abs_sub(&zero), one);\n+        let one: BigInt = One::one();\n+        assert_eq!(one.abs_sub(&-one), IntConvertible::from_int(2));\n     }\n \n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            assert!(ans == IntConvertible::from_int::<BigInt>(n).to_str_radix(10));\n+            let n: BigInt = IntConvertible::from_int(n);\n+            assert!(ans == n.to_str_radix(10));\n         }\n         check(10, \"10\");\n         check(1, \"1\");\n@@ -1962,7 +1982,10 @@ mod bigint_tests {\n     #[test]\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n-            let ans = ans.map_move(|n| IntConvertible::from_int::<BigInt>(n));\n+            let ans = ans.map_move(|n| {\n+                let x: BigInt = IntConvertible::from_int(n);\n+                x\n+            });\n             assert_eq!(FromStrRadix::from_str_radix(s, 10), ans);\n         }\n         check(\"10\", Some(10));\n@@ -1980,7 +2003,8 @@ mod bigint_tests {\n             BigInt::new(Minus, ~[1, 1, 1]));\n         assert!(-BigInt::new(Minus, ~[1, 1, 1]) ==\n             BigInt::new(Plus,  ~[1, 1, 1]));\n-        assert_eq!(-Zero::zero::<BigInt>(), Zero::zero::<BigInt>());\n+        let zero: BigInt = Zero::zero();\n+        assert_eq!(-zero, zero);\n     }\n }\n \n@@ -1992,16 +2016,16 @@ mod bench {\n     use extra::test::BenchHarness;\n \n     fn factorial(n: uint) -> BigUint {\n-        let mut f = One::one::<BigUint>();\n+        let mut f: BigUint = One::one();\n         for i in iterator::range_inclusive(1, n) {\n             f = f * BigUint::from_uint(i);\n         }\n         f\n     }\n \n     fn fib(n: uint) -> BigUint {\n-        let mut f0 = Zero::zero::<BigUint>();\n-        let mut f1 = One::one::<BigUint>();\n+        let mut f0: BigUint = Zero::zero();\n+        let mut f1: BigUint = One::one();\n         for _ in range(0, n) {\n             let f2 = f0 + f1;\n             f0 = util::replace(&mut f1, f2);"}, {"sha": "41e9a488bf8ae8fa74149502dbe2f35eface48b0", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -269,9 +269,13 @@ impl<T: FromStr + Clone + Integer + Ord>\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n         let split: ~[&str] = s.splitn_iter('/', 1).collect();\n-        if split.len() < 2 { return None; }\n-        do FromStr::from_str::<T>(split[0]).chain |a| {\n-            do FromStr::from_str::<T>(split[1]).chain |b| {\n+        if split.len() < 2 {\n+            return None\n+        }\n+        let a_option: Option<T> = FromStr::from_str(split[0]);\n+        do a_option.chain |a| {\n+            let b_option: Option<T> = FromStr::from_str(split[1]);\n+            do b_option.chain |b| {\n                 Some(Ratio::new(a.clone(), b.clone()))\n             }\n         }\n@@ -282,10 +286,15 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n         let split: ~[&str] = s.splitn_iter('/', 1).collect();\n-        if split.len() < 2 { None }\n-        else {\n-            do FromStrRadix::from_str_radix::<T>(split[0], radix).chain |a| {\n-                do FromStrRadix::from_str_radix::<T>(split[1], radix).chain |b| {\n+        if split.len() < 2 {\n+            None\n+        } else {\n+            let a_option: Option<T> = FromStrRadix::from_str_radix(split[0],\n+                                                                   radix);\n+            do a_option.chain |a| {\n+                let b_option: Option<T> =\n+                    FromStrRadix::from_str_radix(split[1], radix);\n+                do b_option.chain |b| {\n                     Some(Ratio::new(a.clone(), b.clone()))\n                 }\n             }\n@@ -496,7 +505,8 @@ mod test {\n     #[test]\n     fn test_from_str_fail() {\n         fn test(s: &str) {\n-            assert_eq!(FromStr::from_str::<Rational>(s), None);\n+            let rational: Option<Rational> = FromStr::from_str(s);\n+            assert_eq!(rational, None);\n         }\n \n         let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"];\n@@ -536,7 +546,8 @@ mod test {\n     #[test]\n     fn test_from_str_radix_fail() {\n         fn test(s: &str) {\n-            assert_eq!(FromStrRadix::from_str_radix::<Rational>(s, 3), None);\n+            let radix: Option<Rational> = FromStrRadix::from_str_radix(s, 3);\n+            assert_eq!(radix, None);\n         }\n \n         let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"];"}, {"sha": "b085981aabba1cb6244130d3be44d1912f436452", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -338,27 +338,36 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_empty_pop() { let mut heap = PriorityQueue::new::<int>(); heap.pop(); }\n+    fn test_empty_pop() {\n+        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n+        heap.pop();\n+    }\n \n     #[test]\n     fn test_empty_maybe_pop() {\n-        let mut heap = PriorityQueue::new::<int>();\n+        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n         assert!(heap.maybe_pop().is_none());\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_empty_top() { let empty = PriorityQueue::new::<int>(); empty.top(); }\n+    fn test_empty_top() {\n+        let empty: PriorityQueue<int> = PriorityQueue::new();\n+        empty.top();\n+    }\n \n     #[test]\n     fn test_empty_maybe_top() {\n-        let empty = PriorityQueue::new::<int>();\n+        let empty: PriorityQueue<int> = PriorityQueue::new();\n         assert!(empty.maybe_top().is_none());\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_empty_replace() { let mut heap = PriorityQueue::new(); heap.replace(5); }\n+    fn test_empty_replace() {\n+        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n+        heap.replace(5);\n+    }\n \n     #[test]\n     fn test_from_iter() {"}, {"sha": "4f2755374af02779354b9ea0a1ffd270e4a4999e", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -483,7 +483,7 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut test::BenchHarness) {\n         do b.iter {\n-            let _ = RingBuf::new::<u64>();\n+            let _: RingBuf<u64> = RingBuf::new();\n         }\n     }\n "}, {"sha": "2b6c53b3c86159987533f8a26f7586d7cb19d22b", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -368,7 +368,7 @@ pub fn write_boxplot(w: @io::Writer, s: &Summary, width_hint: uint) {\n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n-    let mut map = hashmap::HashMap::new::<U, uint>();\n+    let mut map: hashmap::HashMap<U,uint> = hashmap::HashMap::new();\n     for elem in iter {\n         map.insert_or_update_with(elem, 1, |_, count| *count += 1);\n     }"}, {"sha": "307de43a067f0e5a1cccb5d363240af83a1cb0d9", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -879,7 +879,8 @@ mod test_treemap {\n \n     #[test]\n     fn find_empty() {\n-        let m = TreeMap::new::<int, int>(); assert!(m.find(&5) == None);\n+        let m: TreeMap<int,int> = TreeMap::new();\n+        assert!(m.find(&5) == None);\n     }\n \n     #[test]\n@@ -1006,7 +1007,7 @@ mod test_treemap {\n \n     #[test]\n     fn test_rand_int() {\n-        let mut map = TreeMap::new::<int, int>();\n+        let mut map: TreeMap<int,int> = TreeMap::new();\n         let mut ctrl = ~[];\n \n         check_equal(ctrl, &map);"}, {"sha": "429a1c35b3421f7d6b786e34d93de89eff735414", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -17,6 +17,7 @@ use syntax::attr;\n use syntax::codemap::dummy_sp;\n use syntax::codemap;\n use syntax::fold;\n+use syntax::opt_vec;\n \n static STD_VERSION: &'static str = \"0.8-pre\";\n \n@@ -90,12 +91,18 @@ fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n             let prelude_path = ast::Path {\n                 span: dummy_sp(),\n                 global: false,\n-                idents: ~[\n-                    sess.ident_of(\"std\"),\n-                    sess.ident_of(\"prelude\")\n+                segments: ~[\n+                    ast::PathSegment {\n+                        identifier: sess.ident_of(\"std\"),\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    },\n+                    ast::PathSegment {\n+                        identifier: sess.ident_of(\"prelude\"),\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    },\n                 ],\n-                rp: None,\n-                types: ~[]\n             };\n \n             let vp = @spanned(ast::view_path_glob(prelude_path, n2));"}, {"sha": "a341db75393d3d1bf0ec6f08f5e098be300bd16d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -16,14 +16,15 @@ use front::config;\n \n use std::vec;\n use syntax::ast_util::*;\n+use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::{dummy_sp, span, ExpnInfo, NameAndSpan};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold;\n+use syntax::opt_vec;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n-use syntax::attr::AttrMetaMethods;\n \n type node_id_gen = @fn() -> ast::NodeId;\n \n@@ -383,19 +384,27 @@ fn nospan<T>(t: T) -> codemap::spanned<T> {\n }\n \n fn path_node(ids: ~[ast::ident]) -> ast::Path {\n-    ast::Path { span: dummy_sp(),\n-                global: false,\n-                idents: ids,\n-                rp: None,\n-                types: ~[] }\n+    ast::Path {\n+        span: dummy_sp(),\n+        global: false,\n+        segments: ids.move_iter().map(|identifier| ast::PathSegment {\n+            identifier: identifier,\n+            lifetime: None,\n+            types: opt_vec::Empty,\n+        }).collect()\n+    }\n }\n \n fn path_node_global(ids: ~[ast::ident]) -> ast::Path {\n-    ast::Path { span: dummy_sp(),\n-                 global: true,\n-                 idents: ids,\n-                 rp: None,\n-                 types: ~[] }\n+    ast::Path {\n+        span: dummy_sp(),\n+        global: true,\n+        segments: ids.move_iter().map(|identifier| ast::PathSegment {\n+            identifier: identifier,\n+            lifetime: None,\n+            types: opt_vec::Empty,\n+        }).collect()\n+    }\n }\n \n #[cfg(stage0)]"}, {"sha": "8af535865941f0a9da58577e2b2bcae6b71ee308", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -182,6 +182,12 @@ pub static tag_misc_info_crate_items: uint = 0x80;\n pub static tag_item_method_provided_source: uint = 0x81;\n pub static tag_item_impl_vtables: uint = 0x82;\n \n+pub static tag_impls: uint = 0x83;\n+pub static tag_impls_impl: uint = 0x84;\n+\n+pub static tag_items_data_item_inherent_impl: uint = 0x85;\n+pub static tag_items_data_item_extension_impl: uint = 0x86;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "3ad69ff4da03dd53d77ae160eddc2e25efd4a4c0", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -49,16 +49,34 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n     decoder::each_lang_item(crate_data, f)\n }\n \n-/// Iterates over all the paths in the given crate.\n-pub fn each_path(cstore: @mut cstore::CStore,\n-                 cnum: ast::CrateNum,\n-                 f: &fn(&str, decoder::def_like, ast::visibility) -> bool)\n-                 -> bool {\n+/// Iterates over each child of the given item.\n+pub fn each_child_of_item(cstore: @mut cstore::CStore,\n+                          def_id: ast::def_id,\n+                          callback: &fn(decoder::def_like, ast::ident)) {\n+    let crate_data = cstore::get_crate_data(cstore, def_id.crate);\n+    let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n+        cstore::get_crate_data(cstore, cnum)\n+    };\n+    decoder::each_child_of_item(cstore.intr,\n+                                crate_data,\n+                                def_id.node,\n+                                get_crate_data,\n+                                callback)\n+}\n+\n+/// Iterates over each top-level crate item.\n+pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n+                                    cnum: ast::CrateNum,\n+                                    callback: &fn(decoder::def_like,\n+                                                  ast::ident)) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n     };\n-    decoder::each_path(cstore.intr, crate_data, get_crate_data, f)\n+    decoder::each_top_level_item_of_crate(cstore.intr,\n+                                          crate_data,\n+                                          get_crate_data,\n+                                          callback)\n }\n \n pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n@@ -246,3 +264,36 @@ pub fn get_link_args_for_crate(cstore: @mut cstore::CStore,\n     let cdata = cstore::get_crate_data(cstore, crate_num);\n     decoder::get_link_args_for_crate(cdata)\n }\n+\n+pub fn each_impl(cstore: @mut cstore::CStore,\n+                 crate_num: ast::CrateNum,\n+                 callback: &fn(ast::def_id)) {\n+    let cdata = cstore::get_crate_data(cstore, crate_num);\n+    decoder::each_impl(cdata, callback)\n+}\n+\n+pub fn each_implementation_for_type(cstore: @mut cstore::CStore,\n+                                    def_id: ast::def_id,\n+                                    callback: &fn(ast::def_id)) {\n+    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    decoder::each_implementation_for_type(cdata, def_id.node, callback)\n+}\n+\n+pub fn each_implementation_for_trait(cstore: @mut cstore::CStore,\n+                                     def_id: ast::def_id,\n+                                     callback: &fn(ast::def_id)) {\n+    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    decoder::each_implementation_for_trait(cdata, def_id.node, callback)\n+}\n+\n+/// If the given def ID describes a method belonging to a trait (either a\n+/// default method or an implementation of a trait method), returns the ID of\n+/// the trait that the method belongs to. Otherwise, returns `None`.\n+pub fn get_trait_of_method(cstore: @mut cstore::CStore,\n+                           def_id: ast::def_id,\n+                           tcx: ty::ctxt)\n+                           -> Option<ast::def_id> {\n+    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    decoder::get_trait_of_method(cdata, def_id.node, tcx)\n+}\n+"}, {"sha": "336c07c9d6e9cc8eedfc64a0de69b848e14bda11", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 233, "deletions": 52, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -20,6 +20,7 @@ use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n+use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n@@ -39,7 +40,7 @@ use syntax::ast_map;\n use syntax::attr;\n use syntax::parse::token::{ident_interner, special_idents};\n use syntax::print::pprust;\n-use syntax::{ast, ast_util};\n+use syntax::ast;\n use syntax::codemap;\n use syntax::parse::token;\n \n@@ -335,15 +336,19 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::CrateNum)\n             let purity = if fam == UnsafeStaticMethod { ast::unsafe_fn } else\n                 { ast::impure_fn };\n             // def_static_method carries an optional field of its enclosing\n-            // *trait*, but not an inclosing Impl (if this is an inherent\n-            // static method). So we need to detect whether this is in\n-            // a trait or not, which we do through the mildly hacky\n-            // way of checking whether there is a trait_method_sort.\n-            let trait_did_opt = if reader::maybe_get_doc(\n+            // trait or enclosing impl (if this is an inherent static method).\n+            // So we need to detect whether this is in a trait or not, which\n+            // we do through the mildly hacky way of checking whether there is\n+            // a trait_method_sort.\n+            let provenance = if reader::maybe_get_doc(\n                   item, tag_item_trait_method_sort).is_some() {\n-                Some(item_reqd_and_translated_parent_item(cnum, item))\n-            } else { None };\n-            dl_def(ast::def_static_method(did, trait_did_opt, purity))\n+                ast::FromTrait(item_reqd_and_translated_parent_item(cnum,\n+                                                                    item))\n+            } else {\n+                ast::FromImpl(item_reqd_and_translated_parent_item(cnum,\n+                                                                   item))\n+            };\n+            dl_def(ast::def_static_method(did, provenance, purity))\n         }\n         Type | ForeignType => dl_def(ast::def_ty(did)),\n         Mod => dl_def(ast::def_mod(did)),\n@@ -698,33 +703,164 @@ impl<'self> EachItemContext<'self> {\n     }\n }\n \n-/// Iterates over all the paths in the given crate.\n-pub fn each_path(intr: @ident_interner,\n-                 cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like, ast::visibility) -> bool)\n-                 -> bool {\n-    // FIXME #4572: This function needs to be nuked, as it's impossible to\n-    // make fast. It's the source of most of the performance problems when\n-    // compiling small crates.\n+fn each_child_of_item_or_crate(intr: @ident_interner,\n+                               cdata: cmd,\n+                               item_doc: ebml::Doc,\n+                               get_crate_data: GetCrateDataCb,\n+                               callback: &fn(def_like, ast::ident)) {\n+    // Iterate over all children.\n+    let _ = do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+        let child_def_id = reader::with_doc_data(child_info_doc,\n+                                                 parse_def_id);\n+        let child_def_id = translate_def_id(cdata, child_def_id);\n+\n+        // This item may be in yet another crate if it was the child of a\n+        // reexport.\n+        let other_crates_items = if child_def_id.crate == cdata.cnum {\n+            reader::get_doc(reader::Doc(cdata.data), tag_items)\n+        } else {\n+            let crate_data = get_crate_data(child_def_id.crate);\n+            reader::get_doc(reader::Doc(crate_data.data), tag_items)\n+        };\n+\n+        // Get the item.\n+        match maybe_find_item(child_def_id.node, other_crates_items) {\n+            None => {}\n+            Some(child_item_doc) => {\n+                // Hand off the item to the callback.\n+                let child_name = item_name(intr, child_item_doc);\n+                let def_like = item_to_def_like(child_item_doc,\n+                                                child_def_id,\n+                                                cdata.cnum);\n+                callback(def_like, child_name);\n+\n+            }\n+        }\n+\n+        true\n+    };\n+\n+    // As a special case, iterate over all static methods of\n+    // associated implementations too. This is a bit of a botch.\n+    // --pcwalton\n+    let _ = do reader::tagged_docs(item_doc,\n+                                   tag_items_data_item_inherent_impl)\n+            |inherent_impl_def_id_doc| {\n+        let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n+                                               cdata);\n+        let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n+        match maybe_find_item(inherent_impl_def_id.node, items) {\n+            None => {}\n+            Some(inherent_impl_doc) => {\n+                let _ = do reader::tagged_docs(inherent_impl_doc,\n+                                               tag_item_impl_method)\n+                        |impl_method_def_id_doc| {\n+                    let impl_method_def_id =\n+                        reader::with_doc_data(impl_method_def_id_doc,\n+                                              parse_def_id);\n+                    let impl_method_def_id =\n+                        translate_def_id(cdata, impl_method_def_id);\n+                    match maybe_find_item(impl_method_def_id.node, items) {\n+                        None => {}\n+                        Some(impl_method_doc) => {\n+                            match item_family(impl_method_doc) {\n+                                StaticMethod | UnsafeStaticMethod => {\n+                                    // Hand off the static method\n+                                    // to the callback.\n+                                    let static_method_name =\n+                                        item_name(intr, impl_method_doc);\n+                                    let static_method_def_like =\n+                                        item_to_def_like(impl_method_doc,\n+                                                         impl_method_def_id,\n+                                                         cdata.cnum);\n+                                    callback(static_method_def_like,\n+                                             static_method_name);\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+\n+                    true\n+                };\n+            }\n+        }\n+\n+        true\n+    };\n+\n+    // Iterate over all reexports.\n+    let _ = do each_reexport(item_doc) |reexport_doc| {\n+        let def_id_doc = reader::get_doc(reexport_doc,\n+                                         tag_items_data_item_reexport_def_id);\n+        let child_def_id = reader::with_doc_data(def_id_doc,\n+                                                 parse_def_id);\n+        let child_def_id = translate_def_id(cdata, child_def_id);\n+\n+        let name_doc = reader::get_doc(reexport_doc,\n+                                       tag_items_data_item_reexport_name);\n+        let name = name_doc.as_str_slice();\n+\n+        // This reexport may be in yet another crate.\n+        let other_crates_items = if child_def_id.crate == cdata.cnum {\n+            reader::get_doc(reader::Doc(cdata.data), tag_items)\n+        } else {\n+            let crate_data = get_crate_data(child_def_id.crate);\n+            reader::get_doc(reader::Doc(crate_data.data), tag_items)\n+        };\n+\n+        // Get the item.\n+        match maybe_find_item(child_def_id.node, other_crates_items) {\n+            None => {}\n+            Some(child_item_doc) => {\n+                // Hand off the item to the callback.\n+                let def_like = item_to_def_like(child_item_doc,\n+                                                child_def_id,\n+                                                cdata.cnum);\n+                callback(def_like, token::str_to_ident(name));\n+            }\n+        }\n+\n+        true\n+    };\n+}\n+\n+/// Iterates over each child of the given item.\n+pub fn each_child_of_item(intr: @ident_interner,\n+                          cdata: cmd,\n+                          id: ast::NodeId,\n+                          get_crate_data: GetCrateDataCb,\n+                          callback: &fn(def_like, ast::ident)) {\n+    // Find the item.\n+    let root_doc = reader::Doc(cdata.data);\n+    let items = reader::get_doc(root_doc, tag_items);\n+    let item_doc = match maybe_find_item(id, items) {\n+        None => return,\n+        Some(item_doc) => item_doc,\n+    };\n \n+    each_child_of_item_or_crate(intr,\n+                                cdata,\n+                                item_doc,\n+                                get_crate_data,\n+                                callback)\n+}\n+\n+/// Iterates over all the top-level crate items.\n+pub fn each_top_level_item_of_crate(intr: @ident_interner,\n+                                    cdata: cmd,\n+                                    get_crate_data: GetCrateDataCb,\n+                                    callback: &fn(def_like, ast::ident)) {\n     let root_doc = reader::Doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n \n-    let mut path_builder = ~\"\";\n-\n-    let mut context = EachItemContext {\n-        intr: intr,\n-        cdata: cdata,\n-        get_crate_data: get_crate_data,\n-        path_builder: &mut path_builder,\n-        callback: f,\n-    };\n-\n-    // Iterate over all top-level crate items.\n-    context.each_child_of_module_or_crate(crate_items_doc)\n+    each_child_of_item_or_crate(intr,\n+                                cdata,\n+                                crate_items_doc,\n+                                get_crate_data,\n+                                callback)\n }\n \n pub fn get_item_path(cdata: cmd, id: ast::NodeId) -> ast_map::path {\n@@ -804,12 +940,9 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n         match ch as char {\n-            'i' => { ast::m_imm }\n-            'm' => { ast::m_mutbl }\n-            'c' => { ast::m_const }\n-            _ => {\n-                fail!(\"unknown mutability character: `%c`\", ch as char)\n-            }\n+            'i' => ast::m_imm,\n+            'm' => ast::m_mutbl,\n+            _ => fail!(\"unknown mutability character: `%c`\", ch as char),\n         }\n     }\n \n@@ -876,8 +1009,15 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n {\n     let method_doc = lookup_item(id, cdata.data);\n     let def_id = item_def_id(method_doc, cdata);\n+\n     let container_id = item_reqd_and_translated_parent_item(cdata.cnum,\n                                                             method_doc);\n+    let container_doc = lookup_item(container_id.node, cdata.data);\n+    let container = match item_family(container_doc) {\n+        Trait => TraitContainer(container_id),\n+        _ => ImplContainer(container_id),\n+    };\n+\n     let name = item_name(intr, method_doc);\n     let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n                                              tag_item_method_tps);\n@@ -898,7 +1038,7 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n         explicit_self,\n         vis,\n         def_id,\n-        container_id,\n+        container,\n         provided_source\n     )\n }\n@@ -1267,21 +1407,6 @@ pub fn get_crate_vers(data: @~[u8]) -> @str {\n     }\n }\n \n-fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n-                    get_crate_data: GetCrateDataCb,\n-                    proc: &fn(path: &str, ast::def_id)) {\n-    do each_path(intr, cdata, get_crate_data) |path_string, def_like, _| {\n-        match def_like {\n-            dl_impl(*) | dl_field => {}\n-            dl_def(def) => {\n-                proc(path_string,\n-                     ast_util::def_id_of_def(def))\n-            }\n-        }\n-        true\n-    };\n-}\n-\n pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                            out: @io::Writer) {\n     let hash = get_crate_hash(bytes);\n@@ -1315,3 +1440,59 @@ pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n     };\n     result\n }\n+\n+pub fn each_impl(cdata: cmd, callback: &fn(ast::def_id)) {\n+    let impls_doc = reader::get_doc(reader::Doc(cdata.data), tag_impls);\n+    let _ = do reader::tagged_docs(impls_doc, tag_impls_impl) |impl_doc| {\n+        callback(item_def_id(impl_doc, cdata));\n+        true\n+    };\n+}\n+\n+pub fn each_implementation_for_type(cdata: cmd,\n+                                    id: ast::NodeId,\n+                                    callback: &fn(ast::def_id)) {\n+    let item_doc = lookup_item(id, cdata.data);\n+    do reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl)\n+            |impl_doc| {\n+        let implementation_def_id = item_def_id(impl_doc, cdata);\n+        callback(implementation_def_id);\n+        true\n+    };\n+}\n+\n+pub fn each_implementation_for_trait(cdata: cmd,\n+                                     id: ast::NodeId,\n+                                     callback: &fn(ast::def_id)) {\n+    let item_doc = lookup_item(id, cdata.data);\n+\n+    let _ = do reader::tagged_docs(item_doc,\n+                                   tag_items_data_item_extension_impl)\n+            |impl_doc| {\n+        let implementation_def_id = item_def_id(impl_doc, cdata);\n+        callback(implementation_def_id);\n+        true\n+    };\n+}\n+\n+pub fn get_trait_of_method(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n+                           -> Option<ast::def_id> {\n+    let item_doc = lookup_item(id, cdata.data);\n+    let parent_item_id = match item_parent_item(item_doc) {\n+        None => return None,\n+        Some(item_id) => item_id,\n+    };\n+    let parent_item_id = translate_def_id(cdata, parent_item_id);\n+    let parent_item_doc = lookup_item(parent_item_id.node, cdata.data);\n+    match item_family(parent_item_doc) {\n+        Trait => Some(item_def_id(parent_item_doc, cdata)),\n+        Impl => {\n+            do reader::maybe_get_doc(parent_item_doc, tag_item_trait_ref).map\n+                    |_| {\n+                item_trait_ref(parent_item_doc, tcx, cdata).def_id\n+            }\n+        }\n+        _ => None\n+    }\n+}\n+"}, {"sha": "790dff2886fa09f7e488f327efa93df1451e3548", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 123, "deletions": 13, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -39,6 +39,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::span_handler;\n use syntax::parse::token::special_idents;\n use syntax::ast_util;\n+use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::parse::token;\n use syntax;\n@@ -72,6 +73,7 @@ struct Stats {\n     dep_bytes: uint,\n     lang_item_bytes: uint,\n     link_args_bytes: uint,\n+    impl_bytes: uint,\n     misc_bytes: uint,\n     item_bytes: uint,\n     index_bytes: uint,\n@@ -511,8 +513,12 @@ fn encode_reexports(ecx: &EncodeContext,\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n             for exp in exports.iter() {\n-                debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       exp.name, id);\n+                debug!(\"(encoding info for module) reexport '%s' (%d/%d) for \\\n+                        %d\",\n+                       exp.name,\n+                       exp.def_id.crate,\n+                       exp.def_id.node,\n+                       id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n                 ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n                 ebml_w.wr_str(def_to_str(exp.def_id));\n@@ -635,15 +641,8 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explic\n     fn encode_mutability(ebml_w: &writer::Encoder,\n                          m: ast::mutability) {\n         match m {\n-            m_imm => {\n-                ebml_w.writer.write(&[ 'i' as u8 ]);\n-            }\n-            m_mutbl => {\n-                ebml_w.writer.write(&[ 'm' as u8 ]);\n-            }\n-            m_const => {\n-                ebml_w.writer.write(&[ 'c' as u8 ]);\n-            }\n+            m_imm => ebml_w.writer.write(&[ 'i' as u8 ]),\n+            m_mutbl => ebml_w.writer.write(&[ 'm' as u8 ]),\n         }\n     }\n }\n@@ -804,6 +803,38 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n     }\n }\n \n+// Encodes the inherent implementations of a structure, enumeration, or trait.\n+fn encode_inherent_implementations(ecx: &EncodeContext,\n+                                   ebml_w: &mut writer::Encoder,\n+                                   def_id: def_id) {\n+    match ecx.tcx.inherent_impls.find(&def_id) {\n+        None => {}\n+        Some(&implementations) => {\n+            for implementation in implementations.iter() {\n+                ebml_w.start_tag(tag_items_data_item_inherent_impl);\n+                encode_def_id(ebml_w, implementation.did);\n+                ebml_w.end_tag();\n+            }\n+        }\n+    }\n+}\n+\n+// Encodes the implementations of a trait defined in this crate.\n+fn encode_extension_implementations(ecx: &EncodeContext,\n+                                    ebml_w: &mut writer::Encoder,\n+                                    trait_def_id: def_id) {\n+    match ecx.tcx.trait_impls.find(&trait_def_id) {\n+        None => {}\n+        Some(&implementations) => {\n+            for implementation in implementations.iter() {\n+                ebml_w.start_tag(tag_items_data_item_extension_impl);\n+                encode_def_id(ebml_w, implementation.did);\n+                ebml_w.end_tag();\n+            }\n+        }\n+    }\n+}\n+\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n@@ -907,6 +938,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n+\n+        // Encode inherent implementations for this enumeration.\n+        encode_inherent_implementations(ecx, ebml_w, def_id);\n+\n         ebml_w.end_tag();\n \n         encode_enum_variant_info(ecx,\n@@ -959,6 +994,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n         }\n \n+        // Encode inherent implementations for this structure.\n+        encode_inherent_implementations(ecx, ebml_w, def_id);\n+\n         /* Each class has its own index -- encode it */\n         let bkts = create_index(idx);\n         encode_index(ebml_w, bkts, write_i64);\n@@ -995,7 +1033,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n-            ast::ty_path(ref path, ref bounds, _) if path.idents.len() == 1 => {\n+            ast::ty_path(ref path, ref bounds, _) if path.segments\n+                                                         .len() == 1 => {\n                 assert!(bounds.is_none());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));\n@@ -1073,6 +1112,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n         }\n+\n+        // Encode the implementations of this trait.\n+        encode_extension_implementations(ecx, ebml_w, def_id);\n+\n         ebml_w.end_tag();\n \n         // Now output the method info for each method.\n@@ -1134,6 +1177,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             ebml_w.end_tag();\n         }\n+\n+        // Encode inherent implementations for this trait.\n+        encode_inherent_implementations(ecx, ebml_w, def_id);\n       }\n       item_mac(*) => fail!(\"item macros unimplemented\")\n     }\n@@ -1227,7 +1273,10 @@ struct EncodeVisitor {\n }\n \n impl visit::Visitor<()> for EncodeVisitor {\n-    fn visit_expr(&mut self, ex:@expr, _:()) { my_visit_expr(ex); }\n+    fn visit_expr(&mut self, ex:@expr, _:()) {\n+        visit::walk_expr(self, ex, ());\n+        my_visit_expr(ex);\n+    }\n     fn visit_item(&mut self, i:@item, _:()) {\n         visit::walk_item(self, i, ());\n         my_visit_item(i,\n@@ -1516,6 +1565,60 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n+struct ImplVisitor<'self> {\n+    ecx: &'self EncodeContext<'self>,\n+    ebml_w: &'self mut writer::Encoder,\n+}\n+\n+impl<'self> Visitor<()> for ImplVisitor<'self> {\n+    fn visit_item(&mut self, item: @item, _: ()) {\n+        match item.node {\n+            item_impl(_, Some(ref trait_ref), _, _) => {\n+                let def_map = self.ecx.tcx.def_map;\n+                let trait_def = def_map.get_copy(&trait_ref.ref_id);\n+                let def_id = ast_util::def_id_of_def(trait_def);\n+\n+                // Load eagerly if this is an implementation of the Drop trait\n+                // or if the trait is not defined in this crate.\n+                if def_id == self.ecx.tcx.lang_items.drop_trait().unwrap() ||\n+                        def_id.crate != LOCAL_CRATE {\n+                    self.ebml_w.start_tag(tag_impls_impl);\n+                    encode_def_id(self.ebml_w, local_def(item.id));\n+                    self.ebml_w.end_tag();\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_item(self, item, ());\n+    }\n+}\n+\n+/// Encodes implementations that are eagerly loaded.\n+///\n+/// None of this is necessary in theory; we can load all implementations\n+/// lazily. However, in two cases the optimizations to lazily load\n+/// implementations are not yet implemented. These two cases, which require us\n+/// to load implementations eagerly, are:\n+///\n+/// * Destructors (implementations of the Drop trait).\n+///\n+/// * Implementations of traits not defined in this crate.\n+fn encode_impls(ecx: &EncodeContext,\n+                crate: &Crate,\n+                ebml_w: &mut writer::Encoder) {\n+    ebml_w.start_tag(tag_impls);\n+\n+    {\n+        let mut visitor = ImplVisitor {\n+            ecx: ecx,\n+            ebml_w: ebml_w,\n+        };\n+        visit::walk_crate(&mut visitor, crate, ());\n+    }\n+\n+    ebml_w.end_tag();\n+}\n+\n fn encode_misc_info(ecx: &EncodeContext,\n                     crate: &Crate,\n                     ebml_w: &mut writer::Encoder) {\n@@ -1580,6 +1683,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         dep_bytes: 0,\n         lang_item_bytes: 0,\n         link_args_bytes: 0,\n+        impl_bytes: 0,\n         misc_bytes: 0,\n         item_bytes: 0,\n         index_bytes: 0,\n@@ -1638,6 +1742,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     encode_link_args(&ecx, &mut ebml_w);\n     ecx.stats.link_args_bytes = *wr.pos - i;\n \n+    // Encode the def IDs of impls, for coherence checking.\n+    i = *wr.pos;\n+    encode_impls(&ecx, crate, &mut ebml_w);\n+    ecx.stats.impl_bytes = *wr.pos - i;\n+\n     // Encode miscellaneous info.\n     i = *wr.pos;\n     encode_misc_info(&ecx, crate, &mut ebml_w);\n@@ -1670,6 +1779,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         printfln!(\"       dep bytes: %u\", ecx.stats.dep_bytes);\n         printfln!(\" lang item bytes: %u\", ecx.stats.lang_item_bytes);\n         printfln!(\" link args bytes: %u\", ecx.stats.link_args_bytes);\n+        printfln!(\"      impl bytes: %u\", ecx.stats.impl_bytes);\n         printfln!(\"      misc bytes: %u\", ecx.stats.misc_bytes);\n         printfln!(\"      item bytes: %u\", ecx.stats.item_bytes);\n         printfln!(\"     index bytes: %u\", ecx.stats.index_bytes);"}, {"sha": "f5bad88b1ca66eb3a7df4927c3b25247ca7f1e31", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -138,12 +138,20 @@ fn parse_path(st: &mut PState) -> @ast::Path {\n           ':' => { next(st); next(st); }\n           c => {\n             if c == '(' {\n-                return @ast::Path { span: dummy_sp(),\n-                                    global: false,\n-                                    idents: idents,\n-                                    rp: None,\n-                                    types: ~[] };\n-            } else { idents.push(parse_ident_(st, is_last)); }\n+                return @ast::Path {\n+                    span: dummy_sp(),\n+                    global: false,\n+                    segments: idents.move_iter().map(|identifier| {\n+                        ast::PathSegment {\n+                            identifier: identifier,\n+                            lifetime: None,\n+                            types: opt_vec::Empty,\n+                        }\n+                    }).collect()\n+                };\n+            } else {\n+                idents.push(parse_ident_(st, is_last));\n+            }\n           }\n         }\n     };\n@@ -417,7 +425,6 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n fn parse_mutability(st: &mut PState) -> ast::mutability {\n     match peek(st) {\n       'm' => { next(st); ast::m_mutbl }\n-      '?' => { next(st); ast::m_const }\n       _ => { ast::m_imm }\n     }\n }"}, {"sha": "d00928dd3db74232da80f73a8df73150f12d41ab", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -99,7 +99,6 @@ fn enc_mutability(w: @io::Writer, mt: ast::mutability) {\n     match mt {\n       m_imm => (),\n       m_mutbl => w.write_char('m'),\n-      m_const => w.write_char('?')\n     }\n }\n "}, {"sha": "d6b22381192d26c676aabf5a61149cf8ada94fd8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -374,9 +374,16 @@ impl tr for ast::def {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::def {\n         match *self {\n           ast::def_fn(did, p) => ast::def_fn(did.tr(xcx), p),\n-          ast::def_static_method(did, did2_opt, p) => {\n+          ast::def_static_method(did, wrapped_did2, p) => {\n             ast::def_static_method(did.tr(xcx),\n-                                   did2_opt.map(|did2| did2.tr(xcx)),\n+                                   match wrapped_did2 {\n+                                    ast::FromTrait(did2) => {\n+                                        ast::FromTrait(did2.tr(xcx))\n+                                    }\n+                                    ast::FromImpl(did2) => {\n+                                        ast::FromImpl(did2.tr(xcx))\n+                                    }\n+                                   },\n                                    p)\n           }\n           ast::def_method(did0, did1) => {"}, {"sha": "485a0aefe98294e5128dfc07406b59616da33617", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -23,12 +23,12 @@ use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n-use syntax::ast::{m_mutbl, m_imm, m_const};\n+use syntax::ast::{m_imm, m_mutbl};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;\n-use syntax::visit;\n use syntax::visit::Visitor;\n+use syntax::visit;\n use util::ppaux::Repr;\n \n #[deriving(Clone)]\n@@ -86,6 +86,44 @@ enum MoveError {\n }\n \n impl<'self> CheckLoanCtxt<'self> {\n+    fn check_by_move_capture(&self,\n+                             closure_id: ast::NodeId,\n+                             cap_var: &moves::CaptureVar,\n+                             move_path: @LoanPath) {\n+        let move_err = self.analyze_move_out_from(closure_id, move_path);\n+        match move_err {\n+            MoveOk => {}\n+            MoveWhileBorrowed(loan_path, loan_span) => {\n+                self.bccx.span_err(\n+                    cap_var.span,\n+                    fmt!(\"cannot move `%s` into closure \\\n+                          because it is borrowed\",\n+                         self.bccx.loan_path_to_str(move_path)));\n+                self.bccx.span_note(\n+                    loan_span,\n+                    fmt!(\"borrow of `%s` occurs here\",\n+                         self.bccx.loan_path_to_str(loan_path)));\n+            }\n+        }\n+    }\n+\n+    fn check_captured_variables(&self, closure_id: ast::NodeId, span: span) {\n+        let cap_vars = self.bccx.capture_map.get(&closure_id);\n+        for cap_var in cap_vars.iter() {\n+            let var_id = ast_util::def_id_of_def(cap_var.def).node;\n+            let var_path = @LpVar(var_id);\n+            self.check_if_path_is_moved(closure_id, span,\n+                                        MovedInCapture, var_path);\n+            match cap_var.mode {\n+                moves::CapRef | moves::CapCopy => {}\n+                moves::CapMove => {\n+                    self.check_by_move_capture(closure_id, cap_var, var_path);\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n     pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n     pub fn each_issued_loan(&self,\n@@ -220,9 +258,9 @@ impl<'self> CheckLoanCtxt<'self> {\n \n         // Restrictions that would cause the new loan to be illegal:\n         let illegal_if = match loan2.mutbl {\n-            m_mutbl => RESTR_ALIAS | RESTR_FREEZE | RESTR_CLAIM,\n-            m_imm =>   RESTR_ALIAS | RESTR_FREEZE,\n-            m_const => RESTR_ALIAS,\n+            MutableMutability   => RESTR_ALIAS | RESTR_FREEZE | RESTR_CLAIM,\n+            ImmutableMutability => RESTR_ALIAS | RESTR_FREEZE,\n+            ConstMutability     => RESTR_ALIAS,\n         };\n         debug!(\"illegal_if=%?\", illegal_if);\n \n@@ -231,7 +269,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             if restr.loan_path != loan2.loan_path { loop; }\n \n             match (new_loan.mutbl, old_loan.mutbl) {\n-                (m_mutbl, m_mutbl) => {\n+                (MutableMutability, MutableMutability) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         fmt!(\"cannot borrow `%s` as mutable \\\n@@ -450,7 +488,6 @@ impl<'self> CheckLoanCtxt<'self> {\n                     mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n                     mc::cat_static_item(*) |\n                     mc::cat_deref(_, _, mc::gc_ptr(_)) |\n-                    mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n                     mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) => {\n                         // Aliasability is independent of base cmt\n                         match cmt.freely_aliasable() {\n@@ -582,16 +619,18 @@ impl<'self> CheckLoanCtxt<'self> {\n                     // Otherwise stop iterating\n                     LpExtend(_, mc::McDeclared, _) |\n                     LpExtend(_, mc::McImmutable, _) |\n-                    LpExtend(_, mc::McReadOnly, _) |\n                     LpVar(_) => {\n                         return true;\n                     }\n                 }\n \n                 // Check for a non-const loan of `loan_path`\n                 let cont = do this.each_in_scope_loan(expr.id) |loan| {\n-                    if loan.loan_path == loan_path && loan.mutbl != m_const {\n-                        this.report_illegal_mutation(expr, full_loan_path, loan);\n+                    if loan.loan_path == loan_path &&\n+                            loan.mutbl != ConstMutability {\n+                        this.report_illegal_mutation(expr,\n+                                                     full_loan_path,\n+                                                     loan);\n                         false\n                     } else {\n                         true\n@@ -825,3 +864,4 @@ fn check_loans_in_block<'a>(vt: &mut CheckLoanVisitor,\n     visit::walk_block(vt, blk, this);\n     this.check_for_conflicting_loans(blk.id);\n }\n+"}, {"sha": "e76d11c269b2b21461c489aae232ca14135a8b77", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -15,7 +15,7 @@\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::ast::{m_imm, m_mutbl};\n use syntax::ast;\n use syntax::codemap::span;\n use util::ppaux::{note_and_explain_region};\n@@ -26,7 +26,7 @@ pub fn guarantee_lifetime(bccx: @BorrowckCtxt,\n                           span: span,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n-                          loan_mutbl: ast::mutability) {\n+                          loan_mutbl: LoanMutability) {\n     debug!(\"guarantee_lifetime(cmt=%s, loan_region=%s)\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n@@ -54,7 +54,7 @@ struct GuaranteeLifetimeContext {\n \n     span: span,\n     loan_region: ty::Region,\n-    loan_mutbl: ast::mutability,\n+    loan_mutbl: LoanMutability,\n     cmt_original: mc::cmt\n }\n \n@@ -235,11 +235,11 @@ impl GuaranteeLifetimeContext {\n         // we need to dynamically mark it to prevent incompatible\n         // borrows from happening later.\n         let opt_dyna = match ptr_mutbl {\n-            m_imm | m_const => None,\n+            m_imm => None,\n             m_mutbl => {\n                 match self.loan_mutbl {\n-                    m_mutbl => Some(DynaMut),\n-                    m_imm | m_const => Some(DynaImm)\n+                    MutableMutability => Some(DynaMut),\n+                    ImmutableMutability | ConstMutability => Some(DynaImm)\n                 }\n             }\n         };"}, {"sha": "dbe5214e0eb50013cfc0873f239a4ccaabc18345", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 51, "deletions": 35, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -26,7 +26,6 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n-use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n use syntax::ast_util::id_range;\n use syntax::codemap::span;\n@@ -237,7 +236,11 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n         // make sure that the thing we are pointing out stays valid\n         // for the lifetime `scope_r` of the resulting ptr:\n         let scope_r = ty_region(tcx, ex.span, ty::expr_ty(tcx, ex));\n-        this.guarantee_valid(ex.id, ex.span, base_cmt, mutbl, scope_r);\n+        this.guarantee_valid(ex.id,\n+                             ex.span,\n+                             base_cmt,\n+                             LoanMutability::from_ast_mutability(mutbl),\n+                             scope_r);\n         visit::walk_expr(v, ex, this);\n       }\n \n@@ -278,7 +281,11 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n           // adjustments).\n           let scope_r = ty::re_scope(ex.id);\n           let arg_cmt = this.bccx.cat_expr(arg);\n-          this.guarantee_valid(arg.id, arg.span, arg_cmt, m_imm, scope_r);\n+          this.guarantee_valid(arg.id,\n+                               arg.span,\n+                               arg_cmt,\n+                               ImmutableMutability,\n+                               scope_r);\n           visit::walk_expr(v, ex, this);\n       }\n \n@@ -357,34 +364,40 @@ impl GatherLoanCtxt {\n \n                 match *autoref {\n                     ty::AutoPtr(r, m) => {\n+                        let loan_mutability =\n+                            LoanMutability::from_ast_mutability(m);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt,\n-                                             m,\n+                                             loan_mutability,\n                                              r)\n                     }\n                     ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n                         let cmt_index = mcx.cat_index(expr, cmt, autoderefs+1);\n+                        let loan_mutability =\n+                            LoanMutability::from_ast_mutability(m);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_index,\n-                                             m,\n+                                             loan_mutability,\n                                              r)\n                     }\n                     ty::AutoBorrowFn(r) => {\n                         let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,\n-                                             m_imm,\n+                                             ImmutableMutability,\n                                              r)\n                     }\n                     ty::AutoBorrowObj(r, m) => {\n                         let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n+                        let loan_mutability =\n+                            LoanMutability::from_ast_mutability(m);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,\n-                                             m,\n+                                             loan_mutability,\n                                              r)\n                     }\n                     ty::AutoUnsafe(_) => {}\n@@ -402,7 +415,7 @@ impl GatherLoanCtxt {\n                            borrow_id: ast::NodeId,\n                            borrow_span: span,\n                            cmt: mc::cmt,\n-                           req_mutbl: ast::mutability,\n+                           req_mutbl: LoanMutability,\n                            loan_region: ty::Region) {\n         debug!(\"guarantee_valid(borrow_id=%?, cmt=%s, \\\n                 req_mutbl=%?, loan_region=%?)\",\n@@ -473,7 +486,7 @@ impl GatherLoanCtxt {\n                 let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n                 debug!(\"kill_scope = %?\", kill_scope);\n \n-                if req_mutbl == m_mutbl {\n+                if req_mutbl == MutableMutability {\n                     self.mark_loan_path_as_mutated(loan_path);\n                 }\n \n@@ -516,7 +529,7 @@ impl GatherLoanCtxt {\n             //        index: all_loans.len(),\n             //        loan_path: loan_path,\n             //        cmt: cmt,\n-            //        mutbl: m_const,\n+            //        mutbl: ConstMutability,\n             //        gen_scope: borrow_id,\n             //        kill_scope: kill_scope,\n             //        span: borrow_span,\n@@ -527,29 +540,20 @@ impl GatherLoanCtxt {\n         fn check_mutability(bccx: @BorrowckCtxt,\n                             borrow_span: span,\n                             cmt: mc::cmt,\n-                            req_mutbl: ast::mutability) {\n+                            req_mutbl: LoanMutability) {\n             //! Implements the M-* rules in doc.rs.\n \n             match req_mutbl {\n-                m_const => {\n+                ConstMutability => {\n                     // Data of any mutability can be lent as const.\n                 }\n \n-                m_imm => {\n-                    match cmt.mutbl {\n-                        mc::McImmutable | mc::McDeclared | mc::McInherited => {\n-                            // both imm and mut data can be lent as imm;\n-                            // for mutable data, this is a freeze\n-                        }\n-                        mc::McReadOnly => {\n-                            bccx.report(BckError {span: borrow_span,\n-                                                  cmt: cmt,\n-                                                  code: err_mutbl(req_mutbl)});\n-                        }\n-                    }\n+                ImmutableMutability => {\n+                    // both imm and mut data can be lent as imm;\n+                    // for mutable data, this is a freeze\n                 }\n \n-                m_mutbl => {\n+                MutableMutability => {\n                     // Only mutable data can be lent as mutable.\n                     if !cmt.mutbl.is_mutable() {\n                         bccx.report(BckError {span: borrow_span,\n@@ -561,12 +565,14 @@ impl GatherLoanCtxt {\n         }\n     }\n \n-    pub fn restriction_set(&self, req_mutbl: ast::mutability)\n+    pub fn restriction_set(&self, req_mutbl: LoanMutability)\n                            -> RestrictionSet {\n         match req_mutbl {\n-            m_const => RESTR_EMPTY,\n-            m_imm   => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n-            m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n+            ConstMutability => RESTR_EMPTY,\n+            ImmutableMutability => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n+            MutableMutability => {\n+                RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n+            }\n         }\n     }\n \n@@ -582,8 +588,8 @@ impl GatherLoanCtxt {\n                 self.mark_loan_path_as_mutated(base);\n             }\n             LpExtend(_, mc::McDeclared, _) |\n-            LpExtend(_, mc::McImmutable, _) |\n-            LpExtend(_, mc::McReadOnly, _) => {\n+            LpExtend(_, mc::McImmutable, _) => {\n+                // Nothing to do.\n             }\n         }\n     }\n@@ -701,8 +707,13 @@ impl GatherLoanCtxt {\n                             }\n                         }\n                     };\n-                    self.guarantee_valid(pat.id, pat.span,\n-                                         cmt_discr, mutbl, scope_r);\n+                    let loan_mutability =\n+                        LoanMutability::from_ast_mutability(mutbl);\n+                    self.guarantee_valid(pat.id,\n+                                         pat.span,\n+                                         cmt_discr,\n+                                         loan_mutability,\n+                                         scope_r);\n                   }\n                   ast::bind_infer => {\n                       // No borrows here, but there may be moves\n@@ -725,6 +736,8 @@ impl GatherLoanCtxt {\n                       self.vec_slice_info(slice_pat, slice_ty);\n                   let mcx = self.bccx.mc_ctxt();\n                   let cmt_index = mcx.cat_index(slice_pat, cmt, 0);\n+                  let slice_loan_mutability =\n+                    LoanMutability::from_ast_mutability(slice_mutbl);\n \n                   // Note: We declare here that the borrow occurs upon\n                   // entering the `[...]` pattern. This implies that\n@@ -743,8 +756,11 @@ impl GatherLoanCtxt {\n                   // trans do the right thing, and it would only work\n                   // for `~` vectors. It seems simpler to just require\n                   // that people call `vec.pop()` or `vec.unshift()`.\n-                  self.guarantee_valid(pat.id, pat.span,\n-                                       cmt_index, slice_mutbl, slice_r);\n+                  self.guarantee_valid(pat.id,\n+                                       pat.span,\n+                                       cmt_index,\n+                                       slice_loan_mutability,\n+                                       slice_r);\n               }\n \n               _ => {}"}, {"sha": "26c2cff189c46b00923a7ff94d666170926768eb", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -15,7 +15,7 @@ use std::vec;\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::ast::{m_imm, m_mutbl};\n use syntax::codemap::span;\n \n pub enum RestrictionResult {\n@@ -121,13 +121,6 @@ impl RestrictionsContext {\n                 Safe\n             }\n \n-            mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n-            mc::cat_deref(_, _, mc::gc_ptr(m_const)) => {\n-                // R-Deref-Freeze-Borrowed\n-                self.check_no_mutability_control(cmt, restrictions);\n-                Safe\n-            }\n-\n             mc::cat_deref(cmt_base, _, pk @ mc::gc_ptr(m_mutbl)) => {\n                 // R-Deref-Managed-Borrowed\n                 //"}, {"sha": "7113af3fbc2464a8f55c7f6526aea344fbfa3000", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -241,12 +241,39 @@ pub enum PartialTotal {\n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n \n+#[deriving(Clone, Eq)]\n+pub enum LoanMutability {\n+    ImmutableMutability,\n+    ConstMutability,\n+    MutableMutability,\n+}\n+\n+impl LoanMutability {\n+    pub fn from_ast_mutability(ast_mutability: ast::mutability)\n+                               -> LoanMutability {\n+        match ast_mutability {\n+            ast::m_imm => ImmutableMutability,\n+            ast::m_mutbl => MutableMutability,\n+        }\n+    }\n+}\n+\n+impl ToStr for LoanMutability {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ImmutableMutability => ~\"immutable\",\n+            ConstMutability => ~\"read-only\",\n+            MutableMutability => ~\"mutable\",\n+        }\n+    }\n+}\n+\n /// Record of a loan that was issued.\n pub struct Loan {\n     index: uint,\n     loan_path: @LoanPath,\n     cmt: mc::cmt,\n-    mutbl: ast::mutability,\n+    mutbl: LoanMutability,\n     restrictions: ~[Restriction],\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n@@ -417,7 +444,7 @@ impl ToStr for DynaFreezeKind {\n // Errors that can occur\n #[deriving(Eq)]\n pub enum bckerr_code {\n-    err_mutbl(ast::mutability),\n+    err_mutbl(LoanMutability),\n     err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n     err_freeze_aliasable_const\n@@ -794,17 +821,14 @@ impl BorrowckCtxt {\n         mc.cmt_to_str(cmt)\n     }\n \n-    pub fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n-        let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n-                                               method_map: self.method_map};\n-        mc.mut_to_str(mutbl)\n+    pub fn mut_to_str(&self, mutbl: LoanMutability) -> ~str {\n+        mutbl.to_str()\n     }\n \n     pub fn mut_to_keyword(&self, mutbl: ast::mutability) -> &'static str {\n         match mutbl {\n             ast::m_imm => \"\",\n-            ast::m_const => \"const\",\n-            ast::m_mutbl => \"mut\"\n+            ast::m_mutbl => \"mut\",\n         }\n     }\n }"}, {"sha": "fc779f73060a0c80e9a8123a08bbfd4ad891932d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -141,7 +141,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n-            if pth.types.len() != 0 {\n+            if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n                 sess.span_err(\n                     e.span, \"paths in constants may only refer to \\\n                              items without type parameters\");"}, {"sha": "3f1e409e170cde03b53c3f31a1cae27bccb341d3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -52,7 +52,7 @@ use middle::typeck;\n use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n use util::common::indenter;\n \n-use syntax::ast::{m_imm, m_const, m_mutbl};\n+use syntax::ast::{m_imm, m_mutbl};\n use syntax::ast;\n use syntax::codemap::span;\n use syntax::print::pprust;\n@@ -113,7 +113,6 @@ pub enum ElementKind {\n #[deriving(Eq, IterBytes)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n-    McReadOnly,  // Read-only (`const`)\n     McDeclared,  // Directly declared as mutable.\n     McInherited  // Inherited from the fact that owner is mutable.\n }\n@@ -297,39 +296,36 @@ impl MutabilityCategory {\n     pub fn from_mutbl(m: ast::mutability) -> MutabilityCategory {\n         match m {\n             m_imm => McImmutable,\n-            m_const => McReadOnly,\n             m_mutbl => McDeclared\n         }\n     }\n \n     pub fn inherit(&self) -> MutabilityCategory {\n         match *self {\n             McImmutable => McImmutable,\n-            McReadOnly => McReadOnly,\n             McDeclared => McInherited,\n             McInherited => McInherited\n         }\n     }\n \n     pub fn is_mutable(&self) -> bool {\n         match *self {\n-            McImmutable | McReadOnly => false,\n+            McImmutable => false,\n             McDeclared | McInherited => true\n         }\n     }\n \n     pub fn is_immutable(&self) -> bool {\n         match *self {\n             McImmutable => true,\n-            McReadOnly | McDeclared | McInherited => false\n+            McDeclared | McInherited => false\n         }\n     }\n \n     pub fn to_user_str(&self) -> &'static str {\n         match *self {\n             McDeclared | McInherited => \"mutable\",\n             McImmutable => \"immutable\",\n-            McReadOnly => \"const\"\n         }\n     }\n }\n@@ -610,7 +606,6 @@ impl mem_categorization_ctxt {\n                                 -> MutabilityCategory {\n         match interior_m {\n             m_imm => base_m.inherit(),\n-            m_const => McReadOnly,\n             m_mutbl => McDeclared\n         }\n     }\n@@ -999,7 +994,6 @@ impl mem_categorization_ctxt {\n     pub fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n         match mutbl {\n           m_mutbl => ~\"mutable\",\n-          m_const => ~\"const\",\n           m_imm => ~\"immutable\"\n         }\n     }\n@@ -1164,7 +1158,6 @@ impl cmt_ {\n                 Some(AliasableManaged(m))\n             }\n \n-            cat_deref(_, _, region_ptr(m @ m_const, _)) |\n             cat_deref(_, _, region_ptr(m @ m_imm, _)) => {\n                 Some(AliasableBorrowed(m))\n             }"}, {"sha": "ccb62252e5d88ee0f26b283bffe62d2eed5ff588", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// A pass that checks to make sure private fields and methods aren't used\n-// outside their scopes.\n-\n+//! A pass that checks to make sure private fields and methods aren't used\n+//! outside their scopes.\n \n use metadata::csearch;\n use middle::ty::{ty_struct, ty_enum};\n@@ -226,7 +225,7 @@ impl PrivacyVisitor {\n \n         if method_id.crate == LOCAL_CRATE {\n             let is_private = self.method_is_private(span, method_id.node);\n-            let container_id = ty::method(self.tcx, method_id).container_id;\n+            let container_id = ty::method(self.tcx, method_id).container_id();\n             if is_private &&\n                     (container_id.crate != LOCAL_CRATE ||\n                      !self.privileged_items.iter().any(|x| x == &(container_id.node))) {\n@@ -251,21 +250,29 @@ impl PrivacyVisitor {\n         match def {\n             def_static_method(method_id, _, _) => {\n                 debug!(\"found static method def, checking it\");\n-                self.check_method_common(span, method_id, path.idents.last())\n+                self.check_method_common(span,\n+                                         method_id,\n+                                         &path.segments.last().identifier)\n             }\n             def_fn(def_id, _) => {\n                 if def_id.crate == LOCAL_CRATE {\n                     if self.local_item_is_private(span, def_id.node) &&\n                             !self.privileged_items.iter().any(|x| x == &def_id.node) {\n                         self.tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n-                                               token::ident_to_str(path.idents.last())));\n+                                               token::ident_to_str(\n+                                                &path.segments\n+                                                     .last()\n+                                                     .identifier)));\n                     }\n                 } else if csearch::get_item_visibility(self.tcx.sess.cstore,\n                                                        def_id) != public {\n                     self.tcx.sess.span_err(span,\n                                       fmt!(\"function `%s` is private\",\n-                                           token::ident_to_str(path.idents.last())));\n+                                           token::ident_to_str(\n+                                                &path.segments\n+                                                     .last()\n+                                                     .identifier)));\n                 }\n             }\n             _ => {}"}, {"sha": "d6b6a948a57155db396145e565ff43fbc381eb93", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -827,7 +827,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n           Some(&ast::def_trait(did)) |\n           Some(&ast::def_struct(did)) => {\n             if did.crate == ast::LOCAL_CRATE {\n-                if cx.region_is_relevant(&path.rp) {\n+                if cx.region_is_relevant(&path.segments.last().lifetime) {\n                     cx.add_dep(did.node);\n                 }\n             } else {\n@@ -837,7 +837,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n                   Some(variance) => {\n                     debug!(\"reference to external, rp'd type %s\",\n                            pprust::ty_to_str(ty, sess.intr()));\n-                    if cx.region_is_relevant(&path.rp) {\n+                    if cx.region_is_relevant(&path.segments.last().lifetime) {\n                         let rv = cx.add_variance(variance);\n                         cx.add_rp(cx.item_id, rv)\n                     }\n@@ -860,7 +860,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n       ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n-            for tp in path.types.iter() {\n+            for tp in path.segments.iter().flat_map(|s| s.types.iter()) {\n                 visitor.visit_ty(tp, cx);\n             }\n         }"}, {"sha": "2989f1047298ccace23c91427c3adab797062ffb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 332, "deletions": 273, "changes": 605, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -10,10 +10,11 @@\n \n \n use driver::session::Session;\n-use metadata::csearch::{each_path, get_trait_method_def_ids};\n+use metadata::csearch::get_trait_method_def_ids;\n use metadata::csearch::get_method_name_and_explicit_self;\n use metadata::csearch::get_static_methods_if_impl;\n use metadata::csearch::{get_type_name_if_impl, get_struct_fields};\n+use metadata::csearch;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n@@ -55,6 +56,12 @@ pub type BindingMap = HashMap<ident,binding_info>;\n // Trait method resolution\n pub type TraitMap = HashMap<NodeId,@mut ~[def_id]>;\n \n+// A summary of the generics on a trait.\n+struct TraitGenerics {\n+    has_lifetime: bool,\n+    type_parameter_count: uint,\n+}\n+\n // This is the replacement export map. It maps a module to all of the exports\n // within.\n pub type ExportMap2 = @mut HashMap<NodeId, ~[Export2]>;\n@@ -464,12 +471,18 @@ pub struct Module {\n \n     // The index of the import we're resolving.\n     resolved_import_count: uint,\n+\n+    // Whether this module is populated. If not populated, any attempt to\n+    // access the children must be preceded with a\n+    // `populate_module_if_necessary` call.\n+    populated: bool,\n }\n \n pub fn Module(parent_link: ParentLink,\n               def_id: Option<def_id>,\n-              kind: ModuleKind)\n-           -> Module {\n+              kind: ModuleKind,\n+              external: bool)\n+              -> Module {\n     Module {\n         parent_link: parent_link,\n         def_id: def_id,\n@@ -480,7 +493,8 @@ pub fn Module(parent_link: ParentLink,\n         anonymous_children: @mut HashMap::new(),\n         import_resolutions: @mut HashMap::new(),\n         glob_count: 0,\n-        resolved_import_count: 0\n+        resolved_import_count: 0,\n+        populated: !external,\n     }\n }\n \n@@ -527,9 +541,10 @@ impl NameBindings {\n                          parent_link: ParentLink,\n                          def_id: Option<def_id>,\n                          kind: ModuleKind,\n+                         external: bool,\n                          sp: span) {\n         // Merges the module with the existing type def or creates a new one.\n-        let module_ = @mut Module(parent_link, def_id, kind);\n+        let module_ = @mut Module(parent_link, def_id, kind, external);\n         match self.type_def {\n             None => {\n                 self.type_def = Some(TypeNsDef {\n@@ -556,10 +571,11 @@ impl NameBindings {\n                            parent_link: ParentLink,\n                            def_id: Option<def_id>,\n                            kind: ModuleKind,\n+                           external: bool,\n                            _sp: span) {\n         match self.type_def {\n             None => {\n-                let module = @mut Module(parent_link, def_id, kind);\n+                let module = @mut Module(parent_link, def_id, kind, external);\n                 self.type_def = Some(TypeNsDef {\n                     privacy: privacy,\n                     module_def: Some(module),\n@@ -570,7 +586,10 @@ impl NameBindings {\n             Some(type_def) => {\n                 match type_def.module_def {\n                     None => {\n-                        let module = @mut Module(parent_link, def_id, kind);\n+                        let module = @mut Module(parent_link,\n+                                                 def_id,\n+                                                 kind,\n+                                                 external);\n                         self.type_def = Some(TypeNsDef {\n                             privacy: privacy,\n                             module_def: Some(module),\n@@ -792,6 +811,7 @@ pub fn Resolver(session: Session,\n                              NoParentLink,\n                              Some(def_id { crate: 0, node: 0 }),\n                              NormalModuleKind,\n+                             false,\n                              crate.span);\n \n     let current_module = graph_root.get_module();\n@@ -1157,6 +1177,7 @@ impl Resolver {\n                                             parent_link,\n                                             Some(def_id),\n                                             NormalModuleKind,\n+                                            false,\n                                             sp);\n \n                 let new_parent =\n@@ -1179,6 +1200,7 @@ impl Resolver {\n                                                     parent_link,\n                                                     Some(def_id),\n                                                     ExternModuleKind,\n+                                                    false,\n                                                     sp);\n \n                         ModuleReducedGraphParent(name_bindings.get_module())\n@@ -1277,7 +1299,7 @@ impl Resolver {\n                     &Ty {\n                         node: ty_path(ref path, _, _),\n                         _\n-                    } if path.idents.len() == 1 => {\n+                    } if path.segments.len() == 1 => {\n                         let name = path_to_ident(path);\n \n                         let new_parent = match parent.children.find(&name) {\n@@ -1303,6 +1325,7 @@ impl Resolver {\n                                                             parent_link,\n                                                             Some(def_id),\n                                                             ImplModuleKind,\n+                                                            false,\n                                                             sp);\n \n                                 ModuleReducedGraphParent(\n@@ -1321,9 +1344,12 @@ impl Resolver {\n                                                method.span);\n                             let def = match method.explicit_self.node {\n                                 sty_static => {\n-                                    // Static methods become `def_fn`s.\n-                                    def_fn(local_def(method.id),\n-                                           method.purity)\n+                                    // Static methods become\n+                                    // `def_static_method`s.\n+                                    def_static_method(local_def(method.id),\n+                                                      FromImpl(local_def(\n+                                                        item.id)),\n+                                                      method.purity)\n                                 }\n                                 _ => {\n                                     // Non-static methods become\n@@ -1357,6 +1383,7 @@ impl Resolver {\n                                             parent_link,\n                                             Some(local_def(item.id)),\n                                             TraitModuleKind,\n+                                            false,\n                                             sp);\n                 let module_parent = ModuleReducedGraphParent(name_bindings.\n                                                              get_module());\n@@ -1373,7 +1400,7 @@ impl Resolver {\n                         sty_static => {\n                             // Static methods become `def_static_method`s.\n                             def_static_method(local_def(ty_m.id),\n-                                              Some(local_def(item.id)),\n+                                              FromTrait(local_def(item.id)),\n                                               ty_m.purity)\n                         }\n                         _ => {\n@@ -1476,20 +1503,22 @@ impl Resolver {\n                     let mut module_path = ~[];\n                     match view_path.node {\n                         view_path_simple(_, ref full_path, _) => {\n-                            let path_len = full_path.idents.len();\n+                            let path_len = full_path.segments.len();\n                             assert!(path_len != 0);\n \n-                            for (i, ident) in full_path.idents.iter().enumerate() {\n+                            for (i, segment) in full_path.segments\n+                                                         .iter()\n+                                                         .enumerate() {\n                                 if i != path_len - 1 {\n-                                    module_path.push(*ident);\n+                                    module_path.push(segment.identifier)\n                                 }\n                             }\n                         }\n \n                         view_path_glob(ref module_ident_path, _) |\n                         view_path_list(ref module_ident_path, _, _) => {\n-                            for ident in module_ident_path.idents.iter() {\n-                                module_path.push(*ident);\n+                            for segment in module_ident_path.segments.iter() {\n+                                module_path.push(segment.identifier)\n                             }\n                         }\n                     }\n@@ -1498,7 +1527,8 @@ impl Resolver {\n                     let module_ = self.get_module_from_parent(parent);\n                     match view_path.node {\n                         view_path_simple(binding, ref full_path, id) => {\n-                            let source_ident = *full_path.idents.last();\n+                            let source_ident =\n+                                full_path.segments.last().identifier;\n                             let subclass = @SingleImport(binding,\n                                                          source_ident);\n                             self.build_import_directive(privacy,\n@@ -1543,7 +1573,8 @@ impl Resolver {\n                             (self.get_module_from_parent(parent), name);\n                         let external_module = @mut Module(parent_link,\n                                                           Some(def_id),\n-                                                          NormalModuleKind);\n+                                                          NormalModuleKind,\n+                                                          false);\n \n                         parent.external_module_children.insert(\n                             name,\n@@ -1607,7 +1638,8 @@ impl Resolver {\n             let new_module = @mut Module(\n                 BlockParentLink(parent_module, block_id),\n                 None,\n-                AnonymousModuleKind);\n+                AnonymousModuleKind,\n+                false);\n             parent_module.anonymous_children.insert(block_id, new_module);\n             new_parent = ModuleReducedGraphParent(new_module);\n         } else {\n@@ -1617,69 +1649,43 @@ impl Resolver {\n         visit::walk_block(visitor, block, new_parent);\n     }\n \n-    pub fn handle_external_def(@mut self,\n-                               def: def,\n-                               visibility: ast::visibility,\n-                               modules: &mut HashMap<def_id, @mut Module>,\n-                               child_name_bindings: @mut NameBindings,\n-                               final_ident: &str,\n-                               ident: ident,\n-                               new_parent: ReducedGraphParent) {\n+    fn handle_external_def(@mut self,\n+                           def: def,\n+                           visibility: ast::visibility,\n+                           child_name_bindings: @mut NameBindings,\n+                           final_ident: &str,\n+                           ident: ident,\n+                           new_parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(visibility);\n         match def {\n-          def_mod(def_id) | def_foreign_mod(def_id) => {\n+          def_mod(def_id) | def_foreign_mod(def_id) | def_struct(def_id) |\n+          def_ty(def_id) => {\n             match child_name_bindings.type_def {\n               Some(TypeNsDef { module_def: Some(module_def), _ }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n                 module_def.def_id = Some(def_id);\n-                modules.insert(def_id, module_def);\n               }\n               Some(_) | None => {\n                 debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n                         %s\", final_ident);\n                 let parent_link = self.get_parent_link(new_parent, ident);\n \n-                // FIXME (#5074): this should be a match on find\n-                if !modules.contains_key(&def_id) {\n-                    child_name_bindings.define_module(privacy,\n-                                                      parent_link,\n-                                                      Some(def_id),\n-                                                      NormalModuleKind,\n-                                                      dummy_sp());\n-                    modules.insert(def_id,\n-                                   child_name_bindings.get_module());\n-                } else {\n-                    let existing_module = *modules.get(&def_id);\n-\n-                    // Create an import resolution to avoid creating cycles in\n-                    // the module graph.\n-\n-                    let resolution = @mut ImportResolution(Public, 0);\n-                    resolution.outstanding_references = 0;\n-\n-                    match existing_module.parent_link {\n-                      NoParentLink |\n-                      BlockParentLink(*) => {\n-                        fail!(\"can't happen\");\n-                      }\n-                      ModuleParentLink(parent_module, ident) => {\n-                        let name_bindings = parent_module.children.get(\n-                            &ident);\n-                        resolution.type_target =\n-                            Some(Target(parent_module, *name_bindings));\n-                      }\n-                    }\n-\n-                    debug!(\"(building reduced graph for external crate) \\\n-                            ... creating import resolution\");\n-\n-                    new_parent.import_resolutions.insert(ident, resolution);\n-                }\n+                child_name_bindings.define_module(privacy,\n+                                                  parent_link,\n+                                                  Some(def_id),\n+                                                  NormalModuleKind,\n+                                                  true,\n+                                                  dummy_sp());\n               }\n             }\n           }\n+          _ => {}\n+        }\n+\n+        match def {\n+          def_mod(_) | def_foreign_mod(_) => {}\n           def_variant(*) => {\n             debug!(\"(building reduced graph for external crate) building \\\n                     variant %s\",\n@@ -1691,7 +1697,7 @@ impl Resolver {\n           }\n           def_fn(*) | def_static_method(*) | def_static(*) => {\n             debug!(\"(building reduced graph for external \\\n-                    crate) building value %s\", final_ident);\n+                    crate) building value (fn/static) %s\", final_ident);\n             child_name_bindings.define_value(privacy, def, dummy_sp());\n           }\n           def_trait(def_id) => {\n@@ -1737,6 +1743,7 @@ impl Resolver {\n                                                   parent_link,\n                                                   Some(def_id),\n                                                   TraitModuleKind,\n+                                                  true,\n                                                   dummy_sp())\n           }\n           def_ty(_) => {\n@@ -1767,184 +1774,183 @@ impl Resolver {\n         }\n     }\n \n-    /**\n-     * Builds the reduced graph rooted at the 'use' directive for an external\n-     * crate.\n-     */\n-    pub fn build_reduced_graph_for_external_crate(@mut self,\n-                                                  root: @mut Module) {\n-        let mut modules = HashMap::new();\n-\n-        // Create all the items reachable by paths.\n-        do each_path(self.session.cstore, root.def_id.unwrap().crate)\n-                |path_string, def_like, visibility| {\n-\n-            debug!(\"(building reduced graph for external crate) found path \\\n-                        entry: %s (%?)\",\n-                    path_string, def_like);\n-\n-            let mut pieces: ~[&str] = path_string.split_str_iter(\"::\").collect();\n-            let final_ident_str = pieces.pop();\n-            let final_ident = self.session.ident_of(final_ident_str);\n-\n-            // Find the module we need, creating modules along the way if we\n-            // need to.\n-\n-            let mut current_module = root;\n-            for ident_str in pieces.iter() {\n-                let ident = self.session.ident_of(*ident_str);\n-                // Create or reuse a graph node for the child.\n-                let (child_name_bindings, new_parent) =\n-                    self.add_child(ident,\n-                                   ModuleReducedGraphParent(current_module),\n-                                   OverwriteDuplicates,\n-                                   dummy_sp());\n-\n-                // Define or reuse the module node.\n-                match child_name_bindings.type_def {\n-                    None => {\n-                        debug!(\"(building reduced graph for external crate) \\\n-                                autovivifying missing type def %s\",\n-                                *ident_str);\n-                        let parent_link = self.get_parent_link(new_parent,\n-                                                               ident);\n-                        child_name_bindings.define_module(Public,\n-                                                          parent_link,\n-                                                          None,\n-                                                          NormalModuleKind,\n-                                                          dummy_sp());\n+    /// Builds the reduced graph for a single item in an external crate.\n+    fn build_reduced_graph_for_external_crate_def(@mut self,\n+                                                  root: @mut Module,\n+                                                  def_like: def_like,\n+                                                  ident: ident) {\n+        match def_like {\n+            dl_def(def) => {\n+                // Add the new child item, if necessary.\n+                match def {\n+                    def_foreign_mod(def_id) => {\n+                        // Foreign modules have no names. Recur and populate\n+                        // eagerly.\n+                        do csearch::each_child_of_item(self.session.cstore,\n+                                                       def_id)\n+                                |def_like, child_ident| {\n+                            self.build_reduced_graph_for_external_crate_def(\n+                                root,\n+                                def_like,\n+                                child_ident)\n+                        }\n                     }\n-                    Some(type_ns_def)\n-                            if type_ns_def.module_def.is_none() => {\n-                        debug!(\"(building reduced graph for external crate) \\\n-                                autovivifying missing module def %s\",\n-                                *ident_str);\n-                        let parent_link = self.get_parent_link(new_parent,\n-                                                               ident);\n-                        child_name_bindings.define_module(Public,\n-                                                          parent_link,\n-                                                          None,\n-                                                          NormalModuleKind,\n-                                                          dummy_sp());\n+                    _ => {\n+                        let (child_name_bindings, new_parent) =\n+                            self.add_child(ident,\n+                                           ModuleReducedGraphParent(root),\n+                                           OverwriteDuplicates,\n+                                           dummy_sp());\n+\n+                        self.handle_external_def(def,\n+                                                 public,\n+                                                 child_name_bindings,\n+                                                 self.session.str_of(ident),\n+                                                 ident,\n+                                                 new_parent);\n                     }\n-                    _ => {} // Fall through.\n-                }\n-\n-                current_module = child_name_bindings.get_module();\n-            }\n-\n-            match def_like {\n-                dl_def(def) => {\n-                    // Add the new child item.\n-                    let (child_name_bindings, new_parent) =\n-                        self.add_child(final_ident,\n-                                       ModuleReducedGraphParent(\n-                                            current_module),\n-                                       OverwriteDuplicates,\n-                                       dummy_sp());\n-\n-                    self.handle_external_def(def,\n-                                             visibility,\n-                                             &mut modules,\n-                                             child_name_bindings,\n-                                             self.session.str_of(\n-                                                 final_ident),\n-                                             final_ident,\n-                                             new_parent);\n-                }\n-                dl_impl(def) => {\n-                    // We only process static methods of impls here.\n-                    match get_type_name_if_impl(self.session.cstore, def) {\n-                        None => {}\n-                        Some(final_ident) => {\n-                            let static_methods_opt =\n-                                get_static_methods_if_impl(\n-                                    self.session.cstore, def);\n-                            match static_methods_opt {\n-                                Some(ref static_methods) if\n-                                    static_methods.len() >= 1 => {\n-                                    debug!(\"(building reduced graph for \\\n-                                            external crate) processing \\\n-                                            static methods for type name %s\",\n-                                            self.session.str_of(\n-                                                final_ident));\n-\n-                                    let (child_name_bindings, new_parent) =\n-                                        self.add_child(final_ident,\n-                                            ModuleReducedGraphParent(\n-                                                            current_module),\n-                                            OverwriteDuplicates,\n-                                            dummy_sp());\n-\n-                                    // Process the static methods. First,\n-                                    // create the module.\n-                                    let type_module;\n-                                    match child_name_bindings.type_def {\n-                                        Some(TypeNsDef {\n-                                            module_def: Some(module_def),\n-                                            _\n-                                        }) => {\n-                                            // We already have a module. This\n-                                            // is OK.\n-                                            type_module = module_def;\n-\n-                                            // Mark it as an impl module if\n-                                            // necessary.\n-                                            type_module.kind = ImplModuleKind;\n-                                        }\n-                                        Some(_) | None => {\n-                                            let parent_link =\n-                                                self.get_parent_link(\n-                                                    new_parent, final_ident);\n-                                            child_name_bindings.define_module(\n-                                                Public,\n-                                                parent_link,\n-                                                Some(def),\n-                                                ImplModuleKind,\n-                                                dummy_sp());\n-                                            type_module =\n-                                                child_name_bindings.\n-                                                    get_module();\n-                                        }\n+                }\n+            }\n+            dl_impl(def) => {\n+                // We only process static methods of impls here.\n+                match get_type_name_if_impl(self.session.cstore, def) {\n+                    None => {}\n+                    Some(final_ident) => {\n+                        let static_methods_opt =\n+                            get_static_methods_if_impl(self.session.cstore,\n+                                                       def);\n+                        match static_methods_opt {\n+                            Some(ref static_methods) if\n+                                static_methods.len() >= 1 => {\n+                                debug!(\"(building reduced graph for \\\n+                                        external crate) processing \\\n+                                        static methods for type name %s\",\n+                                        self.session.str_of(\n+                                            final_ident));\n+\n+                                let (child_name_bindings, new_parent) =\n+                                    self.add_child(\n+                                        final_ident,\n+                                        ModuleReducedGraphParent(root),\n+                                        OverwriteDuplicates,\n+                                        dummy_sp());\n+\n+                                // Process the static methods. First,\n+                                // create the module.\n+                                let type_module;\n+                                match child_name_bindings.type_def {\n+                                    Some(TypeNsDef {\n+                                        module_def: Some(module_def),\n+                                        _\n+                                    }) => {\n+                                        // We already have a module. This\n+                                        // is OK.\n+                                        type_module = module_def;\n+\n+                                        // Mark it as an impl module if\n+                                        // necessary.\n+                                        type_module.kind = ImplModuleKind;\n                                     }\n-\n-                                    // Add each static method to the module.\n-                                    let new_parent = ModuleReducedGraphParent(\n-                                        type_module);\n-                                    for static_method_info in static_methods.iter() {\n-                                        let ident = static_method_info.ident;\n-                                        debug!(\"(building reduced graph for \\\n-                                                 external crate) creating \\\n-                                                 static method '%s'\",\n-                                               self.session.str_of(ident));\n-\n-                                        let (method_name_bindings, _) =\n-                                            self.add_child(\n-                                                ident,\n-                                                new_parent,\n-                                                OverwriteDuplicates,\n-                                                dummy_sp());\n-                                        let def = def_fn(\n-                                            static_method_info.def_id,\n-                                            static_method_info.purity);\n-                                        method_name_bindings.define_value(\n-                                            Public, def, dummy_sp());\n+                                    Some(_) | None => {\n+                                        let parent_link =\n+                                            self.get_parent_link(new_parent,\n+                                                                 final_ident);\n+                                        child_name_bindings.define_module(\n+                                            Public,\n+                                            parent_link,\n+                                            Some(def),\n+                                            ImplModuleKind,\n+                                            true,\n+                                            dummy_sp());\n+                                        type_module =\n+                                            child_name_bindings.\n+                                                get_module();\n                                     }\n                                 }\n \n-                                // Otherwise, do nothing.\n-                                Some(_) | None => {}\n+                                // Add each static method to the module.\n+                                let new_parent =\n+                                    ModuleReducedGraphParent(type_module);\n+                                for static_method_info in\n+                                        static_methods.iter() {\n+                                    let ident = static_method_info.ident;\n+                                    debug!(\"(building reduced graph for \\\n+                                             external crate) creating \\\n+                                             static method '%s'\",\n+                                           self.session.str_of(ident));\n+\n+                                    let (method_name_bindings, _) =\n+                                        self.add_child(ident,\n+                                                       new_parent,\n+                                                       OverwriteDuplicates,\n+                                                       dummy_sp());\n+                                    let def = def_fn(\n+                                        static_method_info.def_id,\n+                                        static_method_info.purity);\n+                                    method_name_bindings.define_value(\n+                                        Public,\n+                                        def,\n+                                        dummy_sp());\n+                                }\n                             }\n+\n+                            // Otherwise, do nothing.\n+                            Some(_) | None => {}\n                         }\n                     }\n                 }\n-                dl_field => {\n-                    debug!(\"(building reduced graph for external crate) \\\n-                            ignoring field\");\n-                }\n             }\n-            true\n+            dl_field => {\n+                debug!(\"(building reduced graph for external crate) \\\n+                        ignoring field\");\n+            }\n+        }\n+    }\n+\n+    /// Builds the reduced graph rooted at the given external module.\n+    fn populate_external_module(@mut self, module: @mut Module) {\n+        debug!(\"(populating external module) attempting to populate %s\",\n+               self.module_to_str(module));\n+\n+        let def_id = match module.def_id {\n+            None => {\n+                debug!(\"(populating external module) ... no def ID!\");\n+                return\n+            }\n+            Some(def_id) => def_id,\n         };\n+\n+        do csearch::each_child_of_item(self.session.cstore, def_id)\n+                |def_like, child_ident| {\n+            debug!(\"(populating external module) ... found ident: %s\",\n+                   token::ident_to_str(&child_ident));\n+            self.build_reduced_graph_for_external_crate_def(module,\n+                                                            def_like,\n+                                                            child_ident)\n+        }\n+        module.populated = true\n+    }\n+\n+    /// Ensures that the reduced graph rooted at the given external module\n+    /// is built, building it if it is not.\n+    fn populate_module_if_necessary(@mut self, module: @mut Module) {\n+        if !module.populated {\n+            self.populate_external_module(module)\n+        }\n+        assert!(module.populated)\n+    }\n+\n+    /// Builds the reduced graph rooted at the 'use' directive for an external\n+    /// crate.\n+    pub fn build_reduced_graph_for_external_crate(@mut self,\n+                                                  root: @mut Module) {\n+        do csearch::each_top_level_item_of_crate(self.session.cstore,\n+                                                 root.def_id.unwrap().crate)\n+                |def_like, ident| {\n+            self.build_reduced_graph_for_external_crate_def(root,\n+                                                            def_like,\n+                                                            ident)\n+        }\n     }\n \n     /// Creates and adds an import directive to the given module.\n@@ -2043,6 +2049,7 @@ impl Resolver {\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n \n+        self.populate_module_if_necessary(module_);\n         for (_, &child_node) in module_.children.iter() {\n             match child_node.get_module_if_available() {\n                 None => {\n@@ -2109,6 +2116,14 @@ impl Resolver {\n         return result;\n     }\n \n+    fn path_idents_to_str(@mut self, path: &Path) -> ~str {\n+        let identifiers: ~[ast::ident] = path.segments\n+                                             .iter()\n+                                             .map(|seg| seg.identifier)\n+                                             .collect();\n+        self.idents_to_str(identifiers)\n+    }\n+\n     pub fn import_directive_subclass_to_str(@mut self,\n                                             subclass: ImportDirectiveSubclass)\n                                             -> @str {\n@@ -2260,6 +2275,7 @@ impl Resolver {\n         let mut type_result = UnknownResult;\n \n         // Search for direct children of the containing module.\n+        self.populate_module_if_necessary(containing_module);\n         match containing_module.children.find(&source) {\n             None => {\n                 // Continue.\n@@ -2578,6 +2594,7 @@ impl Resolver {\n         };\n \n         // Add all children from the containing module.\n+        self.populate_module_if_necessary(containing_module);\n         for (&ident, name_bindings) in containing_module.children.iter() {\n             merge_import_resolution(ident, *name_bindings);\n         }\n@@ -2811,6 +2828,7 @@ impl Resolver {\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n+        self.populate_module_if_necessary(module_);\n         match module_.children.find(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n@@ -3065,6 +3083,7 @@ impl Resolver {\n                self.module_to_str(module_));\n \n         // First, check the direct children of the module.\n+        self.populate_module_if_necessary(module_);\n         match module_.children.find(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n@@ -3154,6 +3173,7 @@ impl Resolver {\n         }\n \n         // Descend into children and anonymous children.\n+        self.populate_module_if_necessary(module_);\n         for (_, &child_node) in module_.children.iter() {\n             match child_node.get_module_if_available() {\n                 None => {\n@@ -3212,6 +3232,7 @@ impl Resolver {\n         }\n \n         self.record_exports_for_module(module_);\n+        self.populate_module_if_necessary(module_);\n \n         for (_, &child_name_bindings) in module_.children.iter() {\n             match child_name_bindings.get_module_if_available() {\n@@ -3325,6 +3346,7 @@ impl Resolver {\n                 // Nothing to do.\n             }\n             Some(name) => {\n+                self.populate_module_if_necessary(orig_module);\n                 match orig_module.children.find(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n@@ -3841,8 +3863,7 @@ impl Resolver {\n                                    reference_type: TraitReferenceType) {\n         match self.resolve_path(id, &trait_reference.path, TypeNS, true, visitor) {\n             None => {\n-                let path_str = self.idents_to_str(trait_reference.path.idents);\n-\n+                let path_str = self.path_idents_to_str(&trait_reference.path);\n                 let usage_str = match reference_type {\n                     TraitBoundingTypeParameter => \"bound type parameter with\",\n                     TraitImplementation        => \"implement\",\n@@ -3864,7 +3885,7 @@ impl Resolver {\n                           generics: &Generics,\n                           fields: &[@struct_field],\n                           visitor: &mut ResolveVisitor) {\n-        let mut ident_map = HashMap::new::<ast::ident, @struct_field>();\n+        let mut ident_map: HashMap<ast::ident,@struct_field> = HashMap::new();\n         for &field in fields.iter() {\n             match field.node.kind {\n                 named_field(ident, _) => {\n@@ -4141,8 +4162,8 @@ impl Resolver {\n                 let mut result_def = None;\n \n                 // First, check to see whether the name is a primitive type.\n-                if path.idents.len() == 1 {\n-                    let name = *path.idents.last();\n+                if path.segments.len() == 1 {\n+                    let name = path.segments.last().identifier;\n \n                     match self.primitive_type_table\n                             .primitive_types\n@@ -4151,6 +4172,22 @@ impl Resolver {\n                         Some(&primitive_type) => {\n                             result_def =\n                                 Some(def_prim_ty(primitive_type));\n+\n+                            if path.segments\n+                                   .iter()\n+                                   .any(|s| s.lifetime.is_some()) {\n+                                self.session.span_err(path.span,\n+                                                      \"lifetime parameters \\\n+                                                       are not allowed on \\\n+                                                       this type\")\n+                            } else if path.segments\n+                                          .iter()\n+                                          .any(|s| s.types.len() > 0) {\n+                                self.session.span_err(path.span,\n+                                                      \"type parameters are \\\n+                                                       not allowed on this \\\n+                                                       type\")\n+                            }\n                         }\n                         None => {\n                             // Continue.\n@@ -4160,12 +4197,17 @@ impl Resolver {\n \n                 match result_def {\n                     None => {\n-                        match self.resolve_path(ty.id, path, TypeNS, true, visitor) {\n+                        match self.resolve_path(ty.id,\n+                                                path,\n+                                                TypeNS,\n+                                                true,\n+                                                visitor) {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `%s` to \\\n                                         type %?\",\n-                                       self.session.str_of(\n-                                            *path.idents.last()),\n+                                       self.session.str_of(path.segments\n+                                                               .last()\n+                                                               .identifier),\n                                        def);\n                                 result_def = Some(def);\n                             }\n@@ -4174,24 +4216,23 @@ impl Resolver {\n                             }\n                         }\n                     }\n-                    Some(_) => {\n-                        // Continue.\n-                    }\n+                    Some(_) => {}   // Continue.\n                 }\n \n                 match result_def {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `%s` \\\n                                 (id %d)\",\n-                               self.idents_to_str(path.idents),\n+                               self.path_idents_to_str(path),\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n                         self.resolve_error\n-                            (ty.span, fmt!(\"use of undeclared type name `%s`\",\n-                                           self.idents_to_str(path.idents)));\n+                            (ty.span,\n+                             fmt!(\"use of undeclared type name `%s`\",\n+                                  self.path_idents_to_str(path)))\n                     }\n                 }\n \n@@ -4230,7 +4271,7 @@ impl Resolver {\n         do walk_pat(pattern) |pattern| {\n             match pattern.node {\n                 pat_ident(binding_mode, ref path, _)\n-                        if !path.global && path.idents.len() == 1 => {\n+                        if !path.global && path.segments.len() == 1 => {\n \n                     // The meaning of pat_ident with no type parameters\n                     // depends on whether an enum variant or unit-like struct\n@@ -4241,7 +4282,7 @@ impl Resolver {\n                     // such a value is simply disallowed (since it's rarely\n                     // what you want).\n \n-                    let ident = path.idents[0];\n+                    let ident = path.segments[0].identifier;\n \n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def)\n@@ -4351,7 +4392,9 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for ty in path.types.iter() {\n+                    for ty in path.segments\n+                                  .iter()\n+                                  .flat_map(|seg| seg.types.iter()) {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4375,7 +4418,7 @@ impl Resolver {\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant or constant\",\n                                      self.session.str_of(\n-                                         *path.idents.last())));\n+                                         path.segments.last().identifier)))\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n@@ -4384,7 +4427,9 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for ty in path.types.iter() {\n+                    for ty in path.segments\n+                                  .iter()\n+                                  .flat_map(|s| s.types.iter()) {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4402,8 +4447,10 @@ impl Resolver {\n                             self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant, struct or const\",\n-                                     self.session.str_of(\n-                                         *path.idents.last())));\n+                                     self.session\n+                                         .str_of(path.segments\n+                                                     .last()\n+                                                     .identifier)));\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n@@ -4413,7 +4460,9 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for ty in path.types.iter() {\n+                    for ty in path.segments\n+                                  .iter()\n+                                  .flat_map(|s| s.types.iter()) {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4448,7 +4497,7 @@ impl Resolver {\n                             self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` does not name a structure\",\n-                                     self.idents_to_str(path.idents)));\n+                                     self.path_idents_to_str(path)));\n                         }\n                     }\n                 }\n@@ -4510,7 +4559,7 @@ impl Resolver {\n                         visitor: &mut ResolveVisitor)\n                         -> Option<def> {\n         // First, resolve the types.\n-        for ty in path.types.iter() {\n+        for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n             self.resolve_type(ty, visitor);\n         }\n \n@@ -4520,20 +4569,27 @@ impl Resolver {\n                                                     namespace);\n         }\n \n-        let unqualified_def = self.resolve_identifier(\n-            *path.idents.last(), namespace, check_ribs, path.span);\n+        let unqualified_def = self.resolve_identifier(path.segments\n+                                                          .last()\n+                                                          .identifier,\n+                                                      namespace,\n+                                                      check_ribs,\n+                                                      path.span);\n \n-        if path.idents.len() > 1 {\n-            let def = self.resolve_module_relative_path(\n-                path, self.xray_context, namespace);\n+        if path.segments.len() > 1 {\n+            let def = self.resolve_module_relative_path(path,\n+                                                        self.xray_context,\n+                                                        namespace);\n             match (def, unqualified_def) {\n                 (Some(d), Some(ud)) if d == ud => {\n                     self.session.add_lint(unnecessary_qualification,\n-                                          id, path.span,\n+                                          id,\n+                                          path.span,\n                                           ~\"unnecessary qualification\");\n                 }\n                 _ => ()\n             }\n+\n             return def;\n         }\n \n@@ -4571,6 +4627,7 @@ impl Resolver {\n                                                 xray: XrayFlag)\n                                                 -> NameDefinition {\n         // First, search children.\n+        self.populate_module_if_necessary(containing_module);\n         match containing_module.children.find(&name) {\n             Some(child_name_bindings) => {\n                 match (child_name_bindings.def_for_namespace(namespace),\n@@ -4640,12 +4697,12 @@ impl Resolver {\n \n     pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n-        for (index, ident) in path.idents.iter().enumerate() {\n-            if index == path.idents.len() - 1 {\n+        for (index, segment) in path.segments.iter().enumerate() {\n+            if index == path.segments.len() - 1 {\n                 break;\n             }\n \n-            module_path_idents.push(*ident);\n+            module_path_idents.push(segment.identifier);\n         }\n \n         return module_path_idents;\n@@ -4681,7 +4738,7 @@ impl Resolver {\n             }\n         }\n \n-        let name = *path.idents.last();\n+        let name = path.segments.last().identifier;\n         let def = match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace,\n@@ -4749,7 +4806,7 @@ impl Resolver {\n             }\n         }\n \n-        let name = *path.idents.last();\n+        let name = path.segments.last().identifier;\n         match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace,\n@@ -4969,7 +5026,7 @@ impl Resolver {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n-                               self.idents_to_str(path.idents));\n+                               self.path_idents_to_str(path));\n \n                         // First-class methods are not supported yet; error\n                         // out here.\n@@ -4989,8 +5046,7 @@ impl Resolver {\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n-                        let wrong_name = self.idents_to_str(\n-                            path.idents);\n+                        let wrong_name = self.path_idents_to_str(path);\n                         if self.name_exists_in_scope_struct(wrong_name) {\n                             self.resolve_error(expr.span,\n                                         fmt!(\"unresolved name `%s`. \\\n@@ -5066,7 +5122,7 @@ impl Resolver {\n                         self.resolve_error(\n                             path.span,\n                             fmt!(\"`%s` does not name a structure\",\n-                                 self.idents_to_str(path.idents)));\n+                                 self.path_idents_to_str(path)));\n                     }\n                 }\n \n@@ -5236,7 +5292,9 @@ impl Resolver {\n                 }\n \n                 // Look for trait children.\n-                for (_, &child_name_bindings) in search_module.children.iter() {\n+                self.populate_module_if_necessary(search_module);\n+                for (_, &child_name_bindings) in\n+                        search_module.children.iter() {\n                     match child_name_bindings.def_for_namespace(TypeNS) {\n                         Some(def) => {\n                             match def {\n@@ -5435,6 +5493,7 @@ impl Resolver {\n         debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");\n+        self.populate_module_if_necessary(module_);\n         for (&name, _) in module_.children.iter() {\n             debug!(\"* %s\", self.session.str_of(name));\n         }"}, {"sha": "9502e02c27945c687d59d48b1366e58aeff9a386", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -117,10 +117,13 @@ pub fn trans(bcx: @mut Block, expr: @ast::expr) -> Callee {\n \n     fn trans_def(bcx: @mut Block, def: ast::def, ref_expr: @ast::expr) -> Callee {\n         match def {\n-            ast::def_fn(did, _) | ast::def_static_method(did, None, _) => {\n+            ast::def_fn(did, _) |\n+            ast::def_static_method(did, ast::FromImpl(_), _) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, did, ref_expr.id))\n             }\n-            ast::def_static_method(impl_did, Some(trait_did), _) => {\n+            ast::def_static_method(impl_did,\n+                                   ast::FromTrait(trait_did),\n+                                   _) => {\n                 fn_callee(bcx, meth::trans_static_method_callee(bcx, impl_did,\n                                                                 trait_did,\n                                                                 ref_expr.id))\n@@ -280,6 +283,14 @@ pub fn trans_fn_ref_with_vtables(\n                               self_ty: None,\n                               tps: /*bad*/ type_params.to_owned() };\n \n+    // Load the info for the appropriate trait if necessary.\n+    match ty::trait_of_method(tcx, def_id) {\n+        None => {}\n+        Some(trait_id) => {\n+            ty::populate_implementations_for_trait_if_necessary(tcx, trait_id)\n+        }\n+    }\n+\n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n@@ -300,7 +311,7 @@ pub fn trans_fn_ref_with_vtables(\n             // So, what we need to do is find this substitution and\n             // compose it with the one we already have.\n \n-            let impl_id = ty::method(tcx, def_id).container_id;\n+            let impl_id = ty::method(tcx, def_id).container_id();\n             let method = ty::method(tcx, source_id);\n             let trait_ref = ty::impl_trait_ref(tcx, impl_id)\n                 .expect(\"could not find trait_ref for impl with \\"}, {"sha": "0dfce6f42c32970d0cc7cd6d837819c0609a1171", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -559,7 +559,9 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n             v\n           }\n           ast::expr_path(ref pth) => {\n-            assert_eq!(pth.types.len(), 0);\n+            // Assert that there are no type parameters in this path.\n+            assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n+\n             let tcx = cx.tcx;\n             match tcx.def_map.find(&e.id) {\n                 Some(&ast::def_fn(def_id, _purity)) => {"}, {"sha": "7c81bfbda6512f209149fb3bc3a7c691a96eafa0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -825,11 +825,13 @@ fn trans_def_datum_unadjusted(bcx: @mut Block,\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let fn_data = match def {\n-        ast::def_fn(did, _) | ast::def_static_method(did, None, _) => {\n+        ast::def_fn(did, _) |\n+        ast::def_static_method(did, ast::FromImpl(_), _) => {\n             callee::trans_fn_ref(bcx, did, ref_expr.id)\n         }\n-        ast::def_static_method(impl_did, Some(trait_did), _) => {\n-            meth::trans_static_method_callee(bcx, impl_did,\n+        ast::def_static_method(impl_did, ast::FromTrait(trait_did), _) => {\n+            meth::trans_static_method_callee(bcx,\n+                                             impl_did,\n                                              trait_did,\n                                              ref_expr.id)\n         }"}, {"sha": "717dfbb67845396e7561dea48bd44fa6b07125b9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -176,6 +176,10 @@ pub fn trans_method_callee(bcx: @mut Block,\n         }) => {\n             match bcx.fcx.param_substs {\n                 Some(substs) => {\n+                    ty::populate_implementations_for_trait_if_necessary(\n+                        bcx.tcx(),\n+                        trait_id);\n+\n                     let vtbl = find_vtable(bcx.tcx(), substs,\n                                            p, b);\n                     trans_monomorphized_callee(bcx, callee_id, this, mentry,\n@@ -210,6 +214,8 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n            callee_id);\n     let _indenter = indenter();\n \n+    ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trait_id);\n+\n     // When we translate a static fn defined in a trait like:\n     //\n     //   trait<T1...Tn> Trait {\n@@ -575,6 +581,8 @@ fn emit_vtable_methods(bcx: @mut Block,\n                                     make a vtable for a type impl!\")\n     };\n \n+    ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n+\n     let trait_method_def_ids = ty::trait_method_def_ids(tcx, trt_id);\n     do trait_method_def_ids.map |method_def_id| {\n         let ident = ty::method(tcx, *method_def_id).ident;"}, {"sha": "6f90953cd413ab2c3274cc257759178e48e32cec", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 160, "deletions": 6, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -60,6 +60,12 @@ pub struct field {\n     mt: mt\n }\n \n+#[deriving(Clone)]\n+pub enum MethodContainer {\n+    TraitContainer(ast::def_id),\n+    ImplContainer(ast::def_id),\n+}\n+\n #[deriving(Clone)]\n pub struct Method {\n     ident: ast::ident,\n@@ -69,7 +75,7 @@ pub struct Method {\n     explicit_self: ast::explicit_self_,\n     vis: ast::visibility,\n     def_id: ast::def_id,\n-    container_id: ast::def_id,\n+    container: MethodContainer,\n \n     // If this method is provided, we need to know where it came from\n     provided_source: Option<ast::def_id>\n@@ -83,7 +89,7 @@ impl Method {\n                explicit_self: ast::explicit_self_,\n                vis: ast::visibility,\n                def_id: ast::def_id,\n-               container_id: ast::def_id,\n+               container: MethodContainer,\n                provided_source: Option<ast::def_id>)\n                -> Method {\n         // Check the invariants.\n@@ -101,10 +107,17 @@ impl Method {\n             explicit_self: explicit_self,\n             vis: vis,\n             def_id: def_id,\n-            container_id: container_id,\n+            container: container,\n             provided_source: provided_source\n         }\n     }\n+\n+    pub fn container_id(&self) -> ast::def_id {\n+        match self.container {\n+            TraitContainer(id) => id,\n+            ImplContainer(id) => id,\n+        }\n+    }\n }\n \n pub struct Impl {\n@@ -324,7 +337,15 @@ struct ctxt_ {\n     used_mut_nodes: @mut HashSet<ast::NodeId>,\n \n     // vtable resolution information for impl declarations\n-    impl_vtables: typeck::impl_vtable_map\n+    impl_vtables: typeck::impl_vtable_map,\n+\n+    // The set of external nominal types whose implementations have been read.\n+    // This is used for lazy resolution of methods.\n+    populated_external_types: @mut HashSet<ast::def_id>,\n+\n+    // The set of external traits whose implementations have been read. This\n+    // is used for lazy resolution of traits.\n+    populated_external_traits: @mut HashSet<ast::def_id>,\n }\n \n pub enum tbox_flag {\n@@ -938,6 +959,8 @@ pub fn mk_ctxt(s: session::Session,\n         used_unsafe: @mut HashSet::new(),\n         used_mut_nodes: @mut HashSet::new(),\n         impl_vtables: @mut HashMap::new(),\n+        populated_external_types: @mut HashSet::new(),\n+        populated_external_traits: @mut HashSet::new(),\n      }\n }\n \n@@ -3612,8 +3635,7 @@ pub fn def_has_ty_params(def: ast::def) -> bool {\n     }\n }\n \n-pub fn provided_source(cx: ctxt, id: ast::def_id)\n-    -> Option<ast::def_id> {\n+pub fn provided_source(cx: ctxt, id: ast::def_id) -> Option<ast::def_id> {\n     cx.provided_method_sources.find(&id).map_move(|x| *x)\n }\n \n@@ -4553,3 +4575,135 @@ pub fn visitor_object_ty(tcx: ctxt,\n                  ast::m_imm,\n                  EmptyBuiltinBounds())))\n }\n+\n+/// Records a trait-to-implementation mapping.\n+fn record_trait_implementation(tcx: ctxt,\n+                               trait_def_id: def_id,\n+                               implementation: @Impl) {\n+    let implementation_list;\n+    match tcx.trait_impls.find(&trait_def_id) {\n+        None => {\n+            implementation_list = @mut ~[];\n+            tcx.trait_impls.insert(trait_def_id, implementation_list);\n+        }\n+        Some(&existing_implementation_list) => {\n+            implementation_list = existing_implementation_list\n+        }\n+    }\n+\n+    implementation_list.push(implementation);\n+}\n+\n+/// Populates the type context with all the implementations for the given type\n+/// if necessary.\n+pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n+                                                      type_id: ast::def_id) {\n+    if type_id.crate == LOCAL_CRATE {\n+        return\n+    }\n+    if tcx.populated_external_types.contains(&type_id) {\n+        return\n+    }\n+\n+    do csearch::each_implementation_for_type(tcx.sess.cstore, type_id)\n+            |implementation_def_id| {\n+        let implementation = @csearch::get_impl(tcx, implementation_def_id);\n+\n+        // Record the trait->implementation mappings, if applicable.\n+        let associated_traits = csearch::get_impl_trait(tcx,\n+                                                        implementation.did);\n+        for trait_ref in associated_traits.iter() {\n+            record_trait_implementation(tcx,\n+                                        trait_ref.def_id,\n+                                        implementation);\n+        }\n+\n+        // For any methods that use a default implementation, add them to\n+        // the map. This is a bit unfortunate.\n+        for method in implementation.methods.iter() {\n+            for source in method.provided_source.iter() {\n+                tcx.provided_method_sources.insert(method.def_id, *source);\n+            }\n+        }\n+\n+        // If this is an inherent implementation, record it.\n+        if associated_traits.is_none() {\n+            let implementation_list;\n+            match tcx.inherent_impls.find(&type_id) {\n+                None => {\n+                    implementation_list = @mut ~[];\n+                    tcx.inherent_impls.insert(type_id, implementation_list);\n+                }\n+                Some(&existing_implementation_list) => {\n+                    implementation_list = existing_implementation_list;\n+                }\n+            }\n+            implementation_list.push(implementation);\n+        }\n+\n+        // Store the implementation info.\n+        tcx.impls.insert(implementation_def_id, implementation);\n+    }\n+\n+    tcx.populated_external_types.insert(type_id);\n+}\n+\n+/// Populates the type context with all the implementations for the given\n+/// trait if necessary.\n+pub fn populate_implementations_for_trait_if_necessary(\n+        tcx: ctxt,\n+        trait_id: ast::def_id) {\n+    if trait_id.crate == LOCAL_CRATE {\n+        return\n+    }\n+    if tcx.populated_external_traits.contains(&trait_id) {\n+        return\n+    }\n+\n+    do csearch::each_implementation_for_trait(tcx.sess.cstore, trait_id)\n+            |implementation_def_id| {\n+        let implementation = @csearch::get_impl(tcx, implementation_def_id);\n+\n+        // Record the trait->implementation mapping.\n+        record_trait_implementation(tcx, trait_id, implementation);\n+\n+        // For any methods that use a default implementation, add them to\n+        // the map. This is a bit unfortunate.\n+        for method in implementation.methods.iter() {\n+            for source in method.provided_source.iter() {\n+                tcx.provided_method_sources.insert(method.def_id, *source);\n+            }\n+        }\n+\n+        // Store the implementation info.\n+        tcx.impls.insert(implementation_def_id, implementation);\n+    }\n+\n+    tcx.populated_external_traits.insert(trait_id);\n+}\n+\n+/// If the given def ID describes a trait method, returns the ID of the trait\n+/// that the method belongs to. Otherwise, returns `None`.\n+pub fn trait_of_method(tcx: ctxt, def_id: ast::def_id)\n+                       -> Option<ast::def_id> {\n+    match tcx.methods.find(&def_id) {\n+        Some(method_descriptor) => {\n+            match method_descriptor.container {\n+                TraitContainer(id) => return Some(id),\n+                _ => {}\n+            }\n+        }\n+        None => {}\n+    }\n+\n+    // If the method was in the local crate, then if we got here we know the\n+    // answer is negative.\n+    if def_id.crate == LOCAL_CRATE {\n+        return None\n+    }\n+\n+    let result = csearch::get_trait_of_method(tcx.cstore, def_id, tcx);\n+\n+    result\n+}\n+"}, {"sha": "17b4716ad508e8927ab4c5953c0171dfa5db8a57", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -63,7 +63,6 @@ use middle::typeck::rscope::RegionParamNames;\n use middle::typeck::lookup_def_tcx;\n \n use std::result;\n-use std::vec;\n use syntax::abi::AbiSet;\n use syntax::{ast, ast_util};\n use syntax::codemap::span;\n@@ -150,7 +149,8 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Clone + 'static>(\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let regions = match (&decl_generics.region_param, &path.rp) {\n+    let regions = match (&decl_generics.region_param,\n+                         &path.segments.last().lifetime) {\n         (&None, &None) => {\n             opt_vec::Empty\n         }\n@@ -169,20 +169,34 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Clone + 'static>(\n         }\n         (&Some(_), &Some(_)) => {\n             opt_vec::with(\n-                ast_region_to_region(this, rscope, path.span, &path.rp))\n+                ast_region_to_region(this,\n+                                     rscope,\n+                                     path.span,\n+                                     &path.segments.last().lifetime))\n         }\n     };\n \n     // Convert the type parameters supplied by the user.\n-    if !vec::same_length(*decl_generics.type_param_defs, path.types) {\n+    let supplied_type_parameter_count =\n+        path.segments.iter().flat_map(|s| s.types.iter()).len();\n+    if decl_generics.type_param_defs.len() != supplied_type_parameter_count {\n         this.tcx().sess.span_fatal(\n             path.span,\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n-                 decl_generics.type_param_defs.len(), path.types.len()));\n+                 decl_generics.type_param_defs.len(),\n+                 supplied_type_parameter_count));\n+    }\n+    let tps = path.segments\n+                  .iter()\n+                  .flat_map(|s| s.types.iter())\n+                  .map(|a_t| ast_ty_to_ty(this, rscope, a_t))\n+                  .collect();\n+\n+    substs {\n+        regions: ty::NonerasedRegions(regions),\n+        self_ty: self_ty,\n+        tps: tps\n     }\n-    let tps = path.types.map(|a_t| ast_ty_to_ty(this, rscope, a_t));\n-\n-    substs {regions:ty::NonerasedRegions(regions), self_ty:self_ty, tps:tps}\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,\n@@ -272,8 +286,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Clone + 'static>(\n         match a_seq_ty.ty.node {\n             ast::ty_vec(ref mt) => {\n                 let mut mt = ast_mt_to_mt(this, rscope, mt);\n-                if a_seq_ty.mutbl == ast::m_mutbl ||\n-                        a_seq_ty.mutbl == ast::m_const {\n+                if a_seq_ty.mutbl == ast::m_mutbl {\n                     mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n                 }\n                 return ty::mk_evec(tcx, mt, vst);\n@@ -326,15 +339,15 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Clone + 'static>(\n                        path: &ast::Path,\n                        flags: uint) {\n         if (flags & NO_TPS) != 0u {\n-            if path.types.len() > 0u {\n+            if !path.segments.iter().all(|s| s.types.is_empty()) {\n                 tcx.sess.span_err(\n                     path.span,\n                     \"type parameters are not allowed on this type\");\n             }\n         }\n \n         if (flags & NO_REGIONS) != 0u {\n-            if path.rp.is_some() {\n+            if path.segments.last().lifetime.is_some() {\n                 tcx.sess.span_err(\n                     path.span,\n                     \"region parameters are not allowed on this type\");"}, {"sha": "628ceccd61e7e70f39f22e2db1b2f694d9a24b74", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -128,7 +128,12 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                 Some((enm, var)) => {\n                     // Assign the pattern the type of the *enum*, not the variant.\n                     let enum_tpt = ty::lookup_item_type(tcx, enm);\n-                    instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n+                    instantiate_path(pcx.fcx,\n+                                     path,\n+                                     enum_tpt,\n+                                     v_def,\n+                                     pat.span,\n+                                     pat.id);\n \n                     // check that the type of the value being matched is a subtype\n                     // of the type of the pattern:\n@@ -185,7 +190,12 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n             } else {\n                 ctor_tpt\n             };\n-            instantiate_path(pcx.fcx, path, struct_tpt, pat.span, pat.id);\n+            instantiate_path(pcx.fcx,\n+                             path,\n+                             struct_tpt,\n+                             s_def,\n+                             pat.span,\n+                             pat.id);\n \n             // Check that the type of the value being matched is a subtype of\n             // the type of the pattern."}, {"sha": "c20ccafe82c4e6c3bc05f98dbe372232b5a2af0b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -102,7 +102,7 @@ use std::vec;\n use extra::list::Nil;\n use syntax::ast::{def_id, sty_value, sty_region, sty_box};\n use syntax::ast::{sty_uniq, sty_static, NodeId};\n-use syntax::ast::{m_const, m_mutbl, m_imm};\n+use syntax::ast::{m_mutbl, m_imm};\n use syntax::ast;\n use syntax::ast_map;\n \n@@ -350,6 +350,10 @@ impl<'self> LookupContext<'self> {\n         let opt_applicable_traits = trait_map.find(&self.expr.id);\n         for applicable_traits in opt_applicable_traits.iter() {\n             for trait_did in applicable_traits.iter() {\n+                ty::populate_implementations_for_trait_if_necessary(\n+                    self.tcx(),\n+                    *trait_did);\n+\n                 // Look for explicit implementations.\n                 let opt_impl_infos = self.tcx().trait_impls.find(trait_did);\n                 for impl_infos in opt_impl_infos.iter() {\n@@ -534,6 +538,10 @@ impl<'self> LookupContext<'self> {\n \n \n     fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n+        // Read the inherent implementation candidates for this type from the\n+        // metadata if necessary.\n+        ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n+\n         let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n         for impl_infos in opt_impl_infos.iter() {\n             for impl_info in impl_infos.iter() {\n@@ -700,7 +708,7 @@ impl<'self> LookupContext<'self> {\n             ty_evec(mt, vstore_fixed(_)) => {\n                 // First try to borrow to a slice\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVec, autoderefs, [m_const, m_imm, m_mutbl],\n+                    AutoBorrowVec, autoderefs, [m_imm, m_mutbl],\n                     |m,r| ty::mk_evec(tcx,\n                                       ty::mt {ty:mt.ty, mutbl:m},\n                                       vstore_slice(r)));\n@@ -709,7 +717,7 @@ impl<'self> LookupContext<'self> {\n \n                 // Then try to borrow to a slice *and* borrow a pointer.\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVecRef, autoderefs, [m_const, m_imm, m_mutbl],\n+                    AutoBorrowVecRef, autoderefs, [m_imm, m_mutbl],\n                     |m,r| {\n                         let slice_ty = ty::mk_evec(tcx,\n                                                    ty::mt {ty:mt.ty, mutbl:m},\n@@ -744,7 +752,7 @@ impl<'self> LookupContext<'self> {\n                 // Coerce ~/@/&Trait instances to &Trait.\n \n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowObj, autoderefs, [m_const, m_imm, m_mutbl],\n+                    AutoBorrowObj, autoderefs, [m_imm, m_mutbl],\n                     |trt_mut, reg| {\n                         ty::mk_trait(tcx, trt_did, trt_substs.clone(),\n                                      RegionTraitStore(reg), trt_mut, b)\n@@ -779,7 +787,7 @@ impl<'self> LookupContext<'self> {\n             ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_struct(*) | ty_tup(*) |\n             ty_estr(*) | ty_evec(*) | ty_trait(*) | ty_closure(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],\n+                    AutoPtr, autoderefs, [m_imm, m_mutbl],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n             }\n \n@@ -1270,18 +1278,10 @@ impl<'self> LookupContext<'self> {\n         }\n \n         fn mutability_matches(self_mutbl: ast::mutability,\n-                              candidate_mutbl: ast::mutability) -> bool {\n+                              candidate_mutbl: ast::mutability)\n+                              -> bool {\n             //! True if `self_mutbl <: candidate_mutbl`\n-\n-            match (self_mutbl, candidate_mutbl) {\n-                (_, m_const) => true,\n-                (m_mutbl, m_mutbl) => true,\n-                (m_imm, m_imm) => true,\n-                (m_mutbl, m_imm) => false,\n-                (m_imm, m_mutbl) => false,\n-                (m_const, m_imm) => false,\n-                (m_const, m_mutbl) => false,\n-            }\n+            self_mutbl == candidate_mutbl\n         }\n     }\n "}, {"sha": "706d6871f8639c69d54ec9309aab268fd4c17344", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 216, "deletions": 24, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -377,7 +377,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n                   if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n-                       self.tcx.sess.str_of(path.idents[0]),\n+                       self.tcx.sess.str_of(path.segments[0].identifier),\n                        self.fcx.infcx().ty_to_str(\n                            self.fcx.inh.locals.get_copy(&p.id)));\n               }\n@@ -1132,8 +1132,160 @@ pub enum DerefArgs {\n     DoDerefArgs\n }\n \n-pub fn break_here() {\n-    debug!(\"break here!\");\n+// Given the provenance of a static method, returns the generics of the static\n+// method's container.\n+fn generics_of_static_method_container(type_context: ty::ctxt,\n+                                       provenance: ast::MethodProvenance)\n+                                       -> ty::Generics {\n+    match provenance {\n+        ast::FromTrait(trait_def_id) => {\n+            ty::lookup_trait_def(type_context, trait_def_id).generics\n+        }\n+        ast::FromImpl(impl_def_id) => {\n+            ty::lookup_item_type(type_context, impl_def_id).generics\n+        }\n+    }\n+}\n+\n+// Verifies that type parameters supplied in paths are in the right\n+// locations.\n+fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n+                                          path: &ast::Path,\n+                                          def: ast::def) {\n+    // We only care about checking the case in which the path has two or\n+    // more segments.\n+    if path.segments.len() < 2 {\n+        return\n+    }\n+\n+    // Verify that no lifetimes or type parameters are present anywhere\n+    // except the final two elements of the path.\n+    for i in range(0, path.segments.len() - 2) {\n+        match path.segments[i].lifetime {\n+            None => {}\n+            Some(lifetime) => {\n+                function_context.tcx()\n+                                .sess\n+                                .span_err(lifetime.span,\n+                                          \"lifetime parameters may not \\\n+                                           appear here\")\n+            }\n+        }\n+\n+        for typ in path.segments[i].types.iter() {\n+            function_context.tcx()\n+                            .sess\n+                            .span_err(typ.span,\n+                                      \"type parameters may not appear here\")\n+        }\n+    }\n+\n+    // If there are no parameters at all, there is nothing more to do; the\n+    // rest of typechecking will (attempt to) infer everything.\n+    if path.segments\n+           .iter()\n+           .all(|s| s.lifetime.is_none() && s.types.is_empty()) {\n+        return\n+    }\n+\n+    match def {\n+        // If this is a static method of a trait or implementation, then\n+        // ensure that the segment of the path which names the trait or\n+        // implementation (the penultimate segment) is annotated with the\n+        // right number of type parameters.\n+        ast::def_static_method(_, provenance, _) => {\n+            let generics =\n+                generics_of_static_method_container(function_context.ccx.tcx,\n+                                                    provenance);\n+            let name = match provenance {\n+                ast::FromTrait(_) => \"trait\",\n+                ast::FromImpl(_) => \"impl\",\n+            };\n+\n+            let trait_segment = &path.segments[path.segments.len() - 2];\n+\n+            // Make sure lifetime parameterization agrees with the trait or\n+            // implementation type.\n+            match (generics.region_param, trait_segment.lifetime) {\n+                (Some(_), None) => {\n+                    function_context.tcx()\n+                                    .sess\n+                                    .span_err(path.span,\n+                                              fmt!(\"this %s has a lifetime \\\n+                                                    parameter but no \\\n+                                                    lifetime was specified\",\n+                                                   name))\n+                }\n+                (None, Some(_)) => {\n+                    function_context.tcx()\n+                                    .sess\n+                                    .span_err(path.span,\n+                                              fmt!(\"this %s has no lifetime \\\n+                                                    parameter but a lifetime \\\n+                                                    was specified\",\n+                                                   name))\n+                }\n+                (Some(_), Some(_)) | (None, None) => {}\n+            }\n+\n+            // Make sure the number of type parameters supplied on the trait\n+            // or implementation segment equals the number of type parameters\n+            // on the trait or implementation definition.\n+            let trait_type_parameter_count = generics.type_param_defs.len();\n+            let supplied_type_parameter_count = trait_segment.types.len();\n+            if trait_type_parameter_count != supplied_type_parameter_count {\n+                let trait_count_suffix = if trait_type_parameter_count == 1 {\n+                    \"\"\n+                } else {\n+                    \"s\"\n+                };\n+                let supplied_count_suffix =\n+                    if supplied_type_parameter_count == 1 {\n+                        \"\"\n+                    } else {\n+                        \"s\"\n+                    };\n+                function_context.tcx()\n+                                .sess\n+                                .span_err(path.span,\n+                                          fmt!(\"the %s referenced by this \\\n+                                                path has %u type \\\n+                                                parameter%s, but %u type \\\n+                                                parameter%s were supplied\",\n+                                               name,\n+                                               trait_type_parameter_count,\n+                                               trait_count_suffix,\n+                                               supplied_type_parameter_count,\n+                                               supplied_count_suffix))\n+            }\n+        }\n+        _ => {\n+            // Verify that no lifetimes or type parameters are present on\n+            // the penultimate segment of the path.\n+            let segment = &path.segments[path.segments.len() - 2];\n+            match segment.lifetime {\n+                None => {}\n+                Some(lifetime) => {\n+                    function_context.tcx()\n+                                    .sess\n+                                    .span_err(lifetime.span,\n+                                              \"lifetime parameters may not\n+                                               appear here\")\n+                }\n+            }\n+            for typ in segment.types.iter() {\n+                function_context.tcx()\n+                                .sess\n+                                .span_err(typ.span,\n+                                          \"type parameters may not appear \\\n+                                           here\");\n+                function_context.tcx()\n+                                .sess\n+                                .span_note(typ.span,\n+                                           fmt!(\"this is a %?\", def));\n+            }\n+        }\n+    }\n }\n \n /// Invariant:\n@@ -2333,8 +2485,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       ast::expr_path(ref pth) => {\n         let defn = lookup_def(fcx, pth.span, id);\n \n+        check_type_parameter_positions_in_path(fcx, pth, defn);\n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n-        instantiate_path(fcx, pth, tpt, expr.span, expr.id);\n+        instantiate_path(fcx, pth, tpt, defn, expr.span, expr.id);\n       }\n       ast::expr_self => {\n         let definition = lookup_def(fcx, expr.span, id);\n@@ -3141,12 +3294,16 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n pub fn instantiate_path(fcx: @mut FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n+                        def: ast::def,\n                         span: span,\n                         node_id: ast::NodeId) {\n     debug!(\">>> instantiate_path\");\n \n     let ty_param_count = tpt.generics.type_param_defs.len();\n-    let ty_substs_len = pth.types.len();\n+    let mut ty_substs_len = 0;\n+    for segment in pth.segments.iter() {\n+        ty_substs_len += segment.types.len()\n+    }\n \n     debug!(\"tpt=%s ty_param_count=%? ty_substs_len=%?\",\n            tpt.repr(fcx.tcx()),\n@@ -3155,7 +3312,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n \n     // determine the region bound, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n-    let regions = match pth.rp {\n+    let regions = match pth.segments.last().lifetime {\n         Some(_) => { // user supplied a lifetime parameter...\n             match tpt.generics.region_param {\n                 None => { // ...but the type is not lifetime parameterized!\n@@ -3165,7 +3322,10 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                 }\n                 Some(_) => { // ...and the type is lifetime parameterized, ok.\n                     opt_vec::with(\n-                        ast_region_to_region(fcx, fcx, span, &pth.rp))\n+                        ast_region_to_region(fcx,\n+                                             fcx,\n+                                             span,\n+                                             &pth.segments.last().lifetime))\n                 }\n             }\n         }\n@@ -3174,6 +3334,21 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         }\n     };\n \n+    // Special case: If there is a self parameter, omit it from the list of\n+    // type parameters.\n+    //\n+    // Here we calculate the \"user type parameter count\", which is the number\n+    // of type parameters actually manifest in the AST. This will differ from\n+    // the internal type parameter count when there are self types involved.\n+    let (user_type_parameter_count, self_parameter_index) = match def {\n+        ast::def_static_method(_, provenance @ ast::FromTrait(_), _) => {\n+            let generics = generics_of_static_method_container(fcx.ccx.tcx,\n+                                                               provenance);\n+            (ty_param_count - 1, Some(generics.type_param_defs.len()))\n+        }\n+        _ => (ty_param_count, None),\n+    };\n+\n     // determine values for type parameters, using the values given by\n     // the user (if any) and otherwise using fresh type variables\n     let tps = if ty_substs_len == 0 {\n@@ -3182,34 +3357,51 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         fcx.ccx.tcx.sess.span_err\n             (span, \"this item does not take type parameters\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n-    } else if ty_substs_len > ty_param_count {\n+    } else if ty_substs_len > user_type_parameter_count {\n         fcx.ccx.tcx.sess.span_err\n             (span,\n              fmt!(\"too many type parameters provided: expected %u, found %u\",\n-                  ty_param_count, ty_substs_len));\n+                  user_type_parameter_count, ty_substs_len));\n         fcx.infcx().next_ty_vars(ty_param_count)\n-    } else if ty_substs_len < ty_param_count {\n-        let is_static_method = match fcx.ccx.tcx.def_map.find(&node_id) {\n-            Some(&ast::def_static_method(*)) => true,\n-            _ => false\n-        };\n+    } else if ty_substs_len < user_type_parameter_count {\n         fcx.ccx.tcx.sess.span_err\n             (span,\n              fmt!(\"not enough type parameters provided: expected %u, found %u\",\n-                  ty_param_count, ty_substs_len));\n-        if is_static_method {\n-            fcx.ccx.tcx.sess.span_note\n-                (span, \"Static methods have an extra implicit type parameter -- \\\n-                 did you omit the type parameter for the `Self` type?\");\n-        }\n+                  user_type_parameter_count, ty_substs_len));\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n-        pth.types.map(|aty| fcx.to_ty(aty))\n+        // Build up the list of type parameters, inserting the self parameter\n+        // at the appropriate position.\n+        let mut result = ~[];\n+        let mut pushed = false;\n+        for (i, ast_type) in pth.segments\n+                                .iter()\n+                                .flat_map(|segment| segment.types.iter())\n+                                .enumerate() {\n+            match self_parameter_index {\n+                Some(index) if index == i => {\n+                    result.push(fcx.infcx().next_ty_vars(1)[0]);\n+                    pushed = true;\n+                }\n+                _ => {}\n+            }\n+            result.push(fcx.to_ty(ast_type))\n+        }\n+\n+        // If the self parameter goes at the end, insert it there.\n+        if !pushed && self_parameter_index.is_some() {\n+            result.push(fcx.infcx().next_ty_vars(1)[0])\n+        }\n+\n+        assert_eq!(result.len(), ty_param_count)\n+        result\n     };\n \n-    let substs = substs {regions: ty::NonerasedRegions(regions),\n-                         self_ty: None,\n-                         tps: tps };\n+    let substs = substs {\n+        regions: ty::NonerasedRegions(regions),\n+        self_ty: None,\n+        tps: tps\n+    };\n     fcx.write_ty_substs(node_id, tpt.ty, substs);\n \n     debug!(\"<<<\");"}, {"sha": "670553f569a1105f3e5926db77d618e17da35a00", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -136,6 +136,9 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n         // ...and here trait_ref is each bound that was declared on A,\n         // expressed in terms of the type parameters.\n \n+        ty::populate_implementations_for_trait_if_necessary(tcx,\n+                                                            trait_ref.def_id);\n+\n         // Substitute the values of the type parameters that may\n         // appear in the bound.\n         let trait_ref = substs.map_default(trait_ref, |substs| {\n@@ -321,6 +324,10 @@ fn search_for_vtable(vcx: &VtableContext,\n     let mut found = ~[];\n     let mut impls_seen = HashSet::new();\n \n+    // Load the implementations from external metadata if necessary.\n+    ty::populate_implementations_for_trait_if_necessary(tcx,\n+                                                        trait_ref.def_id);\n+\n     // XXX: this is a bad way to do this, since we do\n     // pointless allocations.\n     let impls = tcx.trait_impls.find(&trait_ref.def_id)"}, {"sha": "2aa4e28f1a4de4fcfde84e772334793b2436708c", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 13, "deletions": 66, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -15,12 +15,11 @@\n // each trait in the system to its implementations.\n \n \n-use metadata::csearch::{each_path, get_impl_trait};\n+use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use metadata::cstore::iter_crate_data;\n-use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::ty::get;\n-use middle::ty::{lookup_item_type, subst};\n+use middle::ty::{ImplContainer, lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n@@ -43,13 +42,12 @@ use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, local_def};\n-use syntax::codemap::{span, dummy_sp};\n+use syntax::codemap::span;\n use syntax::opt_vec;\n use syntax::visit;\n use syntax::parse;\n-use util::ppaux::ty_to_str;\n \n-use std::hashmap::{HashMap, HashSet};\n+use std::hashmap::HashSet;\n use std::result::Ok;\n use std::vec;\n \n@@ -150,19 +148,12 @@ pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n-\n-        base_type_def_ids: @mut HashMap::new(),\n     }\n }\n \n pub struct CoherenceChecker {\n     crate_context: @mut CrateCtxt,\n     inference_context: @mut InferCtxt,\n-\n-    // A mapping from implementations to the corresponding base type\n-    // definition ID.\n-\n-    base_type_def_ids: @mut HashMap<def_id,def_id>,\n }\n \n struct CoherenceCheckVisitor { cc: CoherenceChecker }\n@@ -321,9 +312,6 @@ impl CoherenceChecker {\n                 if associated_traits.len() == 0 {\n                     self.add_inherent_impl(base_type_def_id, implementation);\n                 }\n-\n-                self.base_type_def_ids.insert(local_def(item.id),\n-                                              base_type_def_id);\n             }\n         }\n \n@@ -680,35 +668,18 @@ impl CoherenceChecker {\n         let tcx = self.crate_context.tcx;\n         let implementation = @csearch::get_impl(tcx, impl_def_id);\n \n-        debug!(\"coherence: adding impl from external crate: %s\",\n-               ty::item_path_str(tcx, implementation.did));\n-\n         // Make sure we don't visit the same implementation multiple times.\n         if !impls_seen.insert(implementation.did) {\n             // Skip this one.\n             return\n         }\n         // Good. Continue.\n \n-        let self_type = lookup_item_type(tcx, implementation.did);\n-        let associated_traits = get_impl_trait(tcx,\n-                                               implementation.did);\n+        let _ = lookup_item_type(tcx, implementation.did);\n+        let associated_traits = get_impl_trait(tcx, implementation.did);\n \n-        // Do a sanity check to make sure that inherent methods have base\n-        // types.\n-        if associated_traits.is_none() {\n-            match get_base_type_def_id(self.inference_context,\n-                                       dummy_sp(),\n-                                       self_type.ty) {\n-                None => {\n-                    tcx.sess.bug(fmt!(\"no base type for external impl with no \\\n-                                      trait: %s (type %s)!\",\n-                                     tcx.sess.str_of(implementation.ident),\n-                                     ty_to_str(tcx, self_type.ty)));\n-                }\n-                Some(_) => {} // Nothing to do.\n-            }\n-        }\n+        // Do a sanity check.\n+        assert!(associated_traits.is_some());\n \n         // Record all the trait methods.\n         for trait_ref in associated_traits.iter() {\n@@ -723,25 +694,6 @@ impl CoherenceChecker {\n             }\n         }\n \n-        // Add the implementation to the mapping from implementation to base\n-        // type def ID, if there is a base type for this implementation.\n-        match get_base_type_def_id(self.inference_context,\n-                                   dummy_sp(),\n-                                   self_type.ty) {\n-            None => {} // Nothing to do.\n-            Some(base_type_def_id) => {\n-                // inherent methods apply to `impl Type` but not\n-                // `impl Trait for Type`:\n-                if associated_traits.is_none() {\n-                    self.add_inherent_impl(base_type_def_id,\n-                                           implementation);\n-                }\n-\n-                self.base_type_def_ids.insert(implementation.did,\n-                                              base_type_def_id);\n-            }\n-        }\n-\n         tcx.impls.insert(implementation.did, implementation);\n     }\n \n@@ -752,15 +704,10 @@ impl CoherenceChecker {\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            do each_path(crate_store, crate_number) |_, def_like, _| {\n-                match def_like {\n-                    dl_impl(def_id) => {\n-                        self.add_external_impl(&mut impls_seen, def_id)\n-                    }\n-                    dl_def(_) | dl_field => (),   // Skip this.\n-                }\n-                true\n-            };\n+            do each_impl(crate_store, crate_number) |def_id| {\n+                assert_eq!(crate_number, def_id.crate);\n+                self.add_external_impl(&mut impls_seen, def_id)\n+            }\n         }\n     }\n \n@@ -892,7 +839,7 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n         method.explicit_self,\n         method.vis,\n         new_def_id,\n-        impl_id,\n+        ImplContainer(impl_id),\n         provided_source\n     )\n }"}, {"sha": "63317d4ca5c91bb04915e3cd9e734475684ea767", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -32,7 +32,8 @@ are represented as `ty_param()` instances.\n \n \n use metadata::csearch;\n-use middle::ty::{substs, ty_param_bounds_and_ty};\n+use middle::ty::{ImplContainer, MethodContainer, TraitContainer, substs};\n+use middle::ty::{ty_param_bounds_and_ty};\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n@@ -388,7 +389,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n             // assume public, because this is only invoked on trait methods\n             ast::public,\n             local_def(*m_id),\n-            local_def(trait_id),\n+            TraitContainer(local_def(trait_id)),\n             None\n         )\n     }\n@@ -744,7 +745,7 @@ pub struct ConvertedMethod {\n }\n \n pub fn convert_methods(ccx: &CrateCtxt,\n-                       container_id: ast::NodeId,\n+                       container: MethodContainer,\n                        ms: &[@ast::method],\n                        untransformed_rcvr_ty: ty::t,\n                        rcvr_ty_generics: &ty::Generics,\n@@ -758,11 +759,14 @@ pub fn convert_methods(ccx: &CrateCtxt,\n         let m_ty_generics =\n             ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics,\n                         num_rcvr_ty_params);\n-        let mty =\n-            @ty_of_method(ccx, container_id, *m, rcvr_ty_generics.region_param,\n-                          untransformed_rcvr_ty,\n-                          rcvr_ast_generics, rcvr_visibility,\n-                          &m.generics);\n+        let mty = @ty_of_method(ccx,\n+                                container,\n+                                *m,\n+                                rcvr_ty_generics.region_param,\n+                                untransformed_rcvr_ty,\n+                                rcvr_ast_generics,\n+                                rcvr_visibility,\n+                                &m.generics);\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         tcx.tcache.insert(\n             local_def(m.id),\n@@ -785,7 +789,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n     }).collect();\n \n     fn ty_of_method(ccx: &CrateCtxt,\n-                    container_id: ast::NodeId,\n+                    container: MethodContainer,\n                     m: &ast::method,\n                     rp: Option<ty::region_variance>,\n                     untransformed_rcvr_ty: ty::t,\n@@ -817,7 +821,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n             m.explicit_self.node,\n             method_vis,\n             local_def(m.id),\n-            local_def(container_id),\n+            container,\n             None\n         )\n     }\n@@ -877,8 +881,12 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n             it.vis\n         };\n \n-        let cms = convert_methods(ccx, it.id, *ms, selfty,\n-                                  &i_ty_generics, generics,\n+        let cms = convert_methods(ccx,\n+                                  ImplContainer(local_def(it.id)),\n+                                  *ms,\n+                                  selfty,\n+                                  &i_ty_generics,\n+                                  generics,\n                                   parent_visibility);\n         for t in opt_trait_ref.iter() {\n             // Prevent the builtin kind traits from being manually implemented.\n@@ -901,9 +909,12 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n           let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n           let (ty_generics, _) = mk_item_substs(ccx, generics, rp,\n                                                 Some(untransformed_rcvr_ty));\n-          let _ = convert_methods(ccx, it.id, provided_methods,\n+          let _ = convert_methods(ccx,\n+                                  TraitContainer(local_def(it.id)),\n+                                  provided_methods,\n                                   untransformed_rcvr_ty,\n-                                  &ty_generics, generics,\n+                                  &ty_generics,\n+                                  generics,\n                                   it.vis);\n \n           // We need to do this *after* converting methods, since"}, {"sha": "86c0736090c937e1a36a88b5cf00fd2517c276c8", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -21,7 +21,7 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::isr_alist;\n-use syntax::ast::{Many, Once, extern_fn, impure_fn, m_const, m_imm, m_mutbl};\n+use syntax::ast::{Many, Once, extern_fn, impure_fn, m_imm, m_mutbl};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n use util::common::{indenter};\n@@ -52,16 +52,6 @@ impl Combine for Glb {\n         match (a.mutbl, b.mutbl) {\n           // If one side or both is mut, then the GLB must use\n           // the precise type from the mut side.\n-          (m_mutbl, m_const) => {\n-            Sub(**self).tys(a.ty, b.ty).chain(|_t| {\n-                Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n-            })\n-          }\n-          (m_const, m_mutbl) => {\n-            Sub(**self).tys(b.ty, a.ty).chain(|_t| {\n-                Ok(ty::mt {ty: b.ty, mutbl: m_mutbl})\n-            })\n-          }\n           (m_mutbl, m_mutbl) => {\n             eq_tys(self, a.ty, b.ty).then(|| {\n                 Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n@@ -70,22 +60,12 @@ impl Combine for Glb {\n \n           // If one side or both is immutable, we can use the GLB of\n           // both sides but mutbl must be `m_imm`.\n-          (m_imm, m_const) |\n-          (m_const, m_imm) |\n           (m_imm, m_imm) => {\n             self.tys(a.ty, b.ty).chain(|t| {\n                 Ok(ty::mt {ty: t, mutbl: m_imm})\n             })\n           }\n \n-          // If both sides are const, then we can use GLB of both\n-          // sides and mutbl of only `m_const`.\n-          (m_const, m_const) => {\n-            self.tys(a.ty, b.ty).chain(|t| {\n-                Ok(ty::mt {ty: t, mutbl: m_const})\n-            })\n-          }\n-\n           // There is no mutual subtype of these combinations.\n           (m_mutbl, m_imm) |\n           (m_imm, m_mutbl) => {"}, {"sha": "50bddaacc3fc98a95b47c83e15baeb0d42e777bb", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -24,7 +24,7 @@ use middle::typeck::isr_alist;\n use util::ppaux::mt_to_str;\n \n use extra::list;\n-use syntax::ast::{Many, Once, extern_fn, m_const, impure_fn};\n+use syntax::ast::{Many, Once, extern_fn, impure_fn};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n \n@@ -55,14 +55,13 @@ impl Combine for Lub {\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n \n-        let m = if a.mutbl == b.mutbl {\n-            a.mutbl\n-        } else {\n-            m_const\n-        };\n+        if a.mutbl != b.mutbl {\n+            return Err(ty::terr_mutability)\n+        }\n \n+        let m = a.mutbl;\n         match m {\n-          m_imm | m_const => {\n+          m_imm => {\n             self.tys(a.ty, b.ty).chain(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n           }\n \n@@ -71,11 +70,7 @@ impl Combine for Lub {\n                 eq_tys(self, a.ty, b.ty).then(|| {\n                     Ok(ty::mt {ty: a.ty, mutbl: m})\n                 })\n-            }).chain_err(|_e| {\n-                self.tys(a.ty, b.ty).chain(|t| {\n-                    Ok(ty::mt {ty: t, mutbl: m_const})\n-                })\n-            })\n+            }).chain_err(|e| Err(e))\n           }\n         }\n     }"}, {"sha": "a00f018ceab0fdf650e5c93c3525b29060cad261", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -26,7 +26,7 @@ use util::ppaux::bound_region_to_str;\n \n use extra::list::Nil;\n use extra::list;\n-use syntax::ast::{Onceness, m_const, purity};\n+use syntax::ast::{Onceness, purity};\n \n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n \n@@ -67,7 +67,7 @@ impl Combine for Sub {\n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         debug!(\"mts(%s <: %s)\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n-        if a.mutbl != b.mutbl && b.mutbl != m_const {\n+        if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n         }\n \n@@ -77,7 +77,7 @@ impl Combine for Sub {\n             // (i.e., invariant if mut):\n             eq_tys(self, a.ty, b.ty).then(|| Ok(*a))\n           }\n-          m_imm | m_const => {\n+          m_imm => {\n             // Otherwise we can be covariant:\n             self.tys(a.ty, b.ty).chain(|_t| Ok(*a) )\n           }"}, {"sha": "3549323cf085f91d3840633333ab7be3f33c3786", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -239,7 +239,6 @@ fn mutability_to_str(m: ast::mutability) -> ~str {\n     match m {\n         ast::m_mutbl => ~\"mut \",\n         ast::m_imm => ~\"\",\n-        ast::m_const => ~\"const \"\n     }\n }\n "}, {"sha": "c192803efffa94576f51e3805f6341f106db8bf2", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -276,7 +276,7 @@ pub mod raw {\n             use rt::local::Local;\n             use rt::task::Task;\n \n-            do Local::borrow::<Task, *()> |task| {\n+            do Local::borrow |task: &mut Task| {\n                 task.heap.realloc(ptr as *libc::c_void, size) as *()\n             }\n         }"}, {"sha": "a4e18d98f47ea6c90209ef76183942a09f700bca", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -10,6 +10,7 @@\n \n //! Unsafe casting functions\n \n+use ptr::RawPtr;\n use sys;\n use unstable::intrinsics;\n \n@@ -94,13 +95,13 @@ pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T {\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n-pub unsafe fn transmute_mut_unsafe<T>(ptr: *const T) -> *mut T {\n+pub unsafe fn transmute_mut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *mut T {\n     transmute(ptr)\n }\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n-pub unsafe fn transmute_immut_unsafe<T>(ptr: *const T) -> *T {\n+pub unsafe fn transmute_immut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *T {\n     transmute(ptr)\n }\n "}, {"sha": "a1459b780dfb3cd204d4d47bc8f1d04eb2da374e", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -100,7 +100,7 @@ fn test_basic() {\n #[test]\n #[should_fail]\n fn test_take_empty() {\n-    let value_cell = Cell::new_empty::<~int>();\n+    let value_cell: Cell<~int> = Cell::new_empty();\n     value_cell.take();\n }\n "}, {"sha": "6b982ec75da126255f7bc8545bfad0920f969b8c", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -11,7 +11,7 @@\n #[doc(hidden)];\n \n use libc::c_void;\n-use ptr::{mut_null};\n+use ptr::null;\n use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n@@ -37,7 +37,7 @@ unsafe fn each_live_alloc(read_next_before: bool,\n     use rt::local_heap;\n \n     let mut box = local_heap::live_allocs();\n-    while box != mut_null() {\n+    while box != null() {\n         let next_before = (*box).next;\n         let uniq = (*box).ref_count == managed::RC_MANAGED_UNIQUE;\n "}, {"sha": "cdce69f7cd760a05a9c684b6621607a81aef3845", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -884,10 +884,17 @@ impl<T> Poly for T {\n     }\n }\n \n-// n.b. use 'const' to get an implementation for both '*mut' and '*' at the same\n-//      time.\n-impl<T> Pointer for *const T {\n-    fn fmt(t: &*const T, f: &mut Formatter) {\n+impl<T> Pointer for *T {\n+    fn fmt(t: &*T, f: &mut Formatter) {\n+        f.flags |= 1 << (parse::FlagAlternate as uint);\n+        do ::uint::to_str_bytes(*t as uint, 16) |buf| {\n+            f.pad_integral(buf, \"0x\", true);\n+        }\n+    }\n+}\n+\n+impl<T> Pointer for *mut T {\n+    fn fmt(t: &*mut T, f: &mut Formatter) {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n         do ::uint::to_str_bytes(*t as uint, 16) |buf| {\n             f.pad_integral(buf, \"0x\", true);\n@@ -923,8 +930,12 @@ delegate!(float to Float)\n delegate!(f32 to Float)\n delegate!(f64 to Float)\n \n-impl<T> Default for *const T {\n-    fn fmt(me: &*const T, f: &mut Formatter) { Pointer::fmt(me, f) }\n+impl<T> Default for *T {\n+    fn fmt(me: &*T, f: &mut Formatter) { Pointer::fmt(me, f) }\n+}\n+\n+impl<T> Default for *mut T {\n+    fn fmt(me: &*mut T, f: &mut Formatter) { Pointer::fmt(me, f) }\n }\n \n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,"}, {"sha": "bcd658ece66532a52401a041b78537c404de14b8", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -869,21 +869,21 @@ mod test_map {\n \n     #[test]\n     fn test_find_or_insert() {\n-        let mut m = HashMap::new::<int, int>();\n+        let mut m: HashMap<int,int> = HashMap::new();\n         assert_eq!(*m.find_or_insert(1, 2), 2);\n         assert_eq!(*m.find_or_insert(1, 3), 2);\n     }\n \n     #[test]\n     fn test_find_or_insert_with() {\n-        let mut m = HashMap::new::<int, int>();\n+        let mut m: HashMap<int,int> = HashMap::new();\n         assert_eq!(*m.find_or_insert_with(1, |_| 2), 2);\n         assert_eq!(*m.find_or_insert_with(1, |_| 3), 2);\n     }\n \n     #[test]\n     fn test_insert_or_update_with() {\n-        let mut m = HashMap::new::<int, int>();\n+        let mut m: HashMap<int,int> = HashMap::new();\n         assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 2);\n         assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 3);\n     }"}, {"sha": "4af7b3e242596476ec131209c13d1cdc6540a5f4", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -660,7 +660,10 @@ pub trait AdditiveIterator<A> {\n \n impl<A: Add<A, A> + Zero, T: Iterator<A>> AdditiveIterator<A> for T {\n     #[inline]\n-    fn sum(&mut self) -> A { self.fold(Zero::zero::<A>(), |s, x| s + x) }\n+    fn sum(&mut self) -> A {\n+        let zero: A = Zero::zero();\n+        self.fold(zero, |s, x| s + x)\n+    }\n }\n \n /// A trait for iterators over elements whose elements can be multiplied\n@@ -685,7 +688,10 @@ pub trait MultiplicativeIterator<A> {\n \n impl<A: Mul<A, A> + One, T: Iterator<A>> MultiplicativeIterator<A> for T {\n     #[inline]\n-    fn product(&mut self) -> A { self.fold(One::one::<A>(), |p, x| p * x) }\n+    fn product(&mut self) -> A {\n+        let one: A = One::one();\n+        self.fold(one, |p, x| p * x)\n+    }\n }\n \n /// A trait for iterators over elements which can be compared to one another."}, {"sha": "215067ea729197c99e71c7e56609bc3a7304d277", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -59,7 +59,8 @@ fn newsched_log_str(msg: ~str) {\n     use rt::local::Local;\n \n     unsafe {\n-        match Local::try_unsafe_borrow::<Task>() {\n+        let optional_task: Option<*mut Task> = Local::try_unsafe_borrow();\n+        match optional_task {\n             Some(local) => {\n                 // Use the available logger\n                 (*local).logger.log(Left(msg));"}, {"sha": "1c59eaf021969ea446b182f3723e5b8200409442", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 117, "deletions": 62, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -182,7 +182,7 @@ impl ApproxEq<f32> for f32 {\n \n     #[inline]\n     fn approx_eq(&self, other: &f32) -> bool {\n-        self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f32, f32>())\n+        self.approx_eq_eps(other, &1.0e-6)\n     }\n \n     #[inline]\n@@ -561,11 +561,14 @@ impl Real for f32 {\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n+    fn to_degrees(&self) -> f32 { *self * (180.0f32 / Real::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n-    fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n+    fn to_radians(&self) -> f32 {\n+        let value: f32 = Real::pi();\n+        *self * (value / 180.0f32)\n+    }\n }\n \n impl Bounded for f32 {\n@@ -578,10 +581,10 @@ impl Bounded for f32 {\n \n impl Primitive for f32 {\n     #[inline]\n-    fn bits() -> uint { 32 }\n+    fn bits(_: Option<f32>) -> uint { 32 }\n \n     #[inline]\n-    fn bytes() -> uint { Primitive::bits::<f32>() / 8 }\n+    fn bytes(_: Option<f32>) -> uint { Primitive::bits(Some(0f32)) / 8 }\n }\n \n impl Float for f32 {\n@@ -638,25 +641,25 @@ impl Float for f32 {\n     }\n \n     #[inline]\n-    fn mantissa_digits() -> uint { 24 }\n+    fn mantissa_digits(_: Option<f32>) -> uint { 24 }\n \n     #[inline]\n-    fn digits() -> uint { 6 }\n+    fn digits(_: Option<f32>) -> uint { 6 }\n \n     #[inline]\n     fn epsilon() -> f32 { 1.19209290e-07 }\n \n     #[inline]\n-    fn min_exp() -> int { -125 }\n+    fn min_exp(_: Option<f32>) -> int { -125 }\n \n     #[inline]\n-    fn max_exp() -> int { 128 }\n+    fn max_exp(_: Option<f32>) -> int { 128 }\n \n     #[inline]\n-    fn min_10_exp() -> int { -37 }\n+    fn min_10_exp(_: Option<f32>) -> int { -37 }\n \n     #[inline]\n-    fn max_10_exp() -> int { 38 }\n+    fn max_10_exp(_: Option<f32>) -> int { 38 }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n@@ -949,9 +952,11 @@ mod tests {\n         assert_eq!(1f32.clamp(&2f32, &4f32), 2f32);\n         assert_eq!(8f32.clamp(&2f32, &4f32), 4f32);\n         assert_eq!(3f32.clamp(&2f32, &4f32), 3f32);\n-        assert!(3f32.clamp(&Float::NaN::<f32>(), &4f32).is_NaN());\n-        assert!(3f32.clamp(&2f32, &Float::NaN::<f32>()).is_NaN());\n-        assert!(Float::NaN::<f32>().clamp(&2f32, &4f32).is_NaN());\n+\n+        let nan: f32 = Float::NaN();\n+        assert!(3f32.clamp(&nan, &4f32).is_NaN());\n+        assert!(3f32.clamp(&2f32, &nan).is_NaN());\n+        assert!(nan.clamp(&2f32, &4f32).is_NaN());\n     }\n \n     #[test]\n@@ -1028,9 +1033,13 @@ mod tests {\n     fn test_asinh() {\n         assert_eq!(0.0f32.asinh(), 0.0f32);\n         assert_eq!((-0.0f32).asinh(), -0.0f32);\n-        assert_eq!(Float::infinity::<f32>().asinh(), Float::infinity::<f32>());\n-        assert_eq!(Float::neg_infinity::<f32>().asinh(), Float::neg_infinity::<f32>());\n-        assert!(Float::NaN::<f32>().asinh().is_NaN());\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::NaN();\n+        assert_eq!(inf.asinh(), inf);\n+        assert_eq!(neg_inf.asinh(), neg_inf);\n+        assert!(nan.asinh().is_NaN());\n         assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n         assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n     }\n@@ -1039,9 +1048,13 @@ mod tests {\n     fn test_acosh() {\n         assert_eq!(1.0f32.acosh(), 0.0f32);\n         assert!(0.999f32.acosh().is_NaN());\n-        assert_eq!(Float::infinity::<f32>().acosh(), Float::infinity::<f32>());\n-        assert!(Float::neg_infinity::<f32>().acosh().is_NaN());\n-        assert!(Float::NaN::<f32>().acosh().is_NaN());\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::NaN();\n+        assert_eq!(inf.acosh(), inf);\n+        assert!(neg_inf.acosh().is_NaN());\n+        assert!(nan.acosh().is_NaN());\n         assert_approx_eq!(2.0f32.acosh(), 1.31695789692481670862504634730796844f32);\n         assert_approx_eq!(3.0f32.acosh(), 1.76274717403908605046521864995958461f32);\n     }\n@@ -1050,34 +1063,61 @@ mod tests {\n     fn test_atanh() {\n         assert_eq!(0.0f32.atanh(), 0.0f32);\n         assert_eq!((-0.0f32).atanh(), -0.0f32);\n-        assert_eq!(1.0f32.atanh(), Float::infinity::<f32>());\n-        assert_eq!((-1.0f32).atanh(), Float::neg_infinity::<f32>());\n+\n+        let inf32: f32 = Float::infinity();\n+        let neg_inf32: f32 = Float::neg_infinity();\n+        assert_eq!(1.0f32.atanh(), inf32);\n+        assert_eq!((-1.0f32).atanh(), neg_inf32);\n+\n         assert!(2f64.atanh().atanh().is_NaN());\n         assert!((-2f64).atanh().atanh().is_NaN());\n-        assert!(Float::infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::neg_infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::NaN::<f32>().atanh().is_NaN());\n+\n+        let inf64: f32 = Float::infinity();\n+        let neg_inf64: f32 = Float::neg_infinity();\n+        let nan32: f32 = Float::NaN();\n+        assert!(inf64.atanh().is_NaN());\n+        assert!(neg_inf64.atanh().is_NaN());\n+        assert!(nan32.atanh().is_NaN());\n+\n         assert_approx_eq!(0.5f32.atanh(), 0.54930614433405484569762261846126285f32);\n         assert_approx_eq!((-0.5f32).atanh(), -0.54930614433405484569762261846126285f32);\n     }\n \n     #[test]\n     fn test_real_consts() {\n-        assert_approx_eq!(Real::two_pi::<f32>(), 2f32 * Real::pi::<f32>());\n-        assert_approx_eq!(Real::frac_pi_2::<f32>(), Real::pi::<f32>() / 2f32);\n-        assert_approx_eq!(Real::frac_pi_3::<f32>(), Real::pi::<f32>() / 3f32);\n-        assert_approx_eq!(Real::frac_pi_4::<f32>(), Real::pi::<f32>() / 4f32);\n-        assert_approx_eq!(Real::frac_pi_6::<f32>(), Real::pi::<f32>() / 6f32);\n-        assert_approx_eq!(Real::frac_pi_8::<f32>(), Real::pi::<f32>() / 8f32);\n-        assert_approx_eq!(Real::frac_1_pi::<f32>(), 1f32 / Real::pi::<f32>());\n-        assert_approx_eq!(Real::frac_2_pi::<f32>(), 2f32 / Real::pi::<f32>());\n-        assert_approx_eq!(Real::frac_2_sqrtpi::<f32>(), 2f32 / Real::pi::<f32>().sqrt());\n-        assert_approx_eq!(Real::sqrt2::<f32>(), 2f32.sqrt());\n-        assert_approx_eq!(Real::frac_1_sqrt2::<f32>(), 1f32 / 2f32.sqrt());\n-        assert_approx_eq!(Real::log2_e::<f32>(), Real::e::<f32>().log2());\n-        assert_approx_eq!(Real::log10_e::<f32>(), Real::e::<f32>().log10());\n-        assert_approx_eq!(Real::ln_2::<f32>(), 2f32.ln());\n-        assert_approx_eq!(Real::ln_10::<f32>(), 10f32.ln());\n+        let pi: f32 = Real::pi();\n+        let two_pi: f32 = Real::two_pi();\n+        let frac_pi_2: f32 = Real::frac_pi_2();\n+        let frac_pi_3: f32 = Real::frac_pi_3();\n+        let frac_pi_4: f32 = Real::frac_pi_4();\n+        let frac_pi_6: f32 = Real::frac_pi_6();\n+        let frac_pi_8: f32 = Real::frac_pi_8();\n+        let frac_1_pi: f32 = Real::frac_1_pi();\n+        let frac_2_pi: f32 = Real::frac_2_pi();\n+        let frac_2_sqrtpi: f32 = Real::frac_2_sqrtpi();\n+        let sqrt2: f32 = Real::sqrt2();\n+        let frac_1_sqrt2: f32 = Real::frac_1_sqrt2();\n+        let e: f32 = Real::e();\n+        let log2_e: f32 = Real::log2_e();\n+        let log10_e: f32 = Real::log10_e();\n+        let ln_2: f32 = Real::ln_2();\n+        let ln_10: f32 = Real::ln_10();\n+\n+        assert_approx_eq!(two_pi, 2f32 * pi);\n+        assert_approx_eq!(frac_pi_2, pi / 2f32);\n+        assert_approx_eq!(frac_pi_3, pi / 3f32);\n+        assert_approx_eq!(frac_pi_4, pi / 4f32);\n+        assert_approx_eq!(frac_pi_6, pi / 6f32);\n+        assert_approx_eq!(frac_pi_8, pi / 8f32);\n+        assert_approx_eq!(frac_1_pi, 1f32 / pi);\n+        assert_approx_eq!(frac_2_pi, 2f32 / pi);\n+        assert_approx_eq!(frac_2_sqrtpi, 2f32 / pi.sqrt());\n+        assert_approx_eq!(sqrt2, 2f32.sqrt());\n+        assert_approx_eq!(frac_1_sqrt2, 1f32 / 2f32.sqrt());\n+        assert_approx_eq!(log2_e, e.log2());\n+        assert_approx_eq!(log10_e, e.log10());\n+        assert_approx_eq!(ln_2, 2f32.ln());\n+        assert_approx_eq!(ln_10, 10f32.ln());\n     }\n \n     #[test]\n@@ -1153,29 +1193,40 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<f32>(), sys::size_of::<f32>() * 8);\n-        assert_eq!(Primitive::bytes::<f32>(), sys::size_of::<f32>());\n+        let none: Option<f32> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<f32>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<f32>());\n     }\n \n     #[test]\n     fn test_is_normal() {\n-        assert!(!Float::NaN::<f32>().is_normal());\n-        assert!(!Float::infinity::<f32>().is_normal());\n-        assert!(!Float::neg_infinity::<f32>().is_normal());\n-        assert!(!Zero::zero::<f32>().is_normal());\n-        assert!(!Float::neg_zero::<f32>().is_normal());\n+        let nan: f32 = Float::NaN();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let zero: f32 = Zero::zero();\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n         assert!(1f32.is_normal());\n         assert!(1e-37f32.is_normal());\n         assert!(!1e-38f32.is_normal());\n     }\n \n     #[test]\n     fn test_classify() {\n-        assert_eq!(Float::NaN::<f32>().classify(), FPNaN);\n-        assert_eq!(Float::infinity::<f32>().classify(), FPInfinite);\n-        assert_eq!(Float::neg_infinity::<f32>().classify(), FPInfinite);\n-        assert_eq!(Zero::zero::<f32>().classify(), FPZero);\n-        assert_eq!(Float::neg_zero::<f32>().classify(), FPZero);\n+        let nan: f32 = Float::NaN();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let zero: f32 = Zero::zero();\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert_eq!(nan.classify(), FPNaN);\n+        assert_eq!(inf.classify(), FPInfinite);\n+        assert_eq!(neg_inf.classify(), FPInfinite);\n+        assert_eq!(zero.classify(), FPZero);\n+        assert_eq!(neg_zero.classify(), FPZero);\n         assert_eq!(1f32.classify(), FPNormal);\n         assert_eq!(1e-37f32.classify(), FPNormal);\n         assert_eq!(1e-38f32.classify(), FPSubnormal);\n@@ -1192,11 +1243,13 @@ mod tests {\n \n         assert_eq!(Float::ldexp(0f32, -123), 0f32);\n         assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n-        assert_eq!(Float::ldexp(Float::infinity::<f32>(), -123),\n-                   Float::infinity::<f32>());\n-        assert_eq!(Float::ldexp(Float::neg_infinity::<f32>(), -123),\n-                   Float::neg_infinity::<f32>());\n-        assert!(Float::ldexp(Float::NaN::<f32>(), -123).is_NaN());\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::NaN();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_NaN());\n     }\n \n     #[test]\n@@ -1214,10 +1267,12 @@ mod tests {\n \n         assert_eq!(0f32.frexp(), (0f32, 0));\n         assert_eq!((-0f32).frexp(), (-0f32, 0));\n-        assert_eq!(match Float::infinity::<f32>().frexp() { (x, _) => x },\n-                   Float::infinity::<f32>())\n-        assert_eq!(match Float::neg_infinity::<f32>().frexp() { (x, _) => x },\n-                   Float::neg_infinity::<f32>())\n-        assert!(match Float::NaN::<f32>().frexp() { (x, _) => x.is_NaN() })\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::NaN();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf)\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf)\n+        assert!(match nan.frexp() { (x, _) => x.is_NaN() })\n     }\n }"}, {"sha": "8f5d6473aea2f4f3763de9c6f0790e9ed1ffb9fb", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 120, "deletions": 66, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -205,7 +205,7 @@ impl ApproxEq<f64> for f64 {\n \n     #[inline]\n     fn approx_eq(&self, other: &f64) -> bool {\n-        self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f64, f64>())\n+        self.approx_eq_eps(other, &1.0e-6)\n     }\n \n     #[inline]\n@@ -578,11 +578,14 @@ impl Real for f64 {\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n+    fn to_degrees(&self) -> f64 { *self * (180.0f64 / Real::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n-    fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n+    fn to_radians(&self) -> f64 {\n+        let value: f64 = Real::pi();\n+        *self * (value / 180.0)\n+    }\n }\n \n impl RealExt for f64 {\n@@ -625,10 +628,10 @@ impl Bounded for f64 {\n \n impl Primitive for f64 {\n     #[inline]\n-    fn bits() -> uint { 64 }\n+    fn bits(_: Option<f64>) -> uint { 64 }\n \n     #[inline]\n-    fn bytes() -> uint { Primitive::bits::<f64>() / 8 }\n+    fn bytes(_: Option<f64>) -> uint { Primitive::bits(Some(0f64)) / 8 }\n }\n \n impl Float for f64 {\n@@ -685,25 +688,25 @@ impl Float for f64 {\n     }\n \n     #[inline]\n-    fn mantissa_digits() -> uint { 53 }\n+    fn mantissa_digits(_: Option<f64>) -> uint { 53 }\n \n     #[inline]\n-    fn digits() -> uint { 15 }\n+    fn digits(_: Option<f64>) -> uint { 15 }\n \n     #[inline]\n     fn epsilon() -> f64 { 2.2204460492503131e-16 }\n \n     #[inline]\n-    fn min_exp() -> int { -1021 }\n+    fn min_exp(_: Option<f64>) -> int { -1021 }\n \n     #[inline]\n-    fn max_exp() -> int { 1024 }\n+    fn max_exp(_: Option<f64>) -> int { 1024 }\n \n     #[inline]\n-    fn min_10_exp() -> int { -307 }\n+    fn min_10_exp(_: Option<f64>) -> int { -307 }\n \n     #[inline]\n-    fn max_10_exp() -> int { 308 }\n+    fn max_10_exp(_: Option<f64>) -> int { 308 }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n@@ -983,26 +986,32 @@ mod tests {\n     fn test_min() {\n         assert_eq!(1f64.min(&2f64), 1f64);\n         assert_eq!(2f64.min(&1f64), 1f64);\n-        assert!(1f64.min(&Float::NaN::<f64>()).is_NaN());\n-        assert!(Float::NaN::<f64>().min(&1f64).is_NaN());\n+\n+        let nan: f64 = Float::NaN();\n+        assert!(1f64.min(&nan).is_NaN());\n+        assert!(nan.min(&1f64).is_NaN());\n     }\n \n     #[test]\n     fn test_max() {\n         assert_eq!(1f64.max(&2f64), 2f64);\n         assert_eq!(2f64.max(&1f64), 2f64);\n-        assert!(1f64.max(&Float::NaN::<f64>()).is_NaN());\n-        assert!(Float::NaN::<f64>().max(&1f64).is_NaN());\n+\n+        let nan: f64 = Float::NaN();\n+        assert!(1f64.max(&nan).is_NaN());\n+        assert!(nan.max(&1f64).is_NaN());\n     }\n \n     #[test]\n     fn test_clamp() {\n         assert_eq!(1f64.clamp(&2f64, &4f64), 2f64);\n         assert_eq!(8f64.clamp(&2f64, &4f64), 4f64);\n         assert_eq!(3f64.clamp(&2f64, &4f64), 3f64);\n-        assert!(3f64.clamp(&Float::NaN::<f64>(), &4f64).is_NaN());\n-        assert!(3f64.clamp(&2f64, &Float::NaN::<f64>()).is_NaN());\n-        assert!(Float::NaN::<f64>().clamp(&2f64, &4f64).is_NaN());\n+\n+        let nan: f64 = Float::NaN();\n+        assert!(3f64.clamp(&nan, &4f64).is_NaN());\n+        assert!(3f64.clamp(&2f64, &nan).is_NaN());\n+        assert!(nan.clamp(&2f64, &4f64).is_NaN());\n     }\n \n     #[test]\n@@ -1079,9 +1088,13 @@ mod tests {\n     fn test_asinh() {\n         assert_eq!(0.0f64.asinh(), 0.0f64);\n         assert_eq!((-0.0f64).asinh(), -0.0f64);\n-        assert_eq!(Float::infinity::<f64>().asinh(), Float::infinity::<f64>());\n-        assert_eq!(Float::neg_infinity::<f64>().asinh(), Float::neg_infinity::<f64>());\n-        assert!(Float::NaN::<f64>().asinh().is_NaN());\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(inf.asinh(), inf);\n+        assert_eq!(neg_inf.asinh(), neg_inf);\n+        assert!(nan.asinh().is_NaN());\n         assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n         assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n     }\n@@ -1090,9 +1103,13 @@ mod tests {\n     fn test_acosh() {\n         assert_eq!(1.0f64.acosh(), 0.0f64);\n         assert!(0.999f64.acosh().is_NaN());\n-        assert_eq!(Float::infinity::<f64>().acosh(), Float::infinity::<f64>());\n-        assert!(Float::neg_infinity::<f64>().acosh().is_NaN());\n-        assert!(Float::NaN::<f64>().acosh().is_NaN());\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(inf.acosh(), inf);\n+        assert!(neg_inf.acosh().is_NaN());\n+        assert!(nan.acosh().is_NaN());\n         assert_approx_eq!(2.0f64.acosh(), 1.31695789692481670862504634730796844f64);\n         assert_approx_eq!(3.0f64.acosh(), 1.76274717403908605046521864995958461f64);\n     }\n@@ -1101,34 +1118,56 @@ mod tests {\n     fn test_atanh() {\n         assert_eq!(0.0f64.atanh(), 0.0f64);\n         assert_eq!((-0.0f64).atanh(), -0.0f64);\n-        assert_eq!(1.0f64.atanh(), Float::infinity::<f64>());\n-        assert_eq!((-1.0f64).atanh(), Float::neg_infinity::<f64>());\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(1.0f64.atanh(), inf);\n+        assert_eq!((-1.0f64).atanh(), neg_inf);\n         assert!(2f64.atanh().atanh().is_NaN());\n         assert!((-2f64).atanh().atanh().is_NaN());\n-        assert!(Float::infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::neg_infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::NaN::<f64>().atanh().is_NaN());\n+        assert!(inf.atanh().is_NaN());\n+        assert!(neg_inf.atanh().is_NaN());\n+        assert!(nan.atanh().is_NaN());\n         assert_approx_eq!(0.5f64.atanh(), 0.54930614433405484569762261846126285f64);\n         assert_approx_eq!((-0.5f64).atanh(), -0.54930614433405484569762261846126285f64);\n     }\n \n     #[test]\n     fn test_real_consts() {\n-        assert_approx_eq!(Real::two_pi::<f64>(), 2.0 * Real::pi::<f64>());\n-        assert_approx_eq!(Real::frac_pi_2::<f64>(), Real::pi::<f64>() / 2f64);\n-        assert_approx_eq!(Real::frac_pi_3::<f64>(), Real::pi::<f64>() / 3f64);\n-        assert_approx_eq!(Real::frac_pi_4::<f64>(), Real::pi::<f64>() / 4f64);\n-        assert_approx_eq!(Real::frac_pi_6::<f64>(), Real::pi::<f64>() / 6f64);\n-        assert_approx_eq!(Real::frac_pi_8::<f64>(), Real::pi::<f64>() / 8f64);\n-        assert_approx_eq!(Real::frac_1_pi::<f64>(), 1f64 / Real::pi::<f64>());\n-        assert_approx_eq!(Real::frac_2_pi::<f64>(), 2f64 / Real::pi::<f64>());\n-        assert_approx_eq!(Real::frac_2_sqrtpi::<f64>(), 2f64 / Real::pi::<f64>().sqrt());\n-        assert_approx_eq!(Real::sqrt2::<f64>(), 2f64.sqrt());\n-        assert_approx_eq!(Real::frac_1_sqrt2::<f64>(), 1f64 / 2f64.sqrt());\n-        assert_approx_eq!(Real::log2_e::<f64>(), Real::e::<f64>().log2());\n-        assert_approx_eq!(Real::log10_e::<f64>(), Real::e::<f64>().log10());\n-        assert_approx_eq!(Real::ln_2::<f64>(), 2f64.ln());\n-        assert_approx_eq!(Real::ln_10::<f64>(), 10f64.ln());\n+        let pi: f64 = Real::pi();\n+        let two_pi: f64 = Real::two_pi();\n+        let frac_pi_2: f64 = Real::frac_pi_2();\n+        let frac_pi_3: f64 = Real::frac_pi_3();\n+        let frac_pi_4: f64 = Real::frac_pi_4();\n+        let frac_pi_6: f64 = Real::frac_pi_6();\n+        let frac_pi_8: f64 = Real::frac_pi_8();\n+        let frac_1_pi: f64 = Real::frac_1_pi();\n+        let frac_2_pi: f64 = Real::frac_2_pi();\n+        let frac_2_sqrtpi: f64 = Real::frac_2_sqrtpi();\n+        let sqrt2: f64 = Real::sqrt2();\n+        let frac_1_sqrt2: f64 = Real::frac_1_sqrt2();\n+        let e: f64 = Real::e();\n+        let log2_e: f64 = Real::log2_e();\n+        let log10_e: f64 = Real::log10_e();\n+        let ln_2: f64 = Real::ln_2();\n+        let ln_10: f64 = Real::ln_10();\n+\n+        assert_approx_eq!(two_pi, 2.0 * pi);\n+        assert_approx_eq!(frac_pi_2, pi / 2f64);\n+        assert_approx_eq!(frac_pi_3, pi / 3f64);\n+        assert_approx_eq!(frac_pi_4, pi / 4f64);\n+        assert_approx_eq!(frac_pi_6, pi / 6f64);\n+        assert_approx_eq!(frac_pi_8, pi / 8f64);\n+        assert_approx_eq!(frac_1_pi, 1f64 / pi);\n+        assert_approx_eq!(frac_2_pi, 2f64 / pi);\n+        assert_approx_eq!(frac_2_sqrtpi, 2f64 / pi.sqrt());\n+        assert_approx_eq!(sqrt2, 2f64.sqrt());\n+        assert_approx_eq!(frac_1_sqrt2, 1f64 / 2f64.sqrt());\n+        assert_approx_eq!(log2_e, e.log2());\n+        assert_approx_eq!(log10_e, e.log10());\n+        assert_approx_eq!(ln_2, 2f64.ln());\n+        assert_approx_eq!(ln_10, 10f64.ln());\n     }\n \n     #[test]\n@@ -1204,29 +1243,40 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<f64>(), sys::size_of::<f64>() * 8);\n-        assert_eq!(Primitive::bytes::<f64>(), sys::size_of::<f64>());\n+        let none: Option<f64> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<f64>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<f64>());\n     }\n \n     #[test]\n     fn test_is_normal() {\n-        assert!(!Float::NaN::<f64>().is_normal());\n-        assert!(!Float::infinity::<f64>().is_normal());\n-        assert!(!Float::neg_infinity::<f64>().is_normal());\n-        assert!(!Zero::zero::<f64>().is_normal());\n-        assert!(!Float::neg_zero::<f64>().is_normal());\n+        let nan: f64 = Float::NaN();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let zero: f64 = Zero::zero();\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n         assert!(1f64.is_normal());\n         assert!(1e-307f64.is_normal());\n         assert!(!1e-308f64.is_normal());\n     }\n \n     #[test]\n     fn test_classify() {\n-        assert_eq!(Float::NaN::<f64>().classify(), FPNaN);\n-        assert_eq!(Float::infinity::<f64>().classify(), FPInfinite);\n-        assert_eq!(Float::neg_infinity::<f64>().classify(), FPInfinite);\n-        assert_eq!(Zero::zero::<f64>().classify(), FPZero);\n-        assert_eq!(Float::neg_zero::<f64>().classify(), FPZero);\n+        let nan: f64 = Float::NaN();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let zero: f64 = Zero::zero();\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert_eq!(nan.classify(), FPNaN);\n+        assert_eq!(inf.classify(), FPInfinite);\n+        assert_eq!(neg_inf.classify(), FPInfinite);\n+        assert_eq!(zero.classify(), FPZero);\n+        assert_eq!(neg_zero.classify(), FPZero);\n         assert_eq!(1e-307f64.classify(), FPNormal);\n         assert_eq!(1e-308f64.classify(), FPSubnormal);\n     }\n@@ -1242,11 +1292,13 @@ mod tests {\n \n         assert_eq!(Float::ldexp(0f64, -123), 0f64);\n         assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n-        assert_eq!(Float::ldexp(Float::infinity::<f64>(), -123),\n-                   Float::infinity::<f64>());\n-        assert_eq!(Float::ldexp(Float::neg_infinity::<f64>(), -123),\n-                   Float::neg_infinity::<f64>());\n-        assert!(Float::ldexp(Float::NaN::<f64>(), -123).is_NaN());\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_NaN());\n     }\n \n     #[test]\n@@ -1264,10 +1316,12 @@ mod tests {\n \n         assert_eq!(0f64.frexp(), (0f64, 0));\n         assert_eq!((-0f64).frexp(), (-0f64, 0));\n-        assert_eq!(match Float::infinity::<f64>().frexp() { (x, _) => x },\n-                   Float::infinity::<f64>())\n-        assert_eq!(match Float::neg_infinity::<f64>().frexp() { (x, _) => x },\n-                   Float::neg_infinity::<f64>())\n-        assert!(match Float::NaN::<f64>().frexp() { (x, _) => x.is_NaN() })\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf)\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf)\n+        assert!(match nan.frexp() { (x, _) => x.is_NaN() })\n     }\n }"}, {"sha": "d019de2468bdfa568699d8c76a0d8412da0ebd37", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 156, "deletions": 68, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -342,7 +342,7 @@ impl ApproxEq<float> for float {\n \n     #[inline]\n     fn approx_eq(&self, other: &float) -> bool {\n-        self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<float, float>())\n+        self.approx_eq_eps(other, &1.0e-6)\n     }\n \n     #[inline]\n@@ -783,32 +783,56 @@ impl Signed for float {\n \n impl Bounded for float {\n     #[inline]\n-    fn min_value() -> float { Bounded::min_value::<f64>() as float }\n+    fn min_value() -> float {\n+        let x: f64 = Bounded::min_value();\n+        x as float\n+    }\n \n     #[inline]\n-    fn max_value() -> float { Bounded::max_value::<f64>() as float }\n+    fn max_value() -> float {\n+        let x: f64 = Bounded::max_value();\n+        x as float\n+    }\n }\n \n impl Primitive for float {\n     #[inline]\n-    fn bits() -> uint { Primitive::bits::<f64>() }\n+    fn bits(_: Option<float>) -> uint {\n+        let bits: uint = Primitive::bits(Some(0f64));\n+        bits\n+    }\n \n     #[inline]\n-    fn bytes() -> uint { Primitive::bytes::<f64>() }\n+    fn bytes(_: Option<float>) -> uint {\n+        let bytes: uint = Primitive::bytes(Some(0f64));\n+        bytes\n+    }\n }\n \n impl Float for float {\n     #[inline]\n-    fn NaN() -> float { Float::NaN::<f64>() as float }\n+    fn NaN() -> float {\n+        let value: f64 = Float::NaN();\n+        value as float\n+    }\n \n     #[inline]\n-    fn infinity() -> float { Float::infinity::<f64>() as float }\n+    fn infinity() -> float {\n+        let value: f64 = Float::infinity();\n+        value as float\n+    }\n \n     #[inline]\n-    fn neg_infinity() -> float { Float::neg_infinity::<f64>() as float }\n+    fn neg_infinity() -> float {\n+        let value: f64 = Float::neg_infinity();\n+        value as float\n+    }\n \n     #[inline]\n-    fn neg_zero() -> float { Float::neg_zero::<f64>() as float }\n+    fn neg_zero() -> float {\n+        let value: f64 = Float::neg_zero();\n+        value as float\n+    }\n \n     /// Returns `true` if the number is NaN\n     #[inline]\n@@ -832,30 +856,46 @@ impl Float for float {\n     fn classify(&self) -> FPCategory { (*self as f64).classify() }\n \n     #[inline]\n-    fn mantissa_digits() -> uint { Float::mantissa_digits::<f64>() }\n+    fn mantissa_digits(_: Option<float>) -> uint {\n+        Float::mantissa_digits(Some(0f64))\n+    }\n \n     #[inline]\n-    fn digits() -> uint { Float::digits::<f64>() }\n+    fn digits(_: Option<float>) -> uint {\n+        Float::digits(Some(0f64))\n+    }\n \n     #[inline]\n-    fn epsilon() -> float { Float::epsilon::<f64>() as float }\n+    fn epsilon() -> float {\n+        let value: f64 = Float::epsilon();\n+        value as float\n+    }\n \n     #[inline]\n-    fn min_exp() -> int { Float::min_exp::<f64>() }\n+    fn min_exp(_: Option<float>) -> int {\n+        Float::min_exp(Some(0f64))\n+    }\n \n     #[inline]\n-    fn max_exp() -> int { Float::max_exp::<f64>() }\n+    fn max_exp(_: Option<float>) -> int {\n+        Float::max_exp(Some(0f64))\n+    }\n \n     #[inline]\n-    fn min_10_exp() -> int { Float::min_10_exp::<f64>() }\n+    fn min_10_exp(_: Option<float>) -> int {\n+        Float::min_10_exp(Some(0f64))\n+    }\n \n     #[inline]\n-    fn max_10_exp() -> int { Float::max_10_exp::<f64>() }\n+    fn max_10_exp(_: Option<float>) -> int {\n+        Float::max_10_exp(Some(0f64))\n+    }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n     fn ldexp(x: float, exp: int) -> float {\n-        Float::ldexp(x as f64, exp) as float\n+        let value: f64 = Float::ldexp(x as f64, exp);\n+        value as float\n     }\n \n     ///\n@@ -937,9 +977,10 @@ mod tests {\n         assert_eq!(1f.clamp(&2f, &4f), 2f);\n         assert_eq!(8f.clamp(&2f, &4f), 4f);\n         assert_eq!(3f.clamp(&2f, &4f), 3f);\n-        assert!(3f.clamp(&Float::NaN::<float>(), &4f).is_NaN());\n-        assert!(3f.clamp(&2f, &Float::NaN::<float>()).is_NaN());\n-        assert!(Float::NaN::<float>().clamp(&2f, &4f).is_NaN());\n+        let nan: float = Float::NaN();\n+        assert!(3f.clamp(&nan, &4f).is_NaN());\n+        assert!(3f.clamp(&2f, &nan).is_NaN());\n+        assert!(nan.clamp(&2f, &4f).is_NaN());\n     }\n \n     #[test]\n@@ -1016,9 +1057,13 @@ mod tests {\n     fn test_asinh() {\n         assert_eq!(0.0f.asinh(), 0.0f);\n         assert_eq!((-0.0f).asinh(), -0.0f);\n-        assert_eq!(Float::infinity::<float>().asinh(), Float::infinity::<float>());\n-        assert_eq!(Float::neg_infinity::<float>().asinh(), Float::neg_infinity::<float>());\n-        assert!(Float::NaN::<float>().asinh().is_NaN());\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(inf.asinh(), inf);\n+        assert_eq!(neg_inf.asinh(), neg_inf);\n+        assert!(nan.asinh().is_NaN());\n         assert_approx_eq!(2.0f.asinh(), 1.443635475178810342493276740273105f);\n         assert_approx_eq!((-2.0f).asinh(), -1.443635475178810342493276740273105f);\n     }\n@@ -1027,9 +1072,13 @@ mod tests {\n     fn test_acosh() {\n         assert_eq!(1.0f.acosh(), 0.0f);\n         assert!(0.999f.acosh().is_NaN());\n-        assert_eq!(Float::infinity::<float>().acosh(), Float::infinity::<float>());\n-        assert!(Float::neg_infinity::<float>().acosh().is_NaN());\n-        assert!(Float::NaN::<float>().acosh().is_NaN());\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(inf.acosh(), inf);\n+        assert!(neg_inf.acosh().is_NaN());\n+        assert!(nan.acosh().is_NaN());\n         assert_approx_eq!(2.0f.acosh(), 1.31695789692481670862504634730796844f);\n         assert_approx_eq!(3.0f.acosh(), 1.76274717403908605046521864995958461f);\n     }\n@@ -1038,34 +1087,58 @@ mod tests {\n     fn test_atanh() {\n         assert_eq!(0.0f.atanh(), 0.0f);\n         assert_eq!((-0.0f).atanh(), -0.0f);\n-        assert_eq!(1.0f.atanh(), Float::infinity::<float>());\n-        assert_eq!((-1.0f).atanh(), Float::neg_infinity::<float>());\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let inf64: f64 = Float::infinity();\n+        let neg_inf64: f64 = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(1.0f.atanh(), inf);\n+        assert_eq!((-1.0f).atanh(), neg_inf);\n         assert!(2f64.atanh().atanh().is_NaN());\n         assert!((-2f64).atanh().atanh().is_NaN());\n-        assert!(Float::infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::neg_infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::NaN::<float>().atanh().is_NaN());\n+        assert!(inf64.atanh().is_NaN());\n+        assert!(neg_inf64.atanh().is_NaN());\n+        assert!(nan.atanh().is_NaN());\n         assert_approx_eq!(0.5f.atanh(), 0.54930614433405484569762261846126285f);\n         assert_approx_eq!((-0.5f).atanh(), -0.54930614433405484569762261846126285f);\n     }\n \n     #[test]\n     fn test_real_consts() {\n-        assert_approx_eq!(Real::two_pi::<float>(), 2f * Real::pi::<float>());\n-        assert_approx_eq!(Real::frac_pi_2::<float>(), Real::pi::<float>() / 2f);\n-        assert_approx_eq!(Real::frac_pi_3::<float>(), Real::pi::<float>() / 3f);\n-        assert_approx_eq!(Real::frac_pi_4::<float>(), Real::pi::<float>() / 4f);\n-        assert_approx_eq!(Real::frac_pi_6::<float>(), Real::pi::<float>() / 6f);\n-        assert_approx_eq!(Real::frac_pi_8::<float>(), Real::pi::<float>() / 8f);\n-        assert_approx_eq!(Real::frac_1_pi::<float>(), 1f / Real::pi::<float>());\n-        assert_approx_eq!(Real::frac_2_pi::<float>(), 2f / Real::pi::<float>());\n-        assert_approx_eq!(Real::frac_2_sqrtpi::<float>(), 2f / Real::pi::<float>().sqrt());\n-        assert_approx_eq!(Real::sqrt2::<float>(), 2f.sqrt());\n-        assert_approx_eq!(Real::frac_1_sqrt2::<float>(), 1f / 2f.sqrt());\n-        assert_approx_eq!(Real::log2_e::<float>(), Real::e::<float>().log2());\n-        assert_approx_eq!(Real::log10_e::<float>(), Real::e::<float>().log10());\n-        assert_approx_eq!(Real::ln_2::<float>(), 2f.ln());\n-        assert_approx_eq!(Real::ln_10::<float>(), 10f.ln());\n+        let pi: float = Real::pi();\n+        let two_pi: float = Real::two_pi();\n+        let frac_pi_2: float = Real::frac_pi_2();\n+        let frac_pi_3: float = Real::frac_pi_3();\n+        let frac_pi_4: float = Real::frac_pi_4();\n+        let frac_pi_6: float = Real::frac_pi_6();\n+        let frac_pi_8: float = Real::frac_pi_8();\n+        let frac_1_pi: float = Real::frac_1_pi();\n+        let frac_2_pi: float = Real::frac_2_pi();\n+        let frac_2_sqrtpi: float = Real::frac_2_sqrtpi();\n+        let sqrt2: float = Real::sqrt2();\n+        let frac_1_sqrt2: float = Real::frac_1_sqrt2();\n+        let e: float = Real::e();\n+        let log2_e: float = Real::log2_e();\n+        let log10_e: float = Real::log10_e();\n+        let ln_2: float = Real::ln_2();\n+        let ln_10: float = Real::ln_10();\n+\n+        assert_approx_eq!(two_pi, 2f * pi);\n+        assert_approx_eq!(frac_pi_2, pi / 2f);\n+        assert_approx_eq!(frac_pi_3, pi / 3f);\n+        assert_approx_eq!(frac_pi_4, pi / 4f);\n+        assert_approx_eq!(frac_pi_6, pi / 6f);\n+        assert_approx_eq!(frac_pi_8, pi / 8f);\n+        assert_approx_eq!(frac_1_pi, 1f / pi);\n+        assert_approx_eq!(frac_2_pi, 2f / pi);\n+        assert_approx_eq!(frac_2_sqrtpi, 2f / pi.sqrt());\n+        assert_approx_eq!(sqrt2, 2f.sqrt());\n+        assert_approx_eq!(frac_1_sqrt2, 1f / 2f.sqrt());\n+        assert_approx_eq!(log2_e, e.log2());\n+        assert_approx_eq!(log10_e, e.log10());\n+        assert_approx_eq!(ln_2, 2f.ln());\n+        assert_approx_eq!(ln_10, 10f.ln());\n     }\n \n     #[test]\n@@ -1141,29 +1214,40 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<float>(), sys::size_of::<float>() * 8);\n-        assert_eq!(Primitive::bytes::<float>(), sys::size_of::<float>());\n+        let none: Option<float> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<float>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<float>());\n     }\n \n     #[test]\n     fn test_is_normal() {\n-        assert!(!Float::NaN::<float>().is_normal());\n-        assert!(!Float::infinity::<float>().is_normal());\n-        assert!(!Float::neg_infinity::<float>().is_normal());\n-        assert!(!Zero::zero::<float>().is_normal());\n-        assert!(!Float::neg_zero::<float>().is_normal());\n+        let nan: float = Float::NaN();\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let zero: float = Zero::zero();\n+        let neg_zero: float = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n         assert!(1f.is_normal());\n         assert!(1e-307f.is_normal());\n         assert!(!1e-308f.is_normal());\n     }\n \n     #[test]\n     fn test_classify() {\n-        assert_eq!(Float::NaN::<float>().classify(), FPNaN);\n-        assert_eq!(Float::infinity::<float>().classify(), FPInfinite);\n-        assert_eq!(Float::neg_infinity::<float>().classify(), FPInfinite);\n-        assert_eq!(Zero::zero::<float>().classify(), FPZero);\n-        assert_eq!(Float::neg_zero::<float>().classify(), FPZero);\n+        let nan: float = Float::NaN();\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let zero: float = Zero::zero();\n+        let neg_zero: float = Float::neg_zero();\n+        assert_eq!(nan.classify(), FPNaN);\n+        assert_eq!(inf.classify(), FPInfinite);\n+        assert_eq!(neg_inf.classify(), FPInfinite);\n+        assert_eq!(zero.classify(), FPZero);\n+        assert_eq!(neg_zero.classify(), FPZero);\n         assert_eq!(1f.classify(), FPNormal);\n         assert_eq!(1e-307f.classify(), FPNormal);\n         assert_eq!(1e-308f.classify(), FPSubnormal);\n@@ -1180,11 +1264,13 @@ mod tests {\n \n         assert_eq!(Float::ldexp(0f, -123), 0f);\n         assert_eq!(Float::ldexp(-0f, -123), -0f);\n-        assert_eq!(Float::ldexp(Float::infinity::<float>(), -123),\n-                   Float::infinity::<float>());\n-        assert_eq!(Float::ldexp(Float::neg_infinity::<float>(), -123),\n-                   Float::neg_infinity::<float>());\n-        assert!(Float::ldexp(Float::NaN::<float>(), -123).is_NaN());\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_NaN());\n     }\n \n     #[test]\n@@ -1202,11 +1288,13 @@ mod tests {\n \n         assert_eq!(0f.frexp(), (0f, 0));\n         assert_eq!((-0f).frexp(), (-0f, 0));\n-        assert_eq!(match Float::infinity::<float>().frexp() { (x, _) => x },\n-                   Float::infinity::<float>())\n-        assert_eq!(match Float::neg_infinity::<float>().frexp() { (x, _) => x },\n-                   Float::neg_infinity::<float>())\n-        assert!(match Float::NaN::<float>().frexp() { (x, _) => x.is_NaN() })\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n+        assert!(match nan.frexp() { (x, _) => x.is_NaN() })\n     }\n \n     #[test]"}, {"sha": "6054d557fa5cd7547b556d36bd0d7fb979be2cd2", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -466,10 +466,10 @@ impl Int for $T {}\n \n impl Primitive for $T {\n     #[inline]\n-    fn bits() -> uint { bits }\n+    fn bits(_: Option<$T>) -> uint { bits }\n \n     #[inline]\n-    fn bytes() -> uint { bits / 8 }\n+    fn bytes(_: Option<$T>) -> uint { bits / 8 }\n }\n \n // String conversion functions and impl str -> num\n@@ -754,8 +754,9 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<$T>(), sys::size_of::<$T>() * 8);\n-        assert_eq!(Primitive::bytes::<$T>(), sys::size_of::<$T>());\n+        let none: Option<$T> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<$T>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<$T>());\n     }\n \n     #[test]"}, {"sha": "80ab0caac670ccdc911cabd92b808d8ad6da32ad", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -272,8 +272,8 @@ pub trait Primitive: Num\n                    + Div<Self,Self>\n                    + Rem<Self,Self> {\n     // FIXME (#5527): These should be associated constants\n-    fn bits() -> uint;\n-    fn bytes() -> uint;\n+    fn bits(unused_self: Option<Self>) -> uint;\n+    fn bytes(unused_self: Option<Self>) -> uint;\n }\n \n /// A collection of traits relevant to primitive signed and unsigned integers\n@@ -314,13 +314,13 @@ pub trait Float: Real\n     fn is_normal(&self) -> bool;\n     fn classify(&self) -> FPCategory;\n \n-    fn mantissa_digits() -> uint;\n-    fn digits() -> uint;\n+    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    fn digits(unused_self: Option<Self>) -> uint;\n     fn epsilon() -> Self;\n-    fn min_exp() -> int;\n-    fn max_exp() -> int;\n-    fn min_10_exp() -> int;\n-    fn max_10_exp() -> int;\n+    fn min_exp(unused_self: Option<Self>) -> int;\n+    fn max_exp(unused_self: Option<Self>) -> int;\n+    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    fn max_10_exp(unused_self: Option<Self>) -> int;\n \n     fn ldexp(x: Self, exp: int) -> Self;\n     fn frexp(&self) -> (Self, int);\n@@ -484,9 +484,9 @@ impl<T: CheckedAdd+CheckedSub+Zero+Ord+Bounded> Saturating for T {\n         match self.checked_add(&v) {\n             Some(x) => x,\n             None => if v >= Zero::zero() {\n-                Bounded::max_value::<T>()\n+                Bounded::max_value()\n             } else {\n-                Bounded::min_value::<T>()\n+                Bounded::min_value()\n             }\n         }\n     }\n@@ -496,9 +496,9 @@ impl<T: CheckedAdd+CheckedSub+Zero+Ord+Bounded> Saturating for T {\n         match self.checked_sub(&v) {\n             Some(x) => x,\n             None => if v >= Zero::zero() {\n-                Bounded::min_value::<T>()\n+                Bounded::min_value()\n             } else {\n-                Bounded::max_value::<T>()\n+                Bounded::max_value()\n             }\n         }\n     }"}, {"sha": "8ffaed22d01afd1b339030f81b29dc0115511620", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -404,10 +404,10 @@ impl ToStrRadix for $T {\n \n impl Primitive for $T {\n     #[inline]\n-    fn bits() -> uint { bits }\n+    fn bits(_: Option<$T>) -> uint { bits }\n \n     #[inline]\n-    fn bytes() -> uint { bits / 8 }\n+    fn bytes(_: Option<$T>) -> uint { bits / 8 }\n }\n \n impl BitCount for $T {\n@@ -532,8 +532,9 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<$T>(), sys::size_of::<$T>() * 8);\n-        assert_eq!(Primitive::bytes::<$T>(), sys::size_of::<$T>());\n+        let none: Option<$T> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<$T>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<$T>());\n     }\n \n     #[test]"}, {"sha": "7aae9425302255fdfaadac1a28a1612cdaf88096", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -1521,7 +1521,7 @@ impl MemoryMap {\n         let r = unsafe {\n             libc::mmap(addr, len, prot, flags, fd, offset)\n         };\n-        if r == libc::MAP_FAILED {\n+        if r.equiv(&libc::MAP_FAILED) {\n             Err(match errno() as c_int {\n                 libc::EACCES => ErrFdNotAvail,\n                 libc::EBADF => ErrInvalidFd,"}, {"sha": "860b1f4b7683b704151fc8bb95578ee13c70d374", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 114, "deletions": 32, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -12,8 +12,11 @@\n \n use cast;\n use clone::Clone;\n+use cmp::Equiv;\n use iterator::{range, Iterator};\n use option::{Option, Some, None};\n+#[cfg(stage0)]\n+use sys;\n use unstable::intrinsics;\n use util::swap;\n \n@@ -24,18 +27,28 @@ use util::swap;\n \n /// Calculate the offset from a pointer\n #[inline]\n+#[cfg(stage0)]\n pub fn offset<T>(ptr: *T, count: int) -> *T {\n-    unsafe { intrinsics::offset(ptr, count) }\n+    (ptr as uint + (count as uint) * sys::size_of::<T>()) as *T\n }\n \n-/// Calculate the offset from a const pointer\n+/// Calculate the offset from a mut pointer\n #[inline]\n-pub fn const_offset<T>(ptr: *const T, count: int) -> *const T {\n-    unsafe { intrinsics::offset(ptr as *T, count) }\n+#[cfg(stage0)]\n+pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n+    (ptr as uint + (count as uint) * sys::size_of::<T>()) as *mut T\n+}\n+\n+/// Calculate the offset from a pointer\n+#[inline]\n+#[cfg(not(stage0))]\n+pub fn offset<T>(ptr: *T, count: int) -> *T {\n+    unsafe { intrinsics::offset(ptr, count) }\n }\n \n /// Calculate the offset from a mut pointer\n #[inline]\n+#[cfg(not(stage0))]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     unsafe { intrinsics::offset(ptr as *T, count) as *mut T }\n }\n@@ -73,11 +86,11 @@ pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n /// Returns true if the pointer is equal to the null pointer.\n #[inline]\n-pub fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n+pub fn is_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_null() }\n \n /// Returns true if the pointer is not equal to the null pointer.\n #[inline]\n-pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n+pub fn is_not_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_not_null() }\n \n /**\n  * Copies data from one location to another.\n@@ -87,8 +100,10 @@ pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  */\n #[inline]\n #[cfg(target_word_size = \"32\")]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    intrinsics::memmove32(dst, src as *T, count as u32);\n+pub unsafe fn copy_memory<T,P:RawPtr<T>>(dst: *mut T, src: P, count: uint) {\n+    intrinsics::memmove32(dst,\n+                          cast::transmute_immut_unsafe(src),\n+                          count as u32);\n }\n \n /**\n@@ -99,8 +114,10 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  */\n #[inline]\n #[cfg(target_word_size = \"64\")]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    intrinsics::memmove64(dst, src as *T, count as u64);\n+pub unsafe fn copy_memory<T,P:RawPtr<T>>(dst: *mut T, src: P, count: uint) {\n+    intrinsics::memmove64(dst,\n+                          cast::transmute_immut_unsafe(src),\n+                          count as u64);\n }\n \n /**\n@@ -111,8 +128,12 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  */\n #[inline]\n #[cfg(target_word_size = \"32\")]\n-pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    intrinsics::memcpy32(dst, src as *T, count as u32);\n+pub unsafe fn copy_nonoverlapping_memory<T,P:RawPtr<T>>(dst: *mut T,\n+                                                        src: P,\n+                                                        count: uint) {\n+    intrinsics::memcpy32(dst,\n+                         cast::transmute_immut_unsafe(src),\n+                         count as u32);\n }\n \n /**\n@@ -123,8 +144,12 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  */\n #[inline]\n #[cfg(target_word_size = \"64\")]\n-pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    intrinsics::memcpy64(dst, src as *T, count as u64);\n+pub unsafe fn copy_nonoverlapping_memory<T,P:RawPtr<T>>(dst: *mut T,\n+                                                        src: P,\n+                                                        count: uint) {\n+    intrinsics::memcpy64(dst,\n+                         cast::transmute_immut_unsafe(src),\n+                         count as u64);\n }\n \n /**\n@@ -216,12 +241,6 @@ pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n     thing as *T\n }\n \n-/// Transform a const region pointer - &const T - to a const unsafe pointer - *const T.\n-#[inline]\n-pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n-    thing as *const T\n-}\n-\n /// Transform a mutable region pointer - &mut T - to a mutable unsafe pointer - *mut T.\n #[inline]\n pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n@@ -269,22 +288,32 @@ pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n \n #[allow(missing_doc)]\n pub trait RawPtr<T> {\n+    fn null() -> Self;\n     fn is_null(&self) -> bool;\n     fn is_not_null(&self) -> bool;\n+    fn to_uint(&self) -> uint;\n     unsafe fn to_option(&self) -> Option<&T>;\n     fn offset(&self, count: int) -> Self;\n     unsafe fn offset_inbounds(self, count: int) -> Self;\n }\n \n /// Extension methods for immutable pointers\n impl<T> RawPtr<T> for *T {\n+    /// Returns the null pointer.\n+    #[inline]\n+    fn null() -> *T { null() }\n+\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n-    fn is_null(&self) -> bool { is_null(*self) }\n+    fn is_null(&self) -> bool { *self == RawPtr::null() }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&self) -> bool { *self != RawPtr::null() }\n+\n+    /// Returns the address of this pointer.\n+    #[inline]\n+    fn to_uint(&self) -> uint { *self as uint }\n \n     ///\n     /// Returns `None` if the pointer is null, or else returns the value wrapped\n@@ -317,13 +346,21 @@ impl<T> RawPtr<T> for *T {\n \n /// Extension methods for mutable pointers\n impl<T> RawPtr<T> for *mut T {\n+    /// Returns the null pointer.\n+    #[inline]\n+    fn null() -> *mut T { mut_null() }\n+\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n-    fn is_null(&self) -> bool { is_null(*self) }\n+    fn is_null(&self) -> bool { *self == RawPtr::null() }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&self) -> bool { *self != RawPtr::null() }\n+\n+    /// Returns the address of this pointer.\n+    #[inline]\n+    fn to_uint(&self) -> uint { *self as uint }\n \n     ///\n     /// Returns `None` if the pointer is null, or else returns the value wrapped\n@@ -360,13 +397,38 @@ impl<T> RawPtr<T> for *mut T {\n \n // Equality for pointers\n #[cfg(not(test))]\n-impl<T> Eq for *const T {\n+impl<T> Eq for *T {\n+    #[inline]\n+    fn eq(&self, other: &*T) -> bool {\n+        (*self as uint) == (*other as uint)\n+    }\n+    #[inline]\n+    fn ne(&self, other: &*T) -> bool { !self.eq(other) }\n+}\n+\n+#[cfg(not(test))]\n+impl<T> Eq for *mut T {\n     #[inline]\n-    fn eq(&self, other: &*const T) -> bool {\n+    fn eq(&self, other: &*mut T) -> bool {\n         (*self as uint) == (*other as uint)\n     }\n     #[inline]\n-    fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n+}\n+\n+// Equivalence for pointers\n+#[cfg(not(test))]\n+impl<T> Equiv<*mut T> for *T {\n+    fn equiv(&self, other: &*mut T) -> bool {\n+        self.to_uint() == other.to_uint()\n+    }\n+}\n+\n+#[cfg(not(test))]\n+impl<T> Equiv<*T> for *mut T {\n+    fn equiv(&self, other: &*T) -> bool {\n+        self.to_uint() == other.to_uint()\n+    }\n }\n \n // Equality for extern \"C\" fn pointers\n@@ -412,21 +474,41 @@ mod externfnpointers {\n \n // Comparison for pointers\n #[cfg(not(test))]\n-impl<T> Ord for *const T {\n+impl<T> Ord for *T {\n+    #[inline]\n+    fn lt(&self, other: &*T) -> bool {\n+        (*self as uint) < (*other as uint)\n+    }\n+    #[inline]\n+    fn le(&self, other: &*T) -> bool {\n+        (*self as uint) <= (*other as uint)\n+    }\n+    #[inline]\n+    fn ge(&self, other: &*T) -> bool {\n+        (*self as uint) >= (*other as uint)\n+    }\n+    #[inline]\n+    fn gt(&self, other: &*T) -> bool {\n+        (*self as uint) > (*other as uint)\n+    }\n+}\n+\n+#[cfg(not(test))]\n+impl<T> Ord for *mut T {\n     #[inline]\n-    fn lt(&self, other: &*const T) -> bool {\n+    fn lt(&self, other: &*mut T) -> bool {\n         (*self as uint) < (*other as uint)\n     }\n     #[inline]\n-    fn le(&self, other: &*const T) -> bool {\n+    fn le(&self, other: &*mut T) -> bool {\n         (*self as uint) <= (*other as uint)\n     }\n     #[inline]\n-    fn ge(&self, other: &*const T) -> bool {\n+    fn ge(&self, other: &*mut T) -> bool {\n         (*self as uint) >= (*other as uint)\n     }\n     #[inline]\n-    fn gt(&self, other: &*const T) -> bool {\n+    fn gt(&self, other: &*mut T) -> bool {\n         (*self as uint) > (*other as uint)\n     }\n }"}, {"sha": "9dc0abdfbd88ae506faff3c97552c118e42f344a", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -11,17 +11,18 @@\n use cell::Cell;\n use c_str::ToCStr;\n use cast::transmute;\n-use libc::{c_char, size_t, STDERR_FILENO};\n-use io;\n use io::{Writer, WriterUtil};\n+use io;\n+use libc::{c_char, size_t, STDERR_FILENO};\n use option::{Option, None, Some};\n-use uint;\n+use ptr::RawPtr;\n use rt::env;\n use rt::local::Local;\n use rt::task::Task;\n-use str;\n use str::{OwnedStr, StrSlice};\n+use str;\n use sys;\n+use uint;\n use unstable::raw;\n use vec::ImmutableVector;\n \n@@ -37,7 +38,7 @@ pub struct BorrowRecord {\n }\n \n fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    do Local::borrow::<Task, Option<~[BorrowRecord]>> |task| {\n+    do Local::borrow |task: &mut Task| {\n         task.borrow_list.take()\n     }\n }\n@@ -49,7 +50,7 @@ fn swap_task_borrow_list(f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n     };\n     let borrows = f(borrows);\n     let borrows = Cell::new(borrows);\n-    do Local::borrow::<Task, ()> |task| {\n+    do Local::borrow |task: &mut Task| {\n         task.borrow_list = Some(borrows.take());\n     }\n }\n@@ -93,28 +94,28 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n static ENABLE_DEBUG: bool = false;\n \n #[inline]\n-unsafe fn debug_borrow<T>(tag: &'static str,\n-                          p: *const T,\n-                          old_bits: uint,\n-                          new_bits: uint,\n-                          filename: *c_char,\n-                          line: size_t) {\n+unsafe fn debug_borrow<T,P:RawPtr<T>>(tag: &'static str,\n+                                      p: P,\n+                                      old_bits: uint,\n+                                      new_bits: uint,\n+                                      filename: *c_char,\n+                                      line: size_t) {\n     //! A useful debugging function that prints a pointer + tag + newline\n     //! without allocating memory.\n \n     if ENABLE_DEBUG && env::debug_borrow() {\n         debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n     }\n \n-    unsafe fn debug_borrow_slow<T>(tag: &'static str,\n-                                   p: *const T,\n-                                   old_bits: uint,\n-                                   new_bits: uint,\n-                                   filename: *c_char,\n-                                   line: size_t) {\n+    unsafe fn debug_borrow_slow<T,P:RawPtr<T>>(tag: &'static str,\n+                                               p: P,\n+                                               old_bits: uint,\n+                                               new_bits: uint,\n+                                               filename: *c_char,\n+                                               line: size_t) {\n         let dbg = STDERR_FILENO as io::fd_t;\n         dbg.write_str(tag);\n-        dbg.write_hex(p as uint);\n+        dbg.write_hex(p.to_uint());\n         dbg.write_str(\" \");\n         dbg.write_hex(old_bits);\n         dbg.write_str(\" \");"}, {"sha": "4b1881409f44f54e35f002342ee9bf23350e5411", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -159,7 +159,7 @@ impl<T> ChanOne<T> {\n                         };\n                     } else {\n                         let recvr = Cell::new(recvr);\n-                        do Local::borrow::<Scheduler, ()> |sched| {\n+                        do Local::borrow |sched: &mut Scheduler| {\n                             sched.enqueue_blocked_task(recvr.take());\n                         }\n                     }\n@@ -199,7 +199,7 @@ impl<T> PortOne<T> {\n         if !this.optimistic_check() {\n             // No data available yet.\n             // Switch to the scheduler to put the ~Task into the Packet state.\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             do sched.deschedule_running_task_and_then |sched, task| {\n                 this.block_on(sched, task);\n             }\n@@ -221,7 +221,7 @@ impl<T> SelectInner for PortOne<T> {\n         // The optimistic check is never necessary for correctness. For testing\n         // purposes, making it randomly return false simulates a racing sender.\n         use rand::{Rand};\n-        let actually_check = do Local::borrow::<Scheduler, bool> |sched| {\n+        let actually_check = do Local::borrow |sched: &mut Scheduler| {\n             Rand::rand(&mut sched.rng)\n         };\n         if actually_check {"}, {"sha": "f4e9c4d7c11b5aae208a71f72469b9040750a470", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -24,7 +24,7 @@ pub fn open<P: PathLike>(path: &P,\n                          access: FileAccess\n                         ) -> Option<FileStream> {\n     let open_result = unsafe {\n-        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n         (*io).fs_open(path, mode, access)\n     };\n     match open_result {\n@@ -43,7 +43,7 @@ pub fn open<P: PathLike>(path: &P,\n /// by `path`.\n pub fn unlink<P: PathLike>(path: &P) {\n     let unlink_result = unsafe {\n-        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n         (*io).fs_unlink(path)\n     };\n     match unlink_result {"}, {"sha": "d1d6b16e2eb3cd12cc368c38aba3cb1474f1d298", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -359,7 +359,7 @@ impl FromStr for SocketAddr {\n mod test {\n     use super::*;\n     use from_str::FromStr;\n-    use option::{Some, None};\n+    use option::{Option, Some, None};\n \n     #[test]\n     fn test_from_str_ipv4() {\n@@ -368,13 +368,17 @@ mod test {\n         assert_eq!(Some(Ipv4Addr(0, 0, 0, 0)), FromStr::from_str(\"0.0.0.0\"));\n \n         // out of range\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"256.0.0.1\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"256.0.0.1\");\n+        assert_eq!(None, none);\n         // too short\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0.0\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"255.0.0\");\n+        assert_eq!(None, none);\n         // too long\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0.0.1.2\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"255.0.0.1.2\");\n+        assert_eq!(None, none);\n         // no number between dots\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0..1\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"255.0..1\");\n+        assert_eq!(None, none);\n     }\n \n     #[test]\n@@ -389,15 +393,20 @@ mod test {\n                 FromStr::from_str(\"2a02:6b8::11:11\"));\n \n         // too long group\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"::00000\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"::00000\");\n+        assert_eq!(None, none);\n         // too short\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:3:4:5:6:7\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1:2:3:4:5:6:7\");\n+        assert_eq!(None, none);\n         // too long\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:3:4:5:6:7:8:9\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1:2:3:4:5:6:7:8:9\");\n+        assert_eq!(None, none);\n         // triple colon\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:::6:7:8\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1:2:::6:7:8\");\n+        assert_eq!(None, none);\n         // two double colons\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2::6::8\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1:2::6::8\");\n+        assert_eq!(None, none);\n     }\n \n     #[test]\n@@ -412,11 +421,15 @@ mod test {\n                 FromStr::from_str(\"2001:db8:122:c000:2:2100:192.0.2.33\"));\n \n         // colon after v4\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"::127.0.0.1:\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"::127.0.0.1:\");\n+        assert_eq!(None, none);\n         // not enought groups\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1.2.3.4.5:127.0.0.1\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1.2.3.4.5:127.0.0.1\");\n+        assert_eq!(None, none);\n         // too many groups\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1.2.3.4.5:6:7:127.0.0.1\"));\n+        let none: Option<IpAddr> =\n+            FromStr::from_str(\"1.2.3.4.5:6:7:127.0.0.1\");\n+        assert_eq!(None, none);\n     }\n \n     #[test]\n@@ -429,13 +442,17 @@ mod test {\n                 FromStr::from_str(\"[::127.0.0.1]:22\"));\n \n         // without port\n-        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1\"));\n+        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1\");\n+        assert_eq!(None, none);\n         // without port\n-        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1:\"));\n+        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1:\");\n+        assert_eq!(None, none);\n         // wrong brackets around v4\n-        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"[127.0.0.1]:22\"));\n+        let none: Option<SocketAddr> = FromStr::from_str(\"[127.0.0.1]:22\");\n+        assert_eq!(None, none);\n         // port out of range\n-        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1:123456\"));\n+        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1:123456\");\n+        assert_eq!(None, none);\n     }\n \n     #[test]"}, {"sha": "9be5540de484a96357c83b4f0fcc5f8068e569fc", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -29,7 +29,7 @@ impl TcpStream {\n     pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n         let stream = unsafe {\n             rtdebug!(\"borrowing io to connect\");\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             rtdebug!(\"about to connect\");\n             (*io).tcp_connect(addr)\n         };\n@@ -100,7 +100,7 @@ pub struct TcpListener(~RtioTcpListenerObject);\n impl TcpListener {\n     pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n         let listener = unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             (*io).tcp_bind(addr)\n         };\n         match listener {"}, {"sha": "132ca064515c1c867ecf141ad405750124b35dd5", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -20,7 +20,10 @@ pub struct UdpSocket(~RtioUdpSocketObject);\n \n impl UdpSocket {\n     pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n-        let socket = unsafe { (*Local::unsafe_borrow::<IoFactoryObject>()).udp_bind(addr) };\n+        let socket = unsafe {\n+            let factory: *mut IoFactoryObject = Local::unsafe_borrow();\n+            (*factory).udp_bind(addr)\n+        };\n         match socket {\n             Ok(s) => Some(UdpSocket(s)),\n             Err(ioerr) => {"}, {"sha": "7f2d88f994d8cc1fb891ecd438eb7f6e191a8014", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -22,7 +22,7 @@ impl Timer {\n     pub fn new() -> Option<Timer> {\n         let timer = unsafe {\n             rtdebug!(\"Timer::init: borrowing io to init timer\");\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             rtdebug!(\"about to init timer\");\n             (*io).timer_init()\n         };"}, {"sha": "d4f31879c003a01bd49bde2617f33727bbbafe37", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -19,7 +19,7 @@ use cell::Cell;\n pub trait Local {\n     fn put(value: ~Self);\n     fn take() -> ~Self;\n-    fn exists() -> bool;\n+    fn exists(unused_value: Option<Self>) -> bool;\n     fn borrow<T>(f: &fn(&mut Self) -> T) -> T;\n     unsafe fn unsafe_take() -> ~Self;\n     unsafe fn unsafe_borrow() -> *mut Self;\n@@ -31,7 +31,7 @@ impl Local for Task {\n     fn put(value: ~Task) { unsafe { local_ptr::put(value) } }\n     #[inline]\n     fn take() -> ~Task { unsafe { local_ptr::take() } }\n-    fn exists() -> bool { local_ptr::exists() }\n+    fn exists(_: Option<Task>) -> bool { local_ptr::exists() }\n     fn borrow<T>(f: &fn(&mut Task) -> T) -> T {\n         let mut res: Option<T> = None;\n         let res_ptr: *mut Option<T> = &mut res;\n@@ -59,7 +59,7 @@ impl Local for Task {\n impl Local for Scheduler {\n     fn put(value: ~Scheduler) {\n         let value = Cell::new(value);\n-        do Local::borrow::<Task,()> |task| {\n+        do Local::borrow |task: &mut Task| {\n             let task = task;\n             task.sched = Some(value.take());\n         };\n@@ -68,20 +68,20 @@ impl Local for Scheduler {\n     fn take() -> ~Scheduler {\n         unsafe {\n             // XXX: Unsafe for speed\n-            let task = Local::unsafe_borrow::<Task>();\n+            let task: *mut Task = Local::unsafe_borrow();\n             (*task).sched.take_unwrap()\n         }\n     }\n-    fn exists() -> bool {\n-        do Local::borrow::<Task,bool> |task| {\n+    fn exists(_: Option<Scheduler>) -> bool {\n+        do Local::borrow |task: &mut Task| {\n             match task.sched {\n                 Some(ref _task) => true,\n                 None => false\n             }\n         }\n     }\n     fn borrow<T>(f: &fn(&mut Scheduler) -> T) -> T {\n-        do Local::borrow::<Task, T> |task| {\n+        do Local::borrow |task: &mut Task| {\n             match task.sched {\n                 Some(~ref mut task) => {\n                     f(task)\n@@ -94,7 +94,8 @@ impl Local for Scheduler {\n     }\n     unsafe fn unsafe_take() -> ~Scheduler { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut Scheduler {\n-        match (*Local::unsafe_borrow::<Task>()).sched {\n+        let task: *mut Task = Local::unsafe_borrow();\n+        match (*task).sched {\n             Some(~ref mut sched) => {\n                 let s: *mut Scheduler = &mut *sched;\n                 return s;\n@@ -105,7 +106,8 @@ impl Local for Scheduler {\n         }\n     }\n     unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> {\n-        match Local::try_unsafe_borrow::<Task>() {\n+        let task_opt: Option<*mut Task> = Local::try_unsafe_borrow();\n+        match task_opt {\n             Some(task) => {\n                 match (*task).sched {\n                     Some(~ref mut sched) => {\n@@ -124,15 +126,17 @@ impl Local for Scheduler {\n impl Local for IoFactoryObject {\n     fn put(_value: ~IoFactoryObject) { rtabort!(\"unimpl\") }\n     fn take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n-    fn exists() -> bool { rtabort!(\"unimpl\") }\n+    fn exists(_: Option<IoFactoryObject>) -> bool { rtabort!(\"unimpl\") }\n     fn borrow<T>(_f: &fn(&mut IoFactoryObject) -> T) -> T { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut IoFactoryObject {\n-        let sched = Local::unsafe_borrow::<Scheduler>();\n+        let sched: *mut Scheduler = Local::unsafe_borrow();\n         let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n         return io;\n     }\n-    unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> { rtabort!(\"unimpl\") }\n+    unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> {\n+        rtabort!(\"unimpl\")\n+    }\n }\n \n \n@@ -198,7 +202,7 @@ mod test {\n             let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n             Local::put(task);\n \n-            let res = do Local::borrow::<Task,bool> |_task| {\n+            let res = do Local::borrow |_task: &mut Task| {\n                 true\n             };\n             assert!(res)"}, {"sha": "12ec19a1ecc67af345c332a072da5055da186c87", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -13,7 +13,7 @@\n use libc;\n use libc::{c_void, uintptr_t, size_t};\n use ops::Drop;\n-use option::{Some, None};\n+use option::{Option, None, Some};\n use rt::local::Local;\n use rt::task::Task;\n use unstable::raw;\n@@ -89,7 +89,8 @@ impl Drop for LocalHeap {\n // A little compatibility function\n pub unsafe fn local_free(ptr: *libc::c_char) {\n     // XXX: Unsafe borrow for speed. Lame.\n-    match Local::try_unsafe_borrow::<Task>() {\n+    let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n+    match task_ptr {\n         Some(task) => {\n             (*task).heap.free(ptr as *libc::c_void);\n         }\n@@ -98,7 +99,7 @@ pub unsafe fn local_free(ptr: *libc::c_char) {\n }\n \n pub fn live_allocs() -> *raw::Box<()> {\n-    let region = do Local::borrow::<Task, *BoxedRegion> |task| {\n+    let region = do Local::borrow |task: &mut Task| {\n         task.heap.boxed_region\n     };\n "}, {"sha": "6dbeb8c0ea9271d091e60c282aeccfb8a706393c", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -64,7 +64,7 @@ use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iterator::{Iterator, range};\n-use option::{Some, None};\n+use option::{Option, None, Some};\n use ptr::RawPtr;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown};\n@@ -408,7 +408,8 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n pub fn in_sched_context() -> bool {\n     unsafe {\n-        match Local::try_unsafe_borrow::<Task>() {\n+        let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n+        match task_ptr {\n             Some(task) => {\n                 match (*task).task_type {\n                     SchedTask => true,\n@@ -422,7 +423,8 @@ pub fn in_sched_context() -> bool {\n \n pub fn in_green_task_context() -> bool {\n     unsafe {\n-        match Local::try_unsafe_borrow::<Task>() {\n+        let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+        match task {\n             Some(task) => {\n                 match (*task).task_type {\n                     GreenTask(_) => true,"}, {"sha": "b393832871dd7dae2074f028d5fafea4c8fa612c", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -169,13 +169,13 @@ impl Scheduler {\n         // successfully run the input task. Start by running the\n         // scheduler. Grab it out of TLS - performing the scheduler\n         // action will have given it away.\n-        let sched = Local::take::<Scheduler>();\n+        let sched: ~Scheduler = Local::take();\n \n         rtdebug!(\"starting scheduler %u\", sched.sched_id());\n         sched.run();\n \n         // Close the idle callback.\n-        let mut sched = Local::take::<Scheduler>();\n+        let mut sched: ~Scheduler = Local::take();\n         sched.idle_callback.get_mut_ref().close();\n         // Make one go through the loop to run the close callback.\n         sched.run();\n@@ -185,7 +185,7 @@ impl Scheduler {\n         // cleaning up the memory it uses. As we didn't actually call\n         // task.run() on the scheduler task we never get through all\n         // the cleanup code it runs.\n-        let mut stask = Local::take::<Task>();\n+        let mut stask: ~Task = Local::take();\n \n         rtdebug!(\"stopping scheduler %u\", stask.sched.get_ref().sched_id());\n \n@@ -212,7 +212,7 @@ impl Scheduler {\n             // Our scheduler must be in the task before the event loop\n             // is started.\n             let self_sched = Cell::new(self_sched);\n-            do Local::borrow::<Task,()> |stask| {\n+            do Local::borrow |stask: &mut Task| {\n                 stask.sched = Some(self_sched.take());\n             };\n \n@@ -234,7 +234,7 @@ impl Scheduler {\n         // already have a scheduler stored in our local task, so we\n         // start off by taking it. This is the only path through the\n         // scheduler where we get the scheduler this way.\n-        let mut sched = Local::take::<Scheduler>();\n+        let mut sched: ~Scheduler = Local::take();\n \n         // Assume that we need to continue idling unless we reach the\n         // end of this function without performing an action.\n@@ -522,7 +522,7 @@ impl Scheduler {\n         // The current task is grabbed from TLS, not taken as an input.\n         // Doing an unsafe_take to avoid writing back a null pointer -\n         // We're going to call `put` later to do that.\n-        let current_task: ~Task = unsafe { Local::unsafe_take::<Task>() };\n+        let current_task: ~Task = unsafe { Local::unsafe_take() };\n \n         // Check that the task is not in an atomically() section (e.g.,\n         // holding a pthread mutex, which could deadlock the scheduler).\n@@ -554,7 +554,8 @@ impl Scheduler {\n \n             let current_task: &mut Task = match sched.cleanup_job {\n                 Some(CleanupJob { task: ref task, _ }) => {\n-                    transmute_mut_region(*transmute_mut_unsafe(task))\n+                    let task_ptr: *~Task = task;\n+                    transmute_mut_region(*transmute_mut_unsafe(task_ptr))\n                 }\n                 None => {\n                     rtabort!(\"no cleanup job\");\n@@ -580,7 +581,7 @@ impl Scheduler {\n         // run the cleanup job, as expected by the previously called\n         // swap_contexts function.\n         unsafe {\n-            let task = Local::unsafe_borrow::<Task>();\n+            let task: *mut Task = Local::unsafe_borrow();\n             (*task).sched.get_mut_ref().run_cleanup_job();\n \n             // Must happen after running the cleanup job (of course).\n@@ -685,13 +686,13 @@ impl Scheduler {\n     }\n \n     pub fn run_task(task: ~Task) {\n-        let sched = Local::take::<Scheduler>();\n+        let sched: ~Scheduler = Local::take();\n         sched.process_task(task, Scheduler::switch_task).map_move(Local::put);\n     }\n \n     pub fn run_task_later(next_task: ~Task) {\n         let next_task = Cell::new(next_task);\n-        do Local::borrow::<Scheduler,()> |sched| {\n+        do Local::borrow |sched: &mut Scheduler| {\n             sched.enqueue_task(next_task.take());\n         };\n     }\n@@ -1023,12 +1024,12 @@ mod test {\n         // exit before emptying the work queue\n         do run_in_newsched_task {\n             do spawntask {\n-                let sched = Local::take::<Scheduler>();\n+                let sched: ~Scheduler = Local::take();\n                 do sched.deschedule_running_task_and_then |sched, task| {\n                     let task = Cell::new(task);\n                     do sched.event_loop.callback_ms(10) {\n                         rtdebug!(\"in callback\");\n-                        let mut sched = Local::take::<Scheduler>();\n+                        let mut sched: ~Scheduler = Local::take();\n                         sched.enqueue_blocked_task(task.take());\n                         Local::put(sched);\n                     }"}, {"sha": "6cde0a1f2169f5f6f47c38040d1dc15570e5f7f4", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -26,3 +26,4 @@ pub trait SelectInner {\n pub trait SelectPortInner<T> {\n     fn recv_ready(self) -> Option<T>;\n }\n+"}, {"sha": "b1ab7a6cd5d3eb0b96b9f91dbc6baa7dd36ad70c", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -93,7 +93,7 @@ impl Task {\n     pub fn build_homed_child(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n-        do Local::borrow::<Task, ~Task> |running_task| {\n+        do Local::borrow |running_task: &mut Task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~running_task.new_child_homed(&mut sched.stack_pool,\n                                                          stack_size,\n@@ -111,7 +111,7 @@ impl Task {\n     pub fn build_homed_root(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n-        do Local::borrow::<Task, ~Task> |running_task| {\n+        do Local::borrow |running_task: &mut Task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n                                                  stack_size,\n@@ -305,7 +305,7 @@ impl Task {\n     // Grab both the scheduler and the task from TLS and check if the\n     // task is executing on an appropriate scheduler.\n     pub fn on_appropriate_sched() -> bool {\n-        do Local::borrow::<Task,bool> |task| {\n+        do Local::borrow |task: &mut Task| {\n             let sched_id = task.sched.get_ref().sched_id();\n             let sched_run_anything = task.sched.get_ref().run_anything;\n             match task.task_type {\n@@ -369,7 +369,7 @@ impl Coroutine {\n             unsafe {\n \n                 // Again - might work while safe, or it might not.\n-                do Local::borrow::<Scheduler,()> |sched| {\n+                do Local::borrow |sched: &mut Scheduler| {\n                     sched.run_cleanup_job();\n                 }\n \n@@ -378,7 +378,7 @@ impl Coroutine {\n                 // simply unsafe_borrow it to get this reference. We\n                 // need to still have the task in TLS though, so we\n                 // need to unsafe_borrow.\n-                let task = Local::unsafe_borrow::<Task>();\n+                let task: *mut Task = Local::unsafe_borrow();\n \n                 do (*task).run {\n                     // N.B. Removing `start` from the start wrapper\n@@ -397,7 +397,7 @@ impl Coroutine {\n             }\n \n             // We remove the sched from the Task in TLS right now.\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             // ... allowing us to give it away when performing a\n             // scheduling operation.\n             sched.terminate_current_task()"}, {"sha": "b8e535e4c7dfd3ac202427402039dcf6f58e39e2", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -51,7 +51,7 @@ impl<T> Tube<T> {\n                 // There's a waiting task. Wake it up\n                 rtdebug!(\"waking blocked tube\");\n                 let task = (*state).blocked_task.take_unwrap();\n-                let sched = Local::take::<Scheduler>();\n+                let sched: ~Scheduler = Local::take();\n                 sched.resume_blocked_task_immediately(task);\n             }\n         }\n@@ -67,7 +67,7 @@ impl<T> Tube<T> {\n                 rtdebug!(\"blocking on tube recv\");\n                 assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n                 assert!((*state).blocked_task.is_none());\n-                let sched = Local::take::<Scheduler>();\n+                let sched: ~Scheduler = Local::take();\n                 do sched.deschedule_running_task_and_then |_, task| {\n                     (*state).blocked_task = Some(task);\n                 }\n@@ -102,7 +102,7 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone_cell = Cell::new(tube_clone);\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             do sched.deschedule_running_task_and_then |sched, task| {\n                 let mut tube_clone = tube_clone_cell.take();\n                 tube_clone.send(1);\n@@ -119,7 +119,7 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone = Cell::new(tube_clone);\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             do sched.deschedule_running_task_and_then |sched, task| {\n                 let tube_clone = Cell::new(tube_clone.take());\n                 do sched.event_loop.callback {\n@@ -143,15 +143,15 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone = Cell::new(tube_clone);\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             do sched.deschedule_running_task_and_then |sched, task| {\n                 callback_send(tube_clone.take(), 0);\n \n                 fn callback_send(tube: Tube<int>, i: int) {\n                     if i == 100 { return; }\n \n                     let tube = Cell::new(Cell::new(tube));\n-                    do Local::borrow::<Scheduler, ()> |sched| {\n+                    do Local::borrow |sched: &mut Scheduler| {\n                         let tube = tube.take();\n                         do sched.event_loop.callback {\n                             let mut tube = tube.take();"}, {"sha": "e620ab274b1ed238737f1a63625db5d935463caa", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 62, "deletions": 54, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -57,7 +57,7 @@ trait HomingIO {\n         let old_home = Cell::new_empty();\n         let old_home_ptr = &old_home;\n         do task::unkillable { // FIXME(#8674)\n-            let scheduler = Local::take::<Scheduler>();\n+            let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 // get the old home first\n                 do task.wake().map_move |mut task| {\n@@ -72,7 +72,7 @@ trait HomingIO {\n \n         // unhome home\n         do task::unkillable { // FIXME(#8674)\n-            let scheduler = Local::take::<Scheduler>();\n+            let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |scheduler, task| {\n                 do task.wake().map_move |mut task| {\n                     task.give_home(old_home.take());\n@@ -92,7 +92,7 @@ trait HomingIO {\n             // go home\n             let old_home = Cell::new_empty();\n             let old_home_ptr = &old_home;\n-            let scheduler = Local::take::<Scheduler>();\n+            let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 // get the old home first\n                 do task.wake().map_move |mut task| {\n@@ -102,11 +102,11 @@ trait HomingIO {\n             }\n \n             // do IO\n-            let scheduler = Local::take::<Scheduler>();\n+            let scheduler: ~Scheduler = Local::take();\n             let a = io_sched(self, scheduler);\n \n             // unhome home\n-            let scheduler = Local::take::<Scheduler>();\n+            let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |scheduler, task| {\n                 do task.wake().map_move |mut task| {\n                     task.give_home(old_home.take());\n@@ -122,7 +122,7 @@ trait HomingIO {\n \n // get a handle for the current scheduler\n macro_rules! get_handle_to_current_scheduler(\n-    () => (do Local::borrow::<Scheduler, SchedHandle> |sched| { sched.make_handle() })\n+    () => (do Local::borrow |sched: &mut Scheduler| { sched.make_handle() })\n )\n \n enum SocketNameKind {\n@@ -375,7 +375,7 @@ mod test_remote {\n             let mut tube = Tube::new();\n             let tube_clone = tube.clone();\n             let remote_cell = Cell::new_empty();\n-            do Local::borrow::<Scheduler, ()>() |sched| {\n+            do Local::borrow |sched: &mut Scheduler| {\n                 let tube_clone = tube_clone.clone();\n                 let tube_clone_cell = Cell::new(tube_clone);\n                 let remote = do sched.event_loop.remote_callback {\n@@ -416,7 +416,7 @@ impl IoFactory for UvIoFactory {\n \n         // Block this task and take ownership, switch to scheduler context\n         do task::unkillable { // FIXME(#8674)\n-            let scheduler = Local::take::<Scheduler>();\n+            let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n \n                 let mut tcp = TcpWatcher::new(self.uv_loop());\n@@ -434,15 +434,15 @@ impl IoFactory for UvIoFactory {\n                             unsafe { (*result_cell_ptr).put_back(res); }\n \n                             // Context switch\n-                            let scheduler = Local::take::<Scheduler>();\n+                            let scheduler: ~Scheduler = Local::take();\n                             scheduler.resume_blocked_task_immediately(task_cell.take());\n                         }\n                         Some(_) => {\n                             let task_cell = Cell::new(task_cell.take());\n                             do stream.close {\n                                 let res = Err(uv_error_to_io_error(status.unwrap()));\n                                 unsafe { (*result_cell_ptr).put_back(res); }\n-                                let scheduler = Local::take::<Scheduler>();\n+                                let scheduler: ~Scheduler = Local::take();\n                                 scheduler.resume_blocked_task_immediately(task_cell.take());\n                             }\n                         }\n@@ -464,11 +464,11 @@ impl IoFactory for UvIoFactory {\n             }\n             Err(uverr) => {\n                 do task::unkillable { // FIXME(#8674)\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     do scheduler.deschedule_running_task_and_then |_, task| {\n                         let task_cell = Cell::new(task);\n                         do watcher.as_stream().close {\n-                            let scheduler = Local::take::<Scheduler>();\n+                            let scheduler: ~Scheduler = Local::take();\n                             scheduler.resume_blocked_task_immediately(task_cell.take());\n                         }\n                     }\n@@ -487,11 +487,11 @@ impl IoFactory for UvIoFactory {\n             }\n             Err(uverr) => {\n                 do task::unkillable { // FIXME(#8674)\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     do scheduler.deschedule_running_task_and_then |_, task| {\n                         let task_cell = Cell::new(task);\n                         do watcher.close {\n-                            let scheduler = Local::take::<Scheduler>();\n+                            let scheduler: ~Scheduler = Local::take();\n                             scheduler.resume_blocked_task_immediately(task_cell.take());\n                         }\n                     }\n@@ -539,7 +539,7 @@ impl IoFactory for UvIoFactory {\n                                            IoError>> = &result_cell;\n         let path_cell = Cell::new(path);\n         do task::unkillable { // FIXME(#8674)\n-            let scheduler = Local::take::<Scheduler>();\n+            let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n@@ -553,12 +553,12 @@ impl IoFactory for UvIoFactory {\n                             loop_, fd, true, home) as ~RtioFileStream;\n                         let res = Ok(fs);\n                         unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler = Local::take::<Scheduler>();\n+                        let scheduler: ~Scheduler = Local::take();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());\n                     } else {\n                         let res = Err(uv_error_to_io_error(err.unwrap()));\n                         unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler = Local::take::<Scheduler>();\n+                        let scheduler: ~Scheduler = Local::take();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());\n                     }\n                 };\n@@ -573,7 +573,7 @@ impl IoFactory for UvIoFactory {\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let path_cell = Cell::new(path);\n         do task::unkillable { // FIXME(#8674)\n-            let scheduler = Local::take::<Scheduler>();\n+            let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n@@ -583,7 +583,7 @@ impl IoFactory for UvIoFactory {\n                         Some(err) => Err(uv_error_to_io_error(err))\n                     };\n                     unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 };\n             };\n@@ -625,7 +625,7 @@ impl Drop for UvTcpListener {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher().as_stream().close {\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -717,7 +717,7 @@ impl Drop for UvTcpStream {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.as_stream().close {\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -765,7 +765,7 @@ impl RtioTcpStream for UvTcpStream {\n \n                     unsafe { (*result_cell_ptr).put_back(result); }\n \n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -793,7 +793,7 @@ impl RtioTcpStream for UvTcpStream {\n \n                     unsafe { (*result_cell_ptr).put_back(result); }\n \n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -876,7 +876,7 @@ impl Drop for UvUdpSocket {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.close {\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -917,7 +917,7 @@ impl RtioUdpSocket for UvUdpSocket {\n \n                     unsafe { (*result_cell_ptr).put_back(result); }\n \n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -944,7 +944,7 @@ impl RtioUdpSocket for UvUdpSocket {\n \n                     unsafe { (*result_cell_ptr).put_back(result); }\n \n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -1094,7 +1094,7 @@ impl Drop for UvTimer {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.close {\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -1110,7 +1110,7 @@ impl RtioTimer for UvTimer {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.start(msecs, 0) |_, status| {\n                     assert!(status.is_none());\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -1154,7 +1154,7 @@ impl UvFileStream {\n                         Some(err) => Err(uv_error_to_io_error(err))\n                     };\n                     unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 };\n             };\n@@ -1175,7 +1175,7 @@ impl UvFileStream {\n                         Some(err) => Err(uv_error_to_io_error(err))\n                     };\n                     unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 };\n             };\n@@ -1208,7 +1208,7 @@ impl Drop for UvFileStream {\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     let task_cell = Cell::new(task);\n                     do self_.fd.close(&self.loop_) |_,_| {\n-                        let scheduler = Local::take::<Scheduler>();\n+                        let scheduler: ~Scheduler = Local::take();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());\n                     };\n                 };\n@@ -1254,7 +1254,7 @@ impl RtioFileStream for UvFileStream {\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n         unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             let addr = next_test_ip4();\n             let maybe_chan = (*io).tcp_connect(addr);\n             assert!(maybe_chan.is_err());\n@@ -1266,7 +1266,7 @@ fn test_simple_io_no_connect() {\n fn test_simple_udp_io_bind_only() {\n     do run_in_newsched_task {\n         unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             let addr = next_test_ip4();\n             let maybe_socket = (*io).udp_bind(addr);\n             assert!(maybe_socket.is_ok());\n@@ -1303,15 +1303,17 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n         };\n \n         let test_function: ~fn() = || {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe {\n+                Local::unsafe_borrow()\n+            };\n             let addr = next_test_ip4();\n             let maybe_socket = unsafe { (*io).udp_bind(addr) };\n             // this socket is bound to this event loop\n             assert!(maybe_socket.is_ok());\n \n             // block self on sched1\n             do task::unkillable { // FIXME(#8674)\n-                let scheduler = Local::take::<Scheduler>();\n+                let scheduler: ~Scheduler = Local::take();\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     // unblock task\n                     do task.wake().map_move |task| {\n@@ -1377,7 +1379,9 @@ fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n         let chan = Cell::new(chan);\n \n         let body1: ~fn() = || {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe {\n+                Local::unsafe_borrow()\n+            };\n             let addr = next_test_ip4();\n             let socket = unsafe { (*io).udp_bind(addr) };\n             assert!(socket.is_ok());\n@@ -1430,7 +1434,7 @@ fn test_simple_tcp_server_and_client() {\n         // Start the server first so it's listening when we connect\n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n                 let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n@@ -1445,7 +1449,7 @@ fn test_simple_tcp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             }\n@@ -1489,7 +1493,9 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         };\n \n         let server_fn: ~fn() = || {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe {\n+                Local::unsafe_borrow()\n+            };\n             let mut listener = unsafe { (*io).tcp_bind(server_addr).unwrap() };\n             let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n@@ -1501,7 +1507,9 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         };\n \n         let client_fn: ~fn() = || {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe {\n+                Local::unsafe_borrow()\n+            };\n             let mut stream = unsafe { (*io).tcp_connect(client_addr) };\n             while stream.is_err() {\n                 stream = unsafe { (*io).tcp_connect(client_addr) };\n@@ -1540,7 +1548,7 @@ fn test_simple_udp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut server_socket = (*io).udp_bind(server_addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let (nread,src) = server_socket.recvfrom(buf).unwrap();\n@@ -1555,7 +1563,7 @@ fn test_simple_udp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut client_socket = (*io).udp_bind(client_addr).unwrap();\n                 client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n             }\n@@ -1569,7 +1577,7 @@ fn test_read_and_block() {\n         let addr = next_test_ip4();\n \n         do spawntask {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe { Local::unsafe_borrow() };\n             let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n             let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n@@ -1588,7 +1596,7 @@ fn test_read_and_block() {\n                 reads += 1;\n \n                 do task::unkillable { // FIXME(#8674)\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     // Yield to the other task in hopes that it\n                     // will trigger a read callback while we are\n                     // not ready for it\n@@ -1605,7 +1613,7 @@ fn test_read_and_block() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -1625,7 +1633,7 @@ fn test_read_read_read() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n                 let mut stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n@@ -1639,7 +1647,7 @@ fn test_read_read_read() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let mut total_bytes_read = 0;\n@@ -1665,7 +1673,7 @@ fn test_udp_twice() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut client = (*io).udp_bind(client_addr).unwrap();\n                 assert!(client.sendto([1], server_addr).is_ok());\n                 assert!(client.sendto([2], server_addr).is_ok());\n@@ -1674,7 +1682,7 @@ fn test_udp_twice() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut server = (*io).udp_bind(server_addr).unwrap();\n                 let mut buf1 = [0];\n                 let mut buf2 = [0];\n@@ -1702,7 +1710,7 @@ fn test_udp_many_read() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut server_out = (*io).udp_bind(server_out_addr).unwrap();\n                 let mut server_in = (*io).udp_bind(server_in_addr).unwrap();\n                 let msg = [1, .. 2048];\n@@ -1725,7 +1733,7 @@ fn test_udp_many_read() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut client_out = (*io).udp_bind(client_out_addr).unwrap();\n                 let mut client_in = (*io).udp_bind(client_in_addr).unwrap();\n                 let mut total_bytes_recv = 0;\n@@ -1754,7 +1762,7 @@ fn test_udp_many_read() {\n fn test_timer_sleep_simple() {\n     do run_in_newsched_task {\n         unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             let timer = (*io).timer_init();\n             do timer.map_move |mut t| { t.sleep(1) };\n         }\n@@ -1768,7 +1776,7 @@ fn file_test_uvio_full_simple_impl() {\n     use path::Path;\n     use rt::io::{Open, Create, ReadWrite, Read};\n     unsafe {\n-        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n         let write_val = \"hello uvio!\";\n         let path = \"./tmp/file_test_uvio_full.txt\";\n         {\n@@ -1802,7 +1810,7 @@ fn uvio_naive_print(input: &str) {\n     use str::StrSlice;\n     unsafe {\n         use libc::{STDOUT_FILENO};\n-        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n         {\n             let mut fd = (*io).fs_from_raw_fd(STDOUT_FILENO, false);\n             let write_buf = input.as_bytes();"}, {"sha": "f121158d4c525cfe02254028531fb6bb0815bd9b", "filename": "src/libstd/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -60,7 +60,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n \n     do (|| {\n         let c = Cell::new(c.take());\n-        let sched = Local::take::<Scheduler>();\n+        let sched: ~Scheduler = Local::take();\n         do sched.deschedule_running_task_and_then |sched, task| {\n             let task_handles = task.make_selectable(ports.len());\n "}, {"sha": "cb0753fb2e5dee4a45ea3a8d8bbbf871a3857a83", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -143,7 +143,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n         if in_green_task_context() {\n             // XXX: Logging doesn't work here - the check to call the log\n             // function never passes - so calling the log function directly.\n-            do Local::borrow::<Task, ()> |task| {\n+            do Local::borrow |task: &mut Task| {\n                 let msg = match task.name {\n                     Some(ref name) =>\n                     fmt!(\"task '%s' failed at '%s', %s:%i\",\n@@ -160,7 +160,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                      msg, file, line as int);\n         }\n \n-        let task = Local::unsafe_borrow::<Task>();\n+        let task: *mut Task = Local::unsafe_borrow();\n         if (*task).unwinder.unwinding {\n             rtabort!(\"unwinding again\");\n         }"}, {"sha": "2c2dfd8f689c2915cb59aa0a5a198273f27dd6a3", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -28,7 +28,7 @@ impl Handle {\n     pub fn new() -> Handle {\n         use rt::local::Local;\n         unsafe {\n-            let task = Local::unsafe_borrow::<Task>();\n+            let task: *mut Task = Local::unsafe_borrow();\n             NewHandle(&mut (*task).storage)\n         }\n     }"}, {"sha": "c0b331c52eeb0715412171f323aed79f7cda0cab", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -526,7 +526,7 @@ pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n     use rt::task::Task;\n \n     if in_green_task_context() {\n-        do Local::borrow::<Task, U> |task| {\n+        do Local::borrow |task: &mut Task| {\n             match task.name {\n                 Some(ref name) => blk(Some(name.as_slice())),\n                 None => blk(None)\n@@ -545,7 +545,7 @@ pub fn deschedule() {\n \n     // FIXME #6842: What does yield really mean in newsched?\n     // FIXME(#7544): Optimize this, since we know we won't block.\n-    let sched = Local::take::<Scheduler>();\n+    let sched: ~Scheduler = Local::take();\n     do sched.deschedule_running_task_and_then |sched, task| {\n         sched.enqueue_blocked_task(task);\n     }\n@@ -556,7 +556,7 @@ pub fn failing() -> bool {\n \n     use rt::task::Task;\n \n-    do Local::borrow::<Task, bool> |local| {\n+    do Local::borrow |local: &mut Task| {\n         local.unwinder.unwinding\n     }\n }\n@@ -582,7 +582,7 @@ pub fn unkillable<U>(f: &fn() -> U) -> U {\n     unsafe {\n         if in_green_task_context() {\n             // The inhibits/allows might fail and need to borrow the task.\n-            let t = Local::unsafe_borrow::<Task>();\n+            let t: *mut Task = Local::unsafe_borrow();\n             do (|| {\n                 (*t).death.inhibit_kill((*t).unwinder.unwinding);\n                 f()\n@@ -616,7 +616,7 @@ pub fn rekillable<U>(f: &fn() -> U) -> U {\n \n     unsafe {\n         if in_green_task_context() {\n-            let t = Local::unsafe_borrow::<Task>();\n+            let t: *mut Task = Local::unsafe_borrow();\n             do (|| {\n                 (*t).death.allow_kill((*t).unwinder.unwinding);\n                 f()\n@@ -1032,7 +1032,7 @@ fn test_try_fail() {\n \n #[cfg(test)]\n fn get_sched_id() -> int {\n-    do Local::borrow::<::rt::sched::Scheduler, int> |sched| {\n+    do Local::borrow |sched: &mut ::rt::sched::Scheduler| {\n         sched.sched_id() as int\n     }\n }"}, {"sha": "c3a3dc56ce2330de23a04374d359a7de753b0148", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -449,7 +449,7 @@ impl RuntimeGlue {\n     fn kill_task(mut handle: KillHandle) {\n         do handle.kill().map_move |killed_task| {\n             let killed_task = Cell::new(killed_task);\n-            do Local::borrow::<Scheduler, ()> |sched| {\n+            do Local::borrow |sched: &mut Scheduler| {\n                 sched.enqueue_task(killed_task.take());\n             }\n         };\n@@ -460,7 +460,7 @@ impl RuntimeGlue {\n         unsafe {\n             // Can't use safe borrow, because the taskgroup destructor needs to\n             // access the scheduler again to send kill signals to other tasks.\n-            let me = Local::unsafe_borrow::<Task>();\n+            let me: *mut Task = Local::unsafe_borrow();\n             blk((*me).death.kill_handle.get_ref(), (*me).unwinder.unwinding)\n         }\n     }\n@@ -470,7 +470,7 @@ impl RuntimeGlue {\n         unsafe {\n             // Can't use safe borrow, because creating new hashmaps for the\n             // tasksets requires an rng, which needs to borrow the sched.\n-            let me = Local::unsafe_borrow::<Task>();\n+            let me: *mut Task = Local::unsafe_borrow();\n             blk(match (*me).taskgroup {\n                 None => {\n                     // First task in its (unlinked/unsupervised) taskgroup.\n@@ -574,7 +574,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n         // If child data is 'None', the enlist is vacuously successful.\n         let enlist_success = do child_data.take().map_move_default(true) |child_data| {\n             let child_data = Cell::new(child_data); // :(\n-            do Local::borrow::<Task, bool> |me| {\n+            do Local::borrow |me: &mut Task| {\n                 let (child_tg, ancestors) = child_data.take();\n                 let mut ancestors = ancestors;\n                 let handle = me.death.kill_handle.get_ref();\n@@ -608,7 +608,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n     } else {\n         unsafe {\n             // Creating a 1:1 task:thread ...\n-            let sched = Local::unsafe_borrow::<Scheduler>();\n+            let sched: *mut Scheduler = Local::unsafe_borrow();\n             let sched_handle = (*sched).make_handle();\n \n             // Since this is a 1:1 scheduler we create a queue not in"}, {"sha": "01f57c231dadef53cdab7b5ae1e8b05a6ead16b5", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -343,7 +343,14 @@ impl<A:IterBytes> IterBytes for ~A {\n \n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n-impl<A> IterBytes for *const A {\n+impl<A> IterBytes for *A {\n+    #[inline]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl<A> IterBytes for *mut A {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)"}, {"sha": "5d9ca6202e26293b47fef8cf4e0b26c6ec35a73c", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -176,7 +176,7 @@ macro_rules! tuple_impls {\n                 impl<$($T:Zero),+> Zero for ($($T,)+) {\n                     #[inline]\n                     fn zero() -> ($($T,)+) {\n-                        ($(Zero::zero::<$T>(),)+)\n+                        ($({ let x: $T = Zero::zero(); x},)+)\n                     }\n                     #[inline]\n                     fn is_zero(&self) -> bool {"}, {"sha": "f9380e7ad1241fd2f6bf7c3bc9c99d51218a2e9b", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -538,7 +538,8 @@ mod test {\n \n     #[test]\n     fn option_empty() {\n-        assert!(AtomicOption::empty::<()>().is_empty(SeqCst));\n+        let mut option: AtomicOption<()> = AtomicOption::empty();\n+        assert!(option.is_empty(SeqCst));\n     }\n \n     #[test]"}, {"sha": "1d839b55195be9c7bc436d1d001238b69f70bc54", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -13,7 +13,7 @@\n use c_str::ToCStr;\n use cast::transmute;\n use libc::{c_char, c_void, size_t, uintptr_t};\n-use option::{Some, None};\n+use option::{Option, None, Some};\n use sys;\n use rt::task::Task;\n use rt::local::Local;\n@@ -37,7 +37,8 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n #[lang=\"malloc\"]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     // XXX: Unsafe borrow for speed. Lame.\n-    match Local::try_unsafe_borrow::<Task>() {\n+    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+    match task {\n         Some(task) => {\n             (*task).heap.alloc(td as *c_void, size as uint) as *c_char\n         }"}, {"sha": "8d1545ea2b4506061f8c1d1c48c3bf2b3af34a3b", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -279,7 +279,8 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     use rt::task::{Task, GreenTask, SchedTask};\n     use rt::local::Local;\n \n-    match Local::try_unsafe_borrow::<Task>() {\n+    let task_opt: Option<*mut Task> = Local::try_unsafe_borrow();\n+    match task_opt {\n         Some(t) => {\n             match (*t).task_type {\n                 GreenTask(_) => {"}, {"sha": "5085f337d4bba216103ddf9f17c1505dca509123", "filename": "src/libstd/util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -54,8 +54,10 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n         let t: *mut T = &mut tmp;\n \n         // Perform the swap, `&mut` pointers never alias\n-        ptr::copy_nonoverlapping_memory(t, x, 1);\n-        ptr::copy_nonoverlapping_memory(x, y, 1);\n+        let x_raw: *mut T = x;\n+        let y_raw: *mut T = y;\n+        ptr::copy_nonoverlapping_memory(t, x_raw, 1);\n+        ptr::copy_nonoverlapping_memory(x, y_raw, 1);\n         ptr::copy_nonoverlapping_memory(y, t, 1);\n \n         // y and t now point to the same thing, but we need to completely forget `tmp`"}, {"sha": "8cd1b09468d46c721755f9e5cabc95335351be25", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -1122,14 +1122,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      * foreign interop.\n      */\n     #[inline]\n-    fn as_imm_buf<U>(&self,\n-                     /* NB---this CANNOT be const, see below */\n-                     f: &fn(*T, uint) -> U) -> U {\n-        // NB---Do not change the type of s to `&const [T]`.  This is\n-        // unsound.  The reason is that we are going to create immutable pointers\n-        // into `s` and pass them to `f()`, but in fact they are potentially\n-        // pointing at *mutable memory*.  Use `as_mut_buf` instead!\n-\n+    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U {\n         let s = self.repr();\n         f(s.data, s.len / sys::nonzero_size_of::<T>())\n     }"}, {"sha": "44015a8b443f092b899f7102beb53f48ffbca9f8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -109,12 +109,21 @@ pub struct Path {\n     /// A `::foo` path, is relative to the crate root rather than current\n     /// module (like paths in an import).\n     global: bool,\n-    /// The segments in the path (the things separated by ::)\n-    idents: ~[ident],\n-    /// \"Region parameter\", currently only one lifetime is allowed in a path.\n-    rp: Option<Lifetime>,\n-    /// These are the type parameters, ie, the `a, b` in `foo::bar::<a, b>`\n-    types: ~[Ty],\n+    /// The segments in the path: the things separated by `::`.\n+    segments: ~[PathSegment],\n+}\n+\n+/// A segment of a path: an identifier, an optional lifetime, and a set of\n+/// types.\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+pub struct PathSegment {\n+    /// The identifier portion of this path segment.\n+    identifier: ident,\n+    /// The lifetime parameter for this path segment. Currently only one\n+    /// lifetime parameter is allowed.\n+    lifetime: Option<Lifetime>,\n+    /// The type parameters for this path segment, if present.\n+    types: OptVec<Ty>,\n }\n \n pub type CrateNum = int;\n@@ -165,12 +174,16 @@ impl Generics {\n     }\n }\n \n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+pub enum MethodProvenance {\n+    FromTrait(def_id),\n+    FromImpl(def_id),\n+}\n+\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum def {\n     def_fn(def_id, purity),\n-    def_static_method(/* method */ def_id,\n-                      /* trait */  Option<def_id>,\n-                      purity),\n+    def_static_method(/* method */ def_id, MethodProvenance, purity),\n     def_self(NodeId),\n     def_self_ty(/* trait id */ NodeId),\n     def_mod(def_id),\n@@ -298,7 +311,10 @@ pub enum pat_ {\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum mutability { m_mutbl, m_imm, m_const, }\n+pub enum mutability {\n+    m_mutbl,\n+    m_imm,\n+}\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum Sigil {\n@@ -704,7 +720,7 @@ impl ToStr for float_ty {\n }\n \n // NB Eq method appears below.\n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Ty {\n     id: NodeId,\n     node: ty_,"}, {"sha": "2fe42af65ca17aefd9cd25c71bb8b0fa597ab66d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -28,8 +28,8 @@ pub fn path_name_i(idents: &[ident]) -> ~str {\n     idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n }\n \n-pub fn path_to_ident(p: &Path) -> ident {\n-    *p.idents.last()\n+pub fn path_to_ident(path: &Path) -> ident {\n+    path.segments.last().identifier\n }\n \n pub fn local_def(id: NodeId) -> def_id {\n@@ -217,12 +217,18 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: span, i: ident) -> Path {\n-    ast::Path { span: s,\n-                 global: false,\n-                 idents: ~[i],\n-                 rp: None,\n-                 types: ~[] }\n+pub fn ident_to_path(s: span, identifier: ident) -> Path {\n+    ast::Path {\n+        span: s,\n+        global: false,\n+        segments: ~[\n+            ast::PathSegment {\n+                identifier: identifier,\n+                lifetime: None,\n+                types: opt_vec::Empty,\n+            }\n+        ],\n+    }\n }\n \n pub fn ident_to_pat(id: NodeId, s: span, i: ident) -> @pat {\n@@ -420,7 +426,7 @@ impl IdVisitor {\n impl Visitor<()> for IdVisitor {\n     fn visit_mod(&mut self,\n                  module: &_mod,\n-                 _span: span,\n+                 _: span,\n                  node_id: NodeId,\n                  env: ()) {\n         (self.visit_callback)(node_id);"}, {"sha": "7432cf80a41c3756ea280ca155a05e869ac639ee", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -329,20 +329,6 @@ pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: &str) -> @str {\n     }\n }\n \n-pub fn expr_to_ident(cx: @ExtCtxt,\n-                     expr: @ast::expr,\n-                     err_msg: &str) -> ast::ident {\n-    match expr.node {\n-      ast::expr_path(ref p) => {\n-        if p.types.len() > 0u || p.idents.len() != 1u {\n-            cx.span_fatal(expr.span, err_msg);\n-        }\n-        return p.idents[0];\n-      }\n-      _ => cx.span_fatal(expr.span, err_msg)\n-    }\n-}\n-\n pub fn check_zero_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n                       name: &str) {\n     if tts.len() != 0 {\n@@ -353,15 +339,15 @@ pub fn check_zero_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n pub fn get_single_str_from_tts(cx: @ExtCtxt,\n                                sp: span,\n                                tts: &[ast::token_tree],\n-                               name: &str) -> @str {\n+                               name: &str)\n+                               -> @str {\n     if tts.len() != 1 {\n         cx.span_fatal(sp, fmt!(\"%s takes 1 argument.\", name));\n     }\n \n     match tts[0] {\n         ast::tt_tok(_, token::LIT_STR(ident)) => cx.str_of(ident),\n-        _ =>\n-        cx.span_fatal(sp, fmt!(\"%s requires a string.\", name))\n+        _ => cx.span_fatal(sp, fmt!(\"%s requires a string.\", name)),\n     }\n }\n "}, {"sha": "21d67493cbffb9049e9384782f89a0afc0d10c30", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -74,6 +74,13 @@ pub trait AstBuilder {\n     // statements\n     fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt;\n     fn stmt_let(&self, sp: span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt;\n+    fn stmt_let_typed(&self,\n+                      sp: span,\n+                      mutbl: bool,\n+                      ident: ast::ident,\n+                      typ: ast::Ty,\n+                      ex: @ast::expr)\n+                      -> @ast::stmt;\n \n     // blocks\n     fn block(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::Block;\n@@ -233,18 +240,31 @@ impl AstBuilder for @ExtCtxt {\n     fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, true, strs, None, ~[])\n     }\n-    fn path_all(&self, sp: span,\n+    fn path_all(&self,\n+                sp: span,\n                 global: bool,\n-                idents: ~[ast::ident],\n+                mut idents: ~[ast::ident],\n                 rp: Option<ast::Lifetime>,\n                 types: ~[ast::Ty])\n-        -> ast::Path {\n+                -> ast::Path {\n+        let last_identifier = idents.pop();\n+        let mut segments: ~[ast::PathSegment] = idents.move_iter()\n+                                                      .map(|ident| {\n+            ast::PathSegment {\n+                identifier: ident,\n+                lifetime: None,\n+                types: opt_vec::Empty,\n+            }\n+        }).collect();\n+        segments.push(ast::PathSegment {\n+            identifier: last_identifier,\n+            lifetime: rp,\n+            types: opt_vec::from(types),\n+        });\n         ast::Path {\n             span: sp,\n             global: global,\n-            idents: idents,\n-            rp: rp,\n-            types: types\n+            segments: segments,\n         }\n     }\n \n@@ -387,6 +407,26 @@ impl AstBuilder for @ExtCtxt {\n         @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n     }\n \n+    fn stmt_let_typed(&self,\n+                      sp: span,\n+                      mutbl: bool,\n+                      ident: ast::ident,\n+                      typ: ast::Ty,\n+                      ex: @ast::expr)\n+                      -> @ast::stmt {\n+        let pat = self.pat_ident(sp, ident);\n+        let local = @ast::Local {\n+            is_mutbl: mutbl,\n+            ty: typ,\n+            pat: pat,\n+            init: Some(ex),\n+            id: self.next_id(),\n+            span: sp,\n+        };\n+        let decl = respan(sp, ast::decl_local(local));\n+        @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n+    }\n+\n     fn block(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@expr>) -> ast::Block {\n         self.block_all(span, ~[], stmts, expr)\n     }"}, {"sha": "477f3fde99c734c1d23f8650cc317314180bed10", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -12,6 +12,7 @@ use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n+use opt_vec;\n use parse::token;\n use parse::token::{str_to_ident};\n \n@@ -39,9 +40,13 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n             ast::Path {\n                  span: sp,\n                  global: false,\n-                 idents: ~[res],\n-                 rp: None,\n-                 types: ~[],\n+                 segments: ~[\n+                    ast::PathSegment {\n+                        identifier: res,\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    }\n+                ]\n             }\n         ),\n         span: sp,"}, {"sha": "b8cf3de635f04673de303bd8f31829989b143651", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -76,24 +76,33 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n \n             let variant_count = cx.expr_uint(span, variants.len());\n \n-            // need to specify the uint-ness of the random number\n-            let uint_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));\n-            let r_ty = cx.ty_ident(span, cx.ident_of(\"R\"));\n             let rand_name = cx.path_all(span,\n                                         true,\n                                         rand_ident.clone(),\n                                         None,\n-                                        ~[ uint_ty, r_ty ]);\n+                                        ~[]);\n             let rand_name = cx.expr_path(rand_name);\n \n-            // ::std::rand::Rand::rand::<uint>(rng)\n+            // ::std::rand::Rand::rand(rng)\n             let rv_call = cx.expr_call(span,\n                                        rand_name,\n                                        ~[ rng[0].duplicate(cx) ]);\n \n+            // need to specify the uint-ness of the random number\n+            let uint_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));\n+            let value_ident = cx.ident_of(\"__value\");\n+            let let_statement = cx.stmt_let_typed(span,\n+                                                  false,\n+                                                  value_ident,\n+                                                  uint_ty,\n+                                                  rv_call);\n+\n             // rand() % variants.len()\n-            let rand_variant = cx.expr_binary(span, ast::rem,\n-                                              rv_call, variant_count);\n+            let value_ref = cx.expr_ident(span, value_ident);\n+            let rand_variant = cx.expr_binary(span,\n+                                              ast::rem,\n+                                              value_ref,\n+                                              variant_count);\n \n             let mut arms = do variants.iter().enumerate().map |(i, id_sum)| {\n                 let i_expr = cx.expr_uint(span, i);\n@@ -111,7 +120,10 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n             // _ => {} at the end. Should never occur\n             arms.push(cx.arm_unreachable(span));\n \n-            cx.expr_match(span, rand_variant, arms)\n+            let match_expr = cx.expr_match(span, rand_variant, arms);\n+\n+            let block = cx.block(span, ~[ let_statement ], Some(match_expr));\n+            cx.expr_block(block)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };"}, {"sha": "86639c6f121e8c92ff0ca09baeb55e2301e6db57", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -19,6 +19,7 @@ use codemap;\n use codemap::{span, spanned, ExpnInfo, NameAndSpan};\n use ext::base::*;\n use fold::*;\n+use opt_vec;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token;\n@@ -42,13 +43,13 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n             match (*mac).node {\n                 // Token-tree macros:\n                 mac_invoc_tt(ref pth, ref tts) => {\n-                    if (pth.idents.len() > 1u) {\n+                    if (pth.segments.len() > 1u) {\n                         cx.span_fatal(\n                             pth.span,\n                             fmt!(\"expected macro name without module \\\n                                   separators\"));\n                     }\n-                    let extname = &pth.idents[0];\n+                    let extname = &pth.segments[0].identifier;\n                     let extnamestr = ident_to_str(extname);\n                     // leaving explicit deref here to highlight unbox op:\n                     match (*extsbox).find(&extname.name) {\n@@ -143,9 +144,13 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                 ast::Path {\n                     span: span,\n                     global: false,\n-                    idents: ~[ident],\n-                    rp: None,\n-                    types: ~[]\n+                    segments: ~[\n+                        ast::PathSegment {\n+                            identifier: ident,\n+                            lifetime: None,\n+                            types: opt_vec::Empty,\n+                        }\n+                    ],\n                 }\n             }\n \n@@ -368,7 +373,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n-    let extname = &pth.idents[0];\n+    let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n     let expanded = match (*extsbox).find(&extname.name) {\n         None => cx.span_fatal(pth.span,\n@@ -459,13 +464,13 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n         }\n         _ => return orig(s, sp, fld)\n     };\n-    if (pth.idents.len() > 1u) {\n+    if (pth.segments.len() > 1u) {\n         cx.span_fatal(\n             pth.span,\n             fmt!(\"expected macro name without module \\\n                   separators\"));\n     }\n-    let extname = &pth.idents[0];\n+    let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n     let (fully_expanded, sp) = match (*extsbox).find(&extname.name) {\n         None =>\n@@ -534,10 +539,14 @@ impl Visitor<()> for NewNameFinderContext {\n                     // a path of length one:\n                     &ast::Path {\n                         global: false,\n-                        idents: [id],\n                         span: _,\n-                        rp: _,\n-                        types: _\n+                        segments: [\n+                            ast::PathSegment {\n+                                identifier: id,\n+                                lifetime: _,\n+                                types: _\n+                            }\n+                        ]\n                     } => self.ident_accumulator.push(id),\n                     // I believe these must be enums...\n                     _ => ()"}, {"sha": "327ee331c3814fe6491f514cbe04eb0703b0a1ca", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -16,8 +16,8 @@ use codemap::{BytePos, mk_sp};\n use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n-use parse::parser::Parser;\n use parse::attr::parser_attr;\n+use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n use parse::token::{Token, EOF, to_str, nonterminal, get_ident_interner, ident_to_str};\n use parse::token;\n \n@@ -430,7 +430,9 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n         _ => p.fatal(~\"expected ident, found \"\n                      + token::to_str(get_ident_interner(), p.token))\n       },\n-      \"path\" => token::nt_path(~p.parse_path_with_tps(false)),\n+      \"path\" => {\n+        token::nt_path(~p.parse_path(LifetimeAndTypesWithoutColons).path)\n+      }\n       \"attr\" => token::nt_attr(@p.parse_attribute(false)),\n       \"tt\" => {\n         *p.quote_depth += 1u; //but in theory, non-quoted tts might be useful"}, {"sha": "458737e2fbf0bad484310ff5336bd2628942aa4f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -765,9 +765,11 @@ fn noop_fold_path(p: &Path, fld: @ast_fold) -> Path {\n     ast::Path {\n         span: fld.new_span(p.span),\n         global: p.global,\n-        idents: p.idents.map(|x| fld.fold_ident(*x)),\n-        rp: p.rp,\n-        types: p.types.map(|x| fld.fold_ty(x)),\n+        segments: p.segments.map(|segment| ast::PathSegment {\n+            identifier: fld.fold_ident(segment.identifier),\n+            lifetime: segment.lifetime,\n+            types: segment.types.map(|typ| fld.fold_ty(typ)),\n+        })\n     }\n }\n "}, {"sha": "56576ee359960b0a40f5fcedaab5a899def08679", "filename": "src/libsyntax/oldvisit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -284,7 +284,11 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_path<E:Clone>(p: &Path, (e, v): (E, vt<E>)) {\n-    for tp in p.types.iter() { (v.visit_ty)(tp, (e.clone(), v)); }\n+    for segment in p.segments.iter() {\n+        for typ in segment.types.iter() {\n+            (v.visit_ty)(typ, (e.clone(), v))\n+        }\n+    }\n }\n \n pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {"}, {"sha": "81113f2432923c6089cf37e932a07806c2a821c8", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 124, "deletions": 95, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -361,27 +361,47 @@ mod test {\n         span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n     }\n \n-    #[test] fn path_exprs_1 () {\n+    #[test] fn path_exprs_1() {\n         assert_eq!(string_to_expr(@\"a\"),\n-                   @ast::expr{id:1,\n-                              node:ast::expr_path(ast::Path {span:sp(0,1),\n-                                                              global:false,\n-                                                              idents:~[str_to_ident(\"a\")],\n-                                                              rp:None,\n-                                                              types:~[]}),\n-                              span:sp(0,1)})\n+                   @ast::expr{\n+                    id: 1,\n+                    node: ast::expr_path(ast::Path {\n+                        span: sp(0, 1),\n+                        global: false,\n+                        segments: ~[\n+                            ast::PathSegment {\n+                                identifier: str_to_ident(\"a\"),\n+                                lifetime: None,\n+                                types: opt_vec::Empty,\n+                            }\n+                        ],\n+                    }),\n+                    span: sp(0, 1)\n+                   })\n     }\n \n     #[test] fn path_exprs_2 () {\n         assert_eq!(string_to_expr(@\"::a::b\"),\n-                   @ast::expr{id:1,\n-                               node:ast::expr_path(\n-                                    ast::Path {span:sp(0,6),\n-                                               global:true,\n-                                               idents:strs_to_idents(~[\"a\",\"b\"]),\n-                                               rp:None,\n-                                               types:~[]}),\n-                              span:sp(0,6)})\n+                   @ast::expr {\n+                    id:1,\n+                    node: ast::expr_path(ast::Path {\n+                            span: sp(0, 6),\n+                            global: true,\n+                            segments: ~[\n+                                ast::PathSegment {\n+                                    identifier: str_to_ident(\"a\"),\n+                                    lifetime: None,\n+                                    types: opt_vec::Empty,\n+                                },\n+                                ast::PathSegment {\n+                                    identifier: str_to_ident(\"b\"),\n+                                    lifetime: None,\n+                                    types: opt_vec::Empty,\n+                                }\n+                            ]\n+                        }),\n+                    span: sp(0, 6)\n+                   })\n     }\n \n     #[should_fail]\n@@ -420,32 +440,43 @@ mod test {\n \n     #[test] fn ret_expr() {\n         assert_eq!(string_to_expr(@\"return d\"),\n-                   @ast::expr{id:2,\n-                              node:ast::expr_ret(\n-                                  Some(@ast::expr{id:1,\n-                                                  node:ast::expr_path(\n-                                                       ast::Path{span:sp(7,8),\n-                                                                 global:false,\n-                                                                 idents:~[str_to_ident(\"d\")],\n-                                                                 rp:None,\n-                                                                 types:~[]\n-                                                                }),\n-                                                  span:sp(7,8)})),\n-                              span:sp(0,8)})\n+                   @ast::expr{\n+                    id:2,\n+                    node:ast::expr_ret(Some(@ast::expr{\n+                        id:1,\n+                        node:ast::expr_path(ast::Path{\n+                            span: sp(7, 8),\n+                            global: false,\n+                            segments: ~[\n+                                ast::PathSegment {\n+                                    identifier: str_to_ident(\"d\"),\n+                                    lifetime: None,\n+                                    types: opt_vec::Empty,\n+                                }\n+                            ],\n+                        }),\n+                        span:sp(7,8)\n+                    })),\n+                    span:sp(0,8)\n+                   })\n     }\n \n     #[test] fn parse_stmt_1 () {\n         assert_eq!(string_to_stmt(@\"b;\"),\n                    @spanned{\n-                       node: ast::stmt_expr(@ast::expr{\n+                       node: ast::stmt_expr(@ast::expr {\n                            id: 1,\n-                           node: ast::expr_path(\n-                                ast::Path{\n-                                   span:sp(0,1),\n-                                   global:false,\n-                                   idents:~[str_to_ident(\"b\")],\n-                                   rp:None,\n-                                   types: ~[]}),\n+                           node: ast::expr_path(ast::Path {\n+                               span:sp(0,1),\n+                               global:false,\n+                               segments: ~[\n+                                ast::PathSegment {\n+                                    identifier: str_to_ident(\"b\"),\n+                                    lifetime: None,\n+                                    types: opt_vec::Empty,\n+                                }\n+                               ],\n+                            }),\n                            span: sp(0,1)},\n                                             2), // fixme\n                        span: sp(0,1)})\n@@ -460,49 +491,24 @@ mod test {\n         let parser = string_to_parser(@\"b\");\n         assert_eq!(parser.parse_pat(),\n                    @ast::pat{id:1, // fixme\n-                             node: ast::pat_ident(ast::bind_infer,\n-                                                   ast::Path{\n-                                                      span:sp(0,1),\n-                                                      global:false,\n-                                                      idents:~[str_to_ident(\"b\")],\n-                                                      rp: None,\n-                                                      types: ~[]},\n-                                                  None // no idea\n-                                                 ),\n+                             node: ast::pat_ident(\n+                                ast::bind_infer,\n+                                ast::Path {\n+                                    span:sp(0,1),\n+                                    global:false,\n+                                    segments: ~[\n+                                        ast::PathSegment {\n+                                            identifier: str_to_ident(\"b\"),\n+                                            lifetime: None,\n+                                            types: opt_vec::Empty,\n+                                        }\n+                                    ],\n+                                },\n+                                None /* no idea */),\n                              span: sp(0,1)});\n         parser_done(parser);\n     }\n \n-    #[test] fn parse_arg () {\n-        let parser = string_to_parser(@\"b : int\");\n-        assert_eq!(parser.parse_arg_general(true),\n-                   ast::arg{\n-                       is_mutbl: false,\n-                       ty: ast::Ty{id:3, // fixme\n-                                    node: ast::ty_path(ast::Path{\n-                                        span:sp(4,4), // this is bizarre...\n-                                        // check this in the original parser?\n-                                        global:false,\n-                                        idents:~[str_to_ident(\"int\")],\n-                                        rp: None,\n-                                        types: ~[]},\n-                                                       None, 2),\n-                                    span:sp(4,7)},\n-                       pat: @ast::pat{id:1,\n-                                      node: ast::pat_ident(ast::bind_infer,\n-                                                            ast::Path{\n-                                                               span:sp(0,1),\n-                                                               global:false,\n-                                                               idents:~[str_to_ident(\"b\")],\n-                                                               rp: None,\n-                                                               types: ~[]},\n-                                                           None // no idea\n-                                                          ),\n-                                      span: sp(0,1)},\n-                       id: 4 // fixme\n-                   })\n-    }\n-\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"int\", and on the\n@@ -519,23 +525,37 @@ mod test {\n                                                 node: ast::ty_path(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        idents:~[str_to_ident(\"int\")],\n-                                        rp: None,\n-                                        types: ~[]},\n-                                                       None, 2),\n-                                                span:sp(10,13)},\n-                                    pat: @ast::pat{id:1, // fixme\n-                                                   node: ast::pat_ident(\n-                                                       ast::bind_infer,\n-                                                       ast::Path{\n-                                                           span:sp(6,7),\n-                                                           global:false,\n-                                                           idents:~[str_to_ident(\"b\")],\n-                                                           rp: None,\n-                                                           types: ~[]},\n-                                                       None // no idea\n-                                                   ),\n-                                                  span: sp(6,7)},\n+                                        segments: ~[\n+                                            ast::PathSegment {\n+                                                identifier:\n+                                                    str_to_ident(\"int\"),\n+                                                lifetime: None,\n+                                                types: opt_vec::Empty,\n+                                            }\n+                                        ],\n+                                        }, None, 2),\n+                                        span:sp(10,13)\n+                                    },\n+                                    pat: @ast::pat {\n+                                        id:1, // fixme\n+                                        node: ast::pat_ident(\n+                                            ast::bind_infer,\n+                                            ast::Path {\n+                                                span:sp(6,7),\n+                                                global:false,\n+                                                segments: ~[\n+                                                    ast::PathSegment {\n+                                                        identifier:\n+                                                            str_to_ident(\"b\"),\n+                                                        lifetime: None,\n+                                                        types: opt_vec::Empty,\n+                                                    }\n+                                                ],\n+                                            },\n+                                            None // no idea\n+                                        ),\n+                                        span: sp(6,7)\n+                                    },\n                                     id: 4 // fixme\n                                 }],\n                                 output: ast::Ty{id:5, // fixme\n@@ -558,9 +578,18 @@ mod test {\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n-                                                        idents:~[str_to_ident(\"b\")],\n-                                                        rp:None,\n-                                                        types: ~[]}),\n+                                                        segments: ~[\n+                                                            ast::PathSegment {\n+                                                                identifier:\n+                                                                str_to_ident(\n+                                                                    \"b\"),\n+                                                                lifetime:\n+                                                                    None,\n+                                                                types:\n+                                                                opt_vec::Empty\n+                                                            }\n+                                                        ],\n+                                                      }),\n                                                 span: sp(17,18)},\n                                                                  7), // fixme\n                                             span: sp(17,18)}],"}, {"sha": "ab1bde3a3b9eb357c0089d832c353ff9121e43d9", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -53,7 +53,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteMode,\n     ObsoleteImplicitSelf,\n     ObsoleteLifetimeNotation,\n-    ObsoleteConstManagedPointer,\n     ObsoletePurity,\n     ObsoleteStaticMethod,\n     ObsoleteConstItem,\n@@ -65,6 +64,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteUnsafeExternFn,\n     ObsoletePrivVisibility,\n     ObsoleteTraitFuncVisibility,\n+    ObsoleteConstPointer,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -201,10 +201,6 @@ impl ParserObsoleteMethods for Parser {\n                 \"instead of `&foo/bar`, write `&'foo bar`; instead of \\\n                  `bar/&foo`, write `&bar<'foo>\"\n             ),\n-            ObsoleteConstManagedPointer => (\n-                \"const `@` pointer\",\n-                \"instead of `@const Foo`, write `@Foo`\"\n-            ),\n             ObsoletePurity => (\n                 \"pure function\",\n                 \"remove `pure`\"\n@@ -255,6 +251,11 @@ impl ParserObsoleteMethods for Parser {\n                 \"visibility not necessary\",\n                 \"trait functions inherit the visibility of the trait itself\"\n             ),\n+            ObsoleteConstPointer => (\n+                \"const pointer\",\n+                \"instead of `&const Foo` or `@const Foo`, write `&Foo` or \\\n+                 `@Foo`\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "8ca858b7935eceedd2b818e4ee91469ea6e61bf6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 222, "deletions": 152, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -38,7 +38,7 @@ use ast::{ident, impure_fn, inherited, item, item_, item_static};\n use ast::{item_enum, item_fn, item_foreign_mod, item_impl};\n use ast::{item_mac, item_mod, item_struct, item_trait, item_ty, lit, lit_};\n use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int};\n-use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local, m_const};\n+use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local};\n use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mt, mul, mutability};\n use ast::{named_field, neg, NodeId, noreturn, not, pat, pat_box, pat_enum};\n@@ -97,6 +97,37 @@ enum restriction {\n type arg_or_capture_item = Either<arg, ()>;\n type item_info = (ident, item_, Option<~[Attribute]>);\n \n+/// How to parse a path. There are four different kinds of paths, all of which\n+/// are parsed somewhat differently.\n+#[deriving(Eq)]\n+pub enum PathParsingMode {\n+    /// A path with no type parameters; e.g. `foo::bar::Baz`\n+    NoTypesAllowed,\n+    /// A path with a lifetime and type parameters, with no double colons\n+    /// before the type parameters; e.g. `foo::bar<'self>::Baz<T>`\n+    LifetimeAndTypesWithoutColons,\n+    /// A path with a lifetime and type parameters with double colons before\n+    /// the type parameters; e.g. `foo::bar::<'self>::Baz::<T>`\n+    LifetimeAndTypesWithColons,\n+    /// A path with a lifetime and type parameters with bounds before the last\n+    /// set of type parameters only; e.g. `foo::bar<'self>::Baz:X+Y<T>` This\n+    /// form does not use extra double colons.\n+    LifetimeAndTypesAndBounds,\n+}\n+\n+/// A pair of a path segment and group of type parameter bounds. (See `ast.rs`\n+/// for the definition of a path segment.)\n+struct PathSegmentAndBoundSet {\n+    segment: ast::PathSegment,\n+    bound_set: Option<OptVec<TyParamBound>>,\n+}\n+\n+/// A path paired with optional type bounds.\n+struct PathAndBounds {\n+    path: ast::Path,\n+    bounds: Option<OptVec<TyParamBound>>,\n+}\n+\n pub enum item_or_view_item {\n     // Indicates a failure to parse any kind of item. The attributes are\n     // returned.\n@@ -1108,7 +1139,10 @@ impl Parser {\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(self.token) {\n             // NAMED TYPE\n-            let (path, bounds) = self.parse_type_path();\n+            let PathAndBounds {\n+                path,\n+                bounds\n+            } = self.parse_path(LifetimeAndTypesAndBounds);\n             ty_path(path, bounds, self.get_id())\n         } else {\n             self.fatal(fmt!(\"expected type, found token %?\",\n@@ -1153,9 +1187,6 @@ impl Parser {\n         if mt.mutbl != m_imm && sigil == OwnedSigil {\n             self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n         }\n-        if mt.mutbl == m_const && sigil == ManagedSigil {\n-            self.obsolete(*self.last_span, ObsoleteConstManagedPointer);\n-        }\n \n         ctor(mt)\n     }\n@@ -1332,139 +1363,155 @@ impl Parser {\n         }\n     }\n \n-    // parse a path into a vector of idents, whether the path starts\n-    // with ::, and a span.\n-    pub fn parse_path(&self) -> (~[ast::ident],bool,span) {\n+    /// Parses a path and optional type parameter bounds, depending on the\n+    /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n+    /// bounds are permitted and whether `::` must precede type parameter\n+    /// groups.\n+    pub fn parse_path(&self, mode: PathParsingMode) -> PathAndBounds {\n+        // Check for a whole path...\n+        let found = match *self.token {\n+            INTERPOLATED(token::nt_path(_)) => Some(self.bump_and_get()),\n+            _ => None,\n+        };\n+        match found {\n+            Some(INTERPOLATED(token::nt_path(~path))) => {\n+                return PathAndBounds {\n+                    path: path,\n+                    bounds: None,\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         let lo = self.span.lo;\n         let is_global = self.eat(&token::MOD_SEP);\n-        let (ids,span{lo:_,hi,expn_info}) = self.parse_path_non_global();\n-        (ids,is_global,span{lo:lo,hi:hi,expn_info:expn_info})\n-    }\n \n-    // parse a path beginning with an identifier into a vector of idents and a span\n-    pub fn parse_path_non_global(&self) -> (~[ast::ident],span) {\n-        let lo = self.span.lo;\n-        let mut ids = ~[];\n-        // must be at least one to begin:\n-        ids.push(self.parse_ident());\n+        // Parse any number of segments and bound sets. A segment is an\n+        // identifier followed by an optional lifetime and a set of types.\n+        // A bound set is a set of type parameter bounds.\n+        let mut segments = ~[];\n         loop {\n+            // First, parse an identifier.\n             match *self.token {\n-                token::MOD_SEP => {\n-                    let is_ident = do self.look_ahead(1) |t| {\n-                        match *t {\n-                            token::IDENT(*) => true,\n-                            _ => false,\n-                        }\n-                    };\n-                    if is_ident {\n-                        self.bump();\n-                        ids.push(self.parse_ident());\n-                    } else {\n-                        break\n-                    }\n-                }\n-                _ => break\n+                token::IDENT(*) => {}\n+                _ => break,\n             }\n-        }\n-        (ids, mk_sp(lo, self.last_span.hi))\n-    }\n+            let identifier = self.parse_ident();\n \n-    // parse a path that doesn't have type parameters attached\n-    pub fn parse_path_without_tps(&self) -> ast::Path {\n-        maybe_whole!(deref self, nt_path);\n-        let (ids,is_global,sp) = self.parse_path();\n-        ast::Path { span: sp,\n-                     global: is_global,\n-                     idents: ids,\n-                     rp: None,\n-                     types: ~[] }\n-    }\n+            // Next, parse a colon and bounded type parameters, if applicable.\n+            let bound_set = if mode == LifetimeAndTypesAndBounds {\n+                self.parse_optional_ty_param_bounds()\n+            } else {\n+                None\n+            };\n \n-    pub fn parse_bounded_path_with_tps(&self, colons: bool,\n-                                        before_tps: Option<&fn()>) -> ast::Path {\n-        debug!(\"parse_path_with_tps(colons=%b)\", colons);\n+            // Parse the '::' before type parameters if it's required. If\n+            // it is required and wasn't present, then we're done.\n+            if mode == LifetimeAndTypesWithColons &&\n+                    !self.eat(&token::MOD_SEP) {\n+                segments.push(PathSegmentAndBoundSet {\n+                    segment: ast::PathSegment {\n+                        identifier: identifier,\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    },\n+                    bound_set: bound_set\n+                });\n+                break\n+            }\n \n-        maybe_whole!(deref self, nt_path);\n-        let lo = self.span.lo;\n-        let path = self.parse_path_without_tps();\n-        if colons && !self.eat(&token::MOD_SEP) {\n-            return path;\n-        }\n-\n-        // If the path might have bounds on it, they should be parsed before\n-        // the parameters, e.g. module::TraitName:B1+B2<T>\n-        before_tps.map_move(|callback| callback());\n-\n-        // Parse the (obsolete) trailing region parameter, if any, which will\n-        // be written \"foo/&x\"\n-        let rp_slash = {\n-            if *self.token == token::BINOP(token::SLASH)\n-                && self.look_ahead(1, |t| *t == token::BINOP(token::AND))\n-            {\n-                self.bump(); self.bump();\n-                self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n-                match *self.token {\n-                    token::IDENT(sid, _) => {\n-                        let span = self.span;\n-                        self.bump();\n-                        Some(ast::Lifetime {\n-                            id: self.get_id(),\n-                            span: *span,\n-                            ident: sid\n-                        })\n+            // Parse the `<` before the lifetime and types, if applicable.\n+            let (any_lifetime_or_types, optional_lifetime, types) =\n+                    if mode != NoTypesAllowed && self.eat(&token::LT) {\n+                // Parse an optional lifetime.\n+                let optional_lifetime = match *self.token {\n+                    token::LIFETIME(*) => Some(self.parse_lifetime()),\n+                    _ => None,\n+                };\n+\n+                // Parse type parameters.\n+                let mut types = opt_vec::Empty;\n+                let mut need_comma = optional_lifetime.is_some();\n+                loop {\n+                    // We're done if we see a `>`.\n+                    match *self.token {\n+                        token::GT | token::BINOP(token::SHR) => {\n+                            self.expect_gt();\n+                            break\n+                        }\n+                        _ => {} // Go on.\n                     }\n-                    _ => {\n-                        self.fatal(fmt!(\"Expected a lifetime name\"));\n+\n+                    if need_comma {\n+                        self.expect(&token::COMMA)\n+                    } else {\n+                        need_comma = true\n                     }\n+\n+                    types.push(self.parse_ty(false))\n                 }\n+\n+                (true, optional_lifetime, types)\n             } else {\n-                None\n-            }\n-        };\n+                (false, None, opt_vec::Empty)\n+            };\n \n-        // Parse any lifetime or type parameters which may appear:\n-        let (lifetimes, tps) = self.parse_generic_values();\n-        let hi = self.span.lo;\n+            // Assemble and push the result.\n+            segments.push(PathSegmentAndBoundSet {\n+                segment: ast::PathSegment {\n+                    identifier: identifier,\n+                    lifetime: optional_lifetime,\n+                    types: types,\n+                },\n+                bound_set: bound_set\n+            });\n \n-        let rp = match (&rp_slash, &lifetimes) {\n-            (&Some(_), _) => rp_slash,\n-            (&None, v) => {\n-                if v.len() == 0 {\n-                    None\n-                } else if v.len() == 1 {\n-                    Some(*v.get(0))\n-                } else {\n-                    self.fatal(fmt!(\"Expected at most one \\\n-                                     lifetime name (for now)\"));\n+            // We're done if we don't see a '::', unless the mode required\n+            // a double colon to get here in the first place.\n+            if !(mode == LifetimeAndTypesWithColons &&\n+                    !any_lifetime_or_types) {\n+                if !self.eat(&token::MOD_SEP) {\n+                    break\n                 }\n             }\n-        };\n-\n-        ast::Path {\n-            span: mk_sp(lo, hi),\n-            rp: rp,\n-            types: tps,\n-            .. path.clone()\n         }\n-    }\n \n-    // parse a path optionally with type parameters. If 'colons'\n-    // is true, then type parameters must be preceded by colons,\n-    // as in a::t::<t1,t2>\n-    pub fn parse_path_with_tps(&self, colons: bool) -> ast::Path {\n-        self.parse_bounded_path_with_tps(colons, None)\n-    }\n+        // Assemble the span.\n+        let span = mk_sp(lo, self.last_span.hi);\n \n-    // Like the above, but can also parse kind bounds in the case of a\n-    // path to be used as a type that might be a trait.\n-    pub fn parse_type_path(&self) -> (ast::Path, Option<OptVec<TyParamBound>>) {\n+        // Assemble the path segments.\n+        let mut path_segments = ~[];\n         let mut bounds = None;\n-        let path = self.parse_bounded_path_with_tps(false, Some(|| {\n-            // Note: this closure might not even get called in the case of a\n-            // macro-generated path. But that's the macro parser's job.\n-            bounds = self.parse_optional_ty_param_bounds();\n-        }));\n-        (path, bounds)\n+        let last_segment_index = segments.len() - 1;\n+        for (i, segment_and_bounds) in segments.move_iter().enumerate() {\n+            let PathSegmentAndBoundSet {\n+                segment: segment,\n+                bound_set: bound_set\n+            } = segment_and_bounds;\n+            path_segments.push(segment);\n+\n+            if bound_set.is_some() {\n+                if i != last_segment_index {\n+                    self.span_err(span,\n+                                  \"type parameter bounds are allowed only \\\n+                                   before the last segment in a path\")\n+                }\n+\n+                bounds = bound_set\n+            }\n+        }\n+\n+        // Assemble the result.\n+        let path_and_bounds = PathAndBounds {\n+            path: ast::Path {\n+                span: span,\n+                global: is_global,\n+                segments: path_segments,\n+            },\n+            bounds: bounds,\n+        };\n+\n+        path_and_bounds\n     }\n \n     /// parses 0 or 1 lifetime\n@@ -1568,7 +1615,8 @@ impl Parser {\n         if self.eat_keyword(keywords::Mut) {\n             m_mutbl\n         } else if self.eat_keyword(keywords::Const) {\n-            m_const\n+            self.obsolete(*self.last_span, ObsoleteConstPointer);\n+            m_imm\n         } else {\n             m_imm\n         }\n@@ -1727,7 +1775,7 @@ impl Parser {\n         } else if *self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n-            if mutbl == m_mutbl || mutbl == m_const {\n+            if mutbl == m_mutbl {\n                 self.obsolete(*self.last_span, ObsoleteMutVector);\n             }\n \n@@ -1791,7 +1839,7 @@ impl Parser {\n         } else if *self.token == token::MOD_SEP ||\n                 is_ident(&*self.token) && !self.is_keyword(keywords::True) &&\n                 !self.is_keyword(keywords::False) {\n-            let pth = self.parse_path_with_tps(true);\n+            let pth = self.parse_path(LifetimeAndTypesWithColons).path;\n \n             // `!`, as an operator, is prefix, so we know this isn't that\n             if *self.token == token::NOT {\n@@ -2182,10 +2230,6 @@ impl Parser {\n           token::AT => {\n             self.bump();\n             let m = self.parse_mutability();\n-            if m == m_const {\n-                self.obsolete(*self.last_span, ObsoleteConstManagedPointer);\n-            }\n-\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             // HACK: turn @[...] into a @-evec\n@@ -2886,7 +2930,8 @@ impl Parser {\n             let val = self.parse_literal_maybe_minus();\n             if self.eat(&token::DOTDOT) {\n                 let end = if is_ident_or_path(tok) {\n-                    let path = self.parse_path_with_tps(true);\n+                    let path = self.parse_path(LifetimeAndTypesWithColons)\n+                                   .path;\n                     let hi = self.span.hi;\n                     self.mk_expr(lo, hi, expr_path(path))\n                 } else {\n@@ -2915,7 +2960,7 @@ impl Parser {\n                 let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 pat = pat_range(start, end);\n             } else if is_plain_ident(&*self.token) && !can_be_enum_or_struct {\n-                let name = self.parse_path_without_tps();\n+                let name = self.parse_path(NoTypesAllowed).path;\n                 let sub;\n                 if self.eat(&token::AT) {\n                     // parse foo @ pat\n@@ -2927,7 +2972,8 @@ impl Parser {\n                 pat = pat_ident(bind_infer, name, sub);\n             } else {\n                 // parse an enum pat\n-                let enum_path = self.parse_path_with_tps(true);\n+                let enum_path = self.parse_path(LifetimeAndTypesWithColons)\n+                                    .path;\n                 match *self.token {\n                     token::LBRACE => {\n                         self.bump();\n@@ -2963,7 +3009,7 @@ impl Parser {\n                             }\n                           },\n                           _ => {\n-                              if enum_path.idents.len()==1u {\n+                              if enum_path.segments.len() == 1 {\n                                   // it could still be either an enum\n                                   // or an identifier pattern, resolve\n                                   // will sort it out:\n@@ -2998,7 +3044,7 @@ impl Parser {\n                             \"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n-        let name = self.parse_path_without_tps();\n+        let name = self.parse_path(NoTypesAllowed).path;\n         let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat())\n         } else {\n@@ -3115,7 +3161,7 @@ impl Parser {\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n-            let pth = self.parse_path_without_tps();\n+            let pth = self.parse_path(NoTypesAllowed).path;\n             self.bump();\n \n             let id = if *self.token == token::LPAREN {\n@@ -3791,7 +3837,7 @@ impl Parser {\n     // parse a::B<~str,int>\n     fn parse_trait_ref(&self) -> trait_ref {\n         ast::trait_ref {\n-            path: self.parse_path_with_tps(false),\n+            path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n             ref_id: self.get_id(),\n         }\n     }\n@@ -4707,7 +4753,7 @@ impl Parser {\n             }\n \n             // item macro.\n-            let pth = self.parse_path_without_tps();\n+            let pth = self.parse_path(NoTypesAllowed).path;\n             self.expect(&token::NOT);\n \n             // a 'special' identifier (like what `macro_rules!` uses)\n@@ -4791,11 +4837,17 @@ impl Parser {\n                 let id = self.parse_ident();\n                 path.push(id);\n             }\n-            let path = ast::Path { span: mk_sp(lo, self.span.hi),\n-                                    global: false,\n-                                    idents: path,\n-                                    rp: None,\n-                                    types: ~[] };\n+            let path = ast::Path {\n+                span: mk_sp(lo, self.span.hi),\n+                global: false,\n+                segments: path.move_iter().map(|identifier| {\n+                    ast::PathSegment {\n+                        identifier: identifier,\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    }\n+                }).collect()\n+            };\n             return @spanned(lo, self.span.hi,\n                             view_path_simple(first_ident,\n                                              path,\n@@ -4821,23 +4873,35 @@ impl Parser {\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_path_list_ident()\n                     );\n-                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n-                                            global: false,\n-                                            idents: path,\n-                                            rp: None,\n-                                            types: ~[] };\n+                    let path = ast::Path {\n+                        span: mk_sp(lo, self.span.hi),\n+                        global: false,\n+                        segments: path.move_iter().map(|identifier| {\n+                            ast::PathSegment {\n+                                identifier: identifier,\n+                                lifetime: None,\n+                                types: opt_vec::Empty,\n+                            }\n+                        }).collect()\n+                    };\n                     return @spanned(lo, self.span.hi,\n                                  view_path_list(path, idents, self.get_id()));\n                   }\n \n                   // foo::bar::*\n                   token::BINOP(token::STAR) => {\n                     self.bump();\n-                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n-                                            global: false,\n-                                            idents: path,\n-                                            rp: None,\n-                                            types: ~[] };\n+                    let path = ast::Path {\n+                        span: mk_sp(lo, self.span.hi),\n+                        global: false,\n+                        segments: path.move_iter().map(|identifier| {\n+                            ast::PathSegment {\n+                                identifier: identifier,\n+                                lifetime: None,\n+                                types: opt_vec::Empty,\n+                            }\n+                        }).collect()\n+                    };\n                     return @spanned(lo, self.span.hi,\n                                     view_path_glob(path, self.get_id()));\n                   }\n@@ -4849,11 +4913,17 @@ impl Parser {\n           _ => ()\n         }\n         let last = path[path.len() - 1u];\n-        let path = ast::Path { span: mk_sp(lo, self.span.hi),\n-                                global: false,\n-                                idents: path,\n-                                rp: None,\n-                                types: ~[] };\n+        let path = ast::Path {\n+            span: mk_sp(lo, self.span.hi),\n+            global: false,\n+            segments: path.move_iter().map(|identifier| {\n+                ast::PathSegment {\n+                    identifier: identifier,\n+                    lifetime: None,\n+                    types: opt_vec::Empty,\n+                }\n+            }).collect()\n+        };\n         return @spanned(lo,\n                         self.last_span.hi,\n                         view_path_simple(last, path, self.get_id()));"}, {"sha": "d449ba4eb5fb4609c3045958a7fdb004d1da3f0c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -386,7 +386,6 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n         word(s.s, \"[\");\n         match mt.mutbl {\n           ast::m_mutbl => word_space(s, \"mut\"),\n-          ast::m_const => word_space(s, \"const\"),\n           ast::m_imm => ()\n         }\n         print_type(s, mt.ty);\n@@ -429,7 +428,6 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n         word(s.s, \"[\");\n         match mt.mutbl {\n             ast::m_mutbl => word_space(s, \"mut\"),\n-            ast::m_const => word_space(s, \"const\"),\n             ast::m_imm => ()\n         }\n         print_type(s, mt.ty);\n@@ -1503,34 +1501,52 @@ pub fn print_for_decl(s: @ps, loc: &ast::Local, coll: &ast::expr) {\n     print_expr(s, coll);\n }\n \n-fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n+fn print_path_(s: @ps,\n+               path: &ast::Path,\n+               colons_before_params: bool,\n                opt_bounds: &Option<OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n-    if path.global { word(s.s, \"::\"); }\n-    let mut first = true;\n-    for id in path.idents.iter() {\n-        if first { first = false; } else { word(s.s, \"::\"); }\n-        print_ident(s, *id);\n+    if path.global {\n+        word(s.s, \"::\");\n     }\n-    do opt_bounds.map |bounds| {\n-        print_bounds(s, bounds, true);\n-    };\n-    if path.rp.is_some() || !path.types.is_empty() {\n-        if colons_before_params { word(s.s, \"::\"); }\n \n-        if path.rp.is_some() || !path.types.is_empty() {\n+    let mut first = true;\n+    for (i, segment) in path.segments.iter().enumerate() {\n+        if first {\n+            first = false\n+        } else {\n+            word(s.s, \"::\")\n+        }\n+\n+        print_ident(s, segment.identifier);\n+\n+        if segment.lifetime.is_some() || !segment.types.is_empty() {\n+            // If this is the last segment, print the bounds.\n+            if i == path.segments.len() - 1 {\n+                match *opt_bounds {\n+                    None => {}\n+                    Some(ref bounds) => print_bounds(s, bounds, true),\n+                }\n+            }\n+\n+            if colons_before_params {\n+                word(s.s, \"::\")\n+            }\n             word(s.s, \"<\");\n \n-            for r in path.rp.iter() {\n-                print_lifetime(s, r);\n-                if !path.types.is_empty() {\n-                    word_space(s, \",\");\n+            for lifetime in segment.lifetime.iter() {\n+                print_lifetime(s, lifetime);\n+                if !segment.types.is_empty() {\n+                    word_space(s, \",\")\n                 }\n             }\n \n-            commasep(s, inconsistent, path.types, print_type);\n+            commasep(s,\n+                     inconsistent,\n+                     segment.types.map_to_vec(|t| (*t).clone()),\n+                     print_type);\n \n-            word(s.s, \">\");\n+            word(s.s, \">\")\n         }\n     }\n }\n@@ -1821,7 +1837,7 @@ pub fn print_meta_item(s: @ps, item: &ast::MetaItem) {\n pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, ref path, _) => {\n-        if path.idents[path.idents.len()-1u] != ident {\n+        if path.segments.last().identifier != ident {\n             print_ident(s, ident);\n             space(s.s);\n             word_space(s, \"=\");\n@@ -1882,7 +1898,6 @@ pub fn print_view_item(s: @ps, item: &ast::view_item) {\n pub fn print_mutability(s: @ps, mutbl: ast::mutability) {\n     match mutbl {\n       ast::m_mutbl => word_nbsp(s, \"mut\"),\n-      ast::m_const => word_nbsp(s, \"const\"),\n       ast::m_imm => {/* nothing */ }\n     }\n }\n@@ -1902,8 +1917,9 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n       _ => {\n         match input.pat.node {\n             ast::pat_ident(_, ref path, _) if\n-                path.idents.len() == 1 &&\n-                path.idents[0] == parse::token::special_idents::invalid => {\n+                path.segments.len() == 1 &&\n+                path.segments[0].identifier ==\n+                    parse::token::special_idents::invalid => {\n                 // Do nothing.\n             }\n             _ => {"}, {"sha": "e5b7823ae44ecc9a5e1ae7335bd47b93829669a7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -319,8 +319,10 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n }\n \n pub fn walk_path<E:Clone, V:Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n-    for typ in path.types.iter() {\n-        visitor.visit_ty(typ, env.clone())\n+    for segment in path.segments.iter() {\n+        for typ in segment.types.iter() {\n+            visitor.visit_ty(typ, env.clone())\n+        }\n     }\n }\n "}, {"sha": "2571d60145906db1d20da9a6723e14d1979c15a0", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -121,54 +121,54 @@ fn main() {\n     io::println(\"\\nTreeMap:\");\n \n     {\n-        let mut map = TreeMap::new::<uint, uint>();\n+        let mut map: TreeMap<uint,uint> = TreeMap::new();\n         ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map = TreeMap::new::<uint, uint>();\n+        let mut map: TreeMap<uint,uint> = TreeMap::new();\n         descending(&mut map, n_keys);\n     }\n \n     {\n         io::println(\" Random integers:\");\n-        let mut map = TreeMap::new::<uint, uint>();\n+        let mut map: TreeMap<uint,uint> = TreeMap::new();\n         vector(&mut map, n_keys, rand);\n     }\n \n     io::println(\"\\nHashMap:\");\n \n     {\n-        let mut map = HashMap::new::<uint, uint>();\n+        let mut map: HashMap<uint,uint> = HashMap::new();\n         ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map = HashMap::new::<uint, uint>();\n+        let mut map: HashMap<uint,uint> = HashMap::new();\n         descending(&mut map, n_keys);\n     }\n \n     {\n         io::println(\" Random integers:\");\n-        let mut map = HashMap::new::<uint, uint>();\n+        let mut map: HashMap<uint,uint> = HashMap::new();\n         vector(&mut map, n_keys, rand);\n     }\n \n     io::println(\"\\nTrieMap:\");\n \n     {\n-        let mut map = TrieMap::new::<uint>();\n+        let mut map: TrieMap<uint> = TrieMap::new();\n         ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map = TrieMap::new::<uint>();\n+        let mut map: TrieMap<uint> = TrieMap::new();\n         descending(&mut map, n_keys);\n     }\n \n     {\n         io::println(\" Random integers:\");\n-        let mut map = TrieMap::new::<uint>();\n+        let mut map: TrieMap<uint> = TrieMap::new();\n         vector(&mut map, n_keys, rand);\n     }\n }"}, {"sha": "fe77196e2b101512fc89c03a178e9d882b29572c", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -169,16 +169,28 @@ fn main() {\n     {\n         let mut rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(&mut rng, num_keys, max, || HashSet::new::<uint>());\n-        results.bench_str(&mut rng, num_keys, || HashSet::new::<~str>());\n+        results.bench_int(&mut rng, num_keys, max, || {\n+            let s: HashSet<uint> = HashSet::new();\n+            s\n+        });\n+        results.bench_str(&mut rng, num_keys, || {\n+            let s: HashSet<~str> = HashSet::new();\n+            s\n+        });\n         write_results(\"std::hashmap::HashSet\", &results);\n     }\n \n     {\n         let mut rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(&mut rng, num_keys, max, || TreeSet::new::<uint>());\n-        results.bench_str(&mut rng, num_keys, || TreeSet::new::<~str>());\n+        results.bench_int(&mut rng, num_keys, max, || {\n+            let s: TreeSet<uint> = TreeSet::new();\n+            s\n+        });\n+        results.bench_str(&mut rng, num_keys, || {\n+            let s: TreeSet<~str> = TreeSet::new();\n+            s\n+        });\n         write_results(\"extra::treemap::TreeSet\", &results);\n     }\n "}, {"sha": "e4833345d311c0c8e11b868704235dbbe78ff9a6", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -0,0 +1,37 @@\n+#[no_std];\n+\n+struct S<T> {\n+    contents: T,\n+}\n+\n+impl<T> S<T> {\n+    fn new<U>(x: T, _: U) -> S<T> {\n+        S {\n+            contents: x,\n+        }\n+    }\n+}\n+\n+trait Trait<T> {\n+    fn new<U>(x: T, y: U) -> Self;\n+}\n+\n+struct S2 {\n+    contents: int,\n+}\n+\n+impl Trait<int> for S2 {\n+    fn new<U>(x: int, _: U) -> S2 {\n+        S2 {\n+            contents: x,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let _ = S::new::<int,float>(1, 1.0);    //~ ERROR the impl referenced by this path has 1 type parameter, but 0 type parameters were supplied\n+    let _ = S::<'self,int>::new::<float>(1, 1.0);  //~ ERROR this impl has no lifetime parameter\n+    let _: S2 = Trait::new::<int,float>(1, 1.0);    //~ ERROR the trait referenced by this path has 1 type parameter, but 0 type parameters were supplied\n+    let _: S2 = Trait::<'self,int>::new::<float>(1, 1.0);   //~ ERROR this trait has no lifetime parameter\n+}\n+"}, {"sha": "c51cf5b9538d9309a45cbcb2583e1dc2854f2071", "filename": "src/test/compile-fail/borrowck-alias-mut-base-ptr.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs?ref=32117132bdaf572bd4a156ec931579646e16d6f0", "patch": "@@ -1,15 +0,0 @@\n-// Test that attempt to alias `&mut` pointer while pointee is borrowed\n-// yields an error.\n-//\n-// Example from src/middle/borrowck/doc.rs\n-\n-use std::util::swap;\n-\n-fn foo(t0: &mut int) {\n-    let p: &int = &*t0; // Freezes `*t0`\n-    let q: &const &mut int = &const t0; //~ ERROR cannot borrow `t0`\n-    **q = 22; //~ ERROR cannot assign to an `&mut` in a `&const` pointer\n-}\n-\n-fn main() {\n-}\n\\ No newline at end of file"}, {"sha": "843b5436d842c7c89322641dc8c0c70a501df5ef", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -11,21 +11,11 @@ fn foo(t0: & &mut int) {\n     **t1 = 22; //~ ERROR cannot assign\n }\n \n-fn foo2(t0: &const &mut int) {\n-    // Note: reborrowing from an &const actually yields two errors, since it\n-    // is unsafe in two ways: we can't control the aliasing, and we can't\n-    // control the mutation.\n-    let t1 = t0;\n-    let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&const` pointer\n-    //~^ ERROR unsafe borrow of aliasable, const value\n-    **t1 = 22; //~ ERROR cannot assign\n-}\n-\n fn foo3(t0: &mut &mut int) {\n     let t1 = &mut *t0;\n     let p: &int = &**t0; //~ ERROR cannot borrow\n     **t1 = 22;\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c004b3d0e5498fb821eda257abf44e2beec7124c", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -13,8 +13,7 @@\n use std::hashmap::HashMap;\n \n fn main() {\n-    let mut buggy_map :HashMap<uint, &uint> =\n-      HashMap::new::<uint, &uint>();\n+    let mut buggy_map: HashMap<uint, &uint> = HashMap::new();\n     buggy_map.insert(42, &*~1); //~ ERROR borrowed value does not live long enough\n \n     // but it is ok if we use a temporary"}, {"sha": "537e52120d9f1f2c02712f0037ec5aaf6dc55d65", "filename": "src/test/compile-fail/borrowck-call-method-from-mut-aliasable.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -14,29 +14,18 @@ struct Foo {\n \n impl Foo {\n     pub fn f(&self) {}\n-    pub fn g(&const self) {}\n     pub fn h(&mut self) {}\n }\n \n fn a(x: &mut Foo) {\n     x.f();\n-    x.g();\n     x.h();\n }\n \n fn b(x: &Foo) {\n     x.f();\n-    x.g();\n     x.h(); //~ ERROR cannot borrow\n }\n \n-fn c(x: &const Foo) {\n-    x.f(); //~ ERROR cannot borrow\n-    //~^ ERROR unsafe borrow\n-    x.g();\n-    x.h(); //~ ERROR cannot borrow\n-    //~^ ERROR unsafe borrow\n-}\n-\n fn main() {\n }"}, {"sha": "ea840a28b4e6ac97efd6fe7ebb3af8bbcbe691a9", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -32,14 +32,6 @@ fn pre_freeze() {\n     borrow_mut(v); //~ ERROR cannot borrow\n }\n \n-fn pre_const() {\n-    // In this instance, the freeze starts before the mut borrow.\n-\n-    let mut v = ~3;\n-    let _w = &const v;\n-    borrow_mut(v);\n-}\n-\n fn post_freeze() {\n     // In this instance, the const alias starts after the borrow.\n "}, {"sha": "8a4a2cdedb23095987208afbdf2383b9e9c1722f", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -29,16 +29,5 @@ fn has_mut_vec_but_tries_to_change_it() {\n     }\n }\n \n-fn takes_const_elt(_v: &const int, f: &fn()) {\n-    f();\n-}\n-\n-fn has_mut_vec_and_tries_to_change_it() {\n-    let mut v = ~[1, 2, 3];\n-    do takes_const_elt(&const v[0]) {\n-        v[1] = 4;\n-    }\n-}\n-\n fn main() {\n }"}, {"sha": "e77f5245d7d8bb14906e6343d1d918599c2e58e2", "filename": "src/test/compile-fail/borrowck-pat-by-value-binding.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs?ref=32117132bdaf572bd4a156ec931579646e16d6f0", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn process<T>(_t: T) {}\n-\n-fn match_const_opt_by_mut_ref(v: &const Option<int>) {\n-    match *v {\n-      Some(ref mut i) => process(i), //~ ERROR cannot borrow\n-        //~^ ERROR unsafe borrow of aliasable, const value\n-      None => ()\n-    }\n-}\n-\n-fn match_const_opt_by_const_ref(v: &const Option<int>) {\n-    match *v {\n-      Some(ref const i) => process(i),\n-        //~^ ERROR unsafe borrow of aliasable, const value\n-      None => ()\n-    }\n-}\n-\n-fn match_const_opt_by_imm_ref(v: &const Option<int>) {\n-    match *v {\n-      Some(ref i) => process(i), //~ ERROR cannot borrow\n-        //~^ ERROR unsafe borrow of aliasable, const value\n-      None => ()\n-    }\n-}\n-\n-fn match_const_opt_by_value(v: &const Option<int>) {\n-    match *v {\n-      Some(i) => process(i),\n-      None => ()\n-    }\n-}\n-\n-fn main() {\n-}"}, {"sha": "c87428cd300a7ab47bdcb7ca2dc4cac3d0397660", "filename": "src/test/compile-fail/borrowck-uniq-via-lend.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -35,12 +35,6 @@ fn aliased_imm() {\n     borrow(v);\n }\n \n-fn aliased_const() {\n-    let mut v = ~3;\n-    let _w = &const v;\n-    borrow(v);\n-}\n-\n fn aliased_mut() {\n     let mut v = ~3;\n     let _w = &mut v;"}, {"sha": "e42c6b658e4f7b87b5307935c361bc1702e3f940", "filename": "src/test/compile-fail/fn-variance-3.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -23,13 +23,10 @@ fn main() {\n \n     // @int <: X\n     //\n-    // This constraint forces X to be\n-    // @const int.\n-    r(@3);\n+    // Here the type check fails because @const is gone and there is no\n+    // supertype.\n+    r(@3);  //~ ERROR mismatched types\n \n-    // Here the type check succeeds but the\n-    // mutability check will fail, because the\n-    // type of r has been inferred to be\n-    // fn(@const int) -> @const int\n-    *r(@mut 3) = 4; //~ ERROR cannot assign to const dereference of @ pointer\n+    // Here the type check succeeds.\n+    *r(@mut 3) = 4;\n }"}, {"sha": "b60a54a44bbfdf853fe8874151597b6688813439", "filename": "src/test/compile-fail/issue-3969.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs?ref=32117132bdaf572bd4a156ec931579646e16d6f0", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Bike {\n-    name: ~str,\n-}\n-\n-trait BikeMethods {\n-    fn woops(&const self) -> ~str;\n-}\n-\n-impl BikeMethods for Bike {\n-    fn woops() -> ~str { ~\"foo\" }\n-    //~^ ERROR has a `&const self` declaration in the trait, but not in the impl\n-}\n-\n-pub fn main() {\n-}"}, {"sha": "3f1172b6de8f61c7e8244b8c8e823adbb94c63f7", "filename": "src/test/compile-fail/issue-4096.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fissue-4096.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fissue-4096.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4096.rs?ref=32117132bdaf572bd4a156ec931579646e16d6f0", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub trait Nummy {\n-    fn from_inty<T>() -> Self;\n-}\n-\n-impl Nummy for float {\n-    fn from_inty<T>() -> float { 0.0 }\n-}\n-\n-fn main() {\n-    let _1:float = Nummy::from_inty::<int>();  //~ ERROR not enough type\n-    //~^ NOTE Static methods have an extra implicit type parameter\n-}"}, {"sha": "19423c6690f316a77aa1ae2192c5d7fef7797af4", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -14,8 +14,8 @@ use std::hashmap::HashMap;\n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n-    let x: @Map<~str, ~str> = @HashMap::new::<~str, ~str>() as\n-        @Map<~str, ~str>;\n+    let x: @HashMap<~str, ~str> = @HashMap::new();\n+    let x: @Map<~str, ~str> = x as @Map<~str, ~str>;\n     let y: @Map<uint, ~str> = @x;\n     //~^ ERROR expected trait std::container::Map but found @-ptr\n }"}, {"sha": "4460da72e205993ac9e03025a6a9e126502079a0", "filename": "src/test/compile-fail/mutable-huh-ptr-assign.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32117132bdaf572bd4a156ec931579646e16d6f0/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs?ref=32117132bdaf572bd4a156ec931579646e16d6f0", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern mod extra;\n-\n-fn main() {\n-    unsafe fn f(v: *const int) {\n-        *v = 1 //~ ERROR cannot assign\n-    }\n-\n-    unsafe {\n-        let mut a = 0;\n-        let v = &mut a;\n-        f(v);\n-    }\n-}"}, {"sha": "e60fbf4fc49a8c4904438b5eacd07be55db4943c", "filename": "src/test/compile-fail/prim-with-args.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -23,17 +23,17 @@ let x: u64<int>; //~ ERROR type parameters are not allowed on this type\n let x: float<int>; //~ ERROR type parameters are not allowed on this type\n let x: char<int>; //~ ERROR type parameters are not allowed on this type\n \n-let x: int<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: i8<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: i16<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: i32<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: i64<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: uint<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: u8<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: u16<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: u32<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: u64<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: float<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: char<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: int<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: i8<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: i16<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: i32<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: i64<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: uint<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: u8<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: u16<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: u32<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: u64<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: float<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: char<'static>; //~ ERROR lifetime parameters are not allowed on this type\n \n }"}, {"sha": "c3946b330103aa57ee361d81dd1349c6698f14da", "filename": "src/test/compile-fail/private-variant-xc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fprivate-variant-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fprivate-variant-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-variant-xc.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -1,4 +1,5 @@\n // aux-build:private_variant_xc.rs\n+// xfail-test\n \n extern mod private_variant_xc;\n "}, {"sha": "ab365c1bf6fb38ced9cd18e02a886fd21b69bf96", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -25,8 +25,4 @@ fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n     //~^ ERROR cannot infer an appropriate lifetime\n }\n \n-fn a_fn4<'a,'b>() {\n-    let _: int<'a> = 1; //~ ERROR region parameters are not allowed on this type\n-}\n-\n fn main() { }"}, {"sha": "351daf461d2fea5bfbaf26ca1cbb923c7bb501d6", "filename": "src/test/compile-fail/resolve-inconsistent-binding-mode.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -26,13 +26,6 @@ fn matcher2(x: opts) {\n     }\n }\n \n-fn matcher3(x: opts) {\n-    match x {\n-      a(ref mut i) | b(ref const i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n-      c(_) => {}\n-    }\n-}\n-\n fn matcher4(x: opts) {\n     match x {\n       a(ref mut i) | b(ref i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1"}, {"sha": "b637037f60e8f6167e9a3a8c415d36cf4bd6cfc0", "filename": "src/test/compile-fail/static-method-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -6,5 +6,5 @@ mod a {\n }\n \n fn main() {\n-    let _ = a::S::new();    //~ ERROR function `new` is private\n+    let _ = a::S::new();    //~ ERROR method `new` is private\n }"}, {"sha": "371bac7a902feecd1470aa8d9fcd6bdbcaf202dc", "filename": "src/test/compile-fail/xc-private-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -7,10 +7,10 @@ fn main() {\n     // normal method on struct\n     let _ = xc_private_method_lib::Struct{ x: 10 }.meth_struct();  //~ ERROR method `meth_struct` is private\n     // static method on struct\n-    let _ = xc_private_method_lib::Struct::static_meth_struct();  //~ ERROR function `static_meth_struct` is private\n+    let _ = xc_private_method_lib::Struct::static_meth_struct();  //~ ERROR method `static_meth_struct` is private\n \n     // normal method on enum\n     let _ = xc_private_method_lib::Variant1(20).meth_enum();  //~ ERROR method `meth_enum` is private\n     // static method on enum\n-    let _ = xc_private_method_lib::Enum::static_meth_enum();  //~ ERROR function `static_meth_enum` is private\n+    let _ = xc_private_method_lib::Enum::static_meth_enum();  //~ ERROR method `static_meth_enum` is private\n }"}, {"sha": "9dd6d1ef173df35359aa17cc1612d95fe65edca7", "filename": "src/test/debug-info/generic-trait-generic-static-default-method.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fdebug-info%2Fgeneric-trait-generic-static-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fdebug-info%2Fgeneric-trait-generic-static-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-trait-generic-static-default-method.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n // Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "2d666bf4cf5aa7d483c879144b234f209e67735c", "filename": "src/test/debug-info/trait-generic-static-default-method.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fdebug-info%2Ftrait-generic-static-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Fdebug-info%2Ftrait-generic-static-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftrait-generic-static-default-method.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n // Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "d35341516f2a73d5b3ab86420cdd5e65587e2d9e", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -13,17 +13,14 @@\n \n trait MyIter {\n     fn test_imm(&self);\n-    fn test_const(&const self);\n }\n \n impl<'self> MyIter for &'self [int] {\n     fn test_imm(&self) { assert_eq!(self[0], 1) }\n-    fn test_const(&const self) { assert_eq!(self[0], 1) }\n }\n \n impl<'self> MyIter for &'self str {\n     fn test_imm(&self) { assert_eq!(*self, \"test\") }\n-    fn test_const(&const self) { assert_eq!(self[0], 't' as u8) }\n }\n \n pub fn main() {\n@@ -40,15 +37,6 @@ pub fn main() {\n \n     // XXX: Other types of mutable vecs don't currently exist\n \n-    ([1]).test_const();\n-    (~[1]).test_const();\n-    (@[1]).test_const();\n-    (&[1]).test_const();\n-    (\"test\").test_const();\n-    (~\"test\").test_const();\n-    (@\"test\").test_const();\n-    (&\"test\").test_const();\n-\n     // NB: We don't do this double autoreffing for &mut self because that would\n     // allow creating a mutable pointer to a temporary, which would be a source\n     // of confusion"}, {"sha": "fc643ec594089a4cc62f9eca2343f6e4afc6ee01", "filename": "src/test/run-pass/autoderef-and-borrow-method-receiver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -13,7 +13,7 @@ struct Foo {\n }\n \n impl Foo {\n-    pub fn f(&const self) {}\n+    pub fn f(&self) {}\n }\n \n fn g(x: &mut Foo) {"}, {"sha": "f320de39c8c3b2fb762e648e1d5cd6ba7707d129", "filename": "src/test/run-pass/borrowck-pat-enum.rs", "status": "renamed", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -1,3 +1,5 @@\n+// xfail-pretty\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -24,32 +26,9 @@ fn match_ref_unused(v: Option<int>) {\n     }\n }\n \n-fn match_const_reg(v: &const Option<int>) -> int {\n-    match *v {\n-      Some(ref i) => {*i} //~ ERROR cannot borrow\n-        //~^ ERROR unsafe borrow\n-      None => {0}\n-    }\n-}\n-\n fn impure(_i: int) {\n }\n \n-fn match_const_reg_unused(v: &const Option<int>) {\n-    match *v {\n-      Some(_) => {impure(0)} // OK because nothing is captured\n-      None => {}\n-    }\n-}\n-\n-fn match_const_reg_impure(v: &const Option<int>) {\n-    match *v {\n-      Some(ref i) => {impure(*i)} //~ ERROR cannot borrow\n-        //~^ ERROR unsafe borrow\n-      None => {}\n-    }\n-}\n-\n fn match_imm_reg(v: &Option<int>) {\n     match *v {\n       Some(ref i) => {impure(*i)} // OK because immutable", "previous_filename": "src/test/compile-fail/borrowck-pat-enum.rs"}, {"sha": "44f3a8f518a15c44273230efbb3f8c8de49bb770", "filename": "src/test/run-pass/borrowck-uniq-via-ref.rs", "status": "renamed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-uniq-via-ref.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -25,7 +25,6 @@ struct Innermost {\n }\n \n fn borrow(_v: &int) {}\n-fn borrow_const(_v: &const int) {}\n \n fn box_mut(v: &mut ~int) {\n     borrow(*v); // OK: &mut -> &imm\n@@ -51,17 +50,5 @@ fn box_imm_recs(v: &Outer) {\n     borrow(v.f.g.h); // OK\n }\n \n-fn box_const(v: &const ~int) {\n-    borrow_const(*v); //~ ERROR unsafe borrow\n-}\n-\n-fn box_const_rec(v: &const Rec) {\n-    borrow_const(v.f); //~ ERROR unsafe borrow\n-}\n-\n-fn box_const_recs(v: &const Outer) {\n-    borrow_const(v.f.g.h); //~ ERROR unsafe borrow\n-}\n-\n fn main() {\n }", "previous_filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs"}, {"sha": "03dd33b08e2350fe167a8421038f78678ebab177", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -49,8 +49,8 @@ impl<T> cat<T> {\n }\n \n impl<T> Container for cat<T> {\n-    fn len(&const self) -> uint { self.meows as uint }\n-    fn is_empty(&const self) -> bool { self.meows == 0 }\n+    fn len(&self) -> uint { self.meows as uint }\n+    fn is_empty(&self) -> bool { self.meows == 0 }\n }\n \n impl<T> Mutable for cat<T> {"}, {"sha": "52fa1399363cdf4de434167400dce4ee8bbb49c3", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-rcvr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -3,14 +3,14 @@ struct SpeechMaker {\n }\n \n impl SpeechMaker {\n-    pub fn how_many(&const self) -> uint { self.speeches }\n+    pub fn how_many(&self) -> uint { self.speeches }\n }\n \n-fn foo(speaker: &const SpeechMaker) -> uint {\n+fn foo(speaker: &SpeechMaker) -> uint {\n     speaker.how_many() + 33\n }\n \n pub fn main() {\n     let lincoln = SpeechMaker {speeches: 22};\n-    assert_eq!(foo(&const lincoln), 55);\n+    assert_eq!(foo(&lincoln), 55);\n }"}, {"sha": "84ee54cfdde6d548203c8ba43e7b09f61f17ad27", "filename": "src/test/run-pass/const-vec-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fconst-vec-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fconst-vec-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-syntax.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(_: &const [int]) {}\n+fn f(_: &[int]) {}\n \n pub fn main() {\n     let v = [ 1, 2, 3 ];"}, {"sha": "aba23e53282c788e7a4902ca5b3c54fc5a644e87", "filename": "src/test/run-pass/deriving-zero.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -36,5 +36,6 @@ struct Lots {\n }\n \n fn main() {\n-    assert!(Zero::zero::<Lots>().is_zero());\n+    let lots: Lots = Zero::zero();\n+    assert!(lots.is_zero());\n }"}, {"sha": "d59b8c77d006701d7348f48e467ace828521c629", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -13,11 +13,12 @@ extern mod extra;\n use std::num::Float;\n \n pub fn main() {\n-  let nan = Float::NaN::<float>();\n+  let nan: float = Float::NaN();\n   assert!((nan).is_NaN());\n \n-  let inf = Float::infinity::<float>();\n-  assert_eq!(-inf, Float::neg_infinity::<float>());\n+  let inf: float = Float::infinity();\n+  let neg_inf: float = Float::neg_infinity();\n+  assert_eq!(-inf, neg_inf);\n \n   assert!( nan !=  nan);\n   assert!( nan != -nan);"}, {"sha": "ce471e5c827ecd6e1ac2f107fc86083c3d3307b5", "filename": "src/test/run-pass/issue-3026.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3026.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -13,7 +13,7 @@\n use std::hashmap::HashMap;\n \n pub fn main() {\n-    let mut buggy_map: HashMap<uint, &uint> = HashMap::new::<uint, &uint>();\n+    let mut buggy_map: HashMap<uint, &uint> = HashMap::new();\n     let x = ~1;\n     buggy_map.insert(42, &*x);\n }"}, {"sha": "8e9502d6d49e616d82b99284721180853795d092", "filename": "src/test/run-pass/issue-6898.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fissue-6898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fissue-6898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6898.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n // Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "1bc37a035e046d98ffd8353b28a7f0a55119db6f", "filename": "src/test/run-pass/mid-path-type-params.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -0,0 +1,33 @@\n+struct S<T> {\n+    contents: T,\n+}\n+\n+impl<T> S<T> {\n+    fn new<U>(x: T, _: U) -> S<T> {\n+        S {\n+            contents: x,\n+        }\n+    }\n+}\n+\n+trait Trait<T> {\n+    fn new<U>(x: T, y: U) -> Self;\n+}\n+\n+struct S2 {\n+    contents: int,\n+}\n+\n+impl Trait<int> for S2 {\n+    fn new<U>(x: int, _: U) -> S2 {\n+        S2 {\n+            contents: x,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let _ = S::<int>::new::<float>(1, 1.0);\n+    let _: S2 = Trait::<int>::new::<float>(1, 1.0);\n+}\n+"}, {"sha": "baef20944f7047a0fbc825b0bd3be85286f74f35", "filename": "src/test/run-pass/objects-owned-object-borrowed-method-header.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -1,3 +1,5 @@\n+// xfail-pretty\n+\n // Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "a4510ef70e1b257b1db70f9dbcddf21b79801084", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -1,3 +1,5 @@\n+// xfail-pretty\n+\n // Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "baf4cf45b3ce8aa1f996ed7d1842990f9fbd215d", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -59,7 +59,7 @@ fn main () {\n \n     assert_eq!(0i.thing(3.14, 1), (3.14, 1));\n     assert_eq!(B::staticthing(&0i, 3.14, 1), (3.14, 1));\n-    assert_eq!(B::staticthing::<float, int, int>(&0i, 3.14, 1), (3.14, 1));\n+    assert_eq!(B::<float>::staticthing::<int>(&0i, 3.14, 1), (3.14, 1));\n \n     assert_eq!(g(0i, 3.14, 1), (3.14, 1));\n     assert_eq!(g(false, 3.14, 1), (3.14, 1));"}, {"sha": "5ac26e65d888010bb94b9e5f9eb4e98b2ad283a4", "filename": "src/test/run-pass/trait-static-method-overwriting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578e68047736167239c52fa1aba0347011ff1bc3/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs?ref=578e68047736167239c52fa1aba0347011ff1bc3", "patch": "@@ -14,7 +14,7 @@ mod base {\n     use std::io;\n \n     pub trait HasNew<T> {\n-        fn new() -> T;\n+        fn new() -> Self;\n     }\n \n     pub struct Foo {\n@@ -41,6 +41,6 @@ mod base {\n }\n \n pub fn main() {\n-    let _f: base::Foo = base::HasNew::new::<base::Foo, base::Foo>();\n-    let _b: base::Bar = base::HasNew::new::<base::Bar, base::Bar>();\n+    let _f: base::Foo = base::HasNew::<base::Foo>::new();\n+    let _b: base::Bar = base::HasNew::<base::Bar>::new();\n }"}]}