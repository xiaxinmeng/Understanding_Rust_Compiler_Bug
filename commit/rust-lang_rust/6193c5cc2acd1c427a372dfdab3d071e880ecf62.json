{"sha": "6193c5cc2acd1c427a372dfdab3d071e880ecf62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxOTNjNWNjMmFjZDFjNDI3YTM3MmRmZGFiM2QwNzFlODgwZWNmNjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-03T12:01:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-15T15:10:56Z"}, "message": "translate `Verify`s into `TypeTest`s and check them", "tree": {"sha": "ed1cb2879b21cd932f0b870dafc1482dcec412e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed1cb2879b21cd932f0b870dafc1482dcec412e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6193c5cc2acd1c427a372dfdab3d071e880ecf62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6193c5cc2acd1c427a372dfdab3d071e880ecf62", "html_url": "https://github.com/rust-lang/rust/commit/6193c5cc2acd1c427a372dfdab3d071e880ecf62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6193c5cc2acd1c427a372dfdab3d071e880ecf62/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd564d20ff521d56ad3f01fe0e0588d9487c0c13", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd564d20ff521d56ad3f01fe0e0588d9487c0c13", "html_url": "https://github.com/rust-lang/rust/commit/cd564d20ff521d56ad3f01fe0e0588d9487c0c13"}], "stats": {"total": 413, "additions": 389, "deletions": 24}, "files": [{"sha": "dcf5d979a4c0aceaa963074d6ed2d5afbe765674", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=6193c5cc2acd1c427a372dfdab3d071e880ecf62", "patch": "@@ -11,11 +11,12 @@\n //! Module defining the `dfs` method on `RegionInferenceContext`, along with\n //! its associated helper traits.\n \n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::region_infer::values::{RegionElementIndex, RegionValues, RegionValueElements};\n use rustc::mir::{Location, Mir};\n use rustc::ty::RegionVid;\n use rustc_data_structures::fx::FxHashSet;\n-use super::RegionInferenceContext;\n-use super::values::{RegionElementIndex, RegionValues, RegionValueElements};\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Function used to satisfy or test a `R1: R2 @ P`\n@@ -165,17 +166,16 @@ impl<'v> DfsOp for CopyFromSourceToTarget<'v> {\n /// condition. Similarly, if we reach the end of the graph and find\n /// that R1 contains some universal region that R2 does not contain,\n /// we abort the walk early.\n-#[allow(dead_code)] // TODO\n-pub(super) struct TestTarget<'v> {\n-    source_region: RegionVid,\n-    target_region: RegionVid,\n-    elements: &'v RegionValueElements,\n-    inferred_values: &'v RegionValues,\n-    constraint_point: Location,\n+pub(super) struct TestTargetOutlivesSource<'v, 'tcx: 'v> {\n+    pub source_region: RegionVid,\n+    pub target_region: RegionVid,\n+    pub elements: &'v RegionValueElements,\n+    pub universal_regions: &'v UniversalRegions<'tcx>,\n+    pub inferred_values: &'v RegionValues,\n+    pub constraint_point: Location,\n }\n \n-#[allow(dead_code)] // TODO\n-impl<'v> DfsOp for TestTarget<'v> {\n+impl<'v, 'tcx> DfsOp for TestTargetOutlivesSource<'v, 'tcx> {\n     /// The element that was not found within R2.\n     type Early = RegionElementIndex;\n \n@@ -204,12 +204,32 @@ impl<'v> DfsOp for TestTarget<'v> {\n     fn add_universal_regions_outlived_by_source_to_target(\n         &mut self,\n     ) -> Result<bool, RegionElementIndex> {\n-        for ur in self.inferred_values\n+        // For all `ur_in_source` in `source_region`.\n+        for ur_in_source in self.inferred_values\n             .universal_regions_outlived_by(self.source_region)\n         {\n-            if !self.inferred_values.contains(self.target_region, ur) {\n-                return Err(self.elements.index(ur));\n+            // Check that `target_region` outlives `ur_in_source`.\n+\n+            // If `ur_in_source` is a member of `target_region`, OK.\n+            //\n+            // (This is implied by the loop below, actually, just an\n+            // irresistible micro-opt. Mm. Premature optimization. So\n+            // tasty.)\n+            if self.inferred_values.contains(self.target_region, ur_in_source) {\n+                continue;\n             }\n+\n+            // If there is some other element X such that `target_region: X` and\n+            // `X: ur_in_source`, OK.\n+            if self.inferred_values\n+                   .universal_regions_outlived_by(self.target_region)\n+                   .any(|ur_in_target| self.universal_regions.outlives(ur_in_target, ur_in_source))\n+            {\n+                continue;\n+            }\n+\n+            // Otherwise, not known to be true.\n+            return Err(self.elements.index(ur_in_source));\n         }\n \n         Ok(false)"}, {"sha": "86ba7524bf055645491721de9ee9b09af9a31ac7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 217, "deletions": 3, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=6193c5cc2acd1c427a372dfdab3d071e880ecf62", "patch": "@@ -14,7 +14,7 @@ use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n-use rustc::infer::region_constraints::VarOrigins;\n+use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n use rustc::mir::{ClosureOutlivesRequirement, ClosureRegionRequirements, Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -24,7 +24,7 @@ use syntax_pos::Span;\n \n mod annotation;\n mod dfs;\n-use self::dfs::CopyFromSourceToTarget;\n+use self::dfs::{CopyFromSourceToTarget, TestTargetOutlivesSource};\n mod dump_mir;\n mod graphviz;\n mod values;\n@@ -53,6 +53,9 @@ pub struct RegionInferenceContext<'tcx> {\n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n \n+    /// Type constraints that we check after solving.\n+    type_tests: Vec<TypeTest<'tcx>>,\n+\n     /// Information about the universally quantified regions in scope\n     /// on this function and their (known) relations to one another.\n     universal_regions: UniversalRegions<'tcx>,\n@@ -95,6 +98,90 @@ pub struct Constraint {\n     span: Span,\n }\n \n+/// A \"type test\" corresponds to an outlives constraint between a type\n+/// and a lifetime, like `T: 'x` or `<T as Foo>::Bar: 'x`.  They are\n+/// translated from the `Verify` region constraints in the ordinary\n+/// inference context.\n+///\n+/// These sorts of constraints are handled differently than ordinary\n+/// constraints, at least at present. During type checking, the\n+/// `InferCtxt::process_registered_region_obligations` method will\n+/// attempt to convert a type test like `T: 'x` into an ordinary\n+/// outlives constraint when possible (for example, `&'a T: 'b` will\n+/// be converted into `'a: 'b` and registered as a `Constraint`).\n+///\n+/// In some cases, however, there are outlives relationships that are\n+/// not converted into a region constraint, but rather into one of\n+/// these \"type tests\".  The distinction is that a type test does not\n+/// influence the inference result, but instead just examines the\n+/// values that we ultimately inferred for each region variable and\n+/// checks that they meet certain extra criteria.  If not, an error\n+/// can be issued.\n+///\n+/// One reason for this is that these type tests always boil down to a\n+/// check like `'a: 'x` where `'a` is a universally quantified region\n+/// -- and therefore not one whose value is really meant to be\n+/// *inferred*, precisely. Another reason is that these type tests can\n+/// involve *disjunction* -- that is, they can be satisfied in more\n+/// than one way.\n+///\n+/// For more information about this translation, see\n+/// `InferCtxt::process_registered_region_obligations` and\n+/// `InferCtxt::type_must_outlive` in `rustc::infer::outlives`.\n+#[derive(Clone, Debug)]\n+pub struct TypeTest<'tcx> {\n+    /// The type `T` that must outlive the region.\n+    pub generic_kind: GenericKind<'tcx>,\n+\n+    /// The region `'x` that the type must outlive.\n+    pub lower_bound: RegionVid,\n+\n+    /// The point where the outlives relation must hold.\n+    pub point: Location,\n+\n+    /// Where did this constraint arise?\n+    pub span: Span,\n+\n+    /// A test which, if met by the region `'x`, proves that this type\n+    /// constraint is satisfied.\n+    pub test: RegionTest,\n+}\n+\n+/// A \"test\" that can be applied to some \"subject region\" `'x`. These are used to\n+/// describe type constraints. Tests do not presently affect the\n+/// region values that get inferred for each variable; they only\n+/// examine the results *after* inference.  This means they can\n+/// conveniently include disjuction (\"a or b must be true\").\n+#[derive(Clone, Debug)]\n+pub enum RegionTest {\n+    /// The subject region `'x` must by outlived by *some* region in\n+    /// the given set of regions.\n+    ///\n+    /// This test comes from e.g. a where clause like `T: 'a + 'b`,\n+    /// which implies that we know that `T: 'a` and that `T:\n+    /// 'b`. Therefore, if we are trying to prove that `T: 'x`, we can\n+    /// do so by showing that `'a: 'x` *or* `'b: 'x`.\n+    IsOutlivedByAnyRegionIn(Vec<RegionVid>),\n+\n+    /// The subject region `'x` must by outlived by *all* regions in\n+    /// the given set of regions.\n+    ///\n+    /// This test comes from e.g. a projection type like `T = <u32 as\n+    /// Trait<'a, 'b>>::Foo`, which must outlive `'a` or `'b`, and\n+    /// maybe both. Therefore we can prove that `T: 'x` if we know\n+    /// that `'a: 'x` *and* `'b: 'x`.\n+    IsOutlivedByAllRegionsIn(Vec<RegionVid>),\n+\n+    /// Any of the given tests are true.\n+    ///\n+    /// This arises from projections, for which there are multiple\n+    /// ways to prove an outlives relationship.\n+    Any(Vec<RegionTest>),\n+\n+    /// All of the given tests are true.\n+    All(Vec<RegionTest>),\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -122,6 +209,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n             constraints: Vec::new(),\n+            type_tests: Vec::new(),\n             universal_regions,\n         };\n \n@@ -243,7 +331,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n     }\n \n-    /// Perform region inference.\n+    /// Add a \"type test\" that must be satisfied.\n+    pub(super) fn add_type_test(&mut self, type_test: TypeTest<'tcx>) {\n+        self.type_tests.push(type_test);\n+    }\n+\n+    /// Perform region inference and report errors if we see any\n+    /// unsatisfiable constraints. If this is a closure, returns the\n+    /// region requirements to propagate to our creator, if any.\n     pub(super) fn solve(\n         &mut self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n@@ -254,6 +349,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         self.propagate_constraints(mir);\n \n+        self.check_type_tests(infcx, mir);\n+\n         let outlives_requirements = self.check_universal_regions(infcx, mir_def_id);\n \n         if outlives_requirements.is_empty() {\n@@ -315,6 +412,123 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.inferred_values = Some(inferred_values);\n     }\n \n+    /// Once regions have been propagated, this method is used to see\n+    /// whether any of the constraints were too strong. In particular,\n+    /// we want to check for a case where a universally quantified\n+    /// region exceeded its bounds.  Consider:\n+    ///\n+    ///     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    ///\n+    /// In this case, returning `x` requires `&'a u32 <: &'b u32`\n+    /// and hence we establish (transitively) a constraint that\n+    /// `'a: 'b`. The `propagate_constraints` code above will\n+    /// therefore add `end('a)` into the region for `'b` -- but we\n+    /// have no evidence that `'b` outlives `'a`, so we want to report\n+    /// an error.\n+    fn check_type_tests(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+    ) {\n+        for type_test in &self.type_tests {\n+            debug!(\"check_type_test: {:?}\", type_test);\n+\n+            if !self.eval_region_test(\n+                mir,\n+                type_test.point,\n+                type_test.lower_bound,\n+                &type_test.test,\n+            ) {\n+                // Oh the humanity. Obviously we will do better than this error eventually.\n+                infcx.tcx.sess.span_err(\n+                    type_test.span,\n+                    &format!(\"failed type test: {:?}\", type_test),\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Test if `test` is true when applied to `lower_bound` at\n+    /// `point`, and returns true or false.\n+    fn eval_region_test(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        point: Location,\n+        lower_bound: RegionVid,\n+        test: &RegionTest,\n+    ) -> bool {\n+        debug!(\n+            \"eval_region_test(point={:?}, lower_bound={:?}, test={:?})\",\n+            point,\n+            lower_bound,\n+            test\n+        );\n+\n+        match test {\n+            RegionTest::IsOutlivedByAllRegionsIn(regions) => regions\n+                .iter()\n+                .all(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n+\n+            RegionTest::IsOutlivedByAnyRegionIn(regions) => regions\n+                .iter()\n+                .any(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n+\n+            RegionTest::Any(tests) => tests\n+                .iter()\n+                .any(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+\n+            RegionTest::All(tests) => tests\n+                .iter()\n+                .all(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+        }\n+    }\n+\n+    // Evaluate whether `sup_region: sub_region @ point`.\n+    fn eval_outlives(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        sup_region: RegionVid,\n+        sub_region: RegionVid,\n+        point: Location,\n+    ) -> bool {\n+        debug!(\n+            \"eval_outlives({:?}: {:?} @ {:?})\",\n+            sup_region,\n+            sub_region,\n+            point\n+        );\n+\n+        // Roughly speaking, do a DFS of all region elements reachable\n+        // from `point` contained in `sub_region`. If any of those are\n+        // *not* present in `sup_region`, the DFS will abort early and\n+        // yield an `Err` result.\n+        match self.dfs(\n+            mir,\n+            TestTargetOutlivesSource {\n+                source_region: sub_region,\n+                target_region: sup_region,\n+                constraint_point: point,\n+                elements: &self.elements,\n+                universal_regions: &self.universal_regions,\n+                inferred_values: self.inferred_values.as_ref().unwrap(),\n+            },\n+        ) {\n+            Ok(_) => {\n+                debug!(\"eval_outlives: true\");\n+                true\n+            }\n+\n+            Err(elem) => {\n+                debug!(\n+                    \"eval_outlives: false because `{:?}` is not present in `{:?}`\",\n+                    self.elements.to_element(elem),\n+                    sup_region\n+                );\n+                false\n+            }\n+        }\n+    }\n+\n     /// Once regions have been propagated, this method is used to see\n     /// whether any of the constraints were too strong. In particular,\n     /// we want to check for a case where a universally quantified"}, {"sha": "73c40827c540f607c7bec94a81b8cd9d667b94f2", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=6193c5cc2acd1c427a372dfdab3d071e880ecf62", "patch": "@@ -11,11 +11,14 @@\n use rustc::mir::Mir;\n use rustc::infer::region_constraints::Constraint;\n use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::infer::region_constraints::{Verify, VerifyBound};\n use rustc::ty;\n+use syntax::codemap::Span;\n+use transform::type_check::Locations;\n use transform::type_check::MirTypeckRegionConstraints;\n use transform::type_check::OutlivesSet;\n \n-use super::region_infer::RegionInferenceContext;\n+use super::region_infer::{TypeTest, RegionInferenceContext, RegionTest};\n \n /// When the MIR type-checker executes, it validates all the types in\n /// the MIR, and in the process generates a set of constraints that\n@@ -27,10 +30,7 @@ pub(super) fn generate<'tcx>(\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n-    SubtypeConstraintGenerator {\n-        regioncx,\n-        mir,\n-    }.generate(constraints);\n+    SubtypeConstraintGenerator { regioncx, mir }.generate(constraints);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n@@ -65,6 +65,8 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 givens,\n             } = data;\n \n+            let span = self.mir.source_info(locations.from_location).span;\n+\n             for constraint in constraints.keys() {\n                 debug!(\"generate: constraint: {:?}\", constraint);\n                 let (a_vid, b_vid) = match constraint {\n@@ -81,19 +83,71 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 // reverse direction, because `regioncx` talks about\n                 // \"outlives\" (`>=`) whereas the region constraints\n                 // talk about `<=`.\n-                let span = self.mir.source_info(locations.from_location).span;\n                 self.regioncx\n                     .add_outlives(span, b_vid, a_vid, locations.at_location);\n             }\n \n-            assert!(verifys.is_empty(), \"verifys not yet implemented\");\n+            for verify in verifys {\n+                let type_test = self.verify_to_type_test(verify, span, locations);\n+                self.regioncx.add_type_test(type_test);\n+            }\n+\n             assert!(\n                 givens.is_empty(),\n                 \"MIR type-checker does not use givens (thank goodness)\"\n             );\n         }\n     }\n \n+    fn verify_to_type_test(\n+        &self,\n+        verify: &Verify<'tcx>,\n+        span: Span,\n+        locations: &Locations,\n+    ) -> TypeTest<'tcx> {\n+        let generic_kind = verify.kind;\n+\n+        let lower_bound = self.to_region_vid(verify.region);\n+\n+        let point = locations.at_location;\n+\n+        let test = self.verify_bound_to_region_test(&verify.bound);\n+\n+        TypeTest {\n+            generic_kind,\n+            lower_bound,\n+            point,\n+            span,\n+            test,\n+        }\n+    }\n+\n+    fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n+        match verify_bound {\n+            VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n+                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n+            ),\n+\n+            VerifyBound::AllRegions(regions) => RegionTest::IsOutlivedByAllRegionsIn(\n+                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n+            ),\n+\n+            VerifyBound::AnyBound(bounds) => RegionTest::Any(\n+                bounds\n+                    .iter()\n+                    .map(|b| self.verify_bound_to_region_test(b))\n+                    .collect(),\n+            ),\n+\n+            VerifyBound::AllBounds(bounds) => RegionTest::All(\n+                bounds\n+                    .iter()\n+                    .map(|b| self.verify_bound_to_region_test(b))\n+                    .collect(),\n+            ),\n+        }\n+    }\n+\n     fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n         // Every region that we see in the constraints came from the\n         // MIR or from the parameter environment. If the former, it"}, {"sha": "c6547ae68fa1e640fb9be80358e2837e5aebd1f8", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs?ref=6193c5cc2acd1c427a372dfdab3d071e880ecf62", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+\n+use std::fmt::Debug;\n+\n+fn no_region<'a, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: Debug,\n+{\n+    x\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+fn correct_region<'a, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'a + Debug,\n+{\n+    x\n+}\n+\n+fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'b + Debug,\n+{\n+    x\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'b + Debug,\n+    'b: 'a,\n+{\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "5b29ff88621095508a66da26935837ab73cd6062", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6193c5cc2acd1c427a372dfdab3d071e880ecf62/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr?ref=6193c5cc2acd1c427a372dfdab3d071e880ecf62", "patch": "@@ -0,0 +1,26 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-fn.rs:22:5\n+   |\n+22 |     x\n+   |     ^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-fn.rs:38:5\n+   |\n+38 |     x\n+   |     ^\n+\n+error: failed type test: TypeTest { generic_kind: T/#1, lower_bound: '_#2r, point: bb0[3], span: $DIR/ty-param-fn.rs:22:5: 22:6, test: IsOutlivedByAnyRegionIn([]) }\n+  --> $DIR/ty-param-fn.rs:22:5\n+   |\n+22 |     x\n+   |     ^\n+\n+error: failed type test: TypeTest { generic_kind: T/#2, lower_bound: '_#3r, point: bb0[3], span: $DIR/ty-param-fn.rs:38:5: 38:6, test: IsOutlivedByAnyRegionIn(['_#2r]) }\n+  --> $DIR/ty-param-fn.rs:38:5\n+   |\n+38 |     x\n+   |     ^\n+\n+error: aborting due to 2 previous errors\n+"}]}