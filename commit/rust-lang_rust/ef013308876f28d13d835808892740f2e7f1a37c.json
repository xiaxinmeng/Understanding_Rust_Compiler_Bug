{"sha": "ef013308876f28d13d835808892740f2e7f1a37c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMDEzMzA4ODc2ZjI4ZDEzZDgzNTgwODg5Mjc0MGYyZTdmMWEzN2M=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T16:22:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-20T16:22:16Z"}, "message": "Rollup merge of #64588 - matthewjasper:mir-address-of, r=oli-obk\n\nAdd a raw \"address of\" operator\n\n* Parse and feature gate `&raw [const | mut] expr` (feature gate name is `raw_address_of`)\n* Add `mir::Rvalue::AddressOf`\n* Use the new `Rvalue` for:\n    * the new syntax\n    * reference to pointer casts\n    * drop shims for slices and arrays\n* Stop using `mir::Rvalue::Cast` with a reference as the operand\n* Correctly evaluate `mir::Rvalue::{Ref, AddressOf}` in constant propagation\n\ncc @Centril @RalfJung @oli-obk @eddyb\ncc #64490", "tree": {"sha": "304633c7038d4bf194ce18887f224ee3d66ecdf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/304633c7038d4bf194ce18887f224ee3d66ecdf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef013308876f28d13d835808892740f2e7f1a37c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/PU4CRBK7hj4Ov3rIwAAdHIIAJoz1IyzYxDUkTCIbU4703kl\nibpadx/ADvRi2KYBfVxZN6mH3mKASFFBYuRIpy2AGX/BKeXvkeXGiF/P88xm3Vei\nLHv6+JsGczx/8IBjanINwiWTh3zw5J+ancEf8vYs6Mj9G4jTxFNx+dpUQ7JXuYSO\nvKU7bTiTOUR6d+w4+hHL2lB/n+YZhZjZMM9SSm9dn7FILZFszCl9MXeDbJt8G249\ngcs317Aql2YhoqyPXd8PleEO7KcxqLUafqcR08MGJr25heCnASE8OsBTcA1V+4D6\neiBwvSyGmLCp5Eb0U2u2eI/9dPZOuLqsqupPsBWAyuS6EomV8AimCv7U6/ufqHg=\n=RXuY\n-----END PGP SIGNATURE-----\n", "payload": "tree 304633c7038d4bf194ce18887f224ee3d66ecdf3\nparent 6b561b4917e803c4be4ca44d8e552b680cb9e380\nparent a74911662e8de2c024ea188e4dcac6a494c74455\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576858936 +0100\ncommitter GitHub <noreply@github.com> 1576858936 +0100\n\nRollup merge of #64588 - matthewjasper:mir-address-of, r=oli-obk\n\nAdd a raw \"address of\" operator\n\n* Parse and feature gate `&raw [const | mut] expr` (feature gate name is `raw_address_of`)\n* Add `mir::Rvalue::AddressOf`\n* Use the new `Rvalue` for:\n    * the new syntax\n    * reference to pointer casts\n    * drop shims for slices and arrays\n* Stop using `mir::Rvalue::Cast` with a reference as the operand\n* Correctly evaluate `mir::Rvalue::{Ref, AddressOf}` in constant propagation\n\ncc @Centril @RalfJung @oli-obk @eddyb\ncc #64490\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef013308876f28d13d835808892740f2e7f1a37c", "html_url": "https://github.com/rust-lang/rust/commit/ef013308876f28d13d835808892740f2e7f1a37c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef013308876f28d13d835808892740f2e7f1a37c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b561b4917e803c4be4ca44d8e552b680cb9e380", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b561b4917e803c4be4ca44d8e552b680cb9e380", "html_url": "https://github.com/rust-lang/rust/commit/6b561b4917e803c4be4ca44d8e552b680cb9e380"}, {"sha": "a74911662e8de2c024ea188e4dcac6a494c74455", "url": "https://api.github.com/repos/rust-lang/rust/commits/a74911662e8de2c024ea188e4dcac6a494c74455", "html_url": "https://github.com/rust-lang/rust/commit/a74911662e8de2c024ea188e4dcac6a494c74455"}], "stats": {"total": 1675, "additions": 1159, "deletions": 516}, "files": [{"sha": "3b4adbaf78c7460d99200919dcfac3caafbfbed6", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -2060,6 +2060,11 @@ pub enum Rvalue<'tcx> {\n     /// &x or &mut x\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n \n+    /// Create a raw pointer to the given place\n+    /// Can be generated by raw address of expressions (`&raw const x`),\n+    /// or when casting a reference to a raw pointer.\n+    AddressOf(Mutability, Place<'tcx>),\n+\n     /// length of a [X] or [X;n] value\n     Len(Place<'tcx>),\n \n@@ -2214,6 +2219,15 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 write!(fmt, \"&{}{}{:?}\", region, kind_str, place)\n             }\n \n+            AddressOf(mutability, ref place) => {\n+                let kind_str = match mutability {\n+                    Mutability::Mut => \"mut\",\n+                    Mutability::Not => \"const\",\n+                };\n+\n+                write!(fmt, \"&raw {} {:?}\", kind_str, place)\n+            }\n+\n             Aggregate(ref kind, ref places) => {\n                 fn fmt_tuple(fmt: &mut Formatter<'_>, places: &[Operand<'_>]) -> fmt::Result {\n                     let mut tuple_fmt = fmt.debug_tuple(\"\");\n@@ -3085,6 +3099,9 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n             Ref(region, bk, ref place) => {\n                 Ref(region.fold_with(folder), bk, place.fold_with(folder))\n             }\n+            AddressOf(mutability, ref place) => {\n+                AddressOf(mutability, place.fold_with(folder))\n+            }\n             Len(ref place) => Len(place.fold_with(folder)),\n             Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n             BinaryOp(op, ref rhs, ref lhs) => {\n@@ -3125,6 +3142,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n             Use(ref op) => op.visit_with(visitor),\n             Repeat(ref op, _) => op.visit_with(visitor),\n             Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n+            AddressOf(_, ref place) => place.visit_with(visitor),\n             Len(ref place) => place.visit_with(visitor),\n             Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n             BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {"}, {"sha": "a24b1d863d6440b38649e699b100774a4c45a061", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -172,6 +172,13 @@ impl<'tcx> Rvalue<'tcx> {\n                     }\n                 )\n             }\n+            Rvalue::AddressOf(mutability, ref place) => {\n+                let place_ty = place.ty(local_decls, tcx).ty;\n+                tcx.mk_ptr(ty::TypeAndMut {\n+                    ty: place_ty,\n+                    mutbl: mutability.into(),\n+                })\n+            }\n             Rvalue::Len(..) => tcx.types.usize,\n             Rvalue::Cast(.., ty) => ty,\n             Rvalue::BinaryOp(op, ref lhs, ref rhs) => {"}, {"sha": "fa96b51347d350f0197e0ca6a006c2fd6de0d043", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -570,6 +570,18 @@ macro_rules! make_mir_visitor {\n                         self.visit_place(path, ctx, location);\n                     }\n \n+                    Rvalue::AddressOf(m, path) => {\n+                        let ctx = match m {\n+                            Mutability::Mut => PlaceContext::MutatingUse(\n+                                MutatingUseContext::AddressOf\n+                            ),\n+                            Mutability::Not => PlaceContext::NonMutatingUse(\n+                                NonMutatingUseContext::AddressOf\n+                            ),\n+                        };\n+                        self.visit_place(path, ctx, location);\n+                    }\n+\n                     Rvalue::Len(path) => {\n                         self.visit_place(\n                             path,\n@@ -1031,6 +1043,8 @@ pub enum NonMutatingUseContext {\n     ShallowBorrow,\n     /// Unique borrow.\n     UniqueBorrow,\n+    /// AddressOf for *const pointer.\n+    AddressOf,\n     /// Used as base for another place, e.g., `x` in `x.y`. Will not mutate the place.\n     /// For example, the projection `x.y` is not marked as a mutation in these cases:\n     ///\n@@ -1054,6 +1068,8 @@ pub enum MutatingUseContext {\n     Drop,\n     /// Mutable borrow.\n     Borrow,\n+    /// AddressOf for *mut pointer.\n+    AddressOf,\n     /// Used as base for another place, e.g., `x` in `x.y`. Could potentially mutate the place.\n     /// For example, the projection `x.y` is marked as a mutation in these cases:\n     ///"}, {"sha": "fca53db1475a0abc6dc41c0ba720af2feaf5f62b", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -28,8 +28,6 @@ pub enum CastTy<'tcx> {\n     FnPtr,\n     /// Raw pointers\n     Ptr(ty::TypeAndMut<'tcx>),\n-    /// References\n-    RPtr(ty::TypeAndMut<'tcx>),\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n@@ -63,7 +61,6 @@ impl<'tcx> CastTy<'tcx> {\n             ty::Adt(d,_) if d.is_enum() && d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n             ty::RawPtr(mt) => Some(CastTy::Ptr(mt)),\n-            ty::Ref(_, ty, mutbl) => Some(CastTy::RPtr(ty::TypeAndMut { ty, mutbl })),\n             ty::FnPtr(..) => Some(CastTy::FnPtr),\n             _ => None,\n         }"}, {"sha": "7bcd98167864071bf44a2a6c0e0f4704bc7a40be", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -340,10 +340,12 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             PlaceContext::MutatingUse(MutatingUseContext::Store) |\n             PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) |\n             PlaceContext::MutatingUse(MutatingUseContext::Borrow) |\n+            PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n             PlaceContext::MutatingUse(MutatingUseContext::Projection) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) => {\n                 self.not_ssa(local);\n             }"}, {"sha": "5b21dfbdf1c695240a97a22603b279bc4ca2c9a2", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -448,7 +448,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n-        let result = match &place_ref {\n+        let result = match place_ref {\n             mir::PlaceRef {\n                 base: mir::PlaceBase::Local(index),\n                 projection: [],"}, {"sha": "09405cc02b3d46ef04772094d8a12e213b039667", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -7,7 +7,7 @@ use crate::MemFlags;\n use crate::common::{self, RealPredicate, IntPredicate};\n use crate::traits::*;\n \n-use rustc::ty::{self, Ty, adjustment::{PointerCast}, Instance};\n+use rustc::ty::{self, Ty, TyCtxt, adjustment::{PointerCast}, Instance};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc::mir;\n@@ -349,8 +349,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 }\n                             }\n                             (CastTy::Ptr(_), CastTy::Ptr(_)) |\n-                            (CastTy::FnPtr, CastTy::Ptr(_)) |\n-                            (CastTy::RPtr(_), CastTy::Ptr(_)) =>\n+                            (CastTy::FnPtr, CastTy::Ptr(_)) =>\n                                 bx.pointercast(llval, ll_t_out),\n                             (CastTy::Ptr(_), CastTy::Int(_)) |\n                             (CastTy::FnPtr, CastTy::Int(_)) =>\n@@ -375,24 +374,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Ref(_, bk, ref place) => {\n-                let cg_place = self.codegen_place(&mut bx, &place.as_ref());\n-\n-                let ty = cg_place.layout.ty;\n+                let mk_ref = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| tcx.mk_ref(\n+                    tcx.lifetimes.re_erased,\n+                    ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n+                );\n+                self.codegen_place_to_pointer(bx, place, mk_ref)\n+            }\n \n-                // Note: places are indirect, so storing the `llval` into the\n-                // destination effectively creates a reference.\n-                let val = if !bx.cx().type_has_metadata(ty) {\n-                    OperandValue::Immediate(cg_place.llval)\n-                } else {\n-                    OperandValue::Pair(cg_place.llval, cg_place.llextra.unwrap())\n-                };\n-                (bx, OperandRef {\n-                    val,\n-                    layout: self.cx.layout_of(self.cx.tcx().mk_ref(\n-                        self.cx.tcx().lifetimes.re_erased,\n-                        ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n-                    )),\n-                })\n+            mir::Rvalue::AddressOf(mutability, ref place) => {\n+                let mk_ptr = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| tcx.mk_ptr(\n+                    ty::TypeAndMut { ty, mutbl: mutability.into() }\n+                );\n+                self.codegen_place_to_pointer(bx, place, mk_ptr)\n             }\n \n             mir::Rvalue::Len(ref place) => {\n@@ -548,6 +541,30 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         cg_value.len(bx.cx())\n     }\n \n+    /// Codegen an `Rvalue::AddressOf` or `Rvalue::Ref`\n+    fn codegen_place_to_pointer(\n+        &mut self,\n+        mut bx: Bx,\n+        place: &mir::Place<'tcx>,\n+        mk_ptr_ty: impl FnOnce(TyCtxt<'tcx>, Ty<'tcx>) -> Ty<'tcx>,\n+    ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n+        let cg_place = self.codegen_place(&mut bx, &place.as_ref());\n+\n+        let ty = cg_place.layout.ty;\n+\n+        // Note: places are indirect, so storing the `llval` into the\n+        // destination effectively creates a reference.\n+        let val = if !bx.cx().type_has_metadata(ty) {\n+            OperandValue::Immediate(cg_place.llval)\n+        } else {\n+            OperandValue::Pair(cg_place.llval, cg_place.llextra.unwrap())\n+        };\n+        (bx, OperandRef {\n+            val,\n+            layout: self.cx.layout_of(mk_ptr_ty(self.cx.tcx(), ty)),\n+        })\n+    }\n+\n     pub fn codegen_scalar_binop(\n         &mut self,\n         bx: &mut Bx,\n@@ -704,6 +721,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn rvalue_creates_operand(&self, rvalue: &mir::Rvalue<'tcx>, span: Span) -> bool {\n         match *rvalue {\n             mir::Rvalue::Ref(..) |\n+            mir::Rvalue::AddressOf(..) |\n             mir::Rvalue::Len(..) |\n             mir::Rvalue::Cast(..) | // (*)\n             mir::Rvalue::BinaryOp(..) |"}, {"sha": "6595691ce786ca3110da5bcc7bd2a3f890c58803", "filename": "src/librustc_error_codes/error_codes/E0745.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -11,7 +11,7 @@ fn temp_address() {\n \n To avoid the error, first bind the temporary to a named local variable.\n \n-```ignore (not yet implemented)\n+```\n # #![feature(raw_ref_op)]\n fn temp_address() {\n     let val = 2;"}, {"sha": "d5b9aaf9511a19197a859eb609328dee4f56eaee", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -3,7 +3,7 @@ use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, Location, Body, Place, ReadOnlyBodyAndCache, Rvalue};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::TerminatorKind;\n-use rustc::mir::{Operand, BorrowKind};\n+use rustc::mir::{Operand, BorrowKind, Mutability};\n use rustc_data_structures::graph::dominators::Dominators;\n \n use crate::dataflow::indexes::BorrowIndex;\n@@ -337,6 +337,22 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 );\n             }\n \n+            Rvalue::AddressOf(mutability, ref place) => {\n+                let access_kind = match mutability {\n+                    Mutability::Mut => (Deep, Write(WriteKind::MutableBorrow(BorrowKind::Mut {\n+                        allow_two_phase_borrow: false,\n+                    }))),\n+                    Mutability::Not => (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n+                };\n+\n+                self.access_place(\n+                    location,\n+                    place,\n+                    access_kind,\n+                    LocalMutationIsAllowed::No,\n+                );\n+            }\n+\n             Rvalue::Use(ref operand)\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)"}, {"sha": "2554d5e729da983ce477163b82cd2f2e80ab8469", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -1233,6 +1233,31 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n+\n+            Rvalue::AddressOf(mutability, ref place) => {\n+                let access_kind = match mutability {\n+                    Mutability::Mut => (Deep, Write(WriteKind::MutableBorrow(BorrowKind::Mut {\n+                        allow_two_phase_borrow: false,\n+                    }))),\n+                    Mutability::Not => (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n+                };\n+\n+                self.access_place(\n+                    location,\n+                    (place, span),\n+                    access_kind,\n+                    LocalMutationIsAllowed::No,\n+                    flow_state,\n+                );\n+\n+                self.check_if_path_or_subpath_is_moved(\n+                    location,\n+                    InitializationRequiringAction::Borrow,\n+                    (place.as_ref(), span),\n+                    flow_state,\n+                );\n+            }\n+\n             Rvalue::Use(ref operand)\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)"}, {"sha": "108279eeef49245afe35073d8002b8978144e893", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -2273,41 +2273,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n-                            (Some(CastTy::RPtr(ref_tm)), Some(CastTy::Ptr(ptr_tm))) => {\n-                                if let hir::Mutability::Mutable = ptr_tm.mutbl {\n-                                    if let Err(terr) = self.eq_types(\n-                                        ref_tm.ty,\n-                                        ptr_tm.ty,\n-                                        location.to_locations(),\n-                                        ConstraintCategory::Cast,\n-                                    ) {\n-                                        span_mirbug!(\n-                                            self,\n-                                            rvalue,\n-                                            \"equating {:?} with {:?} yields {:?}\",\n-                                            ref_tm.ty,\n-                                            ptr_tm.ty,\n-                                            terr\n-                                        )\n-                                    }\n-                                } else {\n-                                    if let Err(terr) = self.sub_types(\n-                                        ref_tm.ty,\n-                                        ptr_tm.ty,\n-                                        location.to_locations(),\n-                                        ConstraintCategory::Cast,\n-                                    ) {\n-                                        span_mirbug!(\n-                                            self,\n-                                            rvalue,\n-                                            \"relating {:?} with {:?} yields {:?}\",\n-                                            ref_tm.ty,\n-                                            ptr_tm.ty,\n-                                            terr\n-                                        )\n-                                    }\n-                                }\n-                            },\n                             (None, _)\n                             | (_, None)\n                             | (_, Some(CastTy::FnPtr))\n@@ -2320,7 +2285,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ty_from,\n                                 ty,\n                             ),\n-                            _ => (),\n+                            (Some(CastTy::Int(_)), Some(CastTy::Int(_)))\n+                            | (Some(CastTy::Float), Some(CastTy::Int(_)))\n+                            | (Some(CastTy::Int(_)), Some(CastTy::Float))\n+                            | (Some(CastTy::Float), Some(CastTy::Float))\n+                            | (Some(CastTy::Ptr(_)), Some(CastTy::Int(_)))\n+                            | (Some(CastTy::FnPtr), Some(CastTy::Int(_)))\n+                            | (Some(CastTy::Int(_)), Some(CastTy::Ptr(_)))\n+                            | (Some(CastTy::Ptr(_)), Some(CastTy::Ptr(_)))\n+                            | (Some(CastTy::FnPtr), Some(CastTy::Ptr(_))) => (),\n                         }\n                     }\n                 }\n@@ -2371,7 +2344,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n \n-            Rvalue::Use(..)\n+            Rvalue::AddressOf(..)\n+            | Rvalue::Use(..)\n             | Rvalue::Len(..)\n             | Rvalue::BinaryOp(..)\n             | Rvalue::CheckedBinaryOp(..)\n@@ -2388,6 +2362,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::Use(_)\n             | Rvalue::Repeat(..)\n             | Rvalue::Ref(..)\n+            | Rvalue::AddressOf(..)\n             | Rvalue::Len(..)\n             | Rvalue::Cast(..)\n             | Rvalue::BinaryOp(..)"}, {"sha": "15c7c92d7db51c19365c0d0855b1c16eaecfef25", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -276,6 +276,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Pointer { .. }\n             | ExprKind::Repeat { .. }\n             | ExprKind::Borrow { .. }\n+            | ExprKind::AddressOf { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::Loop { .. }\n             | ExprKind::Block { .. }"}, {"sha": "24282a6617acfd3e3e2f52b4afe32c1e66ff7961", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -276,6 +276,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n             | ExprKind::Borrow { .. }\n+            | ExprKind::AddressOf { .. }\n             | ExprKind::Adt { .. }\n             | ExprKind::Loop { .. }\n             | ExprKind::LogicalOp { .. }"}, {"sha": "4d0039b2e8cecae15eba8afc49a74fff5fb9911e", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -49,6 +49,7 @@ impl Category {\n             | ExprKind::Use { .. }\n             | ExprKind::Adt { .. }\n             | ExprKind::Borrow { .. }\n+            | ExprKind::AddressOf { .. }\n             | ExprKind::Call { .. } => Some(Category::Rvalue(RvalueFunc::Into)),\n \n             ExprKind::Array { .. }"}, {"sha": "6b33e8433f673bee3c470ae9cb5ce616f599e9ce", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -3,6 +3,7 @@\n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::hair::*;\n+use rustc::hir;\n use rustc::mir::*;\n use rustc::ty::{self, CanonicalUserTypeAnnotation};\n use rustc_data_structures::fx::FxHashMap;\n@@ -295,6 +296,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.cfg.push_assign(block, source_info, destination, borrow);\n                 block.unit()\n             }\n+            ExprKind::AddressOf {\n+                mutability,\n+                arg,\n+            } => {\n+                let address_of = match mutability {\n+                    hir::Mutability::Immutable => Rvalue::AddressOf(\n+                        Mutability::Not,\n+                        unpack!(block = this.as_read_only_place(block, arg)),\n+                    ),\n+                    hir::Mutability::Mutable => Rvalue::AddressOf(\n+                        Mutability::Mut,\n+                        unpack!(block = this.as_place(block, arg)),\n+                    ),\n+                };\n+                this.cfg.push_assign(block, source_info, destination, address_of);\n+                block.unit()\n+            }\n             ExprKind::Adt {\n                 adt_def,\n                 variant_index,"}, {"sha": "5522da6fbf0858163c0020a39e7599292a8b7bf2", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -335,6 +335,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 }\n             }\n             Rvalue::Ref(..)\n+            | Rvalue::AddressOf(..)\n             | Rvalue::Discriminant(..)\n             | Rvalue::Len(..)\n             | Rvalue::NullaryOp(NullOp::SizeOf, _)"}, {"sha": "6cbc25aa7356ece89ed836026447bc65241e2244", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 10, "deletions": 74, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -137,8 +137,11 @@ fn apply_adjustment<'a, 'tcx>(\n                 arg: expr.to_ref(),\n             }\n         }\n-        Adjust::Borrow(AutoBorrow::RawPtr(mutbl)) => {\n-            raw_ref_shim(cx, expr.to_ref(), adjustment.target, mutbl, span, temp_lifetime)\n+        Adjust::Borrow(AutoBorrow::RawPtr(mutability)) => {\n+            ExprKind::AddressOf {\n+                mutability,\n+                arg: expr.to_ref(),\n+            }\n         }\n     };\n \n@@ -262,17 +265,11 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             }\n         }\n \n-        hir::ExprKind::AddrOf(hir::BorrowKind::Raw, mutbl, ref arg) => {\n-            cx.tcx.sess\n-                .struct_span_err(\n-                    expr.span,\n-                    \"raw borrows are not yet implemented\"\n-                )\n-                .note(\"for more information, see https://github.com/rust-lang/rust/issues/64490\")\n-                .emit();\n-\n-            // Lower to an approximation to avoid further errors.\n-            raw_ref_shim(cx, arg.to_ref(), expr_ty, mutbl, expr.span, temp_lifetime)\n+        hir::ExprKind::AddrOf(hir::BorrowKind::Raw, mutability, ref arg) => {\n+            ExprKind::AddressOf {\n+                mutability,\n+                arg: arg.to_ref(),\n+            }\n         }\n \n         hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: &blk },\n@@ -1082,67 +1079,6 @@ fn convert_var(\n }\n \n \n-/// Fake `&raw [mut|const] expr` using a borrow and a cast until `AddressOf`\n-/// exists in MIR.\n-fn raw_ref_shim<'tcx>(\n-    cx: &mut Cx<'_, 'tcx>,\n-    arg: ExprRef<'tcx>,\n-    ty: Ty<'tcx>,\n-    mutbl: hir::Mutability,\n-    span: Span,\n-    temp_lifetime: Option<region::Scope>,\n-) -> ExprKind<'tcx> {\n-    let arg_tm = if let ty::RawPtr(type_mutbl) = ty.kind {\n-        type_mutbl\n-    } else {\n-        bug!(\"raw_ref_shim called with non-raw pointer type\");\n-    };\n-    // Convert this to a suitable `&foo` and\n-    // then an unsafe coercion.\n-    let borrow_expr = Expr {\n-        temp_lifetime,\n-        ty: cx.tcx.mk_ref(cx.tcx.lifetimes.re_erased, arg_tm),\n-        span,\n-        kind: ExprKind::Borrow {\n-            borrow_kind: mutbl.to_borrow_kind(),\n-            arg,\n-        },\n-    };\n-    let cast_expr = Expr {\n-        temp_lifetime,\n-        ty,\n-        span,\n-        kind: ExprKind::Cast { source: borrow_expr.to_ref() }\n-    };\n-\n-    // To ensure that both implicit and explicit coercions are\n-    // handled the same way, we insert an extra layer of indirection here.\n-    // For explicit casts (e.g., 'foo as *const T'), the source of the 'Use'\n-    // will be an ExprKind::Hair with the appropriate cast expression. Here,\n-    // we make our Use source the generated Cast from the original coercion.\n-    //\n-    // In both cases, this outer 'Use' ensures that the inner 'Cast' is handled by\n-    // as_operand, not by as_rvalue - causing the cast result to be stored in a temporary.\n-    // Ordinary, this is identical to using the cast directly as an rvalue. However, if the\n-    // source of the cast was previously borrowed as mutable, storing the cast in a\n-    // temporary gives the source a chance to expire before the cast is used. For\n-    // structs with a self-referential *mut ptr, this allows assignment to work as\n-    // expected.\n-    //\n-    // For example, consider the type 'struct Foo { field: *mut Foo }',\n-    // The method 'fn bar(&mut self) { self.field = self }'\n-    // triggers a coercion from '&mut self' to '*mut self'. In order\n-    // for the assignment to be valid, the implicit borrow\n-    // of 'self' involved in the coercion needs to end before the local\n-    // containing the '*mut T' is assigned to 'self.field' - otherwise,\n-    // we end up trying to assign to 'self.field' while we have another mutable borrow\n-    // active.\n-    //\n-    // We only need to worry about this kind of thing for coercions from refs to ptrs,\n-    // since they get rid of a borrow implicitly.\n-    ExprKind::Use { source: cast_expr.to_ref() }\n-}\n-\n fn bin_op(op: hir::BinOpKind) -> BinOp {\n     match op {\n         hir::BinOpKind::Add => BinOp::Add,"}, {"sha": "46e0d2a17b32db539a4dbb8c20d74e182489e8f4", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -212,6 +212,11 @@ pub enum ExprKind<'tcx> {\n         borrow_kind: BorrowKind,\n         arg: ExprRef<'tcx>,\n     },\n+    /// A `&raw [const|mut] $place_expr` raw borrow resulting in type `*[const|mut] T`.\n+    AddressOf {\n+        mutability: hir::Mutability,\n+        arg: ExprRef<'tcx>,\n+    },\n     Break {\n         label: region::Scope,\n         value: Option<ExprRef<'tcx>>,"}, {"sha": "33cdf1b27f8db9a8e5942a3f0bd1013aa707771b", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -248,7 +248,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 )?;\n             }\n \n-            Ref(_, _, ref place) => {\n+            AddressOf(_, ref place) | Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n                 let place = self.force_allocation(src)?;\n                 if place.layout.size.bytes() > 0 {"}, {"sha": "0e4fe3f7f4015cd3803b65d3a73298d87c37fd9a", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -136,21 +136,9 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 let (retag_kind, place) = match block_data.statements[i].kind {\n-                    // If we are casting *from* a reference, we may have to retag-as-raw.\n-                    StatementKind::Assign(box(ref place, Rvalue::Cast(\n-                        CastKind::Misc,\n-                        ref src,\n-                        dest_ty,\n-                    ))) => {\n-                        let src_ty = src.ty(&*local_decls, tcx);\n-                        if src_ty.is_region_ptr() {\n-                            // The only `Misc` casts on references are those creating raw pointers.\n-                            assert!(dest_ty.is_unsafe_ptr());\n-                            (RetagKind::Raw, place.clone())\n-                        } else {\n-                            // Some other cast, no retag\n-                            continue\n-                        }\n+                    // Retag-as-raw after escaping to a raw pointer.\n+                    StatementKind::Assign(box (ref place, Rvalue::AddressOf(..))) => {\n+                        (RetagKind::Raw, place.clone())\n                     }\n                     // Assignments of reference or ptr type are the ones where we may have\n                     // to update tags.  This includes `x = &[mut] ...` and hence"}, {"sha": "e5f3003cd711007d55caafdb2e0388c3f8eb42bf", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -224,6 +224,23 @@ impl NonConstOp for MutBorrow {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct MutAddressOf;\n+impl NonConstOp for MutAddressOf {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_mut_refs)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        feature_err(\n+            &item.tcx.sess.parse_sess,\n+            sym::const_mut_refs,\n+            span,\n+            &format!(\"`&raw mut` is not allowed in {}s\", item.const_kind())\n+        ).emit();\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct MutDeref;\n impl NonConstOp for MutDeref {"}, {"sha": "28243bd71a228f05629111ac99c6787d53b891c8", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -151,17 +151,15 @@ pub trait Qualif {\n                 Self::in_operand(cx, per_local, lhs) || Self::in_operand(cx, per_local, rhs)\n             }\n \n-            Rvalue::Ref(_, _, ref place) => {\n+            Rvalue::Ref(_, _, ref place) | Rvalue::AddressOf(_, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n-                    if ProjectionElem::Deref == elem {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, *cx.body, cx.tcx).ty;\n-                        if let ty::Ref(..) = base_ty.kind {\n-                            return Self::in_place(cx, per_local, PlaceRef {\n-                                base: &place.base,\n-                                projection: proj_base,\n-                            });\n-                        }\n+                if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n+                    let base_ty = Place::ty_from(&place.base, proj_base, *cx.body, cx.tcx).ty;\n+                    if let ty::Ref(..) = base_ty.kind {\n+                        return Self::in_place(cx, per_local, PlaceRef {\n+                            base: &place.base,\n+                            projection: proj_base,\n+                        });\n                     }\n                 }\n "}, {"sha": "0904264586c7c855fa372781356a8df77220feae", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 71, "deletions": 41, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -276,6 +276,27 @@ impl Validator<'a, 'mir, 'tcx> {\n             self.check_op_spanned(ops::StaticAccess, span)\n         }\n     }\n+\n+    fn check_immutable_borrow_like(\n+        &mut self,\n+        location: Location,\n+        place: &Place<'tcx>,\n+    ) {\n+        // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually\n+        // seek the cursors beforehand.\n+        self.qualifs.has_mut_interior.cursor.seek_before(location);\n+        self.qualifs.indirectly_mutable.seek(location);\n+\n+        let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n+            &self.item,\n+            &|local| self.qualifs.has_mut_interior_eager_seek(local),\n+            place.as_ref(),\n+        );\n+\n+        if borrowed_place_has_mut_interior {\n+            self.check_op(ops::CellBorrow);\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n@@ -302,26 +323,44 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         trace!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n \n         // Special-case reborrows to be more like a copy of a reference.\n-        if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n-                let ctx = match kind {\n-                    BorrowKind::Shared => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::SharedBorrow,\n-                    ),\n-                    BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::ShallowBorrow,\n-                    ),\n-                    BorrowKind::Unique => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::UniqueBorrow,\n-                    ),\n-                    BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n-                        MutatingUseContext::Borrow,\n-                    ),\n-                };\n-                self.visit_place_base(&place.base, ctx, location);\n-                self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n-                return;\n+        match *rvalue {\n+            Rvalue::Ref(_, kind, ref place) => {\n+                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n+                    let ctx = match kind {\n+                        BorrowKind::Shared => PlaceContext::NonMutatingUse(\n+                            NonMutatingUseContext::SharedBorrow,\n+                        ),\n+                        BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n+                            NonMutatingUseContext::ShallowBorrow,\n+                        ),\n+                        BorrowKind::Unique => PlaceContext::NonMutatingUse(\n+                            NonMutatingUseContext::UniqueBorrow,\n+                        ),\n+                        BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n+                            MutatingUseContext::Borrow,\n+                        ),\n+                    };\n+                    self.visit_place_base(&place.base, ctx, location);\n+                    self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                    return;\n+                }\n             }\n+            Rvalue::AddressOf(mutbl, ref place) => {\n+                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n+                    let ctx = match mutbl {\n+                        Mutability::Not => PlaceContext::NonMutatingUse(\n+                            NonMutatingUseContext::AddressOf,\n+                        ),\n+                        Mutability::Mut => PlaceContext::MutatingUse(\n+                            MutatingUseContext::AddressOf,\n+                        ),\n+                    };\n+                    self.visit_place_base(&place.base, ctx, location);\n+                    self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                    return;\n+                }\n+            }\n+            _ => {}\n         }\n \n         self.super_rvalue(rvalue, location);\n@@ -367,34 +406,25 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 }\n             }\n \n+            Rvalue::AddressOf(Mutability::Mut, _) => {\n+                self.check_op(ops::MutAddressOf)\n+            }\n+\n             // At the moment, `PlaceBase::Static` is only used for promoted MIR.\n             | Rvalue::Ref(_, BorrowKind::Shared, ref place)\n             | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n+            | Rvalue::AddressOf(Mutability::Not, ref place)\n             if matches!(place.base, PlaceBase::Static(_))\n             => bug!(\"Saw a promoted during const-checking, which must run before promotion\"),\n \n-            | Rvalue::Ref(_, kind @ BorrowKind::Shared, ref place)\n-            | Rvalue::Ref(_, kind @ BorrowKind::Shallow, ref place)\n-            => {\n-                // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually\n-                // seek the cursors beforehand.\n-                self.qualifs.has_mut_interior.cursor.seek_before(location);\n-                self.qualifs.indirectly_mutable.seek(location);\n-\n-                let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n-                    &self.item,\n-                    &|local| self.qualifs.has_mut_interior_eager_seek(local),\n-                    place.as_ref(),\n-                );\n-\n-                if borrowed_place_has_mut_interior {\n-                    if let BorrowKind::Mut{ .. } = kind {\n-                        self.check_op(ops::MutBorrow);\n-                    } else {\n-                        self.check_op(ops::CellBorrow);\n-                    }\n-                }\n-            }\n+            | Rvalue::Ref(_, BorrowKind::Shared, ref place)\n+            | Rvalue::Ref(_, BorrowKind::Shallow, ref place) => {\n+                self.check_immutable_borrow_like(location, place)\n+            },\n+\n+            Rvalue::AddressOf(Mutability::Not, ref place) => {\n+                self.check_immutable_borrow_like(location, place)\n+            },\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(*self.body, self.tcx);"}, {"sha": "4e5d8ae08fe5bd7b07c960b5be1758aff50a8241", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -196,7 +196,12 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n         } else if let TempState::Defined { ref mut uses, .. } = *temp {\n             // We always allow borrows, even mutable ones, as we need\n             // to promote mutable borrows of some ZSTs e.g., `&mut []`.\n-            let allowed_use = context.is_borrow() || context.is_nonmutating_use();\n+            let allowed_use = match context {\n+                PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n+                | PlaceContext::NonMutatingUse(_) => true,\n+                PlaceContext::MutatingUse(_)\n+                | PlaceContext::NonUse(_) => false,\n+            };\n             debug!(\"visit_local: allowed_use={:?}\", allowed_use);\n             if allowed_use {\n                 *uses += 1;\n@@ -618,6 +623,21 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 self.validate_operand(rhs)\n             }\n \n+            Rvalue::AddressOf(_, place) => {\n+                // Raw reborrows can come from reference to pointer coercions,\n+                // so are allowed.\n+                if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n+                    let base_ty = Place::ty_from(&place.base, proj_base, *self.body, self.tcx).ty;\n+                    if let ty::Ref(..) = base_ty.kind {\n+                        return self.validate_place(PlaceRef {\n+                            base: &place.base,\n+                            projection: proj_base,\n+                        });\n+                    }\n+                }\n+                Err(Unpromotable)\n+            }\n+\n             Rvalue::Ref(_, kind, place) => {\n                 if let BorrowKind::Mut { .. } = kind {\n                     let ty = place.ty(*self.body, self.tcx).ty;\n@@ -950,7 +970,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 Candidate::Ref(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n                     match statement.kind {\n-                        StatementKind::Assign(box(_, Rvalue::Ref(_, _, ref mut place))) => {\n+                        StatementKind::Assign(box (_, Rvalue::Ref(_, _, ref mut place))) => {\n                             // Use the underlying local for this (necessarily interior) borrow.\n                             let ty = place.base.ty(local_decls).ty;\n                             let span = statement.source_info.span;"}, {"sha": "a61bff37fc873378698104eed255753a6aae2cfa", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -135,7 +135,10 @@ fn check_rvalue(\n         Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => {\n             check_operand(tcx, operand, span, def_id, body)\n         }\n-        Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) => {\n+        Rvalue::Len(place)\n+        | Rvalue::Discriminant(place)\n+        | Rvalue::Ref(_, _, place)\n+        | Rvalue::AddressOf(_, place) => {\n             check_place(tcx, place, span, def_id, body)\n         }\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n@@ -147,9 +150,6 @@ fn check_rvalue(\n                     span,\n                     \"casting pointers to ints is unstable in const fn\".into(),\n                 )),\n-                (CastTy::RPtr(_), CastTy::Float) => bug!(),\n-                (CastTy::RPtr(_), CastTy::Int(_)) => bug!(),\n-                (CastTy::Ptr(_), CastTy::RPtr(_)) => bug!(),\n                 _ => check_operand(tcx, operand, span, def_id, body),\n             }\n         }"}, {"sha": "4f482431d33231c07e45578e748dff9e73d09dac", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -557,10 +557,10 @@ where\n     ///    if can_go then succ else drop-block\n     /// drop-block:\n     ///    if ptr_based {\n-    ///        ptr = &mut *cur\n+    ///        ptr = cur\n     ///        cur = cur.offset(1)\n     ///    } else {\n-    ///        ptr = &mut P[cur]\n+    ///        ptr = &raw mut P[cur]\n     ///        cur = cur + 1\n     ///    }\n     ///    drop(ptr)\n@@ -574,34 +574,28 @@ where\n         unwind: Unwind,\n         ptr_based: bool,\n     ) -> BasicBlock {\n-        let copy = |place: &Place<'tcx>| Operand::Copy(place.clone());\n-        let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n+        let copy = |place: Place<'tcx>| Operand::Copy(place);\n+        let move_ = |place: Place<'tcx>| Operand::Move(place);\n         let tcx = self.tcx();\n \n-        let ref_ty = tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n+        let ptr_ty = tcx.mk_ptr(ty::TypeAndMut {\n             ty: ety,\n             mutbl: hir::Mutability::Mutable\n         });\n-        let ptr = &Place::from(self.new_temp(ref_ty));\n-        let can_go = &Place::from(self.new_temp(tcx.types.bool));\n+        let ptr = &Place::from(self.new_temp(ptr_ty));\n+        let can_go = Place::from(self.new_temp(tcx.types.bool));\n \n         let one = self.constant_usize(1);\n         let (ptr_next, cur_next) = if ptr_based {\n-            (Rvalue::Ref(\n-                tcx.lifetimes.re_erased,\n-                BorrowKind::Mut { allow_two_phase_borrow: false },\n-                Place {\n-                    base: PlaceBase::Local(cur),\n-                    projection: tcx.intern_place_elems(&vec![ProjectionElem::Deref]),\n-                }\n-             ),\n-             Rvalue::BinaryOp(BinOp::Offset, move_(&Place::from(cur)), one))\n+            (\n+                Rvalue::Use(copy(cur.into())),\n+                Rvalue::BinaryOp(BinOp::Offset, move_(cur.into()), one),\n+            )\n         } else {\n-            (Rvalue::Ref(\n-                 tcx.lifetimes.re_erased,\n-                 BorrowKind::Mut { allow_two_phase_borrow: false },\n-                 tcx.mk_place_index(self.place.clone(), cur)),\n-             Rvalue::BinaryOp(BinOp::Add, move_(&Place::from(cur)), one))\n+            (\n+                Rvalue::AddressOf(Mutability::Mut, tcx.mk_place_index(self.place.clone(), cur)),\n+                Rvalue::BinaryOp(BinOp::Add, move_(cur.into()), one),\n+            )\n         };\n \n         let drop_block = BasicBlockData {\n@@ -620,9 +614,9 @@ where\n \n         let loop_block = BasicBlockData {\n             statements: vec![\n-                self.assign(can_go, Rvalue::BinaryOp(BinOp::Eq,\n-                                                     copy(&Place::from(cur)),\n-                                                     copy(length_or_end)))\n+                self.assign(&can_go, Rvalue::BinaryOp(BinOp::Eq,\n+                                                     copy(Place::from(cur)),\n+                                                     copy(length_or_end.clone())))\n             ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n@@ -725,8 +719,6 @@ where\n \n         let cur = self.new_temp(iter_ty);\n         let length_or_end = if ptr_based {\n-            // FIXME check if we want to make it return a `Place` directly\n-            // if all use sites want a `Place::Base` anyway.\n             Place::from(self.new_temp(iter_ty))\n         } else {\n             length.clone()\n@@ -753,23 +745,16 @@ where\n         let drop_block_stmts = if ptr_based {\n             let tmp_ty = tcx.mk_mut_ptr(self.place_ty(self.place));\n             let tmp = Place::from(self.new_temp(tmp_ty));\n-            // tmp = &mut P;\n+            // tmp = &raw mut P;\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n             vec![\n-                self.assign(&tmp, Rvalue::Ref(\n-                    tcx.lifetimes.re_erased,\n-                    BorrowKind::Mut { allow_two_phase_borrow: false },\n-                    self.place.clone()\n-                )),\n-                self.assign(\n-                    &cur,\n-                    Rvalue::Cast(CastKind::Misc, Operand::Move(tmp), iter_ty),\n-                ),\n+                self.assign(&tmp, Rvalue::AddressOf(Mutability::Mut, self.place.clone())),\n+                self.assign(&cur, Rvalue::Cast(CastKind::Misc, Operand::Move(tmp), iter_ty)),\n                 self.assign(\n                     &length_or_end,\n-                    Rvalue::BinaryOp(BinOp::Offset, Operand::Copy(cur), Operand::Move(length)\n-                )),\n+                    Rvalue::BinaryOp(BinOp::Offset, Operand::Copy(cur), Operand::Move(length)),\n+                ),\n             ]\n         } else {\n             // cur = 0 (length already pushed)"}, {"sha": "01eebeb8c55a55a68ed4045b34d1c057743cbcdb", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -167,6 +167,8 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n \n+        PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |"}, {"sha": "21ba02746c79e6cf786b96e8f75837c93e67821a", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -469,30 +469,56 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             // Function item types may need to be reified before casts.\n             (None, Some(t_cast)) => {\n-                if let ty::FnDef(..) = self.expr_ty.kind {\n-                    // Attempt a coercion to a fn pointer type.\n-                    let f = self.expr_ty.fn_sig(fcx.tcx);\n-                    let res = fcx.try_coerce(self.expr,\n-                                             self.expr_ty,\n-                                             fcx.tcx.mk_fn_ptr(f),\n-                                             AllowTwoPhase::No);\n-                    if let Err(TypeError::IntrinsicCast) = res {\n-                        return Err(CastError::IllegalCast);\n+                match self.expr_ty.kind {\n+                    ty::FnDef(..) => {\n+                        // Attempt a coercion to a fn pointer type.\n+                        let f = self.expr_ty.fn_sig(fcx.tcx);\n+                        let res = fcx.try_coerce(self.expr,\n+                                                 self.expr_ty,\n+                                                 fcx.tcx.mk_fn_ptr(f),\n+                                                 AllowTwoPhase::No);\n+                        if let Err(TypeError::IntrinsicCast) = res {\n+                            return Err(CastError::IllegalCast);\n+                        }\n+                        if res.is_err() {\n+                            return Err(CastError::NonScalar);\n+                        }\n+                        (FnPtr, t_cast)\n                     }\n-                    if res.is_err() {\n-                        return Err(CastError::NonScalar);\n+                    // Special case some errors for references, and check for\n+                    // array-ptr-casts. `Ref` is not a CastTy because the cast\n+                    // is split into a coercion to a pointer type, followed by\n+                    // a cast.\n+                    ty::Ref(_, inner_ty, mutbl) => {\n+                        return match t_cast {\n+                            Int(_) | Float => match inner_ty.kind {\n+                                ty::Int(_) |\n+                                ty::Uint(_) |\n+                                ty::Float(_) |\n+                                ty::Infer(ty::InferTy::IntVar(_)) |\n+                                ty::Infer(ty::InferTy::FloatVar(_)) => {\n+                                    Err(CastError::NeedDeref)\n+                                }\n+                                _ => Err(CastError::NeedViaPtr),\n+                            }\n+                            // array-ptr-cast\n+                            Ptr(mt) => self.check_ref_cast(\n+                                fcx,\n+                                TypeAndMut { mutbl, ty: inner_ty },\n+                                mt,\n+                            ),\n+                            _ => Err(CastError::NonScalar),\n+                        };\n                     }\n-                    (FnPtr, t_cast)\n-                } else {\n-                    return Err(CastError::NonScalar);\n+                    _ => return Err(CastError::NonScalar),\n                 }\n             }\n             _ => return Err(CastError::NonScalar),\n         };\n \n         match (t_from, t_cast) {\n             // These types have invariants! can't cast into them.\n-            (_, RPtr(_)) | (_, Int(CEnum)) | (_, FnPtr) => Err(CastError::NonScalar),\n+            (_, Int(CEnum)) | (_, FnPtr) => Err(CastError::NonScalar),\n \n             // * -> Bool\n             (_, Int(Bool)) => Err(CastError::CastToBool),\n@@ -517,28 +543,10 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (Ptr(m_e), Ptr(m_c)) => self.check_ptr_ptr_cast(fcx, m_e, m_c), // ptr-ptr-cast\n             (Ptr(m_expr), Int(_)) => self.check_ptr_addr_cast(fcx, m_expr), // ptr-addr-cast\n             (FnPtr, Int(_)) => Ok(CastKind::FnPtrAddrCast),\n-            (RPtr(p), Int(_)) |\n-            (RPtr(p), Float) => {\n-                match p.ty.kind {\n-                    ty::Int(_) |\n-                    ty::Uint(_) |\n-                    ty::Float(_) => {\n-                        Err(CastError::NeedDeref)\n-                    }\n-                    ty::Infer(t) => {\n-                        match t {\n-                            ty::InferTy::IntVar(_) |\n-                            ty::InferTy::FloatVar(_) => Err(CastError::NeedDeref),\n-                            _ => Err(CastError::NeedViaPtr),\n-                        }\n-                    }\n-                    _ => Err(CastError::NeedViaPtr),\n-                }\n-            }\n+\n             // * -> ptr\n             (Int(_), Ptr(mt)) => self.check_addr_ptr_cast(fcx, mt), // addr-ptr-cast\n             (FnPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n-            (RPtr(rmt), Ptr(mt)) => self.check_ref_cast(fcx, rmt, mt), // array-ptr-cast\n \n             // prim -> prim\n             (Int(CEnum), Int(_)) => Ok(CastKind::EnumCast),"}, {"sha": "274e19ec3e425ada47e9010a0405f0d0f1be4bbd", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -728,13 +728,13 @@ impl Mutability {\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n #[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub enum BorrowKind {\n-    /// A raw borrow, `&raw const $expr` or `&raw mut $expr`.\n-    /// The resulting type is either `*const T` or `*mut T`\n-    /// where `T = typeof($expr)`.\n-    Ref,\n     /// A normal borrow, `&$expr` or `&mut $expr`.\n     /// The resulting type is either `&'a T` or `&'a mut T`\n     /// where `T = typeof($expr)` and `'a` is some lifetime.\n+    Ref,\n+    /// A raw borrow, `&raw const $expr` or `&raw mut $expr`.\n+    /// The resulting type is either `*const T` or `*mut T`\n+    /// where `T = typeof($expr)`.\n     Raw,\n }\n "}, {"sha": "bbd1ca68a8672d3747838f66fdd65c5568ccb312", "filename": "src/test/mir-opt/address-of.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Faddress-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Faddress-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Faddress-of.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,112 @@\n+fn address_of_reborrow() {\n+    let y = &[0; 10];\n+    let mut z = &mut [0; 10];\n+\n+    y as *const _;\n+    y as *const [i32; 10];\n+    y as *const dyn Send;\n+    y as *const [i32];\n+    y as *const i32;            // This is a cast, not a coercion\n+\n+    let p: *const _ = y;\n+    let p: *const [i32; 10] = y;\n+    let p: *const dyn Send = y;\n+    let p: *const [i32] = y;\n+\n+    z as *const _;\n+    z as *const [i32; 10];\n+    z as *const dyn Send;\n+    z as *const [i32];\n+\n+    let p: *const _ = z;\n+    let p: *const [i32; 10] = z;\n+    let p: *const dyn Send = z;\n+    let p: *const [i32] = z;\n+\n+    z as *mut _;\n+    z as *mut [i32; 10];\n+    z as *mut dyn Send;\n+    z as *mut [i32];\n+\n+    let p: *mut _ = z;\n+    let p: *mut [i32; 10] = z;\n+    let p: *mut dyn Send = z;\n+    let p: *mut [i32] = z;\n+}\n+\n+// The normal borrows here should be preserved\n+fn borrow_and_cast(mut x: i32) {\n+    let p = &x as *const i32;\n+    let q = &mut x as *const i32;\n+    let r = &mut x as *mut i32;\n+}\n+\n+fn main() {}\n+\n+// START rustc.address_of_reborrow.SimplifyCfg-initial.after.mir\n+// bb0: {\n+//  ...\n+//  _5 = &raw const (*_1); // & to *const casts\n+//  ...\n+//  _7 = &raw const (*_1);\n+//  ...\n+//  _11 = &raw const (*_1);\n+//  ...\n+//  _14 = &raw const (*_1);\n+//  ...\n+//  _16 = &raw const (*_1);\n+//  ...\n+//  _17 = &raw const (*_1); // & to *const coercions\n+//  ...\n+//  _18 = &raw const (*_1);\n+//  ...\n+//  _20 = &raw const (*_1);\n+//  ...\n+//  _22 = &raw const (*_1);\n+// ...\n+//  _24 = &raw const (*_2); // &mut to *const casts\n+// ...\n+//  _26 = &raw const (*_2);\n+// ...\n+//  _30 = &raw const (*_2);\n+// ...\n+//  _33 = &raw const (*_2);\n+// ...\n+//  _34 = &raw const (*_2); // &mut to *const coercions\n+// ...\n+//  _35 = &raw const (*_2);\n+// ...\n+//  _37 = &raw const (*_2);\n+// ...\n+//  _39 = &raw const (*_2);\n+// ...\n+//  _41 = &raw mut (*_2); // &mut to *mut casts\n+// ...\n+//  _43 = &raw mut (*_2);\n+// ...\n+//  _47 = &raw mut (*_2);\n+// ...\n+//  _50 = &raw mut (*_2);\n+// ...\n+//  _51 = &raw mut (*_2); // &mut to *mut coercions\n+// ...\n+//  _52 = &raw mut (*_2);\n+// ...\n+//  _54 = &raw mut (*_2);\n+// ...\n+//  _56 = &raw mut (*_2);\n+// ...\n+// }\n+// END rustc.address_of_reborrow.SimplifyCfg-initial.after.mir\n+\n+// START rustc.borrow_and_cast.EraseRegions.after.mir\n+// bb0: {\n+//  ...\n+//  _4 = &_1;\n+//  ...\n+//  _7 = &mut _1;\n+//  ...\n+//  _10 = &mut _1;\n+//  ...\n+// }\n+// END rustc.borrow_and_cast.EraseRegions.after.mir"}, {"sha": "096f98bade25ae255c4fc6c7db4c6a2dc57e6005", "filename": "src/test/mir-opt/array-index-is-temporary.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Farray-index-is-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Farray-index-is-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Farray-index-is-temporary.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -18,24 +18,23 @@ fn main() {\n // START rustc.main.EraseRegions.after.mir\n //     bb0: {\n //         ...\n-//         _5 = &mut _2;\n-//         _4 = &mut (*_5);\n-//         _3 = move _4 as *mut usize (Misc);\n+//         _4 = &mut _2;\n+//         _3 = &raw mut (*_4);\n //         ...\n-//         _7 = _3;\n-//         _6 = const foo(move _7) -> bb1;\n+//         _6 = _3;\n+//         _5 = const foo(move _6) -> bb1;\n //     }\n //\n //     bb1: {\n //         ...\n-//         _8 = _2;\n-//         _9 = Len(_1);\n-//         _10 = Lt(_8, _9);\n-//         assert(move _10, \"index out of bounds: the len is move _9 but the index is _8\") -> bb2;\n+//         _7 = _2;\n+//         _8 = Len(_1);\n+//         _9 = Lt(_7, _8);\n+//         assert(move _9, \"index out of bounds: the len is move _8 but the index is _7\") -> bb2;\n //     }\n //\n //     bb2: {\n-//         _1[_8] = move _6;\n+//         _1[_7] = move _5;\n //         ...\n //         return;\n //     }"}, {"sha": "3c8c0ff449345b3ea0440bca6a4d7e36be7a69a8", "filename": "src/test/mir-opt/const_prop/const_prop_fails_gracefully.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -11,25 +11,21 @@ fn main() {\n // START rustc.main.ConstProp.before.mir\n //  bb0: {\n //      ...\n-//      _3 = _4;\n-//      _2 = move _3 as *const i32 (Misc);\n-//      ...\n+//      _2 = &raw const (*_3);\n //      _1 = move _2 as usize (Misc);\n //      ...\n-//      _6 = _1;\n-//      _5 = const read(move _6) -> bb1;\n+//      _5 = _1;\n+//      _4 = const read(move _5) -> bb1;\n //  }\n // END rustc.main.ConstProp.before.mir\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      _4 = const main::FOO;\n-//      _3 = _4;\n-//      _2 = move _3 as *const i32 (Misc);\n-//      ...\n+//      _3 = const main::FOO;\n+//      _2 = &raw const (*_3);\n //      _1 = move _2 as usize (Misc);\n //      ...\n-//      _6 = _1;\n-//      _5 = const read(move _6) -> bb1;\n+//      _5 = _1;\n+//      _4 = const read(move _5) -> bb1;\n //  }\n // END rustc.main.ConstProp.after.mir"}, {"sha": "ccecaeac96b83daa95d6305b28d58cd8bc408062", "filename": "src/test/mir-opt/retag.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Fretag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Fretag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -82,18 +82,16 @@ fn main() {\n //         _10 = move _8;\n //         Retag(_10);\n //         ...\n-//         _13 = &mut (*_10);\n-//         Retag(_13);\n-//         _12 = move _13 as *mut i32 (Misc);\n+//         _12 = &raw mut (*_10);\n //         Retag([raw] _12);\n //         ...\n-//         _16 = move _17(move _18) -> bb5;\n+//         _15 = move _16(move _17) -> bb5;\n //     }\n //\n //     bb5: {\n-//         Retag(_16);\n+//         Retag(_15);\n //         ...\n-//         _20 = const Test::foo_shr(move _21, move _23) -> [return: bb6, unwind: bb7];\n+//         _19 = const Test::foo_shr(move _20, move _22) -> [return: bb6, unwind: bb7];\n //     }\n //\n //     ..."}, {"sha": "5a37b67229c37a14b4dc4b8c0a261ca818aa6202", "filename": "src/test/mir-opt/slice-drop-shim.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -10,15 +10,15 @@ fn main() {\n // let mut _2: usize;\n // let mut _3: usize;\n // let mut _4: usize;\n-// let mut _5: &mut std::string::String;\n+// let mut _5: *mut std::string::String;\n // let mut _6: bool;\n-// let mut _7: &mut std::string::String;\n+// let mut _7: *mut std::string::String;\n // let mut _8: bool;\n // let mut _9: *mut std::string::String;\n // let mut _10: *mut std::string::String;\n-// let mut _11: &mut std::string::String;\n+// let mut _11: *mut std::string::String;\n // let mut _12: bool;\n-// let mut _13: &mut std::string::String;\n+// let mut _13: *mut std::string::String;\n // let mut _14: bool;\n // let mut _15: *mut [std::string::String];\n // bb0: {\n@@ -31,7 +31,7 @@ fn main() {\n //     resume;\n // }\n // bb3 (cleanup): {\n-//     _5 = &mut (*_1)[_4];\n+//     _5 = &raw mut (*_1)[_4];\n //     _4 = Add(move _4, const 1usize);\n //     drop((*_5)) -> bb4;\n // }\n@@ -40,7 +40,7 @@ fn main() {\n //     switchInt(move _6) -> [false: bb3, otherwise: bb2];\n // }\n // bb5: {\n-//     _7 = &mut (*_1)[_4];\n+//     _7 = &raw mut (*_1)[_4];\n //     _4 = Add(move _4, const 1usize);\n //     drop((*_7)) -> [return: bb6, unwind: bb4];\n // }\n@@ -56,7 +56,7 @@ fn main() {\n //     goto -> bb7;\n // }\n // bb9 (cleanup): {\n-//     _11 = &mut (*_9);\n+//     _11 = _9;\n //     _9 = Offset(move _9, const 1usize);\n //     drop((*_11)) -> bb10;\n // }\n@@ -65,7 +65,7 @@ fn main() {\n //     switchInt(move _12) -> [false: bb9, otherwise: bb2];\n // }\n // bb11: {\n-//     _13 = &mut (*_9);\n+//     _13 = _9;\n //     _9 = Offset(move _9, const 1usize);\n //     drop((*_13)) -> [return: bb12, unwind: bb10];\n // }\n@@ -74,7 +74,7 @@ fn main() {\n //     switchInt(move _14) -> [false: bb11, otherwise: bb1];\n // }\n // bb13: {\n-//     _15 = &mut (*_1);\n+//     _15 = &raw mut (*_1);\n //     _9 = move _15 as *mut std::string::String (Misc);\n //     _10 = Offset(_9, move _3);\n //     goto -> bb12;"}, {"sha": "6ccc434a1e79ca1ce0741d9509aec476fe7b1f8c", "filename": "src/test/pretty/raw-address-of.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fpretty%2Fraw-address-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fpretty%2Fraw-address-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fraw-address-of.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,12 @@\n+// pp-exact\n+#![feature(raw_ref_op)]\n+\n+const C_PTR: () = { let a = 1; &raw const a; };\n+static S_PTR: () = { let b = false; &raw const b; };\n+\n+fn main() {\n+    let x = 123;\n+    let mut y = 345;\n+    let c_p = &raw const x;\n+    let parens = unsafe { *(&raw mut (y)) };\n+}"}, {"sha": "f25fd7f66b3ccdaabfd6a91889578dd7a9d21948", "filename": "src/test/ui/borrowck/borrow-raw-address-of-borrowed.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-borrowed.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,22 @@\n+#![feature(raw_ref_op)]\n+\n+fn address_of_shared() {\n+    let mut x = 0;\n+    let y = &x;\n+\n+    let q = &raw mut x;                 //~ ERROR cannot borrow\n+\n+    drop(y);\n+}\n+\n+fn address_of_mutably_borrowed() {\n+    let mut x = 0;\n+    let y = &mut x;\n+\n+    let p = &raw const x;               //~ ERROR cannot borrow\n+    let q = &raw mut x;                 //~ ERROR cannot borrow\n+\n+    drop(y);\n+}\n+\n+fn main() {}"}, {"sha": "ff461b748be88863007d440cb9700f427ca3f852", "filename": "src/test/ui/borrowck/borrow-raw-address-of-borrowed.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-borrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-borrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-borrowed.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,40 @@\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrow-raw-address-of-borrowed.rs:7:13\n+   |\n+LL |     let y = &x;\n+   |             -- immutable borrow occurs here\n+LL | \n+LL |     let q = &raw mut x;\n+   |             ^^^^^^^^^^ mutable borrow occurs here\n+LL | \n+LL |     drop(y);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrow-raw-address-of-borrowed.rs:16:13\n+   |\n+LL |     let y = &mut x;\n+   |             ------ mutable borrow occurs here\n+LL | \n+LL |     let p = &raw const x;\n+   |             ^^^^^^^^^^^^ immutable borrow occurs here\n+...\n+LL |     drop(y);\n+   |          - mutable borrow later used here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/borrow-raw-address-of-borrowed.rs:17:13\n+   |\n+LL |     let y = &mut x;\n+   |             ------ first mutable borrow occurs here\n+...\n+LL |     let q = &raw mut x;\n+   |             ^^^^^^^^^^ second mutable borrow occurs here\n+LL | \n+LL |     drop(y);\n+   |          - first borrow later used here\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0499, E0502.\n+For more information about an error, try `rustc --explain E0499`."}, {"sha": "e381384fe65ecc69102e2c52393e8fa7df74ef96", "filename": "src/test/ui/borrowck/borrow-raw-address-of-deref-mutability-ok.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability-ok.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+#![feature(raw_ref_op)]\n+\n+fn raw_reborrow() {\n+    let x = &0;\n+    let y = &mut 0;\n+\n+    let p = &raw const *x;\n+    let r = &raw const *y;\n+    let s = &raw mut *y;\n+}\n+\n+unsafe fn raw_reborrow_of_raw() {\n+    let x = &0 as *const i32;\n+    let y = &mut 0 as *mut i32;\n+\n+    let p = &raw const *x;\n+    let r = &raw const *y;\n+    let s = &raw mut *y;\n+}\n+\n+fn main() {}"}, {"sha": "712873528b5f1cc04edb4948dc6c60f1a6a82d4c", "filename": "src/test/ui/borrowck/borrow-raw-address-of-deref-mutability.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,17 @@\n+// Check that `&raw mut` cannot be used to turn a `&T` into a `*mut T`.\n+\n+#![feature(raw_ref_op)]\n+\n+fn raw_reborrow() {\n+    let x = &0;\n+\n+    let q = &raw mut *x;                //~ ERROR cannot borrow\n+}\n+\n+unsafe fn raw_reborrow_of_raw() {\n+    let x = &0 as *const i32;\n+\n+    let q = &raw mut *x;                //~ ERROR cannot borrow\n+}\n+\n+fn main() {}"}, {"sha": "31af38507c7d766d1ebcb4a562bc1181f5861691", "filename": "src/test/ui/borrowck/borrow-raw-address-of-deref-mutability.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,21 @@\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n+  --> $DIR/borrow-raw-address-of-deref-mutability.rs:8:13\n+   |\n+LL |     let x = &0;\n+   |             -- help: consider changing this to be a mutable reference: `&mut 0`\n+LL | \n+LL |     let q = &raw mut *x;\n+   |             ^^^^^^^^^^^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n+\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `*const` pointer\n+  --> $DIR/borrow-raw-address-of-deref-mutability.rs:14:13\n+   |\n+LL |     let x = &0 as *const i32;\n+   |             -- help: consider changing this to be a mutable pointer: `&mut 0`\n+LL | \n+LL |     let q = &raw mut *x;\n+   |             ^^^^^^^^^^^ `x` is a `*const` pointer, so the data it refers to cannot be borrowed as mutable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "e1cf2dc53869ba7c0039e2119998bf64ef43d863", "filename": "src/test/ui/borrowck/borrow-raw-address-of-mutability-ok.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability-ok.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,44 @@\n+// check-pass\n+\n+#![feature(raw_ref_op)]\n+\n+fn mutable_address_of() {\n+    let mut x = 0;\n+    let y = &raw mut x;\n+}\n+\n+fn mutable_address_of_closure() {\n+    let mut x = 0;\n+    let mut f = || {\n+        let y = &raw mut x;\n+    };\n+    f();\n+}\n+\n+fn const_address_of_closure() {\n+    let x = 0;\n+    let f = || {\n+        let y = &raw const x;\n+    };\n+    f();\n+}\n+\n+fn make_fn<F: Fn()>(f: F) -> F { f }\n+\n+fn const_address_of_fn_closure() {\n+    let x = 0;\n+    let f = make_fn(|| {\n+        let y = &raw const x;\n+    });\n+    f();\n+}\n+\n+fn const_address_of_fn_closure_move() {\n+    let x = 0;\n+    let f = make_fn(move || {\n+        let y = &raw const x;\n+    });\n+    f();\n+}\n+\n+fn main() {}"}, {"sha": "320c54b806a724da71395206444510e9898b0184", "filename": "src/test/ui/borrowck/borrow-raw-address-of-mutability.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,42 @@\n+#![feature(raw_ref_op)]\n+\n+fn mutable_address_of() {\n+    let x = 0;\n+    let y = &raw mut x;                 //~ ERROR cannot borrow\n+}\n+\n+fn mutable_address_of_closure() {\n+    let x = 0;\n+    let mut f = || {\n+        let y = &raw mut x;             //~ ERROR cannot borrow\n+    };\n+    f();\n+}\n+\n+fn mutable_address_of_imm_closure() {\n+    let mut x = 0;\n+    let f = || {\n+        let y = &raw mut x;\n+    };\n+    f();                                //~ ERROR cannot borrow\n+}\n+\n+fn make_fn<F: Fn()>(f: F) -> F { f }\n+\n+fn mutable_address_of_fn_closure() {\n+    let mut x = 0;\n+    let f = make_fn(|| {\n+        let y = &raw mut x;             //~ ERROR cannot borrow\n+    });\n+    f();\n+}\n+\n+fn mutable_address_of_fn_closure_move() {\n+    let mut x = 0;\n+    let f = make_fn(move || {\n+        let y = &raw mut x;             //~ ERROR cannot borrow\n+    });\n+    f();\n+}\n+\n+fn main() {}"}, {"sha": "cf01c362d50bc171bbf682ce2d6688620541bdce", "filename": "src/test/ui/borrowck/borrow-raw-address-of-mutability.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,59 @@\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n+  --> $DIR/borrow-raw-address-of-mutability.rs:5:13\n+   |\n+LL |     let x = 0;\n+   |         - help: consider changing this to be mutable: `mut x`\n+LL |     let y = &raw mut x;\n+   |             ^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n+  --> $DIR/borrow-raw-address-of-mutability.rs:11:17\n+   |\n+LL |     let x = 0;\n+   |         - help: consider changing this to be mutable: `mut x`\n+LL |     let mut f = || {\n+LL |         let y = &raw mut x;\n+   |                 ^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `f` as mutable, as it is not declared as mutable\n+  --> $DIR/borrow-raw-address-of-mutability.rs:21:5\n+   |\n+LL |     let f = || {\n+   |         - help: consider changing this to be mutable: `mut f`\n+...\n+LL |     f();\n+   |     ^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/borrow-raw-address-of-mutability.rs:29:17\n+   |\n+LL |         let y = &raw mut x;\n+   |                 ^^^^^^^^^^ cannot borrow as mutable\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/borrow-raw-address-of-mutability.rs:28:21\n+   |\n+LL |       let f = make_fn(|| {\n+   |  _____________________^\n+LL | |         let y = &raw mut x;\n+LL | |     });\n+   | |_____^\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/borrow-raw-address-of-mutability.rs:37:17\n+   |\n+LL |         let y = &raw mut x;\n+   |                 ^^^^^^^^^^ cannot borrow as mutable\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/borrow-raw-address-of-mutability.rs:36:21\n+   |\n+LL |       let f = make_fn(move || {\n+   |  _____________________^\n+LL | |         let y = &raw mut x;\n+LL | |     });\n+   | |_____^\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "1aed218aeb473c2bef1345b6e08c827f3502fcef", "filename": "src/test/ui/cast/cast-as-bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fcast%2Fcast-as-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fcast%2Fcast-as-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-as-bool.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let t = (1 + 2) as bool; //~ ERROR cannot cast as `bool`\n                              //~| HELP compare with zero instead\n                              //~| SUGGESTION (1 + 2) != 0\n-    let v = \"hello\" as bool; //~ ERROR cannot cast as `bool`\n+    let v = \"hello\" as bool; //~ ERROR casting `&'static str` as `bool` is invalid\n }"}, {"sha": "15d94ab69d88c707016c314e0286620ff5855a94", "filename": "src/test/ui/cast/cast-as-bool.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fcast%2Fcast-as-bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fcast%2Fcast-as-bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-as-bool.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -10,12 +10,13 @@ error[E0054]: cannot cast as `bool`\n LL |     let t = (1 + 2) as bool;\n    |             ^^^^^^^^^^^^^^^ help: compare with zero instead: `(1 + 2) != 0`\n \n-error[E0054]: cannot cast as `bool`\n+error[E0606]: casting `&'static str` as `bool` is invalid\n   --> $DIR/cast-as-bool.rs:8:13\n    |\n LL |     let v = \"hello\" as bool;\n-   |             ^^^^^^^^^^^^^^^ unsupported cast\n+   |             ^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0054`.\n+Some errors have detailed explanations: E0054, E0606.\n+For more information about an error, try `rustc --explain E0054`."}, {"sha": "60c7c31daca78aa368f85585effcdf7cf53415ad", "filename": "src/test/ui/consts/const-address-of-interior-mut.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-interior-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-interior-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-interior-mut.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,16 @@\n+#![feature(raw_ref_op)]\n+\n+use std::cell::Cell;\n+\n+const A: () = { let x = Cell::new(2); &raw const x; };      //~ ERROR interior mutability\n+\n+static B: () = { let x = Cell::new(2); &raw const x; };     //~ ERROR interior mutability\n+\n+static mut C: () = { let x = Cell::new(2); &raw const x; }; //~ ERROR interior mutability\n+\n+const fn foo() {\n+    let x = Cell::new(0);\n+    let y = &raw const x;                                   //~ ERROR interior mutability\n+}\n+\n+fn main() {}"}, {"sha": "f15174c33b3a019b60a10a87b7977e4a6ea57572", "filename": "src/test/ui/consts/const-address-of-interior-mut.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-interior-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-interior-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-interior-mut.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,27 @@\n+error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+  --> $DIR/const-address-of-interior-mut.rs:5:39\n+   |\n+LL | const A: () = { let x = Cell::new(2); &raw const x; };\n+   |                                       ^^^^^^^^^^^^\n+\n+error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+  --> $DIR/const-address-of-interior-mut.rs:7:40\n+   |\n+LL | static B: () = { let x = Cell::new(2); &raw const x; };\n+   |                                        ^^^^^^^^^^^^\n+\n+error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+  --> $DIR/const-address-of-interior-mut.rs:9:44\n+   |\n+LL | static mut C: () = { let x = Cell::new(2); &raw const x; };\n+   |                                            ^^^^^^^^^^^^\n+\n+error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+  --> $DIR/const-address-of-interior-mut.rs:13:13\n+   |\n+LL |     let y = &raw const x;\n+   |             ^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0492`."}, {"sha": "fe9188cb4904c99eed1022964c1a10a62467024d", "filename": "src/test/ui/consts/const-address-of-mut.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-mut.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,14 @@\n+#![feature(raw_ref_op)]\n+\n+const A: () = { let mut x = 2; &raw mut x; };           //~ ERROR `&raw mut` is not allowed\n+\n+static B: () = { let mut x = 2; &raw mut x; };          //~ ERROR `&raw mut` is not allowed\n+\n+static mut C: () = { let mut x = 2; &raw mut x; };      //~ ERROR `&raw mut` is not allowed\n+\n+const fn foo() {\n+    let mut x = 0;\n+    let y = &raw mut x;                                 //~ ERROR `&raw mut` is not allowed\n+}\n+\n+fn main() {}"}, {"sha": "15f2296c42c25cbbe6bf78bcd8a0f808f80865c2", "filename": "src/test/ui/consts/const-address-of-mut.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-mut.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,39 @@\n+error[E0658]: `&raw mut` is not allowed in constants\n+  --> $DIR/const-address-of-mut.rs:3:32\n+   |\n+LL | const A: () = { let mut x = 2; &raw mut x; };\n+   |                                ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error[E0658]: `&raw mut` is not allowed in statics\n+  --> $DIR/const-address-of-mut.rs:5:33\n+   |\n+LL | static B: () = { let mut x = 2; &raw mut x; };\n+   |                                 ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error[E0658]: `&raw mut` is not allowed in statics\n+  --> $DIR/const-address-of-mut.rs:7:37\n+   |\n+LL | static mut C: () = { let mut x = 2; &raw mut x; };\n+   |                                     ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error[E0658]: `&raw mut` is not allowed in constant functions\n+  --> $DIR/const-address-of-mut.rs:11:13\n+   |\n+LL |     let y = &raw mut x;\n+   |             ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ba162f2a2badf9a8871209a733677d3b31b8be23", "filename": "src/test/ui/consts/const-address-of.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+#![feature(raw_ref_op)]\n+\n+const A: *const i32 = &raw const *&2;\n+static B: () = { &raw const *&2; };\n+static mut C: *const i32 = &raw const *&2;\n+const D: () = { let x = 2; &raw const x; };\n+static E: () = { let x = 2; &raw const x; };\n+static mut F: () = { let x = 2; &raw const x; };\n+\n+const fn const_ptr() {\n+    let x = 0;\n+    let ptr = &raw const x;\n+    let r = &x;\n+    let ptr2 = &raw const *r;\n+}\n+\n+fn main() {}"}, {"sha": "a5c2a57c6c886c051a0553d91be34ef570a24263", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -2,7 +2,6 @@\n #![allow(unused)]\n #![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n-// normalize-stderr-test \"alignment \\d+\" -> \"alignment N\"\n // normalize-stderr-test \"offset \\d+\" -> \"offset N\"\n // normalize-stderr-test \"allocation \\d+\" -> \"allocation N\"\n // normalize-stderr-test \"size \\d+\" -> \"size N\"\n@@ -149,11 +148,23 @@ const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = &unsafe { BoolTransmute { val: 3 }\n //~^ ERROR it is undefined behavior to use this value\n \n // # raw trait object\n-const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.rust};\n+const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.raw_rust};\n //~^ ERROR it is undefined behavior to use this value\n const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.raw_rust};\n //~^ ERROR it is undefined behavior to use this value\n const RAW_TRAIT_OBJ_CONTENT_INVALID: *const dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl } as *const _; // ok because raw\n \n+// Const eval fails for these, so they need to be statics to error.\n+static mut RAW_TRAIT_OBJ_VTABLE_NULL_THROUGH_REF: *const dyn Trait = unsafe {\n+    DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.rust\n+    //~^ ERROR could not evaluate static initializer\n+};\n+static mut RAW_TRAIT_OBJ_VTABLE_INVALID_THROUGH_REF: *const dyn Trait = unsafe {\n+    DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust\n+    //~^ ERROR could not evaluate static initializer\n+};\n+\n fn main() {\n+    let _ = RAW_TRAIT_OBJ_VTABLE_NULL;\n+    let _ = RAW_TRAIT_OBJ_VTABLE_INVALID;\n }"}, {"sha": "ce57d680dc95d6ece189594614af354e04b823f7", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -1,147 +1,159 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:86:1\n    |\n LL | const STR_TOO_LONG: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:90:1\n+  --> $DIR/ub-wide-ptr.rs:89:1\n    |\n LL | const STR_LENGTH_PTR: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:93:1\n+  --> $DIR/ub-wide-ptr.rs:92:1\n    |\n LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:97:1\n+  --> $DIR/ub-wide-ptr.rs:96:1\n    |\n LL | const STR_NO_UTF8: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:100:1\n+  --> $DIR/ub-wide-ptr.rs:99:1\n    |\n LL | const MYSTR_NO_UTF8: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:107:1\n+  --> $DIR/ub-wide-ptr.rs:106:1\n    |\n LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe { SliceTransmute { addr: 42 }.slice};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:110:1\n+  --> $DIR/ub-wide-ptr.rs:109:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:113:1\n+  --> $DIR/ub-wide-ptr.rs:112:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:116:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something less or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:123:1\n+  --> $DIR/ub-wide-ptr.rs:122:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected something less or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:126:1\n+  --> $DIR/ub-wide-ptr.rs:125:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected something less or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:133:1\n+  --> $DIR/ub-wide-ptr.rs:132:1\n    |\n LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe { SliceTransmute { addr: 42 }.raw_slice};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:138:1\n+  --> $DIR/ub-wide-ptr.rs:137:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:141:1\n+  --> $DIR/ub-wide-ptr.rs:140:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:144:1\n+  --> $DIR/ub-wide-ptr.rs:143:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:148:1\n+  --> $DIR/ub-wide-ptr.rs:147:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected something less or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:152:1\n+  --> $DIR/ub-wide-ptr.rs:151:1\n    |\n-LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.raw_rust};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:154:1\n+  --> $DIR/ub-wide-ptr.rs:153:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.raw_rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: aborting due to 18 previous errors\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/ub-wide-ptr.rs:159:5\n+   |\n+LL |     DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.rust\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid use of NULL pointer\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/ub-wide-ptr.rs:163:5\n+   |\n+LL |     DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocation N which has size N\n+\n+error: aborting due to 20 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "130ba9283b1d97b9bfd2d65393779f4d3b40990b", "filename": "src/test/ui/consts/const-mut-refs/const_mut_address_of.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_address_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_address_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_address_of.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+\n+#![feature(const_mut_refs)]\n+#![feature(const_fn)]\n+#![feature(raw_ref_op)]\n+\n+struct Foo {\n+    x: usize\n+}\n+\n+const fn foo() -> Foo {\n+    Foo { x: 0 }\n+}\n+\n+impl Foo {\n+    const fn bar(&mut self) -> *mut usize {\n+        &raw mut self.x\n+    }\n+}\n+\n+const fn baz(foo: &mut Foo)-> *mut usize {\n+    &raw mut foo.x\n+}\n+\n+const _: () = {\n+    foo().bar();\n+    baz(&mut foo());\n+};\n+\n+fn main() {}"}, {"sha": "8ab011661e3c51af2f08a12bde127abd558025b4", "filename": "src/test/ui/consts/const-prop-ice3.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice3.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,7 @@\n+// run-pass (ensure that const-prop is run)\n+\n+struct A<T: ?Sized>(T);\n+\n+fn main() {\n+    let _x = &(&A([2, 3]) as &A<[i32]>).0 as *const [i32] as *const i32;\n+}"}, {"sha": "f8506d70b24980429d78376d4182953b23293c46", "filename": "src/test/ui/consts/min_const_fn/address_of.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Faddress_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Faddress_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Faddress_of.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,17 @@\n+#![feature(raw_ref_op)]\n+\n+const fn mutable_address_of_in_const() {\n+    let mut a = 0;\n+    let b = &raw mut a;         //~ ERROR `&raw mut` is not allowed\n+}\n+\n+struct X;\n+\n+impl X {\n+    const fn inherent_mutable_address_of_in_const() {\n+        let mut a = 0;\n+        let b = &raw mut a;     //~ ERROR `&raw mut` is not allowed\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "3554b8112b168eb16c735df1058f8a1c8deb93ef", "filename": "src/test/ui/consts/min_const_fn/address_of.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Faddress_of.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Faddress_of.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Faddress_of.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,21 @@\n+error[E0658]: `&raw mut` is not allowed in constant functions\n+  --> $DIR/address_of.rs:5:13\n+   |\n+LL |     let b = &raw mut a;\n+   |             ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error[E0658]: `&raw mut` is not allowed in constant functions\n+  --> $DIR/address_of.rs:13:17\n+   |\n+LL |         let b = &raw mut a;\n+   |                 ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "3db19e9cde8f069c97dde9ab4f03adc46ea568d5", "filename": "src/test/ui/consts/min_const_fn/address_of_const.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Faddress_of_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Faddress_of_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Faddress_of_const.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+#![feature(raw_ref_op)]\n+\n+const fn const_address_of_in_const() {\n+    let mut a = 0;\n+    let b = &raw const a;\n+}\n+\n+struct X;\n+\n+impl X {\n+    const fn inherent_const_address_of_in_const() {\n+        let mut a = 0;\n+        let b = &raw const a;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "dd8dbda6d43031e53b650787d91bbd2ed9008b69", "filename": "src/test/ui/lint/lint-unused-mut-variables.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -3,7 +3,7 @@\n // Exercise the unused_mut attribute in some positive and negative cases\n \n #![deny(unused_mut)]\n-#![feature(async_closure)]\n+#![feature(async_closure, raw_ref_op)]\n \n async fn baz_async(\n     mut a: i32,\n@@ -177,6 +177,12 @@ fn main() {\n     // leading underscore should avoid the warning, just like the\n     // unused variable lint.\n     let mut _allowed = 1;\n+\n+    let mut raw_address_of_mut = 1; // OK\n+    let mut_ptr = &raw mut raw_address_of_mut;\n+\n+    let mut raw_address_of_const = 1; //~ ERROR: variable does not need to be mutable\n+    let const_ptr = &raw const raw_address_of_const;\n }\n \n fn callback<F>(f: F) where F: FnOnce() {}"}, {"sha": "c1ab0ab33d4cc528ed735fbe5f3600fb933547ca", "filename": "src/test/ui/lint/lint-unused-mut-variables.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -180,6 +180,14 @@ LL |     let mut v : &mut Vec<()> = &mut vec![];\n    |         |\n    |         help: remove this `mut`\n \n+error: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:184:9\n+   |\n+LL |     let mut raw_address_of_const = 1;\n+   |         ----^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: remove this `mut`\n+\n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:106:13\n    |\n@@ -197,18 +205,18 @@ LL |     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n    |                    help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:196:9\n+  --> $DIR/lint-unused-mut-variables.rs:202:9\n    |\n LL |     let mut b = vec![2];\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n    |\n note: lint level defined here\n-  --> $DIR/lint-unused-mut-variables.rs:192:8\n+  --> $DIR/lint-unused-mut-variables.rs:198:8\n    |\n LL | #[deny(unused_mut)]\n    |        ^^^^^^^^^^\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "812d23fb58023d55be9bb5829e9949c53e394f28", "filename": "src/test/ui/packed/packed-struct-address-of-element.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -0,0 +1,37 @@\n+// run-pass\n+#![allow(dead_code)]\n+#![deny(safe_packed_borrows)]\n+#![feature(raw_ref_op)]\n+// ignore-emscripten weird assertion?\n+\n+#[repr(packed)]\n+struct Foo1 {\n+    bar: u8,\n+    baz: usize\n+}\n+\n+#[repr(packed(2))]\n+struct Foo2 {\n+    bar: u8,\n+    baz: usize\n+}\n+\n+#[repr(C, packed(4))]\n+struct Foo4C {\n+    bar: u8,\n+    baz: usize\n+}\n+\n+pub fn main() {\n+    let foo = Foo1 { bar: 1, baz: 2 };\n+    let brw = &raw const foo.baz;\n+    unsafe { assert_eq!(brw.read_unaligned(), 2); }\n+\n+    let foo = Foo2 { bar: 1, baz: 2 };\n+    let brw = &raw const foo.baz;\n+    unsafe { assert_eq!(brw.read_unaligned(), 2); }\n+\n+    let mut foo = Foo4C { bar: 1, baz: 2 };\n+    let brw = &raw mut foo.baz;\n+    unsafe { assert_eq!(brw.read_unaligned(), 2); }\n+}"}, {"sha": "0072b6191ebb0ccac0d9937be3e7f1559d9d56db", "filename": "src/test/ui/packed/packed-struct-borrow-element.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -1,4 +1,4 @@\n-// run-pass\n+// run-pass (note: this is spec-UB, but it works for now)\n #![allow(dead_code)]\n // ignore-emscripten weird assertion?\n "}, {"sha": "0c6e23a00d52501e7b89c0b248e72a1008789707", "filename": "src/test/ui/raw-ref-op/raw-ref-op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -1,11 +1,11 @@\n-// FIXME(#64490): make this run-pass\n+// run-pass\n \n #![feature(raw_ref_op)]\n \n fn main() {\n     let mut x = 123;\n-    let c_p = &raw const x;                     //~ ERROR not yet implemented\n-    let m_p = &raw mut x;                       //~ ERROR not yet implemented\n+    let c_p = &raw const x;\n+    let m_p = &raw mut x;\n     let i_r = &x;\n     assert!(c_p == i_r);\n     assert!(c_p == m_p);"}, {"sha": "04c59c95fca1eba606186ec23aa508809da44e9c", "filename": "src/test/ui/raw-ref-op/raw-ref-op.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -1,18 +0,0 @@\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-op.rs:7:15\n-   |\n-LL |     let c_p = &raw const x;\n-   |               ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-op.rs:8:15\n-   |\n-LL |     let m_p = &raw mut x;\n-   |               ^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "a814003aebf20c08a43bfdd8f56c288493e0753e", "filename": "src/test/ui/raw-ref-op/raw-ref-temp-deref.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -1,4 +1,4 @@\n-// FIXME(#64490) This should be check-pass\n+// check-pass\n // Check that taking the address of a place that contains a dereference is\n // allowed.\n #![feature(raw_ref_op, type_ascription)]\n@@ -10,15 +10,15 @@ const SLICE_REF: &[i32] = &[5, 6];\n \n fn main() {\n     // These are all OK, we're not taking the address of the temporary\n-    let deref_ref = &raw const *PAIR_REF;                       //~ ERROR not yet implemented\n-    let field_deref_ref = &raw const PAIR_REF.0;                //~ ERROR not yet implemented\n-    let deref_ref = &raw const *ARRAY_REF;                      //~ ERROR not yet implemented\n-    let index_deref_ref = &raw const ARRAY_REF[0];              //~ ERROR not yet implemented\n-    let deref_ref = &raw const *SLICE_REF;                      //~ ERROR not yet implemented\n-    let index_deref_ref = &raw const SLICE_REF[1];              //~ ERROR not yet implemented\n+    let deref_ref = &raw const *PAIR_REF;\n+    let field_deref_ref = &raw const PAIR_REF.0;\n+    let deref_ref = &raw const *ARRAY_REF;\n+    let index_deref_ref = &raw const ARRAY_REF[0];\n+    let deref_ref = &raw const *SLICE_REF;\n+    let index_deref_ref = &raw const SLICE_REF[1];\n \n     let x = 0;\n-    let ascribe_ref = &raw const (x: i32);                      //~ ERROR not yet implemented\n-    let ascribe_deref = &raw const (*ARRAY_REF: [i32; 2]);      //~ ERROR not yet implemented\n-    let ascribe_index_deref = &raw const (ARRAY_REF[0]: i32);   //~ ERROR not yet implemented\n+    let ascribe_ref = &raw const (x: i32);\n+    let ascribe_deref = &raw const (*ARRAY_REF: [i32; 2]);\n+    let ascribe_index_deref = &raw const (ARRAY_REF[0]: i32);\n }"}, {"sha": "b0bfc74903b0ce68f97c35a5ab79121a96b41285", "filename": "src/test/ui/raw-ref-op/raw-ref-temp-deref.stderr", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -1,74 +0,0 @@\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-temp-deref.rs:13:21\n-   |\n-LL |     let deref_ref = &raw const *PAIR_REF;\n-   |                     ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-temp-deref.rs:14:27\n-   |\n-LL |     let field_deref_ref = &raw const PAIR_REF.0;\n-   |                           ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-temp-deref.rs:15:21\n-   |\n-LL |     let deref_ref = &raw const *ARRAY_REF;\n-   |                     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-temp-deref.rs:16:27\n-   |\n-LL |     let index_deref_ref = &raw const ARRAY_REF[0];\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-temp-deref.rs:17:21\n-   |\n-LL |     let deref_ref = &raw const *SLICE_REF;\n-   |                     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-temp-deref.rs:18:27\n-   |\n-LL |     let index_deref_ref = &raw const SLICE_REF[1];\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-temp-deref.rs:21:23\n-   |\n-LL |     let ascribe_ref = &raw const (x: i32);\n-   |                       ^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-temp-deref.rs:22:25\n-   |\n-LL |     let ascribe_deref = &raw const (*ARRAY_REF: [i32; 2]);\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/raw-ref-temp-deref.rs:23:31\n-   |\n-LL |     let ascribe_index_deref = &raw const (ARRAY_REF[0]: i32);\n-   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: aborting due to 9 previous errors\n-"}, {"sha": "32df56468da172e95894f85e6cd187c77ab3f7a7", "filename": "src/test/ui/raw-ref-op/raw-ref-temp.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -1,15 +1,17 @@\n // Ensure that we don't allow taking the address of temporary values\n #![feature(raw_ref_op, type_ascription)]\n \n+const FOUR: u64 = 4;\n+\n const PAIR: (i32, i64) = (1, 2);\n \n const ARRAY: [i32; 2] = [1, 2];\n \n fn main() {\n     let ref_expr = &raw const 2;                        //~ ERROR cannot take address\n     let mut_ref_expr = &raw mut 3;                      //~ ERROR cannot take address\n-    let ref_const = &raw const 4;                       //~ ERROR cannot take address\n-    let mut_ref_const = &raw mut 5;                     //~ ERROR cannot take address\n+    let ref_const = &raw const FOUR;                    //~ ERROR cannot take address\n+    let mut_ref_const = &raw mut FOUR;                  //~ ERROR cannot take address\n \n     let field_ref_expr = &raw const (1, 2).0;           //~ ERROR cannot take address\n     let mut_field_ref_expr = &raw mut (1, 2).0;         //~ ERROR cannot take address"}, {"sha": "80dea76d5953b1c5243863abae85be3825237955", "filename": "src/test/ui/raw-ref-op/raw-ref-temp.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.stderr?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -1,95 +1,95 @@\n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:9:31\n+  --> $DIR/raw-ref-temp.rs:11:31\n    |\n LL |     let ref_expr = &raw const 2;\n    |                               ^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:10:33\n+  --> $DIR/raw-ref-temp.rs:12:33\n    |\n LL |     let mut_ref_expr = &raw mut 3;\n    |                                 ^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:11:32\n+  --> $DIR/raw-ref-temp.rs:13:32\n    |\n-LL |     let ref_const = &raw const 4;\n-   |                                ^ temporary value\n+LL |     let ref_const = &raw const FOUR;\n+   |                                ^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:12:34\n+  --> $DIR/raw-ref-temp.rs:14:34\n    |\n-LL |     let mut_ref_const = &raw mut 5;\n-   |                                  ^ temporary value\n+LL |     let mut_ref_const = &raw mut FOUR;\n+   |                                  ^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:14:37\n+  --> $DIR/raw-ref-temp.rs:16:37\n    |\n LL |     let field_ref_expr = &raw const (1, 2).0;\n    |                                     ^^^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:15:39\n+  --> $DIR/raw-ref-temp.rs:17:39\n    |\n LL |     let mut_field_ref_expr = &raw mut (1, 2).0;\n    |                                       ^^^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:16:32\n+  --> $DIR/raw-ref-temp.rs:18:32\n    |\n LL |     let field_ref = &raw const PAIR.0;\n    |                                ^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:17:34\n+  --> $DIR/raw-ref-temp.rs:19:34\n    |\n LL |     let mut_field_ref = &raw mut PAIR.0;\n    |                                  ^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:19:37\n+  --> $DIR/raw-ref-temp.rs:21:37\n    |\n LL |     let index_ref_expr = &raw const [1, 2][0];\n    |                                     ^^^^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:20:39\n+  --> $DIR/raw-ref-temp.rs:22:39\n    |\n LL |     let mut_index_ref_expr = &raw mut [1, 2][0];\n    |                                       ^^^^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:21:32\n+  --> $DIR/raw-ref-temp.rs:23:32\n    |\n LL |     let index_ref = &raw const ARRAY[0];\n    |                                ^^^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:22:34\n+  --> $DIR/raw-ref-temp.rs:24:34\n    |\n LL |     let mut_index_ref = &raw mut ARRAY[1];\n    |                                  ^^^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:24:34\n+  --> $DIR/raw-ref-temp.rs:26:34\n    |\n LL |     let ref_ascribe = &raw const (2: i32);\n    |                                  ^^^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:25:36\n+  --> $DIR/raw-ref-temp.rs:27:36\n    |\n LL |     let mut_ref_ascribe = &raw mut (3: i32);\n    |                                    ^^^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:27:40\n+  --> $DIR/raw-ref-temp.rs:29:40\n    |\n LL |     let ascribe_field_ref = &raw const (PAIR.0: i32);\n    |                                        ^^^^^^^^^^^^^ temporary value\n \n error[E0745]: cannot take address of a temporary\n-  --> $DIR/raw-ref-temp.rs:28:38\n+  --> $DIR/raw-ref-temp.rs:30:38\n    |\n LL |     let ascribe_index_ref = &raw mut (ARRAY[0]: i32);\n    |                                      ^^^^^^^^^^^^^^^ temporary value"}, {"sha": "6bf37408a8bbdbca2325b98bfd41959601e69e36", "filename": "src/test/ui/raw-ref-op/unusual_locations.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef013308876f28d13d835808892740f2e7f1a37c/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.rs?ref=ef013308876f28d13d835808892740f2e7f1a37c", "patch": "@@ -1,25 +1,22 @@\n-// FIXME(#64490): make this check-pass\n+// check-pass\n \n #![feature(raw_ref_op)]\n \n-const USES_PTR: () = { let u = (); &raw const u; };         //~ ERROR not yet implemented\n-static ALSO_USES_PTR: () = { let u = (); &raw const u; };   //~ ERROR not yet implemented\n+const USES_PTR: () = { let u = (); &raw const u; };\n+static ALSO_USES_PTR: () = { let u = (); &raw const u; };\n \n fn main() {\n-    #[cfg(FALSE)]\n-    {\n-        let x: [i32; { let u = 2; let x = &raw const u; 4 }]\n-            = [2; { let v = 3; let y = &raw const v; 4 }];\n-        let mut one = 1;\n-        let two = 2;\n-        if &raw const one == &raw mut one {\n-            match &raw const two {\n-                _ => {}\n-            }\n+    let x: [i32; { let u = 2; let x = &raw const u; 4 }]\n+        = [2; { let v = 3; let y = &raw const v; 4 }];\n+    let mut one = 1;\n+    let two = 2;\n+    if &raw const one == &raw mut one {\n+        match &raw const two {\n+            _ => {}\n         }\n-        let three = 3;\n-        let mut four = 4;\n-        println!(\"{:p}\", &raw const three);\n-        unsafe { &raw mut four; }\n     }\n+    let three = 3;\n+    let mut four = 4;\n+    println!(\"{:p}\", &raw const three);\n+    unsafe { &raw mut four; }\n }"}, {"sha": "3fae5db3d51a16080644f88af22895e9059d27cb", "filename": "src/test/ui/raw-ref-op/unusual_locations.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -1,18 +0,0 @@\n-error: raw borrows are not yet implemented\n-  --> $DIR/unusual_locations.rs:5:36\n-   |\n-LL | const USES_PTR: () = { let u = (); &raw const u; };\n-   |                                    ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: raw borrows are not yet implemented\n-  --> $DIR/unusual_locations.rs:6:42\n-   |\n-LL | static ALSO_USES_PTR: () = { let u = (); &raw const u; };\n-   |                                          ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n-\n-error: aborting due to 2 previous errors\n-"}]}