{"sha": "8c6dc5f28a5550acffbbb063335833304dac266d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNmRjNWYyOGE1NTUwYWNmZmJiYjA2MzMzNTgzMzMwNGRhYzI2NmQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-14T17:23:59Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-14T17:23:59Z"}, "message": "Factor macro_rules! highlighting out", "tree": {"sha": "6b5966bf5bff6436a47741ce25ace87812794eed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b5966bf5bff6436a47741ce25ace87812794eed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c6dc5f28a5550acffbbb063335833304dac266d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c6dc5f28a5550acffbbb063335833304dac266d", "html_url": "https://github.com/rust-lang/rust/commit/8c6dc5f28a5550acffbbb063335833304dac266d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c6dc5f28a5550acffbbb063335833304dac266d/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df87be88d8500c8955f882d71467e01a7d4db9ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/df87be88d8500c8955f882d71467e01a7d4db9ab", "html_url": "https://github.com/rust-lang/rust/commit/df87be88d8500c8955f882d71467e01a7d4db9ab"}], "stats": {"total": 271, "additions": 154, "deletions": 117}, "files": [{"sha": "8ecaff20473f1f1e9526d973f527180626836992", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 18, "deletions": 117, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/8c6dc5f28a5550acffbbb063335833304dac266d/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6dc5f28a5550acffbbb063335833304dac266d/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=8c6dc5f28a5550acffbbb063335833304dac266d", "patch": "@@ -1,6 +1,7 @@\n mod format;\n mod html;\n mod injection;\n+mod macro_rules;\n mod tags;\n #[cfg(test)]\n mod tests;\n@@ -18,7 +19,10 @@ use syntax::{\n     SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,\n };\n \n-use crate::{syntax_highlighting::format::FormatStringHighlighter, FileId};\n+use crate::{\n+    syntax_highlighting::{format::FormatStringHighlighter, macro_rules::MacroRulesHighlighter},\n+    FileId,\n+};\n \n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n@@ -68,8 +72,9 @@ pub(crate) fn highlight(\n     // When we leave a node, the we use it to flatten the highlighted ranges.\n     let mut stack = HighlightedRangeStack::new();\n \n-    let mut current_macro_call: Option<(ast::MacroCall, Option<MacroMatcherParseState>)> = None;\n+    let mut current_macro_call: Option<ast::MacroCall> = None;\n     let mut format_string_highlighter = FormatStringHighlighter::default();\n+    let mut macro_rules_highlighter = MacroRulesHighlighter::new();\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n@@ -99,9 +104,8 @@ pub(crate) fn highlight(\n                         binding_hash: None,\n                     });\n                 }\n-                let mut is_macro_rules = None;\n                 if let Some(name) = mc.is_macro_rules() {\n-                    is_macro_rules = Some(MacroMatcherParseState::new());\n+                    macro_rules_highlighter.init();\n                     if let Some((highlight, binding_hash)) = highlight_element(\n                         &sema,\n                         &mut bindings_shadow_count,\n@@ -115,13 +119,14 @@ pub(crate) fn highlight(\n                         });\n                     }\n                 }\n-                current_macro_call = Some((mc.clone(), is_macro_rules));\n+                current_macro_call = Some(mc.clone());\n                 continue;\n             }\n             WalkEvent::Leave(Some(mc)) => {\n-                assert!(current_macro_call.map(|it| it.0) == Some(mc));\n+                assert!(current_macro_call == Some(mc));\n                 current_macro_call = None;\n                 format_string_highlighter.reset();\n+                macro_rules_highlighter.reset();\n             }\n             _ => (),\n         }\n@@ -148,20 +153,6 @@ pub(crate) fn highlight(\n             WalkEvent::Leave(_) => continue,\n         };\n \n-        // check if in matcher part of a macro_rules rule\n-        if let Some((_, Some(ref mut state))) = current_macro_call {\n-            if let Some(tok) = element.as_token() {\n-                if matches!(\n-                    update_macro_rules_state(tok, state),\n-                    RuleState::Matcher | RuleState::Expander\n-                ) {\n-                    if skip_metavariables(element.clone()) {\n-                        continue;\n-                    }\n-                }\n-            }\n-        }\n-\n         let range = element.text_range();\n \n         let element_to_highlight = if current_macro_call.is_some() && element.kind() != COMMENT {\n@@ -174,6 +165,9 @@ pub(crate) fn highlight(\n             let parent = token.parent();\n \n             format_string_highlighter.check_for_format_string(&parent);\n+            if let Some(tok) = element.as_token() {\n+                macro_rules_highlighter.advance(tok);\n+            }\n \n             // We only care Name and Name_ref\n             match (token.kind(), parent.kind()) {\n@@ -197,7 +191,10 @@ pub(crate) fn highlight(\n             syntactic_name_ref_highlighting,\n             element_to_highlight.clone(),\n         ) {\n-            stack.add(HighlightedRange { range, highlight, binding_hash });\n+            if macro_rules_highlighter.highlight(element_to_highlight.clone()).is_none() {\n+                stack.add(HighlightedRange { range, highlight, binding_hash });\n+            }\n+\n             if let Some(string) =\n                 element_to_highlight.as_token().cloned().and_then(ast::String::cast)\n             {\n@@ -867,99 +864,3 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n         _ => default.into(),\n     }\n }\n-\n-struct MacroMatcherParseState {\n-    /// Opening and corresponding closing bracket of the matcher or expander of the current rule\n-    paren_ty: Option<(SyntaxKind, SyntaxKind)>,\n-    paren_level: usize,\n-    rule_state: RuleState,\n-    /// Whether we are inside the outer `{` `}` macro block that holds the rules\n-    in_invoc_body: bool,\n-}\n-\n-impl MacroMatcherParseState {\n-    fn new() -> Self {\n-        MacroMatcherParseState {\n-            paren_ty: None,\n-            paren_level: 0,\n-            in_invoc_body: false,\n-            rule_state: RuleState::None,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-enum RuleState {\n-    Matcher,\n-    Expander,\n-    Between,\n-    None,\n-}\n-\n-impl RuleState {\n-    fn transition(&mut self) {\n-        *self = match self {\n-            RuleState::Matcher => RuleState::Between,\n-            RuleState::Expander => RuleState::None,\n-            RuleState::Between => RuleState::Expander,\n-            RuleState::None => RuleState::Matcher,\n-        };\n-    }\n-}\n-\n-fn update_macro_rules_state(tok: &SyntaxToken, state: &mut MacroMatcherParseState) -> RuleState {\n-    if !state.in_invoc_body {\n-        if tok.kind() == T!['{'] {\n-            state.in_invoc_body = true;\n-        }\n-        return state.rule_state;\n-    }\n-\n-    match state.paren_ty {\n-        Some((open, close)) => {\n-            if tok.kind() == open {\n-                state.paren_level += 1;\n-            } else if tok.kind() == close {\n-                state.paren_level -= 1;\n-                if state.paren_level == 0 {\n-                    let res = state.rule_state;\n-                    state.rule_state.transition();\n-                    state.paren_ty = None;\n-                    return res;\n-                }\n-            }\n-        }\n-        None => {\n-            match tok.kind() {\n-                T!['('] => {\n-                    state.paren_ty = Some((T!['('], T![')']));\n-                }\n-                T!['{'] => {\n-                    state.paren_ty = Some((T!['{'], T!['}']));\n-                }\n-                T!['['] => {\n-                    state.paren_ty = Some((T!['['], T![']']));\n-                }\n-                _ => (),\n-            }\n-            if state.paren_ty.is_some() {\n-                state.paren_level = 1;\n-                state.rule_state.transition();\n-            }\n-        }\n-    }\n-    state.rule_state\n-}\n-\n-fn skip_metavariables(element: SyntaxElement) -> bool {\n-    let tok = match element.as_token() {\n-        Some(tok) => tok,\n-        None => return false,\n-    };\n-    let is_fragment = || tok.prev_token().map(|tok| tok.kind()) == Some(T![$]);\n-    match tok.kind() {\n-        IDENT if is_fragment() => true,\n-        kind if kind.is_keyword() && is_fragment() => true,\n-        _ => false,\n-    }\n-}"}, {"sha": "0676e09726a17c03bfd85d336e1175e71616bc2c", "filename": "crates/ide/src/syntax_highlighting/macro_rules.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/8c6dc5f28a5550acffbbb063335833304dac266d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6dc5f28a5550acffbbb063335833304dac266d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs?ref=8c6dc5f28a5550acffbbb063335833304dac266d", "patch": "@@ -0,0 +1,136 @@\n+//! Syntax highlighting for macro_rules!.\n+use syntax::{SyntaxElement, SyntaxKind, SyntaxToken, TextRange, T};\n+\n+use crate::{HighlightTag, HighlightedRange};\n+\n+pub(super) struct MacroRulesHighlighter {\n+    state: Option<MacroMatcherParseState>,\n+}\n+\n+impl MacroRulesHighlighter {\n+    pub(super) fn new() -> Self {\n+        MacroRulesHighlighter { state: None }\n+    }\n+\n+    pub(super) fn init(&mut self) {\n+        self.state = Some(MacroMatcherParseState::new());\n+    }\n+\n+    pub(super) fn reset(&mut self) {\n+        self.state = None;\n+    }\n+\n+    pub(super) fn advance(&mut self, token: &SyntaxToken) {\n+        if let Some(state) = self.state.as_mut() {\n+            update_macro_rules_state(state, token);\n+        }\n+    }\n+\n+    pub(super) fn highlight(&self, element: SyntaxElement) -> Option<HighlightedRange> {\n+        if let Some(state) = self.state.as_ref() {\n+            if matches!(state.rule_state, RuleState::Matcher | RuleState::Expander) {\n+                if let Some(range) = is_metavariable(element) {\n+                    return Some(HighlightedRange {\n+                        range,\n+                        highlight: HighlightTag::UnresolvedReference.into(),\n+                        binding_hash: None,\n+                    });\n+                }\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+struct MacroMatcherParseState {\n+    /// Opening and corresponding closing bracket of the matcher or expander of the current rule\n+    paren_ty: Option<(SyntaxKind, SyntaxKind)>,\n+    paren_level: usize,\n+    rule_state: RuleState,\n+    /// Whether we are inside the outer `{` `}` macro block that holds the rules\n+    in_invoc_body: bool,\n+}\n+\n+impl MacroMatcherParseState {\n+    fn new() -> Self {\n+        MacroMatcherParseState {\n+            paren_ty: None,\n+            paren_level: 0,\n+            in_invoc_body: false,\n+            rule_state: RuleState::None,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum RuleState {\n+    Matcher,\n+    Expander,\n+    Between,\n+    None,\n+}\n+\n+impl RuleState {\n+    fn transition(&mut self) {\n+        *self = match self {\n+            RuleState::Matcher => RuleState::Between,\n+            RuleState::Expander => RuleState::None,\n+            RuleState::Between => RuleState::Expander,\n+            RuleState::None => RuleState::Matcher,\n+        };\n+    }\n+}\n+\n+fn update_macro_rules_state(state: &mut MacroMatcherParseState, tok: &SyntaxToken) {\n+    if !state.in_invoc_body {\n+        if tok.kind() == T!['{'] {\n+            state.in_invoc_body = true;\n+        }\n+        return;\n+    }\n+\n+    match state.paren_ty {\n+        Some((open, close)) => {\n+            if tok.kind() == open {\n+                state.paren_level += 1;\n+            } else if tok.kind() == close {\n+                state.paren_level -= 1;\n+                if state.paren_level == 0 {\n+                    state.rule_state.transition();\n+                    state.paren_ty = None;\n+                }\n+            }\n+        }\n+        None => {\n+            match tok.kind() {\n+                T!['('] => {\n+                    state.paren_ty = Some((T!['('], T![')']));\n+                }\n+                T!['{'] => {\n+                    state.paren_ty = Some((T!['{'], T!['}']));\n+                }\n+                T!['['] => {\n+                    state.paren_ty = Some((T!['['], T![']']));\n+                }\n+                _ => (),\n+            }\n+            if state.paren_ty.is_some() {\n+                state.paren_level = 1;\n+                state.rule_state.transition();\n+            }\n+        }\n+    }\n+}\n+\n+fn is_metavariable(element: SyntaxElement) -> Option<TextRange> {\n+    let tok = element.as_token()?;\n+    match tok.kind() {\n+        kind if kind == SyntaxKind::IDENT || kind.is_keyword() => {\n+            if let Some(_dollar) = tok.prev_token().filter(|t| t.kind() == SyntaxKind::DOLLAR) {\n+                return Some(tok.text_range());\n+            }\n+        }\n+        _ => (),\n+    };\n+    None\n+}"}]}