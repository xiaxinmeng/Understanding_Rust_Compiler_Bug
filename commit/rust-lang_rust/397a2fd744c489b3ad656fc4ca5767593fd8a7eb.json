{"sha": "397a2fd744c489b3ad656fc4ca5767593fd8a7eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5N2EyZmQ3NDRjNDg5YjNhZDY1NmZjNGNhNTc2NzU5M2ZkOGE3ZWI=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-12-28T21:43:39Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-12-31T01:08:36Z"}, "message": "[const-prop] Extract some functions out of `_const_prop`", "tree": {"sha": "89809ad712466dee0b9a3b85d5288ec4c5b1335d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89809ad712466dee0b9a3b85d5288ec4c5b1335d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/397a2fd744c489b3ad656fc4ca5767593fd8a7eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/397a2fd744c489b3ad656fc4ca5767593fd8a7eb", "html_url": "https://github.com/rust-lang/rust/commit/397a2fd744c489b3ad656fc4ca5767593fd8a7eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/397a2fd744c489b3ad656fc4ca5767593fd8a7eb/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e083273ec77b96a17f317d83fa3fed8ab205964a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e083273ec77b96a17f317d83fa3fed8ab205964a", "html_url": "https://github.com/rust-lang/rust/commit/e083273ec77b96a17f317d83fa3fed8ab205964a"}], "stats": {"total": 209, "additions": 118, "deletions": 91}, "files": [{"sha": "2ba18359e02cde827884b00631e3ac001f1f2711", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 118, "deletions": 91, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/397a2fd744c489b3ad656fc4ca5767593fd8a7eb/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397a2fd744c489b3ad656fc4ca5767593fd8a7eb/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=397a2fd744c489b3ad656fc4ca5767593fd8a7eb", "patch": "@@ -469,15 +469,128 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n+    fn check_unary_op(&mut self, arg: &Operand<'tcx>, source_info: SourceInfo) -> Option<()> {\n+        self.use_ecx(source_info, |this| {\n+            let ty = arg.ty(&this.local_decls, this.tcx);\n+\n+            if ty.is_integral() {\n+                let arg = this.ecx.eval_operand(arg, None)?;\n+                let prim = this.ecx.read_immediate(arg)?;\n+                // Need to do overflow check here: For actual CTFE, MIR\n+                // generation emits code that does this before calling the op.\n+                if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n+                    throw_panic!(OverflowNeg)\n+                }\n+            }\n+\n+            Ok(())\n+        })?;\n+\n+        Some(())\n+    }\n+\n+    fn check_binary_op(\n+        &mut self,\n+        op: BinOp,\n+        left: &Operand<'tcx>,\n+        right: &Operand<'tcx>,\n+        source_info: SourceInfo,\n+        place_layout: TyLayout<'tcx>,\n+        overflow_check: bool,\n+    ) -> Option<()> {\n+        let r = self.use_ecx(source_info, |this| {\n+            this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n+        })?;\n+        if op == BinOp::Shr || op == BinOp::Shl {\n+            let left_bits = place_layout.size.bits();\n+            let right_size = r.layout.size;\n+            let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n+            if r_bits.map_or(false, |b| b >= left_bits as u128) {\n+                let lint_root = self.lint_root(source_info)?;\n+                let dir = if op == BinOp::Shr { \"right\" } else { \"left\" };\n+                self.tcx.lint_hir(\n+                    ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n+                    lint_root,\n+                    source_info.span,\n+                    &format!(\"attempt to shift {} with overflow\", dir),\n+                );\n+                return None;\n+            }\n+        }\n+\n+        // If overflow checking is enabled (like in debug mode by default),\n+        // then we'll already catch overflow when we evaluate the `Assert` statement\n+        // in MIR. However, if overflow checking is disabled, then there won't be any\n+        // `Assert` statement and so we have to do additional checking here.\n+        if !overflow_check {\n+            self.use_ecx(source_info, |this| {\n+                let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n+                let (_, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+\n+                if overflow {\n+                    let err = err_panic!(Overflow(op)).into();\n+                    return Err(err);\n+                }\n+\n+                Ok(())\n+            })?;\n+        }\n+\n+        Some(())\n+    }\n+\n+    fn check_cast(\n+        &mut self,\n+        op: &Operand<'tcx>,\n+        ty: Ty<'tcx>,\n+        source_info: SourceInfo,\n+        place_layout: TyLayout<'tcx>,\n+    ) -> Option<()> {\n+        if ty.is_integral() && op.ty(&self.local_decls, self.tcx).is_integral() {\n+            let value = self.use_ecx(source_info, |this| {\n+                this.ecx.read_immediate(this.ecx.eval_operand(op, None)?)\n+            })?;\n+\n+            // Do not try to read bits for ZSTs\n+            if !value.layout.is_zst() {\n+                let value_size = value.layout.size;\n+                let value_bits = value.to_scalar().and_then(|r| r.to_bits(value_size));\n+                if let Ok(value_bits) = value_bits {\n+                    let truncated = truncate(value_bits, place_layout.size);\n+                    if truncated != value_bits {\n+                        let scope = source_info.scope;\n+                        let lint_root = match &self.source_scopes[scope].local_data {\n+                            ClearCrossCrate::Set(data) => data.lint_root,\n+                            ClearCrossCrate::Clear => return None,\n+                        };\n+                        self.tcx.lint_hir(\n+                            ::rustc::lint::builtin::CONST_ERR,\n+                            lint_root,\n+                            source_info.span,\n+                            &format!(\n+                                \"truncating cast: the value {} requires {} bits but \\\n+                                              the target type is only {} bits\",\n+                                value_bits,\n+                                value_size.bits(),\n+                                place_layout.size.bits()\n+                            ),\n+                        );\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        Some(())\n+    }\n+\n     fn const_prop(\n         &mut self,\n         rvalue: &Rvalue<'tcx>,\n         place_layout: TyLayout<'tcx>,\n         source_info: SourceInfo,\n         place: &Place<'tcx>,\n     ) -> Option<()> {\n-        let span = source_info.span;\n-\n         // #66397: Don't try to eval into large places as that can cause an OOM\n         if place_layout.size >= Size::from_bytes(MAX_ALLOC_LIMIT) {\n             return None;\n@@ -498,66 +611,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // if an overflow would occur.\n             Rvalue::UnaryOp(UnOp::Neg, arg) if !overflow_check => {\n                 trace!(\"checking UnaryOp(op = Neg, arg = {:?})\", arg);\n-\n-                self.use_ecx(source_info, |this| {\n-                    let ty = arg.ty(&this.local_decls, this.tcx);\n-\n-                    if ty.is_integral() {\n-                        let arg = this.ecx.eval_operand(arg, None)?;\n-                        let prim = this.ecx.read_immediate(arg)?;\n-                        // Need to do overflow check here: For actual CTFE, MIR\n-                        // generation emits code that does this before calling the op.\n-                        if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                            throw_panic!(OverflowNeg)\n-                        }\n-                    }\n-\n-                    Ok(())\n-                })?;\n+                self.check_unary_op(arg, source_info)?;\n             }\n \n             // Additional checking: check for overflows on integer binary operations and report\n             // them to the user as lints.\n             Rvalue::BinaryOp(op, left, right) => {\n                 trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-\n-                let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n-                })?;\n-                if *op == BinOp::Shr || *op == BinOp::Shl {\n-                    let left_bits = place_layout.size.bits();\n-                    let right_size = r.layout.size;\n-                    let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n-                    if r_bits.map_or(false, |b| b >= left_bits as u128) {\n-                        let lint_root = self.lint_root(source_info)?;\n-                        let dir = if *op == BinOp::Shr { \"right\" } else { \"left\" };\n-                        self.tcx.lint_hir(\n-                            ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n-                            lint_root,\n-                            span,\n-                            &format!(\"attempt to shift {} with overflow\", dir),\n-                        );\n-                        return None;\n-                    }\n-                }\n-\n-                // If overflow checking is enabled (like in debug mode by default),\n-                // then we'll already catch overflow when we evaluate the `Assert` statement\n-                // in MIR. However, if overflow checking is disabled, then there won't be any\n-                // `Assert` statement and so we have to do additional checking here.\n-                if !overflow_check {\n-                    self.use_ecx(source_info, |this| {\n-                        let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n-                        let (_, overflow, _ty) = this.ecx.overflowing_binary_op(*op, l, r)?;\n-\n-                        if overflow {\n-                            let err = err_panic!(Overflow(*op)).into();\n-                            return Err(err);\n-                        }\n-\n-                        Ok(())\n-                    })?;\n-                }\n+                self.check_binary_op(*op, left, right, source_info, place_layout, overflow_check)?;\n             }\n \n             // Work around: avoid ICE in miri. FIXME(wesleywiser)\n@@ -586,41 +647,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n             Rvalue::Cast(CastKind::Misc, op, ty) => {\n                 trace!(\"checking Cast(Misc, {:?}, {:?})\", op, ty);\n-\n-                if ty.is_integral() && op.ty(&self.local_decls, self.tcx).is_integral() {\n-                    let value = self.use_ecx(source_info, |this| {\n-                        this.ecx.read_immediate(this.ecx.eval_operand(op, None)?)\n-                    })?;\n-\n-                    // Do not try to read bits for ZSTs\n-                    if !value.layout.is_zst() {\n-                        let value_size = value.layout.size;\n-                        let value_bits = value.to_scalar().and_then(|r| r.to_bits(value_size));\n-                        if let Ok(value_bits) = value_bits {\n-                            let truncated = truncate(value_bits, place_layout.size);\n-                            if truncated != value_bits {\n-                                let scope = source_info.scope;\n-                                let lint_root = match &self.source_scopes[scope].local_data {\n-                                    ClearCrossCrate::Set(data) => data.lint_root,\n-                                    ClearCrossCrate::Clear => return None,\n-                                };\n-                                self.tcx.lint_hir(\n-                                    ::rustc::lint::builtin::CONST_ERR,\n-                                    lint_root,\n-                                    span,\n-                                    &format!(\n-                                        \"truncating cast: the value {} requires {} bits but \\\n-                                              the target type is only {} bits\",\n-                                        value_bits,\n-                                        value_size.bits(),\n-                                        place_layout.size.bits()\n-                                    ),\n-                                );\n-                                return None;\n-                            }\n-                        }\n-                    }\n-                }\n+                self.check_cast(op, ty, source_info, place_layout)?;\n             }\n \n             _ => {}"}]}