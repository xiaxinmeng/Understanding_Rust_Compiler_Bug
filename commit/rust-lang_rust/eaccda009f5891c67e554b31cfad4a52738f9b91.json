{"sha": "eaccda009f5891c67e554b31cfad4a52738f9b91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhY2NkYTAwOWY1ODkxYzY3ZTU1NGIzMWNmYWQ0YTUyNzM4ZjliOTE=", "commit": {"author": {"name": "Adam Perry", "email": "adam.n.perry@gmail.com", "date": "2019-12-07T16:37:08Z"}, "committer": {"name": "Adam Perry", "email": "adam.n.perry@gmail.com", "date": "2020-01-04T18:02:17Z"}, "message": "core and std macros and panic internals use panic::Location::caller.", "tree": {"sha": "8bfa146ae2a2e7210357d4956aab42213d8216ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bfa146ae2a2e7210357d4956aab42213d8216ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaccda009f5891c67e554b31cfad4a52738f9b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaccda009f5891c67e554b31cfad4a52738f9b91", "html_url": "https://github.com/rust-lang/rust/commit/eaccda009f5891c67e554b31cfad4a52738f9b91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaccda009f5891c67e554b31cfad4a52738f9b91/comments", "author": {"login": "anp", "id": 6812281, "node_id": "MDQ6VXNlcjY4MTIyODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6812281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anp", "html_url": "https://github.com/anp", "followers_url": "https://api.github.com/users/anp/followers", "following_url": "https://api.github.com/users/anp/following{/other_user}", "gists_url": "https://api.github.com/users/anp/gists{/gist_id}", "starred_url": "https://api.github.com/users/anp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anp/subscriptions", "organizations_url": "https://api.github.com/users/anp/orgs", "repos_url": "https://api.github.com/users/anp/repos", "events_url": "https://api.github.com/users/anp/events{/privacy}", "received_events_url": "https://api.github.com/users/anp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anp", "id": 6812281, "node_id": "MDQ6VXNlcjY4MTIyODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6812281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anp", "html_url": "https://github.com/anp", "followers_url": "https://api.github.com/users/anp/followers", "following_url": "https://api.github.com/users/anp/following{/other_user}", "gists_url": "https://api.github.com/users/anp/gists{/gist_id}", "starred_url": "https://api.github.com/users/anp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anp/subscriptions", "organizations_url": "https://api.github.com/users/anp/orgs", "repos_url": "https://api.github.com/users/anp/repos", "events_url": "https://api.github.com/users/anp/events{/privacy}", "received_events_url": "https://api.github.com/users/anp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ed41b072093fe7cccd232f9a2964c5fb6ab9f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ed41b072093fe7cccd232f9a2964c5fb6ab9f60", "html_url": "https://github.com/rust-lang/rust/commit/1ed41b072093fe7cccd232f9a2964c5fb6ab9f60"}], "stats": {"total": 72, "additions": 35, "deletions": 37}, "files": [{"sha": "0eb9e19423617b789ff2d27f914a6bb1b391431d", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=eaccda009f5891c67e554b31cfad4a52738f9b91", "patch": "@@ -1,27 +1,21 @@\n #[doc(include = \"panic.md\")]\n #[macro_export]\n-#[allow_internal_unstable(core_panic,\n-    // FIXME(anp, eddyb) `core_intrinsics` is used here to allow calling\n-    // the `caller_location` intrinsic, but once  `#[track_caller]` is implemented,\n-    // `panicking::{panic, panic_fmt}` can use that instead of a `Location` argument.\n-    core_intrinsics,\n-    const_caller_location,\n-)]\n+#[allow_internal_unstable(core_panic, track_caller)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n         $crate::panic!(\"explicit panic\")\n     );\n     ($msg:expr) => (\n-        $crate::panicking::panic($msg, $crate::intrinsics::caller_location())\n+        $crate::panicking::panic($msg)\n     );\n     ($msg:expr,) => (\n         $crate::panic!($msg)\n     );\n     ($fmt:expr, $($arg:tt)+) => (\n         $crate::panicking::panic_fmt(\n             $crate::format_args!($fmt, $($arg)+),\n-            $crate::intrinsics::caller_location(),\n+            $crate::panic::Location::caller(),\n         )\n     );\n }"}, {"sha": "61b764f2d6206ad7773ede553601ea130ce968d1", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=eaccda009f5891c67e554b31cfad4a52738f9b91", "patch": "@@ -36,8 +36,9 @@ use crate::panic::{Location, PanicInfo};\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[track_caller]\n #[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\n-pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n+pub fn panic(expr: &str) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { super::intrinsics::abort() }\n     }\n@@ -48,7 +49,7 @@ pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), location)\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), Location::caller())\n }\n \n #[cold]"}, {"sha": "868f620300133711d8970b13d1bdefaf4291c89a", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=eaccda009f5891c67e554b31cfad4a52738f9b91", "patch": "@@ -6,7 +6,7 @@ use syntax::ptr::P;\n use syntax::source_map::{respan, Spanned};\n use syntax::symbol::{kw, sym, Symbol};\n \n-use rustc_span::{Pos, Span};\n+use rustc_span::Span;\n \n impl<'a> ExtCtxt<'a> {\n     pub fn path(&self, span: Span, strs: Vec<ast::Ident>) -> ast::Path {\n@@ -350,16 +350,10 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n-        let loc = self.source_map().lookup_char_pos(span.lo());\n-        let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name.to_string()));\n-        let expr_line = self.expr_u32(span, loc.line as u32);\n-        let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);\n-        let expr_loc_tuple = self.expr_tuple(span, vec![expr_file, expr_line, expr_col]);\n-        let expr_loc_ptr = self.expr_addr_of(span, expr_loc_tuple);\n         self.expr_call_global(\n             span,\n             [sym::std, sym::rt, sym::begin_panic].iter().map(|s| Ident::new(*s, span)).collect(),\n-            vec![self.expr_str(span, msg), expr_loc_ptr],\n+            vec![self.expr_str(span, msg)],\n         )\n     }\n "}, {"sha": "256f7f2ab388b9870a7b0c1b8d44f870edbcd065", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=eaccda009f5891c67e554b31cfad4a52738f9b91", "patch": "@@ -392,7 +392,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             throw_panic!(Panic { msg, file, line, col })\n         } else if Some(def_id) == self.tcx.lang_items().begin_panic_fn() {\n             assert!(args.len() == 2);\n-            // &'static str, &(&'static str, u32, u32)\n+            // &'static str, &core::panic::Location { &'static str, u32, u32 }\n             let msg = args[0];\n             let place = self.deref_operand(args[1])?;\n             let (file, line, col) = ("}, {"sha": "23f82d7c2119dfbbd11c58032d728b21f8270662", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=eaccda009f5891c67e554b31cfad4a52738f9b91", "patch": "@@ -306,6 +306,7 @@\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n #![feature(trace_macros)]\n+#![feature(track_caller)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]"}, {"sha": "18fb0f87688dea28d9e3ee577a5f5413b739306d", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=eaccda009f5891c67e554b31cfad4a52738f9b91", "patch": "@@ -4,6 +4,7 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n+#[cfg(bootstrap)]\n #[doc(include = \"../libcore/macros/panic.md\")]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -19,8 +20,21 @@ macro_rules! panic {\n         $crate::panic!($msg)\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+),\n-                                    &($crate::file!(), $crate::line!(), $crate::column!()))\n+        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+))\n+    });\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[doc(include = \"../libcore/macros/panic.md\")]\n+#[macro_export]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow_internal_unstable(libstd_sys_internals)]\n+macro_rules! panic {\n+    () => ({ $crate::panic!(\"explicit panic\") });\n+    ($msg:expr) => ({ $crate::rt::begin_panic($msg) });\n+    ($msg:expr,) => ({ $crate::panic!($msg) });\n+    ($fmt:expr, $($arg:tt)+) => ({\n+        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+))\n     });\n }\n "}, {"sha": "e3ce7a33a6f1f9e89db2122b7c6e0569562961f7", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaccda009f5891c67e554b31cfad4a52738f9b91/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=eaccda009f5891c67e554b31cfad4a52738f9b91", "patch": "@@ -313,17 +313,15 @@ pub fn panicking() -> bool {\n #[cold]\n // If panic_immediate_abort, inline the abort call,\n // otherwise avoid inlining because of it is cold path.\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), track_caller)]\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u32)) -> ! {\n+pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { intrinsics::abort() }\n     }\n \n-    // Just package everything into a `PanicInfo` and continue like libcore panics.\n-    let (file, line, col) = *file_line_col;\n-    let location = Location::internal_constructor(file, line, col);\n-    let info = PanicInfo::internal_constructor(Some(msg), &location);\n+    let info = PanicInfo::internal_constructor(Some(msg), Location::caller());\n     begin_panic_handler(&info)\n }\n \n@@ -372,8 +370,7 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n \n     let loc = info.location().unwrap(); // The current implementation always returns Some\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n-    let file_line_col = (loc.file(), loc.line(), loc.column());\n-    rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), &file_line_col);\n+    rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n }\n \n /// This is the entry point of panicking for the non-format-string variants of\n@@ -386,7 +383,8 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n // bloat at the call sites as much as possible\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[cold]\n-pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n+#[track_caller]\n+pub fn begin_panic<M: Any + Send>(msg: M, #[cfg(bootstrap)] _: &(&str, u32, u32)) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { intrinsics::abort() }\n     }\n@@ -397,8 +395,7 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n     // we do start doing this, then we should propagate this allocation to\n     // be performed in the parent of this thread instead of the thread that's\n     // panicking.\n-\n-    rust_panic_with_hook(&mut PanicPayload::new(msg), None, file_line_col);\n+    rust_panic_with_hook(&mut PanicPayload::new(msg), None, Location::caller());\n \n     struct PanicPayload<A> {\n         inner: Option<A>,\n@@ -436,10 +433,8 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n fn rust_panic_with_hook(\n     payload: &mut dyn BoxMeUp,\n     message: Option<&fmt::Arguments<'_>>,\n-    file_line_col: &(&str, u32, u32),\n+    location: &Location<'_>,\n ) -> ! {\n-    let (file, line, col) = *file_line_col;\n-\n     let panics = update_panic_count(1);\n \n     // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n@@ -456,8 +451,7 @@ fn rust_panic_with_hook(\n     }\n \n     unsafe {\n-        let location = Location::internal_constructor(file, line, col);\n-        let mut info = PanicInfo::internal_constructor(message, &location);\n+        let mut info = PanicInfo::internal_constructor(message, location);\n         HOOK_LOCK.read();\n         match HOOK {\n             // Some platforms (like wasm) know that printing to stderr won't ever actually"}]}