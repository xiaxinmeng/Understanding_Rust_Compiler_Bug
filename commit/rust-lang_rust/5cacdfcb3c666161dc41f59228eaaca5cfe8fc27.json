{"sha": "5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYWNkZmNiM2M2NjYxNjFkYzQxZjU5MjI4ZWFhY2E1Y2ZlOGZjMjc=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-21T13:13:45Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-21T13:13:45Z"}, "message": "Merge #872\n\n872: simplify trait bounds r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "33fc9206a9ee2f2f1c64eeb85748bf5e9cd1c3f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33fc9206a9ee2f2f1c64eeb85748bf5e9cd1c3f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "html_url": "https://github.com/rust-lang/rust/commit/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "9be7426aae359d49ef272db74528a706e7f738a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9be7426aae359d49ef272db74528a706e7f738a0", "html_url": "https://github.com/rust-lang/rust/commit/9be7426aae359d49ef272db74528a706e7f738a0"}, {"sha": "7060a39d5c8dc2c72fe207536fee649ff615860f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7060a39d5c8dc2c72fe207536fee649ff615860f", "html_url": "https://github.com/rust-lang/rust/commit/7060a39d5c8dc2c72fe207536fee649ff615860f"}], "stats": {"total": 343, "additions": 168, "deletions": 175}, "files": [{"sha": "294f4b8af7884dff1dda07e66169ddd656137b02", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "patch": "@@ -4,7 +4,7 @@ use std::{fs, io::Read, path::Path, time::Instant};\n \n use clap::{App, Arg, SubCommand};\n use join_to_string::join;\n-use ra_ide_api_light::{extend_selection, file_structure, syntax_tree};\n+use ra_ide_api_light::{extend_selection, file_structure};\n use ra_syntax::{SourceFile, TextRange, TreeArc, AstNode};\n use tools::collect_tests;\n use flexi_logger::Logger;\n@@ -37,7 +37,7 @@ fn main() -> Result<()> {\n             let file = file()?;\n             let elapsed = start.elapsed();\n             if !matches.is_present(\"no-dump\") {\n-                println!(\"{}\", syntax_tree(&file));\n+                println!(\"{}\", file.syntax().debug_dump());\n             }\n             eprintln!(\"parsing: {:?}\", elapsed);\n             ::std::mem::forget(file);\n@@ -94,7 +94,7 @@ fn render_test(file: &Path, line: usize) -> Result<(String, String)> {\n         Some((_start_line, test)) => test,\n     };\n     let file = SourceFile::parse(&test.text);\n-    let tree = syntax_tree(&file);\n+    let tree = file.syntax().debug_dump();\n     Ok((test.text, tree))\n }\n "}, {"sha": "4b9fc9372e5a3ed578c517b87f403349493d9788", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "patch": "@@ -38,7 +38,7 @@ mod marks;\n \n use std::sync::Arc;\n \n-use ra_syntax::{SourceFile, TreeArc, TextRange, TextUnit};\n+use ra_syntax::{SourceFile, TreeArc, TextRange, TextUnit, AstNode};\n use ra_text_edit::TextEdit;\n use ra_db::{\n     SourceDatabase, CheckCanceled,\n@@ -244,8 +244,7 @@ impl Analysis {\n     /// Returns a syntax tree represented as `String`, for debug purposes.\n     // FIXME: use a better name here.\n     pub fn syntax_tree(&self, file_id: FileId) -> String {\n-        let file = self.db.parse(file_id);\n-        ra_ide_api_light::syntax_tree(&file)\n+        self.db.parse(file_id).syntax().debug_dump()\n     }\n \n     /// Returns an edit to remove all newlines in the range, cleaning up minor"}, {"sha": "43cdd6ea4dd3e94a8a7793660429ea5bee634b13", "filename": "crates/ra_ide_api_light/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs?ref=5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "patch": "@@ -123,10 +123,6 @@ pub fn highlight(root: &SyntaxNode) -> Vec<HighlightedRange> {\n     res\n }\n \n-pub fn syntax_tree(file: &SourceFile) -> String {\n-    ::ra_syntax::utils::dump_tree(file.syntax())\n-}\n-\n #[cfg(test)]\n mod tests {\n     use ra_syntax::AstNode;"}, {"sha": "4667d5579fe7a5b32ef7bfbc64f06f21720e6b78", "filename": "crates/ra_syntax/fuzz/fuzz_targets/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Ffuzz%2Ffuzz_targets%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Ffuzz%2Ffuzz_targets%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ffuzz%2Ffuzz_targets%2Fparser.rs?ref=5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "patch": "@@ -4,6 +4,6 @@ extern crate ra_syntax;\n \n fuzz_target!(|data: &[u8]| {\n     if let Ok(text) = std::str::from_utf8(data) {\n-        ra_syntax::utils::check_fuzz_invariants(text)\n+        ra_syntax::check_fuzz_invariants(text)\n     }\n });"}, {"sha": "dc4b779e82fd63064783b348932c6dfa02fd2c71", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "patch": "@@ -27,8 +27,6 @@ mod ptr;\n \n pub mod algo;\n pub mod ast;\n-/// Utilities for simple uses of the parser.\n-pub mod utils;\n \n pub use rowan::{SmolStr, TextRange, TextUnit};\n pub use ra_parser::SyntaxKind;\n@@ -51,7 +49,7 @@ impl SourceFile {\n     fn new(green: GreenNode, errors: Vec<SyntaxError>) -> TreeArc<SourceFile> {\n         let root = SyntaxNode::new(green, errors);\n         if cfg!(debug_assertions) {\n-            utils::validate_block_structure(&root);\n+            validation::validate_block_structure(&root);\n         }\n         assert_eq!(root.kind(), SyntaxKind::SOURCE_FILE);\n         TreeArc::cast(root)\n@@ -82,3 +80,10 @@ impl SourceFile {\n         errors\n     }\n }\n+\n+pub fn check_fuzz_invariants(text: &str) {\n+    let file = SourceFile::parse(text);\n+    let root = file.syntax();\n+    validation::validate_block_structure(root);\n+    let _ = file.errors();\n+}"}, {"sha": "19d8adcfb3701a8ecbe26a91a565aad766582dff", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "patch": "@@ -143,7 +143,7 @@ fn merge_errors(\n mod tests {\n     use test_utils::{extract_range, assert_eq_text};\n \n-    use crate::{SourceFile, AstNode, utils::dump_tree};\n+    use crate::{SourceFile, AstNode};\n     use super::*;\n \n     fn do_check<F>(before: &str, replace_with: &str, reparser: F)\n@@ -169,8 +169,8 @@ mod tests {\n         };\n \n         assert_eq_text!(\n-            &dump_tree(fully_reparsed.syntax()),\n-            &dump_tree(incrementally_reparsed.syntax()),\n+            &fully_reparsed.syntax().debug_dump(),\n+            &incrementally_reparsed.syntax().debug_dump(),\n         )\n     }\n "}, {"sha": "4d54ae6148d5a0aea1b9c58d90da368a1cef6f17", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 113, "deletions": 63, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "patch": "@@ -6,12 +6,15 @@\n //! The *real* implementation is in the (language-agnostic) `rowan` crate, this\n //! modules just wraps its API.\n \n-use std::{fmt, borrow::Borrow};\n+use std::{\n+    fmt::{self, Write},\n+    borrow::Borrow,\n+};\n \n use rowan::{Types, TransparentNewType};\n \n use crate::{\n-    SmolStr, SyntaxKind, TextRange, SyntaxText,\n+    SmolStr, SyntaxKind, TextRange, SyntaxText, SourceFile, AstNode,\n     syntax_error::SyntaxError,\n };\n \n@@ -24,34 +27,37 @@ impl Types for RaTypes {\n     type RootData = Vec<SyntaxError>;\n }\n \n-pub type GreenNode = rowan::GreenNode<RaTypes>;\n+pub(crate) type GreenNode = rowan::GreenNode<RaTypes>;\n+\n+/// Marker trait for CST and AST nodes\n+pub trait SyntaxNodeWrapper: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>> {}\n+impl<T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>> SyntaxNodeWrapper for T {}\n \n+/// An owning smart pointer for CST or AST node.\n #[derive(PartialEq, Eq, Hash)]\n-pub struct TreeArc<T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>>(\n-    pub(crate) rowan::TreeArc<RaTypes, T>,\n-);\n+pub struct TreeArc<T: SyntaxNodeWrapper>(pub(crate) rowan::TreeArc<RaTypes, T>);\n \n-impl<T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>> Borrow<T> for TreeArc<T> {\n+impl<T: SyntaxNodeWrapper> Borrow<T> for TreeArc<T> {\n     fn borrow(&self) -> &T {\n         &*self\n     }\n }\n \n impl<T> TreeArc<T>\n where\n-    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+    T: SyntaxNodeWrapper,\n {\n     pub(crate) fn cast<U>(this: TreeArc<T>) -> TreeArc<U>\n     where\n-        U: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+        U: SyntaxNodeWrapper,\n     {\n         TreeArc(rowan::TreeArc::cast(this.0))\n     }\n }\n \n impl<T> std::ops::Deref for TreeArc<T>\n where\n-    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+    T: SyntaxNodeWrapper,\n {\n     type Target = T;\n     fn deref(&self) -> &T {\n@@ -61,7 +67,7 @@ where\n \n impl<T> PartialEq<T> for TreeArc<T>\n where\n-    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+    T: SyntaxNodeWrapper,\n     T: PartialEq<T>,\n {\n     fn eq(&self, other: &T) -> bool {\n@@ -72,7 +78,7 @@ where\n \n impl<T> Clone for TreeArc<T>\n where\n-    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+    T: SyntaxNodeWrapper,\n {\n     fn clone(&self) -> TreeArc<T> {\n         TreeArc(self.0.clone())\n@@ -81,7 +87,7 @@ where\n \n impl<T> fmt::Debug for TreeArc<T>\n where\n-    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+    T: SyntaxNodeWrapper,\n     T: fmt::Debug,\n {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n@@ -96,62 +102,35 @@ unsafe impl TransparentNewType for SyntaxNode {\n     type Repr = rowan::SyntaxNode<RaTypes>;\n }\n \n-impl SyntaxNode {\n-    pub(crate) fn new(green: GreenNode, errors: Vec<SyntaxError>) -> TreeArc<SyntaxNode> {\n-        let ptr = TreeArc(rowan::SyntaxNode::new(green, errors));\n+impl ToOwned for SyntaxNode {\n+    type Owned = TreeArc<SyntaxNode>;\n+    fn to_owned(&self) -> TreeArc<SyntaxNode> {\n+        let ptr = TreeArc(self.0.to_owned());\n         TreeArc::cast(ptr)\n     }\n }\n \n+impl fmt::Debug for SyntaxNode {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;\n+        if has_short_text(self.kind()) {\n+            write!(fmt, \" \\\"{}\\\"\", self.text())?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Direction {\n     Next,\n     Prev,\n }\n \n impl SyntaxNode {\n-    pub fn leaf_text(&self) -> Option<&SmolStr> {\n-        self.0.leaf_text()\n-    }\n-    pub fn ancestors(&self) -> impl Iterator<Item = &SyntaxNode> {\n-        crate::algo::generate(Some(self), |&node| node.parent())\n-    }\n-    pub fn descendants(&self) -> impl Iterator<Item = &SyntaxNode> {\n-        self.preorder().filter_map(|event| match event {\n-            WalkEvent::Enter(node) => Some(node),\n-            WalkEvent::Leave(_) => None,\n-        })\n-    }\n-    pub fn siblings(&self, direction: Direction) -> impl Iterator<Item = &SyntaxNode> {\n-        crate::algo::generate(Some(self), move |&node| match direction {\n-            Direction::Next => node.next_sibling(),\n-            Direction::Prev => node.prev_sibling(),\n-        })\n-    }\n-    pub fn preorder(&self) -> impl Iterator<Item = WalkEvent<&SyntaxNode>> {\n-        self.0.preorder().map(|event| match event {\n-            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode::from_repr(n)),\n-            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode::from_repr(n)),\n-        })\n-    }\n-}\n-\n-impl ToOwned for SyntaxNode {\n-    type Owned = TreeArc<SyntaxNode>;\n-    fn to_owned(&self) -> TreeArc<SyntaxNode> {\n-        let ptr = TreeArc(self.0.to_owned());\n+    pub(crate) fn new(green: GreenNode, errors: Vec<SyntaxError>) -> TreeArc<SyntaxNode> {\n+        let ptr = TreeArc(rowan::SyntaxNode::new(green, errors));\n         TreeArc::cast(ptr)\n     }\n-}\n-\n-impl SyntaxNode {\n-    pub(crate) fn root_data(&self) -> &Vec<SyntaxError> {\n-        self.0.root_data()\n-    }\n-\n-    pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n-        self.0.replace_self(replacement)\n-    }\n \n     pub fn kind(&self) -> SyntaxKind {\n         self.0.kind()\n@@ -169,6 +148,10 @@ impl SyntaxNode {\n         self.0.is_leaf()\n     }\n \n+    pub fn leaf_text(&self) -> Option<&SmolStr> {\n+        self.0.leaf_text()\n+    }\n+\n     pub fn parent(&self) -> Option<&SyntaxNode> {\n         self.0.parent().map(SyntaxNode::from_repr)\n     }\n@@ -193,18 +176,85 @@ impl SyntaxNode {\n         SyntaxNodeChildren(self.0.children())\n     }\n \n+    pub fn ancestors(&self) -> impl Iterator<Item = &SyntaxNode> {\n+        crate::algo::generate(Some(self), |&node| node.parent())\n+    }\n+\n+    pub fn descendants(&self) -> impl Iterator<Item = &SyntaxNode> {\n+        self.preorder().filter_map(|event| match event {\n+            WalkEvent::Enter(node) => Some(node),\n+            WalkEvent::Leave(_) => None,\n+        })\n+    }\n+\n+    pub fn siblings(&self, direction: Direction) -> impl Iterator<Item = &SyntaxNode> {\n+        crate::algo::generate(Some(self), move |&node| match direction {\n+            Direction::Next => node.next_sibling(),\n+            Direction::Prev => node.prev_sibling(),\n+        })\n+    }\n+\n+    pub fn preorder(&self) -> impl Iterator<Item = WalkEvent<&SyntaxNode>> {\n+        self.0.preorder().map(|event| match event {\n+            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode::from_repr(n)),\n+            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode::from_repr(n)),\n+        })\n+    }\n+\n     pub fn memory_size_of_subtree(&self) -> usize {\n         self.0.memory_size_of_subtree()\n     }\n-}\n \n-impl fmt::Debug for SyntaxNode {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;\n-        if has_short_text(self.kind()) {\n-            write!(fmt, \" \\\"{}\\\"\", self.text())?;\n+    pub fn debug_dump(&self) -> String {\n+        let mut errors: Vec<_> = match self.ancestors().find_map(SourceFile::cast) {\n+            Some(file) => file.errors(),\n+            None => self.root_data().to_vec(),\n+        };\n+        errors.sort_by_key(|e| e.offset());\n+        let mut err_pos = 0;\n+        let mut level = 0;\n+        let mut buf = String::new();\n+        macro_rules! indent {\n+            () => {\n+                for _ in 0..level {\n+                    buf.push_str(\"  \");\n+                }\n+            };\n         }\n-        Ok(())\n+\n+        for event in self.preorder() {\n+            match event {\n+                WalkEvent::Enter(node) => {\n+                    indent!();\n+                    writeln!(buf, \"{:?}\", node).unwrap();\n+                    if node.first_child().is_none() {\n+                        let off = node.range().end();\n+                        while err_pos < errors.len() && errors[err_pos].offset() <= off {\n+                            indent!();\n+                            writeln!(buf, \"err: `{}`\", errors[err_pos]).unwrap();\n+                            err_pos += 1;\n+                        }\n+                    }\n+                    level += 1;\n+                }\n+                WalkEvent::Leave(_) => level -= 1,\n+            }\n+        }\n+\n+        assert_eq!(level, 0);\n+        for err in errors[err_pos..].iter() {\n+            writeln!(buf, \"err: `{}`\", err).unwrap();\n+        }\n+\n+        buf\n+    }\n+\n+    pub(crate) fn root_data(&self) -> &Vec<SyntaxError> {\n+        self.0.root_data()\n+    }\n+\n+    pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n+        self.0.replace_self(replacement)\n     }\n }\n "}, {"sha": "2e1b42da0f6af6b90d2bb9543623b4733db34638", "filename": "crates/ra_syntax/src/utils.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9be7426aae359d49ef272db74528a706e7f738a0/crates%2Fra_syntax%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be7426aae359d49ef272db74528a706e7f738a0/crates%2Fra_syntax%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Futils.rs?ref=9be7426aae359d49ef272db74528a706e7f738a0", "patch": "@@ -1,83 +0,0 @@\n-use std::{str, fmt::Write};\n-\n-use crate::{SourceFile, SyntaxKind, WalkEvent, AstNode, SyntaxNode};\n-\n-/// Parse a file and create a string representation of the resulting parse tree.\n-pub fn dump_tree(syntax: &SyntaxNode) -> String {\n-    let mut errors: Vec<_> = match syntax.ancestors().find_map(SourceFile::cast) {\n-        Some(file) => file.errors(),\n-        None => syntax.root_data().to_vec(),\n-    };\n-    errors.sort_by_key(|e| e.offset());\n-    let mut err_pos = 0;\n-    let mut level = 0;\n-    let mut buf = String::new();\n-    macro_rules! indent {\n-        () => {\n-            for _ in 0..level {\n-                buf.push_str(\"  \");\n-            }\n-        };\n-    }\n-\n-    for event in syntax.preorder() {\n-        match event {\n-            WalkEvent::Enter(node) => {\n-                indent!();\n-                writeln!(buf, \"{:?}\", node).unwrap();\n-                if node.first_child().is_none() {\n-                    let off = node.range().end();\n-                    while err_pos < errors.len() && errors[err_pos].offset() <= off {\n-                        indent!();\n-                        writeln!(buf, \"err: `{}`\", errors[err_pos]).unwrap();\n-                        err_pos += 1;\n-                    }\n-                }\n-                level += 1;\n-            }\n-            WalkEvent::Leave(_) => level -= 1,\n-        }\n-    }\n-\n-    assert_eq!(level, 0);\n-    for err in errors[err_pos..].iter() {\n-        writeln!(buf, \"err: `{}`\", err).unwrap();\n-    }\n-\n-    buf\n-}\n-\n-pub fn check_fuzz_invariants(text: &str) {\n-    let file = SourceFile::parse(text);\n-    let root = file.syntax();\n-    validate_block_structure(root);\n-    let _ = file.errors();\n-}\n-\n-pub(crate) fn validate_block_structure(root: &SyntaxNode) {\n-    let mut stack = Vec::new();\n-    for node in root.descendants() {\n-        match node.kind() {\n-            SyntaxKind::L_CURLY => stack.push(node),\n-            SyntaxKind::R_CURLY => {\n-                if let Some(pair) = stack.pop() {\n-                    assert_eq!(\n-                        node.parent(),\n-                        pair.parent(),\n-                        \"\\nunpaired curleys:\\n{}\\n{}\\n\",\n-                        root.text(),\n-                        dump_tree(root),\n-                    );\n-                    assert!(\n-                        node.next_sibling().is_none() && pair.prev_sibling().is_none(),\n-                        \"\\nfloating curlys at {:?}\\nfile:\\n{}\\nerror:\\n{}\\n\",\n-                        node,\n-                        root.text(),\n-                        node.text(),\n-                    );\n-                }\n-            }\n-            _ => (),\n-        }\n-    }\n-}"}, {"sha": "69f344d65248afa3868396008cc16f2943919f72", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "patch": "@@ -5,7 +5,8 @@ mod string;\n mod block;\n \n use crate::{\n-    SourceFile, SyntaxError, AstNode,\n+    SourceFile, SyntaxError, AstNode, SyntaxNode,\n+    SyntaxKind::{L_CURLY, R_CURLY},\n     ast,\n     algo::visit::{visitor_ctx, VisitorCtx},\n };\n@@ -14,12 +15,40 @@ pub(crate) fn validate(file: &SourceFile) -> Vec<SyntaxError> {\n     let mut errors = Vec::new();\n     for node in file.syntax().descendants() {\n         let _ = visitor_ctx(&mut errors)\n-            .visit::<ast::Byte, _>(self::byte::validate_byte_node)\n-            .visit::<ast::ByteString, _>(self::byte_string::validate_byte_string_node)\n-            .visit::<ast::Char, _>(self::char::validate_char_node)\n-            .visit::<ast::String, _>(self::string::validate_string_node)\n-            .visit::<ast::Block, _>(self::block::validate_block_node)\n+            .visit::<ast::Byte, _>(byte::validate_byte_node)\n+            .visit::<ast::ByteString, _>(byte_string::validate_byte_string_node)\n+            .visit::<ast::Char, _>(char::validate_char_node)\n+            .visit::<ast::String, _>(string::validate_string_node)\n+            .visit::<ast::Block, _>(block::validate_block_node)\n             .accept(node);\n     }\n     errors\n }\n+\n+pub(crate) fn validate_block_structure(root: &SyntaxNode) {\n+    let mut stack = Vec::new();\n+    for node in root.descendants() {\n+        match node.kind() {\n+            L_CURLY => stack.push(node),\n+            R_CURLY => {\n+                if let Some(pair) = stack.pop() {\n+                    assert_eq!(\n+                        node.parent(),\n+                        pair.parent(),\n+                        \"\\nunpaired curleys:\\n{}\\n{}\\n\",\n+                        root.text(),\n+                        root.debug_dump(),\n+                    );\n+                    assert!(\n+                        node.next_sibling().is_none() && pair.prev_sibling().is_none(),\n+                        \"\\nfloating curlys at {:?}\\nfile:\\n{}\\nerror:\\n{}\\n\",\n+                        node,\n+                        root.text(),\n+                        node.text(),\n+                    );\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}"}, {"sha": "458740c138ed5ebea72a610a1275731f0bb66dc9", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "patch": "@@ -8,10 +8,7 @@ use std::{\n };\n \n use test_utils::{project_dir, dir_tests, read_text, collect_tests};\n-use ra_syntax::{\n-    SourceFile, AstNode,\n-    utils::{check_fuzz_invariants, dump_tree},\n-};\n+use ra_syntax::{SourceFile, AstNode, check_fuzz_invariants};\n \n #[test]\n fn lexer_tests() {\n@@ -32,7 +29,7 @@ fn parser_tests() {\n             \"There should be no errors in the file {:?}\",\n             path.display()\n         );\n-        dump_tree(file.syntax())\n+        file.syntax().debug_dump()\n     });\n     dir_tests(&test_data_dir(), &[\"parser/err\", \"parser/inline/err\"], |text, path| {\n         let file = SourceFile::parse(text);\n@@ -43,7 +40,7 @@ fn parser_tests() {\n             \"There should be errors in the file {:?}\",\n             path.display()\n         );\n-        dump_tree(file.syntax())\n+        file.syntax().debug_dump()\n     });\n }\n "}]}