{"sha": "4bfa3c6663ad6facdbdb8bd533442b050085f753", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZmEzYzY2NjNhZDZmYWNkYmRiOGJkNTMzNDQyYjA1MDA4NWY3NTM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-09T05:31:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-14T05:15:46Z"}, "message": "Add a lint mode for unused unsafe blocks/functions", "tree": {"sha": "ce4e7d841a181baaf8525920ab50eb5179779e3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce4e7d841a181baaf8525920ab50eb5179779e3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bfa3c6663ad6facdbdb8bd533442b050085f753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bfa3c6663ad6facdbdb8bd533442b050085f753", "html_url": "https://github.com/rust-lang/rust/commit/4bfa3c6663ad6facdbdb8bd533442b050085f753", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bfa3c6663ad6facdbdb8bd533442b050085f753/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c2e5cceee6603030a1a96f92be3676d388562e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2e5cceee6603030a1a96f92be3676d388562e3", "html_url": "https://github.com/rust-lang/rust/commit/8c2e5cceee6603030a1a96f92be3676d388562e3"}], "stats": {"total": 294, "additions": 224, "deletions": 70}, "files": [{"sha": "116b70bf7e3200e8afbaba1e6f670b07573a3050", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 86, "deletions": 34, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=4bfa3c6663ad6facdbdb8bd533442b050085f753", "patch": "@@ -33,20 +33,26 @@ use util::ppaux::ty_to_str;\n \n use core::hashmap::HashSet;\n use core::uint;\n+use core::util::with;\n use syntax::ast::m_mutbl;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit;\n \n+struct PurityState {\n+    def: ast::node_id,\n+    purity: ast::purity\n+}\n+\n struct CheckLoanCtxt {\n     bccx: @BorrowckCtxt,\n     req_maps: ReqMaps,\n \n     reported: HashSet<ast::node_id>,\n \n-    declared_purity: @mut ast::purity,\n+    declared_purity: @mut PurityState,\n     fn_args: @mut @~[ast::node_id]\n }\n \n@@ -62,14 +68,25 @@ enum purity_cause {\n     pc_cmt(bckerr)\n }\n \n+// if we're not pure, why?\n+#[deriving(Eq)]\n+enum impurity_cause {\n+    // some surrounding block was marked as 'unsafe'\n+    pc_unsafe,\n+\n+    // nothing was unsafe, and nothing was pure\n+    pc_default,\n+}\n+\n pub fn check_loans(bccx: @BorrowckCtxt,\n                    +req_maps: ReqMaps,\n                    crate: @ast::crate) {\n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n         req_maps: req_maps,\n         reported: HashSet::new(),\n-        declared_purity: @mut ast::impure_fn,\n+        declared_purity: @mut PurityState { purity: ast::impure_fn,\n+                                            def: 0 },\n         fn_args: @mut @~[]\n     };\n     let vt = visit::mk_vt(@visit::Visitor {visit_expr: check_loans_in_expr,\n@@ -106,16 +123,18 @@ pub impl assignment_type {\n pub impl CheckLoanCtxt {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn purity(&mut self, scope_id: ast::node_id) -> Option<purity_cause> {\n-        let default_purity = match *self.declared_purity {\n+    fn purity(&mut self, scope_id: ast::node_id)\n+                -> Either<purity_cause, impurity_cause>\n+    {\n+        let default_purity = match self.declared_purity.purity {\n           // an unsafe declaration overrides all\n-          ast::unsafe_fn => return None,\n+          ast::unsafe_fn => return Right(pc_unsafe),\n \n           // otherwise, remember what was declared as the\n           // default, but we must scan for requirements\n           // imposed by the borrow check\n-          ast::pure_fn => Some(pc_pure_fn),\n-          ast::extern_fn | ast::impure_fn => None\n+          ast::pure_fn => Left(pc_pure_fn),\n+          ast::extern_fn | ast::impure_fn => Right(pc_default)\n         };\n \n         // scan to see if this scope or any enclosing scope requires\n@@ -125,7 +144,7 @@ pub impl CheckLoanCtxt {\n         loop {\n             match self.req_maps.pure_map.find(&scope_id) {\n               None => (),\n-              Some(e) => return Some(pc_cmt(*e))\n+              Some(e) => return Left(pc_cmt(*e))\n             }\n \n             match self.tcx().region_maps.opt_encl_scope(scope_id) {\n@@ -171,7 +190,7 @@ pub impl CheckLoanCtxt {\n     // overloaded operators the callee has an id but no expr.\n     // annoying.\n     fn check_pure_callee_or_arg(&mut self,\n-                                pc: purity_cause,\n+                                pc: Either<purity_cause, impurity_cause>,\n                                 opt_expr: Option<@ast::expr>,\n                                 callee_id: ast::node_id,\n                                 callee_span: span) {\n@@ -196,7 +215,7 @@ pub impl CheckLoanCtxt {\n         match opt_expr {\n           Some(expr) => {\n             match expr.node {\n-              ast::expr_path(_) if pc == pc_pure_fn => {\n+              ast::expr_path(_) if pc == Left(pc_pure_fn) => {\n                 let def = *self.tcx().def_map.get(&expr.id);\n                 let did = ast_util::def_id_of_def(def);\n                 let is_fn_arg =\n@@ -361,10 +380,10 @@ pub impl CheckLoanCtxt {\n         // if this is a pure function, only loan-able state can be\n         // assigned, because it is uniquely tied to this function and\n         // is not visible from the outside\n-        match self.purity(ex.id) {\n-          None => (),\n-          Some(pc_cmt(_)) => {\n-            let purity = self.purity(ex.id).get();\n+        let purity = self.purity(ex.id);\n+        match purity {\n+          Right(_) => (),\n+          Left(pc_cmt(_)) => {\n             // Subtle: Issue #3162.  If we are enforcing purity\n             // because there is a reference to aliasable, mutable data\n             // that we require to be immutable, we can't allow writes\n@@ -376,10 +395,10 @@ pub impl CheckLoanCtxt {\n                 ex.span,\n                 at.ing_form(self.bccx.cmt_to_str(cmt)));\n           }\n-          Some(pc_pure_fn) => {\n+          Left(pc_pure_fn) => {\n             if cmt.lp.is_none() {\n                 self.report_purity_error(\n-                    pc_pure_fn, ex.span,\n+                    purity, ex.span,\n                     at.ing_form(self.bccx.cmt_to_str(cmt)));\n             }\n           }\n@@ -462,14 +481,23 @@ pub impl CheckLoanCtxt {\n         }\n     }\n \n-    fn report_purity_error(&mut self, pc: purity_cause, sp: span, msg: ~str) {\n+    fn report_purity_error(&mut self, pc: Either<purity_cause, impurity_cause>,\n+                           sp: span, msg: ~str) {\n         match pc {\n-          pc_pure_fn => {\n+          Right(pc_default) => { fail!(~\"pc_default should be filtered sooner\") }\n+          Right(pc_unsafe) => {\n+            // this error was prevented by being marked as unsafe, so flag the\n+            // definition as having contributed to the validity of the program\n+            let def = self.declared_purity.def;\n+            debug!(\"flagging %? as a used unsafe source\", def);\n+            self.tcx().used_unsafe.insert(def);\n+          }\n+          Left(pc_pure_fn) => {\n             self.tcx().sess.span_err(\n                 sp,\n                 fmt!(\"%s prohibited in pure context\", msg));\n           }\n-          pc_cmt(ref e) => {\n+          Left(pc_cmt(ref e)) => {\n             if self.reported.insert((*e).cmt.id) {\n                 self.tcx().sess.span_err(\n                     (*e).cmt.span,\n@@ -556,16 +584,32 @@ pub impl CheckLoanCtxt {\n                   callee_id: ast::node_id,\n                   callee_span: span,\n                   args: &[@ast::expr]) {\n-        match self.purity(expr.id) {\n-          None => {}\n-          Some(ref pc) => {\n-            self.check_pure_callee_or_arg(\n-                (*pc), callee, callee_id, callee_span);\n-            for args.each |arg| {\n-                self.check_pure_callee_or_arg(\n-                    (*pc), Some(*arg), arg.id, arg.span);\n+        let pc = self.purity(expr.id);\n+        match pc {\n+            // no purity, no need to check for anything\n+            Right(pc_default) => return,\n+\n+            // some form of purity, definitely need to check\n+            Left(_) => (),\n+\n+            // Unsafe trumped. To see if the unsafe is necessary, see what the\n+            // purity would have been without a trump, and if it's some form\n+            // of purity then we need to go ahead with the check\n+            Right(pc_unsafe) => {\n+                match do with(&mut self.declared_purity.purity,\n+                              ast::impure_fn) { self.purity(expr.id) } {\n+                    Right(pc_unsafe) => fail!(~\"unsafe can't trump twice\"),\n+                    Right(pc_default) => return,\n+                    Left(_) => ()\n+                }\n             }\n-          }\n+\n+        }\n+        self.check_pure_callee_or_arg(\n+            pc, callee, callee_id, callee_span);\n+        for args.each |arg| {\n+            self.check_pure_callee_or_arg(\n+                pc, Some(*arg), arg.id, arg.span);\n         }\n     }\n }\n@@ -580,27 +624,32 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n     let is_stack_closure = self.is_stack_closure(id);\n     let fty = ty::node_id_to_type(self.tcx(), id);\n \n-    let declared_purity;\n+    let declared_purity, src;\n     match *fk {\n         visit::fk_item_fn(*) | visit::fk_method(*) |\n         visit::fk_dtor(*) => {\n             declared_purity = ty::ty_fn_purity(fty);\n+            src = id;\n         }\n \n         visit::fk_anon(*) | visit::fk_fn_block(*) => {\n             let fty_sigil = ty::ty_closure_sigil(fty);\n             check_moves_from_captured_variables(self, id, fty_sigil);\n-            declared_purity = ty::determine_inherited_purity(\n-                *self.declared_purity,\n-                ty::ty_fn_purity(fty),\n+            let pair = ty::determine_inherited_purity(\n+                (self.declared_purity.purity, self.declared_purity.def),\n+                (ty::ty_fn_purity(fty), id),\n                 fty_sigil);\n+            declared_purity = pair.first();\n+            src = pair.second();\n         }\n     }\n \n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n     do save_and_restore_managed(self.declared_purity) {\n         do save_and_restore_managed(self.fn_args) {\n-            *self.declared_purity = declared_purity;\n+            self.declared_purity = @mut PurityState {\n+                purity: declared_purity, def: src\n+            };\n \n             match *fk {\n                 visit::fk_anon(*) |\n@@ -754,7 +803,10 @@ fn check_loans_in_block(blk: &ast::blk,\n           ast::default_blk => {\n           }\n           ast::unsafe_blk => {\n-            *self.declared_purity = ast::unsafe_fn;\n+            *self.declared_purity = PurityState {\n+                purity: ast::unsafe_fn,\n+                def: blk.node.id,\n+            };\n           }\n         }\n "}, {"sha": "876ed76f98741b0bcc848f5507414da86ece0a89", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=4bfa3c6663ad6facdbdb8bd533442b050085f753", "patch": "@@ -75,6 +75,7 @@ pub enum lint {\n     default_methods,\n     deprecated_mutable_fields,\n     deprecated_drop,\n+    unused_unsafe,\n     foreign_mode,\n \n     managed_heap_memory,\n@@ -256,6 +257,13 @@ pub fn get_lint_dict() -> LintDict {\n             default: deny\n         }),\n \n+        (~\"unused_unsafe\",\n+         LintSpec {\n+            lint: unused_unsafe,\n+            desc: \"unnecessary use of an \\\"unsafe\\\" block or function\",\n+            default: warn\n+        }),\n+\n         (~\"unused_variable\",\n          LintSpec {\n             lint: unused_variable,\n@@ -490,6 +498,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_default_methods(cx, i);\n     check_item_deprecated_mutable_fields(cx, i);\n     check_item_deprecated_drop(cx, i);\n+    check_item_unused_unsafe(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -923,19 +932,55 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     }\n }\n \n+fn check_item_unused_unsafe(cx: ty::ctxt, it: @ast::item) {\n+    let visit_expr: @fn(@ast::expr) = |e| {\n+        match e.node {\n+            ast::expr_block(ref blk) if blk.node.rules == ast::unsafe_blk => {\n+                if !cx.used_unsafe.contains(&blk.node.id) {\n+                    cx.sess.span_lint(unused_unsafe, blk.node.id, it.id,\n+                                      blk.span,\n+                                      ~\"unnecessary \\\"unsafe\\\" block\");\n+                }\n+            }\n+            _ => ()\n+        }\n+    };\n+\n+    let visit = item_stopping_visitor(\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_expr: visit_expr,\n+            .. *visit::default_simple_visitor()\n+        }));\n+    visit::visit_item(it, (), visit);\n+}\n+\n fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: &ast::fn_decl,\n             _body: &ast::blk, span: span, id: ast::node_id) {\n     debug!(\"lint check_fn fk=%? id=%?\", fk, id);\n \n-    // don't complain about blocks, since they tend to get their modes\n-    // specified from the outside\n+    // Check for an 'unsafe fn' which doesn't need to be unsafe\n+    match *fk {\n+        visit::fk_item_fn(_, _, ast::unsafe_fn, _) => {\n+            if !tcx.used_unsafe.contains(&id) {\n+                tcx.sess.span_lint(unused_unsafe, id, id, span,\n+                                   ~\"unnecessary \\\"unsafe\\\" function\");\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    // Check for deprecated modes\n     match *fk {\n-      visit::fk_fn_block(*) => { return; }\n-      _ => {}\n+        // don't complain about blocks, since they tend to get their modes\n+        // specified from the outside\n+        visit::fk_fn_block(*) => {}\n+\n+        _ => {\n+            let fn_ty = ty::node_id_to_type(tcx, id);\n+            check_fn_deprecated_modes(tcx, fn_ty, decl, span, id);\n+        }\n     }\n \n-    let fn_ty = ty::node_id_to_type(tcx, id);\n-    check_fn_deprecated_modes(tcx, fn_ty, decl, span, id);\n }\n \n fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: &ast::fn_decl,"}, {"sha": "c9381757d77dc1b32abc3b15ce26753071bd6879", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4bfa3c6663ad6facdbdb8bd533442b050085f753", "patch": "@@ -5212,17 +5212,11 @@ pub impl Resolver {\n                     import_resolution.span != dummy_sp() &&\n                     import_resolution.privacy != Public {\n                 import_resolution.state.warned = true;\n-                match self.unused_import_lint_level(module_) {\n-                    warn => {\n-                        self.session.span_warn(copy import_resolution.span,\n-                                               ~\"unused import\");\n-                    }\n-                    deny | forbid => {\n-                      self.session.span_err(copy import_resolution.span,\n-                                            ~\"unused import\");\n-                    }\n-                    allow => ()\n-                }\n+                let span = import_resolution.span;\n+                self.session.span_lint_level(\n+                    self.unused_import_lint_level(module_),\n+                    span,\n+                    ~\"unused import\");\n             }\n         }\n     }"}, {"sha": "f62e366ebdcaa8432e9996db4616a85e8abdb26f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4bfa3c6663ad6facdbdb8bd533442b050085f753", "patch": "@@ -300,7 +300,11 @@ struct ctxt_ {\n     destructors: @mut HashSet<ast::def_id>,\n \n     // Maps a trait onto a mapping from self-ty to impl\n-    trait_impls: @mut HashMap<ast::def_id, @mut HashMap<t, @Impl>>\n+    trait_impls: @mut HashMap<ast::def_id, @mut HashMap<t, @Impl>>,\n+\n+    // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n+    // present in this set can be warned about.\n+    used_unsafe: @mut HashSet<ast::node_id>,\n }\n \n enum tbox_flag {\n@@ -885,7 +889,8 @@ pub fn mk_ctxt(s: session::Session,\n         supertraits: @mut HashMap::new(),\n         destructor_for_type: @mut HashMap::new(),\n         destructors: @mut HashSet::new(),\n-        trait_impls: @mut HashMap::new()\n+        trait_impls: @mut HashMap::new(),\n+        used_unsafe: @mut HashSet::new(),\n      }\n }\n \n@@ -4309,16 +4314,16 @@ pub fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr) -> uint {\n }\n \n // Determine what purity to check a nested function under\n-pub fn determine_inherited_purity(parent_purity: ast::purity,\n-                                       child_purity: ast::purity,\n-                                       child_sigil: ast::Sigil)\n-                                    -> ast::purity {\n+pub fn determine_inherited_purity(parent: (ast::purity, ast::node_id),\n+                                  child: (ast::purity, ast::node_id),\n+                                  child_sigil: ast::Sigil)\n+                                    -> (ast::purity, ast::node_id) {\n     // If the closure is a stack closure and hasn't had some non-standard\n     // purity inferred for it, then check it under its parent's purity.\n     // Otherwise, use its own\n     match child_sigil {\n-        ast::BorrowedSigil if child_purity == ast::impure_fn => parent_purity,\n-        _ => child_purity\n+        ast::BorrowedSigil if child.first() == ast::impure_fn => parent,\n+        _ => child\n     }\n }\n "}, {"sha": "5ec4c233bc0d24abfa8da3b19a68bb5d87e612c4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4bfa3c6663ad6facdbdb8bd533442b050085f753", "patch": "@@ -179,6 +179,11 @@ pub enum FnKind {\n     Vanilla\n }\n \n+struct PurityState {\n+    purity: ast::purity,\n+    from: ast::node_id,\n+}\n+\n pub struct FnCtxt {\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n@@ -187,7 +192,7 @@ pub struct FnCtxt {\n     ret_ty: ty::t,\n     // Used by loop bodies that return from the outer function\n     indirect_ret_ty: Option<ty::t>,\n-    purity: ast::purity,\n+    ps: PurityState,\n \n     // Sometimes we generate region pointers where the precise region\n     // to use is not known. For example, an expression like `&x.f`\n@@ -238,7 +243,7 @@ pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n     @mut FnCtxt {\n         ret_ty: rty,\n         indirect_ret_ty: None,\n-        purity: ast::pure_fn,\n+        ps: PurityState { purity: ast::pure_fn, from: 0 },\n         region_lb: region_bnd,\n         in_scope_regions: @Nil,\n         fn_kind: Vanilla,\n@@ -265,7 +270,7 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n         ty::ty_bare_fn(ref fn_ty) => {\n             let fcx =\n                 check_fn(ccx, self_info, fn_ty.purity,\n-                         &fn_ty.sig, decl, body, Vanilla,\n+                         &fn_ty.sig, decl, id, body, Vanilla,\n                          @Nil, blank_inherited(ccx));;\n \n             vtable::resolve_in_block(fcx, body);\n@@ -282,6 +287,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 purity: ast::purity,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n+                id: ast::node_id,\n                 body: &ast::blk,\n                 fn_kind: FnKind,\n                 inherited_isr: isr_alist,\n@@ -342,7 +348,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         @mut FnCtxt {\n             ret_ty: ret_ty,\n             indirect_ret_ty: indirect_ret_ty,\n-            purity: purity,\n+            ps: PurityState { purity: purity, from: id },\n             region_lb: body.node.id,\n             in_scope_regions: isr,\n             fn_kind: fn_kind,\n@@ -867,8 +873,12 @@ pub impl FnCtxt {\n     }\n \n     fn require_unsafe(&self, sp: span, op: ~str) {\n-        match self.purity {\n-          ast::unsafe_fn => {/*ok*/}\n+        match self.ps.purity {\n+          ast::unsafe_fn => {\n+            // ok, but flag that we used the source of unsafeness\n+            debug!(\"flagging %? as a used unsafe source\", self.ps.from);\n+            self.tcx().used_unsafe.insert(self.ps.from);\n+          }\n           _ => {\n             self.ccx.tcx.sess.span_err(\n                 sp,\n@@ -1679,12 +1689,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         fcx.write_ty(expr.id, fty);\n \n-        let inherited_purity =\n-            ty::determine_inherited_purity(copy fcx.purity, purity,\n+        let (inherited_purity, id) =\n+            ty::determine_inherited_purity((fcx.ps.purity, fcx.ps.from),\n+                                           (purity, expr.id),\n                                            sigil);\n \n         check_fn(fcx.ccx, None, inherited_purity, &fty_sig,\n-                 decl, body, fn_kind, fcx.in_scope_regions, fcx.inh);\n+                 decl, id, body, fn_kind, fcx.in_scope_regions, fcx.inh);\n     }\n \n \n@@ -2923,8 +2934,11 @@ pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n                                  blk: &ast::blk,\n                                  expected: Option<ty::t>) {\n     let fcx = match blk.node.rules {\n-      ast::unsafe_blk => @mut FnCtxt {purity: ast::unsafe_fn,.. copy *fcx0},\n-      ast::default_blk => fcx0\n+        ast::unsafe_blk => @mut FnCtxt {\n+            ps: PurityState { purity: ast::unsafe_fn, from: blk.node.id },\n+            .. copy *fcx0\n+        },\n+        ast::default_blk => fcx0\n     };\n     do fcx.with_region_lb(blk.node.id) {\n         let mut warned = false;"}, {"sha": "368a0fbe9bece41a947613307e696db4a6f983fc", "filename": "src/test/compile-fail/unused-unsafe.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Ftest%2Fcompile-fail%2Funused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfa3c6663ad6facdbdb8bd533442b050085f753/src%2Ftest%2Fcompile-fail%2Funused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-unsafe.rs?ref=4bfa3c6663ad6facdbdb8bd533442b050085f753", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Exercise the unused_unsafe attribute in some positive and negative cases\n+\n+#[deny(unused_unsafe)];\n+\n+use core::libc;\n+\n+fn callback<T>(_f: &fn() -> T) -> T { fail!() }\n+\n+fn bad1() { unsafe {} }                  //~ ERROR: unnecessary \"unsafe\" block\n+fn bad2() { unsafe { bad1() } }          //~ ERROR: unnecessary \"unsafe\" block\n+unsafe fn bad3() {}                      //~ ERROR: unnecessary \"unsafe\" function\n+unsafe fn bad4() { unsafe {} }           //~ ERROR: unnecessary \"unsafe\" function\n+                                         //~^ ERROR: unnecessary \"unsafe\" block\n+fn bad5() { unsafe { do callback {} } }  //~ ERROR: unnecessary \"unsafe\" block\n+\n+unsafe fn good0() { libc::exit(1) }\n+fn good1() { unsafe { libc::exit(1) } }\n+fn good2() {\n+    /* bug uncovered when implementing warning about unused unsafe blocks. Be\n+       sure that when purity is inherited that the source of the unsafe-ness\n+       is tracked correctly */\n+    unsafe {\n+        unsafe fn what() -> ~[~str] { libc::exit(2) }\n+\n+        do callback {\n+            what();\n+        }\n+    }\n+}\n+\n+#[allow(unused_unsafe)] unsafe fn allowed0() {}\n+#[allow(unused_unsafe)] fn allowed1() { unsafe {} }\n+\n+fn main() { }"}]}