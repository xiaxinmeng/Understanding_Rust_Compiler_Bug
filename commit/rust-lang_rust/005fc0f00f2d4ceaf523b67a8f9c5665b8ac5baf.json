{"sha": "005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "node_id": "C_kwDOAAsO6NoAKDAwNWZjMGYwMGYyZDRjZWFmNTIzYjY3YThmOWM1NjY1YjhhYzViYWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-21T14:18:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-21T14:18:17Z"}, "message": "Auto merge of #106977 - michaelwoerister:unord_id_collections, r=oli-obk\n\nUse UnordMap and UnordSet for id collections (DefIdMap, LocalDefIdMap, etc)\n\nThis PR changes the `rustc_data_structures::define_id_collections!` macro to use `UnordMap` and `UnordSet` instead of `FxHashMap` and `FxHashSet`. This should account for a large portion of hash-maps being used in places where they can cause trouble.\n\nThe changes required are moderate but non-zero:\n- In some places the collections are extracted into sorted vecs.\n- There are a few instances where for-loops have been changed to extends.\n\n~~Let's see what the performance impact is. With a bit more refactoring, we might be able to get rid of some of the additional sorting -- but the change set is already big enough. Unless there's a performance impact, I'd like to do further changes in subsequent PRs.~~\n\nPerformance does not seem to be negatively affected ([perf-run here](https://github.com/rust-lang/rust/pull/106977#issuecomment-1396776699)).\n\nPart of [MCP 533](https://github.com/rust-lang/compiler-team/issues/533).\n\nr? `@ghost`", "tree": {"sha": "aa969088c0dc8aee5e87a1ef814b7a9ba160d832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa969088c0dc8aee5e87a1ef814b7a9ba160d832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "html_url": "https://github.com/rust-lang/rust/commit/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21f683935257713eae8549e8b328367006097053", "url": "https://api.github.com/repos/rust-lang/rust/commits/21f683935257713eae8549e8b328367006097053", "html_url": "https://github.com/rust-lang/rust/commit/21f683935257713eae8549e8b328367006097053"}, {"sha": "f219771961c94f218d23bfab66aa678c48840fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f219771961c94f218d23bfab66aa678c48840fc4", "html_url": "https://github.com/rust-lang/rust/commit/f219771961c94f218d23bfab66aa678c48840fc4"}], "stats": {"total": 513, "additions": 394, "deletions": 119}, "files": [{"sha": "22c61248b7d53275fa3e8a662c93ad7f7ae83775", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -8,7 +8,7 @@ use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefIdSet;\n+use rustc_hir::def_id::DefId;\n use rustc_llvm::RustString;\n use rustc_middle::bug;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n@@ -291,7 +291,7 @@ fn add_unused_functions(cx: &CodegenCx<'_, '_>) {\n \n     let ignore_unused_generics = tcx.sess.instrument_coverage_except_unused_generics();\n \n-    let eligible_def_ids: DefIdSet = tcx\n+    let eligible_def_ids: Vec<DefId> = tcx\n         .mir_keys(())\n         .iter()\n         .filter_map(|local_def_id| {\n@@ -317,7 +317,9 @@ fn add_unused_functions(cx: &CodegenCx<'_, '_>) {\n \n     let codegenned_def_ids = tcx.codegened_and_inlined_items(());\n \n-    for &non_codegenned_def_id in eligible_def_ids.difference(codegenned_def_ids) {\n+    for non_codegenned_def_id in\n+        eligible_def_ids.into_iter().filter(|id| !codegenned_def_ids.contains(id))\n+    {\n         let codegen_fn_attrs = tcx.codegen_fn_attrs(non_codegenned_def_id);\n \n         // If a function is marked `#[no_coverage]`, then skip generating a"}, {"sha": "57a99e74c21ade04464f985e4623fa635e1fdddf", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -173,11 +173,15 @@ fn exported_symbols_provider_local(\n         return &[];\n     }\n \n-    let mut symbols: Vec<_> = tcx\n-        .reachable_non_generics(LOCAL_CRATE)\n-        .iter()\n-        .map(|(&def_id, &info)| (ExportedSymbol::NonGeneric(def_id), info))\n-        .collect();\n+    // FIXME: Sorting this is unnecessary since we are sorting later anyway.\n+    //        Can we skip the later sorting?\n+    let mut symbols: Vec<_> = tcx.with_stable_hashing_context(|hcx| {\n+        tcx.reachable_non_generics(LOCAL_CRATE)\n+            .to_sorted(&hcx, true)\n+            .into_iter()\n+            .map(|(&def_id, &info)| (ExportedSymbol::NonGeneric(def_id), info))\n+            .collect()\n+    });\n \n     if tcx.entry_fn(()).is_some() {\n         let exported_symbol ="}, {"sha": "32d3cfe6fc650a2f76a19e9594bd7870ba5a8eeb", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -964,16 +964,19 @@ pub fn provide(providers: &mut Providers) {\n         };\n \n         let (defids, _) = tcx.collect_and_partition_mono_items(cratenum);\n-        for id in &*defids {\n+\n+        let any_for_speed = defids.items().any(|id| {\n             let CodegenFnAttrs { optimize, .. } = tcx.codegen_fn_attrs(*id);\n             match optimize {\n-                attr::OptimizeAttr::None => continue,\n-                attr::OptimizeAttr::Size => continue,\n-                attr::OptimizeAttr::Speed => {\n-                    return for_speed;\n-                }\n+                attr::OptimizeAttr::None | attr::OptimizeAttr::Size => false,\n+                attr::OptimizeAttr::Speed => true,\n             }\n+        });\n+\n+        if any_for_speed {\n+            return for_speed;\n         }\n+\n         tcx.sess.opts.optimize\n     };\n }"}, {"sha": "9fce0e1e65cc90f416fe8fa228a861796a51a5d9", "filename": "compiler/rustc_data_structures/src/fx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -11,8 +11,8 @@ pub type IndexEntry<'a, K, V> = indexmap::map::Entry<'a, K, V>;\n #[macro_export]\n macro_rules! define_id_collections {\n     ($map_name:ident, $set_name:ident, $entry_name:ident, $key:ty) => {\n-        pub type $map_name<T> = $crate::fx::FxHashMap<$key, T>;\n-        pub type $set_name = $crate::fx::FxHashSet<$key>;\n+        pub type $map_name<T> = $crate::unord::UnordMap<$key, T>;\n+        pub type $set_name = $crate::unord::UnordSet<$key>;\n         pub type $entry_name<'a, T> = $crate::fx::StdEntry<'a, $key, T>;\n     };\n }"}, {"sha": "f35f18e51cb4e5339dfd8a4b88b9c291ce773256", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "modified", "additions": 233, "deletions": 6, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -6,13 +6,15 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use smallvec::SmallVec;\n use std::{\n     borrow::Borrow,\n+    collections::hash_map::Entry,\n     hash::Hash,\n     iter::{Product, Sum},\n+    ops::Index,\n };\n \n use crate::{\n     fingerprint::Fingerprint,\n-    stable_hasher::{HashStable, StableHasher, ToStableHashKey},\n+    stable_hasher::{HashStable, StableHasher, StableOrd, ToStableHashKey},\n };\n \n /// `UnordItems` is the order-less version of `Iterator`. It only contains methods\n@@ -38,17 +40,17 @@ impl<T, I: Iterator<Item = T>> UnordItems<T, I> {\n     }\n \n     #[inline]\n-    pub fn all<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+    pub fn all<F: Fn(T) -> bool>(mut self, f: F) -> bool {\n         self.0.all(f)\n     }\n \n     #[inline]\n-    pub fn any<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+    pub fn any<F: Fn(T) -> bool>(mut self, f: F) -> bool {\n         self.0.any(f)\n     }\n \n     #[inline]\n-    pub fn filter<U, F: Fn(&T) -> bool>(self, f: F) -> UnordItems<T, impl Iterator<Item = T>> {\n+    pub fn filter<F: Fn(&T) -> bool>(self, f: F) -> UnordItems<T, impl Iterator<Item = T>> {\n         UnordItems(self.0.filter(f))\n     }\n \n@@ -96,6 +98,15 @@ impl<T, I: Iterator<Item = T>> UnordItems<T, I> {\n     pub fn count(self) -> usize {\n         self.0.count()\n     }\n+\n+    #[inline]\n+    pub fn flat_map<U, F, O>(self, f: F) -> UnordItems<O, impl Iterator<Item = O>>\n+    where\n+        U: IntoIterator<Item = O>,\n+        F: Fn(T) -> U,\n+    {\n+        UnordItems(self.0.flat_map(f))\n+    }\n }\n \n impl<'a, T: Clone + 'a, I: Iterator<Item = &'a T>> UnordItems<&'a T, I> {\n@@ -147,6 +158,7 @@ pub struct UnordSet<V: Eq + Hash> {\n }\n \n impl<V: Eq + Hash> Default for UnordSet<V> {\n+    #[inline]\n     fn default() -> Self {\n         Self { inner: FxHashSet::default() }\n     }\n@@ -178,7 +190,16 @@ impl<V: Eq + Hash> UnordSet<V> {\n     }\n \n     #[inline]\n-    pub fn items(&self) -> UnordItems<&V, impl Iterator<Item = &V>> {\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> bool\n+    where\n+        V: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.remove(k)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -187,20 +208,75 @@ impl<V: Eq + Hash> UnordSet<V> {\n         UnordItems(self.inner.into_iter())\n     }\n \n+    /// Returns the items of this set in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `V` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn to_sorted<HCX>(&self, hcx: &HCX, cache_sort_key: bool) -> Vec<&V>\n+    where\n+        V: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.iter(), cache_sort_key, |&x| x)\n+    }\n+\n+    /// Returns the items of this set in stable sort order (as defined by\n+    /// `StableOrd`). This method is much more efficient than\n+    /// `into_sorted` because it does not need to transform keys to their\n+    /// `ToStableHashKey` equivalent.\n+    #[inline]\n+    pub fn to_sorted_stable_ord(&self) -> Vec<V>\n+    where\n+        V: Ord + StableOrd + Copy,\n+    {\n+        let mut items: Vec<V> = self.inner.iter().copied().collect();\n+        items.sort_unstable();\n+        items\n+    }\n+\n+    /// Returns the items of this set in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `V` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn into_sorted<HCX>(self, hcx: &HCX, cache_sort_key: bool) -> Vec<V>\n+    where\n+        V: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.into_iter(), cache_sort_key, |x| x)\n+    }\n+\n     // We can safely extend this UnordSet from a set of unordered values because that\n     // won't expose the internal ordering anywhere.\n     #[inline]\n     pub fn extend<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n         self.inner.extend(items.0)\n     }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.inner.clear();\n+    }\n }\n \n impl<V: Hash + Eq> Extend<V> for UnordSet<V> {\n+    #[inline]\n     fn extend<T: IntoIterator<Item = V>>(&mut self, iter: T) {\n         self.inner.extend(iter)\n     }\n }\n \n+impl<V: Hash + Eq> FromIterator<V> for UnordSet<V> {\n+    #[inline]\n+    fn from_iter<T: IntoIterator<Item = V>>(iter: T) -> Self {\n+        UnordSet { inner: FxHashSet::from_iter(iter) }\n+    }\n+}\n+\n impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordSet<V> {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n@@ -223,17 +299,33 @@ pub struct UnordMap<K: Eq + Hash, V> {\n }\n \n impl<K: Eq + Hash, V> Default for UnordMap<K, V> {\n+    #[inline]\n     fn default() -> Self {\n         Self { inner: FxHashMap::default() }\n     }\n }\n \n impl<K: Hash + Eq, V> Extend<(K, V)> for UnordMap<K, V> {\n+    #[inline]\n     fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         self.inner.extend(iter)\n     }\n }\n \n+impl<K: Hash + Eq, V> FromIterator<(K, V)> for UnordMap<K, V> {\n+    #[inline]\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> Self {\n+        UnordMap { inner: FxHashMap::from_iter(iter) }\n+    }\n+}\n+\n+impl<K: Hash + Eq, V, I: Iterator<Item = (K, V)>> From<UnordItems<(K, V), I>> for UnordMap<K, V> {\n+    #[inline]\n+    fn from(items: UnordItems<(K, V), I>) -> Self {\n+        UnordMap { inner: FxHashMap::from_iter(items.0) }\n+    }\n+}\n+\n impl<K: Eq + Hash, V> UnordMap<K, V> {\n     #[inline]\n     pub fn len(&self) -> usize {\n@@ -255,7 +347,44 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n     }\n \n     #[inline]\n-    pub fn items(&self) -> UnordItems<(&K, &V), impl Iterator<Item = (&K, &V)>> {\n+    pub fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n+\n+    #[inline]\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n+        self.inner.entry(key)\n+    }\n+\n+    #[inline]\n+    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.get(k)\n+    }\n+\n+    #[inline]\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.get_mut(k)\n+    }\n+\n+    #[inline]\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.remove(k)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<(&'a K, &'a V), impl Iterator<Item = (&'a K, &'a V)>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -270,6 +399,77 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n     pub fn extend<I: Iterator<Item = (K, V)>>(&mut self, items: UnordItems<(K, V), I>) {\n         self.inner.extend(items.0)\n     }\n+\n+    /// Returns the entries of this map in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `K` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn to_sorted<HCX>(&self, hcx: &HCX, cache_sort_key: bool) -> Vec<(&K, &V)>\n+    where\n+        K: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.iter(), cache_sort_key, |&(k, _)| k)\n+    }\n+\n+    /// Returns the entries of this map in stable sort order (as defined by `StableOrd`).\n+    /// This method can be much more efficient than `into_sorted` because it does not need\n+    /// to transform keys to their `ToStableHashKey` equivalent.\n+    #[inline]\n+    pub fn to_sorted_stable_ord(&self) -> Vec<(K, &V)>\n+    where\n+        K: Ord + StableOrd + Copy,\n+    {\n+        let mut items: Vec<(K, &V)> = self.inner.iter().map(|(&k, v)| (k, v)).collect();\n+        items.sort_unstable_by_key(|&(k, _)| k);\n+        items\n+    }\n+\n+    /// Returns the entries of this map in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `K` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn into_sorted<HCX>(self, hcx: &HCX, cache_sort_key: bool) -> Vec<(K, V)>\n+    where\n+        K: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.into_iter(), cache_sort_key, |(k, _)| k)\n+    }\n+\n+    /// Returns the values of this map in stable sort order (as defined by K's\n+    /// `ToStableHashKey` implementation).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `K` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn values_sorted<HCX>(&self, hcx: &HCX, cache_sort_key: bool) -> impl Iterator<Item = &V>\n+    where\n+        K: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.iter(), cache_sort_key, |&(k, _)| k)\n+            .into_iter()\n+            .map(|(_, v)| v)\n+    }\n+}\n+\n+impl<K, Q: ?Sized, V> Index<&Q> for UnordMap<K, V>\n+where\n+    K: Eq + Hash + Borrow<Q>,\n+    Q: Eq + Hash,\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, key: &Q) -> &V {\n+        &self.inner[key]\n+    }\n }\n \n impl<HCX, K: Hash + Eq + HashStable<HCX>, V: HashStable<HCX>> HashStable<HCX> for UnordMap<K, V> {\n@@ -334,13 +534,40 @@ impl<T> Extend<T> for UnordBag<T> {\n     }\n }\n \n+impl<T, I: Iterator<Item = T>> From<UnordItems<T, I>> for UnordBag<T> {\n+    fn from(value: UnordItems<T, I>) -> Self {\n+        UnordBag { inner: Vec::from_iter(value.0) }\n+    }\n+}\n+\n impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordBag<V> {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n     }\n }\n \n+#[inline]\n+fn to_sorted_vec<HCX, T, K, I>(\n+    hcx: &HCX,\n+    iter: I,\n+    cache_sort_key: bool,\n+    extract_key: fn(&T) -> &K,\n+) -> Vec<T>\n+where\n+    I: Iterator<Item = T>,\n+    K: ToStableHashKey<HCX>,\n+{\n+    let mut items: Vec<T> = iter.collect();\n+    if cache_sort_key {\n+        items.sort_by_cached_key(|x| extract_key(x).to_stable_hash_key(hcx));\n+    } else {\n+        items.sort_unstable_by_key(|x| extract_key(x).to_stable_hash_key(hcx));\n+    }\n+\n+    items\n+}\n+\n fn hash_iter_order_independent<\n     HCX,\n     T: HashStable<HCX>,"}, {"sha": "a17edb598ad5e5eb79d86072571bbc55fda8c2c3", "filename": "compiler/rustc_hir_analysis/src/variance/solve.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -5,8 +5,7 @@\n //! optimal solution to the constraints. The final variance for each\n //! inferred is then written into the `variance_map` in the tcx.\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::DefIdMap;\n use rustc_middle::ty;\n \n use super::constraints::*;\n@@ -89,14 +88,12 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn create_map(&self) -> FxHashMap<DefId, &'tcx [ty::Variance]> {\n+    fn create_map(&self) -> DefIdMap<&'tcx [ty::Variance]> {\n         let tcx = self.terms_cx.tcx;\n \n         let solutions = &self.solutions;\n-        self.terms_cx\n-            .inferred_starts\n-            .iter()\n-            .map(|(&def_id, &InferredIndex(start))| {\n+        DefIdMap::from(self.terms_cx.inferred_starts.items().map(\n+            |(&def_id, &InferredIndex(start))| {\n                 let generics = tcx.generics_of(def_id);\n                 let count = generics.count();\n \n@@ -115,8 +112,8 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 }\n \n                 (def_id.to_def_id(), &*variances)\n-            })\n-            .collect()\n+            },\n+        ))\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "250f4cd3f65fbf4c857e3b3366fa56148f699f54", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -448,8 +448,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (id, origin) in fcx_typeck_results.closure_kind_origins().iter() {\n-            let hir_id = hir::HirId { owner: common_hir_owner, local_id: *id };\n+        let fcx_closure_kind_origins =\n+            fcx_typeck_results.closure_kind_origins().items_in_stable_order();\n+\n+        for (local_id, origin) in fcx_closure_kind_origins {\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let place_span = origin.0;\n             let place = self.resolve(origin.1.clone(), &place_span);\n             self.typeck_results.closure_kind_origins_mut().insert(hir_id, (place_span, place));\n@@ -458,11 +461,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_coercion_casts(&mut self) {\n         let fcx_typeck_results = self.fcx.typeck_results.borrow();\n-        let fcx_coercion_casts = fcx_typeck_results.coercion_casts();\n+\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n \n+        let fcx_coercion_casts = fcx_typeck_results.coercion_casts().to_sorted_stable_ord();\n         for local_id in fcx_coercion_casts {\n-            self.typeck_results.set_coercion_cast(*local_id);\n+            self.typeck_results.set_coercion_cast(local_id);\n         }\n     }\n \n@@ -471,22 +475,15 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        let mut errors_buffer = Vec::new();\n-        for (&local_id, c_ty) in fcx_typeck_results.user_provided_types().iter() {\n-            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n-\n-            if cfg!(debug_assertions) && c_ty.needs_infer() {\n-                span_bug!(\n-                    hir_id.to_span(self.fcx.tcx),\n-                    \"writeback: `{:?}` has inference variables\",\n-                    c_ty\n-                );\n-            };\n+        if self.rustc_dump_user_substs {\n+            let sorted_user_provided_types =\n+                fcx_typeck_results.user_provided_types().items_in_stable_order();\n \n-            self.typeck_results.user_provided_types_mut().insert(hir_id, *c_ty);\n+            let mut errors_buffer = Vec::new();\n+            for (local_id, c_ty) in sorted_user_provided_types {\n+                let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n-            if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n-                if self.rustc_dump_user_substs {\n+                if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n                     // This is a unit-testing mechanism.\n                     let span = self.tcx().hir().span(hir_id);\n                     // We need to buffer the errors in order to guarantee a consistent\n@@ -498,31 +495,49 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     err.buffer(&mut errors_buffer);\n                 }\n             }\n-        }\n \n-        if !errors_buffer.is_empty() {\n-            errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n-            for mut diag in errors_buffer {\n-                self.tcx().sess.diagnostic().emit_diagnostic(&mut diag);\n+            if !errors_buffer.is_empty() {\n+                errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n+                for mut diag in errors_buffer {\n+                    self.tcx().sess.diagnostic().emit_diagnostic(&mut diag);\n+                }\n             }\n         }\n+\n+        self.typeck_results.user_provided_types_mut().extend(\n+            fcx_typeck_results.user_provided_types().items().map(|(local_id, c_ty)| {\n+                let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n+\n+                if cfg!(debug_assertions) && c_ty.needs_infer() {\n+                    span_bug!(\n+                        hir_id.to_span(self.fcx.tcx),\n+                        \"writeback: `{:?}` has inference variables\",\n+                        c_ty\n+                    );\n+                };\n+\n+                (hir_id, *c_ty)\n+            }),\n+        );\n     }\n \n     fn visit_user_provided_sigs(&mut self) {\n         let fcx_typeck_results = self.fcx.typeck_results.borrow();\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n \n-        for (&def_id, c_sig) in fcx_typeck_results.user_provided_sigs.iter() {\n-            if cfg!(debug_assertions) && c_sig.needs_infer() {\n-                span_bug!(\n-                    self.fcx.tcx.def_span(def_id),\n-                    \"writeback: `{:?}` has inference variables\",\n-                    c_sig\n-                );\n-            };\n-\n-            self.typeck_results.user_provided_sigs.insert(def_id, *c_sig);\n-        }\n+        self.typeck_results.user_provided_sigs.extend(\n+            fcx_typeck_results.user_provided_sigs.items().map(|(&def_id, c_sig)| {\n+                if cfg!(debug_assertions) && c_sig.needs_infer() {\n+                    span_bug!(\n+                        self.fcx.tcx.def_span(def_id),\n+                        \"writeback: `{:?}` has inference variables\",\n+                        c_sig\n+                    );\n+                };\n+\n+                (def_id, *c_sig)\n+            }),\n+        );\n     }\n \n     fn visit_generator_interior_types(&mut self) {\n@@ -641,7 +656,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&local_id, &fn_sig) in fcx_typeck_results.liberated_fn_sigs().iter() {\n+        let fcx_liberated_fn_sigs = fcx_typeck_results.liberated_fn_sigs().items_in_stable_order();\n+\n+        for (local_id, &fn_sig) in fcx_liberated_fn_sigs {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n             self.typeck_results.liberated_fn_sigs_mut().insert(hir_id, fn_sig);\n@@ -653,7 +670,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&local_id, ftys) in fcx_typeck_results.fru_field_types().iter() {\n+        let fcx_fru_field_types = fcx_typeck_results.fru_field_types().items_in_stable_order();\n+\n+        for (local_id, ftys) in fcx_fru_field_types {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let ftys = self.resolve(ftys.clone(), &hir_id);\n             self.typeck_results.fru_field_types_mut().insert(hir_id, ftys);"}, {"sha": "9aca485e502e663c58c5ce879b1ca5c0d62c87be", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -6,8 +6,9 @@\n extern crate rustc_macros;\n \n pub use self::Level::*;\n-use rustc_ast::node_id::{NodeId, NodeMap};\n+use rustc_ast::node_id::NodeId;\n use rustc_ast::{AttrId, Attribute};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_error_messages::{DiagnosticMessage, MultiSpan};\n use rustc_hir::HashStableContext;\n@@ -544,7 +545,7 @@ pub struct BufferedEarlyLint {\n \n #[derive(Default)]\n pub struct LintBuffer {\n-    pub map: NodeMap<Vec<BufferedEarlyLint>>,\n+    pub map: FxIndexMap<NodeId, Vec<BufferedEarlyLint>>,\n }\n \n impl LintBuffer {"}, {"sha": "6fd5bd52abe284c008654aee3b8272600f4199ff", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -391,7 +391,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             // keys from the former.\n             // This is a rudimentary check that does not catch all cases,\n             // just the easiest.\n-            let mut fallback_map: DefIdMap<DefId> = Default::default();\n+            let mut fallback_map: Vec<(DefId, DefId)> = Default::default();\n \n             // Issue 46112: We want the map to prefer the shortest\n             // paths when reporting the path to an item. Therefore we\n@@ -421,12 +421,12 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n \n                 if let Some(def_id) = child.res.opt_def_id() {\n                     if child.ident.name == kw::Underscore {\n-                        fallback_map.insert(def_id, parent);\n+                        fallback_map.push((def_id, parent));\n                         return;\n                     }\n \n                     if ty::util::is_doc_hidden(tcx, parent) {\n-                        fallback_map.insert(def_id, parent);\n+                        fallback_map.push((def_id, parent));\n                         return;\n                     }\n \n@@ -460,6 +460,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             // Fill in any missing entries with the less preferable path.\n             // If this path re-exports the child as `_`, we still use this\n             // path in a diagnostic that suggests importing `::*`.\n+\n             for (child, parent) in fallback_map {\n                 visible_parent_map.entry(child).or_insert(parent);\n             }"}, {"sha": "8f7a61b72f81a2cebb7408b11ab2904e17563adf", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -1187,8 +1187,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n         }\n-        let inherent_impls = tcx.crate_inherent_impls(());\n-        for (def_id, implementations) in inherent_impls.inherent_impls.iter() {\n+        let inherent_impls = tcx.with_stable_hashing_context(|hcx| {\n+            tcx.crate_inherent_impls(()).inherent_impls.to_sorted(&hcx, true)\n+        });\n+\n+        for (def_id, implementations) in inherent_impls {\n             if implementations.is_empty() {\n                 continue;\n             }"}, {"sha": "7dfcd1bb5074d50863784d5168ca751851dcdd57", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -38,7 +38,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LocalDefIdMap};\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n@@ -436,7 +436,7 @@ pub struct CrateVariancesMap<'tcx> {\n     /// For each item with generics, maps to a vector of the variance\n     /// of its generics. If an item has no generics, it will have no\n     /// entry.\n-    pub variances: FxHashMap<DefId, &'tcx [ty::Variance]>,\n+    pub variances: DefIdMap<&'tcx [ty::Variance]>,\n }\n \n // Contains information needed to resolve types and (in the future) look up"}, {"sha": "2902c6dc556e4140594243d2507e011055bab13a", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -6,7 +6,12 @@ use crate::{\n         GenericArgKind, InternalSubsts, SubstsRef, Ty, UserSubsts,\n     },\n };\n-use rustc_data_structures::{fx::FxHashMap, sync::Lrc, unord::UnordSet, vec_map::VecMap};\n+use rustc_data_structures::{\n+    fx::FxHashMap,\n+    sync::Lrc,\n+    unord::{UnordItems, UnordSet},\n+    vec_map::VecMap,\n+};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::{\n@@ -20,11 +25,7 @@ use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n use rustc_session::Session;\n use rustc_span::Span;\n-use std::{\n-    collections::hash_map::{self, Entry},\n-    hash::Hash,\n-    iter,\n-};\n+use std::{collections::hash_map::Entry, hash::Hash, iter};\n \n use super::RvalueScopes;\n \n@@ -567,8 +568,15 @@ impl<'a, V> LocalTableInContext<'a, V> {\n         self.data.get(&id.local_id)\n     }\n \n-    pub fn iter(&self) -> hash_map::Iter<'_, hir::ItemLocalId, V> {\n-        self.data.iter()\n+    pub fn items(\n+        &'a self,\n+    ) -> UnordItems<(hir::ItemLocalId, &'a V), impl Iterator<Item = (hir::ItemLocalId, &'a V)>>\n+    {\n+        self.data.items().map(|(id, value)| (*id, value))\n+    }\n+\n+    pub fn items_in_stable_order(&self) -> Vec<(ItemLocalId, &'a V)> {\n+        self.data.to_sorted_stable_ord()\n     }\n }\n \n@@ -605,6 +613,16 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n         validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.remove(&id.local_id)\n     }\n+\n+    pub fn extend(\n+        &mut self,\n+        items: UnordItems<(hir::HirId, V), impl Iterator<Item = (hir::HirId, V)>>,\n+    ) {\n+        self.data.extend(items.map(|(id, value)| {\n+            validate_hir_id_for_typeck_results(self.hir_owner, id);\n+            (id.local_id, value)\n+        }))\n+    }\n }\n \n rustc_index::newtype_index! {"}, {"sha": "eae4c9992eb08d4a6c31118b0fb73abf8d5ce2ea", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -28,9 +28,9 @@ use crate::module_to_string;\n use crate::Resolver;\n \n use rustc_ast as ast;\n-use rustc_ast::node_id::NodeMap;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{pluralize, MultiSpan};\n use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -40,7 +40,7 @@ struct UnusedImport<'a> {\n     use_tree: &'a ast::UseTree,\n     use_tree_id: ast::NodeId,\n     item_span: Span,\n-    unused: FxHashSet<ast::NodeId>,\n+    unused: UnordSet<ast::NodeId>,\n }\n \n impl<'a> UnusedImport<'a> {\n@@ -52,7 +52,7 @@ impl<'a> UnusedImport<'a> {\n struct UnusedImportCheckVisitor<'a, 'b> {\n     r: &'a mut Resolver<'b>,\n     /// All the (so far) unused imports, grouped path list\n-    unused_imports: NodeMap<UnusedImport<'a>>,\n+    unused_imports: FxIndexMap<ast::NodeId, UnusedImport<'a>>,\n     base_use_tree: Option<&'a ast::UseTree>,\n     base_id: ast::NodeId,\n     item_span: Span,\n@@ -89,7 +89,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n             use_tree,\n             use_tree_id,\n             item_span,\n-            unused: FxHashSet::default(),\n+            unused: Default::default(),\n         })\n     }\n }"}, {"sha": "e9b2e31a769ad5a216a3375d9be6a52f9e4f2e24", "filename": "src/tools/clippy/clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -52,21 +52,19 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n         // List of spans to lint. (lint_span, first_span)\n         let mut lint_spans = Vec::new();\n \n-        for (_, impl_ids) in cx\n+        let inherent_impls = cx\n             .tcx\n-            .crate_inherent_impls(())\n-            .inherent_impls\n-            .iter()\n-            .filter(|(&id, impls)| {\n-                impls.len() > 1\n-                    // Check for `#[allow]` on the type definition\n-                    && !is_lint_allowed(\n-                        cx,\n-                        MULTIPLE_INHERENT_IMPL,\n-                        cx.tcx.hir().local_def_id_to_hir_id(id),\n-                    )\n-            })\n-        {\n+            .with_stable_hashing_context(|hcx| cx.tcx.crate_inherent_impls(()).inherent_impls.to_sorted(&hcx, true));\n+\n+        for (_, impl_ids) in inherent_impls.into_iter().filter(|(&id, impls)| {\n+            impls.len() > 1\n+            // Check for `#[allow]` on the type definition\n+            && !is_lint_allowed(\n+                cx,\n+                MULTIPLE_INHERENT_IMPL,\n+                cx.tcx.hir().local_def_id_to_hir_id(id),\n+            )\n+        }) {\n             for impl_id in impl_ids.iter().map(|id| id.expect_local()) {\n                 match type_map.entry(cx.tcx.type_of(impl_id)) {\n                     Entry::Vacant(e) => {"}, {"sha": "3c70c9cf19a516ccdc00d91ef97324d6a86b5682", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -219,7 +219,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         let is_empty = sym!(is_empty);\n \n         let is_empty_method_found = current_and_super_traits\n-            .iter()\n+            .items()\n             .flat_map(|&i| cx.tcx.associated_items(i).filter_by_name_unhygienic(is_empty))\n             .any(|i| {\n                 i.kind == ty::AssocKind::Fn"}, {"sha": "d1a1f773f87b3b0878b83ab05a261a8ea89ab4c9", "filename": "src/tools/clippy/clippy_lints/src/loops/while_immutable_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -35,7 +35,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'\n         } else {\n             return;\n         };\n-    let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n+    let mutable_static_in_cond = var_visitor.def_ids.items().any(|(_, v)| *v);\n \n     let mut has_break_or_return_visitor = HasBreakOrReturnVisitor {\n         has_break_or_return: false,"}, {"sha": "3371b4cce32c1fa265b21ab0c207c6d5d8742a99", "filename": "src/tools/clippy/clippy_lints/src/missing_trait_methods.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_trait_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_trait_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_trait_methods.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -80,19 +80,21 @@ impl<'tcx> LateLintPass<'tcx> for MissingTraitMethods {\n                 }\n             }\n \n-            for assoc in provided.values() {\n-                let source_map = cx.tcx.sess.source_map();\n-                let definition_span = source_map.guess_head_span(cx.tcx.def_span(assoc.def_id));\n+            cx.tcx.with_stable_hashing_context(|hcx| {\n+                for assoc in provided.values_sorted(&hcx, true) {\n+                    let source_map = cx.tcx.sess.source_map();\n+                    let definition_span = source_map.guess_head_span(cx.tcx.def_span(assoc.def_id));\n \n-                span_lint_and_help(\n-                    cx,\n-                    MISSING_TRAIT_METHODS,\n-                    source_map.guess_head_span(item.span),\n-                    &format!(\"missing trait method provided by default: `{}`\", assoc.name),\n-                    Some(definition_span),\n-                    \"implement the method\",\n-                );\n-            }\n+                    span_lint_and_help(\n+                        cx,\n+                        MISSING_TRAIT_METHODS,\n+                        source_map.guess_head_span(item.span),\n+                        &format!(\"missing trait method provided by default: `{}`\", assoc.name),\n+                        Some(definition_span),\n+                        \"implement the method\",\n+                    );\n+                }\n+            })\n         }\n     }\n }"}, {"sha": "2d21aaa4f7fdb5606f560763c8e00dcac0a8ab93", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "patch": "@@ -190,10 +190,10 @@ impl<'tcx> PassByRefOrValue {\n                             // Don't lint if an unsafe pointer is created.\n                             // TODO: Limit the check only to unsafe pointers to the argument (or part of the argument)\n                             //       which escape the current function.\n-                            if typeck.node_types().iter().any(|(_, &ty)| ty.is_unsafe_ptr())\n+                            if typeck.node_types().items().any(|(_, &ty)| ty.is_unsafe_ptr())\n                                 || typeck\n                                     .adjustments()\n-                                    .iter()\n+                                    .items()\n                                     .flat_map(|(_, a)| a)\n                                     .any(|a| matches!(a.kind, Adjust::Pointer(PointerCast::UnsafeFnPointer)))\n                             {"}]}