{"sha": "7669032dd377d6207c4d78e52c9e858e2f2d4180", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NjkwMzJkZDM3N2Q2MjA3YzRkNzhlNTJjOWU4NThlMmYyZDQxODA=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-08-25T00:41:16Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-08-25T01:20:16Z"}, "message": "Remove the old syntax extension section in the documentation.", "tree": {"sha": "b144fbcfdaac76a4c1612ff55e9ce21738bac47e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b144fbcfdaac76a4c1612ff55e9ce21738bac47e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7669032dd377d6207c4d78e52c9e858e2f2d4180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7669032dd377d6207c4d78e52c9e858e2f2d4180", "html_url": "https://github.com/rust-lang/rust/commit/7669032dd377d6207c4d78e52c9e858e2f2d4180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7669032dd377d6207c4d78e52c9e858e2f2d4180/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5f0bf922c96054d628bd4bca986726643c799b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5f0bf922c96054d628bd4bca986726643c799b5", "html_url": "https://github.com/rust-lang/rust/commit/d5f0bf922c96054d628bd4bca986726643c799b5"}], "stats": {"total": 86, "additions": 5, "deletions": 81}, "files": [{"sha": "6a7aa55f0ec4c91cb9b31b19b4d7e25806dea703", "filename": "doc/rust.md", "status": "modified", "additions": 5, "deletions": 81, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7669032dd377d6207c4d78e52c9e858e2f2d4180/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/7669032dd377d6207c4d78e52c9e858e2f2d4180/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=7669032dd377d6207c4d78e52c9e858e2f2d4180", "patch": "@@ -469,14 +469,16 @@ include:\n * `include!` : include the Rust expression in the given file\n * `include_str!` : include the contents of the given file as a string\n * `include_bin!` : include the contents of the given file as a binary blob\n+* `error!`, `warn!`, `info!`, `debug!` : provide diagnostic information.\n \n All of the above extensions, with the exception of `proto!`, are expressions\n with values. `proto!` is an item, defining a new name.\n \n ## Macros\n \n User-defined syntax extensions are called \"macros\", and they can be defined\n-with the `macro_rules!` syntax extension.\n+with the `macro_rules!` syntax extension. User-defined macros can currently\n+only be invoked in expression position.\n \n ~~~~ {.ebnf .gram}\n expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')'\n@@ -2325,9 +2327,9 @@ lower levels indicate more-urgent levels of logging. By default, the lowest\n four logging levels (`0_u32 ... 3_u32`) are predefined as the constants\n `error`, `warn`, `info` and `debug` in the `core` library.\n \n-Additionally, the macros `#error`, `#warn`, `#info` and `#debug` are defined\n+Additionally, the macros `error!`, `warn!`, `info!` and `debug!` are defined\n in the default syntax-extension namespace. These expand into calls to the\n-logging facility composed with calls to the `#fmt` string formatting\n+logging facility composed with calls to the `fmt!` string formatting\n syntax-extension.\n \n The following examples all produce the same output, logged at the `error`\n@@ -2377,84 +2379,6 @@ use of the knowledge that the condition holds if the program continues to\n execute after the `assert`.\n \n \n-### Syntax extension expressions\n-\n-~~~~~~~~ {.abnf .gram}\n-syntax_ext_expr : '#' ident paren_expr_list ? brace_match ? ;\n-~~~~~~~~\n-\n-Rust provides a notation for _syntax extension_. The notation for invoking\n-a syntax extension is a marked syntactic form that can appear as an expression\n-in the body of a Rust program.\n-\n-After parsing, a syntax-extension invocation is expanded into a Rust\n-expression. The name of the extension determines the translation performed. In\n-future versions of Rust, user-provided syntax extensions aside from macros\n-will be provided via external crates.\n-\n-At present, only a set of built-in syntax extensions, as well as macros\n-introduced inline in source code using the `macro` extension, may be used. The\n-current built-in syntax extensions are:\n-\n-\n-* `fmt` expands into code to produce a formatted string, similar to\n-      `printf` from C.\n-* `env` expands into a string literal containing the value of that\n-      environment variable at compile-time.\n-* `concat_idents` expands into an identifier which is the\n-      concatenation of its arguments.\n-* `ident_to_str` expands into a string literal containing the name of\n-      its argument (which must be a literal).\n-* `log_syntax` causes the compiler to pretty-print its arguments.\n-\n-\n-Finally, `macro` is used to define a new macro. A macro can abstract over\n-second-class Rust concepts that are present in syntax. The arguments to\n-`macro` are pairs (two-element vectors). The pairs consist of an invocation\n-and the syntax to expand into. An example:\n-\n-~~~~~~~~{.xfail-test}\n-#macro([#apply[fn, [args, ...]], fn(args, ...)]);\n-~~~~~~~~\n-\n-In this case, the invocation `apply!(sum, 5, 8, 6)` expands to\n-`sum(5,8,6)`. If `...` follows an expression (which need not be as\n-simple as a single identifier) in the input syntax, the matcher will expect an\n-arbitrary number of occurrences of the thing preceding it, and bind syntax to\n-the identifiers it contains. If it follows an expression in the output syntax,\n-it will transcribe that expression repeatedly, according to the identifiers\n-(bound to syntax) that it contains.\n-\n-The behaviour of `...` is known as Macro By Example. It allows you to\n-write a macro with arbitrary repetition by specifying only one case of that\n-repetition, and following it by `...`, both where the repeated input is\n-matched, and where the repeated output must be transcribed. A more\n-sophisticated example:\n-\n-\n-~~~~~~~~{.xfail-test}\n-#macro([#zip_literals[[x, ...], [y, ...]), [[x, y], ...]]);\n-#macro([#unzip_literals[[x, y], ...], [[x, ...], [y, ...]]]);\n-~~~~~~~~\n-\n-In this case, `zip_literals!([1,2,3], [1,2,3])` expands to\n-`[[1,1],[2,2],[3,3]]`, and `unzip_literals!([1,1], [2,2], [3,3])`\n-expands to `[[1,2,3],[1,2,3]]`.\n-\n-Macro expansion takes place outside-in: that is,\n-`unzip_literals!(zip_literals!([1,2,3],[1,2,3]))` will fail because\n-`unzip_literals` expects a list, not a macro invocation, as an argument.\n-\n-The macro system currently has some limitations. It's not possible to\n-destructure anything other than vector literals (therefore, the arguments to\n-complicated macros will tend to be an ocean of square brackets). Macro\n-invocations and `...` can only appear in expression positions. Finally,\n-macro expansion is currently unhygienic. That is, name collisions between\n-macro-generated and user-written code can cause unintentional capture.\n-\n-Future versions of Rust will address these issues.\n-\n-\n # Type system\n \n ## Types"}]}