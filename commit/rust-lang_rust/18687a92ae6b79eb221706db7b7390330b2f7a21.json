{"sha": "18687a92ae6b79eb221706db7b7390330b2f7a21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4Njg3YTkyYWU2Yjc5ZWIyMjE3MDZkYjdiNzM5MDMzMGIyZjdhMjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T22:52:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T22:52:05Z"}, "message": "auto merge of #10649 : sfackler/rust/multi-macro, r=alexcrichton\n\nThe majority of this change is modifying some of the `ast_visit` methods to return multiple values.\r\n\r\nIt's prohibitively expensive to allocate a `~[Foo]` every time a statement, declaration, item, etc is visited, especially since the vast majority will have 0 or 1 elements. I've added a `SmallVector` class that avoids allocation in the 0 and 1 element cases to take care of that.", "tree": {"sha": "aa98b6f6f2366fec615187ea049608a81fba05d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa98b6f6f2366fec615187ea049608a81fba05d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18687a92ae6b79eb221706db7b7390330b2f7a21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18687a92ae6b79eb221706db7b7390330b2f7a21", "html_url": "https://github.com/rust-lang/rust/commit/18687a92ae6b79eb221706db7b7390330b2f7a21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18687a92ae6b79eb221706db7b7390330b2f7a21/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35ebf0348905a3a78025af4019e23ab97c86ec34", "url": "https://api.github.com/repos/rust-lang/rust/commits/35ebf0348905a3a78025af4019e23ab97c86ec34", "html_url": "https://github.com/rust-lang/rust/commit/35ebf0348905a3a78025af4019e23ab97c86ec34"}, {"sha": "c403c1f18e987482a050299a647b0fbcdfea09ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/c403c1f18e987482a050299a647b0fbcdfea09ad", "html_url": "https://github.com/rust-lang/rust/commit/c403c1f18e987482a050299a647b0fbcdfea09ad"}], "stats": {"total": 456, "additions": 328, "deletions": 128}, "files": [{"sha": "ee1935207b17e16c17e36e654a9a87b9480311dc", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -48,14 +48,6 @@ pub fn strip_items(crate: ast::Crate,\n     ctxt.fold_crate(crate)\n }\n \n-fn filter_item(cx: &Context, item: @ast::item) -> Option<@ast::item> {\n-    if item_in_cfg(cx, item) {\n-        Some(item)\n-    } else {\n-        None\n-    }\n-}\n-\n fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n                         -> Option<&'r ast::view_item> {\n     if view_item_in_cfg(cx, view_item) {\n@@ -66,9 +58,10 @@ fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n }\n \n fn fold_mod(cx: &Context, m: &ast::_mod) -> ast::_mod {\n-    let filtered_items = m.items.iter().filter_map(|a| {\n-        filter_item(cx, *a).and_then(|x| cx.fold_item(x))\n-    }).collect();\n+    let filtered_items = m.items.iter()\n+            .filter(|&a| item_in_cfg(cx, *a))\n+            .flat_map(|&x| cx.fold_item(x).move_iter())\n+            .collect();\n     let filtered_view_items = m.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();\n@@ -122,28 +115,25 @@ fn fold_item_underscore(cx: &Context, item: &ast::item_) -> ast::item_ {\n     fold::noop_fold_item_underscore(&item, cx)\n }\n \n-fn filter_stmt(cx: &Context, stmt: @ast::Stmt) -> Option<@ast::Stmt> {\n+fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n     match stmt.node {\n       ast::StmtDecl(decl, _) => {\n         match decl.node {\n           ast::DeclItem(item) => {\n-            if item_in_cfg(cx, item) {\n-                Some(stmt)\n-            } else {\n-                None\n-            }\n+            item_in_cfg(cx, item)\n           }\n-          _ => Some(stmt)\n+          _ => true\n         }\n       }\n-      _ => Some(stmt),\n+      _ => true\n     }\n }\n \n fn fold_block(cx: &Context, b: &ast::Block) -> ast::Block {\n-    let resulting_stmts = b.stmts.iter().filter_map(|a| {\n-        filter_stmt(cx, *a).and_then(|stmt| cx.fold_stmt(stmt))\n-    }).collect();\n+    let resulting_stmts = b.stmts.iter()\n+            .filter(|&a| retain_stmt(cx, *a))\n+            .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())\n+            .collect();\n     let filtered_view_items = b.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();"}, {"sha": "a40f8183e1904200458872664e83d529ecbd642d", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -19,6 +19,7 @@ use syntax::codemap;\n use syntax::fold::ast_fold;\n use syntax::fold;\n use syntax::opt_vec;\n+use syntax::util::small_vector::SmallVector;\n \n static STD_VERSION: &'static str = \"0.9-pre\";\n \n@@ -98,14 +99,14 @@ impl fold::ast_fold for StandardLibraryInjector {\n         }\n     }\n \n-    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n         if !no_prelude(item.attrs) {\n             // only recur if there wasn't `#[no_implicit_prelude];`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree\n             fold::noop_fold_item(item, self)\n         } else {\n-            Some(item)\n+            SmallVector::one(item)\n         }\n     }\n "}, {"sha": "ca82502f84be1cab43d73deb23f8df53fe67bf8b", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -26,6 +26,7 @@ use syntax::fold;\n use syntax::opt_vec;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n+use syntax::util::small_vector::SmallVector;\n \n struct Test {\n     span: Span,\n@@ -76,7 +77,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n         }\n     }\n \n-    fn fold_item(&self, i: @ast::item) -> Option<@ast::item> {\n+    fn fold_item(&self, i: @ast::item) -> SmallVector<@ast::item> {\n         self.cx.path.push(i.ident);\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.clone()));\n@@ -108,7 +109,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n         let res = fold::noop_fold_item(i, self);\n         self.cx.path.pop();\n-        return res;\n+        res\n     }\n \n     fn fold_mod(&self, m: &ast::_mod) -> ast::_mod {"}, {"sha": "64ce1e7b4e7de7d039198f3c3ba15106ee37f0f8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -347,7 +347,8 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n \n     match *ii {\n         //hack: we're not dropping items\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i)\n+                                        .expect_one(\"expected one item\")),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(d, is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n@@ -379,7 +380,8 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n         xcx: xcx,\n     };\n     match ii {\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i)\n+                                        .expect_one(\"expected one item\")),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(xcx.tr_def_id(d), is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i)),"}, {"sha": "ec5922cf67a717c0366c7eeec97e96e9a88feb71", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -22,6 +22,7 @@ use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n use syntax::fold::ast_fold;\n use syntax::visit::Visitor;\n+use syntax::util::small_vector::SmallVector;\n use rustc::back::link::output_type_exe;\n use rustc::back::link;\n use rustc::driver::session::{lib_crate, bin_crate};\n@@ -99,7 +100,7 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n }\n \n fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &CrateSetup)\n-             -> Option<@ast::item> {\n+             -> SmallVector<@ast::item> {\n     ctx.path.push(item.ident);\n \n     let mut cmds = ~[];\n@@ -142,7 +143,7 @@ struct CrateSetup {\n }\n \n impl fold::ast_fold for CrateSetup {\n-    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n         fold_item(self.ctx, item, self)\n     }\n     fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {"}, {"sha": "deaa821cd45f21eefa9757262862d50b947ac75d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -18,6 +18,7 @@ use ext::expand;\n use parse;\n use parse::token;\n use parse::token::{ident_to_str, intern, str_to_ident};\n+use util::small_vector::SmallVector;\n \n use std::hashmap::HashMap;\n \n@@ -131,7 +132,7 @@ pub type SyntaxExpanderTTItemFunNoCtxt =\n \n pub trait AnyMacro {\n     fn make_expr(&self) -> @ast::Expr;\n-    fn make_item(&self) -> Option<@ast::item>;\n+    fn make_items(&self) -> SmallVector<@ast::item>;\n     fn make_stmt(&self) -> @ast::Stmt;\n }\n "}, {"sha": "45f82d9b3a9359cb08d63aa260b0fd62c56c9675", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 48, "deletions": 62, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -28,6 +28,7 @@ use parse::token;\n use parse::token::{fresh_mark, fresh_name, ident_to_str, intern};\n use visit;\n use visit::Visitor;\n+use util::small_vector::SmallVector;\n \n use std::vec;\n \n@@ -310,7 +311,7 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    it: @ast::item,\n                    fld: &MacroExpander)\n-                   -> Option<@ast::item> {\n+                   -> SmallVector<@ast::item> {\n     match it.node {\n         ast::item_mac(*) => expand_item_mac(extsbox, cx, it, fld),\n         ast::item_mod(_) | ast::item_foreign_mod(_) => {\n@@ -337,7 +338,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                        cx: @ExtCtxt,\n                        it: @ast::item,\n                        fld: &MacroExpander)\n-                       -> Option<@ast::item> {\n+                       -> SmallVector<@ast::item> {\n     let (pth, tts, ctxt) = match it.node {\n         item_mac(codemap::Spanned {\n             node: mac_invoc_tt(ref pth, ref tts, ctxt),\n@@ -396,28 +397,30 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             it.span, format!(\"{}! is not legal in item position\", extnamestr))\n     };\n \n-    let maybe_it = match expanded {\n+    let items = match expanded {\n         MRItem(it) => {\n-            mark_item(it,fm)\n-                .and_then(|i| fld.fold_item(i))\n+            mark_item(it,fm).move_iter()\n+                .flat_map(|i| fld.fold_item(i).move_iter())\n+                .collect()\n         }\n         MRExpr(_) => {\n             cx.span_fatal(pth.span, format!(\"expr macro in item position: {}\", extnamestr))\n         }\n         MRAny(any_macro) => {\n-            any_macro.make_item()\n-                     .and_then(|i| mark_item(i,fm))\n-                     .and_then(|i| fld.fold_item(i))\n+            any_macro.make_items().move_iter()\n+                    .flat_map(|i| mark_item(i, fm).move_iter())\n+                    .flat_map(|i| fld.fold_item(i).move_iter())\n+                    .collect()\n         }\n         MRDef(ref mdef) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one.\n             insert_macro(*extsbox,intern(mdef.name), @SE((*mdef).ext));\n-            None\n+            SmallVector::zero()\n         }\n     };\n     cx.bt_pop();\n-    return maybe_it;\n+    return items;\n }\n \n \n@@ -442,7 +445,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    s: &Stmt,\n                    fld: &MacroExpander)\n-                   -> Option<@Stmt> {\n+                   -> SmallVector<@Stmt> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n     let (pth, tts, semi, ctxt) = match s.node {\n@@ -461,7 +464,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n     }\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n-    let fully_expanded: @ast::Stmt = match (*extsbox).find(&extname.name) {\n+    let fully_expanded: SmallVector<@Stmt> = match (*extsbox).find(&extname.name) {\n         None => {\n             cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n         }\n@@ -501,22 +504,15 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             let marked_after = mark_stmt(expanded,fm);\n \n             // Keep going, outside-in.\n-            let fully_expanded = match fld.fold_stmt(marked_after) {\n-                Some(stmt) => {\n-                    let fully_expanded = &stmt.node;\n-                    cx.bt_pop();\n-                    @Spanned {\n-                        span: stmt.span,\n-                        node: (*fully_expanded).clone(),\n-                    }\n-                }\n-                None => {\n-                    cx.span_fatal(pth.span,\n-                                  \"macro didn't expand to a statement\")\n-                }\n-            };\n-\n-            fully_expanded\n+            let fully_expanded = fld.fold_stmt(marked_after);\n+            if fully_expanded.is_empty() {\n+                cx.span_fatal(pth.span,\n+                              \"macro didn't expand to a statement\");\n+            }\n+            cx.bt_pop();\n+            fully_expanded.move_iter()\n+                    .map(|s| @Spanned { span: s.span, node: s.node.clone() })\n+                    .collect()\n         }\n \n         _ => {\n@@ -525,21 +521,23 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n         }\n     };\n \n-    match fully_expanded.node {\n-        StmtExpr(e, stmt_id) if semi => {\n-            Some(@Spanned {\n-                span: fully_expanded.span,\n-                node: StmtSemi(e, stmt_id),\n-            })\n+    fully_expanded.move_iter().map(|s| {\n+        match s.node {\n+            StmtExpr(e, stmt_id) if semi => {\n+                @Spanned {\n+                    span: s.span,\n+                    node: StmtSemi(e, stmt_id)\n+                }\n+            }\n+            _ => s /* might already have a semi */\n         }\n-        _ => Some(fully_expanded), /* might already have a semi */\n-    }\n+    }).collect()\n }\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n-                         -> Option<@Stmt> {\n+                         -> SmallVector<@Stmt> {\n     // is it a let?\n     match s.node {\n         StmtDecl(@Spanned {\n@@ -590,7 +588,7 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n                     id: id,\n                     span: span,\n                 };\n-            Some(@Spanned {\n+            SmallVector::one(@Spanned {\n                 node: StmtDecl(@Spanned {\n                         node: DeclLocal(rewritten_local),\n                         span: stmt_span\n@@ -679,13 +677,11 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n     let pending_renames = block_info.pending_renames;\n     let rename_fld = renames_to_fold(pending_renames);\n     let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n-    let mut new_stmts = ~[];\n-    for x in b.stmts.iter() {\n-        match fld.fold_stmt(mustbesome(rename_fld.fold_stmt(*x))) {\n-            Some(s) => new_stmts.push(s),\n-            None => ()\n-        }\n-    }\n+    let new_stmts = b.stmts.iter()\n+            .map(|x| rename_fld.fold_stmt(*x)\n+                 .expect_one(\"rename_fold didn't return one value\"))\n+            .flat_map(|x| fld.fold_stmt(x).move_iter())\n+            .collect();\n     let new_expr = b.expr.map(|x| fld.fold_expr(rename_fld.fold_expr(x)));\n     Block{\n         view_items: new_view_items,\n@@ -697,15 +693,6 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n     }\n }\n \n-// rename_fold should never return \"None\".\n-// (basically, just .get() with a better message...)\n-fn mustbesome<T>(val : Option<T>) -> T {\n-    match val {\n-        Some(v) => v,\n-        None => fail!(\"rename_fold returned None\")\n-    }\n-}\n-\n // get the (innermost) BlockInfo from an exts stack\n fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n     match exts.find_in_topmost_frame(&intern(special_block_name)) {\n@@ -741,10 +728,8 @@ pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n \n // perform a bunch of renames\n fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n-    match folder.fold_stmt(&stmt) {\n-        Some(s) => s,\n-        None => fail!(\"renaming of stmt produced None\")\n-    }\n+    folder.fold_stmt(&stmt)\n+            .expect_one(\"renaming of stmt did not produce one stmt\")\n }\n \n \n@@ -1025,14 +1010,14 @@ impl ast_fold for MacroExpander {\n                          self)\n     }\n \n-    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n         expand_item(self.extsbox,\n                     self.cx,\n                     item,\n                     self)\n     }\n \n-    fn fold_stmt(&self, stmt: &ast::Stmt) -> Option<@ast::Stmt> {\n+    fn fold_stmt(&self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n         expand_stmt(self.extsbox,\n                     self.cx,\n                     stmt,\n@@ -1191,11 +1176,12 @@ fn mark_expr(expr : @ast::Expr, m : Mrk) -> @ast::Expr {\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n fn mark_stmt(expr : &ast::Stmt, m : Mrk) -> @ast::Stmt {\n-    new_mark_folder(m).fold_stmt(expr).unwrap()\n+    new_mark_folder(m).fold_stmt(expr)\n+            .expect_one(\"marking a stmt didn't return a stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr : @ast::item, m : Mrk) -> Option<@ast::item> {\n+fn mark_item(expr : @ast::item, m : Mrk) -> SmallVector<@ast::item> {\n     new_mark_folder(m).fold_item(expr)\n }\n "}, {"sha": "3cc00ef8199581fe993cd07abaac9111266bcd60", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -24,6 +24,7 @@ use parse::attr::parser_attr;\n use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt, EOF};\n use print;\n+use util::small_vector::SmallVector;\n \n struct ParserAnyMacro {\n     parser: @Parser,\n@@ -54,9 +55,15 @@ impl AnyMacro for ParserAnyMacro {\n         self.ensure_complete_parse(true);\n         ret\n     }\n-    fn make_item(&self) -> Option<@ast::item> {\n-        let attrs = self.parser.parse_outer_attributes();\n-        let ret = self.parser.parse_item(attrs);\n+    fn make_items(&self) -> SmallVector<@ast::item> {\n+        let mut ret = SmallVector::zero();\n+        loop {\n+            let attrs = self.parser.parse_outer_attributes();\n+            match self.parser.parse_item(attrs) {\n+                Some(item) => ret.push(item),\n+                None => break\n+            }\n+        }\n         self.ensure_complete_parse(false);\n         ret\n     }"}, {"sha": "4c0653a3c04f347064a1fe6926716d08d86b9447", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -13,6 +13,7 @@ use ast;\n use codemap::{respan, Span, Spanned};\n use parse::token;\n use opt_vec::OptVec;\n+use util::small_vector::SmallVector;\n \n // We may eventually want to be able to fold over type parameters, too.\n pub trait ast_fold {\n@@ -113,7 +114,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_item(&self, i: @item) -> Option<@item> {\n+    fn fold_item(&self, i: @item) -> SmallVector<@item> {\n         noop_fold_item(i, self)\n     }\n \n@@ -159,7 +160,7 @@ pub trait ast_fold {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&self, s: &Stmt) -> Option<@Stmt> {\n+    fn fold_stmt(&self, s: &Stmt) -> SmallVector<@Stmt> {\n         noop_fold_stmt(s, self)\n     }\n \n@@ -216,23 +217,20 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_decl(&self, d: @Decl) -> Option<@Decl> {\n+    fn fold_decl(&self, d: @Decl) -> SmallVector<@Decl> {\n         let node = match d.node {\n-            DeclLocal(ref l) => Some(DeclLocal(self.fold_local(*l))),\n+            DeclLocal(ref l) => SmallVector::one(DeclLocal(self.fold_local(*l))),\n             DeclItem(it) => {\n-                match self.fold_item(it) {\n-                    Some(it_folded) => Some(DeclItem(it_folded)),\n-                    None => None,\n-                }\n+                self.fold_item(it).move_iter().map(|i| DeclItem(i)).collect()\n             }\n         };\n \n-        node.map(|node| {\n+        node.move_iter().map(|node| {\n             @Spanned {\n                 node: node,\n                 span: d.span,\n             }\n-        })\n+        }).collect()\n     }\n \n     fn fold_expr(&self, e: @Expr) -> @Expr {\n@@ -618,13 +616,7 @@ fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &T)\n \n pub fn noop_fold_block<T:ast_fold>(b: &Block, folder: &T) -> Block {\n     let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n-    let mut stmts = ~[];\n-    for stmt in b.stmts.iter() {\n-        match folder.fold_stmt(*stmt) {\n-            None => {}\n-            Some(stmt) => stmts.push(stmt)\n-        }\n-    }\n+    let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     ast::Block {\n         view_items: view_items,\n         stmts: stmts,\n@@ -711,7 +703,7 @@ pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &T) -> _mod {\n         view_items: m.view_items\n                      .iter()\n                      .map(|x| folder.fold_view_item(x)).collect(),\n-        items: m.items.iter().filter_map(|x| folder.fold_item(*x)).collect(),\n+        items: m.items.iter().flat_map(|x| folder.fold_item(*x).move_iter()).collect(),\n     }\n }\n \n@@ -728,10 +720,10 @@ pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &T) -> Crate {\n }\n \n pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &T)\n-                                  -> Option<@ast::item> {\n+                                  -> SmallVector<@ast::item> {\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n-    Some(@ast::item {\n+    SmallVector::one(@ast::item {\n         ident: folder.fold_ident(i.ident),\n         attrs: i.attrs.map(|e| fold_attribute(*e)),\n         id: folder.new_id(i.id),\n@@ -867,27 +859,26 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n     }\n }\n \n-pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &T) -> Option<@Stmt> {\n-    let node = match s.node {\n+pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &T) -> SmallVector<@Stmt> {\n+    let nodes = match s.node {\n         StmtDecl(d, nid) => {\n-            match folder.fold_decl(d) {\n-                Some(d) => Some(StmtDecl(d, folder.new_id(nid))),\n-                None => None,\n-            }\n+            folder.fold_decl(d).move_iter()\n+                    .map(|d| StmtDecl(d, folder.new_id(nid)))\n+                    .collect()\n         }\n         StmtExpr(e, nid) => {\n-            Some(StmtExpr(folder.fold_expr(e), folder.new_id(nid)))\n+            SmallVector::one(StmtExpr(folder.fold_expr(e), folder.new_id(nid)))\n         }\n         StmtSemi(e, nid) => {\n-            Some(StmtSemi(folder.fold_expr(e), folder.new_id(nid)))\n+            SmallVector::one(StmtSemi(folder.fold_expr(e), folder.new_id(nid)))\n         }\n-        StmtMac(ref mac, semi) => Some(StmtMac(folder.fold_mac(mac), semi))\n+        StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))\n     };\n \n-    node.map(|node| @Spanned {\n+    nodes.move_iter().map(|node| @Spanned {\n         node: node,\n         span: folder.new_span(s.span),\n-    })\n+    }).collect()\n }\n \n #[cfg(test)]"}, {"sha": "5b12e8b8eb1feb9eb434144295d1d827680aff4c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -31,6 +31,7 @@ pub mod util {\n     pub mod interner;\n     #[cfg(test)]\n     pub mod parser_testing;\n+    pub mod small_vector;\n }\n \n pub mod syntax {"}, {"sha": "71eee8b7ccca0516eeafedb6740822b777b6b0ce", "filename": "src/libsyntax/util/small_vector.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use std::vec::MoveIterator;\n+use std::util;\n+\n+/// A vector type optimized for cases where the size is almost always 0 or 1\n+pub enum SmallVector<T> {\n+    priv Zero,\n+    priv One(T),\n+    priv Many(~[T]),\n+}\n+\n+impl<T> Container for SmallVector<T> {\n+    fn len(&self) -> uint {\n+        match *self {\n+            Zero => 0,\n+            One(*) => 1,\n+            Many(ref vals) => vals.len()\n+        }\n+    }\n+}\n+\n+impl<T> FromIterator<T> for SmallVector<T> {\n+    fn from_iterator<I: Iterator<T>>(iter: &mut I) -> SmallVector<T> {\n+        let mut v = Zero;\n+        for val in *iter {\n+            v.push(val);\n+        }\n+        v\n+    }\n+}\n+\n+impl<T> SmallVector<T> {\n+    pub fn zero() -> SmallVector<T> {\n+        Zero\n+    }\n+\n+    pub fn one(v: T) -> SmallVector<T> {\n+        One(v)\n+    }\n+\n+    pub fn many(vs: ~[T]) -> SmallVector<T> {\n+        Many(vs)\n+    }\n+\n+    pub fn push(&mut self, v: T) {\n+        match *self {\n+            Zero => *self = One(v),\n+            One(*) => {\n+                let one = util::replace(self, Zero);\n+                match one {\n+                    One(v1) => util::replace(self, Many(~[v1, v])),\n+                    _ => unreachable!()\n+                };\n+            }\n+            Many(ref mut vs) => vs.push(v)\n+        }\n+    }\n+\n+    fn get<'a>(&'a self, idx: uint) -> &'a T {\n+        match *self {\n+            One(ref v) if idx == 0 => v,\n+            Many(ref vs) => &vs[idx],\n+            _ => fail!(\"Out of bounds access\")\n+        }\n+    }\n+\n+    pub fn expect_one(self, err: &'static str) -> T {\n+        match self {\n+            One(v) => v,\n+            Many([v]) => v,\n+            _ => fail!(err)\n+        }\n+    }\n+\n+    pub fn move_iter(self) -> SmallVectorMoveIterator<T> {\n+        match self {\n+            Zero => ZeroIterator,\n+            One(v) => OneIterator(v),\n+            Many(vs) => ManyIterator(vs.move_iter())\n+        }\n+    }\n+}\n+\n+pub enum SmallVectorMoveIterator<T> {\n+    priv ZeroIterator,\n+    priv OneIterator(T),\n+    priv ManyIterator(MoveIterator<T>),\n+}\n+\n+impl<T> Iterator<T> for SmallVectorMoveIterator<T> {\n+    fn next(&mut self) -> Option<T> {\n+        match *self {\n+            ZeroIterator => None,\n+            OneIterator(*) => {\n+                let mut replacement = ZeroIterator;\n+                util::swap(self, &mut replacement);\n+                match replacement {\n+                    OneIterator(v) => Some(v),\n+                    _ => unreachable!()\n+                }\n+            }\n+            ManyIterator(ref mut inner) => inner.next()\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        match *self {\n+            ZeroIterator => (0, Some(0)),\n+            OneIterator(*) => (1, Some(1)),\n+            ManyIterator(ref inner) => inner.size_hint()\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_len() {\n+        let v: SmallVector<int> = SmallVector::zero();\n+        assert_eq!(0, v.len());\n+\n+        assert_eq!(1, SmallVector::one(1).len());\n+        assert_eq!(5, SmallVector::many(~[1, 2, 3, 4, 5]).len());\n+    }\n+\n+    #[test]\n+    fn test_push_get() {\n+        let mut v = SmallVector::zero();\n+        v.push(1);\n+        assert_eq!(1, v.len());\n+        assert_eq!(&1, v.get(0));\n+        v.push(2);\n+        assert_eq!(2, v.len());\n+        assert_eq!(&2, v.get(1));\n+        v.push(3);\n+        assert_eq!(3, v.len());\n+        assert_eq!(&3, v.get(2));\n+    }\n+\n+    #[test]\n+    fn test_from_iterator() {\n+        let v: SmallVector<int> = (~[1, 2, 3]).move_iter().collect();\n+        assert_eq!(3, v.len());\n+        assert_eq!(&1, v.get(0));\n+        assert_eq!(&2, v.get(1));\n+        assert_eq!(&3, v.get(2));\n+    }\n+\n+    #[test]\n+    fn test_move_iter() {\n+        let v = SmallVector::zero();\n+        let v: ~[int] = v.move_iter().collect();\n+        assert_eq!(~[], v);\n+\n+        let v = SmallVector::one(1);\n+        assert_eq!(~[1], v.move_iter().collect());\n+\n+        let v = SmallVector::many(~[1, 2, 3]);\n+        assert_eq!(~[1, 2, 3], v.move_iter().collect());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_expect_one_zero() {\n+        let _: int = SmallVector::zero().expect_one(\"\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_expect_one_many() {\n+        SmallVector::many(~[1, 2]).expect_one(\"\");\n+    }\n+\n+    #[test]\n+    fn test_expect_one_one() {\n+        assert_eq!(1, SmallVector::one(1).expect_one(\"\"));\n+        assert_eq!(1, SmallVector::many(~[1]).expect_one(\"\"));\n+    }\n+}"}, {"sha": "98e0ecfad864504138c4f631e782eabf8f3754ab", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -13,7 +13,8 @@\n macro_rules! ignored_item {\n     () => {\n         fn foo() {}\n-        fn bar() {} //~ ERROR macro expansion ignores token `fn`\n+        fn bar() {}\n+        , //~ ERROR macro expansion ignores token `,`\n     }\n }\n "}, {"sha": "c96f8c7b7bbe83c01d017b618957018dfb382765", "filename": "src/test/run-pass/macro-multiple-items.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18687a92ae6b79eb221706db7b7390330b2f7a21/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs?ref=18687a92ae6b79eb221706db7b7390330b2f7a21", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-pretty - token trees can't pretty print\n+\n+#[feature(macro_rules)];\n+\n+macro_rules! make_foo(\n+    () => (\n+        struct Foo;\n+\n+        impl Foo {\n+            fn bar(&self) {}\n+        }\n+    )\n+)\n+\n+make_foo!()\n+\n+pub fn main() {\n+    Foo.bar()\n+}"}]}