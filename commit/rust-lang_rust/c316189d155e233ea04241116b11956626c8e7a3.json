{"sha": "c316189d155e233ea04241116b11956626c8e7a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMTYxODlkMTU1ZTIzM2VhMDQyNDExMTZiMTE5NTY2MjZjOGU3YTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-22T19:24:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-22T19:24:38Z"}, "message": "auto merge of #5081 : brson/rust/pipes, r=pcwalton\n\nr?", "tree": {"sha": "930b4d65fa6777b085381271b2922d17f12146dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/930b4d65fa6777b085381271b2922d17f12146dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c316189d155e233ea04241116b11956626c8e7a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c316189d155e233ea04241116b11956626c8e7a3", "html_url": "https://github.com/rust-lang/rust/commit/c316189d155e233ea04241116b11956626c8e7a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c316189d155e233ea04241116b11956626c8e7a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba7a8706609a96080f75de57ab0af7ac86dbb583", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba7a8706609a96080f75de57ab0af7ac86dbb583", "html_url": "https://github.com/rust-lang/rust/commit/ba7a8706609a96080f75de57ab0af7ac86dbb583"}, {"sha": "dab6a852303f68c2ed6c17abaca1d0728d9cf618", "url": "https://api.github.com/repos/rust-lang/rust/commits/dab6a852303f68c2ed6c17abaca1d0728d9cf618", "html_url": "https://github.com/rust-lang/rust/commit/dab6a852303f68c2ed6c17abaca1d0728d9cf618"}], "stats": {"total": 1294, "additions": 683, "deletions": 611}, "files": [{"sha": "c0f9a37627065954197a3d8b2c3b71a67d0f241a", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -157,7 +157,7 @@ concurrently:\n \n ~~~~\n use task::spawn;\n-use pipes::{stream, Port, Chan};\n+use comm::{stream, Port, Chan};\n \n let (port, chan): (Port<int>, Chan<int>) = stream();\n \n@@ -178,7 +178,7 @@ stream for sending and receiving integers (the left-hand side of the `let`,\n a tuple into its component parts).\n \n ~~~~\n-# use pipes::{stream, Chan, Port};\n+# use comm::{stream, Chan, Port};\n let (port, chan): (Port<int>, Chan<int>) = stream();\n ~~~~\n \n@@ -189,7 +189,7 @@ spawns the child task.\n ~~~~\n # use task::{spawn};\n # use task::spawn;\n-# use pipes::{stream, Port, Chan};\n+# use comm::{stream, Port, Chan};\n # fn some_expensive_computation() -> int { 42 }\n # let (port, chan) = stream();\n do spawn || {\n@@ -209,7 +209,7 @@ computation, then waits for the child's result to arrive on the\n port:\n \n ~~~~\n-# use pipes::{stream, Port, Chan};\n+# use comm::{stream, Port, Chan};\n # fn some_other_expensive_computation() {}\n # let (port, chan) = stream::<int>();\n # chan.send(0);\n@@ -225,7 +225,7 @@ following program is ill-typed:\n \n ~~~ {.xfail-test}\n # use task::{spawn};\n-# use pipes::{stream, Port, Chan};\n+# use comm::{stream, Port, Chan};\n # fn some_expensive_computation() -> int { 42 }\n let (port, chan) = stream();\n \n@@ -245,7 +245,7 @@ Instead we can use a `SharedChan`, a type that allows a single\n \n ~~~\n # use task::spawn;\n-use pipes::{stream, SharedChan};\n+use comm::{stream, SharedChan};\n \n let (port, chan) = stream();\n let chan = SharedChan(chan);\n@@ -278,7 +278,7 @@ might look like the example below.\n \n ~~~\n # use task::spawn;\n-# use pipes::{stream, Port, Chan};\n+# use comm::{stream, Port, Chan};\n \n // Create a vector of ports, one for each child task\n let ports = do vec::from_fn(3) |init_val| {\n@@ -393,7 +393,7 @@ internally, with additional logic to wait for the child task to finish\n before returning. Hence:\n \n ~~~\n-# use pipes::{stream, Chan, Port};\n+# use comm::{stream, Chan, Port};\n # use task::{spawn, try};\n # fn sleep_forever() { loop { task::yield() } }\n # do task::try {\n@@ -468,7 +468,7 @@ Here is the function that implements the child task:\n \n ~~~~\n # use std::comm::DuplexStream;\n-# use pipes::{Port, Chan};\n+# use comm::{Port, Chan};\n fn stringifier(channel: &DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n@@ -491,7 +491,7 @@ Here is the code for the parent task:\n \n ~~~~\n # use std::comm::DuplexStream;\n-# use pipes::{Port, Chan};\n+# use comm::{Port, Chan};\n # use task::spawn;\n # fn stringifier(channel: &DuplexStream<~str, uint>) {\n #     let mut value: uint;"}, {"sha": "6c8bd7ea44269151e1d49fc42a5f4f0c1ebf6dab", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -76,7 +76,7 @@ pub fn run(lib_path: ~str,\n \n \n     writeclose(pipe_in.out, input);\n-    let p = pipes::PortSet();\n+    let p = comm::PortSet();\n     let ch = p.chan();\n     do task::spawn_sched(task::SingleThreaded) || {\n         let errput = readclose(pipe_err.in);"}, {"sha": "7939644e51cb9259b160686ee960adfe65bf6672", "filename": "src/libcore/comm.rs", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -0,0 +1,410 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Transitional -- needs snapshot\n+#[allow(structural_records)];\n+\n+use either::{Either, Left, Right};\n+use kinds::Owned;\n+use option;\n+use option::{Option, Some, None, unwrap};\n+use private;\n+use vec;\n+\n+use pipes::{recv, try_recv, wait_many, peek, PacketHeader};\n+\n+// NOTE Making this public exposes some plumbing from pipes. Needs\n+// some refactoring\n+pub use pipes::Selectable;\n+\n+/// A trait for things that can send multiple messages.\n+pub trait GenericChan<T> {\n+    /// Sends a message.\n+    fn send(x: T);\n+}\n+\n+/// Things that can send multiple messages and can detect when the receiver\n+/// is closed\n+pub trait GenericSmartChan<T> {\n+    /// Sends a message, or report if the receiver has closed the connection.\n+    fn try_send(x: T) -> bool;\n+}\n+\n+/// A trait for things that can receive multiple messages.\n+pub trait GenericPort<T> {\n+    /// Receives a message, or fails if the connection closes.\n+    fn recv() -> T;\n+\n+    /** Receives a message, or returns `none` if\n+    the connection is closed or closes.\n+    */\n+    fn try_recv() -> Option<T>;\n+}\n+\n+/// Ports that can `peek`\n+pub trait Peekable<T> {\n+    /// Returns true if a message is available\n+    pure fn peek() -> bool;\n+}\n+\n+/// Returns the index of an endpoint that is ready to receive.\n+pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n+    wait_many(endpoints)\n+}\n+\n+/// Returns 0 or 1 depending on which endpoint is ready to receive\n+pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n+        Either<(), ()> {\n+    match wait_many([a.header(), b.header()]) {\n+      0 => Left(()),\n+      1 => Right(()),\n+      _ => fail!(~\"wait returned unexpected index\")\n+    }\n+}\n+\n+// Streams - Make pipes a little easier in general.\n+\n+proto! streamp (\n+    Open:send<T: Owned> {\n+        data(T) -> Open<T>\n+    }\n+)\n+\n+#[doc(hidden)]\n+struct Chan_<T> {\n+    mut endp: Option<streamp::client::Open<T>>\n+}\n+\n+/// An endpoint that can send many messages.\n+pub enum Chan<T> {\n+    Chan_(Chan_<T>)\n+}\n+\n+struct Port_<T> {\n+    mut endp: Option<streamp::server::Open<T>>,\n+}\n+\n+/// An endpoint that can receive many messages.\n+pub enum Port<T> {\n+    Port_(Port_<T>)\n+}\n+\n+/** Creates a `(chan, port)` pair.\n+\n+These allow sending or receiving an unlimited number of messages.\n+\n+*/\n+pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n+    let (c, s) = streamp::init();\n+\n+    (Port_(Port_ { endp: Some(s) }), Chan_(Chan_{ endp: Some(c) }))\n+}\n+\n+impl<T: Owned> GenericChan<T> for Chan<T> {\n+    fn send(x: T) {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        self.endp = Some(\n+            streamp::client::data(unwrap(endp), x))\n+    }\n+}\n+\n+impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+\n+    fn try_send(x: T) -> bool {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        match streamp::client::try_data(unwrap(endp), x) {\n+            Some(next) => {\n+                self.endp = Some(next);\n+                true\n+            }\n+            None => false\n+        }\n+    }\n+}\n+\n+impl<T: Owned> GenericPort<T> for Port<T> {\n+    fn recv() -> T {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        let streamp::data(x, endp) = recv(unwrap(endp));\n+        self.endp = Some(endp);\n+        x\n+    }\n+\n+    fn try_recv() -> Option<T> {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        match try_recv(unwrap(endp)) {\n+          Some(streamp::data(x, endp)) => {\n+            self.endp = Some(endp);\n+            Some(x)\n+          }\n+          None => None\n+        }\n+    }\n+}\n+\n+impl<T: Owned> Peekable<T> for Port<T> {\n+    pure fn peek() -> bool {\n+        unsafe {\n+            let mut endp = None;\n+            endp <-> self.endp;\n+            let peek = match &endp {\n+              &Some(ref endp) => peek(endp),\n+              &None => fail!(~\"peeking empty stream\")\n+            };\n+            self.endp <-> endp;\n+            peek\n+        }\n+    }\n+}\n+\n+impl<T: Owned> Selectable for Port<T> {\n+    pure fn header() -> *PacketHeader {\n+        unsafe {\n+            match self.endp {\n+              Some(ref endp) => endp.header(),\n+              None => fail!(~\"peeking empty stream\")\n+            }\n+        }\n+    }\n+}\n+\n+/// Treat many ports as one.\n+pub struct PortSet<T> {\n+    mut ports: ~[Port<T>],\n+}\n+\n+pub fn PortSet<T: Owned>() -> PortSet<T>{\n+    PortSet {\n+        ports: ~[]\n+    }\n+}\n+\n+impl<T: Owned> PortSet<T> {\n+\n+    fn add(port: Port<T>) {\n+        self.ports.push(port)\n+    }\n+\n+    fn chan() -> Chan<T> {\n+        let (po, ch) = stream();\n+        self.add(po);\n+        ch\n+    }\n+}\n+\n+impl<T: Owned> GenericPort<T> for PortSet<T> {\n+\n+    fn try_recv() -> Option<T> {\n+        let mut result = None;\n+        // we have to swap the ports array so we aren't borrowing\n+        // aliasable mutable memory.\n+        let mut ports = ~[];\n+        ports <-> self.ports;\n+        while result.is_none() && ports.len() > 0 {\n+            let i = wait_many(ports);\n+            match ports[i].try_recv() {\n+                Some(m) => {\n+                  result = Some(m);\n+                }\n+                None => {\n+                    // Remove this port.\n+                    let _ = ports.swap_remove(i);\n+                }\n+            }\n+        }\n+        ports <-> self.ports;\n+        result\n+    }\n+\n+    fn recv() -> T {\n+        self.try_recv().expect(\"port_set: endpoints closed\")\n+    }\n+\n+}\n+\n+impl<T: Owned> Peekable<T> for PortSet<T> {\n+    pure fn peek() -> bool {\n+        // It'd be nice to use self.port.each, but that version isn't\n+        // pure.\n+        for vec::each(self.ports) |p| {\n+            if p.peek() { return true }\n+        }\n+        false\n+    }\n+}\n+\n+/// A channel that can be shared between many senders.\n+pub type SharedChan<T> = private::Exclusive<Chan<T>>;\n+\n+impl<T: Owned> GenericChan<T> for SharedChan<T> {\n+    fn send(x: T) {\n+        let mut xx = Some(x);\n+        do self.with_imm |chan| {\n+            let mut x = None;\n+            x <-> xx;\n+            chan.send(option::unwrap(x))\n+        }\n+    }\n+}\n+\n+impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n+    fn try_send(x: T) -> bool {\n+        let mut xx = Some(x);\n+        do self.with_imm |chan| {\n+            let mut x = None;\n+            x <-> xx;\n+            chan.try_send(option::unwrap(x))\n+        }\n+    }\n+}\n+\n+/// Converts a `chan` into a `shared_chan`.\n+pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n+    private::exclusive(c)\n+}\n+\n+/// Receive a message from one of two endpoints.\n+pub trait Select2<T: Owned, U: Owned> {\n+    /// Receive a message or return `None` if a connection closes.\n+    fn try_select() -> Either<Option<T>, Option<U>>;\n+    /// Receive a message or fail if a connection closes.\n+    fn select() -> Either<T, U>;\n+}\n+\n+impl<T: Owned, U: Owned,\n+     Left: Selectable + GenericPort<T>,\n+     Right: Selectable + GenericPort<U>>\n+    Select2<T, U> for (Left, Right) {\n+\n+    fn select() -> Either<T, U> {\n+        match self {\n+          (ref lp, ref rp) => match select2i(lp, rp) {\n+            Left(()) => Left (lp.recv()),\n+            Right(()) => Right(rp.recv())\n+          }\n+        }\n+    }\n+\n+    fn try_select() -> Either<Option<T>, Option<U>> {\n+        match self {\n+          (ref lp, ref rp) => match select2i(lp, rp) {\n+            Left(()) => Left (lp.try_recv()),\n+            Right(()) => Right(rp.try_recv())\n+          }\n+        }\n+    }\n+}\n+\n+proto! oneshot (\n+    Oneshot:send<T:Owned> {\n+        send(T) -> !\n+    }\n+)\n+\n+/// The send end of a oneshot pipe.\n+pub type ChanOne<T> = oneshot::client::Oneshot<T>;\n+/// The receive end of a oneshot pipe.\n+pub type PortOne<T> = oneshot::server::Oneshot<T>;\n+\n+/// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n+pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+    let (chan, port) = oneshot::init();\n+    (port, chan)\n+}\n+\n+impl<T: Owned> PortOne<T> {\n+    fn recv(self) -> T { recv_one(self) }\n+    fn try_recv(self) -> Option<T> { try_recv_one(self) }\n+}\n+\n+impl<T: Owned> ChanOne<T> {\n+    fn send(self, data: T) { send_one(self, data) }\n+    fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n+}\n+\n+/**\n+ * Receive a message from a oneshot pipe, failing if the connection was\n+ * closed.\n+ */\n+pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n+    let oneshot::send(message) = recv(port);\n+    message\n+}\n+\n+/// Receive a message from a oneshot pipe unless the connection was closed.\n+pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n+    let message = try_recv(port);\n+\n+    if message.is_none() { None }\n+    else {\n+        let oneshot::send(message) = option::unwrap(message);\n+        Some(message)\n+    }\n+}\n+\n+/// Send a message on a oneshot pipe, failing if the connection was closed.\n+pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n+    oneshot::client::send(chan, data);\n+}\n+\n+/**\n+ * Send a message on a oneshot pipe, or return false if the connection was\n+ * closed.\n+ */\n+pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n+        -> bool {\n+    oneshot::client::try_send(chan, data).is_some()\n+}\n+\n+#[cfg(test)]\n+pub mod test {\n+    use either::{Either, Left, Right};\n+    use super::{Chan, Port, oneshot, recv_one, stream};\n+\n+    #[test]\n+    pub fn test_select2() {\n+        let (p1, c1) = stream();\n+        let (p2, c2) = stream();\n+\n+        c1.send(~\"abc\");\n+\n+        match (p1, p2).select() {\n+          Right(_) => fail!(),\n+          _ => ()\n+        }\n+\n+        c2.send(123);\n+    }\n+\n+    #[test]\n+    pub fn test_oneshot() {\n+        let (c, p) = oneshot::init();\n+\n+        oneshot::client::send(c, ());\n+\n+        recv_one(p)\n+    }\n+\n+    #[test]\n+    fn test_peek_terminated() {\n+        let (port, chan): (Port<int>, Chan<int>) = stream();\n+\n+        {\n+            // Destroy the channel\n+            let _chan = chan;\n+        }\n+\n+        assert !port.peek();\n+    }\n+}"}, {"sha": "01669557389ae575dc893296c9dce9b33cfc0af5", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -148,6 +148,7 @@ pub mod hashmap;\n \n #[path = \"task/mod.rs\"]\n pub mod task;\n+pub mod comm;\n pub mod pipes;\n \n \n@@ -255,6 +256,7 @@ pub mod core {\n     pub use option;\n     pub use kinds;\n     pub use sys;\n+    pub use pipes;\n }\n \n "}, {"sha": "94c0a567f4c0954ec36a89e604b306df0c83490b", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 9, "deletions": 344, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -142,7 +142,7 @@ pub struct Buffer<T> {\n     data: T,\n }\n \n-struct PacketHeader {\n+pub struct PacketHeader {\n     mut state: State,\n     mut blocked_task: *rust_task,\n \n@@ -151,15 +151,15 @@ struct PacketHeader {\n     mut buffer: *libc::c_void,\n }\n \n-fn PacketHeader() -> PacketHeader {\n+pub fn PacketHeader() -> PacketHeader {\n     PacketHeader {\n         state: Empty,\n         blocked_task: ptr::null(),\n         buffer: ptr::null()\n     }\n }\n \n-impl PacketHeader {\n+pub impl PacketHeader {\n     // Returns the old state.\n     unsafe fn mark_blocked(this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n@@ -551,12 +551,6 @@ pub pure fn peek<T:Owned,Tb:Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     }\n }\n \n-impl<T:Owned,Tb:Owned> Peekable<T> for RecvPacketBuffered<T, Tb> {\n-    pure fn peek() -> bool {\n-        peek(&self)\n-    }\n-}\n-\n #[doc(hidden)]\n fn sender_terminate<T:Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n@@ -622,7 +616,7 @@ that vector. The index points to an endpoint that has either been\n closed by the sender or has a message waiting to be received.\n \n */\n-fn wait_many<T:Selectable>(pkts: &[T]) -> uint {\n+pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n     let this = unsafe { rustrt::rust_get_task() };\n \n     unsafe {\n@@ -720,7 +714,7 @@ pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n }\n \n #[doc(hidden)]\n-trait Selectable {\n+pub trait Selectable {\n     pure fn header() -> *PacketHeader;\n }\n \n@@ -957,335 +951,6 @@ pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n     client\n }\n \n-// Streams - Make pipes a little easier in general.\n-\n-proto! streamp (\n-    Open:send<T:Owned> {\n-        data(T) -> Open<T>\n-    }\n-)\n-\n-/// A trait for things that can send multiple messages.\n-pub trait GenericChan<T> {\n-    /// Sends a message.\n-    fn send(x: T);\n-}\n-\n-/// Things that can send multiple messages and can detect when the receiver\n-/// is closed\n-pub trait GenericSmartChan<T> {\n-    /// Sends a message, or report if the receiver has closed the connection.\n-    fn try_send(x: T) -> bool;\n-}\n-\n-/// A trait for things that can receive multiple messages.\n-pub trait GenericPort<T> {\n-    /// Receives a message, or fails if the connection closes.\n-    fn recv() -> T;\n-\n-    /** Receives a message, or returns `none` if\n-    the connection is closed or closes.\n-    */\n-    fn try_recv() -> Option<T>;\n-}\n-\n-/// Ports that can `peek`\n-pub trait Peekable<T> {\n-    /// Returns true if a message is available\n-    pure fn peek() -> bool;\n-}\n-\n-#[doc(hidden)]\n-struct Chan_<T> {\n-    mut endp: Option<streamp::client::Open<T>>\n-}\n-\n-/// An endpoint that can send many messages.\n-pub enum Chan<T> {\n-    Chan_(Chan_<T>)\n-}\n-\n-#[doc(hidden)]\n-struct Port_<T> {\n-    mut endp: Option<streamp::server::Open<T>>,\n-}\n-\n-/// An endpoint that can receive many messages.\n-pub enum Port<T> {\n-    Port_(Port_<T>)\n-}\n-\n-/** Creates a `(chan, port)` pair.\n-\n-These allow sending or receiving an unlimited number of messages.\n-\n-*/\n-pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n-    let (c, s) = streamp::init();\n-\n-    (Port_(Port_ { endp: Some(s) }), Chan_(Chan_{ endp: Some(c) }))\n-}\n-\n-impl<T:Owned> GenericChan<T> for Chan<T> {\n-    fn send(x: T) {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        self.endp = Some(\n-            streamp::client::data(unwrap(endp), x))\n-    }\n-}\n-\n-impl<T:Owned> GenericSmartChan<T> for Chan<T> {\n-\n-    fn try_send(x: T) -> bool {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        match streamp::client::try_data(unwrap(endp), x) {\n-            Some(next) => {\n-                self.endp = Some(next);\n-                true\n-            }\n-            None => false\n-        }\n-    }\n-}\n-\n-impl<T:Owned> GenericPort<T> for Port<T> {\n-    fn recv() -> T {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        let streamp::data(x, endp) = pipes::recv(unwrap(endp));\n-        self.endp = Some(endp);\n-        x\n-    }\n-\n-    fn try_recv() -> Option<T> {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        match pipes::try_recv(unwrap(endp)) {\n-          Some(streamp::data(x, endp)) => {\n-            self.endp = Some(endp);\n-            Some(x)\n-          }\n-          None => None\n-        }\n-    }\n-}\n-\n-impl<T:Owned> Peekable<T> for Port<T> {\n-    pure fn peek() -> bool {\n-        unsafe {\n-            let mut endp = None;\n-            endp <-> self.endp;\n-            let peek = match &endp {\n-              &Some(ref endp) => pipes::peek(endp),\n-              &None => fail!(~\"peeking empty stream\")\n-            };\n-            self.endp <-> endp;\n-            peek\n-        }\n-    }\n-}\n-\n-impl<T:Owned> Selectable for Port<T> {\n-    pure fn header() -> *PacketHeader {\n-        unsafe {\n-            match self.endp {\n-              Some(ref endp) => endp.header(),\n-              None => fail!(~\"peeking empty stream\")\n-            }\n-        }\n-    }\n-}\n-\n-/// Treat many ports as one.\n-pub struct PortSet<T> {\n-    mut ports: ~[pipes::Port<T>],\n-}\n-\n-pub fn PortSet<T:Owned>() -> PortSet<T>{\n-    PortSet {\n-        ports: ~[]\n-    }\n-}\n-\n-impl<T:Owned> PortSet<T> {\n-\n-    fn add(port: pipes::Port<T>) {\n-        self.ports.push(port)\n-    }\n-\n-    fn chan() -> Chan<T> {\n-        let (po, ch) = stream();\n-        self.add(po);\n-        ch\n-    }\n-}\n-\n-impl<T:Owned> GenericPort<T> for PortSet<T> {\n-\n-    fn try_recv() -> Option<T> {\n-        let mut result = None;\n-        // we have to swap the ports array so we aren't borrowing\n-        // aliasable mutable memory.\n-        let mut ports = ~[];\n-        ports <-> self.ports;\n-        while result.is_none() && ports.len() > 0 {\n-            let i = wait_many(ports);\n-            match ports[i].try_recv() {\n-                Some(m) => {\n-                  result = Some(m);\n-                }\n-                None => {\n-                    // Remove this port.\n-                    let _ = ports.swap_remove(i);\n-                }\n-            }\n-        }\n-        ports <-> self.ports;\n-        result\n-    }\n-\n-    fn recv() -> T {\n-        self.try_recv().expect(\"port_set: endpoints closed\")\n-    }\n-\n-}\n-\n-impl<T:Owned> Peekable<T> for PortSet<T> {\n-    pure fn peek() -> bool {\n-        // It'd be nice to use self.port.each, but that version isn't\n-        // pure.\n-        for vec::each(self.ports) |p| {\n-            if p.peek() { return true }\n-        }\n-        false\n-    }\n-}\n-\n-/// A channel that can be shared between many senders.\n-pub type SharedChan<T> = private::Exclusive<Chan<T>>;\n-\n-impl<T:Owned> GenericChan<T> for SharedChan<T> {\n-    fn send(x: T) {\n-        let mut xx = Some(x);\n-        do self.with_imm |chan| {\n-            let mut x = None;\n-            x <-> xx;\n-            chan.send(option::unwrap(x))\n-        }\n-    }\n-}\n-\n-impl<T:Owned> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(x: T) -> bool {\n-        let mut xx = Some(x);\n-        do self.with_imm |chan| {\n-            let mut x = None;\n-            x <-> xx;\n-            chan.try_send(option::unwrap(x))\n-        }\n-    }\n-}\n-\n-/// Converts a `chan` into a `shared_chan`.\n-pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n-    private::exclusive(c)\n-}\n-\n-/// Receive a message from one of two endpoints.\n-pub trait Select2<T:Owned,U:Owned> {\n-    /// Receive a message or return `None` if a connection closes.\n-    fn try_select() -> Either<Option<T>, Option<U>>;\n-    /// Receive a message or fail if a connection closes.\n-    fn select() -> Either<T, U>;\n-}\n-\n-impl<T: Owned,\n-     U: Owned,\n-     Left: Selectable + GenericPort<T>,\n-     Right: Selectable + GenericPort<U>>\n-     Select2<T,U> for (Left, Right) {\n-    fn select() -> Either<T, U> {\n-        match self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.recv()),\n-            Right(()) => Right(rp.recv())\n-          }\n-        }\n-    }\n-\n-    fn try_select() -> Either<Option<T>, Option<U>> {\n-        match self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.try_recv()),\n-            Right(()) => Right(rp.try_recv())\n-          }\n-        }\n-    }\n-}\n-\n-proto! oneshot (\n-    Oneshot:send<T:Owned> {\n-        send(T) -> !\n-    }\n-)\n-\n-/// The send end of a oneshot pipe.\n-pub type ChanOne<T> = oneshot::client::Oneshot<T>;\n-/// The receive end of a oneshot pipe.\n-pub type PortOne<T> = oneshot::server::Oneshot<T>;\n-\n-/// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-pub fn oneshot<T:Owned>() -> (PortOne<T>, ChanOne<T>) {\n-    let (chan, port) = oneshot::init();\n-    (port, chan)\n-}\n-\n-impl<T:Owned> PortOne<T> {\n-    fn recv(self) -> T { recv_one(self) }\n-    fn try_recv(self) -> Option<T> { try_recv_one(self) }\n-}\n-\n-impl<T:Owned> ChanOne<T> {\n-    fn send(self, data: T) { send_one(self, data) }\n-    fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n-}\n-\n-/**\n- * Receive a message from a oneshot pipe, failing if the connection was\n- * closed.\n- */\n-pub fn recv_one<T:Owned>(port: PortOne<T>) -> T {\n-    let oneshot::send(message) = recv(port);\n-    message\n-}\n-\n-/// Receive a message from a oneshot pipe unless the connection was closed.\n-pub fn try_recv_one<T:Owned> (port: PortOne<T>) -> Option<T> {\n-    let message = try_recv(port);\n-\n-    if message.is_none() { None }\n-    else {\n-        let oneshot::send(message) = option::unwrap(message);\n-        Some(message)\n-    }\n-}\n-\n-/// Send a message on a oneshot pipe, failing if the connection was closed.\n-pub fn send_one<T:Owned>(chan: ChanOne<T>, data: T) {\n-    oneshot::client::send(chan, data);\n-}\n-\n-/**\n- * Send a message on a oneshot pipe, or return false if the connection was\n- * closed.\n- */\n-pub fn try_send_one<T:Owned>(chan: ChanOne<T>, data: T)\n-        -> bool {\n-    oneshot::client::try_send(chan, data).is_some()\n-}\n-\n pub mod rt {\n     use option::{None, Option, Some};\n \n@@ -1298,13 +963,13 @@ pub mod rt {\n #[cfg(test)]\n pub mod test {\n     use either::{Either, Left, Right};\n-    use pipes::{Chan, Port, oneshot, recv_one, stream};\n-    use pipes;\n+    use comm::{Chan, Port, oneshot, recv_one, stream, Select2,\n+               GenericPort, GenericChan, Peekable};\n \n     #[test]\n     pub fn test_select2() {\n-        let (p1, c1) = pipes::stream();\n-        let (p2, c2) = pipes::stream();\n+        let (p1, c1) = stream();\n+        let (p2, c2) = stream();\n \n         c1.send(~\"abc\");\n "}, {"sha": "d0a16f7875b5cfb1deb6b25f0bc07eb06c245b79", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -68,7 +68,7 @@ pub use ops;\n pub use option;\n pub use os;\n pub use path;\n-pub use pipes;\n+pub use comm;\n pub use private;\n pub use ptr;\n pub use rand;"}, {"sha": "2738e5564fc18e84ef577d6409b8c12dbc78a3b5", "filename": "src/libcore/private.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -14,7 +14,7 @@ use cast;\n use iter;\n use libc;\n use option;\n-use pipes::{GenericChan, GenericPort};\n+use comm::{GenericChan, GenericPort};\n use prelude::*;\n use ptr;\n use result;\n@@ -59,7 +59,7 @@ The executing thread has no access to a task pointer and will be using\n a normal large stack.\n */\n pub unsafe fn run_in_bare_thread(f: ~fn()) {\n-    let (port, chan) = pipes::stream();\n+    let (port, chan) = comm::stream();\n     // FIXME #4525: Unfortunate that this creates an extra scheduler but it's\n     // necessary since rust_raw_thread_join_delete is blocking\n     do task::spawn_sched(task::SingleThreaded) {\n@@ -110,7 +110,7 @@ fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n // An unwrapper uses this protocol to communicate with the \"other\" task that\n // drops the last refcount on an arc. Unfortunately this can't be a proper\n // pipe protocol because the unwrapper has to access both stages at once.\n-type UnwrapProto = ~mut Option<(pipes::ChanOne<()>,  pipes::PortOne<bool>)>;\n+type UnwrapProto = ~mut Option<(comm::ChanOne<()>,  comm::PortOne<bool>)>;\n \n struct ArcData<T> {\n     mut count:     libc::intptr_t,\n@@ -143,9 +143,9 @@ struct ArcDestruct<T> {\n                             cast::reinterpret_cast(&data.unwrapper);\n                         let (message, response) = option::swap_unwrap(p);\n                         // Send 'ready' and wait for a response.\n-                        pipes::send_one(message, ());\n+                        comm::send_one(message, ());\n                         // Unkillable wait. Message guaranteed to come.\n-                        if pipes::recv_one(response) {\n+                        if comm::recv_one(response) {\n                             // Other task got the data.\n                             cast::forget(data);\n                         } else {\n@@ -172,30 +172,30 @@ pub unsafe fn unwrap_shared_mutable_state<T:Owned>(rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n         mut ptr:      Option<~ArcData<T>>,\n-        mut response: Option<pipes::ChanOne<bool>>,\n+        mut response: Option<comm::ChanOne<bool>>,\n         drop {\n             unsafe {\n                 let response = option::swap_unwrap(&mut self.response);\n                 // In case we get killed early, we need to tell the person who\n                 // tried to wake us whether they should hand-off the data to\n                 // us.\n                 if task::failing() {\n-                    pipes::send_one(response, false);\n+                    comm::send_one(response, false);\n                     // Either this swap_unwrap or the one below (at \"Got\n                     // here\") ought to run.\n                     cast::forget(option::swap_unwrap(&mut self.ptr));\n                 } else {\n                     assert self.ptr.is_none();\n-                    pipes::send_one(response, true);\n+                    comm::send_one(response, true);\n                 }\n             }\n         }\n     }\n \n     do task::unkillable {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&rc.data);\n-        let (p1,c1) = pipes::oneshot(); // ()\n-        let (p2,c2) = pipes::oneshot(); // bool\n+        let (p1,c1) = comm::oneshot(); // ()\n+        let (p2,c2) = comm::oneshot(); // bool\n         let server: UnwrapProto = ~mut Some((c1,p2));\n         let serverp: int = cast::transmute(server);\n         // Try to put our server end in the unwrapper slot.\n@@ -218,7 +218,7 @@ pub unsafe fn unwrap_shared_mutable_state<T:Owned>(rc: SharedMutableState<T>)\n                                   response: Some(c2) };\n                 let mut p1 = Some(p1); // argh\n                 do task::rekillable {\n-                    pipes::recv_one(option::swap_unwrap(&mut p1));\n+                    comm::recv_one(option::swap_unwrap(&mut p1));\n                 }\n                 // Got here. Back in the 'unkillable' without getting killed.\n                 // Recover ownership of ptr, then take the data out.\n@@ -410,7 +410,7 @@ pub mod tests {\n     use core::option::{None, Some};\n \n     use option;\n-    use pipes;\n+    use comm;\n     use private::{exclusive, unwrap_exclusive};\n     use result;\n     use task;\n@@ -427,7 +427,7 @@ pub mod tests {\n \n         for uint::range(0, num_tasks) |_i| {\n             let total = total.clone();\n-            let (port, chan) = pipes::stream();\n+            let (port, chan) = comm::stream();\n             futures.push(port);\n \n             do task::spawn || {"}, {"sha": "f3df8ce72f146cd0b81f773355dce6720b8a77db", "filename": "src/libcore/private/weak_task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fprivate%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Fprivate%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fweak_task.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -22,8 +22,8 @@ use option::{Some, None, swap_unwrap};\n use private::at_exit::at_exit;\n use private::global::global_data_clone_create;\n use private::finally::Finally;\n-use pipes::{Port, Chan, SharedChan, GenericChan, GenericPort,\n-            GenericSmartChan, stream};\n+use comm::{Port, Chan, SharedChan, GenericChan,\n+           GenericPort, GenericSmartChan, stream};\n use task::{Task, task, spawn};\n use task::rt::{task_id, get_task_id};\n use hashmap::linear::LinearMap;\n@@ -186,7 +186,7 @@ fn test_wait_for_signal_many() {\n \n #[test]\n fn test_select_stream_and_oneshot() {\n-    use pipes::select2i;\n+    use comm::select2i;\n     use either::{Left, Right};\n \n     let (port, chan) = stream();"}, {"sha": "4e2337b83313348ef63b8237286502c529b7884a", "filename": "src/libcore/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -14,7 +14,7 @@ use io;\n use io::ReaderUtil;\n use libc;\n use libc::{pid_t, c_void, c_int};\n-use pipes::{stream, SharedChan, GenericChan, GenericPort};\n+use comm::{stream, SharedChan, GenericChan, GenericPort};\n use option::{Some, None};\n use os;\n use prelude::*;"}, {"sha": "336e686193b91b3ff31792acbe61b97bd1e3a68c", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -40,7 +40,7 @@ use iter;\n use libc;\n use option;\n use result::Result;\n-use pipes::{stream, Chan, GenericChan, GenericPort, Port, SharedChan};\n+use comm::{stream, Chan, GenericChan, GenericPort, Port, SharedChan};\n use pipes;\n use prelude::*;\n use ptr;\n@@ -1109,7 +1109,7 @@ fn test_unkillable() {\n #[ignore(cfg(windows))]\n #[should_fail]\n fn test_unkillable_nested() {\n-    let (po, ch) = pipes::stream();\n+    let (po, ch) = comm::stream();\n \n     // We want to do this after failing\n     do spawn_unlinked || {\n@@ -1175,7 +1175,7 @@ fn test_child_doesnt_ref_parent() {\n \n #[test]\n fn test_sched_thread_per_core() {\n-    let (port, chan) = pipes::stream();\n+    let (port, chan) = comm::stream();\n \n     do spawn_sched(ThreadPerCore) || {\n         unsafe {\n@@ -1191,7 +1191,7 @@ fn test_sched_thread_per_core() {\n \n #[test]\n fn test_spawn_thread_on_demand() {\n-    let (port, chan) = pipes::stream();\n+    let (port, chan) = comm::stream();\n \n     do spawn_sched(ManualThreads(2)) || {\n         unsafe {\n@@ -1200,7 +1200,7 @@ fn test_spawn_thread_on_demand() {\n             let running_threads = rt::rust_sched_current_nonlazy_threads();\n             assert(running_threads as int == 1);\n \n-            let (port2, chan2) = pipes::stream();\n+            let (port2, chan2) = comm::stream();\n \n             do spawn_sched(CurrentScheduler) || {\n                 chan2.send(());"}, {"sha": "e77af820079b6acd503e3b0e0bc8fc784add7efa", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -75,7 +75,7 @@\n use cast;\n use container::Map;\n use option;\n-use pipes::{Chan, GenericChan, GenericPort, Port, stream};\n+use comm::{Chan, GenericChan, GenericPort, Port, stream};\n use pipes;\n use prelude::*;\n use private;\n@@ -702,7 +702,7 @@ fn test_spawn_raw_unsupervise() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_spawn_raw_notify_success() {\n-    let (notify_po, notify_ch) = pipes::stream();\n+    let (notify_po, notify_ch) = comm::stream();\n \n     let opts = task::TaskOpts {\n         notify_chan: Some(notify_ch),\n@@ -717,7 +717,7 @@ fn test_spawn_raw_notify_success() {\n #[ignore(cfg(windows))]\n fn test_spawn_raw_notify_failure() {\n     // New bindings for these\n-    let (notify_po, notify_ch) = pipes::stream();\n+    let (notify_po, notify_ch) = comm::stream();\n \n     let opts = task::TaskOpts {\n         linked: false,"}, {"sha": "01758a1845d7c5664532d78750a272497607ed0a", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -314,7 +314,7 @@ fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n pub fn monitor(+f: fn~(diagnostic::Emitter)) {\n-    use core::pipes::*;\n+    use core::comm::*;\n     use std::cell::Cell;\n     let (p, ch) = stream();\n     let ch = SharedChan(ch);"}, {"sha": "fff2e189eb85c565aa39e3c5c49cebf27cf70215", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -23,7 +23,7 @@ use parse;\n use util;\n use std::cell::Cell;\n \n-use core::pipes::{stream, Chan, SharedChan, Port};\n+use core::comm::{stream, Chan, SharedChan, Port};\n use core::vec;\n use core::ops::Drop;\n use rustc::back::link;"}, {"sha": "45a8aa9fd2920c112e3c9fee0b5e0fd806d656fe", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -20,12 +20,12 @@ use core::io::ReaderUtil;\n use core::io;\n use core::libc;\n use core::os;\n-use core::pipes;\n+use core::comm;\n use core::result;\n use core::run;\n use core::str;\n use core::task;\n-use core::pipes::*;\n+use core::comm::*;\n use std::future;\n use syntax;\n \n@@ -128,12 +128,12 @@ fn pandoc_writer(\n         os::close(pipe_err.out);\n         os::close(pipe_in.out);\n \n-        let (stdout_po, stdout_ch) = pipes::stream();\n+        let (stdout_po, stdout_ch) = comm::stream();\n         do task::spawn_sched(task::SingleThreaded) || {\n             stdout_ch.send(readclose(pipe_out.in));\n         }\n \n-        let (stderr_po, stderr_ch) = pipes::stream();\n+        let (stderr_po, stderr_ch) = comm::stream();\n         do task::spawn_sched(task::SingleThreaded) || {\n             stderr_ch.send(readclose(pipe_err.in));\n         }\n@@ -296,7 +296,7 @@ pub fn future_writer_factory(\n     let (markdown_po, markdown_ch) = stream();\n     let markdown_ch = SharedChan(markdown_ch);\n     let writer_factory = fn~(page: doc::Page) -> Writer {\n-        let (writer_po, writer_ch) = pipes::stream();\n+        let (writer_po, writer_ch) = comm::stream();\n         let markdown_ch = markdown_ch.clone();\n         do task::spawn || {\n             let (writer, future) = future_writer();\n@@ -311,7 +311,7 @@ pub fn future_writer_factory(\n }\n \n fn future_writer() -> (Writer, future::Future<~str>) {\n-    let (port, chan) = pipes::stream();\n+    let (port, chan) = comm::stream();\n     let writer = fn~(instr: WriteInstr) {\n         chan.send(copy instr);\n     };"}, {"sha": "2a2c388864723d43826f31da005ddf4653b0f912", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -30,7 +30,7 @@ use util;\n \n use core::option;\n use core::vec;\n-use core::pipes::*;\n+use core::comm::*;\n use syntax::ast;\n \n pub fn mk_pass(output_style: config::OutputStyle) -> Pass {"}, {"sha": "61b5ffd845f892fe2d32db9f7fdd8fbf44fcb5a6", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -507,10 +507,10 @@ mod tests {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = arc::ARC(v);\n \n-        let (p, c) = pipes::stream();\n+        let (p, c) = comm::stream();\n \n         do task::spawn() || {\n-            let p = pipes::PortSet();\n+            let p = comm::PortSet();\n             c.send(p.chan());\n \n             let arc_v = p.recv();\n@@ -531,18 +531,18 @@ mod tests {\n     pub fn test_mutex_arc_condvar() {\n         let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n-        let (p,c) = pipes::oneshot();\n+        let (p,c) = comm::oneshot();\n         let (c,p) = (~mut Some(c), ~mut Some(p));\n         do task::spawn || {\n             // wait until parent gets in\n-            pipes::recv_one(option::swap_unwrap(p));\n+            comm::recv_one(option::swap_unwrap(p));\n             do arc2.access_cond |state, cond| {\n                 *state = true;\n                 cond.signal();\n             }\n         }\n         do arc.access_cond |state, cond| {\n-            pipes::send_one(option::swap_unwrap(c), ());\n+            comm::send_one(option::swap_unwrap(c), ());\n             assert !*state;\n             while !*state {\n                 cond.wait();\n@@ -553,7 +553,7 @@ mod tests {\n     pub fn test_arc_condvar_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n-        let (p, c) = pipes::stream();\n+        let (p, c) = comm::stream();\n \n         do task::spawn_unlinked || {\n             let _ = p.recv();\n@@ -587,7 +587,7 @@ mod tests {\n     pub fn test_mutex_arc_unwrap_poison() {\n         let arc = MutexARC(1);\n         let arc2 = ~(&arc).clone();\n-        let (p, c) = pipes::stream();\n+        let (p, c) = comm::stream();\n         do task::spawn || {\n             do arc2.access |one| {\n                 c.send(());\n@@ -685,7 +685,7 @@ mod tests {\n     pub fn test_rw_arc() {\n         let arc = ~RWARC(0);\n         let arc2 = ~arc.clone();\n-        let (p,c) = pipes::stream();\n+        let (p,c) = comm::stream();\n \n         do task::spawn || {\n             do arc2.write |num| {\n@@ -731,7 +731,7 @@ mod tests {\n         // Reader tasks\n         let mut reader_convos = ~[];\n         for 10.times {\n-            let ((rp1,rc1),(rp2,rc2)) = (pipes::stream(),pipes::stream());\n+            let ((rp1,rc1),(rp2,rc2)) = (comm::stream(),comm::stream());\n             reader_convos.push((rc1, rp2));\n             let arcn = ~arc.clone();\n             do task::spawn || {\n@@ -745,7 +745,7 @@ mod tests {\n \n         // Writer task\n         let arc2 = ~arc.clone();\n-        let ((wp1,wc1),(wp2,wc2)) = (pipes::stream(),pipes::stream());\n+        let ((wp1,wc1),(wp2,wc2)) = (comm::stream(),comm::stream());\n         do task::spawn || {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {"}, {"sha": "02875739ebaf933dff268146a845d7c5501b3f54", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -14,8 +14,8 @@ Higher level communication abstractions.\n \n */\n \n-use core::pipes::{GenericChan, GenericSmartChan, GenericPort};\n-use core::pipes::{Chan, Port, Selectable, Peekable};\n+use core::comm::{GenericChan, GenericSmartChan, GenericPort};\n+use core::comm::{Chan, Port, Selectable, Peekable};\n use core::pipes;\n use core::prelude::*;\n \n@@ -63,8 +63,8 @@ impl<T:Owned,U:Owned> Selectable for DuplexStream<T, U> {\n pub fn DuplexStream<T:Owned,U:Owned>()\n     -> (DuplexStream<T, U>, DuplexStream<U, T>)\n {\n-    let (p1, c2) = pipes::stream();\n-    let (p2, c1) = pipes::stream();\n+    let (p1, c2) = comm::stream();\n+    let (p2, c1) = comm::stream();\n     (DuplexStream {\n         chan: c1,\n         port: p1"}, {"sha": "13c0bbe1a674c732822ef503442ca845ba929d99", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -49,8 +49,8 @@ block the scheduler thread, so will their pipes.\n \n // The basic send/recv interface FlatChan and PortChan will implement\n use core::io;\n-use core::pipes::GenericChan;\n-use core::pipes::GenericPort;\n+use core::comm::GenericChan;\n+use core::comm::GenericPort;\n use core::pipes;\n use core::prelude::*;\n use core::sys::size_of;\n@@ -95,8 +95,8 @@ pub mod serial {\n     use flatpipes::{FlatPort, FlatChan};\n \n     use core::io::{Reader, Writer};\n-    use core::pipes::{Port, Chan};\n-    use core::pipes;\n+    use core::comm::{Port, Chan};\n+    use core::comm;\n \n     pub type ReaderPort<T, R> = FlatPort<\n         T, DeserializingUnflattener<DefaultDecoder, T>,\n@@ -154,7 +154,7 @@ pub mod serial {\n     pub fn pipe_stream<T: Encodable<DefaultEncoder> +\n                           Decodable<DefaultDecoder>>(\n                           ) -> (PipePort<T>, PipeChan<T>) {\n-        let (port, chan) = pipes::stream();\n+        let (port, chan) = comm::stream();\n         return (pipe_port(port), pipe_chan(chan));\n     }\n }\n@@ -177,8 +177,8 @@ pub mod pod {\n     use flatpipes::{FlatPort, FlatChan};\n \n     use core::io::{Reader, Writer};\n-    use core::pipes::{Port, Chan};\n-    use core::pipes;\n+    use core::comm::{Port, Chan};\n+    use core::comm;\n     use core::prelude::*;\n \n     pub type ReaderPort<T, R> =\n@@ -222,7 +222,7 @@ pub mod pod {\n \n     /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n     pub fn pipe_stream<T:Copy + Owned>() -> (PipePort<T>, PipeChan<T>) {\n-        let (port, chan) = pipes::stream();\n+        let (port, chan) = comm::stream();\n         return (pipe_port(port), pipe_chan(chan));\n     }\n \n@@ -507,7 +507,7 @@ pub mod bytepipes {\n     use flatpipes::{ByteChan, BytePort};\n \n     use core::io::{Writer, Reader, ReaderUtil};\n-    use core::pipes::{Port, Chan};\n+    use core::comm::{Port, Chan};\n     use core::pipes;\n     use core::prelude::*;\n \n@@ -564,12 +564,12 @@ pub mod bytepipes {\n     }\n \n     pub struct PipeBytePort {\n-        port: pipes::Port<~[u8]>,\n+        port: comm::Port<~[u8]>,\n         mut buf: ~[u8]\n     }\n \n     pub struct PipeByteChan {\n-        chan: pipes::Chan<~[u8]>\n+        chan: comm::Chan<~[u8]>\n     }\n \n     pub impl BytePort for PipeBytePort {\n@@ -777,12 +777,12 @@ mod test {\n         use uv;\n \n         // Indicate to the client task that the server is listening\n-        let (begin_connect_port, begin_connect_chan) = pipes::stream();\n+        let (begin_connect_port, begin_connect_chan) = comm::stream();\n         // The connection is sent from the server task to the receiver task\n         // to handle the connection\n-        let (accept_port, accept_chan) = pipes::stream();\n+        let (accept_port, accept_chan) = comm::stream();\n         // The main task will wait until the test is over to proceed\n-        let (finish_port, finish_chan) = pipes::stream();\n+        let (finish_port, finish_chan) = comm::stream();\n \n         let addr0 = ip::v4::parse_addr(\"127.0.0.1\");\n \n@@ -803,7 +803,7 @@ mod test {\n                 }) |new_conn, kill_ch| {\n \n                 // Incoming connection. Send it to the receiver task to accept\n-                let (res_port, res_chan) = pipes::stream();\n+                let (res_port, res_chan) = comm::stream();\n                 accept_chan.send((new_conn, res_chan));\n                 // Wait until the connection is accepted\n                 res_port.recv();\n@@ -894,7 +894,7 @@ mod test {\n \n         fn pipe_port_loader(bytes: ~[u8]\n                            ) -> pod::PipePort<int> {\n-            let (port, chan) = pipes::stream();\n+            let (port, chan) = comm::stream();\n             if !bytes.is_empty() {\n                 chan.send(bytes);\n             }"}, {"sha": "b6b001727a45a8af1723c846bac9558507b8eb95", "filename": "src/libstd/future.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -25,7 +25,8 @@ use core::cast::copy_lifetime;\n use core::cast;\n use core::either::Either;\n use core::option;\n-use core::pipes::{recv, oneshot, ChanOne, PortOne, send_one, recv_one};\n+use core::comm::{oneshot, ChanOne, PortOne, send_one, recv_one};\n+use core::pipes::recv;\n use core::prelude::*;\n use core::task;\n \n@@ -150,7 +151,7 @@ pub mod test {\n \n     use future::*;\n \n-    use core::pipes::oneshot;\n+    use core::comm::oneshot;\n     use core::task;\n \n     #[test]"}, {"sha": "bc17cb0bfe9b6f2b3ee5dcb2dced4c512770bb75", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -12,7 +12,7 @@\n \n use core::libc;\n use core::prelude::*;\n-use core::pipes::{stream, SharedChan};\n+use core::comm::{stream, SharedChan};\n use core::ptr;\n use core::result;\n use core::str;"}, {"sha": "8835cdfb105eb57cc5e91e7fcb217bb865d7315e", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -24,7 +24,7 @@ use core::io::{Reader, ReaderUtil, Writer};\n use core::io;\n use core::libc::size_t;\n use core::libc;\n-use core::pipes::{stream, Chan, Port, SharedChan};\n+use core::comm::{stream, Chan, Port, SharedChan};\n use core::prelude::*;\n use core::ptr;\n use core::result::{Result};\n@@ -1441,7 +1441,7 @@ pub mod test {\n     use uv;\n \n     use core::io;\n-    use core::pipes::{stream, Chan, Port, SharedChan};\n+    use core::comm::{stream, Chan, Port, SharedChan};\n     use core::prelude::*;\n     use core::result;\n     use core::str;"}, {"sha": "016847a5bfd7d9b303db6186033c44547e6ef740", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -30,16 +30,16 @@ use core::vec;\n \n // Each waiting task receives on one of these.\n #[doc(hidden)]\n-type WaitEnd = pipes::PortOne<()>;\n+type WaitEnd = comm::PortOne<()>;\n #[doc(hidden)]\n-type SignalEnd = pipes::ChanOne<()>;\n+type SignalEnd = comm::ChanOne<()>;\n // A doubly-ended queue of waiting tasks.\n #[doc(hidden)]\n-struct Waitqueue { head: pipes::Port<SignalEnd>,\n-                   tail: pipes::Chan<SignalEnd> }\n+struct Waitqueue { head: comm::Port<SignalEnd>,\n+                   tail: comm::Chan<SignalEnd> }\n \n fn new_waitqueue() -> Waitqueue {\n-    let (block_head, block_tail) = pipes::stream();\n+    let (block_head, block_tail) = comm::stream();\n     Waitqueue { head: block_head, tail: block_tail }\n }\n \n@@ -50,7 +50,7 @@ fn signal_waitqueue(q: &Waitqueue) -> bool {\n     if q.head.peek() {\n         // Pop and send a wakeup signal. If the waiter was killed, its port\n         // will have closed. Keep trying until we get a live task.\n-        if pipes::try_send_one(q.head.recv(), ()) {\n+        if comm::try_send_one(q.head.recv(), ()) {\n             true\n         } else {\n             signal_waitqueue(q)\n@@ -64,7 +64,7 @@ fn signal_waitqueue(q: &Waitqueue) -> bool {\n fn broadcast_waitqueue(q: &Waitqueue) -> uint {\n     let mut count = 0;\n     while q.head.peek() {\n-        if pipes::try_send_one(q.head.recv(), ()) {\n+        if comm::try_send_one(q.head.recv(), ()) {\n             count += 1;\n         }\n     }\n@@ -107,7 +107,7 @@ impl<Q:Owned> &Sem<Q> {\n                 state.count -= 1;\n                 if state.count < 0 {\n                     // Create waiter nobe.\n-                    let (WaitEnd, SignalEnd) = pipes::oneshot();\n+                    let (WaitEnd, SignalEnd) = comm::oneshot();\n                     // Tell outer scope we need to block.\n                     waiter_nobe = Some(WaitEnd);\n                     // Enqueue ourself.\n@@ -119,7 +119,7 @@ impl<Q:Owned> &Sem<Q> {\n         /* for 1000.times { task::yield(); } */\n         // Need to wait outside the exclusive.\n         if waiter_nobe.is_some() {\n-            let _ = pipes::recv_one(option::unwrap(waiter_nobe));\n+            let _ = comm::recv_one(option::unwrap(waiter_nobe));\n         }\n     }\n     fn release() {\n@@ -214,7 +214,7 @@ impl &Condvar {\n      */\n     fn wait_on(condvar_id: uint) {\n         // Create waiter nobe.\n-        let (WaitEnd, SignalEnd) = pipes::oneshot();\n+        let (WaitEnd, SignalEnd) = comm::oneshot();\n         let mut WaitEnd   = Some(WaitEnd);\n         let mut SignalEnd = Some(SignalEnd);\n         let mut reacquire = None;\n@@ -250,7 +250,7 @@ impl &Condvar {\n             // Unconditionally \"block\". (Might not actually block if a\n             // signaller already sent -- I mean 'unconditionally' in contrast\n             // with acquire().)\n-            let _ = pipes::recv_one(option::swap_unwrap(&mut WaitEnd));\n+            let _ = comm::recv_one(option::swap_unwrap(&mut WaitEnd));\n         }\n \n         // This is needed for a failing condition variable to reacquire the\n@@ -749,7 +749,7 @@ mod tests {\n     #[test]\n     pub fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n-        let (p,c) = pipes::stream();\n+        let (p,c) = comm::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n         do task::spawn || {\n@@ -761,7 +761,7 @@ mod tests {\n         let _ = p.recv();\n \n         /* Parent waits and child signals */\n-        let (p,c) = pipes::stream();\n+        let (p,c) = comm::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n         do task::spawn || {\n@@ -778,8 +778,8 @@ mod tests {\n         // time, and shake hands.\n         let s = ~semaphore(2);\n         let s2 = ~s.clone();\n-        let (p1,c1) = pipes::stream();\n-        let (p2,c2) = pipes::stream();\n+        let (p1,c1) = comm::stream();\n+        let (p2,c2) = comm::stream();\n         do task::spawn || {\n             do s2.access {\n                 let _ = p2.recv();\n@@ -798,7 +798,7 @@ mod tests {\n         do task::spawn_sched(task::ManualThreads(1)) {\n             let s = ~semaphore(1);\n             let s2 = ~s.clone();\n-            let (p,c) = pipes::stream();\n+            let (p,c) = comm::stream();\n             let child_data = ~mut Some((s2, c));\n             do s.access {\n                 let (s2,c) = option::swap_unwrap(child_data);\n@@ -820,7 +820,7 @@ mod tests {\n     pub fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n-        let (p,c) = pipes::stream();\n+        let (p,c) = comm::stream();\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n         let mut sharedstate = ~0;\n@@ -863,7 +863,7 @@ mod tests {\n             cond.wait();\n         }\n         // Parent wakes up child\n-        let (port,chan) = pipes::stream();\n+        let (port,chan) = comm::stream();\n         let m3 = ~m.clone();\n         do task::spawn || {\n             do m3.lock_cond |cond| {\n@@ -886,7 +886,7 @@ mod tests {\n \n         for num_waiters.times {\n             let mi = ~m.clone();\n-            let (port, chan) = pipes::stream();\n+            let (port, chan) = comm::stream();\n             ports.push(port);\n             do task::spawn || {\n                 do mi.lock_cond |cond| {\n@@ -948,7 +948,7 @@ mod tests {\n         let m2 = ~m.clone();\n \n         let result: result::Result<(),()> = do task::try || {\n-            let (p,c) = pipes::stream();\n+            let (p,c) = comm::stream();\n             do task::spawn || { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::yield();\n@@ -970,12 +970,12 @@ mod tests {\n     pub fn test_mutex_killed_broadcast() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n-        let (p,c) = pipes::stream();\n+        let (p,c) = comm::stream();\n \n         let result: result::Result<(),()> = do task::try || {\n             let mut sibling_convos = ~[];\n             for 2.times {\n-                let (p,c) = pipes::stream();\n+                let (p,c) = comm::stream();\n                 let c = ~mut Some(c);\n                 sibling_convos.push(p);\n                 let mi = ~m2.clone();\n@@ -1004,7 +1004,7 @@ mod tests {\n             assert woken == 0;\n         }\n         struct SendOnFailure {\n-            c: pipes::Chan<()>,\n+            c: comm::Chan<()>,\n         }\n \n         impl Drop for SendOnFailure {\n@@ -1013,7 +1013,7 @@ mod tests {\n             }\n         }\n \n-        fn SendOnFailure(c: pipes::Chan<()>) -> SendOnFailure {\n+        fn SendOnFailure(c: comm::Chan<()>) -> SendOnFailure {\n             SendOnFailure {\n                 c: c\n             }\n@@ -1038,7 +1038,7 @@ mod tests {\n         let result = do task::try {\n             let m = ~mutex_with_condvars(2);\n             let m2 = ~m.clone();\n-            let (p,c) = pipes::stream();\n+            let (p,c) = comm::stream();\n             do task::spawn || {\n                 do m2.lock_cond |cond| {\n                     c.send(());\n@@ -1099,7 +1099,7 @@ mod tests {\n                                  mode2: RWlockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n-        let (p,c) = pipes::stream();\n+        let (p,c) = comm::stream();\n         let x2 = ~x.clone();\n         let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(&(*sharedstate));\n@@ -1146,8 +1146,8 @@ mod tests {\n                                  make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = ~x.clone();\n-        let (p1,c1) = pipes::stream();\n-        let (p2,c2) = pipes::stream();\n+        let (p1,c1) = comm::stream();\n+        let (p2,c2) = comm::stream();\n         do task::spawn || {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n@@ -1212,7 +1212,7 @@ mod tests {\n             cond.wait();\n         }\n         // Parent wakes up child\n-        let (port,chan) = pipes::stream();\n+        let (port,chan) = comm::stream();\n         let x3 = ~x.clone();\n         do task::spawn || {\n             do x3.write_cond |cond| {\n@@ -1249,7 +1249,7 @@ mod tests {\n \n         for num_waiters.times {\n             let xi = ~x.clone();\n-            let (port, chan) = pipes::stream();\n+            let (port, chan) = comm::stream();\n             ports.push(port);\n             do task::spawn || {\n                 do lock_cond(xi, dg1) |cond| {"}, {"sha": "6b8ea8a6ef42c13e8382855eec923f745127ff2f", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -12,7 +12,7 @@\n /// parallelism.\n \n use core::io;\n-use core::pipes::{Chan, Port};\n+use core::comm::{Chan, Port};\n use core::pipes;\n use core::prelude::*;\n use core::task::{SchedMode, SingleThreaded};\n@@ -47,7 +47,7 @@ pub impl<T> TaskPool<T> {\n         assert n_tasks >= 1;\n \n         let channels = do vec::from_fn(n_tasks) |i| {\n-            let (port, chan) = pipes::stream::<Msg<T>>();\n+            let (port, chan) = comm::stream::<Msg<T>>();\n             let init_fn = init_fn_factory();\n \n             let task_body: ~fn() = || {"}, {"sha": "e14e9665216f66c2e86e414a660eea6e8511877b", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -27,7 +27,7 @@ use core::either;\n use core::io::WriterUtil;\n use core::io;\n use core::libc::size_t;\n-use core::pipes::{stream, Chan, Port, SharedChan};\n+use core::comm::{stream, Chan, Port, SharedChan};\n use core::option;\n use core::prelude::*;\n use core::result;\n@@ -794,7 +794,7 @@ mod tests {\n     use test::{TestOpts, run_test};\n \n     use core::either;\n-    use core::pipes::{stream, SharedChan};\n+    use core::comm::{stream, SharedChan};\n     use core::option;\n     use core::vec;\n "}, {"sha": "b711825aecf79d61632894df231184b20edab513", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -18,7 +18,7 @@ use core::either;\n use core::libc;\n use core::libc::c_void;\n use core::cast::transmute;\n-use core::pipes::{stream, Chan, SharedChan, Port, select2i};\n+use core::comm::{stream, Chan, SharedChan, Port, select2i};\n use core::prelude::*;\n use core::ptr;\n use core;"}, {"sha": "401cecf8811417a19c0f1bcfe4a012b2cf846813", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -17,7 +17,7 @@ use uv_iotask::{IoTask, spawn_iotask};\n \n use core::either::{Left, Right};\n use core::libc;\n-use core::pipes::{Port, Chan, SharedChan, select2i};\n+use core::comm::{Port, Chan, SharedChan, select2i};\n use core::private::global::{global_data_clone_create,\n                             global_data_clone};\n use core::private::weak_task::weaken_task;\n@@ -133,7 +133,7 @@ mod test {\n     use core::task;\n     use core::cast::transmute;\n     use core::libc::c_void;\n-    use core::pipes::{stream, SharedChan, Chan};\n+    use core::comm::{stream, SharedChan, Chan};\n \n     extern fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) {\n         unsafe {"}, {"sha": "52956f152fe2bb5e073d63f67bc01e2f88d56eb8", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -19,7 +19,7 @@ use ll = uv_ll;\n \n use core::libc::c_void;\n use core::libc;\n-use core::pipes::{stream, Port, Chan, SharedChan};\n+use core::comm::{stream, Port, Chan, SharedChan};\n use core::prelude::*;\n use core::ptr::addr_of;\n use core::task::TaskBuilder;"}, {"sha": "dd54620c83d28cde3d0ace024138aed2bc6e7e33", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -39,7 +39,7 @@ use core::ptr::to_unsafe_ptr;\n use core::ptr;\n use core::str;\n use core::vec;\n-use core::pipes::{stream, Chan, SharedChan, Port};\n+use core::comm::{stream, Chan, SharedChan, Port};\n \n // libuv struct mappings\n pub struct uv_ip4_addr {"}, {"sha": "8ce68a41f81bf09d446af8a15f8a75bc2b555647", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -19,7 +19,8 @@ use core::cmp;\n use core::either::{Either, Left, Right};\n use core::io;\n use core::option;\n-use core::pipes::{recv, oneshot, PortOne, send_one};\n+use core::comm::{oneshot, PortOne, send_one};\n+use core::pipes::recv;\n use core::prelude::*;\n use core::result;\n use core::run;"}, {"sha": "e8e4c939907404938230ea18f13ace388dfbe746", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -78,10 +78,10 @@ pub impl gen_send for message {\n                 };\n \n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n-                body += fmt!(\"let %s = ::pipes::SendPacketBuffered(\\\n+                body += fmt!(\"let %s = ::core::pipes::SendPacketBuffered(\\\n                               ::ptr::addr_of(&(b.buffer.data.%s)));\\n\",\n                              sp, next.name);\n-                body += fmt!(\"let %s = ::pipes::RecvPacketBuffered(\\\n+                body += fmt!(\"let %s = ::core::pipes::RecvPacketBuffered(\\\n                               ::ptr::addr_of(&(b.buffer.data.%s)));\\n\",\n                              rp, next.name);\n             }\n@@ -93,7 +93,7 @@ pub impl gen_send for message {\n                   (recv, recv) => \"(c, s)\"\n                 };\n \n-                body += fmt!(\"let %s = ::pipes::entangle();\\n\", pat);\n+                body += fmt!(\"let %s = ::core::pipes::entangle();\\n\", pat);\n             }\n             body += fmt!(\"let message = %s(%s);\\n\",\n                          self.name(),\n@@ -102,14 +102,14 @@ pub impl gen_send for message {\n                              ~\"s\"), ~\", \"));\n \n             if !try {\n-                body += fmt!(\"::pipes::send(pipe, message);\\n\");\n+                body += fmt!(\"::core::pipes::send(pipe, message);\\n\");\n                 // return the new channel\n                 body += ~\"c }\";\n             }\n             else {\n-                body += fmt!(\"if ::pipes::send(pipe, message) {\\n \\\n-                                  ::pipes::rt::make_some(c) \\\n-                              } else { ::pipes::rt::make_none() } }\");\n+                body += fmt!(\"if ::core::pipes::send(pipe, message) {\\n \\\n+                                  ::core::pipes::rt::make_some(c) \\\n+                              } else { ::core::pipes::rt::make_none() } }\");\n             }\n \n             let body = cx.parse_expr(body);\n@@ -162,14 +162,14 @@ pub impl gen_send for message {\n                              message_args);\n \n                 if !try {\n-                    body += fmt!(\"::pipes::send(pipe, message);\\n\");\n+                    body += fmt!(\"::core::pipes::send(pipe, message);\\n\");\n                     body += ~\" }\";\n                 } else {\n-                    body += fmt!(\"if ::pipes::send(pipe, message) \\\n+                    body += fmt!(\"if ::core::pipes::send(pipe, message) \\\n                                         { \\\n-                                      ::pipes::rt::make_some(()) \\\n+                                      ::core::pipes::rt::make_some(()) \\\n                                   } else { \\\n-                                    ::pipes::rt::make_none() \\\n+                                    ::core::pipes::rt::make_none() \\\n                                   } }\");\n                 }\n \n@@ -272,7 +272,8 @@ pub impl to_type_decls for state {\n                     self.data_name(),\n                     self.span,\n                     cx.ty_path_ast_builder(\n-                        path_global(~[cx.ident_of(~\"pipes\"),\n+                        path_global(~[cx.ident_of(~\"core\"),\n+                                      cx.ident_of(~\"pipes\"),\n                                       cx.ident_of(dir.to_str() + ~\"Packet\")],\n                              dummy_sp())\n                         .add_ty(cx.ty_path_ast_builder(\n@@ -288,7 +289,8 @@ pub impl to_type_decls for state {\n                     self.data_name(),\n                     self.span,\n                     cx.ty_path_ast_builder(\n-                        path_global(~[cx.ident_of(~\"pipes\"),\n+                        path_global(~[cx.ident_of(~\"core\"),\n+                                      cx.ident_of(~\"pipes\"),\n                                       cx.ident_of(dir.to_str()\n                                                   + ~\"PacketBuffered\")],\n                              dummy_sp())\n@@ -313,10 +315,10 @@ pub impl gen_init for protocol {\n \n         let body = if !self.is_bounded() {\n             match start_state.dir {\n-              send => quote_expr!( ::pipes::entangle() ),\n+              send => quote_expr!( ::core::pipes::entangle() ),\n               recv => {\n                 quote_expr!({\n-                    let (s, c) = ::pipes::entangle();\n+                    let (s, c) = ::core::pipes::entangle();\n                     (c, s)\n                 })\n               }\n@@ -336,7 +338,7 @@ pub impl gen_init for protocol {\n         };\n \n         cx.parse_item(fmt!(\"pub fn init%s() -> (client::%s, server::%s)\\\n-                            { use pipes::HasBuffer; %s }\",\n+                            { use core::pipes::HasBuffer; %s }\",\n                            start_state.ty_params.to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n@@ -350,16 +352,16 @@ pub impl gen_init for protocol {\n             let fty = s.to_ty(ext_cx);\n             ext_cx.field_imm(ext_cx.ident_of(s.name),\n                              quote_expr!(\n-                                 ::pipes::mk_packet::<$fty>()\n+                                 ::core::pipes::mk_packet::<$fty>()\n                              ))\n         }))\n     }\n \n     fn gen_init_bounded(&self, ext_cx: ext_ctxt) -> @ast::expr {\n         debug!(\"gen_init_bounded\");\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n-        let buffer = quote_expr!(~::pipes::Buffer {\n-            header: ::pipes::BufferHeader(),\n+        let buffer = quote_expr!(~::core::pipes::Buffer {\n+            header: ::core::pipes::BufferHeader(),\n             data: $buffer_fields,\n         });\n \n@@ -375,7 +377,7 @@ pub impl gen_init for protocol {\n \n         quote_expr!({\n             let buffer = $buffer;\n-            do ::pipes::entangle_buffer(buffer) |buffer, data| {\n+            do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n                 $entangle_body\n             }\n         })\n@@ -408,7 +410,7 @@ pub impl gen_init for protocol {\n                 }\n             }\n             let ty = s.to_ty(cx);\n-            let fty = quote_ty!( ::pipes::Packet<$ty> );\n+            let fty = quote_ty!( ::core::pipes::Packet<$ty> );\n \n             @spanned {\n                 node: ast::struct_field_ {"}, {"sha": "f2749ed1d0c059607a6a34953a171590111f5c07", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::pipes::*;\n+use core::comm::*;\n \n pub fn foo<T:Owned + Copy>(x: T) -> Port<T> {\n     let (p, c) = stream();"}, {"sha": "4bbd22786a563f12082a23886c636459d8c0b1b0", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -24,7 +24,7 @@ extern mod std;\n use io::Writer;\n use io::WriterUtil;\n \n-use pipes::{Port, Chan, SharedChan};\n+use comm::{Port, Chan, SharedChan};\n \n macro_rules! move_out (\n     { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n@@ -36,7 +36,7 @@ enum request {\n     stop\n }\n \n-fn server(requests: Port<request>, responses: pipes::Chan<uint>) {\n+fn server(requests: Port<request>, responses: comm::Chan<uint>) {\n     let mut count = 0u;\n     let mut done = false;\n     while !done {\n@@ -55,8 +55,8 @@ fn server(requests: Port<request>, responses: pipes::Chan<uint>) {\n }\n \n fn run(args: &[~str]) {\n-    let (from_child, to_parent) = pipes::stream();\n-    let (from_parent, to_child) = pipes::stream();\n+    let (from_child, to_parent) = comm::stream();\n+    let (from_parent, to_child) = comm::stream();\n \n     let to_child = SharedChan(to_child);\n "}, {"sha": "a969368ebaca3a88f0ac41d7a3c7f58bb6513842", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -20,7 +20,7 @@ extern mod std;\n use io::Writer;\n use io::WriterUtil;\n \n-use pipes::{Port, PortSet, Chan};\n+use comm::{Port, PortSet, Chan, stream};\n \n macro_rules! move_out (\n     { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n@@ -32,7 +32,7 @@ enum request {\n     stop\n }\n \n-fn server(requests: PortSet<request>, responses: pipes::Chan<uint>) {\n+fn server(requests: PortSet<request>, responses: Chan<uint>) {\n     let mut count = 0;\n     let mut done = false;\n     while !done {\n@@ -51,8 +51,8 @@ fn server(requests: PortSet<request>, responses: pipes::Chan<uint>) {\n }\n \n fn run(args: &[~str]) {\n-    let (from_child, to_parent) = pipes::stream();\n-    let (from_parent_, to_child) = pipes::stream();\n+    let (from_child, to_parent) = stream();\n+    let (from_parent_, to_child) = stream();\n     let from_parent = PortSet();\n     from_parent.add(from_parent_);\n \n@@ -62,7 +62,7 @@ fn run(args: &[~str]) {\n     let start = std::time::precise_time_s();\n     let mut worker_results = ~[];\n     for uint::range(0, workers) |_i| {\n-        let (from_parent_, to_child) = pipes::stream();\n+        let (from_parent_, to_child) = stream();\n         from_parent.add(from_parent_);\n         do task::task().future_result(|+r| {\n             worker_results.push(r);"}, {"sha": "0f7c41f5997a8372ae5a70f0d38496be6d81cc46", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -20,7 +20,7 @@ extern mod std;\n use std::time;\n use std::future;\n \n-use pipes::recv;\n+use core::pipes::recv;\n \n proto! ring (\n     num:send {"}, {"sha": "f95bc3fc35a18498515bc56b63b90830419b417d", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -14,7 +14,7 @@\n  \n extern mod std;\n \n-use pipes::{spawn_service, recv};\n+use core::pipes::{spawn_service, recv};\n use std::time::precise_time_s;\n \n proto! pingpong (\n@@ -70,9 +70,9 @@ macro_rules! follow (\n     )\n )\n \n-fn switch<T:Owned,Tb:Owned,U>(+endp: pipes::RecvPacketBuffered<T, Tb>,\n+fn switch<T:Owned,Tb:Owned,U>(+endp: core::pipes::RecvPacketBuffered<T, Tb>,\n                       f: fn(+v: Option<T>) -> U) -> U {\n-    f(pipes::try_recv(endp))\n+    f(core::pipes::try_recv(endp))\n }\n \n // Here's the benchmark"}, {"sha": "42a1e4b504660f24053f79a32c879878795b503f", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -15,7 +15,7 @@ use std::oldmap;\n use std::oldmap::HashMap;\n use std::sort;\n use std::cell::Cell;\n-use core::pipes::*;\n+use core::comm::*;\n \n fn print_complements() {\n     let all = ~[Blue, Red, Yellow];"}, {"sha": "3fe5f7057057d33814b6be9a7d0c78ff4775c0d8", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -18,7 +18,7 @@ use std::oldmap;\n use std::oldmap::HashMap;\n use std::sort;\n use io::ReaderUtil;\n-use pipes::{stream, Port, Chan};\n+use comm::{stream, Port, Chan};\n use cmp::Ord;\n \n // given a map, print a sorted version of it\n@@ -97,8 +97,8 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n    return vec::slice(bb, len - (nn - 1u), len).to_vec();\n }\n \n-fn make_sequence_processor(sz: uint, from_parent: pipes::Port<~[u8]>,\n-                           to_parent: pipes::Chan<~str>) {\n+fn make_sequence_processor(sz: uint, from_parent: comm::Port<~[u8]>,\n+                           to_parent: comm::Chan<~str>) {\n \n    let freqs: HashMap<~[u8], uint> = oldmap::HashMap();\n    let mut carry: ~[u8] = ~[];\n@@ -159,7 +159,7 @@ fn main() {\n \n         from_child.push(from_child_);\n \n-        let (from_parent, to_child) = pipes::stream();\n+        let (from_parent, to_child) = comm::stream();\n \n         do task::spawn_with(from_parent) |from_parent| {\n             make_sequence_processor(sz, from_parent, to_parent_);"}, {"sha": "5e472712fda4334134fda8ec27f52bacfd09ac24", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -108,7 +108,7 @@ impl io::Writer for Devnull {\n     fn get_type(&self) -> io::WriterType { io::File }\n }\n \n-fn writer(path: ~str, pport: pipes::Port<Line>, size: uint)\n+fn writer(path: ~str, pport: comm::Port<Line>, size: uint)\n {\n     let cout: io::Writer = match path {\n         ~\"\" => {\n@@ -172,8 +172,8 @@ fn main() {\n     let size = if vec::len(args) < 2_u { 80_u }\n     else { uint::from_str(args[1]).get() };\n \n-    let (pport, pchan) = pipes::stream();\n-    let pchan = pipes::SharedChan(pchan);\n+    let (pport, pchan) = comm::stream();\n+    let pchan = comm::SharedChan(pchan);\n     for uint::range(0_u, size) |j| {\n         let cchan = pchan.clone();\n         do task::spawn { cchan.send(chanmb(j, size, depth)) };"}, {"sha": "a8383c4647ec1d50ef81d48f6c81a70906f62563", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -24,12 +24,9 @@\n extern mod std;\n \n use std::{time, getopts};\n-use io::WriterUtil;\n-use int::range;\n-use pipes::Port;\n-use pipes::Chan;\n-use pipes::send;\n-use pipes::recv;\n+use core::int::range;\n+use core::comm::*;\n+use core::io::WriterUtil;\n \n use core::result;\n use result::{Ok, Err};\n@@ -41,7 +38,7 @@ fn fib(n: int) -> int {\n         } else if n <= 2 {\n             c.send(1);\n         } else {\n-            let p = pipes::PortSet();\n+            let p = PortSet();\n             let ch = p.chan();\n             task::spawn(|| pfib(ch, n - 1) );\n             let ch = p.chan();\n@@ -50,7 +47,7 @@ fn fib(n: int) -> int {\n         }\n     }\n \n-    let (p, ch) = pipes::stream();\n+    let (p, ch) = stream();\n     let _t = task::spawn(|| pfib(ch, n) );\n     p.recv()\n }"}, {"sha": "528dfd3ec734159260fdf036e5ba25f20b6a17fe", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -15,7 +15,7 @@\n //\n // The filename is a song reference; google it in quotes.\n \n-fn child_generation(gens_left: uint, -c: pipes::Chan<()>) {\n+fn child_generation(gens_left: uint, -c: comm::Chan<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n@@ -43,7 +43,7 @@ fn main() {\n         copy args\n     };\n \n-    let (p,c) = pipes::stream();\n+    let (p,c) = comm::stream();\n     child_generation(uint::from_str(args[1]).get(), c);\n     if p.try_recv().is_none() {\n         fail!(~\"it happened when we slumbered\");"}, {"sha": "8bb4c9bc592349cb822106c7c766ed6d5906d87e", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -20,7 +20,7 @@\n // Creates in the background 'num_tasks' tasks, all blocked forever.\n // Doesn't return until all such tasks are ready, but doesn't block forever itself.\n \n-use core::pipes::*;\n+use core::comm::*;\n \n fn grandchild_group(num_tasks: uint) {\n     let (po, ch) = stream();"}, {"sha": "8e1cbb9e17bdd90a1026c63279b541ae5f18a3dc", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -10,7 +10,7 @@\n \n // Test for concurrent tasks\n \n-use core::pipes::*;\n+use core::comm::*;\n \n fn calc(children: uint, parent_wait_chan: &Chan<Chan<Chan<int>>>) {\n "}, {"sha": "d428feb2a24de7ff799baab87da11ffddf65096f", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let (p,c) = pipes::stream();\n+    let (p,c) = comm::stream();\n     let x = Some(p);\n     c.send(false);\n     match x {"}, {"sha": "3eebc4647c28be86d9e0474a0be42d136a3ab2e1", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -25,6 +25,6 @@ fn foo(i:int, j: @~str) -> foo {\n \n fn main() {\n   let cat = ~\"kitty\";\n-    let (_, ch) = pipes::stream(); //~ ERROR does not fulfill `Owned`\n+    let (_, ch) = comm::stream(); //~ ERROR does not fulfill `Owned`\n   ch.send(foo(42, @(cat))); //~ ERROR does not fulfill `Owned`\n }"}, {"sha": "e8bb075ac00feabe8a9bb76bc28a5bf04b9149e0", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -16,7 +16,7 @@ extern mod std;\n fn child() { assert (1 == 2); }\n \n fn main() {\n-    let (p, _c) = pipes::stream::<int>();\n+    let (p, _c) = comm::stream::<int>();\n     task::spawn(|| child() );\n     let x = p.recv();\n }"}, {"sha": "9f09c16ed6a571054688a9799dad9cef13f1cf78", "filename": "src/test/run-fail/linked-failure2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure2.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -15,7 +15,7 @@\n fn child() { fail!(); }\n \n fn main() {\n-    let (p, _c) = pipes::stream::<()>();\n+    let (p, _c) = comm::stream::<()>();\n     task::spawn(|| child() );\n     task::yield();\n }"}, {"sha": "c2c97662b6c965b73347ba0cf04159f6327934c4", "filename": "src/test/run-fail/linked-failure3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure3.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -15,13 +15,13 @@\n fn grandchild() { fail!(~\"grandchild dies\"); }\n \n fn child() {\n-    let (p, _c) = pipes::stream::<int>();\n+    let (p, _c) = comm::stream::<int>();\n     task::spawn(|| grandchild() );\n     let x = p.recv();\n }\n \n fn main() {\n-    let (p, _c) = pipes::stream::<int>();\n+    let (p, _c) = comm::stream::<int>();\n     task::spawn(|| child() );\n     let x = p.recv();\n }"}, {"sha": "97e4edc81bccd921d73ad312d4e8521022d9d38b", "filename": "src/test/run-fail/linked-failure4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure4.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -14,15 +14,15 @@\n fn child() { assert (1 == 2); }\n \n fn parent() {\n-    let (p, _c) = pipes::stream::<int>();\n+    let (p, _c) = comm::stream::<int>();\n     task::spawn(|| child() );\n     let x = p.recv();\n }\n \n // This task is not linked to the failure chain, but since the other\n // tasks are going to fail the kernel, this one will fail too\n fn sleeper() {\n-    let (p, _c) = pipes::stream::<int>();\n+    let (p, _c) = comm::stream::<int>();\n     let x = p.recv();\n }\n "}, {"sha": "a0896ea7babbd2a302ccafca956ed35901871a95", "filename": "src/test/run-fail/task-comm-recv-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -17,7 +17,7 @@ fn goodfail() {\n \n fn main() {\n     task::spawn(|| goodfail() );\n-    let (po, _c) = pipes::stream();\n+    let (po, _c) = comm::stream();\n     // We shouldn't be able to get past this recv since there's no\n     // message available\n     let i: int = po.recv();"}, {"sha": "99d8fab4bba501ac24dd9bdf8284c3b574addbf6", "filename": "src/test/run-pass/capture_nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture_nil.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -24,7 +24,7 @@\n // course preferable, as the value itself is\n // irrelevant).\n \n-use core::pipes::*;\n+use core::comm::*;\n \n fn foo(&&x: ()) -> Port<()> {\n     let (p, c) = stream::<()>();"}, {"sha": "da467ae7ba596310d8edcda9ca458cdf911713cc", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -9,7 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::pipes::*;\n+use core::comm::*;\n \n pub fn main() {\n     let (p, ch) = stream();"}, {"sha": "b90633bab01ef9b6ab7881c603655307cb1d7e47", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -20,14 +20,14 @@ extern mod std;\n \n use std::oldmap;\n use std::oldmap::HashMap;\n-use core::pipes::*;\n+use core::comm::*;\n \n pub fn map(filename: ~str, emit: map_reduce::putter) { emit(filename, ~\"1\"); }\n \n mod map_reduce {\n     use std::oldmap;\n     use std::oldmap::HashMap;\n-    use core::pipes::*;\n+    use core::comm::*;\n \n     pub type putter = fn@(~str, ~str);\n "}, {"sha": "e0ec62ff255aeb4fe874204ca5d7b7d17ce40c23", "filename": "src/test/run-pass/issue-3168.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3168.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -11,15 +11,15 @@\n // xfail-fast\n \n pub fn main() {\n-    let (p,c) = pipes::stream();\n+    let (p,c) = comm::stream();\n     do task::try || {\n-        let (p2,c2) = pipes::stream();\n+        let (p2,c2) = comm::stream();\n         do task::spawn || {\n             p2.recv();\n             error!(\"sibling fails\");\n             fail!();\n         }   \n-        let (p3,c3) = pipes::stream();\n+        let (p3,c3) = comm::stream();\n         c.send(c3);\n         c2.send(());\n         error!(\"child blocks\");"}, {"sha": "e441fa22b3150d74d420fde6cc7e761d57d252ce", "filename": "src/test/run-pass/issue-3176.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3176.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -10,22 +10,22 @@\n \n // xfail-fast\n \n-use pipes::{Select2, Selectable};\n+use comm::{Select2, Selectable};\n \n pub fn main() {\n-    let (p,c) = pipes::stream();\n+    let (p,c) = comm::stream();\n     do task::try || {\n-        let (p2,c2) = pipes::stream();\n+        let (p2,c2) = comm::stream();\n         do task::spawn || {\n             p2.recv();\n             error!(\"sibling fails\");\n             fail!();\n         }   \n-        let (p3,c3) = pipes::stream();\n+        let (p3,c3) = comm::stream();\n         c.send(c3);\n         c2.send(());\n         error!(\"child blocks\");\n-        let (p, c) = pipes::stream();\n+        let (p, c) = comm::stream();\n         (p, p3).select();\n         c.send(());\n     };  "}, {"sha": "83703dacc36e3abf8d0f4abf4f0ed4c4c53b9ba7", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -1,6 +1,6 @@\n extern mod std;\n \n-use pipes::Chan;\n+use comm::Chan;\n \n type RingBuffer = ~[float];\n type SamplesFn = fn~ (samples: &RingBuffer);"}, {"sha": "017d90cbcd736a112a841aff8c99fc5d6a0f4cb0", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -1,4 +1,4 @@\n-use core::pipes::*;\n+use core::comm::*;\n \n fn producer(c: &Chan<~[u8]>) {\n     c.send("}, {"sha": "b74c70d3ea71680301101c208304a550661f3c0d", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -15,7 +15,8 @@\n //\n // http://theincredibleholk.wordpress.com/2012/07/06/rusty-pipes/\n \n-use pipes::try_recv;\n+use core::pipes;\n+use core::pipes::try_recv;\n \n pub type username = ~str;\n pub type password = ~str;"}, {"sha": "6afa9e29349f34f57644ba57f71d1477014f37d8", "filename": "src/test/run-pass/pipe-detect-term.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -18,7 +18,8 @@ extern mod std;\n use std::timer::sleep;\n use std::uv;\n \n-use pipes::{try_recv, recv};\n+use core::pipes;\n+use core::pipes::{try_recv, recv};\n \n proto! oneshot (\n     waiting:send {"}, {"sha": "25fa1a956bf78a5f724575258cef2c669e0f2310", "filename": "src/test/run-pass/pipe-peek.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-peek.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -13,6 +13,7 @@\n extern mod std;\n use std::timer::sleep;\n use std::uv;\n+use core::pipes;\n \n proto! oneshot (\n     waiting:send {"}, {"sha": "2ada6df76a6a86d331e1787598b517a748cc60ee", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -19,6 +19,7 @@\n // modified in hopefully straightforward ways.\n \n mod pingpong {\n+    use core::pipes;\n     use core::pipes::*;\n     use core::ptr;\n \n@@ -44,6 +45,7 @@ mod pingpong {\n     pub enum ping = server::pong;\n     pub enum pong = client::ping;\n     pub mod client {\n+        use core::pipes;\n         use core::pipes::*;\n         use core::ptr;\n \n@@ -53,7 +55,7 @@ mod pingpong {\n                 let s = SendPacketBuffered(ptr::addr_of(&(b.buffer.data.pong)));\n                 let c = RecvPacketBuffered(ptr::addr_of(&(b.buffer.data.pong)));\n                 let message = ::pingpong::ping(s);\n-                ::pipes::send(pipe, message);\n+                send(pipe, message);\n                 c\n             }\n         }\n@@ -63,6 +65,7 @@ mod pingpong {\n                                                   ::pingpong::Packets>;\n     }\n     pub mod server {\n+        use core::pipes;\n         use core::pipes::*;\n         use core::ptr;\n \n@@ -74,7 +77,7 @@ mod pingpong {\n                 let s = SendPacketBuffered(ptr::addr_of(&(b.buffer.data.ping)));\n                 let c = RecvPacketBuffered(ptr::addr_of(&(b.buffer.data.ping)));\n                 let message = ::pingpong::pong(s);\n-                ::pipes::send(pipe, message);\n+                send(pipe, message);\n                 c\n             }\n         }\n@@ -84,7 +87,7 @@ mod pingpong {\n }\n \n mod test {\n-    use pipes::recv;\n+    use core::pipes::recv;\n     use pingpong::{ping, pong};\n \n     pub fn client(-chan: ::pingpong::client::ping) {"}, {"sha": "85ab1f89dbeca9165e99a954909731cef1c2ad94", "filename": "src/test/run-pass/pipe-presentation-examples.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -32,7 +32,7 @@ macro_rules! select_if (\n         ], )*\n     } => {\n         if $index == $count {\n-            match pipes::try_recv($port) {\n+            match core::pipes::try_recv($port) {\n               $(Some($message($($($x,)+)* next)) => {\n                 let $next = next;\n                 $e\n@@ -66,7 +66,7 @@ macro_rules! select (\n               -> $next:ident $e:expr),+\n         } )+\n     } => ({\n-        let index = pipes::selecti([$(($port).header()),+]);\n+        let index = core::comm::selecti([$(($port).header()),+]);\n         select_if!(index, 0, $( $port => [\n             $($message$(($($x),+))dont_type_this* -> $next $e),+\n         ], )+)"}, {"sha": "e6a7edd7a6b6bf33ee925ac1baced8bb0e8505d8", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -17,7 +17,8 @@ extern mod std;\n use std::timer::sleep;\n use std::uv;\n \n-use pipes::{recv, select};\n+use core::pipes;\n+use core::pipes::{recv, select};\n \n proto! oneshot (\n     waiting:send {"}, {"sha": "57d72edd0a46a32f54e18f5e69ffed2edf2ff8c6", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -13,7 +13,8 @@\n extern mod std;\n use std::timer::sleep;\n use std::uv;\n-use pipes::recv;\n+use core::pipes;\n+use core::pipes::recv;\n \n proto! oneshot (\n     waiting:send {"}, {"sha": "ca37a6663fd69711dfa25b31b70d32a0b38be532", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -10,7 +10,7 @@\n \n // Tests of the runtime's scheduler interface\n \n-use core::pipes::*;\n+use core::comm::*;\n \n type sched_id = int;\n type task_id = *libc::c_void;"}, {"sha": "18f4fd27858ba8bc9752926bc1a9adbde4b2ffd3", "filename": "src/test/run-pass/send-iloop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-iloop.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -17,7 +17,7 @@ fn die() {\n \n fn iloop() {\n     task::spawn(|| die() );\n-    let (p, c) = core::pipes::stream::<()>();\n+    let (p, c) = comm::stream::<()>();\n     loop {\n         // Sending and receiving here because these actions yield,\n         // at which point our child can kill us."}, {"sha": "6bda62be621d6f2bc342e25e891d9f6d501a75d1", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::pipes::*;\n+use core::comm::*;\n \n struct test {\n   f: int,"}, {"sha": "0f924df8dc006e53a85a61fc5ea6d5c999bd7dee", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::pipes::*;\n+use core::comm::*;\n \n // tests that ctrl's type gets inferred properly\n type command<K, V> = {key: K, val: V};"}, {"sha": "8ef0173dbd32758141af9871ffdbb4dd3e0b873f", "filename": "src/test/run-pass/sendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendable-class.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -23,6 +23,6 @@ fn foo(i:int, j: char) -> foo {\n }\n \n pub fn main() {\n-    let (_po, ch) = pipes::stream();\n+    let (_po, ch) = comm::stream();\n     ch.send(foo(42, 'c'));\n }"}, {"sha": "4111b50549055e394b11e77c4443dd0f67381305", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -14,7 +14,7 @@\n   Arnold.\n  */\n \n-use core::pipes::*;\n+use core::comm::*;\n \n type ctx = Chan<int>;\n "}, {"sha": "f260e571b42ac66edb7c14a2fd216777eff3b96f", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -13,8 +13,8 @@\n \n extern mod std;\n \n-use pipes::Chan;\n-use pipes::Port;\n+use comm::Chan;\n+use comm::Port;\n \n pub fn main() { test05(); }\n \n@@ -28,7 +28,7 @@ fn test05_start(ch : Chan<int>) {\n }\n \n fn test05() {\n-    let (po, ch) = pipes::stream();\n+    let (po, ch) = comm::stream();\n     task::spawn(|| test05_start(ch) );\n     let mut value = po.recv();\n     log(error, value);"}, {"sha": "379b9acf6f554edfb7b4e72b82202747ca85ad03", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -13,8 +13,8 @@\n \n extern mod std;\n \n-fn start(c: pipes::Chan<pipes::Chan<~str>>) {\n-    let (p, ch) = pipes::stream();\n+fn start(c: comm::Chan<comm::Chan<~str>>) {\n+    let (p, ch) = comm::stream();\n     c.send(ch);\n \n     let mut a;\n@@ -28,7 +28,7 @@ fn start(c: pipes::Chan<pipes::Chan<~str>>) {\n }\n \n pub fn main() {\n-    let (p, ch) = pipes::stream();\n+    let (p, ch) = comm::stream();\n     let child = task::spawn(|| start(ch) );\n \n     let c = p.recv();"}, {"sha": "3e3eefd26ba7c2b9213a6126a9e19a639f9906f9", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -13,13 +13,13 @@\n \n extern mod std;\n \n-fn start(c: pipes::Chan<pipes::Chan<int>>) {\n-    let (p, ch) = pipes::stream();\n+fn start(c: comm::Chan<comm::Chan<int>>) {\n+    let (p, ch) = comm::stream();\n     c.send(ch);\n }\n \n pub fn main() {\n-    let (p, ch) = pipes::stream();\n+    let (p, ch) = comm::stream();\n     let child = task::spawn(|| start(ch) );\n     let c = p.recv();\n }"}, {"sha": "a246f1f4af2b187a9d6bb60e6b9dbe630cbd2aec", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -12,16 +12,15 @@\n #[legacy_modes];\n \n extern mod std;\n-use pipes::send;\n \n-fn start(c: pipes::Chan<int>, start: int, number_of_messages: int) {\n+fn start(c: comm::Chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }\n \n pub fn main() {\n     debug!(\"Check that we don't deadlock.\");\n-    let (p, ch) = pipes::stream();\n+    let (p, ch) = comm::stream();\n     task::try(|| start(ch, 0, 10) );\n     debug!(\"Joined task\");\n }"}, {"sha": "c5179652fdc89c51ddf3c4ae9bfe192dc891af1e", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -12,13 +12,13 @@\n #[legacy_modes];\n \n pub fn main() {\n-    let po = pipes::PortSet();\n+    let po = comm::PortSet();\n \n     // Spawn 10 tasks each sending us back one int.\n     let mut i = 10;\n     while (i > 0) {\n         log(debug, i);\n-        let (p, ch) = pipes::stream();\n+        let (p, ch) = comm::stream();\n         po.add(p);\n         task::spawn({let i = i; || child(i, ch)});\n         i = i - 1;\n@@ -37,7 +37,7 @@ pub fn main() {\n     debug!(\"main thread exiting\");\n }\n \n-fn child(x: int, ch: pipes::Chan<int>) {\n+fn child(x: int, ch: comm::Chan<int>) {\n     log(debug, x);\n     ch.send(x);\n }"}, {"sha": "525cafef169ef729b1706b6ce09f8b95c843a4d3", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -14,7 +14,7 @@\n \n extern mod std;\n \n-fn start(c: pipes::Chan<int>, i0: int) {\n+fn start(c: comm::Chan<int>, i0: int) {\n     let mut i = i0;\n     while i > 0 {\n         c.send(0);\n@@ -27,7 +27,7 @@ pub fn main() {\n     // is likely to terminate before the child completes, so from\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n-    let (p, ch) = pipes::stream();\n+    let (p, ch) = comm::stream();\n     task::spawn(|| start(ch, 10));\n     p.recv();\n }"}, {"sha": "e2ac5623db3d965a8a0fa9112fc4f165ef100777", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -10,16 +10,11 @@\n // except according to those terms.\n \n \n-use pipes::send;\n-use pipes::Port;\n-use pipes::recv;\n-use pipes::Chan;\n-\n // Tests of ports and channels on various types\n fn test_rec() {\n     struct R {val0: int, val1: u8, val2: char}\n \n-    let (po, ch) = pipes::stream();\n+    let (po, ch) = comm::stream();\n     let r0: R = R {val0: 0, val1: 1u8, val2: '2'};\n     ch.send(r0);\n     let mut r1: R;\n@@ -30,7 +25,7 @@ fn test_rec() {\n }\n \n fn test_vec() {\n-    let (po, ch) = pipes::stream();\n+    let (po, ch) = comm::stream();\n     let v0: ~[int] = ~[0, 1, 2];\n     ch.send(v0);\n     let v1 = po.recv();\n@@ -40,7 +35,7 @@ fn test_vec() {\n }\n \n fn test_str() {\n-    let (po, ch) = pipes::stream();\n+    let (po, ch) = comm::stream();\n     let s0 = ~\"test\";\n     ch.send(s0);\n     let s1 = po.recv();\n@@ -84,7 +79,7 @@ impl cmp::Eq for t {\n }\n \n fn test_tag() {\n-    let (po, ch) = pipes::stream();\n+    let (po, ch) = comm::stream();\n     ch.send(tag1);\n     ch.send(tag2(10));\n     ch.send(tag3(10, 11u8, 'A'));\n@@ -98,8 +93,8 @@ fn test_tag() {\n }\n \n fn test_chan() {\n-    let (po, ch) = pipes::stream();\n-    let (po0, ch0) = pipes::stream();\n+    let (po, ch) = comm::stream();\n+    let (po0, ch0) = comm::stream();\n     ch.send(ch0);\n     let ch1 = po.recv();\n     // Does the transmitted channel still work?"}, {"sha": "9bbe20c2e1332311d65257e847b4e35fa36558dd", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -12,9 +12,7 @@\n #[legacy_modes];\n \n extern mod std;\n-use pipes::Chan;\n-use pipes::send;\n-use pipes::recv;\n+use core::comm::Chan;\n \n pub fn main() { debug!(\"===== WITHOUT THREADS =====\"); test00(); }\n \n@@ -35,7 +33,7 @@ fn test00() {\n \n     debug!(\"Creating tasks\");\n \n-    let po = pipes::PortSet();\n+    let po = comm::PortSet();\n \n     let mut i: int = 0;\n "}, {"sha": "dc4dc27229c56bf563c5a5f4c97c7118f6bca7d1", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use pipes::send;\n-\n pub fn main() { test00(); }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, c) = pipes::stream();\n+    let (p, c) = comm::stream();\n     c.send(1);\n     c.send(2);\n     c.send(3);"}, {"sha": "0256c1cbb8754b124487a8d3ef21d65fb57a08f3", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -15,7 +15,7 @@ pub fn main() { test00(); }\n fn test00() {\n     let r: int = 0;\n     let mut sum: int = 0;\n-    let (p, c) = pipes::stream();\n+    let (p, c) = comm::stream();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(i + 0); i += 1; }"}, {"sha": "c18090ea45f540a8e720042691fea18bfdf22096", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use pipes::send;\n-use pipes::Chan;\n-use pipes::recv;\n+use core::comm::Chan;\n \n pub fn main() { test00(); }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let p = pipes::PortSet();\n+    let p = comm::PortSet();\n     let c0 = p.chan();\n     let c1 = p.chan();\n     let c2 = p.chan();"}, {"sha": "21eb93e8d09b9a40f02d066dbef5822271f3e738", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -15,15 +15,15 @@ extern mod std;\n \n pub fn main() { test00(); }\n \n-fn test00_start(c: pipes::Chan<int>, start: int, number_of_messages: int) {\n+fn test00_start(c: comm::Chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let p = pipes::PortSet();\n+    let p = comm::PortSet();\n     let number_of_messages: int = 10;\n \n     let c = p.chan();"}, {"sha": "75fcd12c312d0712773ad9c051b84d74919d2958", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -15,15 +15,15 @@ extern mod std;\n \n pub fn main() { test00(); }\n \n-fn test00_start(c: pipes::Chan<int>, number_of_messages: int) {\n+fn test00_start(c: comm::Chan<int>, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(i + 0); i += 1; }\n }\n \n fn test00() {\n     let r: int = 0;\n     let mut sum: int = 0;\n-    let p = pipes::PortSet();\n+    let p = comm::PortSet();\n     let number_of_messages: int = 10;\n     let ch = p.chan();\n "}, {"sha": "db2ad2de61b9577d9e0c370719a2006103f15618", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -16,7 +16,7 @@ extern mod std;\n // any size, but rustc currently can because they do have size. Whether\n // or not this is desirable I don't know, but here's a regression test.\n pub fn main() {\n-    let (po, ch) = pipes::stream();\n+    let (po, ch) = comm::stream();\n     ch.send(());\n     let n: () = po.recv();\n     assert (n == ());"}, {"sha": "b90c39ab34e503654a919591c864883165bc20ed", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -13,7 +13,7 @@\n // A port of task-killjoin to use a class with a dtor to manage\n // the join.\n \n-use core::pipes::*;\n+use core::comm::*;\n \n struct notify {\n     ch: Chan<bool>, v: @mut bool,"}, {"sha": "805f8e8b1e24cae0aa3d85975ed3dcbd9c457efe", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::pipes::*;\n+use core::comm::*;\n \n pub fn main() {\n     let (p, ch) = stream::<uint>();"}, {"sha": "7800ebd7310ca84da6f6d73b96f82424436ff6c8", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use pipes::{Port, Chan};\n-\n /*\n   This is about the simplest program that can successfully send a\n   message.\n  */\n pub fn main() {\n-    let (po, ch) = pipes::stream();\n+    let (po, ch) = comm::stream();\n     ch.send(42);\n     let r = po.recv();\n     log(error, r);"}, {"sha": "7be6907a0c730ef630fec9338f239c350888ae4c", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::pipes::*;\n+use core::comm::*;\n \n fn child(c: &SharedChan<~uint>, i: uint) {\n     c.send(~i);"}, {"sha": "75fc71441f8f3116ed7bca23ed5d78cbc9d386df", "filename": "src/test/run-pass/unique-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::pipes::*;\n+use core::comm::*;\n \n pub fn main() {\n     let (p, c) = stream();"}, {"sha": "2693a8d39423e6a4d32bdece4d6a34c58c3d4899", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316189d155e233ea04241116b11956626c8e7a3/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=c316189d155e233ea04241116b11956626c8e7a3", "patch": "@@ -11,7 +11,7 @@\n // xfail-win32\n extern mod std;\n \n-use core::pipes::*;\n+use core::comm::*;\n \n struct complainer {\n   c: SharedChan<bool>,"}]}