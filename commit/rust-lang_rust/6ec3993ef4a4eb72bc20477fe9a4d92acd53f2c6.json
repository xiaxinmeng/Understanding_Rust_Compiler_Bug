{"sha": "6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "node_id": "C_kwDOAAsO6NoAKDZlYzM5OTNlZjRhNGViNzJiYzIwNDc3ZmU5YTRkOTJhY2Q1M2YyYzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-16T11:13:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-16T11:13:30Z"}, "message": "Auto merge of #97842 - notriddle:notriddle/tuple-docs, r=jsha,GuillaumeGomez\n\nImprove the tuple and unit trait docs\n\n* Reduce duplicate impls; show only the `(T,)` and include a sentence saying that there exists ones up to twelve of them.\n* Show `Copy` and `Clone`.\n* Show auto traits like `Send` and `Sync`, and blanket impls like `Any`.\n\nHere's the new version:\n\n* <https://notriddle.com/notriddle-rustdoc-test/std/primitive.tuple.html>\n* <https://notriddle.com/notriddle-rustdoc-test/std/primitive.unit.html>", "tree": {"sha": "64623290e8e88fc28d678a5b928dc9595fcbcea0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64623290e8e88fc28d678a5b928dc9595fcbcea0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "html_url": "https://github.com/rust-lang/rust/commit/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d40f24e956a698e47a209541031c4045acc5a684", "url": "https://api.github.com/repos/rust-lang/rust/commits/d40f24e956a698e47a209541031c4045acc5a684", "html_url": "https://github.com/rust-lang/rust/commit/d40f24e956a698e47a209541031c4045acc5a684"}, {"sha": "f1d24beb6805e4d16d472964518c576421f8c009", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d24beb6805e4d16d472964518c576421f8c009", "html_url": "https://github.com/rust-lang/rust/commit/f1d24beb6805e4d16d472964518c576421f8c009"}], "stats": {"total": 580, "additions": 468, "deletions": 112}, "files": [{"sha": "37c4f665415fc57e3e8a741cd17181b1128261ab", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -401,6 +401,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     let msg = \"`#[doc(keyword)]` is meant for internal use only\";\n                     gate_feature_post!(self, rustdoc_internals, attr.span, msg);\n                 }\n+\n+                if nested_meta.has_name(sym::tuple_variadic) {\n+                    let msg = \"`#[doc(tuple_variadic)]` is meant for internal use only\";\n+                    gate_feature_post!(self, rustdoc_internals, attr.span, msg);\n+                }\n             }\n         }\n "}, {"sha": "4ef0f590a1f3d94341deeba9554069864ae1aacc", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -805,6 +805,37 @@ impl CheckAttrVisitor<'_> {\n         true\n     }\n \n+    fn check_doc_tuple_variadic(&self, meta: &NestedMetaItem, hir_id: HirId) -> bool {\n+        match self.tcx.hir().find(hir_id).and_then(|node| match node {\n+            hir::Node::Item(item) => Some(&item.kind),\n+            _ => None,\n+        }) {\n+            Some(ItemKind::Impl(ref i)) => {\n+                if !matches!(&i.self_ty.kind, hir::TyKind::Tup([_])) {\n+                    self.tcx\n+                        .sess\n+                        .struct_span_err(\n+                            meta.span(),\n+                            \"`#[doc(tuple_variadic)]` must be used on the first of a set of tuple trait impls with varying arity\",\n+                        )\n+                        .emit();\n+                    return false;\n+                }\n+            }\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(\n+                        meta.span(),\n+                        \"`#[doc(keyword = \\\"...\\\")]` can only be used on impl blocks\",\n+                    )\n+                    .emit();\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n     /// Checks `#[doc(inline)]`/`#[doc(no_inline)]` attributes. Returns `true` if valid.\n     ///\n     /// A doc inlining attribute is invalid if it is applied to a non-`use` item, or\n@@ -1065,6 +1096,13 @@ impl CheckAttrVisitor<'_> {\n                             is_valid = false\n                         }\n \n+                        sym::tuple_variadic\n+                            if !self.check_attr_not_crate_level(meta, hir_id, \"tuple_variadic\")\n+                                || !self.check_doc_tuple_variadic(meta, hir_id) =>\n+                        {\n+                            is_valid = false\n+                        }\n+\n                         sym::html_favicon_url\n                         | sym::html_logo_url\n                         | sym::html_playground_url\n@@ -1118,7 +1156,8 @@ impl CheckAttrVisitor<'_> {\n                         | sym::no_inline\n                         | sym::notable_trait\n                         | sym::passes\n-                        | sym::plugins => {}\n+                        | sym::plugins\n+                        | sym::tuple_variadic => {}\n \n                         sym::test => {\n                             if !self.check_test_attr(meta, hir_id) {"}, {"sha": "6daf811e26f144b5032f4e00f70e90802b7ed493", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -1449,6 +1449,7 @@ symbols! {\n         tuple,\n         tuple_from_req,\n         tuple_indexing,\n+        tuple_variadic,\n         two_phase,\n         ty,\n         type_alias_enum_variants,"}, {"sha": "fd5624812f554823a3f6fbe69cc1b990dee6aa5a", "filename": "library/core/src/clone.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fclone.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -95,7 +95,6 @@ use crate::marker::Destruct;\n ///\n /// * Function item types (i.e., the distinct types defined for each function)\n /// * Function pointer types (e.g., `fn() -> i32`)\n-/// * Tuple types, if each component also implements `Clone` (e.g., `()`, `(i32, bool)`)\n /// * Closure types, if they capture no value from the environment\n ///   or if all such captured values implement `Clone` themselves.\n ///   Note that variables captured by shared reference always implement `Clone`"}, {"sha": "1c66089fad6e63764abb5e48d71b3195bb2259d4", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -2313,29 +2313,46 @@ macro_rules! peel {\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($name:Debug),+> Debug for ($($name,)+) where last_type!($($name,)+): ?Sized {\n-            #[allow(non_snake_case, unused_assignments)]\n-            fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n-                let mut builder = f.debug_tuple(\"\");\n-                let ($(ref $name,)+) = *self;\n-                $(\n-                    builder.field(&$name);\n-                )+\n-\n-                builder.finish()\n+        maybe_tuple_doc! {\n+            $($name)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($name:Debug),+> Debug for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                #[allow(non_snake_case, unused_assignments)]\n+                fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+                    let mut builder = f.debug_tuple(\"\");\n+                    let ($(ref $name,)+) = *self;\n+                    $(\n+                        builder.field(&$name);\n+                    )+\n+\n+                    builder.finish()\n+                }\n             }\n         }\n         peel! { $($name,)+ }\n     )\n }\n \n+macro_rules! maybe_tuple_doc {\n+    ($a:ident @ #[$meta:meta] $item:item) => {\n+        #[cfg_attr(not(bootstrap), doc(tuple_variadic))]\n+        #[doc = \"This trait is implemented for tuples up to twelve items long.\"]\n+        #[$meta]\n+        $item\n+    };\n+    ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n+        #[doc(hidden)]\n+        #[$meta]\n+        $item\n+    };\n+}\n+\n macro_rules! last_type {\n     ($a:ident,) => { $a };\n     ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n }\n \n-tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n+tuple! { E, D, C, B, A, Z, Y, X, W, V, U, T, }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {"}, {"sha": "2c152fe1b2c185e64995c944c4f6674e3a8329b3", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -883,36 +883,53 @@ mod impls {\n         );\n \n         ( $($name:ident)+) => (\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n-                #[allow(non_snake_case)]\n-                #[inline]\n-                fn hash<S: Hasher>(&self, state: &mut S) {\n-                    let ($(ref $name,)+) = *self;\n-                    $($name.hash(state);)+\n+            maybe_tuple_doc! {\n+                $($name)+ @\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                    #[allow(non_snake_case)]\n+                    #[inline]\n+                    fn hash<S: Hasher>(&self, state: &mut S) {\n+                        let ($(ref $name,)+) = *self;\n+                        $($name.hash(state);)+\n+                    }\n                 }\n             }\n         );\n     }\n \n+    macro_rules! maybe_tuple_doc {\n+        ($a:ident @ #[$meta:meta] $item:item) => {\n+            #[cfg_attr(not(bootstrap), doc(tuple_variadic))]\n+            #[doc = \"This trait is implemented for tuples up to twelve items long.\"]\n+            #[$meta]\n+            $item\n+        };\n+        ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n+            #[doc(hidden)]\n+            #[$meta]\n+            $item\n+        };\n+    }\n+\n     macro_rules! last_type {\n         ($a:ident,) => { $a };\n         ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n     }\n \n     impl_hash_tuple! {}\n-    impl_hash_tuple! { A }\n-    impl_hash_tuple! { A B }\n-    impl_hash_tuple! { A B C }\n-    impl_hash_tuple! { A B C D }\n-    impl_hash_tuple! { A B C D E }\n-    impl_hash_tuple! { A B C D E F }\n-    impl_hash_tuple! { A B C D E F G }\n-    impl_hash_tuple! { A B C D E F G H }\n-    impl_hash_tuple! { A B C D E F G H I }\n-    impl_hash_tuple! { A B C D E F G H I J }\n-    impl_hash_tuple! { A B C D E F G H I J K }\n-    impl_hash_tuple! { A B C D E F G H I J K L }\n+    impl_hash_tuple! { T }\n+    impl_hash_tuple! { T B }\n+    impl_hash_tuple! { T B C }\n+    impl_hash_tuple! { T B C D }\n+    impl_hash_tuple! { T B C D E }\n+    impl_hash_tuple! { T B C D E F }\n+    impl_hash_tuple! { T B C D E F G }\n+    impl_hash_tuple! { T B C D E F G H }\n+    impl_hash_tuple! { T B C D E F G H I }\n+    impl_hash_tuple! { T B C D E F G H I J }\n+    impl_hash_tuple! { T B C D E F G H I J K }\n+    impl_hash_tuple! { T B C D E F G H I J K L }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: Hash> Hash for [T] {"}, {"sha": "2c57897956fcd44cb2f9f2cefc16f8e4f80201ee", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -359,7 +359,6 @@ pub trait StructuralEq {\n ///\n /// * Function item types (i.e., the distinct types defined for each function)\n /// * Function pointer types (e.g., `fn() -> i32`)\n-/// * Tuple types, if each component also implements `Copy` (e.g., `()`, `(i32, bool)`)\n /// * Closure types, if they capture no value from the environment\n ///   or if all such captured values implement `Copy` themselves.\n ///   Note that variables captured by shared reference always implement `Copy`"}, {"sha": "00793f7f9204dafd7e85e6f350ecc9a528f48d90", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -439,6 +439,27 @@ mod prim_char {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_unit {}\n \n+// Required to make auto trait impls render.\n+// See src/librustdoc/passes/collect_trait_impls.rs:collect_trait_impls\n+#[doc(hidden)]\n+impl () {}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Clone for () {\n+    fn clone(&self) -> Self {\n+        loop {}\n+    }\n+}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Copy for () {\n+    // empty\n+}\n+\n #[doc(primitive = \"pointer\")]\n #[doc(alias = \"ptr\")]\n #[doc(alias = \"*\")]\n@@ -893,13 +914,18 @@ mod prim_str {}\n ///\n /// For more about tuples, see [the book](../book/ch03-02-data-types.html#the-tuple-type).\n ///\n+// Hardcoded anchor in src/librustdoc/html/format.rs\n+// linked to as `#trait-implementations-1`\n /// # Trait implementations\n ///\n-/// If every type inside a tuple implements one of the following traits, then a\n-/// tuple itself also implements it.\n+/// In this documentation the shorthand `(T\u2081, T\u2082, \u2026, T\u2099)` is used to represent tuples of varying\n+/// length. When that is used, any trait bound expressed on `T` applies to each element of the\n+/// tuple independently. Note that this is a convenience notation to avoid repetitive\n+/// documentation, not valid Rust syntax.\n+///\n+/// Due to a temporary restriction in Rust\u2019s type system, the following traits are only\n+/// implemented on tuples of arity 12 or less. In the future, this may change:\n ///\n-/// * [`Clone`]\n-/// * [`Copy`]\n /// * [`PartialEq`]\n /// * [`Eq`]\n /// * [`PartialOrd`]\n@@ -911,8 +937,21 @@ mod prim_str {}\n /// [`Debug`]: fmt::Debug\n /// [`Hash`]: hash::Hash\n ///\n-/// Due to a temporary restriction in Rust's type system, these traits are only\n-/// implemented on tuples of arity 12 or less. In the future, this may change.\n+/// The following traits are implemented for tuples of any length. These traits have\n+/// implementations that are automatically generated by the compiler, so are not limited by\n+/// missing language features.\n+///\n+/// * [`Clone`]\n+/// * [`Copy`]\n+/// * [`Send`]\n+/// * [`Sync`]\n+/// * [`Unpin`]\n+/// * [`UnwindSafe`]\n+/// * [`RefUnwindSafe`]\n+///\n+/// [`Unpin`]: marker::Unpin\n+/// [`UnwindSafe`]: panic::UnwindSafe\n+/// [`RefUnwindSafe`]: panic::RefUnwindSafe\n ///\n /// # Examples\n ///\n@@ -949,6 +988,31 @@ mod prim_str {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_tuple {}\n \n+// Required to make auto trait impls render.\n+// See src/librustdoc/passes/collect_trait_impls.rs:collect_trait_impls\n+#[doc(hidden)]\n+impl<T> (T,) {}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(bootstrap), doc(tuple_variadic))]\n+/// This trait is implemented on arbitrary-length tuples.\n+impl<T: Clone> Clone for (T,) {\n+    fn clone(&self) -> Self {\n+        loop {}\n+    }\n+}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(bootstrap), doc(tuple_variadic))]\n+/// This trait is implemented on arbitrary-length tuples.\n+impl<T: Copy> Copy for (T,) {\n+    // empty\n+}\n+\n #[doc(primitive = \"f32\")]\n /// A 32-bit floating point type (specifically, the \"binary32\" type defined in IEEE 754-2008).\n ///"}, {"sha": "ab3763cbc4196e07a4ff7794d318d8fcfda74266", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 86, "deletions": 55, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -19,75 +19,106 @@ macro_rules! tuple_impls {\n     };\n     // \"Private\" internal implementation\n     (@impl $( $T:ident )+) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:PartialEq),+> PartialEq for ($($T,)+)\n-        where\n-            last_type!($($T,)+): ?Sized\n-        {\n-            #[inline]\n-            fn eq(&self, other: &($($T,)+)) -> bool {\n-                $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n-            }\n-            #[inline]\n-            fn ne(&self, other: &($($T,)+)) -> bool {\n-                $( ${ignore(T)} self.${index()} != other.${index()} )||+\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:PartialEq),+> PartialEq for ($($T,)+)\n+            where\n+                last_type!($($T,)+): ?Sized\n+            {\n+                #[inline]\n+                fn eq(&self, other: &($($T,)+)) -> bool {\n+                    $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n+                }\n+                #[inline]\n+                fn ne(&self, other: &($($T,)+)) -> bool {\n+                    $( ${ignore(T)} self.${index()} != other.${index()} )||+\n+                }\n             }\n         }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:Eq),+> Eq for ($($T,)+)\n-        where\n-            last_type!($($T,)+): ?Sized\n-        {}\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:Eq),+> Eq for ($($T,)+)\n+            where\n+                last_type!($($T,)+): ?Sized\n+            {}\n+        }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n-        where\n-            last_type!($($T,)+): ?Sized\n-        {\n-            #[inline]\n-            fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n-                lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-            }\n-            #[inline]\n-            fn lt(&self, other: &($($T,)+)) -> bool {\n-                lexical_ord!(lt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-            }\n-            #[inline]\n-            fn le(&self, other: &($($T,)+)) -> bool {\n-                lexical_ord!(le, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-            }\n-            #[inline]\n-            fn ge(&self, other: &($($T,)+)) -> bool {\n-                lexical_ord!(ge, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-            }\n-            #[inline]\n-            fn gt(&self, other: &($($T,)+)) -> bool {\n-                lexical_ord!(gt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n+            where\n+                last_type!($($T,)+): ?Sized\n+            {\n+                #[inline]\n+                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n+                    lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n+                #[inline]\n+                fn lt(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(lt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n+                #[inline]\n+                fn le(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(le, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n+                #[inline]\n+                fn ge(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(ge, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n+                #[inline]\n+                fn gt(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(gt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n             }\n         }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:Ord),+> Ord for ($($T,)+)\n-        where\n-            last_type!($($T,)+): ?Sized\n-        {\n-            #[inline]\n-            fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                lexical_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:Ord),+> Ord for ($($T,)+)\n+            where\n+                last_type!($($T,)+): ?Sized\n+            {\n+                #[inline]\n+                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n+                    lexical_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                }\n             }\n         }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<$($T:Default),+> Default for ($($T,)+) {\n-            #[inline]\n-            fn default() -> ($($T,)+) {\n-                ($({ let x: $T = Default::default(); x},)+)\n+        maybe_tuple_doc! {\n+            $($T)+ @\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:Default),+> Default for ($($T,)+) {\n+                #[inline]\n+                fn default() -> ($($T,)+) {\n+                    ($({ let x: $T = Default::default(); x},)+)\n+                }\n             }\n         }\n     }\n }\n \n+// If this is a unary tuple, it adds a doc comment.\n+// Otherwise, it hides the docs entirely.\n+macro_rules! maybe_tuple_doc {\n+    ($a:ident @ #[$meta:meta] $item:item) => {\n+        #[cfg_attr(not(bootstrap), doc(tuple_variadic))]\n+        #[doc = \"This trait is implemented for tuples up to twelve items long.\"]\n+        #[$meta]\n+        $item\n+    };\n+    ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n+        #[doc(hidden)]\n+        #[$meta]\n+        $item\n+    };\n+}\n+\n // Constructs an expression that performs a lexical ordering using method $rel.\n // The values are interleaved, so the macro invocation for\n // `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_ord!(lt, a1, b1, a2, b2,\n@@ -125,4 +156,4 @@ macro_rules! last_type {\n     ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n }\n \n-tuple_impls!(A B C D E F G H I J K L);\n+tuple_impls!(E D C B A Z Y X W V U T);"}, {"sha": "00793f7f9204dafd7e85e6f350ecc9a528f48d90", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -439,6 +439,27 @@ mod prim_char {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_unit {}\n \n+// Required to make auto trait impls render.\n+// See src/librustdoc/passes/collect_trait_impls.rs:collect_trait_impls\n+#[doc(hidden)]\n+impl () {}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Clone for () {\n+    fn clone(&self) -> Self {\n+        loop {}\n+    }\n+}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Copy for () {\n+    // empty\n+}\n+\n #[doc(primitive = \"pointer\")]\n #[doc(alias = \"ptr\")]\n #[doc(alias = \"*\")]\n@@ -893,13 +914,18 @@ mod prim_str {}\n ///\n /// For more about tuples, see [the book](../book/ch03-02-data-types.html#the-tuple-type).\n ///\n+// Hardcoded anchor in src/librustdoc/html/format.rs\n+// linked to as `#trait-implementations-1`\n /// # Trait implementations\n ///\n-/// If every type inside a tuple implements one of the following traits, then a\n-/// tuple itself also implements it.\n+/// In this documentation the shorthand `(T\u2081, T\u2082, \u2026, T\u2099)` is used to represent tuples of varying\n+/// length. When that is used, any trait bound expressed on `T` applies to each element of the\n+/// tuple independently. Note that this is a convenience notation to avoid repetitive\n+/// documentation, not valid Rust syntax.\n+///\n+/// Due to a temporary restriction in Rust\u2019s type system, the following traits are only\n+/// implemented on tuples of arity 12 or less. In the future, this may change:\n ///\n-/// * [`Clone`]\n-/// * [`Copy`]\n /// * [`PartialEq`]\n /// * [`Eq`]\n /// * [`PartialOrd`]\n@@ -911,8 +937,21 @@ mod prim_str {}\n /// [`Debug`]: fmt::Debug\n /// [`Hash`]: hash::Hash\n ///\n-/// Due to a temporary restriction in Rust's type system, these traits are only\n-/// implemented on tuples of arity 12 or less. In the future, this may change.\n+/// The following traits are implemented for tuples of any length. These traits have\n+/// implementations that are automatically generated by the compiler, so are not limited by\n+/// missing language features.\n+///\n+/// * [`Clone`]\n+/// * [`Copy`]\n+/// * [`Send`]\n+/// * [`Sync`]\n+/// * [`Unpin`]\n+/// * [`UnwindSafe`]\n+/// * [`RefUnwindSafe`]\n+///\n+/// [`Unpin`]: marker::Unpin\n+/// [`UnwindSafe`]: panic::UnwindSafe\n+/// [`RefUnwindSafe`]: panic::RefUnwindSafe\n ///\n /// # Examples\n ///\n@@ -949,6 +988,31 @@ mod prim_str {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_tuple {}\n \n+// Required to make auto trait impls render.\n+// See src/librustdoc/passes/collect_trait_impls.rs:collect_trait_impls\n+#[doc(hidden)]\n+impl<T> (T,) {}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(bootstrap), doc(tuple_variadic))]\n+/// This trait is implemented on arbitrary-length tuples.\n+impl<T: Clone> Clone for (T,) {\n+    fn clone(&self) -> Self {\n+        loop {}\n+    }\n+}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(bootstrap), doc(tuple_variadic))]\n+/// This trait is implemented on arbitrary-length tuples.\n+impl<T: Copy> Copy for (T,) {\n+    // empty\n+}\n+\n #[doc(primitive = \"f32\")]\n /// A 32-bit floating point type (specifically, the \"binary32\" type defined in IEEE 754-2008).\n ///"}, {"sha": "d4c38f34b5b119824c8a11882bcdfea16bff131d", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -500,7 +500,11 @@ pub(crate) fn build_impl(\n             for_,\n             items: trait_items,\n             polarity,\n-            kind: ImplKind::Normal,\n+            kind: if utils::has_doc_flag(tcx, did, sym::tuple_variadic) {\n+                ImplKind::TupleVaradic\n+            } else {\n+                ImplKind::Normal\n+            },\n         }),\n         box merged_attrs,\n         cx,"}, {"sha": "fd30691c32489ea4010b38d73ca8e60c76d51c5f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -1999,7 +1999,11 @@ fn clean_impl<'tcx>(\n             for_,\n             items,\n             polarity: tcx.impl_polarity(def_id),\n-            kind: ImplKind::Normal,\n+            kind: if utils::has_doc_flag(tcx, def_id.to_def_id(), sym::tuple_variadic) {\n+                ImplKind::TupleVaradic\n+            } else {\n+                ImplKind::Normal\n+            },\n         });\n         Item::from_hir_id_and_parts(hir_id, None, kind, cx)\n     };"}, {"sha": "83ab9acd3005a1330bf7883fd5f2a3e6df3ff063", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -1750,7 +1750,7 @@ pub(crate) enum PrimitiveType {\n     Never,\n }\n \n-type SimplifiedTypes = FxHashMap<PrimitiveType, ArrayVec<SimplifiedType, 2>>;\n+type SimplifiedTypes = FxHashMap<PrimitiveType, ArrayVec<SimplifiedType, 3>>;\n impl PrimitiveType {\n     pub(crate) fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n         use ast::{FloatTy, IntTy, UintTy};\n@@ -1839,10 +1839,10 @@ impl PrimitiveType {\n                 //\n                 // Either manually update this arrayvec at this point\n                 // or start with a more complex refactoring.\n-                Tuple => [TupleSimplifiedType(2), TupleSimplifiedType(3)].into(),\n+                Tuple => [TupleSimplifiedType(1), TupleSimplifiedType(2), TupleSimplifiedType(3)].into(),\n                 Unit => single(TupleSimplifiedType(0)),\n-                RawPointer => [PtrSimplifiedType(Mutability::Not), PtrSimplifiedType(Mutability::Mut)].into(),\n-                Reference => [RefSimplifiedType(Mutability::Not), RefSimplifiedType(Mutability::Mut)].into(),\n+                RawPointer => [PtrSimplifiedType(Mutability::Not), PtrSimplifiedType(Mutability::Mut)].into_iter().collect(),\n+                Reference => [RefSimplifiedType(Mutability::Not), RefSimplifiedType(Mutability::Mut)].into_iter().collect(),\n                 // FIXME: This will be wrong if we ever add inherent impls\n                 // for function pointers.\n                 Fn => ArrayVec::new(),\n@@ -2394,6 +2394,7 @@ impl Impl {\n pub(crate) enum ImplKind {\n     Normal,\n     Auto,\n+    TupleVaradic,\n     Blanket(Box<Type>),\n }\n \n@@ -2406,6 +2407,10 @@ impl ImplKind {\n         matches!(self, ImplKind::Blanket(_))\n     }\n \n+    pub(crate) fn is_tuple_variadic(&self) -> bool {\n+        matches!(self, ImplKind::TupleVaradic)\n+    }\n+\n     pub(crate) fn as_blanket_ty(&self) -> Option<&Type> {\n         match self {\n             ImplKind::Blanket(ty) => Some(ty),"}, {"sha": "0c0920ae63e4e33dc43264bda31636ac0fb55df3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -713,6 +713,16 @@ fn primitive_link(\n     prim: clean::PrimitiveType,\n     name: &str,\n     cx: &Context<'_>,\n+) -> fmt::Result {\n+    primitive_link_fragment(f, prim, name, \"\", cx)\n+}\n+\n+fn primitive_link_fragment(\n+    f: &mut fmt::Formatter<'_>,\n+    prim: clean::PrimitiveType,\n+    name: &str,\n+    fragment: &str,\n+    cx: &Context<'_>,\n ) -> fmt::Result {\n     let m = &cx.cache();\n     let mut needs_termination = false;\n@@ -723,7 +733,7 @@ fn primitive_link(\n                 let len = if len == 0 { 0 } else { len - 1 };\n                 write!(\n                     f,\n-                    \"<a class=\\\"primitive\\\" href=\\\"{}primitive.{}.html\\\">\",\n+                    \"<a class=\\\"primitive\\\" href=\\\"{}primitive.{}.html{fragment}\\\">\",\n                     \"../\".repeat(len),\n                     prim.as_sym()\n                 )?;\n@@ -754,7 +764,7 @@ fn primitive_link(\n                 };\n                 if let Some(mut loc) = loc {\n                     loc.push_fmt(format_args!(\"primitive.{}.html\", prim.as_sym()));\n-                    write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}\\\">\", loc.finish())?;\n+                    write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}{fragment}\\\">\", loc.finish())?;\n                     needs_termination = true;\n                 }\n             }\n@@ -1039,7 +1049,13 @@ impl clean::Impl {\n                 write!(f, \" for \")?;\n             }\n \n-            if let Some(ty) = self.kind.as_blanket_ty() {\n+            if let clean::Type::Tuple(types) = &self.for_ &&\n+                let [clean::Type::Generic(name)] = &types[..] &&\n+                (self.kind.is_tuple_variadic() || self.kind.is_auto()) {\n+                // Hardcoded anchor library/core/src/primitive_docs.rs\n+                // Link should match `# Trait implementations`\n+                primitive_link_fragment(f, PrimitiveType::Tuple, &format!(\"({name}\u2081, {name}\u2082, \u2026, {name}\u2099)\"), \"#trait-implementations-1\", cx)?;\n+            } else if let Some(ty) = self.kind.as_blanket_ty() {\n                 fmt_type(ty, f, use_absolute, cx)?;\n             } else {\n                 fmt_type(&self.for_, f, use_absolute, cx)?;"}, {"sha": "4fde63c99d4b962f662b7b535959df45470c7f03", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -552,7 +552,7 @@ impl FromWithTcx<clean::Impl> for Impl {\n         let trait_ = trait_.map(|path| clean::Type::Path { path }.into_tcx(tcx));\n         // FIXME: use something like ImplKind in JSON?\n         let (synthetic, blanket_impl) = match kind {\n-            clean::ImplKind::Normal => (false, None),\n+            clean::ImplKind::Normal | clean::ImplKind::TupleVaradic => (false, None),\n             clean::ImplKind::Auto => (true, None),\n             clean::ImplKind::Blanket(ty) => (false, Some(*ty)),\n         };"}, {"sha": "11ce2dbe280500f201178295801dda910d0f1668", "filename": "src/test/rustdoc-ui/tuple-variadic-check.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc-ui%2Ftuple-variadic-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc-ui%2Ftuple-variadic-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ftuple-variadic-check.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -0,0 +1,15 @@\n+#![feature(rustdoc_internals)]\n+\n+trait Mine {}\n+\n+// This one is fine\n+#[doc(tuple_variadic)]\n+impl<T> Mine for (T,) {}\n+\n+trait Mine2 {}\n+\n+// This one is not\n+#[doc(tuple_variadic)] //~ ERROR\n+impl<T, U> Mine for (T,U) {}\n+\n+fn main() {}"}, {"sha": "358d06d6a42dd4a5028eea021d2c83a5e3b9b4f5", "filename": "src/test/rustdoc-ui/tuple-variadic-check.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc-ui%2Ftuple-variadic-check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc-ui%2Ftuple-variadic-check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ftuple-variadic-check.stderr?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -0,0 +1,8 @@\n+error: `#[doc(tuple_variadic)]` must be used on the first of a set of tuple trait impls with varying arity\n+  --> $DIR/tuple-variadic-check.rs:12:7\n+   |\n+LL | #[doc(tuple_variadic)]\n+   |       ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "71b0b07700958967dcec531d4233833c133260bb", "filename": "src/test/rustdoc/primitive-tuple-auto-trait.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc%2Fprimitive-tuple-auto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc%2Fprimitive-tuple-auto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-tuple-auto-trait.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: --crate-type lib --edition 2018\n+\n+#![crate_name = \"foo\"]\n+#![feature(rustdoc_internals)]\n+\n+// @has foo/primitive.tuple.html '//a[@class=\"primitive\"]' 'tuple'\n+// @has - '//span[@class=\"in-band\"]' 'Primitive Type tuple'\n+// @has - '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n+// @has - '//h2[@id=\"synthetic-implementations\"]' 'Auto Trait Implementations'\n+// @has - '//div[@id=\"synthetic-implementations-list\"]//h3' 'Send'\n+// @has - '//div[@id=\"synthetic-implementations-list\"]//h3' 'Sync'\n+#[doc(primitive = \"tuple\")]\n+/// this is a test!\n+///\n+// Hardcoded anchor to header written in library/core/src/primitive_docs.rs\n+// @has - '//h2[@id=\"trait-implementations-1\"]' 'Trait implementations'\n+/// # Trait implementations\n+///\n+/// This header is hard-coded in the HTML format linking for `#[doc(tuple_variadics)]`.\n+/// To make sure it gets linked correctly, we need to make sure the hardcoded anchor\n+/// in the code matches what rustdoc generates for the header.\n+mod tuple_prim {}"}, {"sha": "4fd6254f6740d0a2e8545445fb732b228023c2ee", "filename": "src/test/rustdoc/primitive-tuple-variadic.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc%2Fprimitive-tuple-variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc%2Fprimitive-tuple-variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-tuple-variadic.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: --crate-type lib --edition 2018\n+\n+#![crate_name = \"foo\"]\n+#![feature(rustdoc_internals)]\n+\n+pub trait Foo {}\n+\n+// @has foo/trait.Foo.html\n+// @has - '//section[@id=\"impl-Foo-for-(T%2C)\"]/h3' 'impl<T> Foo for (T\u2081, T\u2082, \u2026, T\u2099)'\n+#[doc(tuple_variadic)]\n+impl<T> Foo for (T,) {}\n+\n+pub trait Bar {}\n+\n+// @has foo/trait.Bar.html\n+// @has - '//section[@id=\"impl-Bar-for-(U%2C)\"]/h3' 'impl<U: Foo> Bar for (U\u2081, U\u2082, \u2026, U\u2099)'\n+#[doc(tuple_variadic)]\n+impl<U: Foo> Bar for (U,) {}"}, {"sha": "76182622ef5fbfd738694005c32c89219244e14b", "filename": "src/test/rustdoc/primitive-unit-auto-trait.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc%2Fprimitive-unit-auto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Frustdoc%2Fprimitive-unit-auto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-unit-auto-trait.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: --crate-type lib --edition 2018\n+\n+#![crate_name = \"foo\"]\n+#![feature(rustdoc_internals)]\n+\n+// @has foo/primitive.unit.html '//a[@class=\"primitive\"]' 'unit'\n+// @has - '//span[@class=\"in-band\"]' 'Primitive Type unit'\n+// @has - '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n+// @has - '//h2[@id=\"synthetic-implementations\"]' 'Auto Trait Implementations'\n+// @has - '//div[@id=\"synthetic-implementations-list\"]//h3' 'impl Send for ()'\n+// @has - '//div[@id=\"synthetic-implementations-list\"]//h3' 'impl Sync for ()'\n+#[doc(primitive = \"unit\")]\n+/// this is a test!\n+mod unit_prim {}"}, {"sha": "6a144412d0751541c914963d464d2bd25a6330dd", "filename": "src/test/ui/feature-gates/feature-gate-rustdoc_internals.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustdoc_internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustdoc_internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustdoc_internals.rs?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -2,4 +2,9 @@\n /// wonderful\n mod foo {}\n \n+trait Mine {}\n+\n+#[doc(tuple_variadic)]  //~ ERROR: `#[doc(tuple_variadic)]` is meant for internal use only\n+impl<T> Mine for (T,) {}\n+\n fn main() {}"}, {"sha": "9fe08afd4f05e116501cecad567b092e2fd109c6", "filename": "src/test/ui/feature-gates/feature-gate-rustdoc_internals.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustdoc_internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustdoc_internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustdoc_internals.stderr?ref=6ec3993ef4a4eb72bc20477fe9a4d92acd53f2c6", "patch": "@@ -7,6 +7,15 @@ LL | #[doc(keyword = \"match\")]\n    = note: see issue #90418 <https://github.com/rust-lang/rust/issues/90418> for more information\n    = help: add `#![feature(rustdoc_internals)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: `#[doc(tuple_variadic)]` is meant for internal use only\n+  --> $DIR/feature-gate-rustdoc_internals.rs:7:1\n+   |\n+LL | #[doc(tuple_variadic)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #90418 <https://github.com/rust-lang/rust/issues/90418> for more information\n+   = help: add `#![feature(rustdoc_internals)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}]}