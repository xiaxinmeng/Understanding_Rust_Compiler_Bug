{"sha": "5809f8ae746dbde96e0924b8e422b9e0d092375b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MDlmOGFlNzQ2ZGJkZTk2ZTA5MjRiOGU0MjJiOWUwZDA5MjM3NWI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-05T07:19:07Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:14:16Z"}, "message": "rustc_resolve: use the visitor model more, remove redundant repeated lookups.", "tree": {"sha": "c9d4cc7863019b1f9955afad67d75345df2dc3bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9d4cc7863019b1f9955afad67d75345df2dc3bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5809f8ae746dbde96e0924b8e422b9e0d092375b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5809f8ae746dbde96e0924b8e422b9e0d092375b", "html_url": "https://github.com/rust-lang/rust/commit/5809f8ae746dbde96e0924b8e422b9e0d092375b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5809f8ae746dbde96e0924b8e422b9e0d092375b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffb8092ccf8dd186a9a03e6808d04a7276206793", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffb8092ccf8dd186a9a03e6808d04a7276206793", "html_url": "https://github.com/rust-lang/rust/commit/ffb8092ccf8dd186a9a03e6808d04a7276206793"}], "stats": {"total": 1057, "additions": 335, "deletions": 722}, "files": [{"sha": "d45c18efee7b4156f2801ec91ce3a57bb2328b06", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -35,55 +35,36 @@ pub fn check_path_args(tcx: &ty::ctxt,\n     if (flags & NO_REGIONS) != 0 {\n         if path.segments.iter().any(|s| s.parameters.has_lifetimes()) {\n             span_err!(tcx.sess, path.span, E0110,\n-                \"region parameters are not allowed on this type\");\n+                \"lifetime parameters are not allowed on this type\");\n         }\n     }\n }\n \n pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                                -> Option<Ty<'tcx>> {\n-    match ast_ty.node {\n-        ast::TyPath(ref path) => {\n-            let a_def = match tcx.def_map.borrow().get(&ast_ty.id) {\n-                None => {\n-                    tcx.sess.span_bug(ast_ty.span,\n-                                      &format!(\"unbound path {}\",\n-                                              path.repr(tcx)))\n-                }\n-                Some(&d) => d\n-            };\n-            match a_def {\n-                def::DefPrimTy(nty) => {\n-                    match nty {\n-                        ast::TyBool => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(tcx.types.bool)\n-                        }\n-                        ast::TyChar => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(tcx.types.char)\n-                        }\n-                        ast::TyInt(it) => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_int(tcx, it))\n-                        }\n-                        ast::TyUint(uit) => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_uint(tcx, uit))\n-                        }\n-                        ast::TyFloat(ft) => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_float(tcx, ft))\n-                        }\n-                        ast::TyStr => {\n-                            Some(ty::mk_str(tcx))\n-                        }\n-                    }\n-                }\n-                _ => None\n+    if let ast::TyPath(ref path) = ast_ty.node {\n+        let def = match tcx.def_map.borrow().get(&ast_ty.id) {\n+            None => {\n+                tcx.sess.span_bug(ast_ty.span,\n+                                  &format!(\"unbound path {}\", path.repr(tcx)))\n             }\n+            Some(&d) => d\n+        };\n+        if let def::DefPrimTy(nty) = def {\n+            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+            Some(match nty {\n+                ast::TyBool => tcx.types.bool,\n+                ast::TyChar => tcx.types.char,\n+                ast::TyInt(it) => ty::mk_mach_int(tcx, it),\n+                ast::TyUint(uit) => ty::mk_mach_uint(tcx, uit),\n+                ast::TyFloat(ft) => ty::mk_mach_float(tcx, ft),\n+                ast::TyStr => ty::mk_str(tcx)\n+            })\n+        } else {\n+            None\n         }\n-        _ => None\n+    } else {\n+        None\n     }\n }\n "}, {"sha": "37586b08b3654242b10f89565c6f13feff0ec268", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -456,9 +456,6 @@ impl tr for def::Def {\n           }\n           def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n           def::DefRegion(nid) => def::DefRegion(dcx.tr_id(nid)),\n-          def::DefTyParamBinder(nid) => {\n-            def::DefTyParamBinder(dcx.tr_id(nid))\n-          }\n           def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid))\n         }\n     }"}, {"sha": "191672775f25354daade57b14ba014d29beae14b", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -54,7 +54,6 @@ pub enum Def {\n     /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n     ///   it to a def whose id is the StructDef.ctor_id.\n     DefStruct(ast::DefId),\n-    DefTyParamBinder(ast::NodeId), /* struct, impl or trait with ty params */\n     DefRegion(ast::NodeId),\n     DefLabel(ast::NodeId),\n     DefMethod(ast::DefId /* method */, Option<ast::DefId> /* trait */, MethodProvenance),\n@@ -145,7 +144,6 @@ impl Def {\n             DefSelfTy(id) |\n             DefUpvar(id, _) |\n             DefRegion(id) |\n-            DefTyParamBinder(id) |\n             DefLabel(id) => {\n                 local_def(id)\n             }"}, {"sha": "59e090a603703ee1780f94a1eb3bab377047df5e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -580,7 +580,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n           def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n-          def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n+          def::DefTyParam(..) | def::DefRegion(_) |\n           def::DefLabel(_) | def::DefSelfTy(..) |\n           def::DefAssociatedTy(..) | def::DefAssociatedPath(..)=> {\n               Ok(Rc::new(cmt_ {"}, {"sha": "cc47090198ba2237e42038848f85e1990ed457ce", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -23,18 +23,15 @@ use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n use ParentLink::{self, ModuleParentLink, BlockParentLink};\n use Resolver;\n-use RibKind::*;\n use Shadowable;\n use TypeNsDef;\n-use TypeParameters::HasTypeParameters;\n \n use self::DuplicateCheckingMode::*;\n use self::NamespaceError::*;\n \n use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n-use rustc::middle::subst::FnSpace;\n \n use syntax::ast::{Block, Crate};\n use syntax::ast::{DeclItem, DefId};\n@@ -773,38 +770,25 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item<F>(&mut self,\n-                                               foreign_item: &ForeignItem,\n-                                               parent: &Rc<Module>,\n-                                               f: F) where\n-        F: FnOnce(&mut Resolver),\n-    {\n+    fn build_reduced_graph_for_foreign_item(&mut self,\n+                                            foreign_item: &ForeignItem,\n+                                            parent: &Rc<Module>) {\n         let name = foreign_item.ident.name;\n         let is_public = foreign_item.vis == ast::Public;\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n         let name_bindings =\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n \n-        match foreign_item.node {\n-            ForeignItemFn(_, ref generics) => {\n-                let def = DefFn(local_def(foreign_item.id), false);\n-                name_bindings.define_value(def, foreign_item.span, modifiers);\n-\n-                self.with_type_parameter_rib(\n-                    HasTypeParameters(generics,\n-                                      FnSpace,\n-                                      foreign_item.id,\n-                                      NormalRibKind),\n-                    f);\n+        let def = match foreign_item.node {\n+            ForeignItemFn(..) => {\n+                DefFn(local_def(foreign_item.id), false)\n             }\n             ForeignItemStatic(_, m) => {\n-                let def = DefStatic(local_def(foreign_item.id), m);\n-                name_bindings.define_value(def, foreign_item.span, modifiers);\n-\n-                f(self.resolver)\n+                DefStatic(local_def(foreign_item.id), m)\n             }\n-        }\n+        };\n+        name_bindings.define_value(def, foreign_item.span, modifiers);\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &Rc<Module>) -> Rc<Module> {\n@@ -980,7 +964,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n           }\n           DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n-          DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n+          DefLabel(..) | DefSelfTy(..) => {\n             panic!(\"didn't expect `{:?}`\", def);\n           }\n         }\n@@ -1241,16 +1225,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        let parent = &self.parent;\n-        self.builder.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                          parent,\n-                                                          |r| {\n-            let mut v = BuildReducedGraphVisitor {\n-                builder: GraphBuilder { resolver: r },\n-                parent: parent.clone()\n-            };\n-            visit::walk_foreign_item(&mut v, foreign_item);\n-        })\n+        self.builder.build_reduced_graph_for_foreign_item(foreign_item, &self.parent);\n     }\n \n     fn visit_block(&mut self, block: &Block) {"}, {"sha": "b211681992ba96dfb51de53bcfa9feae0848df84", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 252, "deletions": 592, "changes": 844, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -41,14 +41,12 @@ use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n use self::RibKind::*;\n-use self::MethodSort::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n use self::ModuleKind::*;\n-use self::TraitReferenceType::*;\n use self::FallbackChecks::*;\n \n use rustc::session::Session;\n@@ -66,21 +64,18 @@ use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n-use syntax::ast::{ExprClosure, ExprLoop, ExprWhile, ExprMethodCall};\n+use syntax::ast::{ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n-use syntax::ast::{Local, MethodImplItem, Mod, Name, NodeId};\n+use syntax::ast::{Local, MethodImplItem, Name, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n-use syntax::ast::{PatRange, PatStruct, Path};\n-use syntax::ast::{PolyTraitRef, PrimTy, SelfExplicit};\n-use syntax::ast::{RegionTyParamBound, StructField};\n-use syntax::ast::{TraitRef, TraitTyParamBound};\n-use syntax::ast::{Ty, TyBool, TyChar, TyF32};\n-use syntax::ast::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt, TyObjectSum};\n-use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyPolyTraitRef, TyQPath};\n+use syntax::ast::{PatRange, PatStruct, Path, PrimTy};\n+use syntax::ast::{TraitRef, Ty, TyBool, TyChar, TyF32};\n+use syntax::ast::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt};\n+use syntax::ast::{TyPath, TyPtr, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyUs, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem};\n use syntax::ast;\n@@ -89,8 +84,7 @@ use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::{self, special_names, special_idents};\n-use syntax::codemap::{Span, Pos};\n-use syntax::owned_slice::OwnedSlice;\n+use syntax::codemap::{self, Span, Pos};\n use syntax::visit::{self, Visitor};\n \n use std::collections::{HashMap, HashSet};\n@@ -188,6 +182,72 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &Ty) {\n         self.resolve_type(ty);\n     }\n+    fn visit_generics(&mut self, generics: &Generics) {\n+        self.resolve_generics(generics);\n+    }\n+    fn visit_poly_trait_ref(&mut self,\n+                            tref: &ast::PolyTraitRef,\n+                            m: &ast::TraitBoundModifier) {\n+        match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0) {\n+            Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n+            Err(_) => { /* error already reported */ }\n+        }\n+        visit::walk_poly_trait_ref(self, tref, m);\n+    }\n+    fn visit_variant(&mut self, variant: &ast::Variant, generics: &Generics) {\n+        if let Some(ref dis_expr) = variant.node.disr_expr {\n+            // resolve the discriminator expr as a constant\n+            self.with_constant_rib(|this| {\n+                this.visit_expr(&**dis_expr);\n+            });\n+        }\n+\n+        // `visit::walk_variant` without the discriminant expression.\n+        match variant.node.kind {\n+            ast::TupleVariantKind(ref variant_arguments) => {\n+                for variant_argument in variant_arguments.iter() {\n+                    self.visit_ty(&*variant_argument.ty);\n+                }\n+            }\n+            ast::StructVariantKind(ref struct_definition) => {\n+                self.visit_struct_def(&**struct_definition,\n+                                      variant.node.name,\n+                                      generics,\n+                                      variant.node.id);\n+            }\n+        }\n+    }\n+    fn visit_foreign_item(&mut self, foreign_item: &ast::ForeignItem) {\n+        let type_parameters = match foreign_item.node {\n+            ForeignItemFn(_, ref generics) => {\n+                HasTypeParameters(generics, FnSpace, ItemRibKind)\n+            }\n+            ForeignItemStatic(..) => NoTypeParameters\n+        };\n+        self.with_type_parameter_rib(type_parameters, |this| {\n+            visit::walk_foreign_item(this, foreign_item);\n+        });\n+    }\n+    fn visit_fn(&mut self,\n+                function_kind: visit::FnKind<'v>,\n+                declaration: &'v FnDecl,\n+                block: &'v Block,\n+                _: Span,\n+                node_id: NodeId) {\n+        let rib_kind = match function_kind {\n+            visit::FkItemFn(_, generics, _, _) => {\n+                self.visit_generics(generics);\n+                ItemRibKind\n+            }\n+            visit::FkMethod(_, generics, method) => {\n+                self.visit_generics(generics);\n+                self.visit_explicit_self(method.pe_explicit_self());\n+                MethodRibKind\n+            }\n+            visit::FkFnBlock(..) => ClosureRibKind(node_id)\n+        };\n+        self.resolve_function(rib_kind, declaration, block);\n+    }\n }\n \n /// Contains data for specific types of import directives.\n@@ -231,9 +291,6 @@ enum TypeParameters<'a> {\n         // were declared on (type, fn, etc)\n         ParamSpace,\n \n-        // ID of the enclosing item.\n-        NodeId,\n-\n         // The kind of the rib used for type parameters.\n         RibKind)\n }\n@@ -253,8 +310,7 @@ enum RibKind {\n     // methods. Allow references to ty params that impl or trait\n     // binds. Disallow any other upvars (including other ty params that are\n     // upvars).\n-              // parent;   method itself\n-    MethodRibKind(NodeId, MethodSort),\n+    MethodRibKind,\n \n     // We passed through an item scope. Disallow upvars.\n     ItemRibKind,\n@@ -263,13 +319,6 @@ enum RibKind {\n     ConstantItemRibKind\n }\n \n-// Methods can be required or provided. RequiredMethod methods only occur in traits.\n-#[derive(Copy, Debug)]\n-enum MethodSort {\n-    RequiredMethod,\n-    ProvidedMethod(NodeId)\n-}\n-\n #[derive(Copy)]\n enum UseLexicalScopeFlag {\n     DontUseLexicalScope,\n@@ -586,16 +635,6 @@ struct NameBindings {\n     value_def: RefCell<Option<ValueNsDef>>, //< Meaning in value namespace.\n }\n \n-/// Ways in which a trait can be referenced\n-#[derive(Copy)]\n-enum TraitReferenceType {\n-    TraitImplementation,             // impl SomeTrait for T { ... }\n-    TraitDerivation,                 // trait T : SomeTrait { ... }\n-    TraitBoundingTypeParameter,      // fn f<T:SomeTrait>() { ... }\n-    TraitObject,                     // Box<for<'a> SomeTrait>\n-    TraitQPath,                      // <T as SomeTrait>::\n-}\n-\n impl NameBindings {\n     fn new() -> NameBindings {\n         NameBindings {\n@@ -2600,14 +2639,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 def_like: DefLike,\n                 span: Span)\n                 -> Option<DefLike> {\n-        match def_like {\n-            DlDef(d @ DefUpvar(..)) => {\n+        let mut def = match def_like {\n+            DlDef(def) => def,\n+            _ => return Some(def_like)\n+        };\n+        match def {\n+            DefUpvar(..) => {\n                 self.session.span_bug(span,\n-                    &format!(\"unexpected {:?} in bindings\", d))\n+                    &format!(\"unexpected {:?} in bindings\", def))\n             }\n-            DlDef(d @ DefLocal(_)) => {\n-                let node_id = d.def_id().node;\n-                let mut def = d;\n+            DefLocal(node_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind => {\n@@ -2631,82 +2672,32 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             }.push(Freevar { def: prev_def, span: span });\n                             seen.insert(node_id);\n                         }\n-                        MethodRibKind(item_id, _) => {\n-                            // If the def is a ty param, and came from the parent\n-                            // item, it's ok\n-                            match def {\n-                                DefTyParam(_, _, did, _) if {\n-                                    self.def_map.borrow().get(&did.node).cloned()\n-                                        == Some(DefTyParamBinder(item_id))\n-                                } => {} // ok\n-                                DefSelfTy(did) if did == item_id => {} // ok\n-                                _ => {\n-                                    // This was an attempt to access an upvar inside a\n-                                    // named function item. This is not allowed, so we\n-                                    // report an error.\n-\n-                                    self.resolve_error(\n-                                        span,\n-                                        \"can't capture dynamic environment in a fn item; \\\n-                                        use the || { ... } closure form instead\");\n-\n-                                    return None;\n-                                }\n-                            }\n-                        }\n-                        ItemRibKind => {\n+                        ItemRibKind | MethodRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n \n-                            self.resolve_error(\n-                                span,\n+                            self.resolve_error(span,\n                                 \"can't capture dynamic environment in a fn item; \\\n-                                use the || { ... } closure form instead\");\n-\n+                                 use the || { ... } closure form instead\");\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n                             self.resolve_error(span,\n                                                \"attempt to use a non-constant \\\n                                                 value in a constant\");\n-\n+                            return None;\n                         }\n                     }\n                 }\n-                Some(DlDef(def))\n             }\n-            DlDef(def @ DefTyParam(..)) |\n-            DlDef(def @ DefSelfTy(..)) => {\n+            DefTyParam(..) | DefSelfTy(_) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | ClosureRibKind(..) => {\n+                        NormalRibKind | MethodRibKind | ClosureRibKind(..) => {\n                             // Nothing to do. Continue.\n                         }\n-                        MethodRibKind(item_id, _) => {\n-                            // If the def is a ty param, and came from the parent\n-                            // item, it's ok\n-                            match def {\n-                                DefTyParam(_, _, did, _) if {\n-                                    self.def_map.borrow().get(&did.node).cloned()\n-                                        == Some(DefTyParamBinder(item_id))\n-                                } => {} // ok\n-                                DefSelfTy(did) if did == item_id => {} // ok\n-\n-                                _ => {\n-                                    // This was an attempt to use a type parameter outside\n-                                    // its scope.\n-\n-                                    self.resolve_error(span,\n-                                                        \"can't use type parameters from \\\n-                                                        outer function; try using a local \\\n-                                                        type parameter instead\");\n-\n-                                    return None;\n-                                }\n-                            }\n-                        }\n                         ItemRibKind => {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n@@ -2715,22 +2706,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                \"can't use type parameters from \\\n                                                 outer function; try using a local \\\n                                                 type parameter instead\");\n-\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n                             self.resolve_error(span,\n                                                \"cannot use an outer type \\\n                                                 parameter in this context\");\n-\n+                            return None;\n                         }\n                     }\n                 }\n-                Some(DlDef(def))\n             }\n-            _ => Some(def_like)\n+            _ => {}\n         }\n+        Some(DlDef(def))\n     }\n \n     /// Searches the current set of local scopes and\n@@ -2743,13 +2733,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // FIXME #4950: Try caching?\n \n         for (i, rib) in ribs.iter().enumerate().rev() {\n-            match rib.bindings.get(&name).cloned() {\n-                Some(def_like) => {\n-                    return self.upvarify(&ribs[i + 1..], def_like, span);\n-                }\n-                None => {\n-                    // Continue.\n-                }\n+            if let Some(def_like) = rib.bindings.get(&name).cloned() {\n+                return self.upvarify(&ribs[i + 1..], def_like, span);\n             }\n         }\n \n@@ -2797,47 +2782,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                token::get_name(name));\n \n         match item.node {\n-\n-            // enum item: resolve all the variants' discrs,\n-            // then resolve the ty params\n-            ItemEnum(ref enum_def, ref generics) => {\n+            ItemEnum(_, ref generics) |\n+            ItemTy(_, ref generics) |\n+            ItemStruct(_, ref generics) => {\n                 self.check_if_primitive_type_name(name, item.span);\n \n-                for variant in &(*enum_def).variants {\n-                    if let Some(ref dis_expr) = variant.node.disr_expr {\n-                        // resolve the discriminator expr\n-                        // as a constant\n-                        self.with_constant_rib(|this| {\n-                            this.resolve_expr(&**dis_expr);\n-                        });\n-                    }\n-                }\n-\n-                // n.b. the discr expr gets visited twice.\n-                // but maybe it's okay since the first time will signal an\n-                // error if there is one? -- tjc\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                TypeSpace,\n-                                                               item.id,\n                                                                ItemRibKind),\n-                                             |this| {\n-                    this.resolve_type_parameters(&generics.ty_params);\n-                    this.resolve_where_clause(&generics.where_clause);\n-                    visit::walk_item(this, item);\n-                });\n+                                             |this| visit::walk_item(this, item));\n             }\n-\n-            ItemTy(_, ref generics) => {\n-                self.check_if_primitive_type_name(name, item.span);\n-\n+            ItemFn(_, _, _, ref generics, _) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n-                                                               TypeSpace,\n-                                                               item.id,\n+                                                               FnSpace,\n                                                                ItemRibKind),\n-                                             |this| {\n-                    this.resolve_type_parameters(&generics.ty_params);\n-                    visit::walk_item(this, item);\n-                });\n+                                             |this| visit::walk_item(this, item));\n             }\n \n             ItemDefaultImpl(_, ref trait_ref) => {\n@@ -2848,8 +2807,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                      ref implemented_traits,\n                      ref self_type,\n                      ref impl_items) => {\n-                self.resolve_implementation(item.id,\n-                                            generics,\n+                self.resolve_implementation(generics,\n                                             implemented_traits,\n                                             &**self_type,\n                                             &impl_items[..]);\n@@ -2869,115 +2827,45 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                TypeSpace,\n-                                                               item.id,\n                                                                NormalRibKind),\n                                              |this| {\n-                    this.resolve_type_parameters(&generics.ty_params);\n-                    this.resolve_where_clause(&generics.where_clause);\n-\n-                    this.resolve_type_parameter_bounds(bounds, TraitDerivation);\n+                    this.visit_generics(generics);\n+                    visit::walk_ty_param_bounds_helper(this, bounds);\n \n                     for trait_item in &(*trait_items) {\n                         // Create a new rib for the trait_item-specific type\n                         // parameters.\n                         //\n                         // FIXME #4951: Do we need a node ID here?\n \n-                        match *trait_item {\n-                          ast::RequiredMethod(ref ty_m) => {\n-                            this.with_type_parameter_rib\n-                                (HasTypeParameters(&ty_m.generics,\n-                                                   FnSpace,\n-                                                   item.id,\n-                                        MethodRibKind(item.id, RequiredMethod)),\n-                                 |this| {\n-\n-                                // Resolve the method-specific type\n-                                // parameters.\n-                                this.resolve_type_parameters(\n-                                    &ty_m.generics.ty_params);\n-                                this.resolve_where_clause(&ty_m.generics\n-                                                               .where_clause);\n-\n-                                for argument in &ty_m.decl.inputs {\n-                                    this.resolve_type(&*argument.ty);\n-                                }\n-\n-                                if let SelfExplicit(ref typ, _) = ty_m.explicit_self.node {\n-                                    this.resolve_type(&**typ)\n-                                }\n-\n-                                if let ast::Return(ref ret_ty) = ty_m.decl.output {\n-                                    this.resolve_type(&**ret_ty);\n-                                }\n-                            });\n-                          }\n-                          ast::ProvidedMethod(ref m) => {\n-                              this.resolve_method(MethodRibKind(item.id,\n-                                                                ProvidedMethod(m.id)),\n-                                                  &**m)\n-                          }\n-                          ast::TypeTraitItem(ref data) => {\n-                              this.resolve_type_parameter(&data.ty_param);\n-                              visit::walk_trait_item(this, trait_item);\n-                          }\n-                        }\n+                        let type_parameters = match *trait_item {\n+                            ast::RequiredMethod(ref ty_m) => {\n+                                HasTypeParameters(&ty_m.generics,\n+                                                  FnSpace,\n+                                                  MethodRibKind)\n+                            }\n+                            ast::ProvidedMethod(ref m) => {\n+                                HasTypeParameters(m.pe_generics(),\n+                                                  FnSpace,\n+                                                  MethodRibKind)\n+                            }\n+                            ast::TypeTraitItem(_) => NoTypeParameters,\n+                        };\n+                        this.with_type_parameter_rib(type_parameters, |this| {\n+                            visit::walk_trait_item(this, trait_item)\n+                        });\n                     }\n                 });\n \n                 self.type_ribs.pop();\n             }\n \n-            ItemStruct(ref struct_def, ref generics) => {\n-                self.check_if_primitive_type_name(name, item.span);\n-\n-                self.resolve_struct(item.id,\n-                                    generics,\n-                                    &struct_def.fields);\n-            }\n-\n-            ItemMod(ref module_) => {\n+            ItemMod(_) | ItemForeignMod(_) => {\n                 self.with_scope(Some(name), |this| {\n-                    this.resolve_module(module_, item.span, name,\n-                                        item.id);\n-                });\n-            }\n-\n-            ItemForeignMod(ref foreign_module) => {\n-                self.with_scope(Some(name), |this| {\n-                    for foreign_item in &foreign_module.items {\n-                        match foreign_item.node {\n-                            ForeignItemFn(_, ref generics) => {\n-                                this.with_type_parameter_rib(\n-                                    HasTypeParameters(\n-                                        generics, FnSpace, foreign_item.id,\n-                                        ItemRibKind),\n-                                    |this| {\n-                                        this.resolve_type_parameters(&generics.ty_params);\n-                                        this.resolve_where_clause(&generics.where_clause);\n-                                        visit::walk_foreign_item(this, &**foreign_item)\n-                                    });\n-                            }\n-                            ForeignItemStatic(..) => {\n-                                visit::walk_foreign_item(this,\n-                                                         &**foreign_item);\n-                            }\n-                        }\n-                    }\n+                    visit::walk_item(this, item);\n                 });\n             }\n \n-            ItemFn(ref fn_decl, _, _, ref generics, ref block) => {\n-                self.resolve_function(ItemRibKind,\n-                                      Some(&**fn_decl),\n-                                      HasTypeParameters\n-                                        (generics,\n-                                         FnSpace,\n-                                         item.id,\n-                                         ItemRibKind),\n-                                      &**block);\n-            }\n-\n             ItemConst(..) | ItemStatic(..) => {\n                 self.with_constant_rib(|this| {\n                     visit::walk_item(this, item);\n@@ -3006,35 +2894,29 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         F: FnOnce(&mut Resolver),\n     {\n         match type_parameters {\n-            HasTypeParameters(generics, space, node_id, rib_kind) => {\n+            HasTypeParameters(generics, space, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = HashSet::new();\n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let name = type_parameter.ident.name;\n-                    debug!(\"with_type_parameter_rib: {} {}\", node_id,\n-                           type_parameter.id);\n+                    debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n                         self.resolve_error(type_parameter.span,\n                                            &format!(\"the name `{}` is already \\\n-                                                    used for a type \\\n-                                                    parameter in this type \\\n-                                                    parameter list\",\n-                                                   token::get_name(\n-                                                       name)))\n+                                                     used for a type \\\n+                                                     parameter in this type \\\n+                                                     parameter list\",\n+                                                    token::get_name(name)))\n                     }\n                     seen_bindings.insert(name);\n \n-                    let def_like = DlDef(DefTyParam(space,\n-                                                    index as u32,\n-                                                    local_def(type_parameter.id),\n-                                                    name));\n-                    // Associate this type parameter with\n-                    // the item that bound it\n-                    self.record_def(type_parameter.id,\n-                                    (DefTyParamBinder(node_id), LastMod(AllPublic)));\n                     // plain insert (no renaming)\n-                    function_type_rib.bindings.insert(name, def_like);\n+                    function_type_rib.bindings.insert(name,\n+                        DlDef(DefTyParam(space,\n+                                         index as u32,\n+                                         local_def(type_parameter.id),\n+                                         name)));\n                 }\n                 self.type_ribs.push(function_type_rib);\n             }\n@@ -3072,154 +2954,74 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_function(&mut self,\n                         rib_kind: RibKind,\n-                        optional_declaration: Option<&FnDecl>,\n-                        type_parameters: TypeParameters,\n+                        declaration: &FnDecl,\n                         block: &Block) {\n         // Create a value rib for the function.\n-        let function_value_rib = Rib::new(rib_kind);\n-        self.value_ribs.push(function_value_rib);\n+        self.value_ribs.push(Rib::new(rib_kind));\n \n         // Create a label rib for the function.\n-        let function_label_rib = Rib::new(rib_kind);\n-        self.label_ribs.push(function_label_rib);\n-\n-        // If this function has type parameters, add them now.\n-        self.with_type_parameter_rib(type_parameters, |this| {\n-            // Resolve the type parameters.\n-            match type_parameters {\n-                NoTypeParameters => {\n-                    // Continue.\n-                }\n-                HasTypeParameters(ref generics, _, _, _) => {\n-                    this.resolve_type_parameters(&generics.ty_params);\n-                    this.resolve_where_clause(&generics.where_clause);\n-                }\n-            }\n+        self.label_ribs.push(Rib::new(rib_kind));\n \n-            // Add each argument to the rib.\n-            match optional_declaration {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(declaration) => {\n-                    let mut bindings_list = HashMap::new();\n-                    for argument in &declaration.inputs {\n-                        this.resolve_pattern(&*argument.pat,\n-                                             ArgumentIrrefutableMode,\n-                                             &mut bindings_list);\n-\n-                        this.resolve_type(&*argument.ty);\n+        // Add each argument to the rib.\n+        let mut bindings_list = HashMap::new();\n+        for argument in &declaration.inputs {\n+            self.resolve_pattern(&*argument.pat,\n+                                 ArgumentIrrefutableMode,\n+                                 &mut bindings_list);\n \n-                        debug!(\"(resolving function) recorded argument\");\n-                    }\n+            self.visit_ty(&*argument.ty);\n \n-                    if let ast::Return(ref ret_ty) = declaration.output {\n-                        this.resolve_type(&**ret_ty);\n-                    }\n-                }\n-            }\n+            debug!(\"(resolving function) recorded argument\");\n+        }\n+        visit::walk_fn_ret_ty(self, &declaration.output);\n \n-            // Resolve the function body.\n-            this.resolve_block(&*block);\n+        // Resolve the function body.\n+        self.visit_block(&*block);\n \n-            debug!(\"(resolving function) leaving function\");\n-        });\n+        debug!(\"(resolving function) leaving function\");\n \n         self.label_ribs.pop();\n         self.value_ribs.pop();\n     }\n \n-    fn resolve_type_parameters(&mut self,\n-                               type_parameters: &OwnedSlice<TyParam>) {\n-        for type_parameter in &**type_parameters {\n-            self.resolve_type_parameter(type_parameter);\n-        }\n-    }\n-\n-    fn resolve_type_parameter(&mut self,\n-                              type_parameter: &TyParam) {\n-        self.check_if_primitive_type_name(type_parameter.ident.name, type_parameter.span);\n-        for bound in &*type_parameter.bounds {\n-            self.resolve_type_parameter_bound(bound, TraitBoundingTypeParameter);\n-        }\n-        match type_parameter.default {\n-            Some(ref ty) => self.resolve_type(&**ty),\n-            None => {}\n-        }\n-    }\n-\n-    fn resolve_type_parameter_bounds(&mut self,\n-                                     type_parameter_bounds: &OwnedSlice<TyParamBound>,\n-                                     reference_type: TraitReferenceType) {\n-        for type_parameter_bound in &**type_parameter_bounds {\n-            self.resolve_type_parameter_bound(type_parameter_bound, reference_type);\n-        }\n-    }\n-\n-    fn resolve_type_parameter_bound(&mut self,\n-                                    type_parameter_bound: &TyParamBound,\n-                                    reference_type: TraitReferenceType) {\n-        match *type_parameter_bound {\n-            TraitTyParamBound(ref tref, _) => {\n-                self.resolve_trait_reference(tref.trait_ref.ref_id,\n-                                             &tref.trait_ref.path, 0,\n-                                             reference_type)\n-            }\n-            RegionTyParamBound(..) => {}\n-        }\n-    }\n-\n     fn resolve_trait_reference(&mut self,\n                                id: NodeId,\n                                trait_path: &Path,\n-                               path_depth: usize,\n-                               reference_type: TraitReferenceType) {\n+                               path_depth: usize)\n+                               -> Result<(Def, LastPrivate), ()> {\n         match self.resolve_path(id, trait_path, path_depth, TypeNS, true) {\n-            None => {\n-                let path_str = self.path_names_to_string(trait_path, path_depth);\n-                let usage_str = match reference_type {\n-                    TraitBoundingTypeParameter => \"bound type parameter with\",\n-                    TraitImplementation        => \"implement\",\n-                    TraitDerivation            => \"derive\",\n-                    TraitObject                => \"reference\",\n-                    TraitQPath                 => \"extract an associated item from\",\n-                };\n-\n-                let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_path.span, &msg[..]);\n-            }\n-            Some(def) => {\n-                match def {\n-                    (DefTrait(_), _) => {\n-                        debug!(\"(resolving trait) found trait def: {:?}\", def);\n-                        self.record_def(id, def);\n-                    }\n-                    (def, _) => {\n-                        self.resolve_error(trait_path.span,\n-                            &format!(\"`{}` is not a trait\",\n-                                     self.path_names_to_string(trait_path, path_depth)));\n-\n-                        // If it's a typedef, give a note\n-                        if let DefTy(..) = def {\n-                            self.session.span_note(trait_path.span,\n-                                &format!(\"`type` aliases cannot be used for traits\"));\n-                        }\n-                    }\n+            Some(def @ (DefTrait(_), _)) => {\n+                debug!(\"(resolving trait) found trait def: {:?}\", def);\n+                Ok(def)\n+            }\n+            Some((def, _)) => {\n+                self.resolve_error(trait_path.span,\n+                    &format!(\"`{}` is not a trait\",\n+                             self.path_names_to_string(trait_path, path_depth)));\n+\n+                // If it's a typedef, give a note\n+                if let DefTy(..) = def {\n+                    self.session.span_note(trait_path.span,\n+                                           \"`type` aliases cannot be used for traits\");\n                 }\n+                Err(())\n+            }\n+            None => {\n+                let msg = format!(\"use of undeclared trait name `{}`\",\n+                                  self.path_names_to_string(trait_path, path_depth));\n+                self.resolve_error(trait_path.span, &msg[]);\n+                Err(())\n             }\n         }\n     }\n \n-    fn resolve_where_clause(&mut self, where_clause: &ast::WhereClause) {\n-        for predicate in &where_clause.predicates {\n+    fn resolve_generics(&mut self, generics: &Generics) {\n+        for type_parameter in &generics.ty_params {\n+            self.check_if_primitive_type_name(type_parameter.ident.name, type_parameter.span);\n+        }\n+        for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                    self.resolve_type(&*bound_pred.bounded_ty);\n-\n-                    for bound in &*bound_pred.bounds {\n-                        self.resolve_type_parameter_bound(bound, TraitBoundingTypeParameter);\n-                    }\n-                }\n+                &ast::WherePredicate::BoundPredicate(_) |\n                 &ast::WherePredicate::RegionPredicate(_) => {}\n                 &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                     match self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS, true) {\n@@ -3231,53 +3033,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                \"undeclared associated type\");\n                         }\n                     }\n-\n-                    self.resolve_type(&*eq_pred.ty);\n                 }\n             }\n         }\n-    }\n-\n-    fn resolve_struct(&mut self,\n-                      id: NodeId,\n-                      generics: &Generics,\n-                      fields: &[StructField]) {\n-        // If applicable, create a rib for the type parameters.\n-        self.with_type_parameter_rib(HasTypeParameters(generics,\n-                                                       TypeSpace,\n-                                                       id,\n-                                                       ItemRibKind),\n-                                     |this| {\n-            // Resolve the type parameters.\n-            this.resolve_type_parameters(&generics.ty_params);\n-            this.resolve_where_clause(&generics.where_clause);\n-\n-            // Resolve fields.\n-            for field in fields {\n-                this.resolve_type(&*field.node.ty);\n-            }\n-        });\n-    }\n-\n-    // Does this really need to take a RibKind or is it always going\n-    // to be NormalRibKind?\n-    fn resolve_method(&mut self,\n-                      rib_kind: RibKind,\n-                      method: &ast::Method) {\n-        let method_generics = method.pe_generics();\n-        let type_parameters = HasTypeParameters(method_generics,\n-                                                FnSpace,\n-                                                method.id,\n-                                                rib_kind);\n-\n-        if let SelfExplicit(ref typ, _) = method.pe_explicit_self().node {\n-            self.resolve_type(&**typ);\n-        }\n-\n-        self.resolve_function(rib_kind,\n-                              Some(method.pe_fn_decl()),\n-                              type_parameters,\n-                              method.pe_body());\n+        visit::walk_generics(self, generics);\n     }\n \n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T where\n@@ -3295,48 +3054,40 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      f: F) -> T where\n         F: FnOnce(&mut Resolver) -> T,\n     {\n-        let new_val = match *opt_trait_ref {\n-            Some(ref trait_ref) => {\n-                self.resolve_trait_reference(trait_ref.ref_id,\n-                                             &trait_ref.path, 0,\n-                                             TraitImplementation);\n-\n-                match self.def_map.borrow().get(&trait_ref.ref_id) {\n-                    Some(def) => {\n-                        let did = def.def_id();\n-                        Some((did, trait_ref.clone()))\n-                    }\n-                    None => None\n+        let mut new_val = None;\n+        if let Some(ref trait_ref) = *opt_trait_ref {\n+            match self.resolve_trait_reference(trait_ref.ref_id, &trait_ref.path, 0) {\n+                Ok(def) => {\n+                    self.record_def(trait_ref.ref_id, def);\n+                    new_val = Some((def.0.def_id(), trait_ref.clone()));\n                 }\n+                Err(_) => { /* error was already reported */ }\n             }\n-            None => None\n-        };\n+            visit::walk_trait_ref(self, trait_ref);\n+        }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n         let result = f(self);\n         self.current_trait_ref = original_trait_ref;\n         result\n     }\n \n     fn resolve_implementation(&mut self,\n-                              id: NodeId,\n                               generics: &Generics,\n                               opt_trait_reference: &Option<TraitRef>,\n                               self_type: &Ty,\n                               impl_items: &[ImplItem]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                        TypeSpace,\n-                                                       id,\n-                                                       NormalRibKind),\n+                                                       ItemRibKind),\n                                      |this| {\n             // Resolve the type parameters.\n-            this.resolve_type_parameters(&generics.ty_params);\n-            this.resolve_where_clause(&generics.where_clause);\n+            this.visit_generics(generics);\n \n             // Resolve the trait reference, if necessary.\n             this.with_optional_trait_ref(opt_trait_reference, |this| {\n                 // Resolve the self type.\n-                this.resolve_type(self_type);\n+                this.visit_ty(self_type);\n \n                 this.with_current_self_type(self_type, |this| {\n                     for impl_item in impl_items {\n@@ -3349,17 +3100,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                                 // We also need a new scope for the method-\n                                 // specific type parameters.\n-                                this.resolve_method(\n-                                    MethodRibKind(id, ProvidedMethod(method.id)),\n-                                    &**method);\n+                                let type_parameters =\n+                                    HasTypeParameters(method.pe_generics(),\n+                                                      FnSpace,\n+                                                      MethodRibKind);\n+                                this.with_type_parameter_rib(type_parameters, |this| {\n+                                    visit::walk_method_helper(this, &**method);\n+                                });\n                             }\n                             TypeImplItem(ref typedef) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n                                 this.check_trait_item(typedef.ident.name,\n                                                       typedef.span);\n \n-                                this.resolve_type(&*typedef.typ);\n+                                this.visit_ty(&*typedef.typ);\n                             }\n                         }\n                     }\n@@ -3405,34 +3160,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn resolve_module(&mut self, module: &Mod, _span: Span,\n-                      _name: Name, id: NodeId) {\n-        // Write the implementations in scope into the module metadata.\n-        debug!(\"(resolving module) resolving module ID {}\", id);\n-        visit::walk_mod(self, module);\n-    }\n-\n     fn resolve_local(&mut self, local: &Local) {\n         // Resolve the type.\n-        if let Some(ref ty) = local.ty {\n-            self.resolve_type(&**ty);\n-        }\n+        visit::walk_ty_opt(self, &local.ty);\n \n-        // Resolve the initializer, if necessary.\n-        match local.init {\n-            None => {\n-                // Nothing to do.\n-            }\n-            Some(ref initializer) => {\n-                self.resolve_expr(&**initializer);\n-            }\n-        }\n+        // Resolve the initializer.\n+        visit::walk_expr_opt(self, &local.init);\n \n         // Resolve the pattern.\n-        let mut bindings_list = HashMap::new();\n         self.resolve_pattern(&*local.pat,\n                              LocalIrrefutableMode,\n-                             &mut bindings_list);\n+                             &mut HashMap::new());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n@@ -3510,7 +3248,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.check_consistent_bindings(arm);\n \n         visit::walk_expr_opt(self, &arm.guard);\n-        self.resolve_expr(&*arm.body);\n+        self.visit_expr(&*arm.body);\n \n         self.value_ribs.pop();\n     }\n@@ -3566,49 +3304,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // on whether the path has multiple elements in it or not.\n \n             TyPath(ref path) | TyQPath(ast::QPath { ref path, .. }) => {\n-                if let TyQPath(ref qpath) = ty.node {\n-                    self.resolve_type(&*qpath.self_type);\n-\n-                    // Just make sure the trait is valid, don't record a def.\n-                    self.resolve_trait_reference(ty.id, path, 1, TraitQPath);\n-                    self.def_map.borrow_mut().remove(&ty.id);\n+                if let TyQPath(_) = ty.node {\n+                    // Make sure the trait is valid.\n+                    self.resolve_trait_reference(ty.id, path, 1);\n                 }\n \n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n-                let mut result_def = None;\n-\n-                // First, check to see whether the name is a primitive type.\n-                if path.segments.len() == 1 {\n-                    let id = path.segments.last().unwrap().identifier;\n-\n-                    match self.primitive_type_table\n-                            .primitive_types\n-                            .get(&id.name) {\n-\n-                        Some(&primitive_type) => {\n-                            result_def =\n-                                Some((DefPrimTy(primitive_type), LastMod(AllPublic)));\n-\n-                            if path.segments[0].parameters.has_lifetimes() {\n-                                span_err!(self.session, path.span, E0157,\n-                                    \"lifetime parameters are not allowed on this type\");\n-                            } else if !path.segments[0].parameters.is_empty() {\n-                                span_err!(self.session, path.span, E0153,\n-                                    \"type parameters are not allowed on this type\");\n-                            }\n-                        }\n-                        None => {\n-                            // Continue.\n-                        }\n-                    }\n-                }\n-\n-                if let None = result_def {\n-                    result_def = self.resolve_path(ty.id, path, 0, TypeNS, true);\n-                }\n-\n-                match result_def {\n+                match self.resolve_path(ty.id, path, 0, TypeNS, true) {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `{}` \\\n@@ -3628,21 +3331,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             }\n-\n-            TyObjectSum(ref ty, ref bound_vec) => {\n-                self.resolve_type(&**ty);\n-                self.resolve_type_parameter_bounds(bound_vec, TraitBoundingTypeParameter);\n-            }\n-\n-            TyPolyTraitRef(ref bounds) => {\n-                self.resolve_type_parameter_bounds(bounds, TraitObject);\n-                visit::walk_ty(self, ty);\n-            }\n-            _ => {\n-                // Just resolve embedded types.\n-                visit::walk_ty(self, ty);\n-            }\n+            _ => {}\n         }\n+        // Resolve embedded types.\n+        visit::walk_ty(self, ty);\n     }\n \n     fn resolve_pattern(&mut self,\n@@ -3669,7 +3361,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let renamed = mtwt::resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident.name, pattern.span) {\n-                        FoundStructOrEnumVariant(ref def, lp)\n+                        FoundStructOrEnumVariant(def, lp)\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n@@ -3679,7 +3371,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 pattern,\n                                 binding_mode,\n                                 \"an enum variant\");\n-                            self.record_def(pattern.id, (def.clone(), lp));\n+                            self.record_def(pattern.id, (def, lp));\n                         }\n                         FoundStructOrEnumVariant(..) => {\n                             self.resolve_error(\n@@ -3689,7 +3381,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                          scope\",\n                                         token::get_name(renamed)));\n                         }\n-                        FoundConst(ref def, lp) if mode == RefutableMode => {\n+                        FoundConst(def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n                                    token::get_name(renamed));\n@@ -3698,7 +3390,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 pattern,\n                                 binding_mode,\n                                 \"a constant\");\n-                            self.record_def(pattern.id, (def.clone(), lp));\n+                            self.record_def(pattern.id, (def, lp));\n                         }\n                         FoundConst(..) => {\n                             self.resolve_error(pattern.span,\n@@ -3782,22 +3474,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     token::get_ident(path.segments.last().unwrap().identifier)));\n                         }\n                     }\n-\n-                    // Check the types in the path pattern.\n-                    for ty in path.segments\n-                                  .iter()\n-                                  .flat_map(|s| s.parameters.types().into_iter()) {\n-                        self.resolve_type(&**ty);\n-                    }\n-                }\n-\n-                PatLit(ref expr) => {\n-                    self.resolve_expr(&**expr);\n-                }\n-\n-                PatRange(ref first_expr, ref last_expr) => {\n-                    self.resolve_expr(&**first_expr);\n-                    self.resolve_expr(&**last_expr);\n+                    visit::walk_path(self, path);\n                 }\n \n                 PatStruct(ref path, _, _) => {\n@@ -3813,6 +3490,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.resolve_error(path.span, &msg[..]);\n                         }\n                     }\n+                    visit::walk_path(self, path);\n+                }\n+\n+                PatLit(_) | PatRange(..) => {\n+                    visit::walk_pat(self, pattern);\n                 }\n \n                 _ => {\n@@ -3895,14 +3577,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len()-path_depth];\n \n-        // First, resolve the types and associated type bindings.\n-        for ty in segments.iter().flat_map(|s| s.parameters.types().into_iter()) {\n-            self.resolve_type(&**ty);\n-        }\n-        for binding in segments.iter().flat_map(|s| s.parameters.bindings().into_iter()) {\n-            self.resolve_type(&*binding.ty);\n-        }\n-\n         // A special case for sugared associated type paths `T::A` where `T` is\n         // a type parameter and `A` is an associated type on some bound of `T`.\n         if namespace == TypeNS && segments.len() == 2 {\n@@ -3957,7 +3631,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return def;\n         }\n \n-        return unqualified_def;\n+        unqualified_def\n     }\n \n     // resolve a single identifier (used as a varref)\n@@ -3967,20 +3641,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                           check_ribs: bool,\n                           span: Span)\n                           -> Option<(Def, LastPrivate)> {\n+        // First, check to see whether the name is a primitive type.\n+        if namespace == TypeNS {\n+            if let Some(&prim_ty) = self.primitive_type_table\n+                                        .primitive_types\n+                                        .get(&identifier.name) {\n+                return Some((DefPrimTy(prim_ty), LastMod(AllPublic)));\n+            }\n+        }\n+\n         if check_ribs {\n-            match self.resolve_identifier_in_local_ribs(identifier,\n-                                                        namespace,\n-                                                        span) {\n-                Some(def) => {\n-                    return Some((def, LastMod(AllPublic)));\n-                }\n-                None => {\n-                    // Continue.\n-                }\n+            if let Some(def) = self.resolve_identifier_in_local_ribs(identifier,\n+                                                                     namespace,\n+                                                                     span) {\n+                return Some((def, LastMod(AllPublic)));\n             }\n         }\n \n-        return self.resolve_item_by_name_in_lexical_scope(identifier.name, namespace);\n+        self.resolve_item_by_name_in_lexical_scope(identifier.name, namespace)\n     }\n \n     // FIXME #4952: Merge me with resolve_name_in_module?\n@@ -4197,10 +3875,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         local: {:?}\",\n                        token::get_ident(ident),\n                        def);\n-                return Some(def);\n+                Some(def)\n             }\n             Some(DlField) | Some(DlImpl(_)) | None => {\n-                return None;\n+                None\n             }\n         }\n     }\n@@ -4425,12 +4103,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // multiple elements in it or not.\n \n             ExprPath(ref path) | ExprQPath(ast::QPath { ref path, .. }) => {\n-                if let ExprQPath(ref qpath) = expr.node {\n-                    self.resolve_type(&*qpath.self_type);\n-\n-                    // Just make sure the trait is valid, don't record a def.\n-                    self.resolve_trait_reference(expr.id, path, 1, TraitQPath);\n-                    self.def_map.borrow_mut().remove(&expr.id);\n+                if let ExprQPath(_) = expr.node {\n+                    // Make sure the trait is valid.\n+                    self.resolve_trait_reference(expr.id, path, 1);\n                 }\n \n                 // This is a local path in the value namespace. Walk through\n@@ -4482,13 +4157,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             _ => {\n                                 let mut method_scope = false;\n                                 self.value_ribs.iter().rev().all(|rib| {\n-                                    let res = match *rib {\n-                                        Rib { bindings: _, kind: MethodRibKind(_, _) } => true,\n-                                        Rib { bindings: _, kind: ItemRibKind } => false,\n+                                    method_scope = match rib.kind {\n+                                        MethodRibKind => true,\n+                                        ItemRibKind | ConstantItemRibKind => false,\n                                         _ => return true, // Keep advancing\n                                     };\n-\n-                                    method_scope = res;\n                                     false // Stop advancing\n                                 });\n \n@@ -4537,21 +4210,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprClosure(_, ref fn_decl, ref block) => {\n-                self.resolve_function(ClosureRibKind(expr.id),\n-                                      Some(&**fn_decl), NoTypeParameters,\n-                                      &**block);\n-            }\n-\n             ExprStruct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to. We don't\n                 // check to ensure that the path is actually a structure; that\n                 // is checked later during typeck.\n                 match self.resolve_path(expr.id, path, 0, TypeNS, false) {\n                     Some(definition) => self.record_def(expr.id, definition),\n-                    result => {\n-                        debug!(\"(resolving expression) didn't find struct \\\n-                                def: {:?}\", result);\n+                    None => {\n+                        debug!(\"(resolving expression) didn't find struct def\",);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path, 0));\n                         self.resolve_error(path.span, &msg[..]);\n@@ -4704,26 +4370,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         found_traits\n     }\n \n-    fn record_def(&mut self, node_id: NodeId, (def, lp): (Def, LastPrivate)) {\n+    fn record_def(&mut self,\n+                  node_id: NodeId,\n+                  (def, lp): (Def, LastPrivate)) {\n         debug!(\"(recording def) recording {:?} for {}, last private {:?}\",\n                 def, node_id, lp);\n         assert!(match lp {LastImport{..} => false, _ => true},\n                 \"Import should only be used for `use` directives\");\n         self.last_private.insert(node_id, lp);\n \n-        match self.def_map.borrow_mut().entry(node_id) {\n-            // Resolve appears to \"resolve\" the same ID multiple\n-            // times, so here is a sanity check it at least comes to\n-            // the same conclusion! - nmatsakis\n-            Occupied(entry) => if def != *entry.get() {\n-                self.session\n-                    .bug(&format!(\"node_id {} resolved first to {:?} and \\\n-                                  then {:?}\",\n-                                 node_id,\n-                                 *entry.get(),\n-                                 def));\n-            },\n-            Vacant(entry) => { entry.insert(def); },\n+        if let Some(prev_def) = self.def_map.borrow_mut().insert(node_id, def) {\n+            let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n+            self.session.span_bug(span, &format!(\"path resolved multiple times \\\n+                                                  ({:?} before, {:?} now)\",\n+                                                  prev_def, def));\n         }\n     }\n "}, {"sha": "531700b9563be0905259048c905f0ed418315ba6", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -250,7 +250,6 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n             def::DefSelfTy(_) |\n             def::DefRegion(_) |\n-            def::DefTyParamBinder(_) |\n             def::DefLabel(_) |\n             def::DefStaticMethod(..) |\n             def::DefTyParam(..) |"}, {"sha": "9dbcbc8b1a28ee79145948690a14822b27b82536", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -209,9 +209,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             }\n             def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n             def::DefTy(..) | def::DefPrimTy(..) | def::DefAssociatedTy(..) |\n-            def::DefUse(..) | def::DefTyParamBinder(..) |\n-            def::DefRegion(..) | def::DefLabel(..) | def::DefTyParam(..) |\n-            def::DefSelfTy(..) | def::DefAssociatedPath(..) => {\n+            def::DefUse(..) | def::DefRegion(..) | def::DefLabel(..) |\n+            def::DefTyParam(..) | def::DefSelfTy(..) | def::DefAssociatedPath(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     &format!(\"cannot translate def {:?} \\"}, {"sha": "9d303f492eb3484301a92c50fc41a4f91acbe058", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -4729,7 +4729,6 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefSelfTy(..) |\n         def::DefStruct(..) |\n         def::DefVariant(..) |\n-        def::DefTyParamBinder(..) |\n         def::DefTy(..) |\n         def::DefAssociatedTy(..) |\n         def::DefAssociatedPath(..) |"}, {"sha": "7a27159bc47a25c294a8f5ddef35be454ea2f67f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -1344,8 +1344,6 @@ pub enum Type {\n         typarams: Option<Vec<TyParamBound>>,\n         did: ast::DefId,\n     },\n-    // I have no idea how to usefully use this.\n-    TyParamBinder(ast::NodeId),\n     /// For parameterized types, so the consumer of the JSON don't go\n     /// looking for types which don't exist anywhere.\n     Generic(String),\n@@ -2416,7 +2414,6 @@ fn resolve_type(cx: &DocContext,\n             ast::TyFloat(ast::TyF64) => return Primitive(F64),\n         },\n         def::DefTyParam(_, _, _, n) => return Generic(token::get_name(n).to_string()),\n-        def::DefTyParamBinder(i) => return TyParamBinder(i),\n         _ => {}\n     };\n     let did = register_def(&*cx, def);"}, {"sha": "03a2d708ee43aa5b742c2efc9c19aacdf4764ecf", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -454,9 +454,6 @@ fn tybounds(w: &mut fmt::Formatter,\n impl fmt::Display for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            clean::TyParamBinder(id) => {\n-                f.write_str(&cache().typarams[ast_util::local_def(id)])\n-            }\n             clean::Generic(ref name) => {\n                 f.write_str(name)\n             }"}, {"sha": "80ef882745f878e152f3d24b29276bf6624db513", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -70,7 +70,7 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec!(borrowed_self()),\n-                ret_ty: Literal(path!(bool)),\n+                ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 combine_substructure: combine_substructure(box |a, b, c| {\n                     $f(a, b, c)"}, {"sha": "be4a33002aa1c69e87f2227fa0e6490e6571c120", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -36,7 +36,7 @@ pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec!(borrowed_self()),\n-                ret_ty: Literal(path!(bool)),\n+                ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 combine_substructure: combine_substructure(box |cx, span, substr| {\n                     cs_op($op, $equal, cx, span, substr)"}, {"sha": "973c8f5fa1e0b4b26a39defe621cbe74107aab0f", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -30,6 +30,12 @@ macro_rules! path {\n     )\n }\n \n+macro_rules! path_local {\n+    ($x:ident) => (\n+        ::ext::deriving::generic::ty::Path::new_local(stringify!($x))\n+    )\n+}\n+\n macro_rules! pathvec_std {\n     ($cx:expr, $first:ident :: $($rest:ident)::+) => (\n         if $cx.use_std {"}, {"sha": "3b96292323a95039ab6f17535c704ce75023138b", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -38,7 +38,7 @@ pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n                 name: \"from_i64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: vec!(Literal(path!(i64))),\n+                args: vec!(Literal(path_local!(i64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n                                            vec!(box Self_),\n@@ -53,7 +53,7 @@ pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n                 name: \"from_u64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: vec!(Literal(path!(u64))),\n+                args: vec!(Literal(path_local!(u64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n                                            vec!(box Self_),"}, {"sha": "21334e1d51375420c373ed906fdd09e59f1c6bc0", "filename": "src/test/compile-fail/extern-with-type-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -24,7 +24,7 @@ extern \"rust-intrinsic\" {\n \n     // Unresolved bounds should still error.\n     fn align_of<T: NoSuchTrait>() -> usize;\n-    //~^ ERROR attempt to bound type parameter with a nonexistent trait `NoSuchTrait`\n+    //~^ ERROR use of undeclared trait name `NoSuchTrait`\n }\n \n fn main() {}"}, {"sha": "181503db818462907d8854a0cbb9e6b4cd4752dd", "filename": "src/test/compile-fail/glob-resolve1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -36,9 +36,6 @@ fn main() {\n     import(); //~ ERROR: unresolved\n \n     foo::<A>(); //~ ERROR: undeclared\n-    //~^ ERROR: undeclared\n     foo::<C>(); //~ ERROR: undeclared\n-    //~^ ERROR: undeclared\n     foo::<D>(); //~ ERROR: undeclared\n-    //~^ ERROR: undeclared\n }"}, {"sha": "cf2a70deee513cf3945a6389557febc52367ec1f", "filename": "src/test/compile-fail/inner-static-type-parameter.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -14,7 +14,8 @@ enum Bar<T> { What }\n \n fn foo<T>() {\n     static a: Bar<T> = Bar::What;\n-    //~^ ERROR: cannot use an outer type parameter in this context\n+    //~^ ERROR cannot use an outer type parameter in this context\n+    //~| ERROR use of undeclared type name `T`\n }\n \n fn main() {"}, {"sha": "ad5bc4e445c9839b7ebc41064ef684f460087340", "filename": "src/test/compile-fail/issue-3521-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -11,7 +11,9 @@\n fn main() {\n     let foo = 100;\n \n-    static y: isize = foo + 1; //~ ERROR: attempt to use a non-constant value in a constant\n+    static y: isize = foo + 1;\n+    //~^ ERROR attempt to use a non-constant value in a constant\n+    //~| ERROR unresolved name `foo`\n \n     println!(\"{}\", y);\n }"}, {"sha": "f06aa45ac38fd1848c106847d37e1e5421e717af", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -13,7 +13,9 @@ fn main() {\n \n     #[derive(Debug)]\n     enum Stuff {\n-        Bar = foo //~ ERROR attempt to use a non-constant value in a constant\n+        Bar = foo\n+        //~^ ERROR attempt to use a non-constant value in a constant\n+        //~| ERROR unresolved name `foo`\n     }\n \n     println!(\"{}\", Stuff::Bar);"}, {"sha": "a09c8090de06de5716e718d3d33e6291f7edfaf9", "filename": "src/test/compile-fail/issue-3668-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n fn f(x:isize) {\n-    static child: isize = x + 1; //~ ERROR attempt to use a non-constant value in a constant\n+    static child: isize = x + 1;\n+    //~^ ERROR attempt to use a non-constant value in a constant\n+    //~| ERROR unresolved name `x`\n }\n \n fn main() {}"}, {"sha": "9b7476244f0d26a19e0d91639fea3c306c20406f", "filename": "src/test/compile-fail/issue-3668.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -17,6 +17,7 @@ impl PTrait for P {\n    fn getChildOption(&self) -> Option<Box<P>> {\n        static childVal: Box<P> = self.child.get();\n        //~^ ERROR attempt to use a non-constant value in a constant\n+       //~| ERROR unresolved name `self`\n        panic!();\n    }\n }"}, {"sha": "526750257d2785c81f52b11599084aebf589cd16", "filename": "src/test/compile-fail/no-implicit-prelude-nested.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -18,23 +18,23 @@\n mod foo {\n     mod baz {\n         struct Test;\n-        impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+        impl Add for Test {} //~ ERROR: use of undeclared trait\n+        impl Clone for Test {} //~ ERROR: use of undeclared trait\n+        impl Iterator for Test {} //~ ERROR: use of undeclared trait\n+        impl ToString for Test {} //~ ERROR: use of undeclared trait\n+        impl Writer for Test {} //~ ERROR: use of undeclared trait\n \n         fn foo() {\n             drop(2) //~ ERROR: unresolved name\n         }\n     }\n \n     struct Test;\n-    impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-    impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-    impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-    impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-    impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+    impl Add for Test {} //~ ERROR: use of undeclared trait\n+    impl Clone for Test {} //~ ERROR: use of undeclared trait\n+    impl Iterator for Test {} //~ ERROR: use of undeclared trait\n+    impl ToString for Test {} //~ ERROR: use of undeclared trait\n+    impl Writer for Test {} //~ ERROR: use of undeclared trait\n \n     fn foo() {\n         drop(2) //~ ERROR: unresolved name\n@@ -45,11 +45,11 @@ fn qux() {\n     #[no_implicit_prelude]\n     mod qux_inner {\n         struct Test;\n-        impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+        impl Add for Test {} //~ ERROR: use of undeclared trait\n+        impl Clone for Test {} //~ ERROR: use of undeclared trait\n+        impl Iterator for Test {} //~ ERROR: use of undeclared trait\n+        impl ToString for Test {} //~ ERROR: use of undeclared trait\n+        impl Writer for Test {} //~ ERROR: use of undeclared trait\n \n         fn foo() {\n             drop(2) //~ ERROR: unresolved name"}, {"sha": "c4bcd33b93bd0beb67f68e1bf121553ec12432c6", "filename": "src/test/compile-fail/no-implicit-prelude.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -17,11 +17,11 @@\n // fail with the same error message).\n \n struct Test;\n-impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+impl Add for Test {} //~ ERROR: use of undeclared trait\n+impl Clone for Test {} //~ ERROR: use of undeclared trait\n+impl Iterator for Test {} //~ ERROR: use of undeclared trait\n+impl ToString for Test {} //~ ERROR: use of undeclared trait\n+impl Writer for Test {} //~ ERROR: use of undeclared trait\n \n fn main() {\n     drop(2) //~ ERROR: unresolved name"}, {"sha": "3983a84f6ad1795a8d0ffac46710870b32d3d3cd", "filename": "src/test/compile-fail/resolve-unknown-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -10,11 +10,11 @@\n \n \n trait NewTrait : SomeNonExistentTrait {}\n-//~^ ERROR attempt to derive a nonexistent trait `SomeNonExistentTrait`\n+//~^ ERROR use of undeclared trait name `SomeNonExistentTrait`\n \n impl SomeNonExistentTrait for isize {}\n-//~^ ERROR attempt to implement a nonexistent trait `SomeNonExistentTrait`\n+//~^ ERROR use of undeclared trait name `SomeNonExistentTrait`\n \n fn f<T:SomeNonExistentTrait>() {}\n-//~^ ERROR attempt to bound type parameter with a nonexistent trait `SomeNonExistentTrait`\n+//~^ ERROR use of undeclared trait name `SomeNonExistentTrait`\n "}, {"sha": "f28bf7acadd371240b0c3b3c1b77fa885ed95554", "filename": "src/test/compile-fail/unboxed-closure-sugar-nonexistent-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5809f8ae746dbde96e0924b8e422b9e0d092375b/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs?ref=5809f8ae746dbde96e0924b8e422b9e0d092375b", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unboxed_closures)]\n \n-fn f<F:Nonexist(isize) -> isize>(x: F) {} //~ ERROR nonexistent trait `Nonexist`\n+fn f<F:Nonexist(isize) -> isize>(x: F) {} //~ ERROR undeclared trait name `Nonexist`\n \n type Typedef = isize;\n "}]}