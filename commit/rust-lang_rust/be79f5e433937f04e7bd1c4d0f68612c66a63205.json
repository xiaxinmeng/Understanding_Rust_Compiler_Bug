{"sha": "be79f5e433937f04e7bd1c4d0f68612c66a63205", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNzlmNWU0MzM5MzdmMDRlN2JkMWM0ZDBmNjg2MTJjNjZhNjMyMDU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-02-19T05:42:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-19T05:42:47Z"}, "message": "Merge pull request #2468 from topecongiro/perf\n\nApply optimization suggested by perf", "tree": {"sha": "a66ddef73151cc3855a19b1c424af22888dd1dcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a66ddef73151cc3855a19b1c424af22888dd1dcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be79f5e433937f04e7bd1c4d0f68612c66a63205", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaimPXCRBK7hj4Ov3rIwAAdHIIADsG8tI6Gpu1iVoa54mIGk4N\nYz2485dnqfpIjpFzRQ186T9Wqnp6ZUAbtPerHMvc90CdqLrt0LiXuGEmBFJ/b6OJ\nm7o+ondBv/NA3T/iwbJMc0o1f9z3V56DQi8vfu+Ep1uDJeEMSUJ4HfldDpYOhPiH\nt/ZDjkDzsY7WXBWRiYXsQdAWdMC/oxefUFOw58lSohmQ6xsuymxXJ31U7wrvzq6K\nh7lbtK3qrH79gA2lTST0GTHYRtUIyjl5ZfLv8uG7mjj5HHjZhV0nqLZCuubdb47L\nKotHXNO89TofpcurDcRzeishC60wAkOb4DjoP98fgu17fgmisW2PjQ3xiN4WKUQ=\n=l7Hf\n-----END PGP SIGNATURE-----\n", "payload": "tree a66ddef73151cc3855a19b1c424af22888dd1dcb\nparent 377bb5c97f87bba2d4324372f2e4ddf82ee2ff53\nparent 36e8eb68933abd3123db303741d25f9323de3eca\nauthor Nick Cameron <nrc@ncameron.org> 1519018967 +1300\ncommitter GitHub <noreply@github.com> 1519018967 +1300\n\nMerge pull request #2468 from topecongiro/perf\n\nApply optimization suggested by perf"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be79f5e433937f04e7bd1c4d0f68612c66a63205", "html_url": "https://github.com/rust-lang/rust/commit/be79f5e433937f04e7bd1c4d0f68612c66a63205", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be79f5e433937f04e7bd1c4d0f68612c66a63205/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "377bb5c97f87bba2d4324372f2e4ddf82ee2ff53", "url": "https://api.github.com/repos/rust-lang/rust/commits/377bb5c97f87bba2d4324372f2e4ddf82ee2ff53", "html_url": "https://github.com/rust-lang/rust/commit/377bb5c97f87bba2d4324372f2e4ddf82ee2ff53"}, {"sha": "36e8eb68933abd3123db303741d25f9323de3eca", "url": "https://api.github.com/repos/rust-lang/rust/commits/36e8eb68933abd3123db303741d25f9323de3eca", "html_url": "https://github.com/rust-lang/rust/commit/36e8eb68933abd3123db303741d25f9323de3eca"}], "stats": {"total": 530, "additions": 288, "deletions": 242}, "files": [{"sha": "714f33c03dc0933c802098bad627ac2ef10adc25", "filename": "rustfmt-config/src/file_lines.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-config%2Fsrc%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-config%2Fsrc%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Ffile_lines.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -132,6 +132,11 @@ impl FileLines {\n         FileLines(None)\n     }\n \n+    /// Returns true if this `FileLines` contains all lines in all files.\n+    pub fn is_all(&self) -> bool {\n+        self.0.is_none()\n+    }\n+\n     pub fn from_ranges(mut ranges: HashMap<FileName, Vec<Range>>) -> FileLines {\n         normalize_ranges(&mut ranges);\n         FileLines(Some(ranges))"}, {"sha": "87100c7be419339b69b219bdfed7c193dddf628b", "filename": "rustfmt-core/src/chains.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fchains.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -67,8 +67,10 @@ use shape::Shape;\n use utils::{first_line_width, last_line_extendable, last_line_width, mk_sp,\n             trimmed_last_line_width, wrap_str};\n \n+use std::borrow::Cow;\n use std::cmp::min;\n use std::iter;\n+\n use syntax::{ast, ptr};\n use syntax::codemap::Span;\n \n@@ -246,13 +248,13 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n \n     let connector = if fits_single_line && !parent_rewrite_contains_newline {\n         // Yay, we can put everything on one line.\n-        String::new()\n+        Cow::from(\"\")\n     } else {\n         // Use new lines.\n         if context.force_one_line_chain {\n             return None;\n         }\n-        format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n+        nested_shape.indent.to_string_with_newline(context.config)\n     };\n \n     let first_connector = if is_small_parent || fits_single_line\n@@ -261,7 +263,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     {\n         \"\"\n     } else {\n-        connector.as_str()\n+        &connector\n     };\n \n     let result = if is_small_parent && rewrites.len() > 1 {"}, {"sha": "6097f6339edb93ce2d6e8aa6d1007d8ec6de56e3", "filename": "rustfmt-core/src/closures.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fclosures.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -225,14 +225,14 @@ fn rewrite_closure_fn_decl(\n     let ret_str = fn_decl.output.rewrite(context, arg_shape)?;\n \n     let arg_items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         fn_decl.inputs.iter(),\n         \"|\",\n         \",\",\n         |arg| span_lo_for_arg(arg),\n         |arg| span_hi_for_arg(context, arg),\n         |arg| arg.rewrite(context, arg_shape),\n-        context.codemap.span_after(span, \"|\"),\n+        context.snippet_provider.span_after(span, \"|\"),\n         body.span.lo(),\n         false,\n     );"}, {"sha": "224b20835618cbf54fd3c39f2b8c169fcb608823", "filename": "rustfmt-core/src/codemap.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fcodemap.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -12,6 +12,7 @@\n //! This includes extension traits and methods for looking up spans and line ranges for AST nodes.\n \n use config::file_lines::LineRange;\n+use visitor::SnippetProvider;\n use syntax::codemap::{BytePos, CodeMap, Span};\n \n use comment::FindUncommented;\n@@ -32,7 +33,7 @@ pub trait LineRangeUtils {\n     fn lookup_line_range(&self, span: Span) -> LineRange;\n }\n \n-impl SpanUtils for CodeMap {\n+impl<'a> SpanUtils for SnippetProvider<'a> {\n     fn span_after(&self, original: Span, needle: &str) -> BytePos {\n         let snippet = self.span_to_snippet(original).expect(\"Bad snippet\");\n         let offset = snippet.find_uncommented(needle).expect(\"Bad offset\") + needle.len();\n@@ -59,7 +60,7 @@ impl SpanUtils for CodeMap {\n     }\n \n     fn opt_span_after(&self, original: Span, needle: &str) -> Option<BytePos> {\n-        let snippet = self.span_to_snippet(original).ok()?;\n+        let snippet = self.span_to_snippet(original)?;\n         let offset = snippet.find_uncommented(needle)? + needle.len();\n \n         Some(original.lo() + BytePos(offset as u32))\n@@ -68,19 +69,20 @@ impl SpanUtils for CodeMap {\n \n impl LineRangeUtils for CodeMap {\n     fn lookup_line_range(&self, span: Span) -> LineRange {\n-        let lo = self.lookup_char_pos(span.lo());\n-        let hi = self.lookup_char_pos(span.hi());\n+        let lo = self.lookup_line(span.lo()).unwrap();\n+        let hi = self.lookup_line(span.hi()).unwrap();\n \n-        assert_eq!(\n-            lo.file.name, hi.file.name,\n+        debug_assert_eq!(\n+            lo.fm.name, hi.fm.name,\n             \"span crossed file boundary: lo: {:?}, hi: {:?}\",\n             lo, hi\n         );\n \n+        // Line numbers start at 1\n         LineRange {\n-            file: lo.file.clone(),\n-            lo: lo.line,\n-            hi: hi.line,\n+            file: lo.fm.clone(),\n+            lo: lo.line + 1,\n+            hi: hi.line + 1,\n         }\n     }\n }"}, {"sha": "8b148ccfc376ace2876d66af7e14bc4b0555c225", "filename": "rustfmt-core/src/comment.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fcomment.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -10,7 +10,7 @@\n \n // Formatting and tools for comments.\n \n-use std::{self, iter};\n+use std::{self, iter, borrow::Cow};\n \n use syntax::codemap::Span;\n \n@@ -154,6 +154,9 @@ pub fn combine_strs_with_missing_comments(\n     shape: Shape,\n     allow_extend: bool,\n ) -> Option<String> {\n+    let mut result =\n+        String::with_capacity(prev_str.len() + next_str.len() + shape.indent.width() + 128);\n+    result.push_str(prev_str);\n     let mut allow_one_line = !prev_str.contains('\\n') && !next_str.contains('\\n');\n     let first_sep = if prev_str.is_empty() || next_str.is_empty() {\n         \"\"\n@@ -163,20 +166,18 @@ pub fn combine_strs_with_missing_comments(\n     let mut one_line_width =\n         last_line_width(prev_str) + first_line_width(next_str) + first_sep.len();\n \n-    let indent_str = shape.indent.to_string(context.config);\n+    let config = context.config;\n+    let indent = shape.indent;\n     let missing_comment = rewrite_missing_comment(span, shape, context)?;\n \n     if missing_comment.is_empty() {\n         if allow_extend && prev_str.len() + first_sep.len() + next_str.len() <= shape.width {\n-            return Some(format!(\"{}{}{}\", prev_str, first_sep, next_str));\n-        } else {\n-            let sep = if prev_str.is_empty() {\n-                String::new()\n-            } else {\n-                String::from(\"\\n\") + &indent_str\n-            };\n-            return Some(format!(\"{}{}{}\", prev_str, sep, next_str));\n+            result.push_str(first_sep);\n+        } else if !prev_str.is_empty() {\n+            result.push_str(&indent.to_string_with_newline(config))\n         }\n+        result.push_str(next_str);\n+        return Some(result);\n     }\n \n     // We have a missing comment between the first expression and the second expression.\n@@ -193,32 +194,35 @@ pub fn combine_strs_with_missing_comments(\n \n     one_line_width -= first_sep.len();\n     let first_sep = if prev_str.is_empty() || missing_comment.is_empty() {\n-        String::new()\n+        Cow::from(\"\")\n     } else {\n         let one_line_width = last_line_width(prev_str) + first_line_width(&missing_comment) + 1;\n         if prefer_same_line && one_line_width <= shape.width {\n-            String::from(\" \")\n+            Cow::from(\" \")\n         } else {\n-            format!(\"\\n{}\", indent_str)\n+            indent.to_string_with_newline(config)\n         }\n     };\n+    result.push_str(&first_sep);\n+    result.push_str(&missing_comment);\n+\n     let second_sep = if missing_comment.is_empty() || next_str.is_empty() {\n-        String::new()\n+        Cow::from(\"\")\n     } else if missing_comment.starts_with(\"//\") {\n-        format!(\"\\n{}\", indent_str)\n+        indent.to_string_with_newline(config)\n     } else {\n         one_line_width += missing_comment.len() + first_sep.len() + 1;\n         allow_one_line &= !missing_comment.starts_with(\"//\") && !missing_comment.contains('\\n');\n         if prefer_same_line && allow_one_line && one_line_width <= shape.width {\n-            String::from(\" \")\n+            Cow::from(\" \")\n         } else {\n-            format!(\"\\n{}\", indent_str)\n+            indent.to_string_with_newline(config)\n         }\n     };\n-    Some(format!(\n-        \"{}{}{}{}{}\",\n-        prev_str, first_sep, missing_comment, second_sep, next_str,\n-    ))\n+    result.push_str(&second_sep);\n+    result.push_str(next_str);\n+\n+    Some(result)\n }\n \n pub fn rewrite_doc_comment(orig: &str, shape: Shape, config: &Config) -> Option<String> {\n@@ -315,7 +319,7 @@ fn rewrite_comment_inner(\n         .width\n         .checked_sub(closer.len() + opener.len())\n         .unwrap_or(1);\n-    let indent_str = shape.indent.to_string(config);\n+    let indent_str = shape.indent.to_string_with_newline(config);\n     let fmt_indent = shape.indent + (opener.len() - line_start.len());\n     let mut fmt = StringFormat {\n         opener: \"\",\n@@ -356,7 +360,7 @@ fn rewrite_comment_inner(\n     let mut code_block_buffer = String::with_capacity(128);\n     let mut is_prev_line_multi_line = false;\n     let mut inside_code_block = false;\n-    let comment_line_separator = format!(\"\\n{}{}\", indent_str, line_start);\n+    let comment_line_separator = format!(\"{}{}\", indent_str, line_start);\n     let join_code_block_with_comment_line_separator = |s: &str| {\n         let mut result = String::with_capacity(s.len() + 128);\n         let mut iter = s.lines().peekable();\n@@ -404,7 +408,6 @@ fn rewrite_comment_inner(\n             } else if is_prev_line_multi_line && !line.is_empty() {\n                 result.push(' ')\n             } else if is_last && !closer.is_empty() && line.is_empty() {\n-                result.push('\\n');\n                 result.push_str(&indent_str);\n             } else {\n                 result.push_str(&comment_line_separator);\n@@ -516,9 +519,9 @@ pub fn recover_missing_comment_in_span(\n         let force_new_line_before_comment =\n             missing_snippet[..pos].contains('\\n') || total_width > context.config.max_width();\n         let sep = if force_new_line_before_comment {\n-            format!(\"\\n{}\", shape.indent.to_string(context.config))\n+            shape.indent.to_string_with_newline(context.config)\n         } else {\n-            String::from(\" \")\n+            Cow::from(\" \")\n         };\n         Some(format!(\"{}{}\", sep, missing_comment))\n     }\n@@ -701,12 +704,6 @@ impl RichChar for (usize, char) {\n     }\n }\n \n-impl RichChar for (char, usize) {\n-    fn get_char(&self) -> char {\n-        self.0\n-    }\n-}\n-\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n enum CharClassesStatus {\n     Normal,"}, {"sha": "1ed85619235b3db33dde0b4f5f72e2f0504716eb", "filename": "rustfmt-core/src/expr.rs", "status": "modified", "additions": 74, "deletions": 58, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fexpr.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -65,7 +65,10 @@ pub fn format_expr(\n     let expr_rw = match expr.node {\n         ast::ExprKind::Array(ref expr_vec) => rewrite_array(\n             &ptr_vec_to_ref_vec(expr_vec),\n-            mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi()),\n+            mk_sp(\n+                context.snippet_provider.span_after(expr.span, \"[\"),\n+                expr.span.hi(),\n+            ),\n             context,\n             shape,\n             false,\n@@ -389,10 +392,10 @@ where\n         rhs_shape = rhs_shape.offset_left(infix.len())?;\n     }\n     let rhs_result = rhs.rewrite(context, rhs_shape)?;\n-    let indent_str = rhs_shape.indent.to_string(context.config);\n+    let indent_str = rhs_shape.indent.to_string_with_newline(context.config);\n     let infix_with_sep = match separator_place {\n-        SeparatorPlace::Back => format!(\"{}\\n{}\", infix, indent_str),\n-        SeparatorPlace::Front => format!(\"\\n{}{}\", indent_str, infix),\n+        SeparatorPlace::Back => format!(\"{}{}\", infix, indent_str),\n+        SeparatorPlace::Front => format!(\"{}{}\", indent_str, infix),\n     };\n     Some(format!(\n         \"{}{}{}{}\",\n@@ -425,7 +428,7 @@ pub fn rewrite_array<T: Rewrite + Spanned + ToExpr>(\n     };\n \n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         exprs.iter(),\n         \"]\",\n         \",\",\n@@ -486,10 +489,10 @@ pub fn rewrite_array<T: Rewrite + Spanned + ToExpr>(\n         }\n     } else {\n         format!(\n-            \"[\\n{}{}\\n{}]\",\n-            nested_shape.indent.to_string(context.config),\n+            \"[{}{}{}]\",\n+            nested_shape.indent.to_string_with_newline(context.config),\n             list_str,\n-            shape.block().indent.to_string(context.config)\n+            shape.block().indent.to_string_with_newline(context.config)\n         )\n     };\n \n@@ -1002,13 +1005,15 @@ impl<'a> ControlFlow<'a> {\n         let lo = self.label.map_or(self.span.lo(), |label| label.span.hi());\n         let between_kwd_cond = mk_sp(\n             context\n-                .codemap\n+                .snippet_provider\n                 .span_after(mk_sp(lo, self.span.hi()), self.keyword.trim()),\n             self.pat.map_or(cond_span.lo(), |p| {\n                 if self.matcher.is_empty() {\n                     p.span.lo()\n                 } else {\n-                    context.codemap.span_before(self.span, self.matcher.trim())\n+                    context\n+                        .snippet_provider\n+                        .span_before(self.span, self.matcher.trim())\n                 }\n             }),\n         );\n@@ -1060,7 +1065,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         debug!(\"ControlFlow::rewrite {:?} {:?}\", self, shape);\n \n-        let alt_block_sep = String::from(\"\\n\") + &shape.indent.to_string(context.config);\n+        let alt_block_sep = &shape.indent.to_string_with_newline(context.config);\n         let (cond_str, used_width) = self.rewrite_cond(context, shape, &alt_block_sep)?;\n         // If `used_width` is 0, it indicates that whole control flow is written in a single line.\n         if used_width == 0 {\n@@ -1131,15 +1136,15 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             let between_kwd_else_block = mk_sp(\n                 self.block.span.hi(),\n                 context\n-                    .codemap\n+                    .snippet_provider\n                     .span_before(mk_sp(self.block.span.hi(), else_block.span.lo()), \"else\"),\n             );\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n             let after_else = mk_sp(\n                 context\n-                    .codemap\n+                    .snippet_provider\n                     .span_after(mk_sp(self.block.span.hi(), else_block.span.lo()), \"else\"),\n                 else_block.span.lo(),\n             );\n@@ -1180,9 +1185,9 @@ fn rewrite_label(opt_label: Option<ast::Label>) -> Cow<'static, str> {\n fn extract_comment(span: Span, context: &RewriteContext, shape: Shape) -> Option<String> {\n     match rewrite_missing_comment(span, shape, context) {\n         Some(ref comment) if !comment.is_empty() => Some(format!(\n-            \"\\n{indent}{}\\n{indent}\",\n+            \"{indent}{}{indent}\",\n             comment,\n-            indent = shape.indent.to_string(context.config)\n+            indent = shape.indent.to_string_with_newline(context.config)\n         )),\n         _ => None,\n     }\n@@ -1266,7 +1271,7 @@ fn rewrite_match(\n         IndentStyle::Block => cond_shape.offset_left(6)?,\n     };\n     let cond_str = cond.rewrite(context, cond_shape)?;\n-    let alt_block_sep = String::from(\"\\n\") + &shape.indent.to_string(context.config);\n+    let alt_block_sep = &shape.indent.to_string_with_newline(context.config);\n     let block_sep = match context.config.control_brace_style() {\n         ControlBraceStyle::AlwaysNextLine => &alt_block_sep,\n         _ if last_line_extendable(&cond_str) => \" \",\n@@ -1295,7 +1300,9 @@ fn rewrite_match(\n         } else {\n             arms[0].span().lo()\n         };\n-        context.codemap.span_after(mk_sp(cond.span.hi(), hi), \"{\")\n+        context\n+            .snippet_provider\n+            .span_after(mk_sp(cond.span.hi(), hi), \"{\")\n     } else {\n         inner_attrs[inner_attrs.len() - 1].span().hi()\n     };\n@@ -1353,7 +1360,7 @@ fn rewrite_match_arms(\n         .take(arm_len.checked_sub(1).unwrap_or(0))\n         .chain(repeat(true));\n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         arms.iter()\n             .zip(is_last_iter)\n             .map(|(arm, is_last)| ArmWrapper::new(arm, is_last)),\n@@ -1555,8 +1562,7 @@ fn rewrite_match_body(\n     };\n \n     let comma = arm_comma(context.config, body, is_last);\n-    let alt_block_sep = String::from(\"\\n\") + &shape.indent.to_string(context.config);\n-    let alt_block_sep = alt_block_sep.as_str();\n+    let alt_block_sep = &shape.indent.to_string_with_newline(context.config);\n \n     let combine_orig_body = |body_str: &str| {\n         let block_sep = match context.config.control_brace_style() {\n@@ -1576,31 +1582,31 @@ fn rewrite_match_body(\n     let combine_next_line_body = |body_str: &str| {\n         if is_block {\n             return Some(format!(\n-                \"{} =>\\n{}{}\",\n+                \"{} =>{}{}\",\n                 pats_str,\n-                next_line_indent.to_string(context.config),\n+                next_line_indent.to_string_with_newline(context.config),\n                 body_str\n             ));\n         }\n \n-        let indent_str = shape.indent.to_string(context.config);\n-        let nested_indent_str = next_line_indent.to_string(context.config);\n+        let indent_str = shape.indent.to_string_with_newline(context.config);\n+        let nested_indent_str = next_line_indent.to_string_with_newline(context.config);\n         let (body_prefix, body_suffix) = if context.config.match_arm_blocks() {\n             let comma = if context.config.match_block_trailing_comma() {\n                 \",\"\n             } else {\n                 \"\"\n             };\n-            (\"{\", format!(\"\\n{}}}{}\", indent_str, comma))\n+            (\"{\", format!(\"{}}}{}\", indent_str, comma))\n         } else {\n             (\"\", String::from(\",\"))\n         };\n \n         let block_sep = match context.config.control_brace_style() {\n-            ControlBraceStyle::AlwaysNextLine => format!(\"{}{}\\n\", alt_block_sep, body_prefix),\n-            _ if body_prefix.is_empty() => \"\\n\".to_owned(),\n-            _ if forbid_same_line => format!(\"{}{}\\n\", alt_block_sep, body_prefix),\n-            _ => format!(\" {}\\n\", body_prefix),\n+            ControlBraceStyle::AlwaysNextLine => format!(\"{}{}\", alt_block_sep, body_prefix),\n+            _ if body_prefix.is_empty() => \"\".to_owned(),\n+            _ if forbid_same_line => format!(\"{}{}\", alt_block_sep, body_prefix),\n+            _ => format!(\" {}\", body_prefix),\n         } + &nested_indent_str;\n \n         Some(format!(\n@@ -1690,8 +1696,8 @@ fn rewrite_guard(\n         if let Some(cond_shape) = cond_shape {\n             if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n                 return Some(format!(\n-                    \"\\n{}if {}\",\n-                    cond_shape.indent.to_string(context.config),\n+                    \"{}if {}\",\n+                    cond_shape.indent.to_string_with_newline(context.config),\n                     cond_str\n                 ));\n             }\n@@ -1742,9 +1748,9 @@ fn rewrite_pat_expr(\n     let nested_shape = shape\n         .block_indent(context.config.tab_spaces())\n         .with_max_width(context.config);\n-    let nested_indent_str = nested_shape.indent.to_string(context.config);\n+    let nested_indent_str = nested_shape.indent.to_string_with_newline(context.config);\n     expr.rewrite(context, nested_shape)\n-        .map(|expr_rw| format!(\"\\n{}{}\", nested_indent_str, expr_rw))\n+        .map(|expr_rw| format!(\"{}{}\", nested_indent_str, expr_rw))\n }\n \n fn can_extend_match_arm_body(body: &ast::Expr) -> bool {\n@@ -1915,7 +1921,7 @@ where\n         used_width + paren_overhead,\n     )?;\n \n-    let span_lo = context.codemap.span_after(span, \"(\");\n+    let span_lo = context.snippet_provider.span_after(span, \"(\");\n     let args_span = mk_sp(span_lo, span.hi());\n \n     let (extendable, list_str) = rewrite_call_args(\n@@ -1974,7 +1980,7 @@ where\n     T: Rewrite + Spanned + ToExpr + 'a,\n {\n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         args.iter(),\n         \")\",\n         \",\",\n@@ -2315,18 +2321,28 @@ pub fn wrap_args_with_parens(\n         || (context.inside_macro && !args_str.contains('\\n')\n             && args_str.len() + paren_overhead(context) <= shape.width) || is_extendable\n     {\n+        let mut result = String::with_capacity(args_str.len() + 4);\n         if context.config.spaces_within_parens_and_brackets() && !args_str.is_empty() {\n-            format!(\"( {} )\", args_str)\n+            result.push_str(\"( \");\n+            result.push_str(args_str);\n+            result.push_str(\" )\");\n         } else {\n-            format!(\"({})\", args_str)\n+            result.push_str(\"(\");\n+            result.push_str(args_str);\n+            result.push_str(\")\");\n         }\n+        result\n     } else {\n-        format!(\n-            \"(\\n{}{}\\n{})\",\n-            nested_shape.indent.to_string(context.config),\n-            args_str,\n-            shape.block().indent.to_string(context.config)\n-        )\n+        let nested_indent_str = nested_shape.indent.to_string_with_newline(context.config);\n+        let indent_str = shape.block().indent.to_string_with_newline(context.config);\n+        let mut result =\n+            String::with_capacity(args_str.len() + 2 + indent_str.len() + nested_indent_str.len());\n+        result.push_str(\"(\");\n+        result.push_str(&nested_indent_str);\n+        result.push_str(args_str);\n+        result.push_str(&indent_str);\n+        result.push_str(\")\");\n+        result\n     }\n }\n \n@@ -2418,17 +2434,17 @@ fn rewrite_index(\n     let new_index_rw = index.rewrite(context, index_shape);\n     match (orig_index_rw, new_index_rw) {\n         (_, Some(ref new_index_str)) if !new_index_str.contains('\\n') => Some(format!(\n-            \"{}\\n{}{}{}{}\",\n+            \"{}{}{}{}{}\",\n             expr_str,\n-            indent.to_string(context.config),\n+            indent.to_string_with_newline(context.config),\n             lbr,\n             new_index_str,\n             rbr\n         )),\n         (None, Some(ref new_index_str)) => Some(format!(\n-            \"{}\\n{}{}{}{}\",\n+            \"{}{}{}{}{}\",\n             expr_str,\n-            indent.to_string(context.config),\n+            indent.to_string_with_newline(context.config),\n             lbr,\n             new_index_str,\n             rbr\n@@ -2473,7 +2489,7 @@ fn rewrite_struct_lit<'a>(\n     let (h_shape, v_shape) = struct_lit_shape(shape, context, path_str.len() + 3, 2)?;\n \n     let one_line_width = h_shape.map_or(0, |shape| shape.width);\n-    let body_lo = context.codemap.span_after(span, \"{\");\n+    let body_lo = context.snippet_provider.span_after(span, \"{\");\n     let fields_str = if struct_lit_can_be_aligned(fields, &base)\n         && context.config.struct_field_align_threshold() > 0\n     {\n@@ -2516,7 +2532,7 @@ fn rewrite_struct_lit<'a>(\n         };\n \n         let items = itemize_list(\n-            context.codemap,\n+            context.snippet_provider,\n             field_iter,\n             \"}\",\n             \",\",\n@@ -2555,10 +2571,10 @@ pub fn wrap_struct_field(\n             || fields_str.len() > one_line_width)\n     {\n         format!(\n-            \"\\n{}{}\\n{}\",\n-            nested_shape.indent.to_string(context.config),\n+            \"{}{}{}\",\n+            nested_shape.indent.to_string_with_newline(context.config),\n             fields_str,\n-            shape.indent.to_string(context.config)\n+            shape.indent.to_string_with_newline(context.config)\n         )\n     } else {\n         // One liner or visual indent.\n@@ -2581,7 +2597,7 @@ pub fn rewrite_field(\n     }\n     let mut attrs_str = field.attrs.rewrite(context, shape)?;\n     if !attrs_str.is_empty() {\n-        attrs_str.push_str(&format!(\"\\n{}\", shape.indent.to_string(context.config)));\n+        attrs_str.push_str(&shape.indent.to_string_with_newline(context.config));\n     };\n     let name = field.ident.node.to_string();\n     if field.is_shorthand {\n@@ -2665,10 +2681,10 @@ where\n             });\n     }\n \n-    let list_lo = context.codemap.span_after(span, \"(\");\n+    let list_lo = context.snippet_provider.span_after(span, \"(\");\n     let nested_shape = shape.sub_width(2)?.visual_indent(1);\n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         items,\n         \")\",\n         \",\",\n@@ -2840,7 +2856,7 @@ pub fn choose_rhs<R: Rewrite>(\n                 Shape::indented(shape.indent.block_indent(context.config), context.config)\n                     .sub_width(shape.rhs_overhead(context.config))?;\n             let new_rhs = expr.rewrite(context, new_shape);\n-            let new_indent_str = &new_shape.indent.to_string(context.config);\n+            let new_indent_str = &new_shape.indent.to_string_with_newline(context.config);\n \n             match (orig_rhs, new_rhs) {\n                 (Some(ref orig_rhs), Some(ref new_rhs))\n@@ -2850,9 +2866,9 @@ pub fn choose_rhs<R: Rewrite>(\n                     Some(format!(\" {}\", orig_rhs))\n                 }\n                 (Some(ref orig_rhs), Some(ref new_rhs)) if prefer_next_line(orig_rhs, new_rhs) => {\n-                    Some(format!(\"\\n{}{}\", new_indent_str, new_rhs))\n+                    Some(format!(\"{}{}\", new_indent_str, new_rhs))\n                 }\n-                (None, Some(ref new_rhs)) => Some(format!(\"\\n{}{}\", new_indent_str, new_rhs)),\n+                (None, Some(ref new_rhs)) => Some(format!(\"{}{}\", new_indent_str, new_rhs)),\n                 (None, None) => None,\n                 (Some(ref orig_rhs), _) => Some(format!(\" {}\", orig_rhs)),\n             }"}, {"sha": "9a6af3f267c97506bd77f64c884b785aa5bdfd7e", "filename": "rustfmt-core/src/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fimports.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -314,14 +314,14 @@ fn rewrite_nested_use_tree(\n         // Dummy value, see explanation below.\n         let mut items = vec![ListItem::from_str(\"\")];\n         let iter = itemize_list(\n-            context.codemap,\n+            context.snippet_provider,\n             trees.iter().map(|tree| &tree.0),\n             \"}\",\n             \",\",\n             |tree| tree.span.lo(),\n             |tree| tree.span.hi(),\n             |tree| tree.rewrite(context, nested_shape),\n-            context.codemap.span_after(span, \"{\"),\n+            context.snippet_provider.span_after(span, \"{\"),\n             span.hi(),\n             false,\n         );"}, {"sha": "75ad30b6f2a9202a2fa2a2e8b08ab050d99a99b5", "filename": "rustfmt-core/src/issues.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fissues.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -93,6 +93,10 @@ impl BadIssueSeeker {\n         }\n     }\n \n+    pub fn is_disabled(&self) -> bool {\n+        !is_enabled(self.report_todo) && !is_enabled(self.report_fixme)\n+    }\n+\n     // Check whether or not the current char is conclusive evidence for an\n     // unnumbered TO-DO or FIX-ME.\n     pub fn inspect(&mut self, c: char) -> Option<Issue> {"}, {"sha": "add3cdc0d79f6256a6a49c314541208d06c808f2", "filename": "rustfmt-core/src/items.rs", "status": "modified", "additions": 66, "deletions": 67, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fitems.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -318,8 +318,7 @@ impl<'a> FmtVisitor<'a> {\n         // start of the body, but we need more spans from the compiler to solve\n         // this.\n         if newline_brace {\n-            result.push('\\n');\n-            result.push_str(&indent.to_string(self.config));\n+            result.push_str(&indent.to_string_with_newline(self.config));\n         } else {\n             result.push(' ');\n         }\n@@ -471,13 +470,12 @@ impl<'a> FmtVisitor<'a> {\n             return None;\n         }\n         let mut result = String::with_capacity(1024);\n-        result.push('\\n');\n-        let indentation = self.block_indent.to_string(self.config);\n+        let indentation = self.block_indent.to_string_with_newline(self.config);\n         result.push_str(&indentation);\n \n         let itemize_list_with = |one_line_width: usize| {\n             itemize_list(\n-                self.codemap,\n+                self.snippet_provider,\n                 enum_def.variants.iter(),\n                 \"}\",\n                 \",\",\n@@ -571,8 +569,7 @@ pub fn format_impl(\n     if let ast::ItemKind::Impl(_, _, _, ref generics, _, ref self_ty, ref items) = item.node {\n         let mut result = String::with_capacity(128);\n         let ref_and_type = format_impl_ref_and_type(context, item, offset)?;\n-        let indent_str = offset.to_string(context.config);\n-        let sep = format!(\"\\n{}\", &indent_str);\n+        let sep = offset.to_string_with_newline(context.config);\n         result.push_str(&ref_and_type);\n \n         let where_budget = if result.contains('\\n') {\n@@ -623,10 +620,9 @@ pub fn format_impl(\n         }\n \n         if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') {\n-            result.push('\\n');\n             let width = offset.block_indent + context.config.tab_spaces() - 1;\n             let where_indent = Indent::new(0, width);\n-            result.push_str(&where_indent.to_string(context.config));\n+            result.push_str(&where_indent.to_string_with_newline(context.config));\n         }\n         result.push_str(&where_clause_str);\n \n@@ -662,13 +658,11 @@ pub fn format_impl(\n \n             visitor.format_missing(item.span.hi() - BytePos(1));\n \n-            let inner_indent_str = visitor.block_indent.to_string(context.config);\n-            let outer_indent_str = offset.block_only().to_string(context.config);\n+            let inner_indent_str = visitor.block_indent.to_string_with_newline(context.config);\n+            let outer_indent_str = offset.block_only().to_string_with_newline(context.config);\n \n-            result.push('\\n');\n             result.push_str(&inner_indent_str);\n             result.push_str(visitor.buffer.to_string().trim());\n-            result.push('\\n');\n             result.push_str(&outer_indent_str);\n         }\n \n@@ -722,7 +716,7 @@ fn format_impl_ref_and_type(\n         result.push_str(format_unsafety(unsafety));\n         result.push_str(\"impl\");\n \n-        let lo = context.codemap.span_after(item.span, \"impl\");\n+        let lo = context.snippet_provider.span_after(item.span, \"impl\");\n         let hi = match *trait_ref {\n             Some(ref tr) => tr.path.span.lo(),\n             None => self_ty.span.lo(),\n@@ -929,7 +923,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         result.push_str(&header);\n \n-        let body_lo = context.codemap.span_after(item.span, \"{\");\n+        let body_lo = context.snippet_provider.span_after(item.span, \"{\");\n \n         let shape = Shape::indented(offset, context.config).offset_left(result.len())?;\n         let generics_str =\n@@ -939,7 +933,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         // FIXME(#2055): rustfmt fails to format when there are comments between trait bounds.\n         if !type_param_bounds.is_empty() {\n             let ident_hi = context\n-                .codemap\n+                .snippet_provider\n                 .span_after(item.span, &format!(\"{}\", item.ident));\n             let bound_hi = type_param_bounds.last().unwrap().span().hi();\n             let snippet = context.snippet(mk_sp(ident_hi, bound_hi));\n@@ -957,9 +951,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         if offset.width() + last_line_width(&result) + trait_bound_str.len()\n             > context.config.comment_width()\n         {\n-            result.push('\\n');\n             let trait_indent = offset.block_only().block_indent(context.config);\n-            result.push_str(&trait_indent.to_string(context.config));\n+            result.push_str(&trait_indent.to_string_with_newline(context.config));\n         }\n         result.push_str(&trait_bound_str);\n \n@@ -995,10 +988,9 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             && last_line_width(&result) + where_clause_str.len() + offset.width()\n                 > context.config.comment_width()\n         {\n-            result.push('\\n');\n             let width = offset.block_indent + context.config.tab_spaces() - 1;\n             let where_indent = Indent::new(0, width);\n-            result.push_str(&where_indent.to_string(context.config));\n+            result.push_str(&where_indent.to_string_with_newline(context.config));\n         }\n         result.push_str(&where_clause_str);\n \n@@ -1026,20 +1018,17 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         match context.config.brace_style() {\n             _ if last_line_contains_single_line_comment(&result) => {\n-                result.push('\\n');\n-                result.push_str(&offset.to_string(context.config));\n+                result.push_str(&offset.to_string_with_newline(context.config));\n             }\n             BraceStyle::AlwaysNextLine => {\n-                result.push('\\n');\n-                result.push_str(&offset.to_string(context.config));\n+                result.push_str(&offset.to_string_with_newline(context.config));\n             }\n             BraceStyle::PreferSameLine => result.push(' '),\n             BraceStyle::SameLineWhere => {\n                 if !where_clause_str.is_empty()\n                     && (!trait_items.is_empty() || result.contains('\\n'))\n                 {\n-                    result.push('\\n');\n-                    result.push_str(&offset.to_string(context.config));\n+                    result.push_str(&offset.to_string_with_newline(context.config));\n                 } else {\n                     result.push(' ');\n                 }\n@@ -1061,13 +1050,11 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n             visitor.format_missing(item.span.hi() - BytePos(1));\n \n-            let inner_indent_str = visitor.block_indent.to_string(context.config);\n-            let outer_indent_str = offset.block_only().to_string(context.config);\n+            let inner_indent_str = visitor.block_indent.to_string_with_newline(context.config);\n+            let outer_indent_str = offset.block_only().to_string_with_newline(context.config);\n \n-            result.push('\\n');\n             result.push_str(&inner_indent_str);\n             result.push_str(visitor.buffer.to_string().trim());\n-            result.push('\\n');\n             result.push_str(&outer_indent_str);\n         } else if result.contains('\\n') {\n             result.push('\\n');\n@@ -1133,7 +1120,7 @@ pub fn format_struct_struct(\n     result.push_str(&header_str);\n \n     let header_hi = span.lo() + BytePos(header_str.len() as u32);\n-    let body_lo = context.codemap.span_after(span, \"{\");\n+    let body_lo = context.snippet_provider.span_after(span, \"{\");\n \n     let generics_str = match struct_parts.generics {\n         Some(g) => format_generics(\n@@ -1231,7 +1218,7 @@ fn get_bytepos_after_visibility(\n ) -> BytePos {\n     match *vis {\n         ast::Visibility::Crate(s, CrateSugar::PubCrate) => context\n-            .codemap\n+            .snippet_provider\n             .span_after(mk_sp(s.hi(), default_span.hi()), terminator),\n         ast::Visibility::Crate(s, CrateSugar::JustCrate) => s.hi(),\n         ast::Visibility::Restricted { ref path, .. } => path.span.hi(),\n@@ -1253,20 +1240,24 @@ fn format_tuple_struct(\n \n     let body_lo = if fields.is_empty() {\n         let lo = get_bytepos_after_visibility(context, struct_parts.vis, span, \")\");\n-        context.codemap.span_after(mk_sp(lo, span.hi()), \"(\")\n+        context\n+            .snippet_provider\n+            .span_after(mk_sp(lo, span.hi()), \"(\")\n     } else {\n         fields[0].span.lo()\n     };\n     let body_hi = if fields.is_empty() {\n-        context.codemap.span_after(mk_sp(body_lo, span.hi()), \")\")\n+        context\n+            .snippet_provider\n+            .span_after(mk_sp(body_lo, span.hi()), \")\")\n     } else {\n         // This is a dirty hack to work around a missing `)` from the span of the last field.\n         let last_arg_span = fields[fields.len() - 1].span;\n         if context.snippet(last_arg_span).ends_with(')') {\n             last_arg_span.hi()\n         } else {\n             context\n-                .codemap\n+                .snippet_provider\n                 .span_after(mk_sp(last_arg_span.hi(), span.hi()), \")\")\n         }\n     };\n@@ -1309,7 +1300,9 @@ fn format_tuple_struct(\n         result.push('(');\n         let snippet = context.snippet(mk_sp(\n             body_lo,\n-            context.codemap.span_before(mk_sp(body_lo, span.hi()), \")\"),\n+            context\n+                .snippet_provider\n+                .span_before(mk_sp(body_lo, span.hi()), \")\"),\n         ));\n         if snippet.is_empty() {\n             // `struct S ()`\n@@ -1364,7 +1357,10 @@ pub fn rewrite_type_alias(\n     let g_shape = Shape::indented(indent, context.config)\n         .offset_left(result.len())?\n         .sub_width(2)?;\n-    let g_span = mk_sp(context.codemap.span_after(span, \"type\"), ty.span.lo());\n+    let g_span = mk_sp(\n+        context.snippet_provider.span_after(span, \"type\"),\n+        ty.span.lo(),\n+    );\n     let generics_str = rewrite_generics(context, generics, g_shape, g_span)?;\n     result.push_str(&generics_str);\n \n@@ -1386,7 +1382,10 @@ pub fn rewrite_type_alias(\n     if where_clause_str.is_empty() {\n         result.push_str(\" =\");\n     } else {\n-        result.push_str(&format!(\"\\n{}=\", indent.to_string(context.config)));\n+        result.push_str(&format!(\n+            \"{}=\",\n+            indent.to_string_with_newline(context.config)\n+        ));\n     }\n \n     // 1 = \";\"\n@@ -1580,7 +1579,11 @@ fn rewrite_static(\n             let nested_indent = offset.block_indent(context.config);\n             let nested_shape = Shape::indented(nested_indent, context.config);\n             let ty_str = static_parts.ty.rewrite(context, nested_shape)?;\n-            format!(\"\\n{}{}\", nested_indent.to_string(context.config), ty_str)\n+            format!(\n+                \"{}{}\",\n+                nested_indent.to_string_with_newline(context.config),\n+                ty_str\n+            )\n         }\n     };\n \n@@ -1857,8 +1860,7 @@ fn rewrite_fn_base(\n         } else {\n             result.push_str(\"(\");\n             if context.config.indent_style() == IndentStyle::Visual {\n-                result.push('\\n');\n-                result.push_str(&arg_indent.to_string(context.config));\n+                result.push_str(&arg_indent.to_string_with_newline(context.config));\n             }\n         }\n     } else {\n@@ -1881,15 +1883,15 @@ fn rewrite_fn_base(\n         .map_or(lo_after_visibility, |param| param.span().hi());\n     let args_end = if fd.inputs.is_empty() {\n         context\n-            .codemap\n+            .snippet_provider\n             .span_after(mk_sp(args_start, span.hi()), \")\")\n     } else {\n         let last_span = mk_sp(fd.inputs[fd.inputs.len() - 1].span().hi(), span.hi());\n-        context.codemap.span_after(last_span, \")\")\n+        context.snippet_provider.span_after(last_span, \")\")\n     };\n     let args_span = mk_sp(\n         context\n-            .codemap\n+            .snippet_provider\n             .span_after(mk_sp(args_start, span.hi()), \"(\"),\n         args_end,\n     );\n@@ -1914,11 +1916,9 @@ fn rewrite_fn_base(\n     let mut args_last_line_contains_comment = false;\n     if put_args_in_block {\n         arg_indent = indent.block_indent(context.config);\n-        result.push('\\n');\n-        result.push_str(&arg_indent.to_string(context.config));\n+        result.push_str(&arg_indent.to_string_with_newline(context.config));\n         result.push_str(&arg_str);\n-        result.push('\\n');\n-        result.push_str(&indent.to_string(context.config));\n+        result.push_str(&indent.to_string_with_newline(context.config));\n         result.push(')');\n     } else {\n         result.push_str(&arg_str);\n@@ -1939,8 +1939,7 @@ fn rewrite_fn_base(\n             .map_or(false, |last_line| last_line.contains(\"//\"))\n         {\n             args_last_line_contains_comment = true;\n-            result.push('\\n');\n-            result.push_str(&arg_indent.to_string(context.config));\n+            result.push_str(&arg_indent.to_string_with_newline(context.config));\n         }\n         result.push(')');\n     }\n@@ -1979,8 +1978,7 @@ fn rewrite_fn_base(\n                 arg_indent\n             };\n \n-            result.push('\\n');\n-            result.push_str(&indent.to_string(context.config));\n+            result.push_str(&indent.to_string_with_newline(context.config));\n             indent\n         } else {\n             result.push(' ');\n@@ -2140,7 +2138,7 @@ fn rewrite_args(\n             };\n             let reduced_span = mk_sp(span.lo(), second_arg_start);\n \n-            context.codemap.span_after_last(reduced_span, \",\")\n+            context.snippet_provider.span_after_last(reduced_span, \",\")\n         } else {\n             span.lo()\n         };\n@@ -2152,14 +2150,15 @@ fn rewrite_args(\n \n         let variadic_arg = if variadic {\n             let variadic_span = mk_sp(args.last().unwrap().ty.span.hi(), span.hi());\n-            let variadic_start = context.codemap.span_after(variadic_span, \"...\") - BytePos(3);\n+            let variadic_start =\n+                context.snippet_provider.span_after(variadic_span, \"...\") - BytePos(3);\n             Some(ArgumentKind::Variadic(variadic_start))\n         } else {\n             None\n         };\n \n         let more_items = itemize_list(\n-            context.codemap,\n+            context.snippet_provider,\n             args[min_args - 1..]\n                 .iter()\n                 .map(ArgumentKind::Regular)\n@@ -2353,14 +2352,14 @@ fn rewrite_generics_inner(\n     }\n \n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         generics.params.iter(),\n         \">\",\n         \",\",\n         |arg| arg.span().lo(),\n         |arg| arg.span().hi(),\n         |arg| arg.rewrite(context, shape),\n-        context.codemap.span_after(span, \"<\"),\n+        context.snippet_provider.span_after(span, \"<\"),\n         span.hi(),\n         false,\n     );\n@@ -2478,9 +2477,9 @@ fn rewrite_where_clause_rfc_style(\n         rewrite_comments_before_after_where(context, span_before, span_after, shape)?;\n \n     let starting_newline = if where_clause_option.snuggle && comment_before.is_empty() {\n-        \" \".to_owned()\n+        Cow::from(\" \")\n     } else {\n-        \"\\n\".to_owned() + &block_shape.indent.to_string(context.config)\n+        block_shape.indent.to_string_with_newline(context.config)\n     };\n \n     let clause_shape = block_shape.block_left(context.config.tab_spaces())?;\n@@ -2494,7 +2493,7 @@ fn rewrite_where_clause_rfc_style(\n     let end_of_preds = where_clause.predicates[len - 1].span().hi();\n     let span_end = span_end.unwrap_or(end_of_preds);\n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         where_clause.predicates.iter(),\n         terminator,\n         \",\",\n@@ -2534,9 +2533,9 @@ fn rewrite_where_clause_rfc_style(\n \n     let comment_separator = |comment: &str, shape: Shape| {\n         if comment.is_empty() {\n-            String::new()\n+            Cow::from(\"\")\n         } else {\n-            format!(\"\\n{}\", shape.indent.to_string(context.config))\n+            shape.indent.to_string_with_newline(context.config)\n         }\n     };\n     let newline_before_where = comment_separator(&comment_before, shape);\n@@ -2547,9 +2546,9 @@ fn rewrite_where_clause_rfc_style(\n         && comment_after.is_empty() && !preds_str.contains('\\n')\n         && 6 + preds_str.len() <= shape.width || where_single_line\n     {\n-        String::from(\" \")\n+        Cow::from(\" \")\n     } else {\n-        format!(\"\\n{}\", clause_shape.indent.to_string(context.config))\n+        clause_shape.indent.to_string_with_newline(context.config)\n     };\n     Some(format!(\n         \"{}{}{}where{}{}{}{}\",\n@@ -2610,7 +2609,7 @@ fn rewrite_where_clause(\n     let end_of_preds = where_clause.predicates[len - 1].span().hi();\n     let span_end = span_end.unwrap_or(end_of_preds);\n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         where_clause.predicates.iter(),\n         terminator,\n         \",\",\n@@ -2807,10 +2806,10 @@ impl Rewrite for ast::ForeignItem {\n                 ty.rewrite(context, shape).map(|ty_str| {\n                     // 1 = space between prefix and type.\n                     let sep = if prefix.len() + ty_str.len() + 1 <= shape.width {\n-                        String::from(\" \")\n+                        Cow::from(\" \")\n                     } else {\n                         let nested_indent = shape.indent.block_indent(context.config);\n-                        format!(\"\\n{}\", nested_indent.to_string(context.config))\n+                        nested_indent.to_string_with_newline(context.config)\n                     };\n                     format!(\"{}{}{};\", prefix, sep, ty_str)\n                 })"}, {"sha": "b095d06abb816aa7cfdccc19023024b404bb693d", "filename": "rustfmt-core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Flib.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -352,7 +352,7 @@ where\n             visitor.format_separate_mod(module, &*filemap);\n         };\n \n-        assert_eq!(\n+        debug_assert_eq!(\n             visitor.line_number,\n             ::utils::count_newlines(&format!(\"{}\", visitor.buffer))\n         );\n@@ -420,13 +420,14 @@ fn format_lines(\n     let mut line_buffer = String::with_capacity(config.max_width() * 2);\n     let mut is_string = false; // true if the current line contains a string literal.\n     let mut format_line = config.file_lines().contains_line(name, cur_line);\n+    let allow_issue_seek = !issue_seeker.is_disabled();\n \n     for (kind, (b, c)) in CharClasses::new(text.chars().enumerate()) {\n         if c == '\\r' {\n             continue;\n         }\n \n-        if format_line {\n+        if allow_issue_seek && format_line {\n             // Add warnings for bad todos/ fixmes\n             if let Some(issue) = issue_seeker.inspect(c) {\n                 errors.push(FormattingError {"}, {"sha": "49797a785bbaa6a3c8cd8216bb0840d7e79764be", "filename": "rustfmt-core/src/lists.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Flists.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -14,13 +14,14 @@ use std::cmp;\n use std::iter::Peekable;\n \n use config::lists::*;\n-use syntax::codemap::{BytePos, CodeMap};\n+use syntax::codemap::BytePos;\n \n use comment::{find_comment_end, rewrite_comment, FindUncommented};\n use config::{Config, IndentStyle};\n use rewrite::RewriteContext;\n use shape::{Indent, Shape};\n use utils::{count_newlines, first_line_width, last_line_width, mk_sp, starts_with_newline};\n+use visitor::SnippetProvider;\n \n pub struct ListFormatting<'a> {\n     pub tactic: DefinitiveListTactic,\n@@ -446,7 +447,7 @@ pub struct ListItems<'a, I, F1, F2, F3>\n where\n     I: Iterator,\n {\n-    codemap: &'a CodeMap,\n+    snippet_provider: &'a SnippetProvider<'a>,\n     inner: Peekable<I>,\n     get_lo: F1,\n     get_hi: F2,\n@@ -473,7 +474,7 @@ where\n         self.inner.next().map(|item| {\n             let mut new_lines = false;\n             // Pre-comment\n-            let pre_snippet = self.codemap\n+            let pre_snippet = self.snippet_provider\n                 .span_to_snippet(mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n                 .unwrap();\n             let trimmed_pre_snippet = pre_snippet.trim();\n@@ -511,7 +512,7 @@ where\n                 Some(next_item) => (self.get_lo)(next_item),\n                 None => self.next_span_start,\n             };\n-            let post_snippet = self.codemap\n+            let post_snippet = self.snippet_provider\n                 .span_to_snippet(mk_sp((self.get_hi)(&item), next_start))\n                 .unwrap();\n \n@@ -619,7 +620,7 @@ where\n #[cfg_attr(feature = \"cargo-clippy\", allow(too_many_arguments))]\n // Creates an iterator over a list's items with associated comments.\n pub fn itemize_list<'a, T, I, F1, F2, F3>(\n-    codemap: &'a CodeMap,\n+    snippet_provider: &'a SnippetProvider,\n     inner: I,\n     terminator: &'a str,\n     separator: &'a str,\n@@ -637,7 +638,7 @@ where\n     F3: Fn(&T) -> Option<String>,\n {\n     ListItems {\n-        codemap,\n+        snippet_provider,\n         inner: inner.peekable(),\n         get_lo,\n         get_hi,"}, {"sha": "1d40efb9b3a1d92135c974852eed2a36c4b839b0", "filename": "rustfmt-core/src/macros.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fmacros.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -114,6 +114,20 @@ fn parse_macro_arg(parser: &mut Parser) -> Option<MacroArg> {\n     None\n }\n \n+/// Rewrite macro name without using pretty-printer if possible.\n+fn rewrite_macro_name(path: &ast::Path, extra_ident: Option<ast::Ident>) -> String {\n+    let name = if path.segments.len() == 1 {\n+        // Avoid using pretty-printer in the common case.\n+        format!(\"{}!\", path.segments[0].identifier)\n+    } else {\n+        format!(\"{}!\", path)\n+    };\n+    match extra_ident {\n+        Some(ident) if ident != symbol::keywords::Invalid.ident() => format!(\"{} {}\", name, ident),\n+        _ => name,\n+    }\n+}\n+\n pub fn rewrite_macro(\n     mac: &ast::Mac,\n     extra_ident: Option<ast::Ident>,\n@@ -132,16 +146,7 @@ pub fn rewrite_macro(\n \n     let original_style = macro_style(mac, context);\n \n-    let macro_name = match extra_ident {\n-        None => format!(\"{}!\", mac.node.path),\n-        Some(ident) => {\n-            if ident == symbol::keywords::Invalid.ident() {\n-                format!(\"{}!\", mac.node.path)\n-            } else {\n-                format!(\"{}! {}\", mac.node.path, ident)\n-            }\n-        }\n-    };\n+    let macro_name = rewrite_macro_name(&mac.node.path, extra_ident);\n \n     let style = if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) {\n         MacroStyle::Brackets\n@@ -245,14 +250,14 @@ pub fn rewrite_macro(\n                     Some(format!(\"{}{}{}; {}{}\", macro_name, lbr, lhs, rhs, rbr))\n                 } else {\n                     Some(format!(\n-                        \"{}{}\\n{}{};\\n{}{}\\n{}{}\",\n+                        \"{}{}{}{};{}{}{}{}\",\n                         macro_name,\n                         lbr,\n-                        nested_shape.indent.to_string(context.config),\n+                        nested_shape.indent.to_string_with_newline(context.config),\n                         lhs,\n-                        nested_shape.indent.to_string(context.config),\n+                        nested_shape.indent.to_string_with_newline(context.config),\n                         rhs,\n-                        shape.indent.to_string(context.config),\n+                        shape.indent.to_string_with_newline(context.config),\n                         rbr\n                     ))\n                 }\n@@ -267,7 +272,7 @@ pub fn rewrite_macro(\n                 // Convert `MacroArg` into `ast::Expr`, as `rewrite_array` only accepts the latter.\n                 let sp = mk_sp(\n                     context\n-                        .codemap\n+                        .snippet_provider\n                         .span_after(mac.span, original_style.opener()),\n                     mac.span.hi() - BytePos(1),\n                 );\n@@ -324,14 +329,14 @@ pub fn rewrite_macro_def(\n     };\n \n     let branch_items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         parsed_def.branches.iter(),\n         \"}\",\n         \";\",\n         |branch| branch.span.lo(),\n         |branch| branch.span.hi(),\n         |branch| branch.rewrite(context, arm_shape, multi_branch_style),\n-        context.codemap.span_after(span, \"{\"),\n+        context.snippet_provider.span_after(span, \"{\"),\n         span.hi(),\n         false,\n     ).collect::<Vec<_>>();\n@@ -348,15 +353,14 @@ pub fn rewrite_macro_def(\n     };\n \n     if multi_branch_style {\n-        result += \" {\\n\";\n-        result += &arm_shape.indent.to_string(context.config);\n+        result += \" {\";\n+        result += &arm_shape.indent.to_string_with_newline(context.config);\n     }\n \n     result += write_list(&branch_items, &fmt)?.as_str();\n \n     if multi_branch_style {\n-        result += \"\\n\";\n-        result += &indent.to_string(context.config);\n+        result += &indent.to_string_with_newline(context.config);\n         result += \"}\";\n     }\n "}, {"sha": "4bcf2890c35e8678b8e9cbd17706e2bee7611c25", "filename": "rustfmt-core/src/patterns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fpatterns.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -156,14 +156,14 @@ fn rewrite_struct_pat(\n         struct_lit_shape(shape, context, path_str.len() + 3, ellipsis_str.len() + 2)?;\n \n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         fields.iter(),\n         terminator,\n         \",\",\n         |f| f.span.lo(),\n         |f| f.span.hi(),\n         |f| f.node.rewrite(context, v_shape),\n-        context.codemap.span_after(span, \"{\"),\n+        context.snippet_provider.span_after(span, \"{\"),\n         span.hi(),\n         false,\n     );\n@@ -353,14 +353,14 @@ fn count_wildcard_suffix_len(\n     let mut suffix_len = 0;\n \n     let items: Vec<_> = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         patterns.iter(),\n         \")\",\n         \",\",\n         |item| item.span().lo(),\n         |item| item.span().hi(),\n         |item| item.rewrite(context, shape),\n-        context.codemap.span_after(span, \"(\"),\n+        context.snippet_provider.span_after(span, \"(\"),\n         span.hi() - BytePos(1),\n         false,\n     ).collect();"}, {"sha": "51c081e6ba88ee3c5f53339415d78b5bc1f121e1", "filename": "rustfmt-core/src/reorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Freorder.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -157,7 +157,7 @@ fn rewrite_reorderable_items(\n     span: Span,\n ) -> Option<String> {\n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         reorderable_items.iter(),\n         \"\",\n         \";\","}, {"sha": "22d6a096efa4b2a3d49ec389d1c7d6f2ee30dc5b", "filename": "rustfmt-core/src/shape.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fshape.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -25,7 +25,7 @@ pub struct Indent {\n // INDENT_BUFFER.len() = 80\n const INDENT_BUFFER_LEN: usize = 80;\n const INDENT_BUFFER: &str =\n-    \"                                                                                \";\n+    \"\\n                                                                               \";\n impl Indent {\n     pub fn new(block_indent: usize, alignment: usize) -> Indent {\n         Indent {\n@@ -74,16 +74,27 @@ impl Indent {\n     }\n \n     pub fn to_string(&self, config: &Config) -> Cow<'static, str> {\n+        self.to_string_inner(config, 1)\n+    }\n+\n+    pub fn to_string_with_newline(&self, config: &Config) -> Cow<'static, str> {\n+        self.to_string_inner(config, 0)\n+    }\n+\n+    fn to_string_inner(&self, config: &Config, offset: usize) -> Cow<'static, str> {\n         let (num_tabs, num_spaces) = if config.hard_tabs() {\n             (self.block_indent / config.tab_spaces(), self.alignment)\n         } else {\n             (0, self.width())\n         };\n         let num_chars = num_tabs + num_spaces;\n-        if num_tabs == 0 && num_chars <= INDENT_BUFFER_LEN {\n-            Cow::from(&INDENT_BUFFER[0..num_chars])\n+        if num_tabs == 0 && num_chars + offset <= INDENT_BUFFER_LEN {\n+            Cow::from(&INDENT_BUFFER[offset..num_chars + 1])\n         } else {\n-            let mut indent = String::with_capacity(num_chars);\n+            let mut indent = String::with_capacity(num_chars + if offset == 0 { 1 } else { 0 });\n+            if offset == 0 {\n+                indent.push('\\n');\n+            }\n             for _ in 0..num_tabs {\n                 indent.push('\\t')\n             }"}, {"sha": "8a6b0e685c4939889e8487ece16c431916910881", "filename": "rustfmt-core/src/string.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fstring.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -55,7 +55,7 @@ pub fn rewrite_string<'a>(\n \n     let graphemes = UnicodeSegmentation::graphemes(&*stripped_str, false).collect::<Vec<&str>>();\n     let shape = fmt.shape;\n-    let indent = shape.indent.to_string(fmt.config);\n+    let indent = shape.indent.to_string_with_newline(fmt.config);\n     let punctuation = \":,;.\";\n \n     // `cur_start` is the position in `orig` of the start of the current line.\n@@ -133,7 +133,6 @@ pub fn rewrite_string<'a>(\n \n         result.push_str(line);\n         result.push_str(fmt.line_end);\n-        result.push('\\n');\n         result.push_str(&indent);\n         result.push_str(fmt.line_start);\n "}, {"sha": "204b5869f03643ac7771eeda1c86858c13801090", "filename": "rustfmt-core/src/types.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Ftypes.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -14,7 +14,6 @@ use std::ops::Deref;\n use config::lists::*;\n use syntax::ast::{self, FunctionRetTy, Mutability};\n use syntax::codemap::{self, BytePos, Span};\n-use syntax::print::pprust;\n use syntax::symbol::keywords;\n \n use codemap::SpanUtils;\n@@ -201,10 +200,13 @@ fn rewrite_segment(\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n-    let ident_len = segment.identifier.to_string().len();\n+    let mut result = String::with_capacity(128);\n+    result.push_str(&segment.identifier.name.as_str());\n+\n+    let ident_len = result.len();\n     let shape = shape.shrink_left(ident_len)?;\n \n-    let params = if let Some(ref params) = segment.parameters {\n+    if let Some(ref params) = segment.parameters {\n         match **params {\n             ast::PathParameters::AngleBracketed(ref data)\n                 if !data.lifetimes.is_empty() || !data.types.is_empty()\n@@ -218,18 +220,21 @@ fn rewrite_segment(\n                     .collect::<Vec<_>>();\n \n                 let next_span_lo = param_list.last().unwrap().get_span().hi() + BytePos(1);\n-                let list_lo = context.codemap.span_after(mk_sp(*span_lo, span_hi), \"<\");\n+                let list_lo = context\n+                    .snippet_provider\n+                    .span_after(mk_sp(*span_lo, span_hi), \"<\");\n                 let separator = if path_context == PathContext::Expr {\n                     \"::\"\n                 } else {\n                     \"\"\n                 };\n+                result.push_str(separator);\n \n                 let generics_shape =\n                     generics_shape_from_config(context.config, shape, separator.len())?;\n                 let one_line_width = shape.width.checked_sub(separator.len() + 2)?;\n                 let items = itemize_list(\n-                    context.codemap,\n+                    context.snippet_provider,\n                     param_list.into_iter(),\n                     \">\",\n                     \",\",\n@@ -246,29 +251,27 @@ fn rewrite_segment(\n                 // Update position of last bracket.\n                 *span_lo = next_span_lo;\n \n-                format!(\"{}{}\", separator, generics_str)\n+                result.push_str(&generics_str)\n             }\n             ast::PathParameters::Parenthesized(ref data) => {\n                 let output = match data.output {\n                     Some(ref ty) => FunctionRetTy::Ty(ty.clone()),\n                     None => FunctionRetTy::Default(codemap::DUMMY_SP),\n                 };\n-                format_function_type(\n+                result.push_str(&format_function_type(\n                     data.inputs.iter().map(|x| &**x),\n                     &output,\n                     false,\n                     data.span,\n                     context,\n                     shape,\n-                )?\n+                )?);\n             }\n-            _ => String::new(),\n+            _ => (),\n         }\n-    } else {\n-        String::new()\n-    };\n+    }\n \n-    Some(format!(\"{}{}\", segment.identifier, params))\n+    Some(result)\n }\n \n fn format_function_type<'a, I>(\n@@ -296,7 +299,7 @@ where\n     }\n \n     let variadic_arg = if variadic {\n-        let variadic_start = context.codemap.span_before(span, \"...\");\n+        let variadic_start = context.snippet_provider.span_before(span, \"...\");\n         Some(ArgumentKind::Variadic(variadic_start))\n     } else {\n         None\n@@ -315,9 +318,9 @@ where\n         IndentStyle::Visual => shape.indent + 1,\n     };\n     let list_shape = Shape::legacy(budget, offset);\n-    let list_lo = context.codemap.span_after(span, \"(\");\n+    let list_lo = context.snippet_provider.span_after(span, \"(\");\n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         // FIXME Would be nice to avoid this allocation,\n         // but I couldn't get the types to work out.\n         inputs\n@@ -539,7 +542,7 @@ impl Rewrite for ast::TyParamBound {\n \n impl Rewrite for ast::Lifetime {\n     fn rewrite(&self, _: &RewriteContext, _: Shape) -> Option<String> {\n-        Some(pprust::lifetime_to_string(self))\n+        Some(self.ident.to_string())\n     }\n }\n \n@@ -783,7 +786,7 @@ pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &[String])\n     let result = type_strs.join(joiner);\n     if result.contains('\\n') || result.len() > shape.width {\n         let joiner_indent = shape.indent.block_indent(context.config);\n-        let joiner = format!(\"\\n{}+ \", joiner_indent.to_string(context.config));\n+        let joiner = format!(\"{}+ \", joiner_indent.to_string_with_newline(context.config));\n         type_strs.join(&joiner)\n     } else {\n         result"}, {"sha": "20b30089d70eda65a552db7d42b18a19b55f29f3", "filename": "rustfmt-core/src/utils.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Futils.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -278,10 +278,11 @@ pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n // Return true if the given span does not intersect with file lines.\n macro_rules! out_of_file_lines_range {\n     ($self: ident, $span: expr) => {\n-        !$self\n-            .config\n-            .file_lines()\n-            .intersects(&$self.codemap.lookup_line_range($span))\n+        !$self.config.file_lines().is_all()\n+            && !$self\n+                .config\n+                .file_lines()\n+                .intersects(&$self.codemap.lookup_line_range($span))\n     };\n }\n "}, {"sha": "887fefb2272a4aedba809a46bb284adb3a3eb2dc", "filename": "rustfmt-core/src/vertical.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fvertical.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -136,7 +136,7 @@ pub fn rewrite_with_alignment<T: AlignedItem>(\n         let rest_lo = rest[0].get_span().lo();\n         let missing_span = mk_sp(init_hi, rest_lo);\n         let missing_span = mk_sp(\n-            context.codemap.span_after(missing_span, \",\"),\n+            context.snippet_provider.span_after(missing_span, \",\"),\n             missing_span.hi(),\n         );\n \n@@ -227,7 +227,7 @@ fn rewrite_aligned_items_inner<T: AlignedItem>(\n     }\n \n     let items = itemize_list(\n-        context.codemap,\n+        context.snippet_provider,\n         fields.iter(),\n         \"}\",\n         \",\","}, {"sha": "0921c189cd7837e7b8169f2a647ace4d4e54cecb", "filename": "rustfmt-core/src/visitor.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be79f5e433937f04e7bd1c4d0f68612c66a63205/rustfmt-core%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fvisitor.rs?ref=be79f5e433937f04e7bd1c4d0f68612c66a63205", "patch": "@@ -674,13 +674,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         if is_internal {\n             match self.config.brace_style() {\n                 BraceStyle::AlwaysNextLine => {\n-                    let sep_str = format!(\"\\n{}{{\", self.block_indent.to_string(self.config));\n-                    self.push_str(&sep_str);\n+                    let indent_str = self.block_indent.to_string_with_newline(self.config);\n+                    self.push_str(&indent_str);\n+                    self.push_str(\"{\");\n                 }\n                 _ => self.push_str(\" {\"),\n             }\n             // Hackery to account for the closing }.\n-            let mod_lo = self.codemap.span_after(source!(self, s), \"{\");\n+            let mod_lo = self.snippet_provider.span_after(source!(self, s), \"{\");\n             let body_snippet =\n                 self.snippet(mk_sp(mod_lo, source!(self, m.inner).hi() - BytePos(1)));\n             let body_snippet = body_snippet.trim();\n@@ -708,7 +709,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     }\n \n     pub fn skip_empty_lines(&mut self, end_pos: BytePos) {\n-        while let Some(pos) = self.codemap\n+        while let Some(pos) = self.snippet_provider\n             .opt_span_after(mk_sp(self.last_pos, end_pos), \"\\n\")\n         {\n             if let Some(snippet) = self.opt_snippet(mk_sp(self.last_pos, pos)) {\n@@ -756,7 +757,7 @@ impl Rewrite for ast::MetaItem {\n                     .shrink_left(name.len() + 1)\n                     .and_then(|s| s.sub_width(2))?;\n                 let items = itemize_list(\n-                    context.codemap,\n+                    context.snippet_provider,\n                     list.iter(),\n                     \")\",\n                     \",\","}]}