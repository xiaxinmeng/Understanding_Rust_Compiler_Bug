{"sha": "677f0df63b7f39c3b22a84004c1697e85743c470", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3N2YwZGY2M2I3ZjM5YzNiMjJhODQwMDRjMTY5N2U4NTc0M2M0NzA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-13T18:52:18Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-15T15:23:51Z"}, "message": "rustc_metadata: add a helper macro for recording into PerDefTable's.", "tree": {"sha": "2929862d30a3902ec7cf50b03d9a0a75d0d06234", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2929862d30a3902ec7cf50b03d9a0a75d0d06234"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/677f0df63b7f39c3b22a84004c1697e85743c470", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/677f0df63b7f39c3b22a84004c1697e85743c470", "html_url": "https://github.com/rust-lang/rust/commit/677f0df63b7f39c3b22a84004c1697e85743c470", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/677f0df63b7f39c3b22a84004c1697e85743c470/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d52a7e0d0f230627c20dc874c17c528261a397f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d52a7e0d0f230627c20dc874c17c528261a397f", "html_url": "https://github.com/rust-lang/rust/commit/5d52a7e0d0f230627c20dc874c17c528261a397f"}], "stats": {"total": 245, "additions": 118, "deletions": 127}, "files": [{"sha": "7ba395a1bd50ee1c67e315ffc9365745472c64c5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/677f0df63b7f39c3b22a84004c1697e85743c470/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677f0df63b7f39c3b22a84004c1697e85743c470/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=677f0df63b7f39c3b22a84004c1697e85743c470", "patch": "@@ -481,7 +481,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        self.root.entries_table.lookup(self.blob.raw_bytes(), item_id)\n+        self.root.per_def.entry.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n     fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {"}, {"sha": "51634e372a2cd0c625dac1ebd1fb4d3942db584a", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 110, "deletions": 124, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/677f0df63b7f39c3b22a84004c1697e85743c470/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677f0df63b7f39c3b22a84004c1697e85743c470/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=677f0df63b7f39c3b22a84004c1697e85743c470", "patch": "@@ -47,7 +47,7 @@ struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n \n-    entries_table: PerDefTable<Entry<'tcx>>,\n+    per_def: PerDefTables<'tcx>,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -60,6 +60,10 @@ struct EncodeContext<'tcx> {\n     source_file_cache: Lrc<SourceFile>,\n }\n \n+struct PerDefTables<'tcx> {\n+    entry: PerDefTable<Entry<'tcx>>,\n+}\n+\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n@@ -276,6 +280,18 @@ impl<I, T: Encodable> EncodeContentsForLazy<[T]> for I\n     }\n }\n \n+// Shorthand for `$self.$tables.$table.record($key, $self.lazy($value))`, which would\n+// normally need extra variables to avoid errors about multiple mutable borrows.\n+macro_rules! record {\n+    ($self:ident.$tables:ident.$table:ident[$key:expr] <- $value:expr) => {{\n+        {\n+            let value = $value;\n+            let lazy = $self.lazy(value);\n+            $self.$tables.$table.record($key, lazy);\n+        }\n+    }}\n+}\n+\n impl<'tcx> EncodeContext<'tcx> {\n     fn emit_lazy_distance<T: ?Sized + LazyMeta>(\n         &mut self,\n@@ -318,31 +334,10 @@ impl<'tcx> EncodeContext<'tcx> {\n         Lazy::from_position_and_meta(pos, meta)\n     }\n \n-    /// Emit the data for a `DefId` to the metadata. The function to\n-    /// emit the data is `op`, and it will be given `data` as\n-    /// arguments. This `record` function will call `op` to generate\n-    /// the `Entry` (which may point to other encoded information)\n-    /// and will then record the `Lazy<Entry>` for use in the index.\n-    // FIXME(eddyb) remove this.\n-    fn record<DATA>(\n-        &mut self,\n-        id: DefId,\n-        op: impl FnOnce(&mut Self, DATA) -> Entry<'tcx>,\n-        data: DATA,\n-    ) {\n-        assert!(id.is_local());\n-\n-        let entry = op(self, data);\n-        let entry = self.lazy(entry);\n-        self.entries_table.record(id, entry);\n-    }\n-\n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n         let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Public };\n-        self.record(DefId::local(CRATE_DEF_INDEX),\n-                     EncodeContext::encode_info_for_mod,\n-                     (hir::CRATE_HIR_ID, &krate.module, &krate.attrs, &vis));\n+        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.module, &krate.attrs, &vis);\n         krate.visit_all_item_likes(&mut self.as_deep_visitor());\n         for macro_def in &krate.exported_macros {\n             self.visit_macro_def(macro_def);\n@@ -486,8 +481,10 @@ impl<'tcx> EncodeContext<'tcx> {\n \n \n         i = self.position();\n-        let entries_table = self.entries_table.encode(&mut self.opaque);\n-        let entries_table_bytes = self.position() - i;\n+        let per_def = LazyPerDefTables {\n+            entry: self.per_def.entry.encode(&mut self.opaque),\n+        };\n+        let per_def_bytes = self.position() - i;\n \n         // Encode the proc macro data\n         i = self.position();\n@@ -546,7 +543,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             impls,\n             exported_symbols,\n             interpret_alloc_index,\n-            entries_table,\n+            per_def,\n         });\n \n         let total_bytes = self.position();\n@@ -571,7 +568,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"   entries table bytes: {}\", entries_table_bytes);\n+            println!(\"   per-def table bytes: {}\", per_def_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n             println!(\"           total bytes: {}\", total_bytes);\n         }\n@@ -596,8 +593,9 @@ impl EncodeContext<'tcx> {\n \n     fn encode_enum_variant_info(\n         &mut self,\n-        (enum_did, index): (DefId, VariantIdx),\n-    ) -> Entry<'tcx> {\n+        enum_did: DefId,\n+        index: VariantIdx,\n+    ) {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -619,7 +617,7 @@ impl EncodeContext<'tcx> {\n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind: EntryKind::Variant(self.lazy(data)),\n             visibility: self.lazy(ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n             span: self.lazy(tcx.def_span(def_id)),\n@@ -644,13 +642,14 @@ impl EncodeContext<'tcx> {\n \n             mir: self.encode_optimized_mir(def_id),\n             promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n+        })\n     }\n \n     fn encode_enum_variant_ctor(\n         &mut self,\n-        (enum_did, index): (DefId, VariantIdx),\n-    ) -> Entry<'tcx> {\n+        enum_did: DefId,\n+        index: VariantIdx,\n+    ) {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -677,7 +676,7 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind: EntryKind::Variant(self.lazy(data)),\n             visibility: self.lazy(ctor_vis),\n             span: self.lazy(tcx.def_span(def_id)),\n@@ -699,13 +698,16 @@ impl EncodeContext<'tcx> {\n \n             mir: self.encode_optimized_mir(def_id),\n             promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n+        })\n     }\n \n     fn encode_info_for_mod(\n         &mut self,\n-        (id, md, attrs, vis): (hir::HirId, &hir::Mod, &[ast::Attribute], &hir::Visibility),\n-    ) -> Entry<'tcx> {\n+        id: hir::HirId,\n+        md: &hir::Mod,\n+        attrs: &[ast::Attribute],\n+        vis: &hir::Visibility,\n+    ) {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id(id);\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n@@ -717,7 +719,7 @@ impl EncodeContext<'tcx> {\n             },\n         };\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind: EntryKind::Mod(self.lazy(data)),\n             visibility: self.lazy(ty::Visibility::from_hir(vis, id, tcx)),\n             span: self.lazy(tcx.def_span(def_id)),\n@@ -737,13 +739,15 @@ impl EncodeContext<'tcx> {\n \n             mir: None,\n             promoted_mir: None,\n-        }\n+        })\n     }\n \n     fn encode_field(\n         &mut self,\n-        (adt_def_id, variant_index, field_index): (DefId, VariantIdx, usize),\n-    ) -> Entry<'tcx> {\n+        adt_def_id: DefId,\n+        variant_index: VariantIdx,\n+        field_index: usize,\n+    ) {\n         let tcx = self.tcx;\n         let variant = &tcx.adt_def(adt_def_id).variants[variant_index];\n         let field = &variant.fields[field_index];\n@@ -754,7 +758,7 @@ impl EncodeContext<'tcx> {\n         let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind: EntryKind::Field,\n             visibility: self.lazy(field.vis),\n             span: self.lazy(tcx.def_span(def_id)),\n@@ -772,10 +776,10 @@ impl EncodeContext<'tcx> {\n \n             mir: None,\n             promoted_mir: None,\n-        }\n+        })\n     }\n \n-    fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n+    fn encode_struct_ctor(&mut self, adt_def_id: DefId, def_id: DefId) {\n         debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n         let adt_def = tcx.adt_def(adt_def_id);\n@@ -811,7 +815,7 @@ impl EncodeContext<'tcx> {\n \n         let repr_options = get_repr_options(tcx, adt_def_id);\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind: EntryKind::Struct(self.lazy(data), repr_options),\n             visibility: self.lazy(ctor_vis),\n             span: self.lazy(tcx.def_span(def_id)),\n@@ -833,7 +837,7 @@ impl EncodeContext<'tcx> {\n \n             mir: self.encode_optimized_mir(def_id),\n             promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n+        })\n     }\n \n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n@@ -854,7 +858,7 @@ impl EncodeContext<'tcx> {\n         self.lazy(&*tcx.predicates_defined_on(def_id))\n     }\n \n-    fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n@@ -908,7 +912,7 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::OpaqueTy => span_bug!(ast_item.span, \"opaque type in trait\"),\n         };\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind,\n             visibility: self.lazy(trait_item.vis),\n             span: self.lazy(ast_item.span),\n@@ -943,15 +947,15 @@ impl EncodeContext<'tcx> {\n \n             mir: self.encode_optimized_mir(def_id),\n             promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n+        })\n     }\n \n     fn metadata_output_only(&self) -> bool {\n         // MIR optimisation can be skipped when we're just interested in the metadata.\n         !self.tcx.sess.opts.output_types.should_codegen()\n     }\n \n-    fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n@@ -1014,7 +1018,7 @@ impl EncodeContext<'tcx> {\n             hir::ImplItemKind::TyAlias(..) => false,\n         };\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind,\n             visibility: self.lazy(impl_item.vis),\n             span: self.lazy(ast_item.span),\n@@ -1036,7 +1040,7 @@ impl EncodeContext<'tcx> {\n \n             mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n             promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n-        }\n+        })\n     }\n \n     fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId)\n@@ -1110,7 +1114,7 @@ impl EncodeContext<'tcx> {\n         self.lazy(rendered_const)\n     }\n \n-    fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n+    fn encode_info_for_item(&mut self, def_id: DefId, item: &'tcx hir::Item) {\n         let tcx = self.tcx;\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n@@ -1136,7 +1140,7 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod((item.hir_id, m, &item.attrs, &item.vis));\n+                return self.encode_info_for_mod(item.hir_id, m, &item.attrs, &item.vis);\n             }\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1245,7 +1249,7 @@ impl EncodeContext<'tcx> {\n             _ => false,\n         };\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind,\n             visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n             span: self.lazy(item.span),\n@@ -1340,20 +1344,22 @@ impl EncodeContext<'tcx> {\n             // necessary.)\n             predicates_defined_on: match item.kind {\n                 hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates_defined_on(def_id)),\n+                hir::ItemKind::TraitAlias(..) => {\n+                    Some(self.encode_predicates_defined_on(def_id))\n+                }\n                 _ => None, // not *wrong* for other kinds of items, but not needed\n             },\n \n             mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n             promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n-        }\n+        })\n     }\n \n     /// Serialize the text of exported macros\n-    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n+    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) {\n         use syntax::print::pprust;\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind: EntryKind::MacroDef(self.lazy(MacroDef {\n                 body: pprust::tts_to_string(macro_def.body.clone()),\n                 legacy: macro_def.legacy,\n@@ -1373,17 +1379,17 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n             mir: None,\n             promoted_mir: None,\n-        }\n+        })\n     }\n \n     fn encode_info_for_generic_param(\n         &mut self,\n         def_id: DefId,\n         entry_kind: EntryKind<'tcx>,\n         encode_type: bool,\n-    ) -> Entry<'tcx> {\n+    ) {\n         let tcx = self.tcx;\n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind: entry_kind,\n             visibility: self.lazy(ty::Visibility::Public),\n             span: self.lazy(tcx.def_span(def_id)),\n@@ -1400,26 +1406,10 @@ impl EncodeContext<'tcx> {\n \n             mir: None,\n             promoted_mir: None,\n-        }\n-    }\n-\n-    fn encode_info_for_ty_param(\n-        &mut self,\n-        (def_id, encode_type): (DefId, bool),\n-    ) -> Entry<'tcx> {\n-        debug!(\"EncodeContext::encode_info_for_ty_param({:?})\", def_id);\n-        self.encode_info_for_generic_param(def_id, EntryKind::TypeParam, encode_type)\n-    }\n-\n-    fn encode_info_for_const_param(\n-        &mut self,\n-        def_id: DefId,\n-    ) -> Entry<'tcx> {\n-        debug!(\"EncodeContext::encode_info_for_const_param({:?})\", def_id);\n-        self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true)\n+        })\n     }\n \n-    fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_closure(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n \n@@ -1443,7 +1433,7 @@ impl EncodeContext<'tcx> {\n             _ => bug!(\"closure that is neither generator nor closure\")\n         };\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind,\n             visibility: self.lazy(ty::Visibility::Public),\n             span: self.lazy(tcx.def_span(def_id)),\n@@ -1461,18 +1451,18 @@ impl EncodeContext<'tcx> {\n \n             mir: self.encode_optimized_mir(def_id),\n             promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n+        })\n     }\n \n-    fn encode_info_for_anon_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_anon_const(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n         let tcx = self.tcx;\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let mir = tcx.mir_const_qualif(def_id).0;\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind: EntryKind::Const(ConstQualif { mir }, const_data),\n             visibility: self.lazy(ty::Visibility::Public),\n             span: self.lazy(tcx.def_span(def_id)),\n@@ -1490,7 +1480,7 @@ impl EncodeContext<'tcx> {\n \n             mir: self.encode_optimized_mir(def_id),\n             promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n+        })\n     }\n \n     fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> Lazy<[ast::Attribute]> {\n@@ -1668,9 +1658,11 @@ impl EncodeContext<'tcx> {\n         Lazy::empty()\n     }\n \n-    fn encode_info_for_foreign_item(&mut self,\n-                                    (def_id, nitem): (DefId, &hir::ForeignItem))\n-                                    -> Entry<'tcx> {\n+    fn encode_info_for_foreign_item(\n+        &mut self,\n+        def_id: DefId,\n+        nitem: &hir::ForeignItem,\n+    )  {\n         let tcx = self.tcx;\n \n         debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n@@ -1690,7 +1682,7 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         };\n \n-        Entry {\n+        record!(self.per_def.entry[def_id] <- Entry {\n             kind,\n             visibility: self.lazy(ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n             span: self.lazy(nitem.span),\n@@ -1711,10 +1703,11 @@ impl EncodeContext<'tcx> {\n \n             mir: None,\n             promoted_mir: None,\n-        }\n+        })\n     }\n }\n \n+// FIXME(eddyb) make metadata encoding walk over all definitions, instead of HIR.\n impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n@@ -1726,43 +1719,40 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn visit_anon_const(&mut self, c: &'tcx AnonConst) {\n         intravisit::walk_anon_const(self, c);\n         let def_id = self.tcx.hir().local_def_id(c.hir_id);\n-        self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n+        self.encode_info_for_anon_const(def_id);\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n+            _ => self.encode_info_for_item(def_id, item),\n         }\n         self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n-        self.record(def_id,\n-                          EncodeContext::encode_info_for_foreign_item,\n-                          (def_id, ni));\n+        self.encode_info_for_foreign_item(def_id, ni);\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         intravisit::walk_generics(self, generics);\n         self.encode_info_for_generics(generics);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n-        self.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n+        self.encode_info_for_macro_def(macro_def);\n     }\n }\n \n impl EncodeContext<'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter_enumerated() {\n-            for (field_index, field) in variant.fields.iter().enumerate() {\n-                self.record(field.did,\n-                            EncodeContext::encode_field,\n-                            (adt_def_id, variant_index, field_index));\n+            for (field_index, _field) in variant.fields.iter().enumerate() {\n+                // FIXME(eddyb) `adt_def_id` is leftover from incremental isolation,\n+                // pass `def`, `variant` or `field` instead.\n+                self.encode_field(adt_def_id, variant_index, field_index);\n             }\n         }\n     }\n@@ -1773,14 +1763,14 @@ impl EncodeContext<'tcx> {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => continue,\n                 GenericParamKind::Type { ref default, .. } => {\n-                    self.record(\n+                    self.encode_info_for_generic_param(\n                         def_id,\n-                        EncodeContext::encode_info_for_ty_param,\n-                        (def_id, default.is_some()),\n+                        EntryKind::TypeParam,\n+                        default.is_some(),\n                     );\n                 }\n                 GenericParamKind::Const { .. } => {\n-                    self.record(def_id, EncodeContext::encode_info_for_const_param, def_id);\n+                    self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true);\n                 }\n             }\n         }\n@@ -1790,7 +1780,7 @@ impl EncodeContext<'tcx> {\n         match expr.kind {\n             hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-                self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n+                self.encode_info_for_closure(def_id);\n             }\n             _ => {}\n         }\n@@ -1821,14 +1811,14 @@ impl EncodeContext<'tcx> {\n \n                 let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n-                    self.record(variant.def_id,\n-                                EncodeContext::encode_enum_variant_info,\n-                                (def_id, i));\n-\n-                    if let Some(ctor_def_id) = variant.ctor_def_id {\n-                        self.record(ctor_def_id,\n-                                    EncodeContext::encode_enum_variant_ctor,\n-                                    (def_id, i));\n+                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n+                    // pass `def` or `variant` instead.\n+                    self.encode_enum_variant_info(def_id, i);\n+\n+                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n+                    // pass `def`, `variant` or `ctor_def_id` instead.\n+                    if let Some(_ctor_def_id) = variant.ctor_def_id {\n+                        self.encode_enum_variant_ctor(def_id, i);\n                     }\n                 }\n             }\n@@ -1838,26 +1828,20 @@ impl EncodeContext<'tcx> {\n                 // If the struct has a constructor, encode it.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n-                    self.record(ctor_def_id,\n-                                EncodeContext::encode_struct_ctor,\n-                                (def_id, ctor_def_id));\n+                    self.encode_struct_ctor(def_id, ctor_def_id);\n                 }\n             }\n             hir::ItemKind::Union(..) => {\n                 self.encode_fields(def_id);\n             }\n             hir::ItemKind::Impl(..) => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(trait_item_def_id,\n-                                EncodeContext::encode_info_for_impl_item,\n-                                trait_item_def_id);\n+                    self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n                 for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(item_def_id,\n-                                EncodeContext::encode_info_for_trait_item,\n-                                item_def_id);\n+                    self.encode_info_for_trait_item(item_def_id);\n                 }\n             }\n         }\n@@ -1925,7 +1909,9 @@ crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         let mut ecx = EncodeContext {\n             opaque: encoder,\n             tcx,\n-            entries_table: PerDefTable::new(tcx.hir().definitions().def_index_count()),\n+            per_def: PerDefTables {\n+                entry: PerDefTable::new(tcx.hir().definitions().def_index_count()),\n+            },\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),"}, {"sha": "9d6748732b8be6757af0da3bceda75b70a3cbf68", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/677f0df63b7f39c3b22a84004c1697e85743c470/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677f0df63b7f39c3b22a84004c1697e85743c470/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=677f0df63b7f39c3b22a84004c1697e85743c470", "patch": "@@ -197,7 +197,7 @@ crate struct CrateRoot<'tcx> {\n     pub exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n     pub interpret_alloc_index: Lazy<[u32]>,\n \n-    pub entries_table: Lazy!(PerDefTable<Entry<'tcx>>),\n+    pub per_def: LazyPerDefTables<'tcx>,\n \n     /// The DefIndex's of any proc macros delcared by\n     /// this crate\n@@ -227,6 +227,11 @@ crate struct TraitImpls {\n     pub impls: Lazy<[DefIndex]>,\n }\n \n+#[derive(RustcEncodable, RustcDecodable)]\n+crate struct LazyPerDefTables<'tcx> {\n+    pub entry: Lazy!(PerDefTable<Entry<'tcx>>),\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n crate struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n@@ -245,7 +250,7 @@ crate struct Entry<'tcx> {\n     pub predicates_defined_on: Option<Lazy!(ty::GenericPredicates<'tcx>)>,\n \n     pub mir: Option<Lazy!(mir::Body<'tcx>)>,\n-    pub promoted_mir: Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n+    pub promoted_mir: Option<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}]}