{"sha": "f5ea35a2710c78e77c81f491cc6f8abd40e33981", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZWEzNWEyNzEwYzc4ZTc3YzgxZjQ5MWNjNmY4YWJkNDBlMzM5ODE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T15:50:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T16:28:58Z"}, "message": "Add NotificationDispatcher", "tree": {"sha": "8ba08993d86c5c93b9a0db373b22444d25bfab65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ba08993d86c5c93b9a0db373b22444d25bfab65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5ea35a2710c78e77c81f491cc6f8abd40e33981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ea35a2710c78e77c81f491cc6f8abd40e33981", "html_url": "https://github.com/rust-lang/rust/commit/f5ea35a2710c78e77c81f491cc6f8abd40e33981", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5ea35a2710c78e77c81f491cc6f8abd40e33981/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22098127c4f4b7414f0695c7788f07d0a1c43892", "url": "https://api.github.com/repos/rust-lang/rust/commits/22098127c4f4b7414f0695c7788f07d0a1c43892", "html_url": "https://github.com/rust-lang/rust/commit/22098127c4f4b7414f0695c7788f07d0a1c43892"}], "stats": {"total": 166, "additions": 85, "deletions": 81}, "files": [{"sha": "5fdbed8ef395a6ddee41269bd8ff970e2f348b28", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f5ea35a2710c78e77c81f491cc6f8abd40e33981/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ea35a2710c78e77c81f491cc6f8abd40e33981/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=f5ea35a2710c78e77c81f491cc6f8abd40e33981", "patch": "@@ -1,3 +1,4 @@\n+//! A visitor for downcasting arbitrary request (JSON) into a specific type.\n use std::{panic, time::Instant};\n \n use serde::{de::DeserializeOwned, Serialize};\n@@ -135,3 +136,41 @@ where\n     };\n     Task::Respond(response)\n }\n+\n+pub(crate) struct NotificationDispatcher<'a> {\n+    pub(crate) not: Option<lsp_server::Notification>,\n+    pub(crate) global_state: &'a mut GlobalState,\n+}\n+\n+impl<'a> NotificationDispatcher<'a> {\n+    pub(crate) fn on<N>(\n+        &mut self,\n+        f: fn(&mut GlobalState, N::Params) -> Result<()>,\n+    ) -> Result<&mut Self>\n+    where\n+        N: lsp_types::notification::Notification + 'static,\n+        N::Params: DeserializeOwned + Send + 'static,\n+    {\n+        let not = match self.not.take() {\n+            Some(it) => it,\n+            None => return Ok(self),\n+        };\n+        let params = match not.extract::<N::Params>(N::METHOD) {\n+            Ok(it) => it,\n+            Err(not) => {\n+                self.not = Some(not);\n+                return Ok(self);\n+            }\n+        };\n+        f(self.global_state, params)?;\n+        Ok(self)\n+    }\n+\n+    pub(crate) fn finish(&mut self) {\n+        if let Some(not) = &self.not {\n+            if !not.method.starts_with(\"$/\") {\n+                log::error!(\"unhandled notification: {:?}\", not);\n+            }\n+        }\n+    }\n+}"}, {"sha": "35917030c8df6b9e31d6c4f5067c1edd8b6c191c", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5ea35a2710c78e77c81f491cc6f8abd40e33981/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ea35a2710c78e77c81f491cc6f8abd40e33981/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=f5ea35a2710c78e77c81f491cc6f8abd40e33981", "patch": "@@ -1,12 +1,13 @@\n //! Utilities for LSP-related boilerplate code.\n use std::{error::Error, ops::Range};\n \n-use crate::from_proto;\n use crossbeam_channel::Sender;\n use lsp_server::{Message, Notification};\n use ra_db::Canceled;\n use ra_ide::LineIndex;\n-use serde::{de::DeserializeOwned, Serialize};\n+use serde::Serialize;\n+\n+use crate::from_proto;\n \n pub fn show_message(\n     typ: lsp_types::MessageType,\n@@ -29,14 +30,6 @@ pub(crate) fn notification_is<N: lsp_types::notification::Notification>(\n     notification.method == N::METHOD\n }\n \n-pub(crate) fn notification_cast<N>(notification: Notification) -> Result<N::Params, Notification>\n-where\n-    N: lsp_types::notification::Notification,\n-    N::Params: DeserializeOwned,\n-{\n-    notification.extract(N::METHOD)\n-}\n-\n pub(crate) fn notification_new<N>(params: N::Params) -> Notification\n where\n     N: lsp_types::notification::Notification,"}, {"sha": "c2f43df1d0b75a73fd21ae42b594abdff3d0e4ad", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 43, "deletions": 71, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f5ea35a2710c78e77c81f491cc6f8abd40e33981/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ea35a2710c78e77c81f491cc6f8abd40e33981/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=f5ea35a2710c78e77c81f491cc6f8abd40e33981", "patch": "@@ -6,8 +6,8 @@ use std::{\n };\n \n use crossbeam_channel::{never, select, Receiver};\n-use lsp_server::{Connection, Notification, Request, RequestId, Response};\n-use lsp_types::{notification::Notification as _, request::Request as _, NumberOrString};\n+use lsp_server::{Connection, Notification, Request, Response};\n+use lsp_types::{notification::Notification as _, request::Request as _};\n use ra_db::VfsPath;\n use ra_ide::{Canceled, FileId};\n use ra_prof::profile;\n@@ -16,13 +16,12 @@ use ra_project_model::{PackageRoot, ProjectWorkspace};\n use crate::{\n     config::{Config, FilesWatcher, LinkedProject},\n     diagnostics::DiagnosticTask,\n-    dispatch::RequestDispatcher,\n+    dispatch::{NotificationDispatcher, RequestDispatcher},\n     from_proto,\n     global_state::{file_id_to_url, GlobalState, Status},\n     handlers, lsp_ext,\n     lsp_utils::{\n-        apply_document_changes, is_canceled, notification_cast, notification_is, notification_new,\n-        show_message,\n+        apply_document_changes, is_canceled, notification_is, notification_new, show_message,\n     },\n     request_metrics::RequestMetrics,\n     Result,\n@@ -240,9 +239,7 @@ impl GlobalState {\n     }\n \n     fn on_request(&mut self, request_received: Instant, req: Request) -> Result<()> {\n-        let mut pool_dispatcher =\n-            RequestDispatcher { req: Some(req), global_state: self, request_received };\n-        pool_dispatcher\n+        RequestDispatcher { req: Some(req), global_state: self, request_received }\n             .on_sync::<lsp_ext::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n             .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n             .on_sync::<lsp_ext::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n@@ -298,56 +295,47 @@ impl GlobalState {\n         Ok(())\n     }\n     fn on_notification(&mut self, not: Notification) -> Result<()> {\n-        let not = match notification_cast::<lsp_types::notification::Cancel>(not) {\n-            Ok(params) => {\n-                let id: RequestId = match params.id {\n-                    NumberOrString::Number(id) => id.into(),\n-                    NumberOrString::String(id) => id.into(),\n+        NotificationDispatcher { not: Some(not), global_state: self }\n+            .on::<lsp_types::notification::Cancel>(|this, params| {\n+                let id: lsp_server::RequestId = match params.id {\n+                    lsp_types::NumberOrString::Number(id) => id.into(),\n+                    lsp_types::NumberOrString::String(id) => id.into(),\n                 };\n-                if let Some(response) = self.req_queue.incoming.cancel(id) {\n-                    self.send(response.into())\n+                if let Some(response) = this.req_queue.incoming.cancel(id) {\n+                    this.send(response.into());\n                 }\n-                return Ok(());\n-            }\n-            Err(not) => not,\n-        };\n-        let not = match notification_cast::<lsp_types::notification::DidOpenTextDocument>(not) {\n-            Ok(params) => {\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidOpenTextDocument>(|this, params| {\n                 if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    if !self.mem_docs.insert(path.clone()) {\n+                    if !this.mem_docs.insert(path.clone()) {\n                         log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n                     }\n-                    self.vfs\n+                    this.vfs\n                         .write()\n                         .0\n                         .set_file_contents(path, Some(params.text_document.text.into_bytes()));\n                 }\n-                return Ok(());\n-            }\n-            Err(not) => not,\n-        };\n-        let not = match notification_cast::<lsp_types::notification::DidChangeTextDocument>(not) {\n-            Ok(params) => {\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidChangeTextDocument>(|this, params| {\n                 if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    assert!(self.mem_docs.contains(&path));\n-                    let vfs = &mut self.vfs.write().0;\n+                    assert!(this.mem_docs.contains(&path));\n+                    let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n                     let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n                     apply_document_changes(&mut text, params.content_changes);\n                     vfs.set_file_contents(path, Some(text.into_bytes()))\n                 }\n-                return Ok(());\n-            }\n-            Err(not) => not,\n-        };\n-        let not = match notification_cast::<lsp_types::notification::DidCloseTextDocument>(not) {\n-            Ok(params) => {\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidCloseTextDocument>(|this, params| {\n                 if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    if !self.mem_docs.remove(&path) {\n+                    if !this.mem_docs.remove(&path) {\n                         log::error!(\"orphan DidCloseTextDocument: {}\", path)\n                     }\n                     if let Some(path) = path.as_path() {\n-                        self.loader.invalidate(path.to_path_buf());\n+                        this.loader.invalidate(path.to_path_buf());\n                     }\n                 }\n                 let params = lsp_types::PublishDiagnosticsParams {\n@@ -356,25 +344,19 @@ impl GlobalState {\n                     version: None,\n                 };\n                 let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n-                self.send(not.into());\n-                return Ok(());\n-            }\n-            Err(not) => not,\n-        };\n-        let not = match notification_cast::<lsp_types::notification::DidSaveTextDocument>(not) {\n-            Ok(_params) => {\n-                if let Some(flycheck) = &self.flycheck {\n+                this.send(not.into());\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidSaveTextDocument>(|this, _params| {\n+                if let Some(flycheck) = &this.flycheck {\n                     flycheck.0.update();\n                 }\n-                return Ok(());\n-            }\n-            Err(not) => not,\n-        };\n-        let not = match notification_cast::<lsp_types::notification::DidChangeConfiguration>(not) {\n-            Ok(_) => {\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidChangeConfiguration>(|this, _params| {\n                 // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n                 // this notification's parameters should be ignored and the actual config queried separately.\n-                let request = self.req_queue.outgoing.register(\n+                let request = this.req_queue.outgoing.register(\n                     lsp_types::request::WorkspaceConfiguration::METHOD.to_string(),\n                     lsp_types::ConfigurationParams {\n                         items: vec![lsp_types::ConfigurationItem {\n@@ -403,30 +385,21 @@ impl GlobalState {\n                         }\n                     },\n                 );\n-                self.send(request.into());\n+                this.send(request.into());\n \n                 return Ok(());\n-            }\n-            Err(not) => not,\n-        };\n-        let not = match notification_cast::<lsp_types::notification::DidChangeWatchedFiles>(not) {\n-            Ok(params) => {\n+            })?\n+            .on::<lsp_types::notification::DidChangeWatchedFiles>(|this, params| {\n                 for change in params.changes {\n                     if let Ok(path) = from_proto::abs_path(&change.uri) {\n-                        self.loader.invalidate(path)\n+                        this.loader.invalidate(path);\n                     }\n                 }\n-                return Ok(());\n-            }\n-            Err(not) => not,\n-        };\n-        if not.method.starts_with(\"$/\") {\n-            return Ok(());\n-        }\n-        log::error!(\"unhandled notification: {:?}\", not);\n+                Ok(())\n+            })?\n+            .finish();\n         Ok(())\n     }\n-    // TODO\n     pub(crate) fn on_task(&mut self, task: Task) {\n         match task {\n             Task::Respond(response) => {\n@@ -481,7 +454,6 @@ impl GlobalState {\n     }\n }\n \n-// TODO\n #[derive(Debug)]\n pub(crate) enum Task {\n     Respond(Response),"}]}