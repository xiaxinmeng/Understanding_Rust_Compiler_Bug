{"sha": "cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZWViYzViMmNkZTZjYjRmNmNlYzljZDBjZGZiZDVkMmMxNWRjMzk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-14T23:18:48Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-16T16:12:13Z"}, "message": "rustc_trans: take into account primitives larger than 8 bytes.", "tree": {"sha": "eceee893a7de35adc59ea9ea4de726bc65f9b4ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eceee893a7de35adc59ea9ea4de726bc65f9b4ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39", "html_url": "https://github.com/rust-lang/rust/commit/cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da569fa9ddf8369a9809184d43c600dc06bd4b4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/da569fa9ddf8369a9809184d43c600dc06bd4b4d", "html_url": "https://github.com/rust-lang/rust/commit/da569fa9ddf8369a9809184d43c600dc06bd4b4d"}], "stats": {"total": 119, "additions": 64, "deletions": 55}, "files": [{"sha": "630762602d0ac2422375783749252b94cd568fdf", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 43, "deletions": 55, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39", "patch": "@@ -16,9 +16,11 @@ use context::CodegenCx;\n \n use rustc::ty::layout::{self, TyLayout, Size};\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n+/// Classification of \"eightbyte\" components.\n+// NB: the order of the variants is from general to specific,\n+// such that `unify(a, b)` is the \"smaller\" of `a` and `b`.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n enum Class {\n-    None,\n     Int,\n     Sse,\n     SseUp\n@@ -32,29 +34,10 @@ const LARGEST_VECTOR_SIZE: usize = 512;\n const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n-                          -> Result<[Class; MAX_EIGHTBYTES], Memory> {\n-    fn unify(cls: &mut [Class],\n-             off: Size,\n-             c: Class) {\n-        let i = (off.bytes() / 8) as usize;\n-        let to_write = match (cls[i], c) {\n-            (Class::None, _) => c,\n-            (_, Class::None) => return,\n-\n-            (Class::Int, _) |\n-            (_, Class::Int) => Class::Int,\n-\n-            (Class::Sse, _) |\n-            (_, Class::Sse) => Class::Sse,\n-\n-            (Class::SseUp, Class::SseUp) => Class::SseUp\n-        };\n-        cls[i] = to_write;\n-    }\n-\n+                          -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory> {\n     fn classify<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                           layout: TyLayout<'tcx>,\n-                          cls: &mut [Class],\n+                          cls: &mut [Option<Class>],\n                           off: Size)\n                           -> Result<(), Memory> {\n         if !off.is_abi_aligned(layout.align) {\n@@ -64,31 +47,20 @@ fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n             return Ok(());\n         }\n \n-        match layout.abi {\n-            layout::Abi::Uninhabited => {}\n+        let mut c = match layout.abi {\n+            layout::Abi::Uninhabited => return Ok(()),\n \n             layout::Abi::Scalar(ref scalar) => {\n-                let reg = match scalar.value {\n+                match scalar.value {\n                     layout::Int(..) |\n                     layout::Pointer => Class::Int,\n                     layout::F32 |\n                     layout::F64 => Class::Sse\n-                };\n-                unify(cls, off, reg);\n-            }\n-\n-            layout::Abi::Vector { ref element, count } => {\n-                unify(cls, off, Class::Sse);\n-\n-                // everything after the first one is the upper\n-                // half of a register.\n-                let stride = element.value.size(cx);\n-                for i in 1..count {\n-                    let field_off = off + stride * i;\n-                    unify(cls, field_off, Class::SseUp);\n                 }\n             }\n \n+            layout::Abi::Vector { .. } => Class::Sse,\n+\n             layout::Abi::ScalarPair(..) |\n             layout::Abi::Aggregate { .. } => {\n                 match layout.variants {\n@@ -97,12 +69,26 @@ fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n                             let field_off = off + layout.fields.offset(i);\n                             classify(cx, layout.field(cx, i), cls, field_off)?;\n                         }\n+                        return Ok(());\n                     }\n                     layout::Variants::Tagged { .. } |\n                     layout::Variants::NicheFilling { .. } => return Err(Memory),\n                 }\n             }\n \n+        };\n+\n+        // Fill in `cls` for scalars (Int/Sse) and vectors (Sse).\n+        let first = (off.bytes() / 8) as usize;\n+        let last = ((off.bytes() + layout.size.bytes() - 1) / 8) as usize;\n+        for cls in &mut cls[first..=last] {\n+            *cls = Some(cls.map_or(c, |old| old.min(c)));\n+\n+            // Everything after the first Sse \"eightbyte\"\n+            // component is the upper half of a register.\n+            if c == Class::Sse {\n+                c = Class::SseUp;\n+            }\n         }\n \n         Ok(())\n@@ -113,23 +99,23 @@ fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n         return Err(Memory);\n     }\n \n-    let mut cls = [Class::None; MAX_EIGHTBYTES];\n+    let mut cls = [None; MAX_EIGHTBYTES];\n     classify(cx, arg.layout, &mut cls, Size::from_bytes(0))?;\n     if n > 2 {\n-        if cls[0] != Class::Sse {\n+        if cls[0] != Some(Class::Sse) {\n             return Err(Memory);\n         }\n-        if cls[1..n].iter().any(|&c| c != Class::SseUp) {\n+        if cls[1..n].iter().any(|&c| c != Some(Class::SseUp)) {\n             return Err(Memory);\n         }\n     } else {\n         let mut i = 0;\n         while i < n {\n-            if cls[i] == Class::SseUp {\n-                cls[i] = Class::Sse;\n-            } else if cls[i] == Class::Sse {\n+            if cls[i] == Some(Class::SseUp) {\n+                cls[i] = Some(Class::Sse);\n+            } else if cls[i] == Some(Class::Sse) {\n                 i += 1;\n-                while i != n && cls[i] == Class::SseUp { i += 1; }\n+                while i != n && cls[i] == Some(Class::SseUp) { i += 1; }\n             } else {\n                 i += 1;\n             }\n@@ -139,14 +125,14 @@ fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n     Ok(cls)\n }\n \n-fn reg_component(cls: &[Class], i: &mut usize, size: Size) -> Option<Reg> {\n+fn reg_component(cls: &[Option<Class>], i: &mut usize, size: Size) -> Option<Reg> {\n     if *i >= cls.len() {\n         return None;\n     }\n \n     match cls[*i] {\n-        Class::None => None,\n-        Class::Int => {\n+        None => None,\n+        Some(Class::Int) => {\n             *i += 1;\n             Some(match size.bytes() {\n                 1 => Reg::i8(),\n@@ -156,8 +142,10 @@ fn reg_component(cls: &[Class], i: &mut usize, size: Size) -> Option<Reg> {\n                 _ => Reg::i64()\n             })\n         }\n-        Class::Sse => {\n-            let vec_len = 1 + cls[*i+1..].iter().take_while(|&&c| c == Class::SseUp).count();\n+        Some(Class::Sse) => {\n+            let vec_len = 1 + cls[*i+1..].iter()\n+                .take_while(|&&c| c == Some(Class::SseUp))\n+                .count();\n             *i += vec_len;\n             Some(if vec_len == 1 {\n                 match size.bytes() {\n@@ -171,11 +159,11 @@ fn reg_component(cls: &[Class], i: &mut usize, size: Size) -> Option<Reg> {\n                 }\n             })\n         }\n-        c => bug!(\"reg_component: unhandled class {:?}\", c)\n+        Some(c) => bug!(\"reg_component: unhandled class {:?}\", c)\n     }\n }\n \n-fn cast_target(cls: &[Class], size: Size) -> CastTarget {\n+fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n     let mut i = 0;\n     let lo = reg_component(cls, &mut i, size).unwrap();\n     let offset = Size::from_bytes(8) * (i as u64);\n@@ -203,8 +191,8 @@ pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tc\n             Ok(ref cls) if is_arg => {\n                 for &c in cls {\n                     match c {\n-                        Class::Int => needed_int += 1,\n-                        Class::Sse => needed_sse += 1,\n+                        Some(Class::Int) => needed_int += 1,\n+                        Some(Class::Sse) => needed_sse += 1,\n                         _ => {}\n                     }\n                 }"}, {"sha": "4bf9513d64f92e3f9f72a1d5b0ce590c41266ca5", "filename": "src/test/run-pass/issue-38763.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39/src%2Ftest%2Frun-pass%2Fissue-38763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39/src%2Ftest%2Frun-pass%2Fissue-38763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-38763.rs?ref=cbeebc5b2cde6cb4f6cec9cd0cdfbd5d2c15dc39", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(i128_type)]\n+\n+#[repr(C)]\n+pub struct Foo(i128);\n+\n+#[no_mangle]\n+pub extern \"C\" fn foo(x: Foo) -> Foo { x }\n+\n+fn main() {\n+    foo(Foo(1));\n+}"}]}