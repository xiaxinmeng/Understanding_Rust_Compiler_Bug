{"sha": "62f1d68439dcfd509eaca29887afa97f22938373", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZjFkNjg0MzlkY2ZkNTA5ZWFjYTI5ODg3YWZhOTdmMjI5MzgzNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-09T10:06:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-09T10:06:42Z"}, "message": "auto merge of #12747 : huonw/rust/rustdoc-markdown, r=alexcrichton\n\nThis gives Rustdoc the ability to render our guides, tutorial and manual and modifies the those documents (minor modifications) and makefiles to achieve this.\r\n\r\nSee commits for more details (especially the makefile rewrite).", "tree": {"sha": "a178bd283545d0876d001e5adc58e26b32868019", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a178bd283545d0876d001e5adc58e26b32868019"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62f1d68439dcfd509eaca29887afa97f22938373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62f1d68439dcfd509eaca29887afa97f22938373", "html_url": "https://github.com/rust-lang/rust/commit/62f1d68439dcfd509eaca29887afa97f22938373", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62f1d68439dcfd509eaca29887afa97f22938373/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e959c8794b80ffad3abd50f773e5a613e13ff7b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e959c8794b80ffad3abd50f773e5a613e13ff7b2", "html_url": "https://github.com/rust-lang/rust/commit/e959c8794b80ffad3abd50f773e5a613e13ff7b2"}, {"sha": "b4815ad1baffb2603f7580cbdf1ac1b01879b767", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4815ad1baffb2603f7580cbdf1ac1b01879b767", "html_url": "https://github.com/rust-lang/rust/commit/b4815ad1baffb2603f7580cbdf1ac1b01879b767"}], "stats": {"total": 1714, "additions": 1035, "deletions": 679}, "files": [{"sha": "73813a4b7512b41a8a32e1d5f16c4b0f47f3ab1d", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -41,7 +41,6 @@ clean-misc:\n \t@$(call E, cleaning)\n \t$(Q)rm -f $(RUNTIME_OBJS) $(RUNTIME_DEF)\n \t$(Q)rm -f $(RUSTLLVM_LIB_OBJS) $(RUSTLLVM_OBJS_OBJS) $(RUSTLLVM_DEF)\n-\t$(Q)rm -Rf $(DOCS)\n \t$(Q)rm -Rf $(GENERATED)\n \t$(Q)rm -Rf tmp/*\n \t$(Q)rm -Rf rust-stage0-*.tar.bz2 $(PKG_NAME)-*.tar.gz $(PKG_NAME)-*.exe dist"}, {"sha": "70560d41b8d4cc3227286f75a432cc1c862bef35", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -92,6 +92,7 @@ TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n ################################################################################\n \n DOC_CRATES := $(filter-out rustc, $(filter-out syntax, $(CRATES)))\n+COMPILER_DOC_CRATES := rustc syntax\n \n # This macro creates some simple definitions for each crate being built, just\n # some munging of all of the parameters above."}, {"sha": "00832e0821690f1c0bd47a5e1249da123449de23", "filename": "mk/docs.mk", "status": "modified", "additions": 183, "deletions": 216, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -9,24 +9,96 @@\n # except according to those terms.\n \n ######################################################################\n-# Doc variables and rules\n+# The various pieces of standalone documentation: guides, tutorial,\n+# manual etc.\n+#\n+# The DOCS variable is their names (with no file extension).\n+#\n+# PDF_DOCS lists the targets for which PDF documentation should be\n+# build.\n+#\n+# RUSTDOC_FLAGS_xyz variables are extra arguments to pass to the\n+# rustdoc invocation for xyz.\n+#\n+# RUSTDOC_DEPS_xyz are extra dependencies for the rustdoc invocation\n+# on xyz.\n+#\n+# L10N_LANGS are the languages for which the docs have been\n+# translated.\n ######################################################################\n+DOCS := index tutorial guide-ffi guide-macros guide-lifetimes \\\n+\tguide-tasks guide-container guide-pointers \\\n+\tcomplement-cheatsheet guide-runtime \\\n+\trust rustdoc\n+\n+PDF_DOCS := tutorial rust\n+\n+RUSTDOC_DEPS_rust := doc/full-toc.inc\n+RUSTDOC_FLAGS_rust := --markdown-in-header=doc/full-toc.inc\n \n-DOCS :=\n-CDOCS :=\n-DOCS_L10N :=\n-HTML_DEPS := doc/\n+L10N_LANGS := ja\n \n-BASE_DOC_OPTS := --standalone --toc --number-sections\n-HTML_OPTS = $(BASE_DOC_OPTS) --to=html5 --section-divs --css=rust.css \\\n-    --include-before-body=doc/version_info.html \\\n-    --include-in-header=doc/favicon.inc --include-after-body=doc/footer.inc\n-TEX_OPTS = $(BASE_DOC_OPTS) --include-before-body=doc/version.md \\\n-    --from=markdown --include-before-body=doc/footer.tex --to=latex\n-EPUB_OPTS = $(BASE_DOC_OPTS) --to=epub\n+# Generally no need to edit below here.\n+\n+# The options are passed to the documentation generators.\n+RUSTDOC_HTML_OPTS = --markdown-css rust.css \\\n+\t--markdown-before-content=doc/version_info.html \\\n+\t--markdown-in-header=doc/favicon.inc --markdown-after-content=doc/footer.inc\n+\n+PANDOC_BASE_OPTS := --standalone --toc --number-sections\n+PANDOC_TEX_OPTS = $(PANDOC_BASE_OPTS) --include-before-body=doc/version.md \\\n+\t--from=markdown --include-before-body=doc/footer.tex --to=latex\n+PANDOC_EPUB_OPTS = $(PANDOC_BASE_OPTS) --to=epub\n+\n+# The rustdoc executable...\n+RUSTDOC_EXE = $(HBIN2_H_$(CFG_BUILD))/rustdoc$(X_$(CFG_BUILD))\n+# ...with rpath included in case --disable-rpath was provided to\n+# ./configure\n+RUSTDOC = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(RUSTDOC_EXE)\n \n D := $(S)src/doc\n \n+DOC_TARGETS :=\n+COMPILER_DOC_TARGETS :=\n+DOC_L10N_TARGETS :=\n+\n+# If NO_REBUILD is set then break the dependencies on rustdoc so we\n+# build the documentation without having to rebuild rustdoc.\n+ifeq ($(NO_REBUILD),)\n+HTML_DEPS := $(RUSTDOC_EXE)\n+else\n+HTML_DEPS :=\n+endif\n+\n+# Check for the various external utilities for the EPUB/PDF docs:\n+\n+ifeq ($(CFG_PDFLATEX),)\n+  $(info cfg: no pdflatex found, omitting doc/rust.pdf)\n+  NO_PDF_DOCS = 1\n+else\n+  ifeq ($(CFG_XETEX),)\n+    $(info cfg: no xetex found, disabling doc/rust.pdf)\n+    NO_PDF_DOCS = 1\n+  else\n+    ifeq ($(CFG_LUATEX),)\n+       $(info cfg: lacking luatex, disabling pdflatex)\n+       NO_PDF_DOCS = 1\n+\tendif\n+  endif\n+endif\n+\n+\n+ifeq ($(CFG_PANDOC),)\n+$(info cfg: no pandoc found, omitting PDF and EPUB docs)\n+ONLY_HTML_DOCS = 1\n+endif\n+\n+ifeq ($(CFG_NODE),)\n+$(info cfg: no node found, omitting PDF and EPUB docs)\n+ONLY_HTML_DOCS = 1\n+endif\n+\n+\n ######################################################################\n # Rust version\n ######################################################################\n@@ -46,7 +118,7 @@ doc/version_info.html: $(D)/version_info.html.template $(MKFILE_DEPS) \\\n GENERATED += doc/version.md doc/version_info.html\n \n ######################################################################\n-# Docs, from pandoc, rustdoc (which runs pandoc), and node\n+# Docs, from rustdoc and sometimes pandoc & node\n ######################################################################\n \n doc/:\n@@ -75,184 +147,85 @@ doc/footer.tex: $(D)/footer.tex | doc/\n \t@$(call E, cp: $@)\n \t$(Q)cp -a $< $@ 2> /dev/null\n \n-ifeq ($(CFG_PANDOC),)\n-  $(info cfg: no pandoc found, omitting docs)\n-  NO_DOCS = 1\n-endif\n+# The (english) documentation for each doc item.\n \n-ifeq ($(CFG_NODE),)\n-  $(info cfg: no node found, omitting docs)\n-  NO_DOCS = 1\n-endif\n+define DEF_SHOULD_BUILD_PDF_DOC\n+SHOULD_BUILD_PDF_DOC_$(1) = 1\n+endef\n+$(foreach docname,$(PDF_DOCS),$(eval $(call DEF_SHOULD_BUILD_PDF_DOC,$(docname))))\n+\n+define DEF_DOC\n+\n+# HTML (rustdoc)\n+DOC_TARGETS += doc/$(1).html\n+doc/$(1).html: $$(D)/$(1).md $$(HTML_DEPS) $$(RUSTDOC_DEPS_$(1)) | doc/\n+\t@$$(call E, rustdoc: $$@)\n+\t$$(RUSTDOC) $$(RUSTDOC_HTML_OPTS) $$(RUSTDOC_FLAGS_$(1)) $$<\n+\n+ifneq ($(ONLY_HTML_DOCS),1)\n+\n+# EPUB (pandoc directly)\n+DOC_TARGETS += doc/$(1).epub\n+doc/$(1).epub: $$(D)/$(1).md | doc/\n+\t@$$(call E, pandoc: $$@)\n+\t$$(Q)$$(CFG_NODE) $$(D)/prep.js --highlight $$< | \\\n+\t$$(CFG_PANDOC) $$(PANDOC_EPUB_OPTS) --output=$$@\n+\n+# PDF (md =(pandoc)=> tex =(pdflatex)=> pdf)\n+DOC_TARGETS += doc/$(1).tex\n+doc/$(1).tex: $$(D)/$(1).md doc/footer.tex doc/version.md | doc/\n+\t@$$(call E, pandoc: $$@)\n+\t$$(Q)$$(CFG_NODE) $$(D)/prep.js $$< | \\\n+\t$$(CFG_PANDOC) $$(PANDOC_TEX_OPTS) --output=$$@\n+\n+ifneq ($(NO_PDF_DOCS),1)\n+ifeq ($$(SHOULD_BUILD_PDF_DOC_$(1)),1)\n+DOC_TARGETS += doc/$(1).pdf\n+doc/$(1).pdf: doc/$(1).tex\n+\t@$$(call E, pdflatex: $$@)\n+\t$$(Q)$$(CFG_PDFLATEX) \\\n+\t-interaction=batchmode \\\n+\t-output-directory=doc \\\n+\t$$<\n+endif # SHOULD_BUILD_PDF_DOCS_$(1)\n+endif # NO_PDF_DOCS\n+\n+endif # ONLY_HTML_DOCS\n+\n+endef\n+\n+$(foreach docname,$(DOCS),$(eval $(call DEF_DOC,$(docname))))\n+\n+\n+# Localized documentation\n \n-ifneq ($(NO_DOCS),1)\n-\n-DOCS += doc/rust.html\n-doc/rust.html: $(D)/rust.md doc/full-toc.inc $(HTML_DEPS) | doc/\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --include-in-header=doc/full-toc.inc --output=$@\n-\n-DOCS += doc/rust.tex\n-doc/rust.tex: $(D)/rust.md doc/footer.tex doc/version.md | doc/\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js $< | \\\n-\t$(CFG_PANDOC) $(TEX_OPTS) --output=$@\n-\n-DOCS += doc/rust.epub\n-doc/rust.epub: $(D)/rust.md | doc/\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(EPUB_OPTS) --output=$@\n-\n-DOCS += doc/rustdoc.html\n-doc/rustdoc.html: $(D)/rustdoc.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/tutorial.html\n-doc/tutorial.html: $(D)/tutorial.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/tutorial.tex\n-doc/tutorial.tex: $(D)/tutorial.md doc/footer.tex doc/version.md\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js $< | \\\n-\t$(CFG_PANDOC) $(TEX_OPTS) --output=$@\n-\n-DOCS += doc/tutorial.epub\n-doc/tutorial.epub: $(D)/tutorial.md\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(EPUB_OPTS) --output=$@\n-\n-\n-DOCS_L10N += doc/l10n/ja/tutorial.html\n-doc/l10n/ja/tutorial.html: doc/l10n/ja/tutorial.md doc/version_info.html doc/rust.css\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight doc/l10n/ja/tutorial.md | \\\n-          $(CFG_PANDOC) --standalone --toc \\\n-           --section-divs --number-sections \\\n-           --from=markdown --to=html5 --css=../../rust.css \\\n-           --include-before-body=doc/version_info.html \\\n-           --output=$@\n-\n-# Complementary documentation\n+# FIXME: I (huonw) haven't actually been able to test properly, since\n+# e.g. (by default) I'm doing an out-of-tree build (#12763), but even\n+# adjusting for that, the files are too old(?) and are rejected by\n+# po4a.\n #\n-DOCS += doc/index.html\n-doc/index.html: $(D)/index.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/complement-lang-faq.html\n-doc/complement-lang-faq.html: $(D)/complement-lang-faq.md doc/full-toc.inc $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --include-in-header=doc/full-toc.inc --output=$@\n-\n-DOCS += doc/complement-project-faq.html\n-doc/complement-project-faq.html: $(D)/complement-project-faq.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/complement-cheatsheet.html\n-doc/complement-cheatsheet.html: $(D)/complement-cheatsheet.md doc/full-toc.inc $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --include-in-header=doc/full-toc.inc --output=$@\n-\n-DOCS += doc/complement-bugreport.html\n-doc/complement-bugreport.html: $(D)/complement-bugreport.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-# Guides\n-\n-DOCS += doc/guide-macros.html\n-doc/guide-macros.html: $(D)/guide-macros.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/guide-container.html\n-doc/guide-container.html: $(D)/guide-container.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/guide-ffi.html\n-doc/guide-ffi.html: $(D)/guide-ffi.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/guide-testing.html\n-doc/guide-testing.html: $(D)/guide-testing.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/guide-lifetimes.html\n-doc/guide-lifetimes.html: $(D)/guide-lifetimes.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/guide-tasks.html\n-doc/guide-tasks.html: $(D)/guide-tasks.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/guide-pointers.html\n-doc/guide-pointers.html: $(D)/guide-pointers.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-DOCS += doc/guide-runtime.html\n-doc/guide-runtime.html: $(D)/guide-runtime.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n-  ifeq ($(CFG_PDFLATEX),)\n-    $(info cfg: no pdflatex found, omitting doc/rust.pdf)\n-  else\n-    ifeq ($(CFG_XETEX),)\n-      $(info cfg: no xetex found, disabling doc/rust.pdf)\n-    else\n-      ifeq ($(CFG_LUATEX),)\n-        $(info cfg: lacking luatex, disabling pdflatex)\n-      else\n-\n-DOCS += doc/rust.pdf\n-doc/rust.pdf: doc/rust.tex\n-\t@$(call E, pdflatex: $@)\n-\t$(Q)$(CFG_PDFLATEX) \\\n-        -interaction=batchmode \\\n-        -output-directory=doc \\\n-        $<\n-\n-DOCS += doc/tutorial.pdf\n-doc/tutorial.pdf: doc/tutorial.tex\n-\t@$(call E, pdflatex: $@)\n-\t$(Q)$(CFG_PDFLATEX) \\\n-        -interaction=batchmode \\\n-        -output-directory=doc \\\n-        $<\n-\n-      endif\n-    endif\n-  endif\n+# As such, I've attempted to get it working as much as possible (and\n+# switching from pandoc to rustdoc), but preserving the old behaviour\n+# (e.g. only running on the tutorial)\n+.PHONY: l10n-mds\n+l10n-mds: $(D)/po4a.conf \\\n+\t\t$(foreach lang,$(L10N_LANG),$(D)/po/$(lang)/*.md.po)\n+\t$(warning WARNING: localized documentation is experimental)\n+\tpo4a --copyright-holder=\"The Rust Project Developers\" \\\n+\t\t--package-name=\"Rust\" \\\n+\t\t--package-version=\"$(CFG_RELEASE)\" \\\n+\t\t-M UTF-8 -L UTF-8 \\\n+\t\t$(D)/po4a.conf\n+\n+define DEF_L10N_DOC\n+DOC_L10N_TARGETS += doc/l10n/$(1)/$(2).html\n+doc/l10n/$(1)/$(2).html: l10n-mds $$(HTML_DEPS) $$(RUSTDOC_DEPS_$(2))\n+\t@$$(call E, rustdoc: $$@)\n+\t$$(RUSTDOC) $$(RUSTDOC_HTML_OPTS) $$(RUSTDOC_FLAGS_$(1)) doc/l10n/$(1)/$(2).md\n+endef\n+\n+$(foreach lang,$(L10N_LANGS),$(eval $(call DEF_L10N_DOC,$(lang),tutorial)))\n \n-endif # No pandoc / node\n \n ######################################################################\n # LLnextgen (grammar analysis from refman)\n@@ -278,50 +251,44 @@ endif\n # Rustdoc (libstd/extra)\n ######################################################################\n \n-# The rustdoc executable, rpath included in case --disable-rpath was provided to\n-# ./configure\n-RUSTDOC = $(HBIN2_H_$(CFG_BUILD))/rustdoc$(X_$(CFG_BUILD))\n \n # The library documenting macro\n #\n # $(1) - The crate name (std/extra)\n #\n # Passes --cfg stage2 to rustdoc because it uses the stage2 librustc.\n-define libdoc\n-doc/$(1)/index.html:\t\t\t\t\t\t\t    \\\n-\t    $$(CRATEFILE_$(1))\t\t\t\t\t\t    \\\n-\t    $$(RSINPUTS_$(1))\t\t\t\t\t\t    \\\n-\t    $$(RUSTDOC)\t\t\t\t\t\t\t    \\\n-\t    $$(foreach dep,$$(RUST_DEPS_$(1)),\t\t\t\t    \\\n+define DEF_LIB_DOC\n+\n+# If NO_REBUILD is set then break the dependencies on rustdoc so we\n+# build crate documentation without having to rebuild rustdoc.\n+ifeq ($(NO_REBUILD),)\n+LIB_DOC_DEP_$(1) = \\\n+\t$$(CRATEFILE_$(1)) \\\n+\t$$(RSINPUTS_$(1)) \\\n+\t$$(RUSTDOC_EXE) \\\n+\t$$(foreach dep,$$(RUST_DEPS_$(1)), \\\n \t\t$$(TLIB2_T_$(CFG_BUILD)_H_$(CFG_BUILD))/stamp.$$(dep))\n-\t@$$(call E, rustdoc: $$@)\n-\t$$(Q)$$(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $$(RUSTDOC) \\\n-\t    --cfg stage2 $$<\n+else\n+LIB_DOC_DEP_$(1) = $$(CRATEFILE_$(1)) $$(RSINPUTS_$(1))\n+endif\n \n+$(2) += doc/$(1)/index.html\n+doc/$(1)/index.html: $$(LIB_DOC_DEP_$(1))\n+\t@$$(call E, rustdoc $$@)\n+\t$$(Q)$$(RUSTDOC) --cfg stage2 $$<\n endef\n \n-$(foreach crate,$(CRATES),$(eval $(call libdoc,$(crate))))\n-\n-DOCS += $(DOC_CRATES:%=doc/%/index.html)\n-\n-CDOCS += doc/rustc/index.html\n-CDOCS += doc/syntax/index.html\n+$(foreach crate,$(DOC_CRATES),$(eval $(call DEF_LIB_DOC,$(crate),DOC_TARGETS)))\n+$(foreach crate,$(COMPILER_DOC_CRATES),$(eval $(call DEF_LIB_DOC,$(crate),COMPILER_DOC_TARGETS)))\n \n ifdef CFG_DISABLE_DOCS\n   $(info cfg: disabling doc build (CFG_DISABLE_DOCS))\n-  DOCS :=\n+  DOC_TARGETS :=\n endif\n \n-docs: $(DOCS)\n-compiler-docs: $(CDOCS)\n-\n-docs-l10n: $(DOCS_L10N)\n+docs: $(DOC_TARGETS)\n+compiler-docs: $(COMPILER_DOC_TARGETS)\n \n-doc/l10n/%.md: doc/po/%.md.po doc/po4a.conf\n-\tpo4a --copyright-holder=\"The Rust Project Developers\" \\\n-\t     --package-name=\"Rust\" \\\n-\t     --package-version=\"$(CFG_RELEASE)\" \\\n-\t     -M UTF-8 -L UTF-8 \\\n-\t     doc/po4a.conf\n+docs-l10n: $(DOC_L10N_TARGETS)\n \n .PHONY: docs-l10n"}, {"sha": "23433a4705a39dc437fc3c134fc87871adddaae6", "filename": "mk/tests.mk", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -19,12 +19,6 @@ TEST_DOC_CRATES = $(DOC_CRATES)\n TEST_HOST_CRATES = $(HOST_CRATES)\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n-# Markdown files under doc/ that should have their code extracted and run\n-DOC_TEST_NAMES = tutorial guide-ffi guide-macros guide-lifetimes \\\n-                 guide-tasks guide-container guide-pointers \\\n-                 complement-cheatsheet guide-runtime \\\n-                 rust\n-\n ######################################################################\n # Environment configuration\n ######################################################################\n@@ -315,10 +309,10 @@ endif\n \n check-stage$(1)-T-$(2)-H-$(3)-doc-crates-exec: \\\n         $$(foreach crate,$$(TEST_DOC_CRATES), \\\n-           check-stage$(1)-T-$(2)-H-$(3)-doc-$$(crate)-exec)\n+           check-stage$(1)-T-$(2)-H-$(3)-doc-crate-$$(crate)-exec)\n \n check-stage$(1)-T-$(2)-H-$(3)-doc-exec: \\\n-        $$(foreach docname,$$(DOC_TEST_NAMES), \\\n+        $$(foreach docname,$$(DOCS), \\\n            check-stage$(1)-T-$(2)-H-$(3)-doc-$$(docname)-exec)\n \n check-stage$(1)-T-$(2)-H-$(3)-pretty-exec: \\\n@@ -662,87 +656,91 @@ $(foreach host,$(CFG_HOST), \\\n    $(foreach pretty-name,$(PRETTY_NAMES), \\\n     $(eval $(call DEF_RUN_PRETTY_TEST,$(stage),$(target),$(host),$(pretty-name)))))))\n \n-define DEF_RUN_DOC_TEST\n-\n-DOC_TEST_ARGS$(1)-T-$(2)-H-$(3)-doc-$(4) := \\\n-        $$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3))\t\\\n-        --src-base $(3)/test/doc-$(4)/\t\\\n-        --build-base $(3)/test/doc-$(4)/\t\\\n-        --mode run-pass\n-\n-check-stage$(1)-T-$(2)-H-$(3)-doc-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4))\n \n-$$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4)): \\\n-\t        $$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\\\n-                doc-$(4)-extract$(3)\n-\t@$$(call E, run doc-$(4) [$(2)]: $$<)\n-\t$$(Q)$$(call CFG_RUN_CTEST_$(2),$(1),$$<,$(3)) \\\n-                $$(DOC_TEST_ARGS$(1)-T-$(2)-H-$(3)-doc-$(4)) \\\n-\t\t--logfile $$(call TEST_LOG_FILE,$(1),$(2),$(3),doc-$(4)) \\\n-                && touch $$@\n+######################################################################\n+# Crate & freestanding documentation tests\n+######################################################################\n \n+define DEF_RUSTDOC\n+RUSTDOC_EXE_$(1)_T_$(2)_H_$(3) := $$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3))\n+RUSTDOC_$(1)_T_$(2)_H_$(3) := $$(RPATH_VAR$(1)_T_$(2)_H_$(3)) $$(RUSTDOC_EXE_$(1)_T_$(2)_H_$(3))\n endef\n \n $(foreach host,$(CFG_HOST), \\\n  $(foreach target,$(CFG_TARGET), \\\n   $(foreach stage,$(STAGES), \\\n-   $(foreach docname,$(DOC_TEST_NAMES), \\\n-    $(eval $(call DEF_RUN_DOC_TEST,$(stage),$(target),$(host),$(docname)))))))\n+   $(eval $(call DEF_RUSTDOC,$(stage),$(target),$(host))))))\n \n-define DEF_CRATE_DOC_TEST\n+# Freestanding\n+\n+define DEF_DOC_TEST\n+\n+check-stage$(1)-T-$(2)-H-$(3)-doc-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4))\n \n # If NO_REBUILD is set then break the dependencies on everything but\n-# the source files so we can test crate documentation without\n-# rebuilding any of the parent crates.\n+# the source files so we can test documentation without rebuilding\n+# rustdoc etc.\n ifeq ($(NO_REBUILD),)\n DOCTESTDEP_$(1)_$(2)_$(3)_$(4) = \\\n+\t$$(D)/$(4).md \\\n \t$$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\t\t\\\n-\t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4))\t\t\\\n-\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3))\n+\t$$(RUSTDOC_EXE_$(1)_T_$(2)_H_$(3))\n else\n-DOCTESTDEP_$(1)_$(2)_$(3)_$(4) = $$(RSINPUTS_$(4))\n+DOCTESTDEP_$(1)_$(2)_$(3)_$(4) = $$(D)/$(4).md\n endif\n \n-check-stage$(1)-T-$(2)-H-$(3)-doc-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4))\n-\n ifeq ($(2),$$(CFG_BUILD))\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4)): $$(DOCTESTDEP_$(1)_$(2)_$(3)_$(4))\n \t@$$(call E, run doc-$(4) [$(2)])\n-\t$$(Q)$$(RPATH_VAR$(1)_T_$(2)_H_$(3)) \\\n-\t\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) --test \\\n-\t    \t$$(CRATEFILE_$(4)) --test-args \"$$(TESTARGS)\" && touch $$@\n+\t$$(Q)$$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --test $$< --test-args \"$$(TESTARGS)\" && touch $$@\n else\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4)):\n \ttouch $$@\n endif\n-\n endef\n \n $(foreach host,$(CFG_HOST), \\\n  $(foreach target,$(CFG_TARGET), \\\n   $(foreach stage,$(STAGES), \\\n-   $(foreach crate,$(TEST_DOC_CRATES), \\\n-    $(eval $(call DEF_CRATE_DOC_TEST,$(stage),$(target),$(host),$(crate)))))))\n+   $(foreach docname,$(DOCS), \\\n+    $(eval $(call DEF_DOC_TEST,$(stage),$(target),$(host),$(docname)))))))\n \n-######################################################################\n-# Extracting tests for docs\n-######################################################################\n+# Crates\n+\n+define DEF_CRATE_DOC_TEST\n \n-EXTRACT_TESTS := \"$(CFG_PYTHON)\" $(S)src/etc/extract-tests.py\n+# If NO_REBUILD is set then break the dependencies on everything but\n+# the source files so we can test crate documentation without\n+# rebuilding any of the parent crates.\n+ifeq ($(NO_REBUILD),)\n+CRATEDOCTESTDEP_$(1)_$(2)_$(3)_$(4) = \\\n+\t$$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\t\t\\\n+\t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4))\t\t\\\n+\t$$(RUSTDOC_EXE_$(1)_T_$(2)_H_$(3))\n+else\n+CRATEDOCTESTDEP_$(1)_$(2)_$(3)_$(4) = $$(RSINPUTS_$(4))\n+endif\n \n-define DEF_DOC_TEST_HOST\n+check-stage$(1)-T-$(2)-H-$(3)-doc-crate-$(4)-exec: \\\n+\t$$(call TEST_OK_FILE,$(1),$(2),$(3),doc-crate-$(4))\n \n-doc-$(2)-extract$(1):\n-\t@$$(call E, extract: $(2) tests)\n-\t$$(Q)rm -f $(1)/test/doc-$(2)/*.rs\n-\t$$(Q)$$(EXTRACT_TESTS) $$(D)/$(2).md $(1)/test/doc-$(2)\n+ifeq ($(2),$$(CFG_BUILD))\n+$$(call TEST_OK_FILE,$(1),$(2),$(3),doc-crate-$(4)): $$(CRATEDOCTESTDEP_$(1)_$(2)_$(3)_$(4))\n+\t@$$(call E, run doc-crate-$(4) [$(2)])\n+\t$$(Q)$$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --test \\\n+\t    \t$$(CRATEFILE_$(4)) --test-args \"$$(TESTARGS)\" && touch $$@\n+else\n+$$(call TEST_OK_FILE,$(1),$(2),$(3),doc-crate-$(4)):\n+\ttouch $$@\n+endif\n \n endef\n \n $(foreach host,$(CFG_HOST), \\\n- $(foreach docname,$(DOC_TEST_NAMES), \\\n-  $(eval $(call DEF_DOC_TEST_HOST,$(host),$(docname)))))\n-\n+ $(foreach target,$(CFG_TARGET), \\\n+  $(foreach stage,$(STAGES), \\\n+   $(foreach crate,$(TEST_DOC_CRATES), \\\n+    $(eval $(call DEF_CRATE_DOC_TEST,$(stage),$(target),$(host),$(crate)))))))\n \n ######################################################################\n # Shortcut rules\n@@ -751,7 +749,7 @@ $(foreach host,$(CFG_HOST), \\\n TEST_GROUPS = \\\n \tcrates \\\n \t$(foreach crate,$(TEST_CRATES),$(crate)) \\\n-\t$(foreach crate,$(TEST_DOC_CRATES),doc-$(crate)) \\\n+\t$(foreach crate,$(TEST_DOC_CRATES),doc-crate-$(crate)) \\\n \trpass \\\n \trpass-full \\\n \trfail \\\n@@ -762,7 +760,7 @@ TEST_GROUPS = \\\n \tdebuginfo \\\n \tcodegen \\\n \tdoc \\\n-\t$(foreach docname,$(DOC_TEST_NAMES),doc-$(docname)) \\\n+\t$(foreach docname,$(DOCS),doc-$(docname)) \\\n \tpretty \\\n \tpretty-rpass \\\n \tpretty-rpass-full \\\n@@ -830,10 +828,10 @@ $(foreach stage,$(STAGES), \\\n    $(eval $(call DEF_CHECK_FOR_STAGE_AND_HOSTS_AND_GROUP,$(stage),$(host),$(group))))))\n \n define DEF_CHECK_DOC_FOR_STAGE\n-check-stage$(1)-docs: $$(foreach docname,$$(DOC_TEST_NAMES),\\\n+check-stage$(1)-docs: $$(foreach docname,$$(DOCS),\\\n                        check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-$$(docname)) \\\n-                     $$(foreach crate,$$(DOC_CRATE_NAMES),\\\n-                       check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-$$(crate))\n+                     $$(foreach crate,$$(TEST_DOC_CRATES),\\\n+                       check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-crate-$$(crate))\n endef\n \n $(foreach stage,$(STAGES), \\"}, {"sha": "5b38ef5645e2b127afb5a530f0f0f6fa4bac81d9", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -135,7 +135,7 @@ For simplicity, we do not plan to do so. Implementing automatic semicolon insert\n \n **Short answer** set the RUST_LOG environment variable to the name of your source file, sans extension.\n \n-```sh\n+``` {.sh .notrust}\n rustc hello.rs\n export RUST_LOG=hello\n ./hello"}, {"sha": "b9cab358e909da0c9018a82b26329a8127a4cd23", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -263,6 +263,7 @@ to the C library and afterwards be invoked from there.\n A basic example is:\n \n Rust code:\n+\n ~~~~ {.ignore}\n extern fn callback(a:i32) {\n     println!(\"I'm called from C with value {0}\", a);\n@@ -283,7 +284,8 @@ fn main() {\n ~~~~\n \n C code:\n-~~~~ {.ignore}\n+\n+~~~~ {.notrust}\n typedef void (*rust_callback)(int32_t);\n rust_callback cb;\n \n@@ -314,6 +316,7 @@ the notification. This will allow the callback to unsafely access the\n referenced Rust object.\n \n Rust code:\n+\n ~~~~ {.ignore}\n \n struct RustObject {\n@@ -346,7 +349,8 @@ fn main() {\n ~~~~\n \n C code:\n-~~~~ {.ignore}\n+\n+~~~~ {.notrust}\n typedef void (*rust_callback)(int32_t);\n void* cb_target;\n rust_callback cb;"}, {"sha": "69596b6e30475bfd6ec379a62d6e8e185225dbda", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -205,7 +205,7 @@ struct X { f: int }\n fn example1() {\n     let mut x = X { f: 3 };\n     let y = &mut x.f;  // -+ L\n-    ...                //  |\n+    // ...             //  |\n }                      // -+\n ~~~\n \n@@ -221,7 +221,7 @@ The situation gets more complex when borrowing data inside heap boxes:\n fn example2() {\n     let mut x = @X { f: 3 };\n     let y = &x.f;      // -+ L\n-    ...                //  |\n+    // ...             //  |\n }                      // -+\n ~~~\n \n@@ -251,7 +251,7 @@ fn example2() {\n     let mut x = @X {f: 3};\n     let x1 = x;\n     let y = &x1.f;     // -+ L\n-    ...                //  |\n+    // ...             //  |\n }                      // -+\n ~~~\n \n@@ -282,7 +282,7 @@ fn example3() -> int {\n         return *y;         //  |\n     }                      // -+\n     x = ~Foo {f: 4};\n-    ...\n+    // ...\n # return 0;\n }\n ~~~"}, {"sha": "1a01fad5da2144e71d7fbc6d3b469cdeb93993fa", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -185,6 +185,7 @@ amount.\n For example:\n \n ~~~\n+# #[allow(unused_imports)];\n extern crate test;\n \n use std::vec;\n@@ -201,6 +202,8 @@ fn initialise_a_vector(b: &mut BenchHarness) {\n     b.iter(|| {vec::from_elem(1024, 0u64);} );\n     b.bytes = 1024 * 8;\n }\n+\n+# fn main() {}\n ~~~\n \n The benchmark runner will calibrate measurement of the benchmark\n@@ -244,6 +247,7 @@ recognize that some calculation has no external effects and remove\n it entirely.\n \n ~~~\n+# #[allow(unused_imports)];\n extern crate test;\n use test::BenchHarness;\n \n@@ -253,6 +257,8 @@ fn bench_xor_1000_ints(bh: &mut BenchHarness) {\n             range(0, 1000).fold(0, |old, new| old ^ new);\n         });\n }\n+\n+# fn main() {}\n ~~~\n \n gives the following results\n@@ -271,6 +277,7 @@ cannot remove the computation entirely. This could be done for the\n example above by adjusting the `bh.iter` call to\n \n ~~~\n+# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let bh = X;\n bh.iter(|| range(0, 1000).fold(0, |old, new| old ^ new))\n ~~~\n \n@@ -281,9 +288,12 @@ forces it to consider any argument as used.\n ~~~\n extern crate test;\n \n+# fn main() {\n+# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let bh = X;\n bh.iter(|| {\n         test::black_box(range(0, 1000).fold(0, |old, new| old ^ new));\n     });\n+# }\n ~~~\n \n Neither of these read or modify the value, and are very cheap for"}, {"sha": "8dacf0e4de886f4cbaf6958ccd69cb117c06ef43", "filename": "src/doc/index.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -25,6 +25,8 @@ li {list-style-type: none; }\n \n * [The standard library, `std`](std/index.html)\n \n+<!-- force the two lists to be separate -->\n+\n * [The `arena` allocation library](arena/index.html)\n * [The `collections` library](collections/index.html)\n * [The `extra` library of extra stuff](extra/index.html)"}, {"sha": "26681adad6d78bff14ada65bb7eed8f304153da2", "filename": "src/doc/rust.css", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -142,25 +142,18 @@ pre code {\n }\n \n /* Code highlighting */\n-.cm-s-default span.cm-keyword {color: #8959A8;}\n-.cm-s-default span.cm-atom {color: #219;}\n-.cm-s-default span.cm-number {color: #3E999F;}\n-.cm-s-default span.cm-def {color: #4271AE;}\n-/*.cm-s-default span.cm-variable {color: #C82829;}*/\n-.cm-s-default span.cm-variable-2 {color: #6F906C;}\n-.cm-s-default span.cm-variable-3 {color: #B76514;}\n-.cm-s-default span.cm-property {color: black;}\n-.cm-s-default span.cm-operator {color: black;}\n-.cm-s-default span.cm-comment {color: #8E908C;}\n-.cm-s-default span.cm-string {color: #718C00;}\n-.cm-s-default span.cm-string-2 {color: #866544;}\n-.cm-s-default span.cm-meta {color: #555;}\n-/*.cm-s-default span.cm-error {color: #F00;}*/\n-.cm-s-default span.cm-qualifier {color: #555;}\n-.cm-s-default span.cm-builtin {color: #30A;}\n-.cm-s-default span.cm-bracket {color: #CC7;}\n-.cm-s-default span.cm-tag {color: #C82829;}\n-.cm-s-default span.cm-attribute {color: #00C;}\n+pre.rust .kw { color: #8959A8; }\n+pre.rust .kw-2, pre.rust .prelude-ty { color: #4271AE; }\n+pre.rust .number { color: #718C00; }\n+pre.rust .self { color: #C13928; }\n+pre.rust .boolval { color: #C13928; }\n+pre.rust .prelude-val { color: #C13928; }\n+pre.rust .comment { color: #8E908C; }\n+pre.rust .doccomment { color: #4D4D4C; }\n+pre.rust .macro, pre.rust .macro-nonterminal { color: #3E999f; }\n+pre.rust .string { color: #718C00; }\n+pre.rust .lifetime { color: #C13928; }\n+pre.rust .attribute, pre.rust .attribute .ident { color: #C82829; }\n \n /* The rest\n    ========================================================================== */"}, {"sha": "d1cef9a0614771903ad98eafcf683914b8b3b88f", "filename": "src/doc/rust.md", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -60,7 +60,7 @@ dialect of EBNF supported by common automated LL(k) parsing tools such as\n `llgen`, rather than the dialect given in ISO 14977. The dialect can be\n defined self-referentially as follows:\n \n-~~~~ {.ebnf .notation}\n+~~~~ {.notrust .ebnf .notation}\n grammar : rule + ;\n rule    : nonterminal ':' productionrule ';' ;\n productionrule : production [ '|' production ] * ;\n@@ -150,7 +150,7 @@ Some productions are defined by exclusion of particular Unicode characters:\n \n ## Comments\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n comment : block_comment | line_comment ;\n block_comment : \"/*\" block_comment_body * '*' + '/' ;\n block_comment_body : (block_comment | character) * ;\n@@ -171,7 +171,7 @@ Non-doc comments are interpreted as a form of whitespace.\n \n ## Whitespace\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n whitespace : [ whitespace_char | comment ] + ;\n ~~~~\n@@ -188,7 +188,7 @@ with any other legal whitespace element, such as a single space character.\n \n ## Tokens\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n simple_token : keyword | unop | binop ;\n token : simple_token | ident | literal | symbol | whitespace token ;\n ~~~~\n@@ -202,7 +202,7 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n The keywords are the following strings:\n \n-~~~~ {.keyword}\n+~~~~ {.notrust .keyword}\n as\n break\n do\n@@ -230,13 +230,13 @@ evaluates to, rather than referring to it by name or some other evaluation\n rule. A literal is a form of constant expression, so is evaluated (primarily)\n at compile time.\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n literal : string_lit | char_lit | num_lit ;\n ~~~~\n \n #### Character and string literals\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n char_lit : '\\x27' char_body '\\x27' ;\n string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n \n@@ -318,7 +318,7 @@ r##\"foo #\"# bar\"##;                // foo #\"# bar\n \n #### Number literals\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n num_lit : nonzero_dec [ dec_digit | '_' ] * num_suffix ?\n         | '0' [       [ dec_digit | '_' ] * num_suffix ?\n               | 'b'   [ '1' | '0' | '_' ] + int_suffix ?\n@@ -416,7 +416,7 @@ The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n symbol : \"::\" \"->\"\n        | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n        | ',' | ';' ;\n@@ -431,7 +431,7 @@ operators](#binary-operator-expressions), or [keywords](#keywords).\n \n ## Paths\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n expr_path : ident [ \"::\" expr_path_tail ] + ;\n expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n                | expr_path ;\n@@ -495,7 +495,7 @@ All of the above extensions are expressions with values.\n \n ## Macros\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')'\n macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';'\n matcher : '(' matcher * ')' | '[' matcher * ']'\n@@ -635,7 +635,7 @@ each of which may have some number of [attributes](#attributes) attached to it.\n \n ## Items\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n item : mod_item | fn_item | type_item | struct_item | enum_item\n      | static_item | trait_item | impl_item | extern_block ;\n ~~~~\n@@ -683,7 +683,7 @@ That is, Rust has no notion of type abstraction: there are no first-class \"foral\n \n ### Modules\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n mod : [ view_item | item ] * ;\n ~~~~\n@@ -703,15 +703,15 @@ An example of a module:\n mod math {\n     type Complex = (f64, f64);\n     fn sin(f: f64) -> f64 {\n-        ...\n+        /* ... */\n # fail!();\n     }\n     fn cos(f: f64) -> f64 {\n-        ...\n+        /* ... */\n # fail!();\n     }\n     fn tan(f: f64) -> f64 {\n-        ...\n+        /* ... */\n # fail!();\n     }\n }\n@@ -751,7 +751,7 @@ mod task {\n \n #### View items\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n view_item : extern_crate_decl | use_decl ;\n ~~~~\n \n@@ -764,7 +764,7 @@ There are several kinds of view item:\n \n ##### Extern crate declarations\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n extern_crate_decl : \"extern\" \"crate\" ident [ '(' link_attrs ')' ] ? [ '=' string_lit ] ? ;\n link_attrs : link_attr [ ',' link_attrs ] + ;\n link_attr : ident '=' literal ;\n@@ -796,7 +796,7 @@ extern crate foo = \"some/where/rust-foo#foo:1.0\"; // a full package ID for exter\n \n ##### Use declarations\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n use_decl : \"pub\" ? \"use\" ident [ '=' path\n                           | \"::\" path_glob ] ;\n \n@@ -1205,7 +1205,7 @@ whereas `Dog` is simply called an enum variant.\n \n ### Static items\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n static_item : \"static\" ident ':' type '=' expr ';' ;\n ~~~~\n \n@@ -1447,7 +1447,7 @@ Implementation parameters are written after the `impl` keyword.\n # trait Seq<T> { }\n \n impl<T> Seq<T> for ~[T] {\n-   ...\n+   /* ... */\n }\n impl Seq<bool> for u32 {\n    /* Treat the integer as a sequence of bits */\n@@ -1456,7 +1456,7 @@ impl Seq<bool> for u32 {\n \n ### External blocks\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n extern_block_item : \"extern\" '{' extern_block '} ;\n extern_block : [ foreign_fn ] * ;\n ~~~~\n@@ -1682,7 +1682,7 @@ import public items from their destination, not private items.\n \n ## Attributes\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n attribute : '#' '[' attr_list ']' ;\n attr_list : attr [ ',' attr_list ]*\n attr : ident [ '=' literal\n@@ -2226,7 +2226,7 @@ declaring a function-local item.\n \n #### Slot declarations\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' ] expr ;\n ~~~~\n@@ -2326,7 +2326,7 @@ values.\n \n ### Structure expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n struct_expr : expr_path '{' ident ':' expr\n                       [ ',' ident ':' expr ] *\n                       [ \"..\" expr ] '}' |\n@@ -2380,7 +2380,7 @@ Point3d {y: 0, z: 10, .. base};\n \n ### Block expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n block_expr : '{' [ view_item ] *\n                  [ stmt ';' | item ] *\n                  [ expr ] '}'\n@@ -2398,7 +2398,7 @@ of the block are that of the expression itself.\n \n ### Method-call expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n method_call_expr : expr '.' ident paren_expr_list ;\n ~~~~\n \n@@ -2409,17 +2409,18 @@ or dynamically dispatching if the left-hand-side expression is an indirect [obje\n \n ### Field expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n field_expr : expr '.' ident\n ~~~~\n \n A _field expression_ consists of an expression followed by a single dot and an identifier,\n when not immediately followed by a parenthesized expression-list (the latter is a [method call expression](#method-call-expressions)).\n A field expression denotes a field of a [structure](#structure-types).\n \n-~~~~ {.field}\n+~~~~ {.ignore .field}\n myrecord.myfield;\n-{a: 10, b: 20}.a;\n+foo().x;\n+(Struct {a: 10, b: 20}).a;\n ~~~~\n \n A field access on a record is an [lvalue](#lvalues-rvalues-and-temporaries) referring to the value of that field.\n@@ -2430,7 +2431,7 @@ it is automatically dereferenced to make the field access possible.\n \n ### Vector expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n vec_expr : '[' \"mut\" ? vec_elems? ']'\n \n vec_elems : [expr [',' expr]*] | [expr ',' \"..\" expr]\n@@ -2452,7 +2453,7 @@ as a [literal](#literals) or a [static item](#static-items).\n \n ### Index expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n idx_expr : expr '[' expr ']'\n ~~~~\n \n@@ -2504,7 +2505,7 @@ before the expression they apply to.\n \n ### Binary operator expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n binop_expr : expr binop expr ;\n ~~~~\n \n@@ -2645,7 +2646,7 @@ Any such expression always has the [`unit`](#primitive-types) type.\n The precedence of Rust binary operators is ordered as follows, going\n from strong to weak:\n \n-~~~~ {.precedence}\n+~~~~ {.notrust .precedence}\n * / %\n as\n + -\n@@ -2669,7 +2670,7 @@ An expression enclosed in parentheses evaluates to the result of the enclosed\n expression.  Parentheses can be used to explicitly specify evaluation order\n within an expression.\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n paren_expr : '(' expr ')' ;\n ~~~~\n \n@@ -2682,7 +2683,7 @@ let x = (2 + 3) * 4;\n \n ### Call expressions\n \n-~~~~ {.abnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n expr_list : [ expr [ ',' expr ]* ] ? ;\n paren_expr_list : '(' expr_list ')' ;\n call_expr : expr paren_expr_list ;\n@@ -2705,7 +2706,7 @@ let pi: Option<f32> = FromStr::from_str(\"3.14\");\n \n ### Lambda expressions\n \n-~~~~ {.abnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n ident_list : [ ident [ ',' ident ]* ] ? ;\n lambda_expr : '|' ident_list '|' expr ;\n ~~~~\n@@ -2748,7 +2749,7 @@ ten_times(|j| println!(\"hello, {}\", j));\n \n ### While loops\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n while_expr : \"while\" expr '{' block '}' ;\n ~~~~\n \n@@ -2774,7 +2775,7 @@ The keyword `loop` in Rust appears both in _loop expressions_ and in _continue e\n A loop expression denotes an infinite loop;\n see [Continue expressions](#continue-expressions) for continue expressions.\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n ~~~~\n \n@@ -2785,7 +2786,7 @@ See [Break expressions](#break-expressions).\n \n ### Break expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n break_expr : \"break\" [ lifetime ];\n ~~~~\n \n@@ -2798,7 +2799,7 @@ but must enclose it.\n \n ### Continue expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n continue_expr : \"loop\" [ lifetime ];\n ~~~~\n \n@@ -2817,7 +2818,7 @@ A `loop` expression is only permitted in the body of a loop.\n \n ### For expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n for_expr : \"for\" pat \"in\" expr '{' block '}' ;\n ~~~~\n \n@@ -2851,7 +2852,7 @@ for i in range(0u, 256) {\n \n ### If expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n if_expr : \"if\" expr '{' block '}'\n           else_tail ? ;\n \n@@ -2872,7 +2873,7 @@ then any `else` block is executed.\n \n ### Match expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n match_expr : \"match\" expr '{' match_arm [ '|' match_arm ] * '}' ;\n \n match_arm : match_pat '=>' [ expr \",\" | '{' block '}' ] ;\n@@ -3063,7 +3064,7 @@ let message = match maybe_digit {\n \n ### Return expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n return_expr : \"return\" expr ? ;\n ~~~~\n \n@@ -3895,7 +3896,7 @@ fn main() {\n \n These four log levels correspond to levels 1-4, as controlled by `RUST_LOG`:\n \n-```bash\n+``` {.bash .notrust}\n $ RUST_LOG=rust=3 ./rust\n This is an error log\n This is a warn log"}, {"sha": "3359cd4f40d9552af25b1b7c865f6d7f625abf5c", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 79, "deletions": 39, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -20,6 +20,7 @@ comments\":\n //! the crate index page. The ! makes it apply to the parent of the comment,\n //! rather than what follows).\n \n+# mod workaround_the_outer_function_rustdoc_inserts {\n /// Widgets are very common (this is a doc comment, and will show up on\n /// Widget's documentation).\n pub struct Widget {\n@@ -36,6 +37,7 @@ pub fn recalibrate() {\n \t//! `recalibrate`).\n \t/* ... */\n }\n+# }\n ~~~\n \n Doc comments are markdown, and are currently parsed with the\n@@ -94,7 +96,7 @@ source code.\n \n To test documentation, the `--test` argument is passed to rustdoc:\n \n-~~~\n+~~~ {.notrust}\n rustdoc --test crate.rs\n ~~~\n \n@@ -105,56 +107,68 @@ code blocks as testable-by-default. In order to not run a test over a block of\n code, the `ignore` string can be added to the three-backtick form of markdown\n code block.\n \n-~~~\n-```\n-// This is a testable code block\n-```\n+    /**\n+    # nested codefences confuse sundown => indentation + comment to\n+    #  avoid failing tests\n+    ```\n+    // This is a testable code block\n+    ```\n \n-```ignore\n-// This is not a testable code block\n-```\n+    ```ignore\n+    // This is not a testable code block\n+    ```\n \n-    // This is a testable code block (4-space indent)\n-~~~\n+        // This is a testable code block (4-space indent)\n+    */\n+    # fn foo() {}\n \n You can specify that the test's execution should fail with the `should_fail`\n directive.\n \n-~~~\n-```should_fail\n-// This code block is expected to generate a failure when run\n-```\n-~~~\n+    /**\n+    # nested codefences confuse sundown => indentation + comment to\n+    #  avoid failing tests\n+    ```should_fail\n+    // This code block is expected to generate a failure when run\n+    ```\n+    */\n+    # fn foo() {}\n \n You can specify that the code block should be compiled but not run with the\n `no_run` directive.\n \n-~~~\n-```no_run\n-// This code will be compiled but not executed\n-```\n-~~~\n+    /**\n+    # nested codefences confuse sundown => indentation + comment to\n+    #  avoid failing tests\n+    ```no_run\n+    // This code will be compiled but not executed\n+    ```\n+    */\n+    # fn foo() {}\n \n Rustdoc also supplies some extra sugar for helping with some tedious\n documentation examples. If a line is prefixed with `# `, then the line\n will not show up in the HTML documentation, but it will be used when\n testing the code block (NB. the space after the `#` is required, so\n that one can still write things like `#[deriving(Eq)]`).\n \n-~~~\n-```rust\n-# /!\\ The three following lines are comments, which are usually stripped off by\n-# the doc-generating tool.  In order to display them anyway in this particular\n-# case, the character following the leading '#' is not a usual space like in\n-# these first five lines but a non breakable one.\n-#\n-#\u00a0// showing 'fib' in this documentation would just be tedious and detracts from\n-#\u00a0// what's actualy being documented.\n-#\u00a0fn fib(n: int) { n + 2 }\n-\n-do spawn { fib(200); }\n-```\n-~~~\n+    /**\n+    # nested codefences confuse sundown => indentation + comment to\n+    #  avoid failing tests\n+    ```rust\n+    # /!\\ The three following lines are comments, which are usually stripped off by\n+    # the doc-generating tool.  In order to display them anyway in this particular\n+    # case, the character following the leading '#' is not a usual space like in\n+    # these first five lines but a non breakable one.\n+    #\n+    #\u00a0// showing 'fib' in this documentation would just be tedious and detracts from\n+    #\u00a0// what's actualy being documented.\n+    #\u00a0fn fib(n: int) { n + 2 }\n+\n+    do spawn { fib(200); }\n+    ```\n+    */\n+    # fn foo() {}\n \n The documentation online would look like `do spawn { fib(200); }`, but when\n testing this code, the `fib` function will be included (so it can compile).\n@@ -167,12 +181,12 @@ uses is build on crate `test`, which is also used when you compile crates with\n rustc's `--test` flag. Extra arguments can be passed to rustdoc's test harness\n with the `--test-args` flag.\n \n-~~~\n-// Only run tests containing 'foo' in their name\n-rustdoc --test lib.rs --test-args 'foo'\n+~~~ {.notrust}\n+$ # Only run tests containing 'foo' in their name\n+$ rustdoc --test lib.rs --test-args 'foo'\n \n-// See what's possible when running tests\n-rustdoc --test lib.rs --test-args '--help'\n+$ # See what's possible when running tests\n+$ rustdoc --test lib.rs --test-args '--help'\n ~~~\n \n When testing a library, code examples will often show how functions are used,\n@@ -181,3 +195,29 @@ rustdoc will implicitly add `extern crate <crate>;` where `<crate>` is the name\n the crate being tested to the top of each code example. This means that rustdoc\n must be able to find a compiled version of the library crate being tested. Extra\n search paths may be added via the `-L` flag to `rustdoc`.\n+\n+# Standalone Markdown files\n+\n+As well as Rust crates, rustdoc supports rendering pure Markdown files\n+into HTML and testing the code snippets from them. A Markdown file is\n+detected by a `.md` or `.markdown` extension.\n+\n+There are 4 options to modify the output that Rustdoc creates.\n+\n+- `--markdown-css PATH`: adds a `<link rel=\"stylesheet\">` tag pointing to `PATH`.\n+- `--markdown-in-header FILE`: includes the contents of `FILE` at the\n+  end of the `<head>...</head>` section.\n+- `--markdown-before-content FILE`: includes the contents of `FILE`\n+  directly after `<body>`, before the rendered content (including the\n+  title).\n+- `--markdown-after-content FILE`: includes the contents of `FILE`\n+  directly before `</body>`, after all the rendered content.\n+\n+All of these can be specified multiple times, and they are output in\n+the order in which they are specified. The first line of the file must\n+be the title, prefixed with `%` (e.g. this page has `% Rust\n+Documentation` on the first line).\n+\n+Like with a Rust crate, the `--test` argument will run the code\n+examples to check they compile, and obeys any `--test-args` flags. The\n+tests are named after the last `#` heading."}, {"sha": "d103b9356d91a5619ef6ea2e3d0a3994ba3e052b", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -1058,10 +1058,12 @@ being destroyed along with the owner. Since the `list` variable above is\n immutable, the whole list is immutable. The memory allocation itself is the\n box, while the owner holds onto a pointer to it:\n \n-              List box             List box           List box            List box\n-            +--------------+    +--------------+    +--------------+    +--------------+\n-    list -> | Cons | 1 | ~ | -> | Cons | 2 | ~ | -> | Cons | 3 | ~ | -> | Nil          |\n-            +--------------+    +--------------+    +--------------+    +--------------+\n+~~~ {.notrust}\n+          List box             List box           List box            List box\n+        +--------------+    +--------------+    +--------------+    +--------------+\n+list -> | Cons | 1 | ~ | -> | Cons | 2 | ~ | -> | Cons | 3 | ~ | -> | Nil          |\n+        +--------------+    +--------------+    +--------------+    +--------------+\n+~~~\n \n > ***Note:*** the above diagram shows the logical contents of the enum. The actual\n > memory layout of the enum may vary. For example, for the `List` enum shown\n@@ -1173,15 +1175,15 @@ ownership of a list to be passed in rather than just mutating it in-place.\n The obvious signature for a `List` equality comparison is the following:\n \n ~~~{.ignore}\n-fn eq(xs: List, ys: List) -> bool { ... }\n+fn eq(xs: List, ys: List) -> bool { /* ... */ }\n ~~~\n \n However, this will cause both lists to be moved into the function. Ownership\n isn't required to compare the lists, so the function should take *references*\n (&T) instead.\n \n ~~~{.ignore}\n-fn eq(xs: &List, ys: &List) -> bool { ... }\n+fn eq(xs: &List, ys: &List) -> bool { /* ... */ }\n ~~~\n \n A reference is a *non-owning* view of a value. A reference can be obtained with the `&` (address-of)\n@@ -1881,9 +1883,9 @@ A caller must in turn have a compatible pointer type to call the method.\n #     Rectangle(Point, Point)\n # }\n impl Shape {\n-    fn draw_reference(&self) { ... }\n-    fn draw_owned(~self) { ... }\n-    fn draw_value(self) { ... }\n+    fn draw_reference(&self) { /* ... */ }\n+    fn draw_owned(~self) { /* ... */ }\n+    fn draw_value(self) { /* ... */ }\n }\n \n let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n@@ -1906,9 +1908,9 @@ to a reference.\n #     Rectangle(Point, Point)\n # }\n # impl Shape {\n-#    fn draw_reference(&self) { ... }\n-#    fn draw_owned(~self) { ... }\n-#    fn draw_value(self) { ... }\n+#    fn draw_reference(&self) { /* ... */ }\n+#    fn draw_owned(~self) { /* ... */ }\n+#    fn draw_value(self) { /* ... */ }\n # }\n # let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n // As with typical function arguments, managed and owned pointers\n@@ -1934,8 +1936,8 @@ These methods are the preferred way to define constructor functions.\n \n ~~~~ {.ignore}\n impl Circle {\n-    fn area(&self) -> f64 { ... }\n-    fn new(area: f64) -> Circle { ... }\n+    fn area(&self) -> f64 { /* ... */ }\n+    fn new(area: f64) -> Circle { /* ... */ }\n }\n ~~~~\n \n@@ -2395,8 +2397,8 @@ to an object:\n # fn new_rectangle() -> Rectangle { true }\n # fn draw_all(shapes: &[~Drawable]) {}\n \n-impl Drawable for Circle { fn draw(&self) { ... } }\n-impl Drawable for Rectangle { fn draw(&self) { ... } }\n+impl Drawable for Circle { fn draw(&self) { /* ... */ } }\n+impl Drawable for Rectangle { fn draw(&self) { /* ... */ } }\n \n let c: ~Circle = ~new_circle();\n let r: ~Rectangle = ~new_rectangle();\n@@ -2510,7 +2512,7 @@ use std::f64::consts::PI;\n # impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / PI).sqrt() } }\n # impl Shape for CircleStruct { fn area(&self) -> f64 { PI * square(self.radius) } }\n \n-let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};\n+let concrete = @CircleStruct{center:Point{x:3.0,y:4.0},radius:5.0};\n let mycircle: @Circle = concrete as @Circle;\n let nonsense = mycircle.radius() * mycircle.area();\n ~~~\n@@ -2667,8 +2669,8 @@ mod farm {\n     }\n \n     impl Farm {\n-        fn feed_chickens(&self) { ... }\n-        pub fn add_chicken(&self, c: Chicken) { ... }\n+        fn feed_chickens(&self) { /* ... */ }\n+        pub fn add_chicken(&self, c: Chicken) { /* ... */ }\n     }\n \n     pub fn feed_animals(farm: &Farm) {\n@@ -3144,9 +3146,10 @@ We define two crates, and use one of them as a library in the other.\n ~~~~\n // `world.rs`\n #[crate_id = \"world#0.42\"];\n-# extern crate extra;\n+\n+# mod secret_module_to_make_this_test_run {\n pub fn explore() -> &'static str { \"world\" }\n-# fn main() {}\n+# }\n ~~~~\n \n ~~~~ {.ignore}"}, {"sha": "2900023ea2b43fd2f599cfe8f6cf422382e821d0", "filename": "src/etc/extract-tests.py", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/e959c8794b80ffad3abd50f773e5a613e13ff7b2/src%2Fetc%2Fextract-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/e959c8794b80ffad3abd50f773e5a613e13ff7b2/src%2Fetc%2Fextract-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract-tests.py?ref=e959c8794b80ffad3abd50f773e5a613e13ff7b2", "patch": "@@ -1,217 +0,0 @@\n-# Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-\"\"\"\n-Script for extracting compilable fragments from markdown documentation. See\n-prep.js for a description of the format recognized by this tool. Expects\n-a directory fragments/ to exist under the current directory, and writes the\n-fragments in there as individual .rs files.\n-\"\"\"\n-from __future__ import print_function\n-from codecs import open\n-from collections import deque\n-from itertools import imap\n-import os\n-import re\n-import sys\n-\n-# regexes\n-CHAPTER_NAME_REGEX = re.compile(r'# (.*)')\n-CODE_BLOCK_DELIM_REGEX = re.compile(r'~~~')\n-COMMENT_REGEX = re.compile(r'^# ')\n-COMPILER_DIRECTIVE_REGEX = re.compile(r'\\#\\[(.*)\\];')\n-ELLIPSES_REGEX = re.compile(r'\\.\\.\\.')\n-EXTERN_CRATE_REGEX = re.compile(r'\\bextern crate extra\\b')\n-MAIN_FUNCTION_REGEX = re.compile(r'\\bfn main\\b')\n-TAGS_REGEX = re.compile(r'\\.([\\w-]*)')\n-\n-# tags to ignore\n-IGNORE_TAGS = \\\n-        frozenset([\"abnf\", \"ebnf\", \"field\", \"keyword\", \"notrust\", \"precedence\"])\n-\n-# header for code snippet files\n-OUTPUT_BLOCK_HEADER = '\\n'.join((\n-    \"#[ deny(warnings) ];\",\n-    \"#[ allow(unused_variable) ];\",\n-    \"#[ allow(dead_assignment) ];\",\n-    \"#[ allow(unused_mut) ];\",\n-    \"#[ allow(attribute_usage) ];\",\n-    \"#[ allow(dead_code) ];\",\n-    \"#[ feature(macro_rules, globs, struct_variant, managed_boxes) ];\\n\",))\n-\n-\n-def add_extern_mod(block):\n-    if not has_extern_mod(block):\n-        # add `extern crate extra;` after compiler directives\n-        directives = []\n-        while len(block) and is_compiler_directive(block[0]):\n-            directives.append(block.popleft())\n-\n-        block.appendleft(\"\\nextern crate extra;\\n\\n\")\n-        block.extendleft(reversed(directives))\n-\n-    return block\n-\n-\n-def add_main_function(block):\n-    if not has_main_function(block):\n-        prepend_spaces = lambda x: '    ' + x\n-        block = deque(imap(prepend_spaces, block))\n-        block.appendleft(\"\\nfn main() {\\n\")\n-        block.append(\"\\n}\\n\")\n-    return block\n-\n-\n-def extract_code_fragments(dest_dir, lines):\n-    \"\"\"\n-    Extracts all the code fragments from a file that do not have ignored tags\n-    writing them to the following file:\n-\n-        [dest dir]/[chapter name]_[chapter_index].rs\n-    \"\"\"\n-    chapter_name = None\n-    chapter_index = 0\n-\n-    for line in lines:\n-        if is_chapter_title(line):\n-            chapter_name = get_chapter_name(line)\n-            chapter_index = 1\n-            continue\n-\n-        if not is_code_block_delim(line):\n-            continue\n-\n-        assert chapter_name, \"Chapter name missing for code block.\"\n-        tags = get_tags(line)\n-        block = get_code_block(lines)\n-\n-        if tags & IGNORE_TAGS:\n-            continue\n-\n-        block = add_extern_mod(add_main_function(block))\n-        block.appendleft(OUTPUT_BLOCK_HEADER)\n-\n-        if \"ignore\" in tags:\n-            block.appendleft(\"//ignore-test\\n\")\n-        elif \"should_fail\" in tags:\n-            block.appendleft(\"//should-fail\\n\")\n-\n-        output_filename = os.path.join(\n-                dest_dir,\n-                chapter_name + '_' + str(chapter_index) + '.rs')\n-\n-        write_file(output_filename, block)\n-        chapter_index += 1\n-\n-\n-def has_extern_mod(block):\n-    \"\"\"Checks if a code block has the line `extern crate extra`.\"\"\"\n-    find_extern_mod = lambda x: re.search(EXTERN_CRATE_REGEX, x)\n-    return any(imap(find_extern_mod, block))\n-\n-\n-def has_main_function(block):\n-    \"\"\"Checks if a code block has a main function.\"\"\"\n-    find_main_fn = lambda x: re.search(MAIN_FUNCTION_REGEX, x)\n-    return any(imap(find_main_fn, block))\n-\n-\n-def is_chapter_title(line):\n-    return re.match(CHAPTER_NAME_REGEX, line)\n-\n-\n-def is_code_block_delim(line):\n-    return re.match(CODE_BLOCK_DELIM_REGEX, line)\n-\n-\n-def is_compiler_directive(line):\n-    return re.match(COMPILER_DIRECTIVE_REGEX, line)\n-\n-\n-def get_chapter_name(line):\n-    \"\"\"Get the chapter name from a `# Containers` line.\"\"\"\n-    return re.sub(\n-            r'\\W',\n-            '_',\n-            re.match(CHAPTER_NAME_REGEX, line).group(1)).lower()\n-\n-\n-def get_code_block(lines):\n-    \"\"\"\n-    Get a code block surrounded by ~~~, for example:\n-\n-        1: ~~~ { .tag }\n-        2: let u: ~[u32] = ~[0, 1, 2];\n-        3: let v: &[u32] = &[0, 1, 2, 3];\n-        4: let w: [u32, .. 5] = [0, 1, 2, 3, 4];\n-        5:\n-        6: println!(\"u: {}, v: {}, w: {}\", u.len(), v.len(), w.len());\n-        7: ~~~\n-\n-    Returns lines 2-6. Assumes line 1 has been consumed by the caller.\n-    \"\"\"\n-    strip_comments = lambda x: re.sub(COMMENT_REGEX, '', x)\n-    strip_ellipses = lambda x: re.sub(ELLIPSES_REGEX, '', x)\n-\n-    result = deque()\n-\n-    for line in lines:\n-        if is_code_block_delim(line):\n-            break\n-        result.append(strip_comments(strip_ellipses(line)))\n-    return result\n-\n-\n-def get_lines(filename):\n-    with open(filename) as f:\n-        for line in f:\n-            yield line\n-\n-\n-def get_tags(line):\n-    \"\"\"\n-    Retrieves all tags from the line format:\n-        ~~~ { .tag1 .tag2 .tag3 }\n-    \"\"\"\n-    return set(re.findall(TAGS_REGEX, line))\n-\n-\n-def write_file(filename, lines):\n-    with open(filename, 'w', encoding='utf-8') as f:\n-        for line in lines:\n-            f.write(unicode(line, encoding='utf-8', errors='replace'))\n-\n-\n-def main(argv=None):\n-    if not argv:\n-        argv = sys.argv\n-\n-    if len(sys.argv) < 2:\n-        sys.stderr.write(\"Please provide an input filename.\")\n-        sys.exit(1)\n-    elif len(sys.argv) < 3:\n-        sys.stderr.write(\"Please provide a destination directory.\")\n-        sys.exit(1)\n-\n-    input_file = sys.argv[1]\n-    dest_dir = sys.argv[2]\n-\n-    if not os.path.exists(input_file):\n-        sys.stderr.write(\"Input file does not exist.\")\n-        sys.exit(1)\n-\n-    if not os.path.exists(dest_dir):\n-        os.mkdir(dest_dir)\n-\n-    extract_code_fragments(dest_dir, get_lines(input_file))\n-\n-\n-if __name__ == \"__main__\":\n-    sys.exit(main())"}, {"sha": "61c1cd734a38d9652e2f8c30b4ce89d5bb777abe", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -28,7 +28,6 @@\n \n use std::cast;\n use std::fmt;\n-use std::intrinsics;\n use std::io;\n use std::libc;\n use std::local_data;\n@@ -37,12 +36,16 @@ use std::str;\n use std::vec;\n use collections::HashMap;\n \n+use html::toc::TocBuilder;\n use html::highlight;\n \n /// A unit struct which has the `fmt::Show` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n pub struct Markdown<'a>(&'a str);\n+/// A unit struct like `Markdown`, that renders the markdown with a\n+/// table of contents.\n+pub struct MarkdownWithToc<'a>(&'a str);\n \n static OUTPUT_UNIT: libc::size_t = 64;\n static MKDEXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 0;\n@@ -76,6 +79,7 @@ struct html_renderopt {\n struct my_opaque {\n     opt: html_renderopt,\n     dfltblk: extern \"C\" fn(*buf, *buf, *buf, *libc::c_void),\n+    toc_builder: Option<TocBuilder>,\n }\n \n struct buf {\n@@ -122,7 +126,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n \n local_data_key!(used_header_map: HashMap<~str, uint>)\n \n-pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n+pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *buf, text: *buf, lang: *buf, opaque: *libc::c_void) {\n         unsafe {\n             let my_opaque: &my_opaque = cast::transmute(opaque);\n@@ -163,7 +167,7 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n     }\n \n     extern fn header(ob: *buf, text: *buf, level: libc::c_int,\n-                     _opaque: *libc::c_void) {\n+                     opaque: *libc::c_void) {\n         // sundown does this, we may as well too\n         \"\\n\".with_c_str(|p| unsafe { bufputs(ob, p) });\n \n@@ -184,6 +188,8 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n             }\n         }).to_owned_vec().connect(\"-\");\n \n+        let opaque = unsafe {&mut *(opaque as *mut my_opaque)};\n+\n         // Make sure our hyphenated ID is unique for this page\n         let id = local_data::get_mut(used_header_map, |map| {\n             let map = map.unwrap();\n@@ -195,9 +201,19 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n             id.clone()\n         });\n \n+        let sec = match opaque.toc_builder {\n+            Some(ref mut builder) => {\n+                builder.push(level as u32, s.clone(), id.clone())\n+            }\n+            None => {\"\"}\n+        };\n+\n         // Render the HTML\n-        let text = format!(r#\"<h{lvl} id=\"{id}\">{}</h{lvl}>\"#,\n-                           s, lvl = level, id = id);\n+        let text = format!(r#\"<h{lvl} id=\"{id}\"><a\n+                           href=\"\\#{id}\">{sec_len,plural,=0{}other{{sec} }}{}</a></h{lvl}>\"#,\n+                           s, lvl = level, id = id,\n+                           sec_len = sec.len(), sec = sec);\n+\n         text.with_c_str(|p| unsafe { bufputs(ob, p) });\n     }\n \n@@ -219,23 +235,30 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n         let mut callbacks: sd_callbacks = mem::init();\n \n         sdhtml_renderer(&callbacks, &options, 0);\n-        let opaque = my_opaque {\n+        let mut opaque = my_opaque {\n             opt: options,\n             dfltblk: callbacks.blockcode.unwrap(),\n+            toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n         };\n         callbacks.blockcode = Some(block);\n         callbacks.header = Some(header);\n         let markdown = sd_markdown_new(extensions, 16, &callbacks,\n-                                       &opaque as *my_opaque as *libc::c_void);\n+                                       &mut opaque as *mut my_opaque as *libc::c_void);\n \n \n         sd_markdown_render(ob, s.as_ptr(), s.len() as libc::size_t, markdown);\n         sd_markdown_free(markdown);\n \n-        let ret = vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n-            w.write(buf)\n-        });\n+        let mut ret = match opaque.toc_builder {\n+            Some(b) => write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", b.into_toc()),\n+            None => Ok(())\n+        };\n \n+        if ret.is_ok() {\n+            ret = vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n+                w.write(buf)\n+            });\n+        }\n         bufrelease(ob);\n         ret\n     }\n@@ -258,14 +281,27 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             };\n             if ignore { return }\n             vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n-                let tests: &mut ::test::Collector = intrinsics::transmute(opaque);\n+                let tests = &mut *(opaque as *mut ::test::Collector);\n                 let text = str::from_utf8(text).unwrap();\n                 let mut lines = text.lines().map(|l| stripped_filtered_line(l).unwrap_or(l));\n                 let text = lines.to_owned_vec().connect(\"\\n\");\n                 tests.add_test(text, should_fail, no_run);\n             })\n         }\n     }\n+    extern fn header(_ob: *buf, text: *buf, level: libc::c_int, opaque: *libc::c_void) {\n+        unsafe {\n+            let tests = &mut *(opaque as *mut ::test::Collector);\n+            if text.is_null() {\n+                tests.register_header(\"\", level as u32);\n+            } else {\n+                vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+                    let text = str::from_utf8(text).unwrap();\n+                    tests.register_header(text, level as u32);\n+                })\n+            }\n+        }\n+    }\n \n     unsafe {\n         let ob = bufnew(OUTPUT_UNIT);\n@@ -276,7 +312,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             blockcode: Some(block),\n             blockquote: None,\n             blockhtml: None,\n-            header: None,\n+            header: Some(header),\n             other: mem::init()\n         };\n \n@@ -307,6 +343,13 @@ impl<'a> fmt::Show for Markdown<'a> {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.len() == 0 { return Ok(()) }\n-        render(fmt.buf, md.as_slice())\n+        render(fmt.buf, md.as_slice(), false)\n+    }\n+}\n+\n+impl<'a> fmt::Show for MarkdownWithToc<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let MarkdownWithToc(md) = *self;\n+        render(fmt.buf, md.as_slice(), true)\n     }\n }"}, {"sha": "b705e976e4656ddddb12e6befe6929d8724f6ba9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -1064,7 +1064,8 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 clean::ForeignStaticItem(..)   => (\"ffi-statics\", \"Foreign Statics\"),\n                 clean::MacroItem(..)           => (\"macros\", \"Macros\"),\n             };\n-            try!(write!(w, \"<h2 id='{}'>{}</h2>\\n<table>\", short, name));\n+            try!(write!(w, \"<h2 id='{id}'><a href=\\\"\\\\#{id}\\\">{name}</a></h2>\\n<table>\",\n+                        id = short, name = name));\n         }\n \n         match myitem.inner {"}, {"sha": "0efee51a2190986a5a19a38a5d7184fe1df5f47a", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -320,9 +320,16 @@ pre.rust .string { color: #718C00; }\n pre.rust .lifetime { color: #C13928; }\n pre.rust .attribute, pre.rust .attribute .ident { color: #C82829; }\n \n-h1 a.anchor,\n-h2 a.anchor,\n-h3 a.anchor { display: none; }\n-h1:hover a.anchor,\n-h2:hover a.anchor,\n-h3:hover a.anchor { display: inline-block; }\n+h1:hover a:after,\n+h2:hover a:after,\n+h3:hover a:after,\n+h4:hover a:after,\n+h5:hover a:after,\n+h6:hover a:after {\n+  content: '\u2002\u00a7\u2002';\n+}\n+\n+h1.fqn:hover a:after,\n+:hover a.fnname:after {\n+  content: none;\n+}"}, {"sha": "3056bca68d7845e89dfa74bad7d88930cbb884a0", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -600,10 +600,4 @@\n \n     initSearch(searchIndex);\n \n-    $.each($('h1, h2, h3'), function(idx, element) {\n-        if ($(element).attr('id') != undefined) {\n-            $(element).append('<a href=\"#' + $(element).attr('id') + '\" ' +\n-                              'class=\"anchor\">\u2002\u00a7\u2002</a>');\n-        }\n-    });\n }());"}, {"sha": "61031c222e74a6f0219ceb54fc037ad3fd76e209", "filename": "src/librustdoc/html/toc.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -0,0 +1,269 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Table-of-contents creation.\n+\n+use std::fmt;\n+use std::vec_ng::Vec;\n+\n+/// A (recursive) table of contents\n+#[deriving(Eq)]\n+pub struct Toc {\n+    /// The levels are strictly decreasing, i.e.\n+    ///\n+    /// entries[0].level >= entries[1].level >= ...\n+    ///\n+    /// Normally they are equal, but can differ in cases like A and B,\n+    /// both of which end up in the same `Toc` as they have the same\n+    /// parent (Main).\n+    ///\n+    /// # Main\n+    /// ### A\n+    /// ## B\n+    priv entries: Vec<TocEntry>\n+}\n+\n+impl Toc {\n+    fn count_entries_with_level(&self, level: u32) -> uint {\n+        self.entries.iter().count(|e| e.level == level)\n+    }\n+}\n+\n+#[deriving(Eq)]\n+pub struct TocEntry {\n+    priv level: u32,\n+    priv sec_number: ~str,\n+    priv name: ~str,\n+    priv id: ~str,\n+    priv children: Toc,\n+}\n+\n+/// Progressive construction of a table of contents.\n+#[deriving(Eq)]\n+pub struct TocBuilder {\n+    priv top_level: Toc,\n+    /// The current heirachy of parent headings, the levels are\n+    /// strictly increasing (i.e. chain[0].level < chain[1].level <\n+    /// ...) with each entry being the most recent occurance of a\n+    /// heading with that level (it doesn't include the most recent\n+    /// occurences of every level, just, if *is* in `chain` then is is\n+    /// the most recent one).\n+    ///\n+    /// We also have `chain[0].level <= top_level.entries[last]`.\n+    priv chain: Vec<TocEntry>\n+}\n+\n+impl TocBuilder {\n+    pub fn new() -> TocBuilder {\n+        TocBuilder { top_level: Toc { entries: Vec::new() }, chain: Vec::new() }\n+    }\n+\n+\n+    /// Convert into a true `Toc` struct.\n+    pub fn into_toc(mut self) -> Toc {\n+        // we know all levels are >= 1.\n+        self.fold_until(0);\n+        self.top_level\n+    }\n+\n+    /// Collapse the chain until the first heading more important than\n+    /// `level` (i.e. lower level)\n+    ///\n+    /// Example:\n+    ///\n+    /// ## A\n+    /// # B\n+    /// # C\n+    /// ## D\n+    /// ## E\n+    /// ### F\n+    /// #### G\n+    /// ### H\n+    ///\n+    /// If we are considering H (i.e. level 3), then A and B are in\n+    /// self.top_level, D is in C.children, and C, E, F, G are in\n+    /// self.chain.\n+    ///\n+    /// When we attempt to push H, we realise that first G is not the\n+    /// parent (level is too high) so it is popped from chain and put\n+    /// into F.children, then F isn't the parent (level is equal, aka\n+    /// sibling), so it's also popped and put into E.children.\n+    ///\n+    /// This leaves us looking at E, which does have a smaller level,\n+    /// and, by construction, it's the most recent thing with smaller\n+    /// level, i.e. it's the immediate parent of H.\n+    fn fold_until(&mut self, level: u32) {\n+        let mut this = None;\n+        loop {\n+            match self.chain.pop() {\n+                Some(mut next) => {\n+                    this.map(|e| next.children.entries.push(e));\n+                    if next.level < level {\n+                        // this is the parent we want, so return it to\n+                        // its rightful place.\n+                        self.chain.push(next);\n+                        return\n+                    } else {\n+                        this = Some(next);\n+                    }\n+                }\n+                None => {\n+                    this.map(|e| self.top_level.entries.push(e));\n+                    return\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Push a level `level` heading into the appropriate place in the\n+    /// heirarchy, returning a string containing the section number in\n+    /// `<num>.<num>.<num>` format.\n+    pub fn push<'a>(&'a mut self, level: u32, name: ~str, id: ~str) -> &'a str {\n+        assert!(level >= 1);\n+\n+        // collapse all previous sections into their parents until we\n+        // get to relevant heading (i.e. the first one with a smaller\n+        // level than us)\n+        self.fold_until(level);\n+\n+        let mut sec_number;\n+        {\n+            let (toc_level, toc) = match self.chain.last() {\n+                None => {\n+                    sec_number = ~\"\";\n+                    (0, &self.top_level)\n+                }\n+                Some(entry) => {\n+                    sec_number = entry.sec_number.clone();\n+                    sec_number.push_str(\".\");\n+                    (entry.level, &entry.children)\n+                }\n+            };\n+            // fill in any missing zeros, e.g. for\n+            // # Foo (1)\n+            // ### Bar (1.0.1)\n+            for _ in range(toc_level, level - 1) {\n+                sec_number.push_str(\"0.\");\n+            }\n+            let number = toc.count_entries_with_level(level);\n+            sec_number.push_str(format!(\"{}\", number + 1))\n+        }\n+\n+        self.chain.push(TocEntry {\n+                level: level,\n+                name: name,\n+                sec_number: sec_number,\n+                id: id,\n+                children: Toc { entries: Vec::new() }\n+            });\n+\n+        // get the thing we just pushed, so we can borrow the string\n+        // out of it with the right lifetime\n+        let just_inserted = self.chain.mut_last().unwrap();\n+        just_inserted.sec_number.as_slice()\n+    }\n+}\n+\n+impl fmt::Show for Toc {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(fmt.buf, \"<ul>\"));\n+        for entry in self.entries.iter() {\n+            // recursively format this table of contents (the\n+            // `{children}` is the key).\n+            try!(write!(fmt.buf,\n+                        \"\\n<li><a href=\\\"\\\\#{id}\\\">{num} {name}</a>{children}</li>\",\n+                        id = entry.id,\n+                        num = entry.sec_number, name = entry.name,\n+                        children = entry.children))\n+        }\n+        write!(fmt.buf, \"</ul>\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{TocBuilder, Toc, TocEntry};\n+\n+    #[test]\n+    fn builder_smoke() {\n+        let mut builder = TocBuilder::new();\n+\n+        // this is purposely not using a fancy macro like below so\n+        // that we're sure that this is doing the correct thing, and\n+        // there's been no macro mistake.\n+        macro_rules! push {\n+            ($level: expr, $name: expr) => {\n+                assert_eq!(builder.push($level, $name.to_owned(), ~\"\"), $name);\n+            }\n+        }\n+        push!(2, \"0.1\");\n+        push!(1, \"1\");\n+        {\n+            push!(2, \"1.1\");\n+            {\n+                push!(3, \"1.1.1\");\n+                push!(3, \"1.1.2\");\n+            }\n+            push!(2, \"1.2\");\n+            {\n+                push!(3, \"1.2.1\");\n+                push!(3, \"1.2.2\");\n+            }\n+        }\n+        push!(1, \"2\");\n+        push!(1, \"3\");\n+        {\n+            push!(4, \"3.0.0.1\");\n+            {\n+                push!(6, \"3.0.0.1.0.1\");\n+            }\n+            push!(4, \"3.0.0.2\");\n+            push!(2, \"3.1\");\n+            {\n+                push!(4, \"3.1.0.1\");\n+            }\n+        }\n+\n+        macro_rules! toc {\n+            ($(($level: expr, $name: expr, $(($sub: tt))* )),*) => {\n+                Toc {\n+                    entries: vec!(\n+                        $(\n+                            TocEntry {\n+                                level: $level,\n+                                name: $name.to_owned(),\n+                                sec_number: $name.to_owned(),\n+                                id: ~\"\",\n+                                children: toc!($($sub),*)\n+                            }\n+                            ),*\n+                        )\n+                }\n+            }\n+        }\n+        let expected = toc!(\n+            (2, \"0.1\", ),\n+\n+            (1, \"1\",\n+             ((2, \"1.1\", ((3, \"1.1.1\", )) ((3, \"1.1.2\", ))))\n+             ((2, \"1.2\", ((3, \"1.2.1\", )) ((3, \"1.2.2\", ))))\n+             ),\n+\n+            (1, \"2\", ),\n+\n+            (1, \"3\",\n+             ((4, \"3.0.0.1\", ((6, \"3.0.0.1.0.1\", ))))\n+             ((4, \"3.0.0.2\", ))\n+             ((2, \"3.1\", ((4, \"3.1.0.1\", ))))\n+             )\n+            );\n+        assert_eq!(expected, builder.into_toc());\n+    }\n+}"}, {"sha": "2d08dca97b986af22d987226a7f18d316474dfe0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -14,7 +14,7 @@\n #[crate_type = \"dylib\"];\n #[crate_type = \"rlib\"];\n \n-#[feature(globs, struct_variant, managed_boxes)];\n+#[feature(globs, struct_variant, managed_boxes, macro_rules)];\n \n extern crate syntax;\n extern crate rustc;\n@@ -26,6 +26,7 @@ extern crate collections;\n extern crate testing = \"test\";\n extern crate time;\n \n+use std::cell::RefCell;\n use std::local_data;\n use std::io;\n use std::io::{File, MemWriter};\n@@ -43,7 +44,9 @@ pub mod html {\n     pub mod layout;\n     pub mod markdown;\n     pub mod render;\n+    pub mod toc;\n }\n+pub mod markdown;\n pub mod passes;\n pub mod plugins;\n pub mod visit_ast;\n@@ -105,6 +108,19 @@ pub fn opts() -> ~[getopts::OptGroup] {\n         optflag(\"\", \"test\", \"run code examples as tests\"),\n         optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\",\n                  \"ARGS\"),\n+        optmulti(\"\", \"markdown-css\", \"CSS files to include via <link> in a rendered Markdown file\",\n+                 \"FILES\"),\n+        optmulti(\"\", \"markdown-in-header\",\n+                 \"files to include inline in the <head> section of a rendered Markdown file\",\n+                 \"FILES\"),\n+        optmulti(\"\", \"markdown-before-content\",\n+                 \"files to include inline between <body> and the content of a rendered \\\n+                 Markdown file\",\n+                 \"FILES\"),\n+        optmulti(\"\", \"markdown-after-content\",\n+                 \"files to include inline between the content and </body> of a rendered \\\n+                 Markdown file\",\n+                 \"FILES\"),\n     ]\n }\n \n@@ -137,8 +153,24 @@ pub fn main_args(args: &[~str]) -> int {\n     }\n     let input = matches.free[0].as_slice();\n \n-    if matches.opt_present(\"test\") {\n-        return test::run(input, &matches);\n+    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n+    let libs = @RefCell::new(libs.move_iter().collect());\n+\n+    let test_args = matches.opt_strs(\"test-args\");\n+    let test_args = test_args.iter().flat_map(|s| s.words()).map(|s| s.to_owned()).to_owned_vec();\n+\n+    let should_test = matches.opt_present(\"test\");\n+    let markdown_input = input.ends_with(\".md\") || input.ends_with(\".markdown\");\n+\n+    let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n+\n+    match (should_test, markdown_input) {\n+        (true, true) => return markdown::test(input, libs, test_args),\n+        (true, false) => return test::run(input, libs, test_args),\n+\n+        (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n+                                                 &matches),\n+        (false, false) => {}\n     }\n \n     if matches.opt_strs(\"passes\") == ~[~\"list\"] {\n@@ -163,7 +195,6 @@ pub fn main_args(args: &[~str]) -> int {\n \n     info!(\"going to format\");\n     let started = time::precise_time_ns();\n-    let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n     match matches.opt_str(\"w\") {\n         Some(~\"html\") | None => {\n             match html::render::run(krate, output.unwrap_or(Path::new(\"doc\"))) {"}, {"sha": "5d8e0008b870d393069a7f33c64a5fb8dfa206a9", "filename": "src/librustdoc/markdown.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -0,0 +1,171 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{str, io};\n+use std::cell::RefCell;\n+use std::vec_ng::Vec;\n+\n+use collections::HashSet;\n+\n+use getopts;\n+use testing;\n+\n+use html::escape::Escape;\n+use html::markdown::{MarkdownWithToc, find_testable_code, reset_headers};\n+use test::Collector;\n+\n+fn load_string(input: &Path) -> io::IoResult<Option<~str>> {\n+    let mut f = try!(io::File::open(input));\n+    let d = try!(f.read_to_end());\n+    Ok(str::from_utf8_owned(d))\n+}\n+macro_rules! load_or_return {\n+    ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n+        {\n+            let input = Path::new($input);\n+            match load_string(&input) {\n+                Err(e) => {\n+                    let _ = writeln!(&mut io::stderr(),\n+                                     \"error reading `{}`: {}\", input.display(), e);\n+                    return $cant_read;\n+                }\n+                Ok(None) => {\n+                    let _ = writeln!(&mut io::stderr(),\n+                                     \"error reading `{}`: not UTF-8\", input.display());\n+                    return $not_utf8;\n+                }\n+                Ok(Some(s)) => s\n+            }\n+        }\n+    }\n+}\n+\n+/// Separate any lines at the start of the file that begin with `%`.\n+fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n+    let mut metadata = Vec::new();\n+    for line in s.lines() {\n+        if line.starts_with(\"%\") {\n+            // remove %<whitespace>\n+            metadata.push(line.slice_from(1).trim_left())\n+        } else {\n+            let line_start_byte = s.subslice_offset(line);\n+            return (metadata, s.slice_from(line_start_byte));\n+        }\n+    }\n+    // if we're here, then all lines were metadata % lines.\n+    (metadata, \"\")\n+}\n+\n+fn load_external_files(names: &[~str]) -> Option<~str> {\n+    let mut out = ~\"\";\n+    for name in names.iter() {\n+        out.push_str(load_or_return!(name.as_slice(), None, None));\n+        out.push_char('\\n');\n+    }\n+    Some(out)\n+}\n+\n+/// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n+/// (e.g. output = \"bar\" => \"bar/foo.html\").\n+pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int {\n+    let input_p = Path::new(input);\n+    output.push(input_p.filestem().unwrap());\n+    output.set_extension(\"html\");\n+\n+    let mut css = ~\"\";\n+    for name in matches.opt_strs(\"markdown-css\").iter() {\n+        let s = format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\", name);\n+        css.push_str(s)\n+    }\n+\n+    let input_str = load_or_return!(input, 1, 2);\n+\n+    let (in_header, before_content, after_content) =\n+        match (load_external_files(matches.opt_strs(\"markdown-in-header\")),\n+               load_external_files(matches.opt_strs(\"markdown-before-content\")),\n+               load_external_files(matches.opt_strs(\"markdown-after-content\"))) {\n+        (Some(a), Some(b), Some(c)) => (a,b,c),\n+        _ => return 3\n+    };\n+\n+    let mut out = match io::File::create(&output) {\n+        Err(e) => {\n+            let _ = writeln!(&mut io::stderr(),\n+                             \"error opening `{}` for writing: {}\",\n+                             output.display(), e);\n+            return 4;\n+        }\n+        Ok(f) => f\n+    };\n+\n+    let (metadata, text) = extract_leading_metadata(input_str);\n+    if metadata.len() == 0 {\n+        let _ = writeln!(&mut io::stderr(),\n+                         \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n+        return 5;\n+    }\n+    let title = metadata.get(0).as_slice();\n+\n+    reset_headers();\n+\n+    let err = write!(\n+        &mut out,\n+        r#\"<!doctype html>\n+<html lang=\"en\">\n+<head>\n+    <meta charset=\"utf-8\">\n+    <meta name=\"generator\" content=\"rustdoc\">\n+    <title>{title}</title>\n+\n+    {css}\n+    {in_header}\n+</head>\n+<body>\n+    <!--[if lte IE 8]>\n+    <div class=\"warning\">\n+        This old browser is unsupported and will most likely display funky\n+        things.\n+    </div>\n+    <![endif]-->\n+\n+    {before_content}\n+    <h1 class=\"title\">{title}</h1>\n+    {text}\n+    {after_content}\n+</body>\n+</html>\"#,\n+        title = Escape(title),\n+        css = css,\n+        in_header = in_header,\n+        before_content = before_content,\n+        text = MarkdownWithToc(text),\n+        after_content = after_content);\n+\n+    match err {\n+        Err(e) => {\n+            let _ = writeln!(&mut io::stderr(),\n+                             \"error writing to `{}`: {}\",\n+                             output.display(), e);\n+            6\n+        }\n+        Ok(_) => 0\n+    }\n+}\n+\n+/// Run any tests/code examples in the markdown file `input`.\n+pub fn test(input: &str, libs: @RefCell<HashSet<Path>>, mut test_args: ~[~str]) -> int {\n+    let input_str = load_or_return!(input, 1, 2);\n+\n+    let mut collector = Collector::new(input.to_owned(), libs, true, true);\n+    find_testable_code(input_str, &mut collector);\n+    test_args.unshift(~\"rustdoctest\");\n+    testing::test_main(test_args, collector.tests);\n+    0\n+}"}, {"sha": "45607a0992e2342d42543785527083d3d16a14ba", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n+use std::char;\n use std::io;\n use std::io::Process;\n use std::local_data;\n@@ -22,7 +23,6 @@ use rustc::back::link;\n use rustc::driver::driver;\n use rustc::driver::session;\n use rustc::metadata::creader::Loader;\n-use getopts;\n use syntax::diagnostic;\n use syntax::parse;\n use syntax::codemap::CodeMap;\n@@ -35,11 +35,9 @@ use html::markdown;\n use passes;\n use visit_ast::RustdocVisitor;\n \n-pub fn run(input: &str, matches: &getopts::Matches) -> int {\n+pub fn run(input: &str, libs: @RefCell<HashSet<Path>>, mut test_args: ~[~str]) -> int {\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n-    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n-    let libs = @RefCell::new(libs.move_iter().collect());\n \n     let sessopts = @session::Options {\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n@@ -79,28 +77,19 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     let (krate, _) = passes::unindent_comments(krate);\n     let (krate, _) = passes::collapse_docs(krate);\n \n-    let mut collector = Collector {\n-        tests: ~[],\n-        names: ~[],\n-        cnt: 0,\n-        libs: libs,\n-        cratename: krate.name.to_owned(),\n-    };\n+    let mut collector = Collector::new(krate.name.to_owned(), libs, false, false);\n     collector.fold_crate(krate);\n \n-    let args = matches.opt_strs(\"test-args\");\n-    let mut args = args.iter().flat_map(|s| s.words()).map(|s| s.to_owned());\n-    let mut args = args.to_owned_vec();\n-    args.unshift(~\"rustdoctest\");\n+    test_args.unshift(~\"rustdoctest\");\n \n-    testing::test_main(args, collector.tests);\n+    testing::test_main(test_args, collector.tests);\n \n     0\n }\n \n fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n-           no_run: bool) {\n-    let test = maketest(test, cratename);\n+           no_run: bool, loose_feature_gating: bool) {\n+    let test = maketest(test, cratename, loose_feature_gating);\n     let parsesess = parse::new_parse_sess();\n     let input = driver::StrInput(test);\n \n@@ -173,11 +162,18 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     }\n }\n \n-fn maketest(s: &str, cratename: &str) -> ~str {\n+fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n     let mut prog = ~r\"\n #[deny(warnings)];\n #[allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)];\n \";\n+\n+    if loose_feature_gating {\n+        // FIXME #12773: avoid inserting these when the tutorial & manual\n+        // etc. have been updated to not use them so prolifically.\n+        prog.push_str(\"#[ feature(macro_rules, globs, struct_variant, managed_boxes) ];\\n\");\n+    }\n+\n     if !s.contains(\"extern crate\") {\n         if s.contains(\"extra\") {\n             prog.push_str(\"extern crate extra;\\n\");\n@@ -198,21 +194,45 @@ fn maketest(s: &str, cratename: &str) -> ~str {\n }\n \n pub struct Collector {\n-    priv tests: ~[testing::TestDescAndFn],\n+    tests: ~[testing::TestDescAndFn],\n     priv names: ~[~str],\n     priv libs: @RefCell<HashSet<Path>>,\n     priv cnt: uint,\n+    priv use_headers: bool,\n+    priv current_header: Option<~str>,\n     priv cratename: ~str,\n+\n+    priv loose_feature_gating: bool\n }\n \n impl Collector {\n-    pub fn add_test(&mut self, test: &str, should_fail: bool, no_run: bool) {\n-        let test = test.to_owned();\n-        let name = format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt);\n+    pub fn new(cratename: ~str, libs: @RefCell<HashSet<Path>>,\n+               use_headers: bool, loose_feature_gating: bool) -> Collector {\n+        Collector {\n+            tests: ~[],\n+            names: ~[],\n+            libs: libs,\n+            cnt: 0,\n+            use_headers: use_headers,\n+            current_header: None,\n+            cratename: cratename,\n+\n+            loose_feature_gating: loose_feature_gating\n+        }\n+    }\n+\n+    pub fn add_test(&mut self, test: ~str, should_fail: bool, no_run: bool) {\n+        let name = if self.use_headers {\n+            let s = self.current_header.as_ref().map(|s| s.as_slice()).unwrap_or(\"\");\n+            format!(\"{}_{}\", s, self.cnt)\n+        } else {\n+            format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt)\n+        };\n         self.cnt += 1;\n         let libs = self.libs.borrow();\n         let libs = (*libs.get()).clone();\n         let cratename = self.cratename.to_owned();\n+        let loose_feature_gating = self.loose_feature_gating;\n         debug!(\"Creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n             desc: testing::TestDesc {\n@@ -221,10 +241,29 @@ impl Collector {\n                 should_fail: false, // compiler failures are test failures\n             },\n             testfn: testing::DynTestFn(proc() {\n-                runtest(test, cratename, libs, should_fail, no_run);\n+                runtest(test, cratename, libs, should_fail, no_run, loose_feature_gating);\n             }),\n         });\n     }\n+\n+    pub fn register_header(&mut self, name: &str, level: u32) {\n+        if self.use_headers && level == 1 {\n+            // we use these headings as test names, so it's good if\n+            // they're valid identifiers.\n+            let name = name.chars().enumerate().map(|(i, c)| {\n+                    if (i == 0 && char::is_XID_start(c)) ||\n+                        (i != 0 && char::is_XID_continue(c)) {\n+                        c\n+                    } else {\n+                        '_'\n+                    }\n+                }).collect::<~str>();\n+\n+            // new header => reset count.\n+            self.cnt = 0;\n+            self.current_header = Some(name);\n+        }\n+    }\n }\n \n impl DocFolder for Collector {\n@@ -237,7 +276,7 @@ impl DocFolder for Collector {\n         match item.doc_value() {\n             Some(doc) => {\n                 self.cnt = 0;\n-                markdown::find_testable_code(doc, self);\n+                markdown::find_testable_code(doc, &mut *self);\n             }\n             None => {}\n         }"}]}