{"sha": "6465868449fe4fe8405decb82dceb957068922da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NjU4Njg0NDlmZTRmZTg0MDVkZWNiODJkY2ViOTU3MDY4OTIyZGE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-18T11:19:29Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-18T11:19:29Z"}, "message": "Make inlay hints work in attributed items", "tree": {"sha": "bb62c5575b68ab0f1af79dcbf1fc4d536ecbde66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb62c5575b68ab0f1af79dcbf1fc4d536ecbde66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6465868449fe4fe8405decb82dceb957068922da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6465868449fe4fe8405decb82dceb957068922da", "html_url": "https://github.com/rust-lang/rust/commit/6465868449fe4fe8405decb82dceb957068922da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6465868449fe4fe8405decb82dceb957068922da/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11a17c803f1dc7d803b8ea2eeda0c15c55d7ec6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/11a17c803f1dc7d803b8ea2eeda0c15c55d7ec6a", "html_url": "https://github.com/rust-lang/rust/commit/11a17c803f1dc7d803b8ea2eeda0c15c55d7ec6a"}], "stats": {"total": 166, "additions": 147, "deletions": 19}, "files": [{"sha": "9821d9d4fa55dc0682a62248655b90983a0f5229", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 72, "deletions": 5, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6465868449fe4fe8405decb82dceb957068922da/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6465868449fe4fe8405decb82dceb957068922da/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=6465868449fe4fe8405decb82dceb957068922da", "patch": "@@ -16,8 +16,9 @@ use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n+    algo::skip_trivia_token,\n     ast::{self, GenericParamsOwner, LoopBodyOwner},\n-    match_ast, AstNode, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::{\n@@ -184,6 +185,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.descend_into_macros(token)\n     }\n \n+    /// Maps a node down by mapping its first and last token down.\n+    pub fn descend_node_into_attributes<N: AstNode>(&self, node: N) -> SmallVec<[N; 1]> {\n+        self.imp.descend_node_into_attributes(node)\n+    }\n+\n     pub fn hir_file_for(&self, syntax_node: &SyntaxNode) -> HirFileId {\n         self.imp.find_file(syntax_node.clone()).file_id\n     }\n@@ -192,6 +198,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.original_range(node)\n     }\n \n+    pub fn original_range_opt(&self, node: &SyntaxNode) -> Option<FileRange> {\n+        self.imp.original_range_opt(node)\n+    }\n+\n     pub fn diagnostics_display_range(&self, diagnostics: InFile<SyntaxNodePtr>) -> FileRange {\n         self.imp.diagnostics_display_range(diagnostics)\n     }\n@@ -471,16 +481,69 @@ impl<'db> SemanticsImpl<'db> {\n         )\n     }\n \n+    // This might not be the correct way to due this, but it works for now\n+    fn descend_node_into_attributes<N: AstNode>(&self, node: N) -> SmallVec<[N; 1]> {\n+        let mut res = smallvec![];\n+        let tokens = (|| {\n+            let first = skip_trivia_token(node.syntax().first_token()?, Direction::Next)?;\n+            let last = skip_trivia_token(node.syntax().last_token()?, Direction::Prev)?;\n+            Some((first, last))\n+        })();\n+        let (first, last) = match tokens {\n+            Some(it) => it,\n+            None => return res,\n+        };\n+\n+        if first == last {\n+            self.descend_into_macros_impl(first, |InFile { value, .. }| {\n+                if let Some(node) = value.ancestors().find_map(N::cast) {\n+                    res.push(node)\n+                }\n+            });\n+        } else {\n+            // Descend first and last token, then zip them to look for the node they belong to\n+            let mut scratch: SmallVec<[_; 1]> = smallvec![];\n+            self.descend_into_macros_impl(first, |token| {\n+                scratch.push(token);\n+            });\n+\n+            let mut scratch = scratch.into_iter();\n+            self.descend_into_macros_impl(last, |InFile { value: last, file_id: last_fid }| {\n+                if let Some(InFile { value: first, file_id: first_fid }) = scratch.next() {\n+                    if first_fid == last_fid {\n+                        if let Some(p) = first.parent() {\n+                            let range = first.text_range().cover(last.text_range());\n+                            let node = find_root(&p)\n+                                .covering_element(range)\n+                                .ancestors()\n+                                .take_while(|it| it.text_range() == range)\n+                                .find_map(N::cast);\n+                            if let Some(node) = node {\n+                                res.push(node);\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+        res\n+    }\n+\n     fn descend_into_macros(&self, token: SyntaxToken) -> SmallVec<[SyntaxToken; 1]> {\n+        let mut res = smallvec![];\n+        self.descend_into_macros_impl(token, |InFile { value, .. }| res.push(value));\n+        res\n+    }\n+\n+    fn descend_into_macros_impl(&self, token: SyntaxToken, mut f: impl FnMut(InFile<SyntaxToken>)) {\n         let _p = profile::span(\"descend_into_macros\");\n         let parent = match token.parent() {\n             Some(it) => it,\n-            None => return smallvec![token],\n+            None => return,\n         };\n         let sa = self.analyze(&parent);\n         let mut queue = vec![InFile::new(sa.file_id, token)];\n         let mut cache = self.expansion_info_cache.borrow_mut();\n-        let mut res = smallvec![];\n         // Remap the next token in the queue into a macro call its in, if it is not being remapped\n         // either due to not being in a macro-call or because its unused push it into the result vec,\n         // otherwise push the remapped tokens back into the queue as they can potentially be remapped again.\n@@ -546,10 +609,9 @@ impl<'db> SemanticsImpl<'db> {\n             .is_none();\n \n             if was_not_remapped {\n-                res.push(token.value)\n+                f(token)\n             }\n         }\n-        res\n     }\n \n     // Note this return type is deliberate as [`find_nodes_at_offset_with_descend`] wants to stop\n@@ -580,6 +642,11 @@ impl<'db> SemanticsImpl<'db> {\n         node.as_ref().original_file_range(self.db.upcast())\n     }\n \n+    fn original_range_opt(&self, node: &SyntaxNode) -> Option<FileRange> {\n+        let node = self.find_file(node.clone());\n+        node.as_ref().original_file_range_opt(self.db.upcast())\n+    }\n+\n     fn diagnostics_display_range(&self, src: InFile<SyntaxNodePtr>) -> FileRange {\n         let root = self.db.parse_or_expand(src.file_id).unwrap();\n         let node = src.value.to_node(&root);"}, {"sha": "79e68aa1dddcbe804987de2a6bf0ed38cf0ecc47", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 75, "deletions": 14, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6465868449fe4fe8405decb82dceb957068922da/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6465868449fe4fe8405decb82dceb957068922da/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=6465868449fe4fe8405decb82dceb957068922da", "patch": "@@ -1,7 +1,7 @@\n use either::Either;\n use hir::{known, Callable, HasVisibility, HirDisplay, Semantics, TypeInfo};\n-use ide_db::helpers::FamousDefs;\n use ide_db::RootDatabase;\n+use ide_db::{base_db::FileRange, helpers::FamousDefs};\n use stdx::to_lower_snake_case;\n use syntax::{\n     ast::{self, ArgListOwner, AstNode, NameOwner},\n@@ -79,7 +79,7 @@ pub(crate) fn inlay_hints(\n                 _ => (),\n             }\n         } else if let Some(it) = ast::IdentPat::cast(node.clone()) {\n-            get_bind_pat_hints(&mut res, &sema, config, it);\n+            get_bind_pat_hints(&mut res, &sema, config, &it);\n         }\n     }\n     res\n@@ -99,7 +99,9 @@ fn get_chaining_hints(\n         return None;\n     }\n \n-    let krate = sema.scope(expr.syntax()).module().map(|it| it.krate());\n+    let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+    let desc_expr = descended.as_ref().unwrap_or(expr);\n+    let krate = sema.scope(desc_expr.syntax()).module().map(|it| it.krate());\n     let famous_defs = FamousDefs(sema, krate);\n \n     let mut tokens = expr\n@@ -121,7 +123,7 @@ fn get_chaining_hints(\n             next_next = tokens.next()?.kind();\n         }\n         if next_next == T![.] {\n-            let ty = sema.type_of_expr(expr)?.original;\n+            let ty = sema.type_of_expr(desc_expr)?.original;\n             if ty.is_unknown() {\n                 return None;\n             }\n@@ -133,7 +135,7 @@ fn get_chaining_hints(\n                 }\n             }\n             acc.push(InlayHint {\n-                range: sema.original_range(expr.syntax()).range,\n+                range: expr.syntax().text_range(),\n                 kind: InlayKind::ChainingHint,\n                 label: hint_iterator(sema, &famous_defs, config, &ty).unwrap_or_else(|| {\n                     ty.display_truncated(sema.db, config.max_length).to_string().into()\n@@ -160,18 +162,22 @@ fn get_param_name_hints(\n         .into_iter()\n         .zip(arg_list.args())\n         .filter_map(|((param, _ty), arg)| {\n+            // Only annotate hints for expressions that exist in the original file\n+            let range = sema.original_range_opt(arg.syntax())?;\n             let param_name = match param? {\n                 Either::Left(_) => \"self\".to_string(),\n                 Either::Right(pat) => match pat {\n                     ast::Pat::IdentPat(it) => it.name()?.to_string(),\n                     _ => return None,\n                 },\n             };\n-            Some((param_name, arg))\n+            Some((param_name, arg, range))\n         })\n-        .filter(|(param_name, arg)| !should_hide_param_name_hint(sema, &callable, param_name, arg))\n-        .map(|(param_name, arg)| InlayHint {\n-            range: sema.original_range(arg.syntax()).range,\n+        .filter(|(param_name, arg, _)| {\n+            !should_hide_param_name_hint(sema, &callable, param_name, arg)\n+        })\n+        .map(|(param_name, _, FileRange { range, .. })| InlayHint {\n+            range,\n             kind: InlayKind::ParameterHint,\n             label: param_name.into(),\n         });\n@@ -184,25 +190,27 @@ fn get_bind_pat_hints(\n     acc: &mut Vec<InlayHint>,\n     sema: &Semantics<RootDatabase>,\n     config: &InlayHintsConfig,\n-    pat: ast::IdentPat,\n+    pat: &ast::IdentPat,\n ) -> Option<()> {\n     if !config.type_hints {\n         return None;\n     }\n \n-    let krate = sema.scope(pat.syntax()).module().map(|it| it.krate());\n+    let descended = sema.descend_node_into_attributes(pat.clone()).pop();\n+    let desc_pat = descended.as_ref().unwrap_or(pat);\n+    let krate = sema.scope(desc_pat.syntax()).module().map(|it| it.krate());\n     let famous_defs = FamousDefs(sema, krate);\n \n-    let ty = sema.type_of_pat(&pat.clone().into())?.original;\n+    let ty = sema.type_of_pat(&desc_pat.clone().into())?.original;\n \n     if should_not_display_type_hint(sema, &pat, &ty) {\n         return None;\n     }\n \n     acc.push(InlayHint {\n         range: match pat.name() {\n-            Some(name) => sema.original_range(name.syntax()).range,\n-            None => sema.original_range(pat.syntax()).range,\n+            Some(name) => name.syntax().text_range(),\n+            None => pat.syntax().text_range(),\n         },\n         kind: InlayKind::TypeHint,\n         label: hint_iterator(sema, &famous_defs, config, &ty)\n@@ -435,9 +443,13 @@ fn get_callable(\n ) -> Option<(hir::Callable, ast::ArgList)> {\n     match expr {\n         ast::Expr::CallExpr(expr) => {\n+            let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+            let expr = descended.as_ref().unwrap_or(expr);\n             sema.type_of_expr(&expr.expr()?)?.original.as_callable(sema.db).zip(expr.arg_list())\n         }\n         ast::Expr::MethodCallExpr(expr) => {\n+            let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+            let expr = descended.as_ref().unwrap_or(expr);\n             sema.resolve_method_call_as_callable(expr).zip(expr.arg_list())\n         }\n         _ => None,\n@@ -1471,4 +1483,53 @@ fn main() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hints_in_attr_call() {\n+        check_expect(\n+            TEST_CONFIG,\n+            r#\"\n+//- proc_macros: identity, input_replace\n+struct Struct;\n+impl Struct {\n+    fn chain(self) -> Self {\n+        self\n+    }\n+}\n+#[proc_macros::identity]\n+fn main() {\n+    let strukt = Struct;\n+    strukt\n+        .chain()\n+        .chain()\n+        .chain();\n+    Struct::chain(strukt);\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 124..130,\n+                        kind: TypeHint,\n+                        label: \"Struct\",\n+                    },\n+                    InlayHint {\n+                        range: 145..185,\n+                        kind: ChainingHint,\n+                        label: \"Struct\",\n+                    },\n+                    InlayHint {\n+                        range: 145..168,\n+                        kind: ChainingHint,\n+                        label: \"Struct\",\n+                    },\n+                    InlayHint {\n+                        range: 222..228,\n+                        kind: ParameterHint,\n+                        label: \"self\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n }"}]}