{"sha": "e17c48e2f21eefd59748e364234efc7037a3ec96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxN2M0OGUyZjIxZWVmZDU5NzQ4ZTM2NDIzNGVmYzcwMzdhM2VjOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-24T06:59:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-24T06:59:13Z"}, "message": "Auto merge of #58691 - Centril:rollup, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #57364 (Improve parsing diagnostic for negative supertrait bounds)\n - #58183 (Clarify guarantees for `Box` allocation)\n - #58442 (Simplify the unix `Weak` functionality)\n - #58454 (Refactor Windows stdio and remove stdin double buffering )\n - #58511 (Const to op simplification)\n - #58642 (rustdoc: support methods on primitives in intra-doc links)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a989c587e29193df64c07d603037060b3dcefc6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a989c587e29193df64c07d603037060b3dcefc6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e17c48e2f21eefd59748e364234efc7037a3ec96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e17c48e2f21eefd59748e364234efc7037a3ec96", "html_url": "https://github.com/rust-lang/rust/commit/e17c48e2f21eefd59748e364234efc7037a3ec96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e17c48e2f21eefd59748e364234efc7037a3ec96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cb3ee453b829a513749eb49e6cbe7fe4da527b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cb3ee453b829a513749eb49e6cbe7fe4da527b1", "html_url": "https://github.com/rust-lang/rust/commit/7cb3ee453b829a513749eb49e6cbe7fe4da527b1"}, {"sha": "f01ebc56dc9000f0f6507121e6702f83c2b8d2e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f01ebc56dc9000f0f6507121e6702f83c2b8d2e2", "html_url": "https://github.com/rust-lang/rust/commit/f01ebc56dc9000f0f6507121e6702f83c2b8d2e2"}], "stats": {"total": 981, "additions": 583, "deletions": 398}, "files": [{"sha": "f3877e51a6633f2589885ce08015fa5d0da46b85", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -34,6 +34,9 @@ extern \"Rust\" {\n /// This type implements the [`Alloc`] trait by forwarding calls\n /// to the allocator registered with the `#[global_allocator]` attribute\n /// if there is one, or the `std` crate\u2019s default.\n+///\n+/// Note: while this type is unstable, the functionality it provides can be\n+/// accessed through the [free functions in `alloc`](index.html#functions).\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;"}, {"sha": "e99ae6315f830c605c0f76d6f6809bc80f865e27", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -4,6 +4,16 @@\n //! heap allocation in Rust. Boxes provide ownership for this allocation, and\n //! drop their contents when they go out of scope.\n //!\n+//! For non-zero-sized values, a [`Box`] will use the [`Global`] allocator for\n+//! its allocation. It is valid to convert both ways between a [`Box`] and a\n+//! raw pointer allocated with the [`Global`] allocator, given that the\n+//! [`Layout`] used with the allocator is correct for the type. More precisely,\n+//! a `value: *mut T` that has been allocated with the [`Global`] allocator\n+//! with `Layout::for_value(&*value)` may be converted into a box using\n+//! `Box::<T>::from_raw(value)`. Conversely, the memory backing a `value: *mut\n+//! T` obtained from `Box::<T>::into_raw` may be deallocated using the\n+//! [`Global`] allocator with `Layout::for_value(&*value)`.\n+//!\n //! # Examples\n //!\n //! Move a value from the stack to the heap by creating a [`Box`]:"}, {"sha": "cce1273b7f025d0743b29c355061f141e7752960", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -312,7 +312,7 @@ impl_stable_hash_for!(\n     impl<'tcx> for enum mir::interpret::ConstValue<'tcx> [ mir::interpret::ConstValue ] {\n         Scalar(val),\n         Slice(a, b),\n-        ByRef(id, alloc, offset),\n+        ByRef(ptr, alloc),\n     }\n );\n impl_stable_hash_for!(struct crate::mir::interpret::RawConst<'tcx> {"}, {"sha": "956182fc8b275bd680e06f2ac85287deb3cc61ef", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -31,9 +31,9 @@ pub enum ConstValue<'tcx> {\n     /// it.\n     Slice(Scalar, u64),\n \n-    /// An allocation together with an offset into the allocation.\n-    /// Invariant: the `AllocId` matches the allocation.\n-    ByRef(AllocId, &'tcx Allocation, Size),\n+    /// An allocation together with a pointer into the allocation.\n+    /// Invariant: the pointer's `AllocId` resolves to the allocation.\n+    ByRef(Pointer, &'tcx Allocation),\n }\n \n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "a81d5c9d86edd1ae17bbe81fcdf52a26a1dfc25e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -505,8 +505,8 @@ impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n         match *self {\n             ConstValue::Scalar(x) => Some(ConstValue::Scalar(x)),\n             ConstValue::Slice(x, y) => Some(ConstValue::Slice(x, y)),\n-            ConstValue::ByRef(x, alloc, z) => Some(ConstValue::ByRef(\n-                x, alloc.lift_to_tcx(tcx)?, z,\n+            ConstValue::ByRef(ptr, alloc) => Some(ConstValue::ByRef(\n+                ptr, alloc.lift_to_tcx(tcx)?,\n             )),\n         }\n     }"}, {"sha": "4c88d4f0e63ca0aefd03303ec2184999ce3e474c", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -71,7 +71,7 @@ pub fn codegen_static_initializer(\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc = match static_.val {\n-        ConstValue::ByRef(_, alloc, n) if n.bytes() == 0 => alloc,\n+        ConstValue::ByRef(ptr, alloc) if ptr.offset.bytes() == 0 => alloc,\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))"}, {"sha": "3cac1befaf4ef13b83cf918d2ec3a2ad69ed617f", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -101,8 +101,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                 let b_llval = bx.cx().const_usize(b);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef(_, alloc, offset) => {\n-                return Ok(bx.load_operand(bx.cx().from_const_alloc(layout, alloc, offset)));\n+            ConstValue::ByRef(ptr, alloc) => {\n+                return Ok(bx.load_operand(bx.cx().from_const_alloc(layout, alloc, ptr.offset)));\n             },\n         };\n "}, {"sha": "1edcbfead2c94424ca509af15fb458825214bd5d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -417,8 +417,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef(_, alloc, offset) => {\n-                            bx.cx().from_const_alloc(layout, alloc, offset)\n+                        mir::interpret::ConstValue::ByRef(ptr, alloc) => {\n+                            bx.cx().from_const_alloc(layout, alloc, ptr.offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },"}, {"sha": "2f8e3189d12e969f5394031128f4a2def3fe2b90", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -21,7 +21,7 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Operand, Immediate, Scalar, Pointer,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar, Pointer,\n     RawConst, ConstValue,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n@@ -62,45 +62,46 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n     eval_body_using_ecx(&mut ecx, cid, Some(mir), param_env)\n }\n \n-// FIXME: These two conversion functions are bad hacks.  We should just always use allocations.\n-pub fn op_to_const<'tcx>(\n+fn mplace_to_const<'tcx>(\n+    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n+    mplace: MPlaceTy<'tcx>,\n+) -> EvalResult<'tcx, ty::Const<'tcx>> {\n+    let MemPlace { ptr, align, meta } = *mplace;\n+    // extract alloc-offset pair\n+    assert!(meta.is_none());\n+    let ptr = ptr.to_ptr()?;\n+    let alloc = ecx.memory.get(ptr.alloc_id)?;\n+    assert!(alloc.align >= align);\n+    assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= mplace.layout.size.bytes());\n+    let mut alloc = alloc.clone();\n+    alloc.align = align;\n+    // FIXME shouldn't it be the case that `mark_static_initialized` has already\n+    // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n+    let alloc = ecx.tcx.intern_const_alloc(alloc);\n+    let val = ConstValue::ByRef(ptr, alloc);\n+    Ok(ty::Const { val, ty: mplace.layout.ty })\n+}\n+\n+fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n-    may_normalize: bool,\n ) -> EvalResult<'tcx, ty::Const<'tcx>> {\n     // We do not normalize just any data.  Only scalar layout and slices.\n-    let normalize = may_normalize\n-        && match op.layout.abi {\n-            layout::Abi::Scalar(..) => true,\n-            layout::Abi::ScalarPair(..) => op.layout.ty.is_slice(),\n-            _ => false,\n-        };\n+    let normalize = match op.layout.abi {\n+        layout::Abi::Scalar(..) => true,\n+        layout::Abi::ScalarPair(..) => op.layout.ty.is_slice(),\n+        _ => false,\n+    };\n     let normalized_op = if normalize {\n-        ecx.try_read_immediate(op)?\n+        Err(*ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n     } else {\n-        match *op {\n-            Operand::Indirect(mplace) => Err(mplace),\n-            Operand::Immediate(val) => Ok(val)\n-        }\n+        op.try_as_mplace()\n     };\n     let val = match normalized_op {\n-        Err(MemPlace { ptr, align, meta }) => {\n-            // extract alloc-offset pair\n-            assert!(meta.is_none());\n-            let ptr = ptr.to_ptr()?;\n-            let alloc = ecx.memory.get(ptr.alloc_id)?;\n-            assert!(alloc.align >= align);\n-            assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= op.layout.size.bytes());\n-            let mut alloc = alloc.clone();\n-            alloc.align = align;\n-            // FIXME shouldn't it be the case that `mark_static_initialized` has already\n-            // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n-            let alloc = ecx.tcx.intern_const_alloc(alloc);\n-            ConstValue::ByRef(ptr.alloc_id, alloc, ptr.offset)\n-        },\n-        Ok(Immediate::Scalar(x)) =>\n+        Ok(mplace) => return mplace_to_const(ecx, mplace),\n+        Err(Immediate::Scalar(x)) =>\n             ConstValue::Scalar(x.not_undef()?),\n-        Ok(Immediate::ScalarPair(a, b)) =>\n+        Err(Immediate::ScalarPair(a, b)) =>\n             ConstValue::Slice(a.not_undef()?, b.to_usize(ecx)?),\n     };\n     Ok(ty::Const { val, ty: op.layout.ty })\n@@ -476,7 +477,7 @@ pub fn const_field<'a, 'tcx>(\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     let result = (|| {\n         // get the operand again\n-        let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(value), value.ty)?;\n+        let op = ecx.const_to_op(value, None)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -486,7 +487,7 @@ pub fn const_field<'a, 'tcx>(\n         let field = ecx.operand_field(down, field.index() as u64)?;\n         // and finally move back to the const world, always normalizing because\n         // this is not called for statics.\n-        op_to_const(&ecx, field, true)\n+        op_to_const(&ecx, field)\n     })();\n     result.map_err(|error| {\n         let err = error_to_const_error(&ecx, error);\n@@ -502,7 +503,7 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> EvalResult<'tcx, VariantIdx> {\n     trace!(\"const_variant_index: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(val), val.ty)?;\n+    let op = ecx.const_to_op(val, None)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n \n@@ -523,22 +524,23 @@ fn validate_and_turn_into_const<'a, 'tcx>(\n     let cid = key.value;\n     let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env);\n     let val = (|| {\n-        let op = ecx.raw_const_to_mplace(constant)?.into();\n-        // FIXME: Once the visitor infrastructure landed, change validation to\n-        // work directly on `MPlaceTy`.\n-        let mut ref_tracking = RefTracking::new(op);\n-        while let Some((op, path)) = ref_tracking.todo.pop() {\n+        let mplace = ecx.raw_const_to_mplace(constant)?;\n+        let mut ref_tracking = RefTracking::new(mplace);\n+        while let Some((mplace, path)) = ref_tracking.todo.pop() {\n             ecx.validate_operand(\n-                op,\n+                mplace.into(),\n                 path,\n                 Some(&mut ref_tracking),\n                 true, // const mode\n             )?;\n         }\n         // Now that we validated, turn this into a proper constant.\n         let def_id = cid.instance.def.def_id();\n-        let normalize = tcx.is_static(def_id).is_none() && cid.promoted.is_none();\n-        op_to_const(&ecx, op, normalize)\n+        if tcx.is_static(def_id).is_some() || cid.promoted.is_some() {\n+            mplace_to_const(&ecx, mplace)\n+        } else {\n+            op_to_const(&ecx, mplace.into())\n+        }\n     })();\n \n     val.map_err(|error| {"}, {"sha": "10bef53e249c4430993e3581013d81d776b1d11a", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -172,7 +172,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Pointer, Scalar};\n+use rustc::mir::interpret::{ConstValue, Scalar};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -214,9 +214,8 @@ impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n         match (val, &crty.sty, &rty.sty) {\n             // the easy case, deref a reference\n             (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => ConstValue::ByRef(\n-                p.alloc_id,\n+                p,\n                 self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n-                p.offset,\n             ),\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n@@ -1428,15 +1427,14 @@ fn slice_pat_covered_by_const<'tcx>(\n     suffix: &[Pattern<'tcx>]\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n-        (ConstValue::ByRef(id, alloc, offset), ty::Array(t, n)) => {\n+        (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n             if *t != tcx.types.u8 {\n                 // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n                 // any sort of exhaustiveness/unreachable check yet\n                 // This solely means that we don't lint about unreachable patterns, even if some\n                 // are definitely unreachable.\n                 return Ok(false);\n             }\n-            let ptr = Pointer::new(id, offset);\n             let n = n.assert_usize(tcx).unwrap();\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n         },\n@@ -1778,8 +1776,8 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     let (opt_ptr, n, ty) = match value.ty.sty {\n                         ty::TyKind::Array(t, n) => {\n                             match value.val {\n-                                ConstValue::ByRef(id, alloc, offset) => (\n-                                    Some((Pointer::new(id, offset), alloc)),\n+                                ConstValue::ByRef(ptr, alloc) => (\n+                                    Some((ptr, alloc)),\n                                     n.unwrap_usize(cx.tcx),\n                                     t,\n                                 ),"}, {"sha": "474df457f61a2826a9c799599b4835ab932b2aff", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 40, "deletions": 48, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::interpret::{\n     sign_extend, truncate,\n };\n use super::{\n-    EvalContext, Machine, AllocMap, Allocation, AllocationExtra,\n+    EvalContext, Machine,\n     MemPlace, MPlaceTy, PlaceTy, Place, MemoryKind,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -270,7 +270,7 @@ pub(super) fn from_known_layout<'tcx>(\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for ScalarPair.\n     /// Returns `None` if the layout does not permit loading this as a value.\n-    pub(super) fn try_read_immediate_from_mplace(\n+    fn try_read_immediate_from_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, Option<Immediate<M::PointerTag>>> {\n@@ -324,7 +324,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Note that for a given layout, this operation will either always fail or always\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n     /// in a `Immediate`, not on which data is stored there currently.\n-    pub(crate) fn try_read_immediate(\n+    pub(super) fn try_read_immediate(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, Result<Immediate<M::PointerTag>, MemPlace<M::PointerTag>>> {\n@@ -509,7 +509,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     // Evaluate a place with the goal of reading from it.  This lets us sometimes\n     // avoid allocations.\n-    fn eval_place_to_op(\n+    pub(super) fn eval_place_to_op(\n         &self,\n         mir_place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n@@ -546,14 +546,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             Move(ref place) =>\n                 self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => {\n-                let layout = from_known_layout(layout, || {\n-                    let ty = self.monomorphize(mir_op.ty(self.mir(), *self.tcx))?;\n-                    self.layout_of(ty)\n-                })?;\n-                let op = self.const_value_to_op(*constant.literal)?;\n-                OpTy { op, layout }\n-            }\n+            Constant(ref constant) => self.eval_lazy_const_to_op(*constant.literal, layout)?,\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n         Ok(op)\n@@ -569,38 +562,56 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             .collect()\n     }\n \n-    // Used when Miri runs into a constant, and (indirectly through lazy_const_to_op) by CTFE.\n-    fn const_value_to_op(\n+    // Used when Miri runs into a constant, and by const propagation.\n+    crate fn eval_lazy_const_to_op(\n         &self,\n         val: ty::LazyConst<'tcx>,\n-    ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n-        trace!(\"const_value_to_op: {:?}\", val);\n-        let val = match val {\n+        layout: Option<TyLayout<'tcx>>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        trace!(\"const_to_op: {:?}\", val);\n+        match val {\n             ty::LazyConst::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                return Ok(*OpTy::from(self.const_eval_raw(GlobalId {\n+                return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: None,\n                 })?));\n             },\n-            ty::LazyConst::Evaluated(c) => c,\n-        };\n-        match val.val {\n-            ConstValue::ByRef(id, alloc, offset) => {\n+            ty::LazyConst::Evaluated(c) => self.const_to_op(c, layout),\n+        }\n+    }\n+\n+    // Used when the miri-engine runs into a constant and for extracting information from constants\n+    // in patterns via the `const_eval` module\n+    crate fn const_to_op(\n+        &self,\n+        val: ty::Const<'tcx>,\n+        layout: Option<TyLayout<'tcx>>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        let layout = from_known_layout(layout, || {\n+            let ty = self.monomorphize(val.ty)?;\n+            self.layout_of(ty)\n+        })?;\n+        let op = match val.val {\n+            ConstValue::ByRef(ptr, alloc) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway.\n-                Ok(Operand::Indirect(\n-                    MemPlace::from_ptr(Pointer::new(id, offset), alloc.align)\n-                ).with_default_tag())\n+                Operand::Indirect(\n+                    MemPlace::from_ptr(ptr, alloc.align)\n+                ).with_default_tag()\n             },\n             ConstValue::Slice(a, b) =>\n-                Ok(Operand::Immediate(Immediate::ScalarPair(\n+                Operand::Immediate(Immediate::ScalarPair(\n                     a.into(),\n                     Scalar::from_uint(b, self.tcx.data_layout.pointer_size).into(),\n-                )).with_default_tag()),\n+                )).with_default_tag(),\n             ConstValue::Scalar(x) =>\n-                Ok(Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag()),\n-        }\n+                Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag(),\n+        };\n+        Ok(OpTy {\n+            op,\n+            layout,\n+        })\n     }\n \n     /// Read discriminant, return the runtime value as well as the variant index.\n@@ -697,23 +708,4 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n         })\n     }\n-\n-}\n-\n-impl<'a, 'mir, 'tcx, M> EvalContext<'a, 'mir, 'tcx, M>\n-where\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=()>,\n-    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<(), M::AllocExtra>)>,\n-    M::AllocExtra: AllocationExtra<(), M::MemoryExtra>,\n-{\n-    // FIXME: CTFE should use allocations, then we can remove this.\n-    pub(crate) fn lazy_const_to_op(\n-        &self,\n-        cnst: ty::LazyConst<'tcx>,\n-        ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n-        let op = self.const_value_to_op(cnst)?;\n-        Ok(OpTy { op, layout: self.layout_of(ty)? })\n-    }\n }"}, {"sha": "7b66d11131c13fdd09ae365fd491f78ca7533ca2", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -59,7 +59,7 @@ impl<'tcx, Tag> ::std::ops::Deref for PlaceTy<'tcx, Tag> {\n }\n \n /// A MemPlace with its layout. Constructing it is only possible in this module.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n pub struct MPlaceTy<'tcx, Tag=()> {\n     mplace: MemPlace<Tag>,\n     pub layout: TyLayout<'tcx>,"}, {"sha": "656c13c16d9edac1ff96f0bec5933adba795c04d", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -266,8 +266,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             Discriminant(ref place) => {\n-                let place = self.eval_place(place)?;\n-                let discr_val = self.read_discriminant(self.place_to_op(place)?)?.0;\n+                let op = self.eval_place_to_op(place, None)?;\n+                let discr_val = self.read_discriminant(op)?.0;\n                 let size = dest.layout.size;\n                 self.write_scalar(Scalar::from_uint(discr_val, size), dest)?;\n             }"}, {"sha": "252e8bac2a3f8c1c5c9a79ff1037de488f1b9020", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    OpTy, Machine, EvalContext, ValueVisitor,\n+    OpTy, Machine, EvalContext, ValueVisitor, MPlaceTy,\n };\n \n macro_rules! validation_failure {\n@@ -74,13 +74,13 @@ pub enum PathElem {\n }\n \n /// State for tracking recursive validation of references\n-pub struct RefTracking<'tcx, Tag> {\n-    pub seen: FxHashSet<(OpTy<'tcx, Tag>)>,\n-    pub todo: Vec<(OpTy<'tcx, Tag>, Vec<PathElem>)>,\n+pub struct RefTracking<T> {\n+    pub seen: FxHashSet<T>,\n+    pub todo: Vec<(T, Vec<PathElem>)>,\n }\n \n-impl<'tcx, Tag: Copy+Eq+Hash> RefTracking<'tcx, Tag> {\n-    pub fn new(op: OpTy<'tcx, Tag>) -> Self {\n+impl<'tcx, T: Copy + Eq + Hash> RefTracking<T> {\n+    pub fn new(op: T) -> Self {\n         let mut ref_tracking = RefTracking {\n             seen: FxHashSet::default(),\n             todo: vec![(op, Vec::new())],\n@@ -151,7 +151,7 @@ struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking: Option<&'rt mut RefTracking<'tcx, M::PointerTag>>,\n+    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n     const_mode: bool,\n     ecx: &'rt EvalContext<'a, 'mir, 'tcx, M>,\n }\n@@ -401,16 +401,15 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     // before.  Proceed recursively even for integer pointers, no\n                     // reason to skip them! They are (recursively) valid for some ZST,\n                     // but not for others (e.g., `!` is a ZST).\n-                    let op = place.into();\n-                    if ref_tracking.seen.insert(op) {\n-                        trace!(\"Recursing below ptr {:#?}\", *op);\n+                    if ref_tracking.seen.insert(place) {\n+                        trace!(\"Recursing below ptr {:#?}\", *place);\n                         // We need to clone the path anyway, make sure it gets created\n                         // with enough space for the additional `Deref`.\n                         let mut new_path = Vec::with_capacity(self.path.len()+1);\n                         new_path.clone_from(&self.path);\n                         new_path.push(PathElem::Deref);\n                         // Remember to come back to this later.\n-                        ref_tracking.todo.push((op, new_path));\n+                        ref_tracking.todo.push((place, new_path));\n                     }\n                 }\n             }\n@@ -600,7 +599,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n+        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n         const_mode: bool,\n     ) -> EvalResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);"}, {"sha": "dd7158897b889fb037739645410e0cfb645c8626", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -1260,7 +1260,7 @@ fn collect_const<'a, 'tcx>(\n         ConstValue::Slice(Scalar::Ptr(ptr), _) |\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n-        ConstValue::ByRef(_id, alloc, _offset) => {\n+        ConstValue::ByRef(_ptr, alloc) => {\n             for &((), id) in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}, {"sha": "1acc7b6e0c57fe2cc295a4a908473a767968c512", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match self.ecx.lazy_const_to_op(*c.literal, c.ty) {\n+        match self.ecx.eval_lazy_const_to_op(*c.literal, None) {\n             Ok(op) => {\n                 Some((op, c.span))\n             },"}, {"sha": "3fe73e78bba836472aee89357a0577356b9e2249", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -1461,7 +1461,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt, id: DefId, span: Span) {\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n     if let Ok(static_) = tcx.const_eval(param_env.and(cid)) {\n-        let alloc = if let ConstValue::ByRef(_, allocation, _) = static_.val {\n+        let alloc = if let ConstValue::ByRef(_, allocation) = static_.val {\n             allocation\n         } else {\n             bug!(\"Matching on non-ByRef static\")"}, {"sha": "03dff108770413c0959f4c24fbf8d6eb3a468bfc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -976,11 +976,13 @@ impl Attributes {\n                                 \"https://doc.rust-lang.org/nightly\",\n                         };\n                         // This is a primitive so the url is done \"by hand\".\n+                        let tail = fragment.find('#').unwrap_or_else(|| fragment.len());\n                         Some((s.clone(),\n-                              format!(\"{}{}std/primitive.{}.html\",\n+                              format!(\"{}{}std/primitive.{}.html{}\",\n                                       url,\n                                       if !url.ends_with('/') { \"/\" } else { \"\" },\n-                                      fragment)))\n+                                      &fragment[..tail],\n+                                      &fragment[tail..])))\n                     } else {\n                         panic!(\"This isn't a primitive?!\");\n                     }"}, {"sha": "42fa3e2006b42320e3fcb19163ba30d7cc36ec09", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -1,6 +1,7 @@\n use rustc::lint as lint;\n use rustc::hir;\n use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n use rustc::ty;\n use syntax;\n use syntax::ast::{self, Ident, NodeId};\n@@ -126,6 +127,17 @@ impl<'a, 'tcx, 'rcx> LinkCollector<'a, 'tcx, 'rcx> {\n                     path = name.clone();\n                 }\n             }\n+            if let Some(prim) = is_primitive(&path, false) {\n+                let did = primitive_impl(cx, &path).ok_or(())?;\n+                return cx.tcx.associated_items(did)\n+                    .find(|item| item.ident.name == item_name)\n+                    .and_then(|item| match item.kind {\n+                        ty::AssociatedKind::Method => Some(\"method\"),\n+                        _ => None,\n+                    })\n+                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))))\n+                    .ok_or(());\n+            }\n \n             // FIXME: `with_scope` requires the `NodeId` of a module.\n             let ty = cx.resolver.borrow_mut()\n@@ -589,3 +601,26 @@ fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {\n         PRIMITIVES.iter().find(|x| x.0 == path_str).map(|x| x.1)\n     }\n }\n+\n+fn primitive_impl(cx: &DocContext<'_, '_, '_>, path_str: &str) -> Option<DefId> {\n+    let tcx = cx.tcx;\n+    match path_str {\n+        \"u8\" => tcx.lang_items().u8_impl(),\n+        \"u16\" => tcx.lang_items().u16_impl(),\n+        \"u32\" => tcx.lang_items().u32_impl(),\n+        \"u64\" => tcx.lang_items().u64_impl(),\n+        \"u128\" => tcx.lang_items().u128_impl(),\n+        \"usize\" => tcx.lang_items().usize_impl(),\n+        \"i8\" => tcx.lang_items().i8_impl(),\n+        \"i16\" => tcx.lang_items().i16_impl(),\n+        \"i32\" => tcx.lang_items().i32_impl(),\n+        \"i64\" => tcx.lang_items().i64_impl(),\n+        \"i128\" => tcx.lang_items().i128_impl(),\n+        \"isize\" => tcx.lang_items().isize_impl(),\n+        \"f32\" => tcx.lang_items().f32_impl(),\n+        \"f64\" => tcx.lang_items().f64_impl(),\n+        \"str\" => tcx.lang_items().str_impl(),\n+        \"char\" => tcx.lang_items().char_impl(),\n+        _ => None,\n+    }\n+}"}, {"sha": "81d79213f615cd583abf1392541a43158dc0b7cc", "filename": "src/libstd/sys/cloudabi/stdio.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -9,8 +9,10 @@ impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n         Ok(Stdin(()))\n     }\n+}\n \n-    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+impl io::Read for Stdin {\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n         Ok(0)\n     }\n }\n@@ -19,15 +21,17 @@ impl Stdout {\n     pub fn new() -> io::Result<Stdout> {\n         Ok(Stdout(()))\n     }\n+}\n \n-    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stdout {\n+    fn write(&mut self, _buf: &[u8]) -> io::Result<usize> {\n         Err(io::Error::new(\n             io::ErrorKind::BrokenPipe,\n             \"Stdout is not connected to any output in this environment\",\n         ))\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n }\n@@ -36,29 +40,18 @@ impl Stderr {\n     pub fn new() -> io::Result<Stderr> {\n         Ok(Stderr(()))\n     }\n+}\n \n-    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stderr {\n+    fn write(&mut self, _buf: &[u8]) -> io::Result<usize> {\n         Err(io::Error::new(\n             io::ErrorKind::BrokenPipe,\n             \"Stderr is not connected to any output in this environment\",\n         ))\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n-impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n-    }\n-\n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        Ok(())\n     }\n }\n "}, {"sha": "8571b38cefa1c53acb86b2149d283309b1dab59e", "filename": "src/libstd/sys/redox/stdio.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -8,55 +8,48 @@ pub struct Stderr(());\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+}\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(0);\n-        let ret = fd.read(data);\n+        let ret = fd.read(buf);\n         fd.into_raw();\n         ret\n     }\n }\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(1);\n-        let ret = fd.write(data);\n+        let ret = fd.write(buf);\n         fd.into_raw();\n         ret\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         cvt(syscall::fsync(1)).and(Ok(()))\n     }\n }\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(2);\n-        let ret = fd.write(data);\n+        let ret = fd.write(buf);\n         fd.into_raw();\n         ret\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        cvt(syscall::fsync(2)).and(Ok(()))\n-    }\n-}\n-\n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n-impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n-    }\n-\n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        cvt(syscall::fsync(2)).and(Ok(()))\n     }\n }\n "}, {"sha": "57d66ed9a853c7dc3690b0e708af347221de4bbe", "filename": "src/libstd/sys/sgx/stdio.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -16,46 +16,39 @@ fn with_std_fd<F: FnOnce(&FileDesc) -> R, R>(fd: abi::Fd, f: F) -> R {\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+}\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n-        with_std_fd(abi::FD_STDIN, |fd| fd.read(data))\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        with_std_fd(abi::FD_STDIN, |fd| fd.read(buf))\n     }\n }\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        with_std_fd(abi::FD_STDOUT, |fd| fd.write(data))\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        with_std_fd(abi::FD_STDOUT, |fd| fd.write(buf))\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         with_std_fd(abi::FD_STDOUT, |fd| fd.flush())\n     }\n }\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n-\n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        with_std_fd(abi::FD_STDERR, |fd| fd.write(data))\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n-        with_std_fd(abi::FD_STDERR, |fd| fd.flush())\n-    }\n }\n \n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        with_std_fd(abi::FD_STDERR, |fd| fd.write(buf))\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        with_std_fd(abi::FD_STDERR, |fd| fd.flush())\n     }\n }\n "}, {"sha": "56b75bf9f7931954cd1c9d0e0c52f0485a7a3f30", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -8,55 +8,48 @@ pub struct Stderr(());\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+}\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(libc::STDIN_FILENO);\n-        let ret = fd.read(data);\n+        let ret = fd.read(buf);\n         fd.into_raw(); // do not close this FD\n         ret\n     }\n }\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(libc::STDOUT_FILENO);\n-        let ret = fd.write(data);\n+        let ret = fd.write(buf);\n         fd.into_raw(); // do not close this FD\n         ret\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n }\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(libc::STDERR_FILENO);\n-        let ret = fd.write(data);\n+        let ret = fd.write(buf);\n         fd.into_raw(); // do not close this FD\n         ret\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n-impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n-    }\n-\n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        Ok(())\n     }\n }\n "}, {"sha": "b60e241f10ceee698ddfcf65acbad46ae76b967f", "filename": "src/libstd/sys/unix/weak.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fweak.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -18,15 +18,15 @@\n \n use libc;\n \n-use ffi::CString;\n+use ffi::CStr;\n use marker;\n use mem;\n use sync::atomic::{AtomicUsize, Ordering};\n \n macro_rules! weak {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n         static $name: ::sys::weak::Weak<unsafe extern fn($($t),*) -> $ret> =\n-            ::sys::weak::Weak::new(stringify!($name));\n+            ::sys::weak::Weak::new(concat!(stringify!($name), '\\0'));\n     )\n }\n \n@@ -45,23 +45,22 @@ impl<F> Weak<F> {\n         }\n     }\n \n-    pub fn get(&self) -> Option<&F> {\n+    pub fn get(&self) -> Option<F> {\n         assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n         unsafe {\n             if self.addr.load(Ordering::SeqCst) == 1 {\n                 self.addr.store(fetch(self.name), Ordering::SeqCst);\n             }\n-            if self.addr.load(Ordering::SeqCst) == 0 {\n-                None\n-            } else {\n-                mem::transmute::<&AtomicUsize, Option<&F>>(&self.addr)\n+            match self.addr.load(Ordering::SeqCst) {\n+                0 => None,\n+                addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n             }\n         }\n     }\n }\n \n unsafe fn fetch(name: &str) -> usize {\n-    let name = match CString::new(name) {\n+    let name = match CStr::from_bytes_with_nul(name.as_bytes()) {\n         Ok(cstr) => cstr,\n         Err(..) => return 0,\n     };"}, {"sha": "d7540fd815c98b01b3bd1590e02d0ee3ea27ce62", "filename": "src/libstd/sys/wasm/stdio.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -9,23 +9,27 @@ impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n         Ok(Stdin)\n     }\n+}\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n-        Ok(ReadSysCall::perform(0, data))\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        Ok(ReadSysCall::perform(0, buf))\n     }\n }\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> {\n         Ok(Stdout)\n     }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(1, data);\n-        Ok(data.len())\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        WriteSysCall::perform(1, buf);\n+        Ok(buf.len())\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n }\n@@ -34,23 +38,16 @@ impl Stderr {\n     pub fn new() -> io::Result<Stderr> {\n         Ok(Stderr)\n     }\n-\n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(2, data);\n-        Ok(data.len())\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n }\n \n impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        (&*self).write(data)\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        WriteSysCall::perform(2, buf);\n+        Ok(buf.len())\n     }\n+\n     fn flush(&mut self) -> io::Result<()> {\n-        (&*self).flush()\n+        Ok(())\n     }\n }\n "}, {"sha": "2527168a968c47a5be151a453ad7e69042eed8f4", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -252,9 +252,9 @@ impl Stdio {\n             // should still be unavailable so propagate the\n             // INVALID_HANDLE_VALUE.\n             Stdio::Inherit => {\n-                match stdio::get(stdio_id) {\n+                match stdio::get_handle(stdio_id) {\n                     Ok(io) => {\n-                        let io = Handle::new(io.handle());\n+                        let io = Handle::new(io);\n                         let ret = io.duplicate(0, true,\n                                                c::DUPLICATE_SAME_ACCESS);\n                         io.into_raw();"}, {"sha": "99445f4e0d45de75f363258927b791b5d316b0d6", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 205, "deletions": 142, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -1,220 +1,283 @@\n #![unstable(issue = \"0\", feature = \"windows_stdio\")]\n \n-use io::prelude::*;\n-\n+use char::decode_utf16;\n use cmp;\n-use io::{self, Cursor};\n+use io;\n use ptr;\n use str;\n-use sync::Mutex;\n use sys::c;\n use sys::cvt;\n use sys::handle::Handle;\n \n-pub enum Output {\n-    Console(c::HANDLE),\n-    Pipe(c::HANDLE),\n-}\n-\n+// Don't cache handles but get them fresh for every read/write. This allows us to track changes to\n+// the value over time (such as if a process calls `SetStdHandle` while it's running). See #40490.\n pub struct Stdin {\n-    utf8: Mutex<io::Cursor<Vec<u8>>>,\n+    surrogate: u16,\n }\n pub struct Stdout;\n pub struct Stderr;\n \n-pub fn get(handle: c::DWORD) -> io::Result<Output> {\n-    let handle = unsafe { c::GetStdHandle(handle) };\n+// Apparently Windows doesn't handle large reads on stdin or writes to stdout/stderr well (see\n+// #13304 for details).\n+//\n+// From MSDN (2011): \"The storage for this buffer is allocated from a shared heap for the\n+// process that is 64 KB in size. The maximum size of the buffer will depend on heap usage.\"\n+//\n+// We choose the cap at 8 KiB because libuv does the same, and it seems to be acceptable so far.\n+const MAX_BUFFER_SIZE: usize = 8192;\n+\n+// The standard buffer size of BufReader for Stdin should be able to hold 3x more bytes than there\n+// are `u16`'s in MAX_BUFFER_SIZE. This ensures the read data can always be completely decoded from\n+// UTF-16 to UTF-8.\n+pub const STDIN_BUF_SIZE: usize = MAX_BUFFER_SIZE / 2 * 3;\n+\n+pub fn get_handle(handle_id: c::DWORD) -> io::Result<c::HANDLE> {\n+    let handle = unsafe { c::GetStdHandle(handle_id) };\n     if handle == c::INVALID_HANDLE_VALUE {\n         Err(io::Error::last_os_error())\n     } else if handle.is_null() {\n         Err(io::Error::from_raw_os_error(c::ERROR_INVALID_HANDLE as i32))\n     } else {\n-        let mut out = 0;\n-        match unsafe { c::GetConsoleMode(handle, &mut out) } {\n-            0 => Ok(Output::Pipe(handle)),\n-            _ => Ok(Output::Console(handle)),\n-        }\n+        Ok(handle)\n     }\n }\n \n-fn write(handle: c::DWORD, data: &[u8]) -> io::Result<usize> {\n-    let handle = match get(handle)? {\n-        Output::Console(c) => c,\n-        Output::Pipe(p) => {\n-            let handle = Handle::new(p);\n-            let ret = handle.write(data);\n-            handle.into_raw();\n-            return ret\n-        }\n-    };\n+fn is_console(handle: c::HANDLE) -> bool {\n+    // `GetConsoleMode` will return false (0) if this is a pipe (we don't care about the reported\n+    // mode). This will only detect Windows Console, not other terminals connected to a pipe like\n+    // MSYS. Which is exactly what we need, as only Windows Console needs a conversion to UTF-16.\n+    let mut mode = 0;\n+    unsafe { c::GetConsoleMode(handle, &mut mode) != 0 }\n+}\n \n-    // As with stdin on windows, stdout often can't handle writes of large\n-    // sizes. For an example, see #14940. For this reason, don't try to\n-    // write the entire output buffer on windows.\n-    //\n-    // For some other references, it appears that this problem has been\n-    // encountered by others [1] [2]. We choose the number 8K just because\n-    // libuv does the same.\n+fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n+    let handle = get_handle(handle_id)?;\n+    if !is_console(handle) {\n+        let handle = Handle::new(handle);\n+        let ret = handle.write(data);\n+        handle.into_raw(); // Don't close the handle\n+        return ret;\n+    }\n+\n+    // As the console is meant for presenting text, we assume bytes of `data` come from a string\n+    // and are encoded as UTF-8, which needs to be encoded as UTF-16.\n     //\n-    // [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n-    // [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n-    const OUT_MAX: usize = 8192;\n-    let len = cmp::min(data.len(), OUT_MAX);\n+    // If the data is not valid UTF-8 we write out as many bytes as are valid.\n+    // Only when there are no valid bytes (which will happen on the next call), return an error.\n+    let len = cmp::min(data.len(), MAX_BUFFER_SIZE / 2);\n     let utf8 = match str::from_utf8(&data[..len]) {\n         Ok(s) => s,\n-        Err(ref e) if e.valid_up_to() == 0 => return Err(invalid_encoding()),\n+        Err(ref e) if e.valid_up_to() == 0 => {\n+            return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\"))\n+        },\n         Err(e) => str::from_utf8(&data[..e.valid_up_to()]).unwrap(),\n     };\n-    let utf16 = utf8.encode_utf16().collect::<Vec<u16>>();\n+    let mut utf16 = [0u16; MAX_BUFFER_SIZE / 2];\n+    let mut len_utf16 = 0;\n+    for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n+        *dest = chr;\n+        len_utf16 += 1;\n+    }\n+    let utf16 = &utf16[..len_utf16];\n+\n+    let mut written = write_u16s(handle, &utf16)?;\n+\n+    // Figure out how many bytes of as UTF-8 were written away as UTF-16.\n+    if written == utf16.len() {\n+        Ok(utf8.len())\n+    } else {\n+        // Make sure we didn't end up writing only half of a surrogate pair (even though the chance\n+        // is tiny). Because it is not possible for user code to re-slice `data` in such a way that\n+        // a missing surrogate can be produced (and also because of the UTF-8 validation above),\n+        // write the missing surrogate out now.\n+        // Buffering it would mean we have to lie about the number of bytes written.\n+        let first_char_remaining = utf16[written];\n+        if first_char_remaining >= 0xDCEE && first_char_remaining <= 0xDFFF { // low surrogate\n+            // We just hope this works, and give up otherwise\n+            let _ = write_u16s(handle, &utf16[written..written+1]);\n+            written += 1;\n+        }\n+        // Calculate the number of bytes of `utf8` that were actually written.\n+        let mut count = 0;\n+        for ch in utf16[..written].iter() {\n+            count += match ch {\n+                0x0000 ..= 0x007F => 1,\n+                0x0080 ..= 0x07FF => 2,\n+                0xDCEE ..= 0xDFFF => 1, // Low surrogate. We already counted 3 bytes for the other.\n+                _ => 3,\n+            };\n+        }\n+        debug_assert!(String::from_utf16(&utf16[..written]).unwrap() == utf8[..count]);\n+        Ok(count)\n+    }\n+}\n+\n+fn write_u16s(handle: c::HANDLE, data: &[u16]) -> io::Result<usize> {\n     let mut written = 0;\n     cvt(unsafe {\n         c::WriteConsoleW(handle,\n-                         utf16.as_ptr() as c::LPCVOID,\n-                         utf16.len() as u32,\n+                         data.as_ptr() as c::LPCVOID,\n+                         data.len() as u32,\n                          &mut written,\n                          ptr::null_mut())\n     })?;\n-\n-    // FIXME if this only partially writes the utf16 buffer then we need to\n-    //       figure out how many bytes of `data` were actually written\n-    assert_eq!(written as usize, utf16.len());\n-    Ok(utf8.len())\n+    Ok(written as usize)\n }\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n-        Ok(Stdin {\n-            utf8: Mutex::new(Cursor::new(Vec::new())),\n-        })\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let handle = match get(c::STD_INPUT_HANDLE)? {\n-            Output::Console(c) => c,\n-            Output::Pipe(p) => {\n-                let handle = Handle::new(p);\n-                let ret = handle.read(buf);\n-                handle.into_raw();\n-                return ret\n-            }\n-        };\n-        let mut utf8 = self.utf8.lock().unwrap();\n-        // Read more if the buffer is empty\n-        if utf8.position() as usize == utf8.get_ref().len() {\n-            let mut utf16 = vec![0u16; 0x1000];\n-            let mut num = 0;\n-            let mut input_control = readconsole_input_control(CTRL_Z_MASK);\n-            cvt(unsafe {\n-                c::ReadConsoleW(handle,\n-                                utf16.as_mut_ptr() as c::LPVOID,\n-                                utf16.len() as u32,\n-                                &mut num,\n-                                &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL)\n-            })?;\n-            utf16.truncate(num as usize);\n-            // FIXME: what to do about this data that has already been read?\n-            let mut data = match String::from_utf16(&utf16) {\n-                Ok(utf8) => utf8.into_bytes(),\n-                Err(..) => return Err(invalid_encoding()),\n-            };\n-            if let Some(&last_byte) = data.last() {\n-                if last_byte == CTRL_Z {\n-                    data.pop();\n-                }\n-            }\n-            *utf8 = Cursor::new(data);\n-        }\n-\n-        // MemReader shouldn't error here since we just filled it\n-        utf8.read(buf)\n+        Ok(Stdin { surrogate: 0 })\n     }\n }\n \n-#[unstable(reason = \"not public\", issue = \"0\", feature = \"fd_read\")]\n-impl<'a> Read for &'a Stdin {\n+impl io::Read for Stdin {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        (**self).read(buf)\n+        let handle = get_handle(c::STD_INPUT_HANDLE)?;\n+        if !is_console(handle) {\n+            let handle = Handle::new(handle);\n+            let ret = handle.read(buf);\n+            handle.into_raw(); // Don't close the handle\n+            return ret;\n+        }\n+\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        } else if buf.len() < 4 {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                        \"Windows stdin in console mode does not support a buffer too small to \\\n+                        guarantee holding one arbitrary UTF-8 character (4 bytes)\"))\n+        }\n+\n+        let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n+        // In the worst case, an UTF-8 string can take 3 bytes for every `u16` of an UTF-16. So\n+        // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n+        // lost.\n+        let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n+        let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n+\n+        utf16_to_utf8(&utf16_buf[..read], buf)\n     }\n }\n \n-impl Stdout {\n-    pub fn new() -> io::Result<Stdout> {\n-        Ok(Stdout)\n-    }\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        write(c::STD_OUTPUT_HANDLE, data)\n+// We assume that if the last `u16` is an unpaired surrogate they got sliced apart by our\n+// buffer size, and keep it around for the next read hoping to put them together.\n+// This is a best effort, and may not work if we are not the only reader on Stdin.\n+fn read_u16s_fixup_surrogates(handle: c::HANDLE,\n+                              buf: &mut [u16],\n+                              mut amount: usize,\n+                              surrogate: &mut u16) -> io::Result<usize>\n+{\n+    // Insert possibly remaining unpaired surrogate from last read.\n+    let mut start = 0;\n+    if *surrogate != 0 {\n+        buf[0] = *surrogate;\n+        *surrogate = 0;\n+        start = 1;\n+        if amount == 1 {\n+            // Special case: `Stdin::read` guarantees we can always read at least one new `u16`\n+            // and combine it with an unpaired surrogate, because the UTF-8 buffer is at least\n+            // 4 bytes.\n+            amount = 2;\n+        }\n     }\n+    let mut amount = read_u16s(handle, &mut buf[start..amount])? + start;\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n+    if amount > 0 {\n+        let last_char = buf[amount - 1];\n+        if last_char >= 0xD800 && last_char <= 0xDBFF { // high surrogate\n+            *surrogate = last_char;\n+            amount -= 1;\n+        }\n     }\n+    Ok(amount)\n }\n \n-impl Stderr {\n-    pub fn new() -> io::Result<Stderr> {\n-        Ok(Stderr)\n+fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n+    // Configure the `pInputControl` parameter to not only return on `\\r\\n` but also Ctrl-Z, the\n+    // traditional DOS method to indicate end of character stream / user input (SUB).\n+    // See #38274 and https://stackoverflow.com/questions/43836040/win-api-readconsole.\n+    const CTRL_Z: u16 = 0x1A;\n+    const CTRL_Z_MASK: c::ULONG = 1 << CTRL_Z;\n+    let mut input_control = c::CONSOLE_READCONSOLE_CONTROL {\n+        nLength: ::mem::size_of::<c::CONSOLE_READCONSOLE_CONTROL>() as c::ULONG,\n+        nInitialChars: 0,\n+        dwCtrlWakeupMask: CTRL_Z_MASK,\n+        dwControlKeyState: 0,\n+    };\n+\n+    let mut amount = 0;\n+    cvt(unsafe {\n+        c::ReadConsoleW(handle,\n+                        buf.as_mut_ptr() as c::LPVOID,\n+                        buf.len() as u32,\n+                        &mut amount,\n+                        &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL)\n+    })?;\n+\n+    if amount > 0 && buf[amount as usize - 1] == CTRL_Z {\n+        amount -= 1;\n     }\n+    Ok(amount as usize)\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        write(c::STD_ERROR_HANDLE, data)\n+#[allow(unused)]\n+fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n+    let mut written = 0;\n+    for chr in decode_utf16(utf16.iter().cloned()) {\n+        match chr {\n+            Ok(chr) => {\n+                chr.encode_utf8(&mut utf8[written..]);\n+                written += chr.len_utf8();\n+            }\n+            Err(_) => {\n+                // We can't really do any better than forget all data and return an error.\n+                return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n+                    encountered unpaired surrogate\"))\n+            }\n+        }\n     }\n+    Ok(written)\n+}\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout)\n     }\n }\n \n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n-impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        write(c::STD_OUTPUT_HANDLE, buf)\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        Ok(())\n     }\n }\n \n-impl Output {\n-    pub fn handle(&self) -> c::HANDLE {\n-        match *self {\n-            Output::Console(c) => c,\n-            Output::Pipe(c) => c,\n-        }\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr)\n     }\n }\n \n-fn invalid_encoding() -> io::Error {\n-    io::Error::new(io::ErrorKind::InvalidData,\n-                   \"Windows stdio in console mode does not support non-UTF-8 byte sequences; \\\n-                    see https://github.com/rust-lang/rust/issues/23344\")\n-}\n+impl io::Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        write(c::STD_ERROR_HANDLE, buf)\n+    }\n \n-fn readconsole_input_control(wakeup_mask: c::ULONG) -> c::CONSOLE_READCONSOLE_CONTROL {\n-    c::CONSOLE_READCONSOLE_CONTROL {\n-        nLength: ::mem::size_of::<c::CONSOLE_READCONSOLE_CONTROL>() as c::ULONG,\n-        nInitialChars: 0,\n-        dwCtrlWakeupMask: wakeup_mask,\n-        dwControlKeyState: 0,\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n     }\n }\n \n-const CTRL_Z: u8 = 0x1A;\n-const CTRL_Z_MASK: c::ULONG = 0x4000000; //1 << 0x1A\n-\n pub fn is_ebadf(err: &io::Error) -> bool {\n     err.raw_os_error() == Some(c::ERROR_INVALID_HANDLE as i32)\n }\n \n-// The default buffer capacity is 64k, but apparently windows\n-// doesn't like 64k reads on stdin. See #13304 for details, but the\n-// idea is that on windows we use a slightly smaller buffer that's\n-// been seen to be acceptable.\n-pub const STDIN_BUF_SIZE: usize = 8 * 1024;\n-\n pub fn panic_output() -> Option<impl io::Write> {\n     Stderr::new().ok()\n }"}, {"sha": "7e900dfeb1eeb1040eae25390c66c3c4fc3155da", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 59, "deletions": 21, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -1733,7 +1733,7 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.eat_keyword(keywords::Impl) {\n             // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_generic_bounds()?;\n+            let bounds = self.parse_generic_bounds(None)?;\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n         } else if self.check_keyword(keywords::Dyn) &&\n@@ -1742,13 +1742,13 @@ impl<'a> Parser<'a> {\n                                           !can_continue_type_after_non_fn_ident(t))) {\n             self.bump(); // `dyn`\n             // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_generic_bounds()?;\n+            let bounds = self.parse_generic_bounds(None)?;\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn)\n         } else if self.check(&token::Question) ||\n                   self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus()) {\n             // Bound list (trait object type)\n-            TyKind::TraitObject(self.parse_generic_bounds_common(allow_plus)?,\n+            TyKind::TraitObject(self.parse_generic_bounds_common(allow_plus, None)?,\n                                 TraitObjectSyntax::None)\n         } else if self.eat_lt() {\n             // Qualified path\n@@ -1794,7 +1794,7 @@ impl<'a> Parser<'a> {\n         let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n-            bounds.append(&mut self.parse_generic_bounds()?);\n+            bounds.append(&mut self.parse_generic_bounds(None)?);\n         }\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n@@ -1819,7 +1819,7 @@ impl<'a> Parser<'a> {\n         }\n \n         self.bump(); // `+`\n-        let bounds = self.parse_generic_bounds()?;\n+        let bounds = self.parse_generic_bounds(None)?;\n         let sum_span = ty.span.to(self.prev_span);\n \n         let mut err = struct_span_err!(self.sess.span_diagnostic, sum_span, E0178,\n@@ -5496,18 +5496,24 @@ impl<'a> Parser<'a> {\n     /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n     /// TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g., `?for<'a: 'b> m::Trait<'a>`)\n     /// ```\n-    fn parse_generic_bounds_common(&mut self, allow_plus: bool) -> PResult<'a, GenericBounds> {\n+    fn parse_generic_bounds_common(&mut self,\n+                                   allow_plus: bool,\n+                                   colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n         let mut bounds = Vec::new();\n+        let mut negative_bounds = Vec::new();\n+        let mut last_plus_span = None;\n         loop {\n             // This needs to be synchronized with `Token::can_begin_bound`.\n             let is_bound_start = self.check_path() || self.check_lifetime() ||\n+                                 self.check(&token::Not) || // used for error reporting only\n                                  self.check(&token::Question) ||\n                                  self.check_keyword(keywords::For) ||\n                                  self.check(&token::OpenDelim(token::Paren));\n             if is_bound_start {\n                 let lo = self.span;\n                 let has_parens = self.eat(&token::OpenDelim(token::Paren));\n                 let inner_lo = self.span;\n+                let is_negative = self.eat(&token::Not);\n                 let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n                 if self.token.is_lifetime() {\n                     if let Some(question_span) = question {\n@@ -5538,28 +5544,60 @@ impl<'a> Parser<'a> {\n                     if has_parens {\n                         self.expect(&token::CloseDelim(token::Paren))?;\n                     }\n-                    let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n-                    let modifier = if question.is_some() {\n-                        TraitBoundModifier::Maybe\n+                    let poly_span = lo.to(self.prev_span);\n+                    if is_negative {\n+                        negative_bounds.push(\n+                            last_plus_span.or(colon_span).unwrap()\n+                                .to(poly_span));\n                     } else {\n-                        TraitBoundModifier::None\n-                    };\n-                    bounds.push(GenericBound::Trait(poly_trait, modifier));\n+                        let poly_trait = PolyTraitRef::new(lifetime_defs, path, poly_span);\n+                        let modifier = if question.is_some() {\n+                            TraitBoundModifier::Maybe\n+                        } else {\n+                            TraitBoundModifier::None\n+                        };\n+                        bounds.push(GenericBound::Trait(poly_trait, modifier));\n+                    }\n                 }\n             } else {\n                 break\n             }\n \n             if !allow_plus || !self.eat_plus() {\n                 break\n-            }\n+            } else {\n+                last_plus_span = Some(self.prev_span);\n+            }\n+        }\n+\n+        if !negative_bounds.is_empty() {\n+            let plural = negative_bounds.len() > 1;\n+            let mut err = self.struct_span_err(negative_bounds,\n+                                               \"negative trait bounds are not supported\");\n+            let bound_list = colon_span.unwrap().to(self.prev_span);\n+            let mut new_bound_list = String::new();\n+            if !bounds.is_empty() {\n+                let mut snippets = bounds.iter().map(|bound| bound.span())\n+                    .map(|span| self.sess.source_map().span_to_snippet(span));\n+                while let Some(Ok(snippet)) = snippets.next() {\n+                    new_bound_list.push_str(\" + \");\n+                    new_bound_list.push_str(&snippet);\n+                }\n+                new_bound_list = new_bound_list.replacen(\" +\", \":\", 1);\n+            }\n+            err.span_suggestion_short(bound_list,\n+                                      &format!(\"remove the trait bound{}\",\n+                                              if plural { \"s\" } else { \"\" }),\n+                                      new_bound_list,\n+                                      Applicability::MachineApplicable);\n+            err.emit();\n         }\n \n         return Ok(bounds);\n     }\n \n-    fn parse_generic_bounds(&mut self) -> PResult<'a, GenericBounds> {\n-        self.parse_generic_bounds_common(true)\n+    fn parse_generic_bounds(&mut self, colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+        self.parse_generic_bounds_common(true, colon_span)\n     }\n \n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n@@ -5587,7 +5625,7 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and param bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds()?\n+            self.parse_generic_bounds(None)?\n         } else {\n             Vec::new()\n         };\n@@ -5619,7 +5657,7 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and param bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds()?\n+            self.parse_generic_bounds(None)?\n         } else {\n             Vec::new()\n         };\n@@ -6032,7 +6070,7 @@ impl<'a> Parser<'a> {\n                 // or with mandatory equality sign and the second type.\n                 let ty = self.parse_ty()?;\n                 if self.eat(&token::Colon) {\n-                    let bounds = self.parse_generic_bounds()?;\n+                    let bounds = self.parse_generic_bounds(None)?;\n                     where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                         ast::WhereBoundPredicate {\n                             span: lo.to(self.prev_span),\n@@ -6546,14 +6584,14 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and supertrait bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds()?\n+            self.parse_generic_bounds(Some(self.prev_span))?\n         } else {\n             Vec::new()\n         };\n \n         if self.eat(&token::Eq) {\n             // it's a trait alias\n-            let bounds = self.parse_generic_bounds()?;\n+            let bounds = self.parse_generic_bounds(None)?;\n             tps.where_clause = self.parse_where_clause()?;\n             self.expect(&token::Semi)?;\n             if is_auto == IsAuto::Yes {\n@@ -7588,7 +7626,7 @@ impl<'a> Parser<'a> {\n         tps.where_clause = self.parse_where_clause()?;\n         let alias = if existential {\n             self.expect(&token::Colon)?;\n-            let bounds = self.parse_generic_bounds()?;\n+            let bounds = self.parse_generic_bounds(None)?;\n             AliasKind::Existential(bounds)\n         } else {\n             self.expect(&token::Eq)?;"}, {"sha": "af0426b22c557adf233f3db8c3b769be42ac7ef2", "filename": "src/test/rustdoc/intra-link-prim-methods.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Ftest%2Frustdoc%2Fintra-link-prim-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Ftest%2Frustdoc%2Fintra-link-prim-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-prim-methods.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -0,0 +1,3 @@\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+//! A [`char`] and its [`char::len_utf8`]."}, {"sha": "df11f2d855ce0115bf16a7be7cadb88869837de1", "filename": "src/test/ui/parser/issue-33418.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Ftest%2Fui%2Fparser%2Fissue-33418.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Ftest%2Fui%2Fparser%2Fissue-33418.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33418.fixed?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+\n+trait Tr {} //~ ERROR negative trait bounds are not supported\n+trait Tr2: SuperA {} //~ ERROR negative trait bounds are not supported\n+trait Tr3: SuperB {} //~ ERROR negative trait bounds are not supported\n+trait Tr4: SuperB + SuperD {}\n+trait Tr5 {}\n+\n+trait SuperA {}\n+trait SuperB {}\n+trait SuperC {}\n+trait SuperD {}\n+\n+fn main() {}"}, {"sha": "5bb5f2afca377188105ed00011294633bda41c81", "filename": "src/test/ui/parser/issue-33418.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Ftest%2Fui%2Fparser%2Fissue-33418.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Ftest%2Fui%2Fparser%2Fissue-33418.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33418.rs?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+\n+trait Tr: !SuperA {} //~ ERROR negative trait bounds are not supported\n+trait Tr2: SuperA + !SuperB {} //~ ERROR negative trait bounds are not supported\n+trait Tr3: !SuperA + SuperB {} //~ ERROR negative trait bounds are not supported\n+trait Tr4: !SuperA + SuperB //~ ERROR negative trait bounds are not supported\n+    + !SuperC + SuperD {}\n+trait Tr5: !SuperA //~ ERROR negative trait bounds are not supported\n+    + !SuperB {}\n+\n+trait SuperA {}\n+trait SuperB {}\n+trait SuperC {}\n+trait SuperD {}\n+\n+fn main() {}"}, {"sha": "bfe44588a5b0b08d858c4db271f3961c4f09fafc", "filename": "src/test/ui/parser/issue-33418.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Ftest%2Fui%2Fparser%2Fissue-33418.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e17c48e2f21eefd59748e364234efc7037a3ec96/src%2Ftest%2Fui%2Fparser%2Fissue-33418.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33418.stderr?ref=e17c48e2f21eefd59748e364234efc7037a3ec96", "patch": "@@ -0,0 +1,42 @@\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:3:9\n+   |\n+LL | trait Tr: !SuperA {} //~ ERROR negative trait bounds are not supported\n+   |         ^^^^^^^^^ help: remove the trait bound\n+\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:4:19\n+   |\n+LL | trait Tr2: SuperA + !SuperB {} //~ ERROR negative trait bounds are not supported\n+   |          ---------^^^^^^^^^\n+   |          |\n+   |          help: remove the trait bound\n+\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:5:10\n+   |\n+LL | trait Tr3: !SuperA + SuperB {} //~ ERROR negative trait bounds are not supported\n+   |          ^^^^^^^^^---------\n+   |          |\n+   |          help: remove the trait bound\n+\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:6:10\n+   |\n+LL |   trait Tr4: !SuperA + SuperB //~ ERROR negative trait bounds are not supported\n+   |  __________-^^^^^^^^\n+LL | |     + !SuperC + SuperD {}\n+   | |_____^^^^^^^^^________- help: remove the trait bounds\n+\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:8:10\n+   |\n+LL |   trait Tr5: !SuperA //~ ERROR negative trait bounds are not supported\n+   |  __________-^^^^^^^^\n+LL | |     + !SuperB {}\n+   | |     ^^^^^^^^-\n+   | |_____________|\n+   |               help: remove the trait bounds\n+\n+error: aborting due to 5 previous errors\n+"}]}