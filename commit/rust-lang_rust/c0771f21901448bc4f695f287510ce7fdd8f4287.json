{"sha": "c0771f21901448bc4f695f287510ce7fdd8f4287", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNzcxZjIxOTAxNDQ4YmM0ZjY5NWYyODc1MTBjZTdmZGQ4ZjQyODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-24T21:18:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-24T21:18:16Z"}, "message": "Auto merge of #44051 - eddyb:apfloat-faster-div, r=nagisa\n\nSpeed up APFloat division by using short division for small divisors.\n\nFixes #43828 (hopefully), by not doing long division bit-by-bit for small divisors.\n\nWhen parsing the ~200,000 decimal float literals in the `tuple-stress` benchmark, this change brings roughly a 5x speed increase (from `0.6s` to `0.12s`), and the hottest instructions are native `div`s.", "tree": {"sha": "557e2efb877d34e799a0f657b6ac0a75232bd1f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/557e2efb877d34e799a0f657b6ac0a75232bd1f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0771f21901448bc4f695f287510ce7fdd8f4287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0771f21901448bc4f695f287510ce7fdd8f4287", "html_url": "https://github.com/rust-lang/rust/commit/c0771f21901448bc4f695f287510ce7fdd8f4287", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0771f21901448bc4f695f287510ce7fdd8f4287/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c0558f635861533e2fcb4298ea93250cdfc2c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0558f635861533e2fcb4298ea93250cdfc2c58", "html_url": "https://github.com/rust-lang/rust/commit/2c0558f635861533e2fcb4298ea93250cdfc2c58"}, {"sha": "b9c69ec3c3a318b8279ec69b3548e0dfdd462038", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c69ec3c3a318b8279ec69b3548e0dfdd462038", "html_url": "https://github.com/rust-lang/rust/commit/b9c69ec3c3a318b8279ec69b3548e0dfdd462038"}], "stats": {"total": 126, "additions": 96, "deletions": 30}, "files": [{"sha": "124c840cc56d63cbf311a8676598e8bb7e8586e6", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 96, "deletions": 30, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/c0771f21901448bc4f695f287510ce7fdd8f4287/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0771f21901448bc4f695f287510ce7fdd8f4287/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=c0771f21901448bc4f695f287510ce7fdd8f4287", "patch": "@@ -460,18 +460,15 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n             // rem <- sig % 10\n             // sig <- sig / 10\n             let mut rem = 0;\n-            for limb in sig.iter_mut().rev() {\n-                // We don't have an integer doubly wide than Limb,\n-                // so we have to split the divrem on two halves.\n-                const HALF_BITS: usize = LIMB_BITS / 2;\n-                let mut halves = [*limb & ((1 << HALF_BITS) - 1), *limb >> HALF_BITS];\n-                for half in halves.iter_mut().rev() {\n-                    *half |= rem << HALF_BITS;\n-                    rem = *half % 10;\n-                    *half /= 10;\n-                }\n-                *limb = halves[0] | (halves[1] << HALF_BITS);\n-            }\n+\n+            // Use 64-bit division and remainder, with 32-bit chunks from sig.\n+            sig::each_chunk(&mut sig, 32, |chunk| {\n+                let chunk = chunk as u32;\n+                let combined = ((rem as u64) << 32) | (chunk as u64);\n+                rem = (combined % 10) as u8;\n+                (combined / 10) as u32 as Limb\n+            });\n+\n             // Reduce the sigificand to avoid wasting time dividing 0's.\n             while sig.last() == Some(&0) {\n                 sig.pop();\n@@ -491,7 +488,7 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n                 exp += 1;\n             } else {\n                 in_trail = false;\n-                buffer.push(b'0' + digit as u8);\n+                buffer.push(b'0' + digit);\n             }\n         }\n \n@@ -2065,7 +2062,7 @@ impl<S: Semantics> IeeeFloat<S> {\n         };\n \n         // Attempt dec_sig * 10^dec_exp with increasing precision.\n-        let mut attempt = 1;\n+        let mut attempt = 0;\n         loop {\n             let calc_precision = (LIMB_BITS << attempt) - 1;\n             attempt += 1;\n@@ -2310,6 +2307,17 @@ mod sig {\n         limbs.iter().all(|&l| l == 0)\n     }\n \n+    /// One, not zero, based LSB. That is, returns 0 for a zeroed significand.\n+    pub(super) fn olsb(limbs: &[Limb]) -> usize {\n+        for i in 0..limbs.len() {\n+            if limbs[i] != 0 {\n+                return i * LIMB_BITS + limbs[i].trailing_zeros() as usize + 1;\n+            }\n+        }\n+\n+        0\n+    }\n+\n     /// One, not zero, based MSB. That is, returns 0 for a zeroed significand.\n     pub(super) fn omsb(limbs: &[Limb]) -> usize {\n         for i in (0..limbs.len()).rev() {\n@@ -2468,6 +2476,20 @@ mod sig {\n         }\n     }\n \n+    /// For every consecutive chunk of `bits` bits from `limbs`,\n+    /// going from most significant to the least significant bits,\n+    /// call `f` to transform those bits and store the result back.\n+    pub(super) fn each_chunk<F: FnMut(Limb) -> Limb>(limbs: &mut [Limb], bits: usize, mut f: F) {\n+        assert_eq!(LIMB_BITS % bits, 0);\n+        for limb in limbs.iter_mut().rev() {\n+            let mut r = 0;\n+            for i in (0..LIMB_BITS / bits).rev() {\n+                r |= f((*limb >> (i * bits)) & ((1 << bits) - 1)) << (i * bits);\n+            }\n+            *limb = r;\n+        }\n+    }\n+\n     /// Increment in-place, return the carry flag.\n     pub(super) fn increment(dst: &mut [Limb]) -> Limb {\n         for x in dst {\n@@ -2686,10 +2708,6 @@ mod sig {\n         divisor: &mut [Limb],\n         precision: usize,\n     ) -> Loss {\n-        // Zero the quotient before setting bits in it.\n-        for x in &mut quotient[..limbs_for_bits(precision)] {\n-            *x = 0;\n-        }\n \n         // Normalize the divisor.\n         let bits = precision - omsb(divisor);\n@@ -2700,6 +2718,13 @@ mod sig {\n         let bits = precision - omsb(dividend);\n         shift_left(dividend, exp, bits);\n \n+        // Division by 1.\n+        let olsb_divisor = olsb(divisor);\n+        if olsb_divisor == precision {\n+            quotient.copy_from_slice(dividend);\n+            return Loss::ExactlyZero;\n+        }\n+\n         // Ensure the dividend >= divisor initially for the loop below.\n         // Incidentally, this means that the division loop below is\n         // guaranteed to set the integer bit to one.\n@@ -2708,6 +2733,58 @@ mod sig {\n             assert_ne!(cmp(dividend, divisor), Ordering::Less)\n         }\n \n+        // Helper for figuring out the lost fraction.\n+        let lost_fraction = |dividend: &[Limb], divisor: &[Limb]| {\n+            match cmp(dividend, divisor) {\n+                Ordering::Greater => Loss::MoreThanHalf,\n+                Ordering::Equal => Loss::ExactlyHalf,\n+                Ordering::Less => {\n+                    if is_all_zeros(dividend) {\n+                        Loss::ExactlyZero\n+                    } else {\n+                        Loss::LessThanHalf\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Try to perform a (much faster) short division for small divisors.\n+        let divisor_bits = precision - (olsb_divisor - 1);\n+        macro_rules! try_short_div {\n+            ($W:ty, $H:ty, $half:expr) => {\n+                if divisor_bits * 2 <= $half {\n+                    // Extract the small divisor.\n+                    let _: Loss = shift_right(divisor, &mut 0, olsb_divisor - 1);\n+                    let divisor = divisor[0] as $H as $W;\n+\n+                    // Shift the dividend to produce a quotient with the unit bit set.\n+                    let top_limb = *dividend.last().unwrap();\n+                    let mut rem = (top_limb >> (LIMB_BITS - (divisor_bits - 1))) as $H;\n+                    shift_left(dividend, &mut 0, divisor_bits - 1);\n+\n+                    // Apply short division in place on $H (of $half bits) chunks.\n+                    each_chunk(dividend, $half, |chunk| {\n+                        let chunk = chunk as $H;\n+                        let combined = ((rem as $W) << $half) | (chunk as $W);\n+                        rem = (combined % divisor) as $H;\n+                        (combined / divisor) as $H as Limb\n+                    });\n+                    quotient.copy_from_slice(dividend);\n+\n+                    return lost_fraction(&[(rem as Limb) << 1], &[divisor as Limb]);\n+                }\n+            }\n+        }\n+\n+        try_short_div!(u32, u16, 16);\n+        try_short_div!(u64, u32, 32);\n+        try_short_div!(u128, u64, 64);\n+\n+        // Zero the quotient before setting bits in it.\n+        for x in &mut quotient[..limbs_for_bits(precision)] {\n+            *x = 0;\n+        }\n+\n         // Long division.\n         for bit in (0..precision).rev() {\n             if cmp(dividend, divisor) != Ordering::Less {\n@@ -2717,17 +2794,6 @@ mod sig {\n             shift_left(dividend, &mut 0, 1);\n         }\n \n-        // Figure out the lost fraction.\n-        match cmp(dividend, divisor) {\n-            Ordering::Greater => Loss::MoreThanHalf,\n-            Ordering::Equal => Loss::ExactlyHalf,\n-            Ordering::Less => {\n-                if is_all_zeros(dividend) {\n-                    Loss::ExactlyZero\n-                } else {\n-                    Loss::LessThanHalf\n-                }\n-            }\n-        }\n+        lost_fraction(dividend, divisor)\n     }\n }"}]}