{"sha": "02d1d92878181a1c99b6d6029f44fbbb91bff499", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZDFkOTI4NzgxODFhMWM5OWI2ZDYwMjlmNDRmYmJiOTFiZmY0OTk=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-25T05:10:39Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-26T20:47:24Z"}, "message": "Still more comments", "tree": {"sha": "3043610f9e0f384e732e301c56eb5d47da1b603e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3043610f9e0f384e732e301c56eb5d47da1b603e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02d1d92878181a1c99b6d6029f44fbbb91bff499", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02d1d92878181a1c99b6d6029f44fbbb91bff499", "html_url": "https://github.com/rust-lang/rust/commit/02d1d92878181a1c99b6d6029f44fbbb91bff499", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02d1d92878181a1c99b6d6029f44fbbb91bff499/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c", "html_url": "https://github.com/rust-lang/rust/commit/b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c"}], "stats": {"total": 28, "additions": 26, "deletions": 2}, "files": [{"sha": "e15198cc3835e3f35d0ca946ed3f4f1bbf5c9cd4", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/02d1d92878181a1c99b6d6029f44fbbb91bff499/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d1d92878181a1c99b6d6029f44fbbb91bff499/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=02d1d92878181a1c99b6d6029f44fbbb91bff499", "patch": "@@ -469,9 +469,13 @@ fn inner_parse_loop(\n             else {\n                 eof_items.push(item);\n             }\n-        } else {\n+        }\n+        // We are in the middle of a matcher.\n+        else {\n+            // Look at what token in the matcher we are trying to match the current token (`token`)\n+            // against. Depending on that, we may generate new items.\n             match item.top_elts.get_tt(idx) {\n-                /* need to descend into sequence */\n+                // Need to descend into a sequence\n                 TokenTree::Sequence(sp, seq) => {\n                     if seq.op == quoted::KleeneOp::ZeroOrMore {\n                         // Examine the case where there are 0 matches of this sequence\n@@ -499,18 +503,30 @@ fn inner_parse_loop(\n                         top_elts: Tt(TokenTree::Sequence(sp, seq)),\n                     }));\n                 }\n+\n+                // We need to match a metavar (but the identifier is invalid)... this is an error\n                 TokenTree::MetaVarDecl(span, _, id) if id.name == keywords::Invalid.name() => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span) {\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n                 }\n+\n+                // We need to match a metavar with a valid ident... call out to the black-box\n+                // parser by adding an item to `bb_items`.\n                 TokenTree::MetaVarDecl(_, _, id) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n                     if may_begin_with(&*id.name.as_str(), token) {\n                         bb_items.push(item);\n                     }\n                 }\n+\n+                // We need to descend into a delimited submatcher or a doc comment. To do this, we\n+                // push the current matcher onto a stack and push a new item containing the\n+                // submatcher onto `cur_items`.\n+                //\n+                // At the beginning of the loop, if we reach the end of the delimited submatcher,\n+                // we pop the stack to backtrack out of the descent.\n                 seq @ TokenTree::Delimited(..) | seq @ TokenTree::Token(_, DocComment(..)) => {\n                     let lower_elts = mem::replace(&mut item.top_elts, Tt(seq));\n                     let idx = item.idx;\n@@ -521,15 +537,23 @@ fn inner_parse_loop(\n                     item.idx = 0;\n                     cur_items.push(item);\n                 }\n+\n+                // We just matched a normal token. We can just advance the parser.\n                 TokenTree::Token(_, ref t) if token_name_eq(t, token) => {\n                     item.idx += 1;\n                     next_items.push(item);\n                 }\n+\n+                // There was another token that was not `token`... This means we can't add any\n+                // rules. NOTE that this is not necessarily an error unless _all_ items in\n+                // `cur_items` end up doing this. There may still be some other matchers that do\n+                // end up working out.\n                 TokenTree::Token(..) | TokenTree::MetaVar(..) => {}\n             }\n         }\n     }\n \n+    // Yay a successful parse (so far)!\n     Success(())\n }\n "}]}