{"sha": "b5fc999e7dafa8217d77088ae10bff96e767a3e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZmM5OTllN2RhZmE4MjE3ZDc3MDg4YWUxMGJmZjk2ZTc2N2EzZTk=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-08T11:37:05Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-08T11:37:05Z"}, "message": "Merge #765\n\n765: Jettison `imp` module r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "7fb47d6afa2eca87d2cd330e8e39af2ce3615dd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fb47d6afa2eca87d2cd330e8e39af2ce3615dd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5fc999e7dafa8217d77088ae10bff96e767a3e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5fc999e7dafa8217d77088ae10bff96e767a3e9", "html_url": "https://github.com/rust-lang/rust/commit/b5fc999e7dafa8217d77088ae10bff96e767a3e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5fc999e7dafa8217d77088ae10bff96e767a3e9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "9a1d2a46c249fa81294c156b9e23b624e14495cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a1d2a46c249fa81294c156b9e23b624e14495cd", "html_url": "https://github.com/rust-lang/rust/commit/9a1d2a46c249fa81294c156b9e23b624e14495cd"}, {"sha": "884f04670aea239f06fe5b6ff7a9f2073034f8bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/884f04670aea239f06fe5b6ff7a9f2073034f8bc", "html_url": "https://github.com/rust-lang/rust/commit/884f04670aea239f06fe5b6ff7a9f2073034f8bc"}], "stats": {"total": 869, "additions": 428, "deletions": 441}, "files": [{"sha": "a59ab78535f92cd344680273585c9e663da37af8", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -20,7 +20,7 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     let name_ref = calling_node.name_ref()?;\n \n     // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n-    let file_symbols = db.index_resolve(name_ref);\n+    let file_symbols = crate::symbol_index::index_resolve(db, name_ref);\n     let symbol = file_symbols\n         .into_iter()\n         .find(|it| it.ptr.kind() == FN_DEF)?;"}, {"sha": "992955740474666c239d39ebf750edeabab862b2", "filename": "crates/ra_ide_api/src/change.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -0,0 +1,255 @@\n+use std::{\n+    fmt, time,\n+    sync::Arc,\n+};\n+\n+use rustc_hash::FxHashMap;\n+use ra_db::{\n+    SourceRootId, FileId, CrateGraph, SourceDatabase, SourceRoot,\n+    salsa::{Database, SweepStrategy},\n+};\n+use ra_syntax::SourceFile;\n+use relative_path::RelativePathBuf;\n+use rayon::prelude::*;\n+\n+use crate::{\n+    db::RootDatabase,\n+    symbol_index::{SymbolIndex, SymbolsDatabase},\n+    status::syntax_tree_stats,\n+};\n+\n+#[derive(Default)]\n+pub struct AnalysisChange {\n+    new_roots: Vec<(SourceRootId, bool)>,\n+    roots_changed: FxHashMap<SourceRootId, RootChange>,\n+    files_changed: Vec<(FileId, Arc<String>)>,\n+    libraries_added: Vec<LibraryData>,\n+    crate_graph: Option<CrateGraph>,\n+}\n+\n+impl fmt::Debug for AnalysisChange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut d = fmt.debug_struct(\"AnalysisChange\");\n+        if !self.new_roots.is_empty() {\n+            d.field(\"new_roots\", &self.new_roots);\n+        }\n+        if !self.roots_changed.is_empty() {\n+            d.field(\"roots_changed\", &self.roots_changed);\n+        }\n+        if !self.files_changed.is_empty() {\n+            d.field(\"files_changed\", &self.files_changed.len());\n+        }\n+        if !self.libraries_added.is_empty() {\n+            d.field(\"libraries_added\", &self.libraries_added.len());\n+        }\n+        if !self.crate_graph.is_some() {\n+            d.field(\"crate_graph\", &self.crate_graph);\n+        }\n+        d.finish()\n+    }\n+}\n+\n+impl AnalysisChange {\n+    pub fn new() -> AnalysisChange {\n+        AnalysisChange::default()\n+    }\n+\n+    pub fn add_root(&mut self, root_id: SourceRootId, is_local: bool) {\n+        self.new_roots.push((root_id, is_local));\n+    }\n+\n+    pub fn add_file(\n+        &mut self,\n+        root_id: SourceRootId,\n+        file_id: FileId,\n+        path: RelativePathBuf,\n+        text: Arc<String>,\n+    ) {\n+        let file = AddFile {\n+            file_id,\n+            path,\n+            text,\n+        };\n+        self.roots_changed\n+            .entry(root_id)\n+            .or_default()\n+            .added\n+            .push(file);\n+    }\n+\n+    pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n+        self.files_changed.push((file_id, new_text))\n+    }\n+\n+    pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n+        let file = RemoveFile { file_id, path };\n+        self.roots_changed\n+            .entry(root_id)\n+            .or_default()\n+            .removed\n+            .push(file);\n+    }\n+\n+    pub fn add_library(&mut self, data: LibraryData) {\n+        self.libraries_added.push(data)\n+    }\n+\n+    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n+        self.crate_graph = Some(graph);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct AddFile {\n+    file_id: FileId,\n+    path: RelativePathBuf,\n+    text: Arc<String>,\n+}\n+\n+#[derive(Debug)]\n+struct RemoveFile {\n+    file_id: FileId,\n+    path: RelativePathBuf,\n+}\n+\n+#[derive(Default)]\n+struct RootChange {\n+    added: Vec<AddFile>,\n+    removed: Vec<RemoveFile>,\n+}\n+\n+impl fmt::Debug for RootChange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.debug_struct(\"AnalysisChange\")\n+            .field(\"added\", &self.added.len())\n+            .field(\"removed\", &self.removed.len())\n+            .finish()\n+    }\n+}\n+\n+pub struct LibraryData {\n+    root_id: SourceRootId,\n+    root_change: RootChange,\n+    symbol_index: SymbolIndex,\n+}\n+\n+impl fmt::Debug for LibraryData {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"LibraryData\")\n+            .field(\"root_id\", &self.root_id)\n+            .field(\"root_change\", &self.root_change)\n+            .field(\"n_symbols\", &self.symbol_index.len())\n+            .finish()\n+    }\n+}\n+\n+impl LibraryData {\n+    pub fn prepare(\n+        root_id: SourceRootId,\n+        files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n+    ) -> LibraryData {\n+        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, _, text)| {\n+            let file = SourceFile::parse(text);\n+            (*file_id, file)\n+        }));\n+        let mut root_change = RootChange::default();\n+        root_change.added = files\n+            .into_iter()\n+            .map(|(file_id, path, text)| AddFile {\n+                file_id,\n+                path,\n+                text,\n+            })\n+            .collect();\n+        LibraryData {\n+            root_id,\n+            root_change,\n+            symbol_index,\n+        }\n+    }\n+}\n+\n+const GC_COOLDOWN: time::Duration = time::Duration::from_millis(100);\n+\n+impl RootDatabase {\n+    pub(crate) fn apply_change(&mut self, change: AnalysisChange) {\n+        log::info!(\"apply_change {:?}\", change);\n+        if !change.new_roots.is_empty() {\n+            let mut local_roots = Vec::clone(&self.local_roots());\n+            for (root_id, is_local) in change.new_roots {\n+                self.set_source_root(root_id, Default::default());\n+                if is_local {\n+                    local_roots.push(root_id);\n+                }\n+            }\n+            self.set_local_roots(Arc::new(local_roots));\n+        }\n+\n+        for (root_id, root_change) in change.roots_changed {\n+            self.apply_root_change(root_id, root_change);\n+        }\n+        for (file_id, text) in change.files_changed {\n+            self.set_file_text(file_id, text)\n+        }\n+        if !change.libraries_added.is_empty() {\n+            let mut libraries = Vec::clone(&self.library_roots());\n+            for library in change.libraries_added {\n+                libraries.push(library.root_id);\n+                self.set_source_root(library.root_id, Default::default());\n+                self.set_constant_library_symbols(library.root_id, Arc::new(library.symbol_index));\n+                self.apply_root_change(library.root_id, library.root_change);\n+            }\n+            self.set_library_roots(Arc::new(libraries));\n+        }\n+        if let Some(crate_graph) = change.crate_graph {\n+            self.set_crate_graph(Arc::new(crate_graph))\n+        }\n+    }\n+\n+    fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n+        let mut source_root = SourceRoot::clone(&self.source_root(root_id));\n+        for add_file in root_change.added {\n+            self.set_file_text(add_file.file_id, add_file.text);\n+            self.set_file_relative_path(add_file.file_id, add_file.path.clone());\n+            self.set_file_source_root(add_file.file_id, root_id);\n+            source_root.files.insert(add_file.path, add_file.file_id);\n+        }\n+        for remove_file in root_change.removed {\n+            self.set_file_text(remove_file.file_id, Default::default());\n+            source_root.files.remove(&remove_file.path);\n+        }\n+        self.set_source_root(root_id, Arc::new(source_root));\n+    }\n+\n+    pub(crate) fn maybe_collect_garbage(&mut self) {\n+        if self.last_gc_check.elapsed() > GC_COOLDOWN {\n+            self.last_gc_check = time::Instant::now();\n+            let retained_trees = syntax_tree_stats(self).retained;\n+            if retained_trees > 100 {\n+                log::info!(\n+                    \"automatic garbadge collection, {} retained trees\",\n+                    retained_trees\n+                );\n+                self.collect_garbage();\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn collect_garbage(&mut self) {\n+        self.last_gc = time::Instant::now();\n+\n+        let sweep = SweepStrategy::default()\n+            .discard_values()\n+            .sweep_all_revisions();\n+\n+        self.query(ra_db::ParseQuery).sweep(sweep);\n+\n+        self.query(hir::db::HirParseQuery).sweep(sweep);\n+        self.query(hir::db::FileItemsQuery).sweep(sweep);\n+        self.query(hir::db::FileItemQuery).sweep(sweep);\n+\n+        self.query(hir::db::LowerModuleQuery).sweep(sweep);\n+        self.query(hir::db::LowerModuleSourceMapQuery).sweep(sweep);\n+        self.query(hir::db::BodySyntaxMappingQuery).sweep(sweep);\n+    }\n+}"}, {"sha": "a499ac7c60606ca69a0137f302cf53d551d1a7ba", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -0,0 +1,69 @@\n+use hir::{Problem, source_binder};\n+use ra_ide_api_light::Severity;\n+use ra_db::SourceDatabase;\n+\n+use crate::{Diagnostic, FileId, FileSystemEdit, SourceChange, db::RootDatabase};\n+\n+pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic> {\n+    let syntax = db.parse(file_id);\n+\n+    let mut res = ra_ide_api_light::diagnostics(&syntax)\n+        .into_iter()\n+        .map(|d| Diagnostic {\n+            range: d.range,\n+            message: d.msg,\n+            severity: d.severity,\n+            fix: d.fix.map(|fix| SourceChange::from_local_edit(file_id, fix)),\n+        })\n+        .collect::<Vec<_>>();\n+    if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n+        for (name_node, problem) in m.problems(db) {\n+            let source_root = db.file_source_root(file_id);\n+            let diag = match problem {\n+                Problem::UnresolvedModule { candidate } => {\n+                    let create_file = FileSystemEdit::CreateFile {\n+                        source_root,\n+                        path: candidate.clone(),\n+                    };\n+                    let fix = SourceChange {\n+                        label: \"create module\".to_string(),\n+                        source_file_edits: Vec::new(),\n+                        file_system_edits: vec![create_file],\n+                        cursor_position: None,\n+                    };\n+                    Diagnostic {\n+                        range: name_node.range(),\n+                        message: \"unresolved module\".to_string(),\n+                        severity: Severity::Error,\n+                        fix: Some(fix),\n+                    }\n+                }\n+                Problem::NotDirOwner { move_to, candidate } => {\n+                    let move_file = FileSystemEdit::MoveFile {\n+                        src: file_id,\n+                        dst_source_root: source_root,\n+                        dst_path: move_to.clone(),\n+                    };\n+                    let create_file = FileSystemEdit::CreateFile {\n+                        source_root,\n+                        path: move_to.join(candidate),\n+                    };\n+                    let fix = SourceChange {\n+                        label: \"move file and create module\".to_string(),\n+                        source_file_edits: Vec::new(),\n+                        file_system_edits: vec![move_file, create_file],\n+                        cursor_position: None,\n+                    };\n+                    Diagnostic {\n+                        range: name_node.range(),\n+                        message: \"can't declare module at this location\".to_string(),\n+                        severity: Severity::Error,\n+                        fix: Some(fix),\n+                    }\n+                }\n+            };\n+            res.push(diag)\n+        }\n+    };\n+    res\n+}"}, {"sha": "69f2d2bf622089263661c99d067afe036d249340", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -118,8 +118,7 @@ pub(crate) fn reference_definition(\n         }\n     }\n     // If that fails try the index based approach.\n-    let navs = db\n-        .index_resolve(name_ref)\n+    let navs = crate::symbol_index::index_resolve(db, name_ref)\n         .into_iter()\n         .map(NavigationTarget::from_symbol)\n         .collect();"}, {"sha": "b139efabf6d96ef212f69ffbc4a0f6bbaa7e18c4", "filename": "crates/ra_ide_api/src/imp.rs", "status": "removed", "additions": 0, "deletions": 263, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/9a1d2a46c249fa81294c156b9e23b624e14495cd/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a1d2a46c249fa81294c156b9e23b624e14495cd/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimp.rs?ref=9a1d2a46c249fa81294c156b9e23b624e14495cd", "patch": "@@ -1,263 +0,0 @@\n-use std::{\n-    sync::Arc,\n-    time,\n-};\n-\n-use hir::{\n-    self, Problem, source_binder\n-};\n-use ra_db::{\n-    SourceDatabase, SourceRoot, SourceRootId,\n-    salsa::{Database, SweepStrategy},\n-};\n-use ra_ide_api_light::{self, LocalEdit, Severity};\n-use ra_syntax::{\n-    algo::find_node_at_offset, ast::{self, NameOwner}, AstNode,\n-    SourceFile,\n-    TextRange,\n-};\n-\n-use crate::{\n-    AnalysisChange,\n-    CrateId, db, Diagnostic, FileId, FilePosition, FileSystemEdit,\n-    Query, RootChange, SourceChange, SourceFileEdit,\n-    symbol_index::{FileSymbol, SymbolsDatabase},\n-    status::syntax_tree_stats\n-};\n-\n-const GC_COOLDOWN: time::Duration = time::Duration::from_millis(100);\n-\n-impl db::RootDatabase {\n-    pub(crate) fn apply_change(&mut self, change: AnalysisChange) {\n-        log::info!(\"apply_change {:?}\", change);\n-        if !change.new_roots.is_empty() {\n-            let mut local_roots = Vec::clone(&self.local_roots());\n-            for (root_id, is_local) in change.new_roots {\n-                self.set_source_root(root_id, Default::default());\n-                if is_local {\n-                    local_roots.push(root_id);\n-                }\n-            }\n-            self.set_local_roots(Arc::new(local_roots));\n-        }\n-\n-        for (root_id, root_change) in change.roots_changed {\n-            self.apply_root_change(root_id, root_change);\n-        }\n-        for (file_id, text) in change.files_changed {\n-            self.set_file_text(file_id, text)\n-        }\n-        if !change.libraries_added.is_empty() {\n-            let mut libraries = Vec::clone(&self.library_roots());\n-            for library in change.libraries_added {\n-                libraries.push(library.root_id);\n-                self.set_source_root(library.root_id, Default::default());\n-                self.set_constant_library_symbols(library.root_id, Arc::new(library.symbol_index));\n-                self.apply_root_change(library.root_id, library.root_change);\n-            }\n-            self.set_library_roots(Arc::new(libraries));\n-        }\n-        if let Some(crate_graph) = change.crate_graph {\n-            self.set_crate_graph(Arc::new(crate_graph))\n-        }\n-    }\n-\n-    fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n-        let mut source_root = SourceRoot::clone(&self.source_root(root_id));\n-        for add_file in root_change.added {\n-            self.set_file_text(add_file.file_id, add_file.text);\n-            self.set_file_relative_path(add_file.file_id, add_file.path.clone());\n-            self.set_file_source_root(add_file.file_id, root_id);\n-            source_root.files.insert(add_file.path, add_file.file_id);\n-        }\n-        for remove_file in root_change.removed {\n-            self.set_file_text(remove_file.file_id, Default::default());\n-            source_root.files.remove(&remove_file.path);\n-        }\n-        self.set_source_root(root_id, Arc::new(source_root));\n-    }\n-\n-    pub(crate) fn maybe_collect_garbage(&mut self) {\n-        if self.last_gc_check.elapsed() > GC_COOLDOWN {\n-            self.last_gc_check = time::Instant::now();\n-            let retained_trees = syntax_tree_stats(self).retained;\n-            if retained_trees > 100 {\n-                log::info!(\n-                    \"automatic garbadge collection, {} retained trees\",\n-                    retained_trees\n-                );\n-                self.collect_garbage();\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn collect_garbage(&mut self) {\n-        self.last_gc = time::Instant::now();\n-\n-        let sweep = SweepStrategy::default()\n-            .discard_values()\n-            .sweep_all_revisions();\n-\n-        self.query(ra_db::ParseQuery).sweep(sweep);\n-\n-        self.query(hir::db::HirParseQuery).sweep(sweep);\n-        self.query(hir::db::FileItemsQuery).sweep(sweep);\n-        self.query(hir::db::FileItemQuery).sweep(sweep);\n-\n-        self.query(hir::db::LowerModuleQuery).sweep(sweep);\n-        self.query(hir::db::LowerModuleSourceMapQuery).sweep(sweep);\n-        self.query(hir::db::BodySyntaxMappingQuery).sweep(sweep);\n-    }\n-}\n-\n-impl db::RootDatabase {\n-    /// Returns `Vec` for the same reason as `parent_module`\n-    pub(crate) fn crate_for(&self, file_id: FileId) -> Vec<CrateId> {\n-        let module = match source_binder::module_from_file_id(self, file_id) {\n-            Some(it) => it,\n-            None => return Vec::new(),\n-        };\n-        let krate = match module.krate(self) {\n-            Some(it) => it,\n-            None => return Vec::new(),\n-        };\n-        vec![krate.crate_id()]\n-    }\n-\n-    pub(crate) fn find_all_refs(&self, position: FilePosition) -> Vec<(FileId, TextRange)> {\n-        let file = self.parse(position.file_id);\n-        // Find the binding associated with the offset\n-        let (binding, descr) = match find_binding(self, &file, position) {\n-            None => return Vec::new(),\n-            Some(it) => it,\n-        };\n-\n-        let mut ret = binding\n-            .name()\n-            .into_iter()\n-            .map(|name| (position.file_id, name.syntax().range()))\n-            .collect::<Vec<_>>();\n-        ret.extend(\n-            descr\n-                .scopes(self)\n-                .find_all_refs(binding)\n-                .into_iter()\n-                .map(|ref_desc| (position.file_id, ref_desc.range)),\n-        );\n-\n-        return ret;\n-\n-        fn find_binding<'a>(\n-            db: &db::RootDatabase,\n-            source_file: &'a SourceFile,\n-            position: FilePosition,\n-        ) -> Option<(&'a ast::BindPat, hir::Function)> {\n-            let syntax = source_file.syntax();\n-            if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n-                let descr = source_binder::function_from_child_node(\n-                    db,\n-                    position.file_id,\n-                    binding.syntax(),\n-                )?;\n-                return Some((binding, descr));\n-            };\n-            let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n-            let descr =\n-                source_binder::function_from_child_node(db, position.file_id, name_ref.syntax())?;\n-            let scope = descr.scopes(db);\n-            let resolved = scope.resolve_local_name(name_ref)?;\n-            let resolved = resolved.ptr().to_node(source_file);\n-            let binding = find_node_at_offset::<ast::BindPat>(syntax, resolved.range().end())?;\n-            Some((binding, descr))\n-        }\n-    }\n-\n-    pub(crate) fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n-        let syntax = self.parse(file_id);\n-\n-        let mut res = ra_ide_api_light::diagnostics(&syntax)\n-            .into_iter()\n-            .map(|d| Diagnostic {\n-                range: d.range,\n-                message: d.msg,\n-                severity: d.severity,\n-                fix: d.fix.map(|fix| SourceChange::from_local_edit(file_id, fix)),\n-            })\n-            .collect::<Vec<_>>();\n-        if let Some(m) = source_binder::module_from_file_id(self, file_id) {\n-            for (name_node, problem) in m.problems(self) {\n-                let source_root = self.file_source_root(file_id);\n-                let diag = match problem {\n-                    Problem::UnresolvedModule { candidate } => {\n-                        let create_file = FileSystemEdit::CreateFile {\n-                            source_root,\n-                            path: candidate.clone(),\n-                        };\n-                        let fix = SourceChange {\n-                            label: \"create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.range(),\n-                            message: \"unresolved module\".to_string(),\n-                            severity: Severity::Error,\n-                            fix: Some(fix),\n-                        }\n-                    }\n-                    Problem::NotDirOwner { move_to, candidate } => {\n-                        let move_file = FileSystemEdit::MoveFile {\n-                            src: file_id,\n-                            dst_source_root: source_root,\n-                            dst_path: move_to.clone(),\n-                        };\n-                        let create_file = FileSystemEdit::CreateFile {\n-                            source_root,\n-                            path: move_to.join(candidate),\n-                        };\n-                        let fix = SourceChange {\n-                            label: \"move file and create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![move_file, create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.range(),\n-                            message: \"can't declare module at this location\".to_string(),\n-                            severity: Severity::Error,\n-                            fix: Some(fix),\n-                        }\n-                    }\n-                };\n-                res.push(diag)\n-            }\n-        };\n-        res\n-    }\n-\n-    pub(crate) fn index_resolve(&self, name_ref: &ast::NameRef) -> Vec<FileSymbol> {\n-        let name = name_ref.text();\n-        let mut query = Query::new(name.to_string());\n-        query.exact();\n-        query.limit(4);\n-        crate::symbol_index::world_symbols(self, query)\n-    }\n-}\n-\n-impl SourceChange {\n-    pub(crate) fn from_local_edit(file_id: FileId, edit: LocalEdit) -> SourceChange {\n-        let file_edit = SourceFileEdit {\n-            file_id,\n-            edit: edit.edit,\n-        };\n-        SourceChange {\n-            label: edit.label,\n-            source_file_edits: vec![file_edit],\n-            file_system_edits: vec![],\n-            cursor_position: edit\n-                .cursor_position\n-                .map(|offset| FilePosition { offset, file_id }),\n-        }\n-    }\n-}"}, {"sha": "4fb0541395119a4f0dd57cdad723710dcf485cfc", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::{SourceDatabase};\n+use ra_db::SourceDatabase;\n use ra_syntax::{\n     AstNode, ast,\n     algo::find_node_at_offset,"}, {"sha": "1f43b762338633881e7a885e1a08c81f31c2c7ca", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 24, "deletions": 158, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -14,10 +14,10 @@\n #![recursion_limit = \"128\"]\n \n mod db;\n-mod imp;\n pub mod mock_analysis;\n mod symbol_index;\n mod navigation_target;\n+mod change;\n \n mod status;\n mod completion;\n@@ -28,37 +28,37 @@ mod hover;\n mod call_info;\n mod syntax_highlighting;\n mod parent_module;\n-mod rename;\n+mod references;\n mod impls;\n mod assists;\n+mod diagnostics;\n \n #[cfg(test)]\n mod marks;\n \n-use std::{fmt, sync::Arc};\n+use std::sync::Arc;\n \n use ra_syntax::{SourceFile, TreeArc, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n use ra_db::{\n     SourceDatabase, CheckCanceled,\n     salsa::{self, ParallelDatabase},\n };\n-use rayon::prelude::*;\n use relative_path::RelativePathBuf;\n-use rustc_hash::FxHashMap;\n \n use crate::{\n-    symbol_index::{FileSymbol, SymbolIndex},\n+    symbol_index::FileSymbol,\n     db::LineIndexDatabase,\n };\n \n pub use crate::{\n+    change::{AnalysisChange, LibraryData},\n     completion::{CompletionItem, CompletionItemKind, InsertTextFormat},\n     runnables::{Runnable, RunnableKind},\n     navigation_target::NavigationTarget,\n };\n pub use ra_ide_api_light::{\n-    Fold, FoldKind, HighlightedRange, Severity, StructureNode,\n+    Fold, FoldKind, HighlightedRange, Severity, StructureNode, LocalEdit,\n     LineIndex, LineCol, translate_offset_with_edit,\n };\n pub use ra_db::{\n@@ -74,115 +74,6 @@ static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n \n pub type Cancelable<T> = Result<T, Canceled>;\n \n-#[derive(Default)]\n-pub struct AnalysisChange {\n-    new_roots: Vec<(SourceRootId, bool)>,\n-    roots_changed: FxHashMap<SourceRootId, RootChange>,\n-    files_changed: Vec<(FileId, Arc<String>)>,\n-    libraries_added: Vec<LibraryData>,\n-    crate_graph: Option<CrateGraph>,\n-}\n-\n-#[derive(Default)]\n-struct RootChange {\n-    added: Vec<AddFile>,\n-    removed: Vec<RemoveFile>,\n-}\n-\n-#[derive(Debug)]\n-struct AddFile {\n-    file_id: FileId,\n-    path: RelativePathBuf,\n-    text: Arc<String>,\n-}\n-\n-#[derive(Debug)]\n-struct RemoveFile {\n-    file_id: FileId,\n-    path: RelativePathBuf,\n-}\n-\n-impl fmt::Debug for AnalysisChange {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut d = fmt.debug_struct(\"AnalysisChange\");\n-        if !self.new_roots.is_empty() {\n-            d.field(\"new_roots\", &self.new_roots);\n-        }\n-        if !self.roots_changed.is_empty() {\n-            d.field(\"roots_changed\", &self.roots_changed);\n-        }\n-        if !self.files_changed.is_empty() {\n-            d.field(\"files_changed\", &self.files_changed.len());\n-        }\n-        if !self.libraries_added.is_empty() {\n-            d.field(\"libraries_added\", &self.libraries_added.len());\n-        }\n-        if self.crate_graph.is_none() {\n-            d.field(\"crate_graph\", &self.crate_graph);\n-        }\n-        d.finish()\n-    }\n-}\n-\n-impl fmt::Debug for RootChange {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.debug_struct(\"AnalysisChange\")\n-            .field(\"added\", &self.added.len())\n-            .field(\"removed\", &self.removed.len())\n-            .finish()\n-    }\n-}\n-\n-impl AnalysisChange {\n-    pub fn new() -> AnalysisChange {\n-        AnalysisChange::default()\n-    }\n-\n-    pub fn add_root(&mut self, root_id: SourceRootId, is_local: bool) {\n-        self.new_roots.push((root_id, is_local));\n-    }\n-\n-    pub fn add_file(\n-        &mut self,\n-        root_id: SourceRootId,\n-        file_id: FileId,\n-        path: RelativePathBuf,\n-        text: Arc<String>,\n-    ) {\n-        let file = AddFile {\n-            file_id,\n-            path,\n-            text,\n-        };\n-        self.roots_changed\n-            .entry(root_id)\n-            .or_default()\n-            .added\n-            .push(file);\n-    }\n-\n-    pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n-        self.files_changed.push((file_id, new_text))\n-    }\n-\n-    pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n-        let file = RemoveFile { file_id, path };\n-        self.roots_changed\n-            .entry(root_id)\n-            .or_default()\n-            .removed\n-            .push(file);\n-    }\n-\n-    pub fn add_library(&mut self, data: LibraryData) {\n-        self.libraries_added.push(data)\n-    }\n-\n-    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n-        self.crate_graph = Some(graph);\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct SourceChange {\n     pub label: String,\n@@ -431,7 +322,7 @@ impl Analysis {\n \n     /// Finds all usages of the reference at point.\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n-        self.with_db(|db| db.find_all_refs(position))\n+        self.with_db(|db| references::find_all_refs(db, position))\n     }\n \n     /// Returns a short text descrbing element at position.\n@@ -451,7 +342,7 @@ impl Analysis {\n \n     /// Returns crates this file belongs too.\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        self.with_db(|db| db.crate_for(file_id))\n+        self.with_db(|db| parent_module::crate_for(db, file_id))\n     }\n \n     /// Returns the root file of the given crate.\n@@ -482,7 +373,7 @@ impl Analysis {\n \n     /// Computes the set of diagnostics for the given file.\n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n-        self.with_db(|db| db.diagnostics(file_id))\n+        self.with_db(|db| diagnostics::diagnostics(db, file_id))\n     }\n \n     /// Computes the type of the expression at the given position.\n@@ -497,7 +388,7 @@ impl Analysis {\n         position: FilePosition,\n         new_name: &str,\n     ) -> Cancelable<Option<SourceChange>> {\n-        self.with_db(|db| rename::rename(db, position, new_name))\n+        self.with_db(|db| references::rename(db, position, new_name))\n     }\n \n     fn with_db<F: FnOnce(&db::RootDatabase) -> T + std::panic::UnwindSafe, T>(\n@@ -508,44 +399,19 @@ impl Analysis {\n     }\n }\n \n-pub struct LibraryData {\n-    root_id: SourceRootId,\n-    root_change: RootChange,\n-    symbol_index: SymbolIndex,\n-}\n-\n-impl fmt::Debug for LibraryData {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LibraryData\")\n-            .field(\"root_id\", &self.root_id)\n-            .field(\"root_change\", &self.root_change)\n-            .field(\"n_symbols\", &self.symbol_index.len())\n-            .finish()\n-    }\n-}\n-\n-impl LibraryData {\n-    pub fn prepare(\n-        root_id: SourceRootId,\n-        files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n-    ) -> LibraryData {\n-        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, _, text)| {\n-            let file = SourceFile::parse(text);\n-            (*file_id, file)\n-        }));\n-        let mut root_change = RootChange::default();\n-        root_change.added = files\n-            .into_iter()\n-            .map(|(file_id, path, text)| AddFile {\n-                file_id,\n-                path,\n-                text,\n-            })\n-            .collect();\n-        LibraryData {\n-            root_id,\n-            root_change,\n-            symbol_index,\n+impl SourceChange {\n+    pub(crate) fn from_local_edit(file_id: FileId, edit: LocalEdit) -> SourceChange {\n+        let file_edit = SourceFileEdit {\n+            file_id,\n+            edit: edit.edit,\n+        };\n+        SourceChange {\n+            label: edit.label,\n+            source_file_edits: vec![file_edit],\n+            file_system_edits: vec![],\n+            cursor_position: edit\n+                .cursor_position\n+                .map(|offset| FilePosition { offset, file_id }),\n         }\n     }\n }"}, {"sha": "603c3db6ae223609de3bc9605d5e0759c112e3f2", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::FilePosition;\n+use ra_db::{FilePosition, FileId, CrateId};\n \n use crate::{NavigationTarget, db::RootDatabase};\n \n@@ -13,6 +13,19 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n     vec![nav]\n }\n \n+/// Returns `Vec` for the same reason as `parent_module`\n+pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n+    let module = match hir::source_binder::module_from_file_id(db, file_id) {\n+        Some(it) => it,\n+        None => return Vec::new(),\n+    };\n+    let krate = match module.krate(db) {\n+        Some(it) => it,\n+        None => return Vec::new(),\n+    };\n+    vec![krate.crate_id()]\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::mock_analysis::analysis_and_position;"}, {"sha": "b129f3134928c73ea706bd8ac417e8999986b781", "filename": "crates/ra_ide_api/src/references.rs", "status": "renamed", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -1,13 +1,10 @@\n-use relative_path::RelativePathBuf;\n-\n-use hir::{\n-    self, ModuleSource, source_binder::module_from_declaration,\n-};\n+use relative_path::{RelativePath, RelativePathBuf};\n+use hir::{ModuleSource, source_binder};\n+use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n+    AstNode, SyntaxNode, TextRange, SourceFile,\n+    ast::{self, NameOwner},\n     algo::find_node_at_offset,\n-    ast,\n-    AstNode,\n-    SyntaxNode\n };\n \n use crate::{\n@@ -17,8 +14,51 @@ use crate::{\n     SourceChange,\n     SourceFileEdit,\n };\n-use ra_db::SourceDatabase;\n-use relative_path::RelativePath;\n+\n+pub(crate) fn find_all_refs(db: &RootDatabase, position: FilePosition) -> Vec<(FileId, TextRange)> {\n+    let file = db.parse(position.file_id);\n+    // Find the binding associated with the offset\n+    let (binding, descr) = match find_binding(db, &file, position) {\n+        None => return Vec::new(),\n+        Some(it) => it,\n+    };\n+\n+    let mut ret = binding\n+        .name()\n+        .into_iter()\n+        .map(|name| (position.file_id, name.syntax().range()))\n+        .collect::<Vec<_>>();\n+    ret.extend(\n+        descr\n+            .scopes(db)\n+            .find_all_refs(binding)\n+            .into_iter()\n+            .map(|ref_desc| (position.file_id, ref_desc.range)),\n+    );\n+\n+    return ret;\n+\n+    fn find_binding<'a>(\n+        db: &RootDatabase,\n+        source_file: &'a SourceFile,\n+        position: FilePosition,\n+    ) -> Option<(&'a ast::BindPat, hir::Function)> {\n+        let syntax = source_file.syntax();\n+        if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n+            let descr =\n+                source_binder::function_from_child_node(db, position.file_id, binding.syntax())?;\n+            return Some((binding, descr));\n+        };\n+        let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n+        let descr =\n+            source_binder::function_from_child_node(db, position.file_id, name_ref.syntax())?;\n+        let scope = descr.scopes(db);\n+        let resolved = scope.resolve_local_name(name_ref)?;\n+        let resolved = resolved.ptr().to_node(source_file);\n+        let binding = find_node_at_offset::<ast::BindPat>(syntax, resolved.range().end())?;\n+        Some((binding, descr))\n+    }\n+}\n \n pub(crate) fn rename(\n     db: &RootDatabase,\n@@ -57,7 +97,8 @@ fn rename_mod(\n ) -> Option<SourceChange> {\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n-    if let Some(module) = module_from_declaration(db, position.file_id, &ast_module) {\n+    if let Some(module) = source_binder::module_from_declaration(db, position.file_id, &ast_module)\n+    {\n         let (file_id, module_source) = module.definition_source(db);\n         match module_source {\n             ModuleSource::SourceFile(..) => {\n@@ -108,8 +149,7 @@ fn rename_reference(\n     position: FilePosition,\n     new_name: &str,\n ) -> Option<SourceChange> {\n-    let edit = db\n-        .find_all_refs(position)\n+    let edit = find_all_refs(db, position)\n         .iter()\n         .map(|(file_id, text_range)| SourceFileEdit {\n             file_id: *file_id,", "previous_filename": "crates/ra_ide_api/src/rename.rs"}, {"sha": "3d0b2369eda5734b4c04b7711374636f766f04dc", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -109,6 +109,14 @@ pub(crate) fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol>\n     query.search(&buf)\n }\n \n+pub(crate) fn index_resolve(db: &RootDatabase, name_ref: &ast::NameRef) -> Vec<FileSymbol> {\n+    let name = name_ref.text();\n+    let mut query = Query::new(name.to_string());\n+    query.exact();\n+    query.limit(4);\n+    crate::symbol_index::world_symbols(db, query)\n+}\n+\n #[derive(Default, Debug)]\n pub(crate) struct SymbolIndex {\n     symbols: Vec<FileSymbol>,"}, {"sha": "fb1066eec68092030828eb2f64ae64e6651495f7", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5fc999e7dafa8217d77088ae10bff96e767a3e9/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=b5fc999e7dafa8217d77088ae10bff96e767a3e9", "patch": "@@ -28,7 +28,7 @@ fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Option<tt::Subtree> {\n ///\n /// The tricky bit is dealing with repetitions (`$()*`). Consider this example:\n ///\n-/// ```ignore\n+/// ```not_rust\n /// macro_rules! foo {\n ///     ($($ i:ident $($ e:expr),*);*) => {\n ///         $(fn $ i() { $($ e);*; })*\n@@ -46,7 +46,7 @@ fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Option<tt::Subtree> {\n ///\n /// For the above example, the bindings would store\n ///\n-/// ```ignore\n+/// ```not_rust\n /// i -> [foo, bar]\n /// e -> [[1, 2, 3], [4, 5, 6]]\n /// ```"}]}