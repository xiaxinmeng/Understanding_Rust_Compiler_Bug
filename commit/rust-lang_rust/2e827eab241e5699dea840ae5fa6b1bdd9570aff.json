{"sha": "2e827eab241e5699dea840ae5fa6b1bdd9570aff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlODI3ZWFiMjQxZTU2OTlkZWE4NDBhZTVmYTZiMWJkZDk1NzBhZmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-13T00:33:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-13T00:33:17Z"}, "message": "stdlib: Port most of getopts over to interior vectors", "tree": {"sha": "673ea54ea7d3d7e1972990f446fbd0a4107cb4a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/673ea54ea7d3d7e1972990f446fbd0a4107cb4a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e827eab241e5699dea840ae5fa6b1bdd9570aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e827eab241e5699dea840ae5fa6b1bdd9570aff", "html_url": "https://github.com/rust-lang/rust/commit/2e827eab241e5699dea840ae5fa6b1bdd9570aff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e827eab241e5699dea840ae5fa6b1bdd9570aff/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3427a412722016c237b473790da63d89a164217c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3427a412722016c237b473790da63d89a164217c", "html_url": "https://github.com/rust-lang/rust/commit/3427a412722016c237b473790da63d89a164217c"}], "stats": {"total": 74, "additions": 46, "deletions": 28}, "files": [{"sha": "bdcfbea3b2872ee4883d7f58ef4db391efdc11db", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2e827eab241e5699dea840ae5fa6b1bdd9570aff/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e827eab241e5699dea840ae5fa6b1bdd9570aff/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=2e827eab241e5699dea840ae5fa6b1bdd9570aff", "patch": "@@ -65,7 +65,7 @@ fn optmulti(str name) -> opt {\n \n tag optval { val(str); given; }\n \n-type match = rec(vec[opt] opts, vec[mutable vec[optval]] vals, vec[str] free);\n+type match = rec(opt[] opts, (optval[])[mutable] vals, vec[str] free);\n \n fn is_arg(str arg) -> bool {\n     ret str::byte_len(arg) > 1u && arg.(0) == '-' as u8;\n@@ -78,9 +78,9 @@ fn name_str(name nm) -> str {\n         };\n }\n \n-fn find_opt(vec[opt] opts, name nm) -> option::t[uint] {\n+fn find_opt(&opt[] opts, name nm) -> option::t[uint] {\n     auto i = 0u;\n-    auto l = vec::len[opt](opts);\n+    auto l = ivec::len[opt](opts);\n     while (i < l) {\n         if (opts.(i).name == nm) { ret some[uint](i); }\n         i += 1u;\n@@ -119,19 +119,31 @@ fn fail_str(fail_ f) -> str {\n tag result { success(match); failure(fail_); }\n \n fn getopts(vec[str] args, vec[opt] opts) -> result {\n-    auto n_opts = vec::len[opt](opts);\n-    fn f(uint x) -> vec[optval] { ret vec::empty(); }\n-    auto vals = vec::init_fn_mut[vec[optval]](f, n_opts);\n+    // FIXME: Remove this vec->ivec conversion.\n+    auto args_ivec = ~[]; auto opts_ivec = ~[];\n+    for (str arg in args) { args_ivec += ~[arg]; }\n+    for (opt o in opts) { opts_ivec += ~[o]; }\n+    ret getopts_ivec(args_ivec, opts_ivec);\n+}\n+\n+fn getopts_ivec(&str[] args, &opt[] opts) -> result {\n+    auto n_opts = ivec::len[opt](opts);\n+    fn f(uint x) -> optval[] { ret ~[]; }\n+    auto vals = ivec::init_fn_mut[optval[]](f, n_opts);\n     let vec[str] free = [];\n-    auto l = vec::len[str](args);\n+    auto l = ivec::len[str](args);\n     auto i = 0u;\n     while (i < l) {\n         auto cur = args.(i);\n         auto curlen = str::byte_len(cur);\n         if (!is_arg(cur)) {\n-            vec::push[str](free, cur);\n+            free += [cur];\n         } else if (str::eq(cur, \"--\")) {\n-            free += vec::slice[str](args, i + 1u, l);\n+            auto j = i + 1u;\n+            while (j < l) {\n+                free += [args.(j)];\n+                j += 1u;\n+            }\n             break;\n         } else {\n             auto names;\n@@ -140,19 +152,19 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n                 auto tail = str::slice(cur, 2u, curlen);\n                 auto eq = str::index(tail, '=' as u8);\n                 if (eq == -1) {\n-                    names = [long(tail)];\n+                    names = ~[long(tail)];\n                 } else {\n-                    names = [long(str::slice(tail, 0u, eq as uint))];\n+                    names = ~[long(str::slice(tail, 0u, eq as uint))];\n                     i_arg =\n                         option::some[str](str::slice(tail, (eq as uint) + 1u,\n                                                      curlen - 2u));\n                 }\n             } else {\n                 auto j = 1u;\n-                names = [];\n+                names = ~[];\n                 while (j < curlen) {\n                     auto range = str::char_range_at(cur, j);\n-                    vec::push[name](names, short(range._0));\n+                    names += ~[short(range._0)];\n                     j = range._1;\n                 }\n             }\n@@ -171,29 +183,27 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n                         if (!option::is_none[str](i_arg)) {\n                             ret failure(unexpected_argument(name_str(nm)));\n                         }\n-                        vec::push[optval](vals.(optid), given);\n+                        vals.(optid) += ~[given];\n                     }\n                     case (maybe) {\n                         if (!option::is_none[str](i_arg)) {\n-                            vec::push[optval](vals.(optid),\n-                                              val(option::get[str](i_arg)));\n-                        } else if (name_pos < vec::len[name](names) ||\n+                            vals.(optid) += ~[val(option::get(i_arg))];\n+                        } else if (name_pos < ivec::len[name](names) ||\n                                        i + 1u == l || is_arg(args.(i + 1u))) {\n-                            vec::push[optval](vals.(optid), given);\n+                            vals.(optid) += ~[given];\n                         } else {\n                             i += 1u;\n-                            vec::push[optval](vals.(optid), val(args.(i)));\n+                            vals.(optid) += ~[val(args.(i))];\n                         }\n                     }\n                     case (yes) {\n                         if (!option::is_none[str](i_arg)) {\n-                            vec::push[optval](vals.(optid),\n-                                              val(option::get[str](i_arg)));\n+                            vals.(optid) += ~[val(option::get[str](i_arg))];\n                         } else if (i + 1u == l) {\n                             ret failure(argument_missing(name_str(nm)));\n                         } else {\n                             i += 1u;\n-                            vec::push[optval](vals.(optid), val(args.(i)));\n+                            vals.(optid) += ~[val(args.(i))];\n                         }\n                     }\n                 }\n@@ -203,7 +213,7 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n     }\n     i = 0u;\n     while (i < n_opts) {\n-        auto n = vec::len[optval](vals.(i));\n+        auto n = ivec::len[optval](vals.(i));\n         auto occ = opts.(i).occur;\n         if (occ == req) {\n             if (n == 0u) {\n@@ -220,7 +230,7 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n     ret success(rec(opts=opts, vals=vals, free=free));\n }\n \n-fn opt_vals(match m, str nm) -> vec[optval] {\n+fn opt_vals(match m, str nm) -> optval[] {\n     ret alt (find_opt(m.opts, mkname(nm))) {\n             case (some(?id)) { m.vals.(id) }\n             case (none) { log_err \"No option '\" + nm + \"' defined.\"; fail }\n@@ -230,7 +240,7 @@ fn opt_vals(match m, str nm) -> vec[optval] {\n fn opt_val(match m, str nm) -> optval { ret opt_vals(m, nm).(0); }\n \n fn opt_present(match m, str nm) -> bool {\n-    ret vec::len[optval](opt_vals(m, nm)) > 0u;\n+    ret ivec::len[optval](opt_vals(m, nm)) > 0u;\n }\n \n fn opt_str(match m, str nm) -> str {\n@@ -240,14 +250,22 @@ fn opt_str(match m, str nm) -> str {\n fn opt_strs(match m, str nm) -> vec[str] {\n     let vec[str] acc = [];\n     for (optval v in opt_vals(m, nm)) {\n-        alt (v) { case (val(?s)) { vec::push[str](acc, s); } case (_) { } }\n+        alt (v) { case (val(?s)) { acc += [s]; } case (_) { } }\n+    }\n+    ret acc;\n+}\n+\n+fn opt_strs_ivec(match m, str nm) -> str[] {\n+    let str[] acc = ~[];\n+    for (optval v in opt_vals(m, nm)) {\n+        alt (v) { case (val(?s)) { acc += ~[s]; } case (_) { } }\n     }\n     ret acc;\n }\n \n fn opt_maybe_str(match m, str nm) -> option::t[str] {\n     auto vals = opt_vals(m, nm);\n-    if (vec::len[optval](vals) == 0u) { ret none[str]; }\n+    if (ivec::len[optval](vals) == 0u) { ret none[str]; }\n     ret alt (vals.(0)) {\n             case (val(?s)) { some[str](s) }\n             case (_) { none[str] }\n@@ -260,7 +278,7 @@ fn opt_maybe_str(match m, str nm) -> option::t[str] {\n /// present and an argument was provided.\n fn opt_default(match m, str nm, str def) -> option::t[str] {\n     auto vals = opt_vals(m, nm);\n-    if (vec::len[optval](vals) == 0u) { ret none[str]; }\n+    if (ivec::len[optval](vals) == 0u) { ret none[str]; }\n     ret alt (vals.(0)) {\n             case (val(?s)) { some[str](s) }\n             case (_) { some[str](def) }"}]}