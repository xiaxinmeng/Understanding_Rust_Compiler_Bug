{"sha": "cc23d17ce9288cee77f0441018a248a6bd106880", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMjNkMTdjZTkyODhjZWU3N2YwNDQxMDE4YTI0OGE2YmQxMDY4ODA=", "commit": {"author": {"name": "Tim Neumann", "email": "mail@timnn.me", "date": "2017-03-14T15:35:11Z"}, "committer": {"name": "Tim Neumann", "email": "mail@timnn.me", "date": "2017-03-15T05:59:09Z"}, "message": "make shift builtins panic-free with new unchecked_sh* intrinsics\n\nAlso update some 128 bit builtins to be panic-free without relying\non the const evaluator.", "tree": {"sha": "af8f25a9b894fc143c1b2f1a88e2d9b94335fa5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af8f25a9b894fc143c1b2f1a88e2d9b94335fa5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc23d17ce9288cee77f0441018a248a6bd106880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc23d17ce9288cee77f0441018a248a6bd106880", "html_url": "https://github.com/rust-lang/rust/commit/cc23d17ce9288cee77f0441018a248a6bd106880", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc23d17ce9288cee77f0441018a248a6bd106880/comments", "author": {"login": "TimNN", "id": 1178249, "node_id": "MDQ6VXNlcjExNzgyNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1178249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimNN", "html_url": "https://github.com/TimNN", "followers_url": "https://api.github.com/users/TimNN/followers", "following_url": "https://api.github.com/users/TimNN/following{/other_user}", "gists_url": "https://api.github.com/users/TimNN/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimNN/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimNN/subscriptions", "organizations_url": "https://api.github.com/users/TimNN/orgs", "repos_url": "https://api.github.com/users/TimNN/repos", "events_url": "https://api.github.com/users/TimNN/events{/privacy}", "received_events_url": "https://api.github.com/users/TimNN/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimNN", "id": 1178249, "node_id": "MDQ6VXNlcjExNzgyNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1178249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimNN", "html_url": "https://github.com/TimNN", "followers_url": "https://api.github.com/users/TimNN/followers", "following_url": "https://api.github.com/users/TimNN/following{/other_user}", "gists_url": "https://api.github.com/users/TimNN/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimNN/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimNN/subscriptions", "organizations_url": "https://api.github.com/users/TimNN/orgs", "repos_url": "https://api.github.com/users/TimNN/repos", "events_url": "https://api.github.com/users/TimNN/events{/privacy}", "received_events_url": "https://api.github.com/users/TimNN/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "html_url": "https://github.com/rust-lang/rust/commit/6f10e2f63de720468e2b4bfcb275e4b90b1f9870"}], "stats": {"total": 151, "additions": 123, "deletions": 28}, "files": [{"sha": "58aba11e4394f6e619c60775d353cb0df68b35c8", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=cc23d17ce9288cee77f0441018a248a6bd106880", "patch": "@@ -34,8 +34,8 @@ pub mod reimpls {\n     macro_rules! ashl {\n         ($a:expr, $b:expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits >> 1;\n+            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n+            let half_bits = bits.wrapping_shr(1);\n             if b & half_bits != 0 {\n                 <$ty>::from_parts(0, a.low().wrapping_shl(\n                                         b.wrapping_sub(half_bits) as u32))\n@@ -58,8 +58,8 @@ pub mod reimpls {\n     macro_rules! ashr {\n         ($a: expr, $b: expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits >> 1;\n+            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n+            let half_bits = bits.wrapping_shr(1);\n             if b & half_bits != 0 {\n                 <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32)\n                                   as <$ty as LargeInt>::LowHalf,\n@@ -83,8 +83,8 @@ pub mod reimpls {\n     macro_rules! lshr {\n         ($a: expr, $b: expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits >> 1;\n+            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n+            let half_bits = bits.wrapping_shr(1);\n             if b & half_bits != 0 {\n                 <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32), 0)\n             } else if b == 0 {\n@@ -370,7 +370,7 @@ pub mod reimpls {\n     macro_rules! mul {\n         ($a:expr, $b:expr, $ty: ty, $tyh: ty) => {{\n             let (a, b) = ($a, $b);\n-            let half_bits = ((::core::mem::size_of::<$tyh>() * 8) / 2) as u32;\n+            let half_bits = ::core::mem::size_of::<$tyh>().wrapping_mul(4) as u32;\n             let lower_mask = (!0u64).wrapping_shr(half_bits);\n             let mut low = (a.low() & lower_mask).wrapping_mul(b.low() & lower_mask);\n             let mut t = low.wrapping_shr(half_bits);\n@@ -478,7 +478,7 @@ pub mod reimpls {\n             let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n             if sign == -1.0 || exponent < 0 { return 0 as u128; }\n-            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+            if exponent > ::core::mem::size_of::<$outty>().wrapping_mul(8) as i32 {\n                 return !(0 as u128);\n             }\n             (if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n@@ -503,7 +503,7 @@ pub mod reimpls {\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n \n             if exponent < 0 { return 0 as i128; }\n-            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+            if exponent > ::core::mem::size_of::<$outty>().wrapping_mul(8) as i32 {\n                 let ret = if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n                 return ret\n             }"}, {"sha": "f8d067e9696fd560cef0e8cc4cdc20b9bbce7339", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=cc23d17ce9288cee77f0441018a248a6bd106880", "patch": "@@ -1238,6 +1238,15 @@ extern \"rust-intrinsic\" {\n     /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n     pub fn unchecked_rem<T>(x: T, y: T) -> T;\n \n+    /// Performs an unchecked left shift, resulting in undefined behavior when\n+    /// y < 0 or y >= N, where N is the width of T in bits.\n+    #[cfg(not(stage0))]\n+    pub fn unchecked_shl<T>(x: T, y: T) -> T;\n+    /// Performs an unchecked right shift, resulting in undefined behavior when\n+    /// y < 0 or y >= N, where N is the width of T in bits.\n+    #[cfg(not(stage0))]\n+    pub fn unchecked_shr<T>(x: T, y: T) -> T;\n+\n     /// Returns (a + b) mod 2^N, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,"}, {"sha": "d12002fdfa7f27e17aca0bc876127ba466ca3010", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 95, "deletions": 18, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=cc23d17ce9288cee77f0441018a248a6bd106880", "patch": "@@ -177,7 +177,7 @@ macro_rules! checked_op {\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($ActualT:ident, $UnsignedT:ty, $BITS:expr,\n+    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n@@ -850,6 +850,16 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[cfg(stage0)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n@@ -875,6 +885,16 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[cfg(stage0)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n@@ -1089,6 +1109,15 @@ macro_rules! int_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n             (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -1111,6 +1140,15 @@ macro_rules! int_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -1268,39 +1306,39 @@ macro_rules! int_impl {\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8, u8, 8,\n+    int_impl! { i8, i8, u8, 8,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16, u16, 16,\n+    int_impl! { i16, i16, u16, 16,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32, u32, 32,\n+    int_impl! { i32, i32, u32, 32,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64, u64, 64,\n+    int_impl! { i64, i64, u64, 64,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i128\"]\n impl i128 {\n-    int_impl! { i128, u128, 128,\n+    int_impl! { i128, i128, u128, 128,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n@@ -1309,7 +1347,7 @@ impl i128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { i16, u16, 16,\n+    int_impl! { isize, i16, u16, 16,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n@@ -1318,7 +1356,7 @@ impl isize {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { i32, u32, 32,\n+    int_impl! { isize, i32, u32, 32,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n@@ -1327,15 +1365,15 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { i64, u64, 64,\n+    int_impl! { isize, i64, u64, 64,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n-    ($ActualT:ty, $BITS:expr,\n+    ($SelfT:ty, $ActualT:ty, $BITS:expr,\n      $ctpop:path,\n      $ctlz:path,\n      $cttz:path,\n@@ -1978,6 +2016,16 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[cfg(stage0)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n@@ -2003,6 +2051,16 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[cfg(stage0)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n@@ -2170,6 +2228,15 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n             (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -2192,6 +2259,16 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -2292,7 +2369,7 @@ macro_rules! uint_impl {\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, 8,\n+    uint_impl! { u8, u8, 8,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2304,7 +2381,7 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, 16,\n+    uint_impl! { u16, u16, 16,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2316,7 +2393,7 @@ impl u16 {\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32, 32,\n+    uint_impl! { u32, u32, 32,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2328,7 +2405,7 @@ impl u32 {\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64, 64,\n+    uint_impl! { u64, u64, 64,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2340,7 +2417,7 @@ impl u64 {\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, 128,\n+    uint_impl! { u128, u128, 128,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2353,7 +2430,7 @@ impl u128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { u16, 16,\n+    uint_impl! { usize, u16, 16,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2365,7 +2442,7 @@ impl usize {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { u32, 32,\n+    uint_impl! { usize, u32, 32,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2378,7 +2455,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { u64, 64,\n+    uint_impl! { usize, u64, 64,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,"}, {"sha": "762bf8592ffccf83049d8804013b8d00f437141d", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=cc23d17ce9288cee77f0441018a248a6bd106880", "patch": "@@ -261,7 +261,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"ctlz\" | \"cttz\" | \"ctpop\" | \"bswap\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n-        \"unchecked_div\" | \"unchecked_rem\" => {\n+        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n             let sty = &arg_tys[0].sty;\n             match int_type_width_signed(sty, ccx) {\n                 Some((width, signed)) =>\n@@ -311,6 +311,13 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             } else {\n                                 bcx.urem(llargs[0], llargs[1])\n                             },\n+                        \"unchecked_shl\" => bcx.shl(llargs[0], llargs[1]),\n+                        \"unchecked_shr\" =>\n+                            if signed {\n+                                bcx.ashr(llargs[0], llargs[1])\n+                            } else {\n+                                bcx.lshr(llargs[0], llargs[1])\n+                            },\n                         _ => bug!(),\n                     },\n                 None => {"}, {"sha": "2861fd288326b001f639e03bbf4fd7bb7f61a140", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc23d17ce9288cee77f0441018a248a6bd106880/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=cc23d17ce9288cee77f0441018a248a6bd106880", "patch": "@@ -273,6 +273,8 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             \"unchecked_div\" | \"unchecked_rem\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n+            \"unchecked_shl\" | \"unchecked_shr\" =>\n+                (1, vec![param(0), param(0)], param(0)),\n \n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n                 (1, vec![param(0), param(0)], param(0)),"}]}