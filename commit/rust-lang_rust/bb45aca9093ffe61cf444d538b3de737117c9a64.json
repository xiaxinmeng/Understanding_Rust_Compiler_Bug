{"sha": "bb45aca9093ffe61cf444d538b3de737117c9a64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNDVhY2E5MDkzZmZlNjFjZjQ0NGQ1MzhiM2RlNzM3MTE3YzlhNjQ=", "commit": {"author": {"name": "Leander Tentrup", "email": "leander.tentrup@gmail.com", "date": "2020-04-02T12:34:51Z"}, "committer": {"name": "Leander Tentrup", "email": "leander.tentrup@gmail.com", "date": "2020-04-03T07:46:07Z"}, "message": "Flatten nested highlight ranges during DFS traversal", "tree": {"sha": "7f7672e3347fa4054480b0d035caeb94d7f0af32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f7672e3347fa4054480b0d035caeb94d7f0af32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb45aca9093ffe61cf444d538b3de737117c9a64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb45aca9093ffe61cf444d538b3de737117c9a64", "html_url": "https://github.com/rust-lang/rust/commit/bb45aca9093ffe61cf444d538b3de737117c9a64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb45aca9093ffe61cf444d538b3de737117c9a64/comments", "author": {"login": "ltentrup", "id": 201808, "node_id": "MDQ6VXNlcjIwMTgwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/201808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ltentrup", "html_url": "https://github.com/ltentrup", "followers_url": "https://api.github.com/users/ltentrup/followers", "following_url": "https://api.github.com/users/ltentrup/following{/other_user}", "gists_url": "https://api.github.com/users/ltentrup/gists{/gist_id}", "starred_url": "https://api.github.com/users/ltentrup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ltentrup/subscriptions", "organizations_url": "https://api.github.com/users/ltentrup/orgs", "repos_url": "https://api.github.com/users/ltentrup/repos", "events_url": "https://api.github.com/users/ltentrup/events{/privacy}", "received_events_url": "https://api.github.com/users/ltentrup/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ltentrup", "id": 201808, "node_id": "MDQ6VXNlcjIwMTgwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/201808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ltentrup", "html_url": "https://github.com/ltentrup", "followers_url": "https://api.github.com/users/ltentrup/followers", "following_url": "https://api.github.com/users/ltentrup/following{/other_user}", "gists_url": "https://api.github.com/users/ltentrup/gists{/gist_id}", "starred_url": "https://api.github.com/users/ltentrup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ltentrup/subscriptions", "organizations_url": "https://api.github.com/users/ltentrup/orgs", "repos_url": "https://api.github.com/users/ltentrup/repos", "events_url": "https://api.github.com/users/ltentrup/events{/privacy}", "received_events_url": "https://api.github.com/users/ltentrup/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c9e9d3f3ebbc7a22d932dd2a3fd63f1e44c4568", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c9e9d3f3ebbc7a22d932dd2a3fd63f1e44c4568", "html_url": "https://github.com/rust-lang/rust/commit/3c9e9d3f3ebbc7a22d932dd2a3fd63f1e44c4568"}], "stats": {"total": 71, "additions": 65, "deletions": 6}, "files": [{"sha": "eb1c54639d2ecff1f1239393ad5de7fae7f87e3b", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bb45aca9093ffe61cf444d538b3de737117c9a64/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb45aca9093ffe61cf444d538b3de737117c9a64/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=bb45aca9093ffe61cf444d538b3de737117c9a64", "patch": "@@ -24,7 +24,7 @@ use crate::{call_info::call_info_for_token, Analysis, FileId};\n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct HighlightedRange {\n     pub range: TextRange,\n     pub highlight: Highlight,\n@@ -55,13 +55,55 @@ pub(crate) fn highlight(\n     };\n \n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n-    let mut res = Vec::new();\n+    // We use a stack for the DFS traversal below.\n+    // When we leave a node, the we use it to flatten the highlighted ranges.\n+    let mut res: Vec<Vec<HighlightedRange>> = vec![Vec::new()];\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n     for event in root.preorder_with_tokens() {\n+        match &event {\n+            WalkEvent::Enter(_) => res.push(Vec::new()),\n+            WalkEvent::Leave(_) => {\n+                /* Flattens the highlighted ranges.\n+                 *\n+                 * For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n+                 * 1) parent-range: Attribute [0, 23)\n+                 * 2) child-range: String [16, 21)\n+                 *\n+                 * The following code implements the flattening, for our example this results to:\n+                 * `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n+                 */\n+                let children = res.pop().unwrap();\n+                let prev = res.last_mut().unwrap();\n+                let needs_flattening = !children.is_empty()\n+                    && !prev.is_empty()\n+                    && children.first().unwrap().range.is_subrange(&prev.last().unwrap().range);\n+                if !needs_flattening {\n+                    prev.extend(children);\n+                } else {\n+                    let mut parent = prev.pop().unwrap();\n+                    for ele in children {\n+                        assert!(ele.range.is_subrange(&parent.range));\n+                        let mut cloned = parent.clone();\n+                        parent.range = TextRange::from_to(parent.range.start(), ele.range.start());\n+                        cloned.range = TextRange::from_to(ele.range.end(), cloned.range.end());\n+                        if !parent.range.is_empty() {\n+                            prev.push(parent);\n+                        }\n+                        prev.push(ele);\n+                        parent = cloned;\n+                    }\n+                    if !parent.range.is_empty() {\n+                        prev.push(parent);\n+                    }\n+                }\n+            }\n+        };\n+        let current = res.last_mut().expect(\"during DFS traversal, the stack must not be empty\");\n+\n         let event_range = match &event {\n             WalkEvent::Enter(it) => it.text_range(),\n             WalkEvent::Leave(it) => it.text_range(),\n@@ -77,7 +119,7 @@ pub(crate) fn highlight(\n             WalkEvent::Enter(Some(mc)) => {\n                 current_macro_call = Some(mc.clone());\n                 if let Some(range) = macro_call_range(&mc) {\n-                    res.push(HighlightedRange {\n+                    current.push(HighlightedRange {\n                         range,\n                         highlight: HighlightTag::Macro.into(),\n                         binding_hash: None,\n@@ -119,19 +161,20 @@ pub(crate) fn highlight(\n \n         if let Some(token) = element.as_token().cloned().and_then(ast::RawString::cast) {\n             let expanded = element_to_highlight.as_token().unwrap().clone();\n-            if highlight_injection(&mut res, &sema, token, expanded).is_some() {\n+            if highlight_injection(current, &sema, token, expanded).is_some() {\n                 continue;\n             }\n         }\n \n         if let Some((highlight, binding_hash)) =\n             highlight_element(&sema, &mut bindings_shadow_count, element_to_highlight)\n         {\n-            res.push(HighlightedRange { range, highlight, binding_hash });\n+            current.push(HighlightedRange { range, highlight, binding_hash });\n         }\n     }\n \n-    res\n+    assert_eq!(res.len(), 1, \"after DFS traversal, the stack should only contain a single element\");\n+    res.pop().unwrap()\n }\n \n fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {"}, {"sha": "7f442bd0fefbd6661ea43c93f5022f631f6145a3", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb45aca9093ffe61cf444d538b3de737117c9a64/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb45aca9093ffe61cf444d538b3de737117c9a64/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=bb45aca9093ffe61cf444d538b3de737117c9a64", "patch": "@@ -131,3 +131,19 @@ fn test_ranges() {\n \n     assert_eq!(&highlights[0].highlight.to_string(), \"field.declaration\");\n }\n+\n+#[test]\n+fn test_flattening() {\n+    let (analysis, file_id) = single_file(r#\"#[cfg(feature = \"foo\")]\"#);\n+\n+    let highlights = analysis.highlight(file_id).unwrap();\n+\n+    // The source code snippet contains 2 nested highlights:\n+    // 1) Attribute spanning the whole string\n+    // 2) The string \"foo\"\n+    // The resulting flattening splits the attribute range:\n+    assert_eq!(highlights.len(), 3);\n+    assert_eq!(&highlights[0].highlight.to_string(), \"attribute\");\n+    assert_eq!(&highlights[1].highlight.to_string(), \"string_literal\");\n+    assert_eq!(&highlights[2].highlight.to_string(), \"attribute\");\n+}"}]}