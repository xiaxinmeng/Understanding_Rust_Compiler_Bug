{"sha": "c440743dcc17635eb65cc509a473d66dc6654e87", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NDA3NDNkY2MxNzYzNWViNjVjYzUwOWE0NzNkNjZkYzY2NTRlODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T13:01:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T13:01:30Z"}, "message": "auto merge of #7403 : catamorphism/rust/package-scripts, r=brson\n\nr? @brson (or @graydon if available) rustpkg/api.rs provides functions intended for package scripts to call.\r\nIt will probably need more functionality added to it later, but this is\r\na start.\r\n\r\nAdded a test case checking that a package script can use the API.\r\n\r\nCloses #6401", "tree": {"sha": "16949e997c37a6a520a340e5d1b1612eb435b746", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16949e997c37a6a520a340e5d1b1612eb435b746"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c440743dcc17635eb65cc509a473d66dc6654e87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c440743dcc17635eb65cc509a473d66dc6654e87", "html_url": "https://github.com/rust-lang/rust/commit/c440743dcc17635eb65cc509a473d66dc6654e87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c440743dcc17635eb65cc509a473d66dc6654e87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bad3e62b48a172389833520fad375fecc3f9be7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bad3e62b48a172389833520fad375fecc3f9be7", "html_url": "https://github.com/rust-lang/rust/commit/0bad3e62b48a172389833520fad375fecc3f9be7"}, {"sha": "3789433b4f588301140c97bb5b67094a8c8576cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3789433b4f588301140c97bb5b67094a8c8576cc", "html_url": "https://github.com/rust-lang/rust/commit/3789433b4f588301140c97bb5b67094a8c8576cc"}], "stats": {"total": 188, "additions": 166, "deletions": 22}, "files": [{"sha": "7f8333561cb8b4ed2db2f36b6e8850c6d05fb5d8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c440743dcc17635eb65cc509a473d66dc6654e87", "patch": "@@ -161,7 +161,7 @@ pub struct compile_upto {\n #[deriving(Eq)]\n pub enum compile_phase {\n     cu_parse,\n-    cu_expand,\n+    cu_expand, // means \"it's already expanded\"\n     cu_typeck,\n     cu_no_trans,\n     cu_everything,"}, {"sha": "9f8e925fa07597dd429d10f3e4783df696961442", "filename": "src/librustpkg/api.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=c440743dcc17635eb65cc509a473d66dc6654e87", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use context::*;\n+use crate::*;\n+use package_id::*;\n+use package_source::*;\n+use version::Version;\n+\n+use core::option::*;\n+use core::os;\n+use core::hashmap::*;\n+use core::path::*;\n+\n+/// Convenience functions intended for calling from pkg.rs\n+\n+fn default_ctxt(p: @Path) -> Ctx {\n+    Ctx { sysroot_opt: Some(p), json: false, dep_cache: @mut HashMap::new() }\n+}\n+\n+pub fn build_lib(sysroot: @Path, root: Path, dest: Path, name: ~str, version: Version,\n+                 lib: Path) {\n+\n+    let pkg_src = PkgSrc {\n+        root: root,\n+        dst_dir: dest,\n+        id: PkgId{ version: version, ..PkgId::new(name)},\n+        libs: ~[mk_crate(lib)],\n+        mains: ~[],\n+        tests: ~[],\n+        benchs: ~[]\n+    };\n+    pkg_src.build(&default_ctxt(sysroot), pkg_src.dst_dir, ~[]);\n+}\n+\n+pub fn build_exe(sysroot: @Path, root: Path, dest: Path, name: ~str, version: Version,\n+                 main: Path) {\n+    let pkg_src = PkgSrc {\n+        root: root,\n+        dst_dir: dest,\n+        id: PkgId{ version: version, ..PkgId::new(name)},\n+        libs: ~[],\n+        mains: ~[mk_crate(main)],\n+        tests: ~[],\n+        benchs: ~[]\n+    };\n+    pkg_src.build(&default_ctxt(sysroot), pkg_src.dst_dir, ~[]);\n+\n+}\n+\n+pub fn install_lib(sysroot: @Path,\n+                   workspace: Path,\n+                   name: ~str,\n+                   lib_path: Path,\n+                   version: Version) {\n+    debug!(\"self_exe: %?\", os::self_exe_path());\n+    debug!(\"sysroot = %s\", sysroot.to_str());\n+    debug!(\"workspace = %s\", workspace.to_str());\n+    // make a PkgSrc\n+    let pkg_id = PkgId{ version: version, ..PkgId::new(name)};\n+    let build_dir = workspace.push(\"build\");\n+    let dst_dir = build_dir.push_rel(&*pkg_id.local_path);\n+    let pkg_src = PkgSrc {\n+        root: copy workspace,\n+        dst_dir: copy dst_dir,\n+        id: copy pkg_id,\n+        libs: ~[mk_crate(lib_path)],\n+        mains: ~[],\n+        tests: ~[],\n+        benchs: ~[]\n+    };\n+    let cx = default_ctxt(sysroot);\n+    pkg_src.build(&cx, dst_dir, ~[]);\n+    cx.install_no_build(&workspace, &pkg_id);\n+}\n+\n+pub fn install_exe(sysroot: @Path, workspace: Path, name: ~str, version: Version) {\n+    default_ctxt(sysroot).install(&workspace, &PkgId{ version: version,\n+                                            ..PkgId::new(name)});\n+\n+}\n+\n+fn mk_crate(p: Path) -> Crate {\n+    Crate { file: p, flags: ~[], cfgs: ~[] }\n+}\n\\ No newline at end of file"}, {"sha": "d70428e733858feeb9453325494761aa60d6d5c0", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=c440743dcc17635eb65cc509a473d66dc6654e87", "patch": "@@ -46,6 +46,7 @@ use context::Ctx;\n use package_id::PkgId;\n use package_source::PkgSrc;\n \n+pub mod api;\n mod conditions;\n mod context;\n mod crate;\n@@ -104,8 +105,10 @@ impl<'self> PkgScript<'self> {\n         let binary = os::args()[0].to_managed();\n         // Build the rustc session data structures to pass\n         // to the compiler\n+    debug!(\"pkgscript parse: %?\", os::self_exe_path());\n         let options = @session::options {\n             binary: binary,\n+            maybe_sysroot: Some(@os::self_exe_path().get().pop()),\n             crate_type: session::bin_crate,\n             .. copy *session::basic_options()\n         };\n@@ -132,8 +135,7 @@ impl<'self> PkgScript<'self> {\n     /// Returns a pair of an exit code and list of configs (obtained by\n     /// calling the package script's configs() function if it exists\n     // FIXME (#4432): Use workcache to only compile the script when changed\n-    fn run_custom(&self, what: ~str) -> (~[~str], ExitCode) {\n-        debug!(\"run_custom: %s\", what);\n+    fn run_custom(&self, sysroot: @Path) -> (~[~str], ExitCode) {\n         let sess = self.sess;\n \n         debug!(\"Working directory = %s\", self.build_dir.to_str());\n@@ -152,9 +154,12 @@ impl<'self> PkgScript<'self> {\n                                                sess,\n                                                crate,\n                                                driver::build_configuration(sess,\n-                                                                           binary, &self.input));\n-                debug!(\"Running program: %s %s %s\", exe.to_str(), root.to_str(), what);\n-                let status = run::process_status(exe.to_str(), [root.to_str(), what]);\n+                                                                           binary, &self.input),\n+                                               driver::cu_parse);\n+                debug!(\"Running program: %s %s %s %s\", exe.to_str(),\n+                       sysroot.to_str(), root.to_str(), \"install\");\n+                // FIXME #7401 should support commands besides `install`\n+                let status = run::process_status(exe.to_str(), [sysroot.to_str(), ~\"install\"]);\n                 if status != 0 {\n                     return (~[], status);\n                 }\n@@ -291,10 +296,8 @@ impl Ctx {\n                 let pscript = PkgScript::parse(package_script_path,\n                                                workspace,\n                                                pkgid);\n-                // Limited right now -- we're only running the post_build\n-                // hook and probably fail otherwise\n-                // also post_build should be called pre_build\n-                let (cfgs, hook_result) = pscript.run_custom(~\"post_build\");\n+                let sysroot = self.sysroot_opt.expect(\"custom build needs a sysroot\");\n+                let (cfgs, hook_result) = pscript.run_custom(sysroot);\n                 debug!(\"Command return code = %?\", hook_result);\n                 if hook_result != 0 {\n                     fail!(\"Error running custom build command\")\n@@ -341,13 +344,17 @@ impl Ctx {\n     }\n \n     fn install(&self, workspace: &Path, id: &PkgId)  {\n-        use conditions::copy_failed::cond;\n-\n-        // Should use RUST_PATH in the future.\n+        // FIXME #7402: Use RUST_PATH to determine target dir\n         // Also should use workcache to not build if not necessary.\n         self.build(workspace, id);\n         debug!(\"install: workspace = %s, id = %s\", workspace.to_str(),\n                id.to_str());\n+        self.install_no_build(workspace, id);\n+\n+    }\n+\n+    fn install_no_build(&self, workspace: &Path, id: &PkgId) {\n+        use conditions::copy_failed::cond;\n \n         // Now copy stuff into the install dirs\n         let maybe_executable = built_executable_in_workspace(id, workspace);"}, {"sha": "afeb64075335be80bcd38c7c09f9c5be2903e4aa", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=c440743dcc17635eb65cc509a473d66dc6654e87", "patch": "@@ -545,6 +545,22 @@ fn rustpkg_local_pkg() {\n     assert_executable_exists(&dir, \"foo\");\n }\n \n+#[test]\n+fn package_script_with_default_build() {\n+    let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n+    debug!(\"dir = %s\", dir.to_str());\n+    let source = test_sysroot().pop().pop().pop().push(\"src\").push(\"librustpkg\").\n+        push(\"testsuite\").push(\"pass\").push(\"src\").push(\"fancy-lib\").push(\"pkg.rs\");\n+    debug!(\"package_script_with_default_build: %s\", source.to_str());\n+    if !os::copy_file(&source,\n+                      & dir.push(\"src\").push(\"fancy_lib-0.1\").push(\"pkg.rs\")) {\n+        fail!(\"Couldn't copy file\");\n+    }\n+    command_line_test([~\"install\", ~\"fancy-lib\"], &dir);\n+    assert_lib_exists(&dir, \"fancy-lib\");\n+    assert!(os::path_exists(&dir.push(\"build\").push(\"fancy_lib\").push(\"generated.rs\")));\n+}\n+\n #[test]\n #[ignore (reason = \"RUST_PATH not yet implemented -- #5682\")]\n fn rust_path_test() {"}, {"sha": "dc068eed143efd313d93299be2e0debbc10a0228", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs?ref=c440743dcc17635eb65cc509a473d66dc6654e87", "previous_filename": "src/librustpkg/testsuite/pass/src/fancy-lib/fancy-lib.rs"}, {"sha": "009f37c8a49e7f1852df964a1ecf698d727886c6", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=c440743dcc17635eb65cc509a473d66dc6654e87", "patch": "@@ -8,12 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::run;\n+extern mod rustpkg;\n+extern mod rustc;\n+\n+use std::{io, os};\n+use rustpkg::api;\n+use rustpkg::version::NoVersion;\n+\n+use rustc::metadata::filesearch;\n \n pub fn main() {\n-    use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+    use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+    let args = os::args();\n+\n+// by convention, first arg is sysroot\n+    if args.len() < 2 {\n+        fail!(\"Package script requires a directory where rustc libraries live as the first \\\n+               argument\");\n+    }\n+\n+    let sysroot_arg = copy args[1];\n+    let sysroot = Path(sysroot_arg);\n+    if !os::path_exists(&sysroot) {\n+        fail!(\"Package script requires a sysroot that exists; %s doesn't\", sysroot.to_str());\n+    }\n+\n+    if args[2] != ~\"install\" {\n+        io::println(fmt!(\"Warning: I don't know how to %s\", args[2]));\n+        return;\n+    }\n \n-    let out_path = Path(~\"build/fancy_lib\");\n+    let out_path = Path(\"build/fancy_lib\");\n     if !os::path_exists(&out_path) {\n         assert!(os::make_dir(&out_path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n     }\n@@ -22,7 +47,10 @@ pub fn main() {\n                                [io::Create]).get();\n     file.write_str(\"pub fn wheeeee() { for [1, 2, 3].each() |_| { assert!(true); } }\");\n \n-    // now compile the crate itself\n-    run::process_status(\"rustc\", [~\"src/fancy-lib/fancy-lib.rs\", ~\"--lib\", ~\"-o\",\n-                        out_path.push(~\"fancy_lib\").to_str()]);\n+\n+    debug!(\"api_____install_____lib, my sysroot:\");\n+    debug!(sysroot.to_str());\n+\n+    api::install_lib(@sysroot, os::getcwd(), ~\"fancy-lib\", Path(\"lib.rs\"),\n+                     NoVersion);\n }\n\\ No newline at end of file"}, {"sha": "92cc5bbd2c1db1e07b09ad1860cd6f69f74f8a0f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=c440743dcc17635eb65cc509a473d66dc6654e87", "patch": "@@ -257,7 +257,7 @@ pub fn compile_input(ctxt: &Ctx,\n \n     debug!(\"calling compile_crate_from_input, out_dir = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    compile_crate_from_input(&input, out_dir, sess, crate, copy cfg);\n+    compile_crate_from_input(&input, out_dir, sess, crate, copy cfg, driver::cu_expand);\n     true\n }\n \n@@ -270,7 +270,8 @@ pub fn compile_crate_from_input(input: &driver::input,\n                                 build_dir: &Path,\n                                 sess: session::Session,\n                                 crate: @ast::crate,\n-                                cfg: ast::crate_cfg) {\n+                                cfg: ast::crate_cfg,\n+                                compile_from: driver::compile_phase) {\n     debug!(\"Calling build_output_filenames with %s, building library? %?\",\n            build_dir.to_str(), sess.building_library);\n \n@@ -287,7 +288,7 @@ pub fn compile_crate_from_input(input: &driver::input,\n     driver::compile_rest(sess,\n                          cfg,\n                          compile_upto {\n-                             from: driver::cu_expand,\n+                             from: compile_from,\n                              to: driver::cu_everything\n                          },\n                          Some(outputs),"}]}