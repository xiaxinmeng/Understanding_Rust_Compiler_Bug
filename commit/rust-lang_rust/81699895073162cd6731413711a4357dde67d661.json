{"sha": "81699895073162cd6731413711a4357dde67d661", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNjk5ODk1MDczMTYyY2Q2NzMxNDEzNzExYTQzNTdkZGU2N2Q2NjE=", "commit": {"author": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2020-09-19T19:32:33Z"}, "committer": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2020-09-20T16:05:31Z"}, "message": "Add non-`unsafe` `.get_mut()` for `UnsafeCell`\n\nUpdate the tracking issue number\n\nUpdated the documentation for `UnsafeCell`\n\nAddress review comments\n\nAddress more review comments + minor changes", "tree": {"sha": "9a0bf6f189fe608db9f0055a474c3d949ac82c44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a0bf6f189fe608db9f0055a474c3d949ac82c44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81699895073162cd6731413711a4357dde67d661", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81699895073162cd6731413711a4357dde67d661", "html_url": "https://github.com/rust-lang/rust/commit/81699895073162cd6731413711a4357dde67d661", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81699895073162cd6731413711a4357dde67d661/comments", "author": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3aae050cd7e0c9a9eb6085bd49b02f67dc1396f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3aae050cd7e0c9a9eb6085bd49b02f67dc1396f", "html_url": "https://github.com/rust-lang/rust/commit/b3aae050cd7e0c9a9eb6085bd49b02f67dc1396f"}], "stats": {"total": 93, "additions": 84, "deletions": 9}, "files": [{"sha": "44b863b220051fec921da271a9d528ab17336da0", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 84, "deletions": 9, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/81699895073162cd6731413711a4357dde67d661/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81699895073162cd6731413711a4357dde67d661/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=81699895073162cd6731413711a4357dde67d661", "patch": "@@ -1543,8 +1543,11 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// allow internal mutability, such as `Cell<T>` and `RefCell<T>`, use `UnsafeCell` to wrap their\n /// internal data. There is *no* legal way to obtain aliasing `&mut`, not even with `UnsafeCell<T>`.\n ///\n-/// The `UnsafeCell` API itself is technically very simple: it gives you a raw pointer `*mut T` to\n-/// its contents. It is up to _you_ as the abstraction designer to use that raw pointer correctly.\n+/// The `UnsafeCell` API itself is technically very simple: [`.get()`] gives you a raw pointer\n+/// `*mut T` to its contents. It is up to _you_ as the abstraction designer to use that raw pointer\n+/// correctly.\n+///\n+/// [`.get()`]: `UnsafeCell::get`\n ///\n /// The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:\n ///\n@@ -1571,21 +1574,70 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// 2. A `&mut T` reference may be released to safe code provided neither other `&mut T` nor `&T`\n /// co-exist with it. A `&mut T` must always be unique.\n ///\n-/// Note that while mutating or mutably aliasing the contents of an `&UnsafeCell<T>` is\n-/// ok (provided you enforce the invariants some other way), it is still undefined behavior\n-/// to have multiple `&mut UnsafeCell<T>` aliases.\n+/// Note that whilst mutating the contents of an `&UnsafeCell<T>` (even while other\n+/// `&UnsafeCell<T>` references alias the cell) is\n+/// ok (provided you enforce the above invariants some other way), it is still undefined behavior\n+/// to have multiple `&mut UnsafeCell<T>` aliases. That is, `UnsafeCell` is a wrapper\n+/// designed to have a special interaction with _shared_ accesses (_i.e._, through an\n+/// `&UnsafeCell<_>` reference); there is no magic whatsoever when dealing with _exclusive_\n+/// accesses (_e.g._, through an `&mut UnsafeCell<_>`): neither the cell nor the wrapped value\n+/// may be aliased for the duration of that `&mut` borrow.\n+/// This is showcased by the [`.get_mut()`] accessor, which is a non-`unsafe` getter that yields\n+/// a `&mut T`.\n+///\n+/// [`.get_mut()`]: `UnsafeCell::get_mut`\n ///\n /// # Examples\n ///\n+/// Here is an example showcasing how to soundly mutate the contents of an `UnsafeCell<_>` despite\n+/// there being multiple references aliasing the cell:\n+///\n /// ```\n /// use std::cell::UnsafeCell;\n ///\n-/// # #[allow(dead_code)]\n-/// struct NotThreadSafe<T> {\n-///     value: UnsafeCell<T>,\n+/// let x: UnsafeCell<i32> = 42.into();\n+/// // Get multiple / concurrent / shared references to the same `x`.\n+/// let (p1, p2): (&UnsafeCell<i32>, &UnsafeCell<i32>) = (&x, &x);\n+///\n+/// unsafe {\n+///     // SAFETY: within this scope there are no other references to `x`'s contents,\n+///     // so ours is effectively unique.\n+///     let p1_exclusive: &mut i32 = &mut *p1.get(); // -- borrow --+\n+///     *p1_exclusive += 27; //                                     |\n+/// } // <---------- cannot go beyond this point -------------------+\n+///\n+/// unsafe {\n+///     // SAFETY: within this scope nobody expects to have exclusive access to `x`'s contents,\n+///     // so we can have multiple shared accesses concurrently.\n+///     let p2_shared: &i32 = &*p2.get();\n+///     assert_eq!(*p2_shared, 42 + 27);\n+///     let p1_shared: &i32 = &*p1.get();\n+///     assert_eq!(*p1_shared, *p2_shared);\n /// }\n+/// ```\n+///\n+/// The following example showcases the fact that exclusive access to an `UnsafeCell<T>`\n+/// implies exclusive access to its `T`:\n ///\n-/// unsafe impl<T> Sync for NotThreadSafe<T> {}\n+/// ```rust\n+/// #![feature(unsafe_cell_get_mut)]\n+/// #![forbid(unsafe_code)] // with exclusive accesses,\n+///                         // `UnsafeCell` is a transparent no-op wrapper,\n+///                         // so no need for `unsafe` here.\n+/// use std::cell::UnsafeCell;\n+///\n+/// let mut x: UnsafeCell<i32> = 42.into();\n+///\n+/// // Get a compile-time-checked unique reference to `x`.\n+/// let p_unique: &mut UnsafeCell<i32> = &mut x;\n+/// // With an exclusive reference, we can mutate the contents for free.\n+/// *p_unique.get_mut() = 0;\n+/// // Or, equivalently:\n+/// x = UnsafeCell::new(0);\n+///\n+/// // When we own the value, we can extract the contents for free.\n+/// let contents: i32 = x.into_inner();\n+/// assert_eq!(contents, 0);\n /// ```\n #[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1663,6 +1715,29 @@ impl<T: ?Sized> UnsafeCell<T> {\n         self as *const UnsafeCell<T> as *const T as *mut T\n     }\n \n+    /// Returns a mutable reference to the underlying data.\n+    ///\n+    /// This call borrows the `UnsafeCell` mutably (at compile-time) which\n+    /// guarantees that we possess the only reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unsafe_cell_get_mut)]\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// let mut c = UnsafeCell::new(5);\n+    /// *c.get_mut() += 1;\n+    ///\n+    /// assert_eq!(*c.get_mut(), 6);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"unsafe_cell_get_mut\", issue = \"76943\")]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: (outer) `&mut` guarantees unique access.\n+        unsafe { &mut *self.get() }\n+    }\n+\n     /// Gets a mutable pointer to the wrapped value.\n     /// The difference to [`get`] is that this function accepts a raw pointer,\n     /// which is useful to avoid the creation of temporary references."}]}