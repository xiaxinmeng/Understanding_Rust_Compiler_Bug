{"sha": "5ab502c6d308b0ccac8127c0464e432334755a60", "node_id": "C_kwDOAAsO6NoAKDVhYjUwMmM2ZDMwOGIwY2NhYzgxMjdjMDQ2NGU0MzIzMzQ3NTVhNjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-28T01:33:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-28T01:33:00Z"}, "message": "Auto merge of #93376 - flip1995:clippyup, r=Manishearth\n\nUpdate Clippy\n\nr? `@Manishearth`", "tree": {"sha": "6db0c39580d0eded0dfa8e15f1524b1290a92c59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6db0c39580d0eded0dfa8e15f1524b1290a92c59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ab502c6d308b0ccac8127c0464e432334755a60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab502c6d308b0ccac8127c0464e432334755a60", "html_url": "https://github.com/rust-lang/rust/commit/5ab502c6d308b0ccac8127c0464e432334755a60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ab502c6d308b0ccac8127c0464e432334755a60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b4109306c1d98a8e993ec2c748d286927dddbf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b4109306c1d98a8e993ec2c748d286927dddbf5", "html_url": "https://github.com/rust-lang/rust/commit/1b4109306c1d98a8e993ec2c748d286927dddbf5"}, {"sha": "cce9231c19378f57b05f3c8b09df317c3a512f82", "url": "https://api.github.com/repos/rust-lang/rust/commits/cce9231c19378f57b05f3c8b09df317c3a512f82", "html_url": "https://github.com/rust-lang/rust/commit/cce9231c19378f57b05f3c8b09df317c3a512f82"}], "stats": {"total": 2838, "additions": 1841, "deletions": 997}, "files": [{"sha": "d66e6cf7fb6596ad20f5cfb1bf9dfba0e409d624", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -981,7 +981,7 @@ Released 2021-03-25\n   [#6532](https://github.com/rust-lang/rust-clippy/pull/6532)\n * [`single_match`] Suggest `if` over `if let` when possible\n   [#6574](https://github.com/rust-lang/rust-clippy/pull/6574)\n-* [`ref_in_deref`] Use parentheses correctly in suggestion\n+* `ref_in_deref` Use parentheses correctly in suggestion\n   [#6609](https://github.com/rust-lang/rust-clippy/pull/6609)\n * [`stable_sort_primitive`] Clarify error message\n   [#6611](https://github.com/rust-lang/rust-clippy/pull/6611)\n@@ -3227,7 +3227,6 @@ Released 2018-09-13\n [`redundant_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_slicing\n [`redundant_static_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes\n [`ref_binding_to_reference`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_binding_to_reference\n-[`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n [`ref_option_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_option_ref\n [`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro\n [`repeat_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#repeat_once"}, {"sha": "dcc2502e4c59a0f2cf4b01ac0f08669fe828c108", "filename": "src/tools/clippy/clippy_dev/src/bless.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -9,9 +9,14 @@ use walkdir::WalkDir;\n \n use crate::clippy_project_root;\n \n+#[cfg(not(windows))]\n+static CARGO_CLIPPY_EXE: &str = \"cargo-clippy\";\n+#[cfg(windows)]\n+static CARGO_CLIPPY_EXE: &str = \"cargo-clippy.exe\";\n+\n static CLIPPY_BUILD_TIME: SyncLazy<Option<std::time::SystemTime>> = SyncLazy::new(|| {\n     let mut path = std::env::current_exe().unwrap();\n-    path.set_file_name(\"cargo-clippy\");\n+    path.set_file_name(CARGO_CLIPPY_EXE);\n     fs::metadata(path).ok()?.modified().ok()\n });\n "}, {"sha": "b8287980a4bacea5df7cadbe2a50621eac7e6131", "filename": "src/tools/clippy/clippy_dev/src/lint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -7,7 +7,6 @@ pub fn run(filename: &str) {\n         .args([\"-Z\", \"no-codegen\"])\n         .args([\"--edition\", \"2021\"])\n         .arg(filename)\n-        .env(\"__CLIPPY_INTERNAL_TESTS\", \"true\")\n         .status()\n         .expect(\"failed to run cargo\")\n         .code();"}, {"sha": "9f8eb488c29ba049cf25619ac4e6902d137415fb", "filename": "src/tools/clippy/clippy_lints/src/borrow_as_ptr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_as_ptr.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -94,4 +94,6 @@ impl<'tcx> LateLintPass<'tcx> for BorrowAsPtr {\n             }\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }"}, {"sha": "470c8c7ea26a60dd2b48b142ffac3cb6ec10a63b", "filename": "src/tools/clippy/clippy_lints/src/casts/unnecessary_cast.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -23,15 +23,14 @@ pub(super) fn check(\n \n         if_chain! {\n             if let LitKind::Int(n, _) = lit.node;\n-            if let Some(src) = snippet_opt(cx, lit.span);\n+            if let Some(src) = snippet_opt(cx, cast_expr.span);\n             if cast_to.is_floating_point();\n             if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node);\n             let from_nbits = 128 - n.leading_zeros();\n             let to_nbits = fp_ty_mantissa_nbits(cast_to);\n             if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n             then {\n-                let literal_str = if is_unary_neg(cast_expr) { format!(\"-{}\", num_lit.integer) } else { num_lit.integer.into() };\n-                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                lint_unnecessary_cast(cx, expr, num_lit.integer, cast_from, cast_to);\n                 return true\n             }\n         }\n@@ -48,7 +47,7 @@ pub(super) fn check(\n             | LitKind::Float(_, LitFloatType::Suffixed(_))\n                 if cast_from.kind() == cast_to.kind() =>\n             {\n-                if let Some(src) = snippet_opt(cx, lit.span) {\n+                if let Some(src) = snippet_opt(cx, cast_expr.span) {\n                     if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node) {\n                         lint_unnecessary_cast(cx, expr, num_lit.integer, cast_from, cast_to);\n                     }\n@@ -113,7 +112,3 @@ fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n         _ => 0,\n     }\n }\n-\n-fn is_unary_neg(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Unary(UnOp::Neg, _))\n-}"}, {"sha": "c0adab790f0d51a2971311113ed506fa244190da", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 144, "deletions": 55, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::sugg::has_enclosing_paren;\n use clippy_utils::ty::peel_mid_ty_refs;\n use clippy_utils::{get_parent_expr, get_parent_node, is_lint_allowed, path_to_local};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n@@ -10,11 +11,10 @@ use rustc_hir::{\n     Pat, PatKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{self, Ty, TyCtxt, TyS, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span};\n-use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -131,8 +131,6 @@ pub struct Dereferencing {\n struct StateData {\n     /// Span of the top level expression\n     span: Span,\n-    /// The required mutability\n-    target_mut: Mutability,\n }\n \n enum State {\n@@ -141,9 +139,13 @@ enum State {\n         // The number of calls in a sequence which changed the referenced type\n         ty_changed_count: usize,\n         is_final_ufcs: bool,\n+        /// The required mutability\n+        target_mut: Mutability,\n     },\n     DerefedBorrow {\n-        count: u32,\n+        count: usize,\n+        required_precedence: i8,\n+        msg: &'static str,\n     },\n }\n \n@@ -214,59 +216,98 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     1\n                                 },\n                                 is_final_ufcs: matches!(expr.kind, ExprKind::Call(..)),\n-                            },\n-                            StateData {\n-                                span: expr.span,\n                                 target_mut,\n                             },\n+                            StateData { span: expr.span },\n                         ));\n                     },\n                     RefOp::AddrOf => {\n                         // Find the number of times the borrow is auto-derefed.\n                         let mut iter = find_adjustments(cx.tcx, typeck, expr).iter();\n-                        if let Some((i, adjust)) = iter.by_ref().enumerate().find_map(|(i, adjust)| {\n-                            if !matches!(adjust.kind, Adjust::Deref(_)) {\n-                                Some((i, adjust))\n-                            } else if !adjust.target.is_ref() {\n-                                // Add one to the number of references found.\n-                                Some((i + 1, adjust))\n+                        let mut deref_count = 0usize;\n+                        let next_adjust = loop {\n+                            match iter.next() {\n+                                Some(adjust) => {\n+                                    if !matches!(adjust.kind, Adjust::Deref(_)) {\n+                                        break Some(adjust);\n+                                    } else if !adjust.target.is_ref() {\n+                                        deref_count += 1;\n+                                        break iter.next();\n+                                    }\n+                                    deref_count += 1;\n+                                },\n+                                None => break None,\n+                            };\n+                        };\n+\n+                        // Determine the required number of references before any can be removed. In all cases the\n+                        // reference made by the current expression will be removed. After that there are four cases to\n+                        // handle.\n+                        //\n+                        // 1. Auto-borrow will trigger in the current position, so no further references are required.\n+                        // 2. Auto-deref ends at a reference, or the underlying type, so one extra needs to be left to\n+                        //    handle the automatically inserted re-borrow.\n+                        // 3. Auto-deref hits a user-defined `Deref` impl, so at least one reference needs to exist to\n+                        //    start auto-deref.\n+                        // 4. If the chain of non-user-defined derefs ends with a mutable re-borrow, and re-borrow\n+                        //    adjustments will not be inserted automatically, then leave one further reference to avoid\n+                        //    moving a mutable borrow.\n+                        //    e.g.\n+                        //        fn foo<T>(x: &mut Option<&mut T>, y: &mut T) {\n+                        //            let x = match x {\n+                        //                // Removing the borrow will cause `x` to be moved\n+                        //                Some(x) => &mut *x,\n+                        //                None => y\n+                        //            };\n+                        //        }\n+                        let deref_msg =\n+                            \"this expression creates a reference which is immediately dereferenced by the compiler\";\n+                        let borrow_msg = \"this expression borrows a value the compiler would automatically borrow\";\n+\n+                        let (required_refs, required_precedence, msg) = if is_auto_borrow_position(parent, expr.hir_id)\n+                        {\n+                            (1, PREC_POSTFIX, if deref_count == 1 { borrow_msg } else { deref_msg })\n+                        } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n+                            next_adjust.map(|a| &a.kind)\n+                        {\n+                            if matches!(mutability, AutoBorrowMutability::Mut { .. })\n+                                && !is_auto_reborrow_position(parent)\n+                            {\n+                                (3, 0, deref_msg)\n                             } else {\n-                                None\n-                            }\n-                        }) {\n-                            // Found two consecutive derefs. At least one can be removed.\n-                            if i > 1 {\n-                                let target_mut = iter::once(adjust)\n-                                    .chain(iter)\n-                                    .find_map(|adjust| match adjust.kind {\n-                                        Adjust::Borrow(AutoBorrow::Ref(_, m)) => Some(m.into()),\n-                                        _ => None,\n-                                    })\n-                                    // This default should never happen. Auto-deref always reborrows.\n-                                    .unwrap_or(Mutability::Not);\n-                                self.state = Some((\n-                                    // Subtract one for the current borrow expression, and one to cover the last\n-                                    // reference which can't be removed (it's either reborrowed, or needed for\n-                                    // auto-deref to happen).\n-                                    State::DerefedBorrow {\n-                                        count:\n-                                            // Truncation here would require more than a `u32::MAX` level reference. The compiler\n-                                            // does not support this.\n-                                            #[allow(clippy::cast_possible_truncation)]\n-                                            { i as u32 - 2 }\n-                                    },\n-                                    StateData {\n-                                        span: expr.span,\n-                                        target_mut,\n-                                    },\n-                                ));\n+                                (2, 0, deref_msg)\n                             }\n+                        } else {\n+                            (2, 0, deref_msg)\n+                        };\n+\n+                        if deref_count >= required_refs {\n+                            self.state = Some((\n+                                State::DerefedBorrow {\n+                                    // One of the required refs is for the current borrow expression, the remaining ones\n+                                    // can't be removed without breaking the code. See earlier comment.\n+                                    count: deref_count - required_refs,\n+                                    required_precedence,\n+                                    msg,\n+                                },\n+                                StateData { span: expr.span },\n+                            ));\n                         }\n                     },\n                     _ => (),\n                 }\n             },\n-            (Some((State::DerefMethod { ty_changed_count, .. }, data)), RefOp::Method(_)) => {\n+            (\n+                Some((\n+                    State::DerefMethod {\n+                        target_mut,\n+                        ty_changed_count,\n+                        ..\n+                    },\n+                    data,\n+                )),\n+                RefOp::Method(_),\n+            ) => {\n                 self.state = Some((\n                     State::DerefMethod {\n                         ty_changed_count: if deref_method_same_type(typeck.expr_ty(expr), typeck.expr_ty(sub_expr)) {\n@@ -275,12 +316,30 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             ty_changed_count + 1\n                         },\n                         is_final_ufcs: matches!(expr.kind, ExprKind::Call(..)),\n+                        target_mut,\n                     },\n                     data,\n                 ));\n             },\n-            (Some((State::DerefedBorrow { count }, data)), RefOp::AddrOf) if count != 0 => {\n-                self.state = Some((State::DerefedBorrow { count: count - 1 }, data));\n+            (\n+                Some((\n+                    State::DerefedBorrow {\n+                        count,\n+                        required_precedence,\n+                        msg,\n+                    },\n+                    data,\n+                )),\n+                RefOp::AddrOf,\n+            ) if count != 0 => {\n+                self.state = Some((\n+                    State::DerefedBorrow {\n+                        count: count - 1,\n+                        required_precedence,\n+                        msg,\n+                    },\n+                    data,\n+                ));\n             },\n \n             (Some((state, data)), _) => report(cx, expr, state, data),\n@@ -455,6 +514,30 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n     }\n }\n \n+/// Checks if the given expression is in a position which can be auto-reborrowed.\n+/// Note: This is only correct assuming auto-deref is already occurring.\n+fn is_auto_reborrow_position(parent: Option<Node<'_>>) -> bool {\n+    match parent {\n+        Some(Node::Expr(parent)) => matches!(parent.kind, ExprKind::MethodCall(..) | ExprKind::Call(..)),\n+        Some(Node::Local(_)) => true,\n+        _ => false,\n+    }\n+}\n+\n+/// Checks if the given expression is a position which can auto-borrow.\n+fn is_auto_borrow_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n+    if let Some(Node::Expr(parent)) = parent {\n+        match parent.kind {\n+            ExprKind::MethodCall(_, [self_arg, ..], _) => self_arg.hir_id == child_id,\n+            ExprKind::Field(..) => true,\n+            ExprKind::Call(f, _) => f.hir_id == child_id,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n /// Adjustments are sometimes made in the parent block rather than the expression itself.\n fn find_adjustments<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -503,6 +586,7 @@ fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData)\n         State::DerefMethod {\n             ty_changed_count,\n             is_final_ufcs,\n+            target_mut,\n         } => {\n             let mut app = Applicability::MachineApplicable;\n             let (expr_str, expr_is_macro_call) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n@@ -517,12 +601,12 @@ fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData)\n             };\n             let addr_of_str = if ty_changed_count < ref_count {\n                 // Check if a reborrow from &mut T -> &T is required.\n-                if data.target_mut == Mutability::Not && matches!(ty.kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                if target_mut == Mutability::Not && matches!(ty.kind(), ty::Ref(_, _, Mutability::Mut)) {\n                     \"&*\"\n                 } else {\n                     \"\"\n                 }\n-            } else if data.target_mut == Mutability::Mut {\n+            } else if target_mut == Mutability::Mut {\n                 \"&mut \"\n             } else {\n                 \"&\"\n@@ -538,7 +622,7 @@ fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData)\n                 cx,\n                 EXPLICIT_DEREF_METHODS,\n                 data.span,\n-                match data.target_mut {\n+                match target_mut {\n                     Mutability::Not => \"explicit `deref` method call\",\n                     Mutability::Mut => \"explicit `deref_mut` method call\",\n                 },\n@@ -547,19 +631,24 @@ fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData)\n                 app,\n             );\n         },\n-        State::DerefedBorrow { .. } => {\n+        State::DerefedBorrow {\n+            required_precedence,\n+            msg,\n+            ..\n+        } => {\n             let mut app = Applicability::MachineApplicable;\n             let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n             span_lint_and_sugg(\n                 cx,\n                 NEEDLESS_BORROW,\n                 data.span,\n-                &format!(\n-                    \"this expression borrows a reference (`{}`) that is immediately dereferenced by the compiler\",\n-                    cx.typeck_results().expr_ty(expr),\n-                ),\n+                msg,\n                 \"change this to\",\n-                snip.into(),\n+                if required_precedence > expr.precedence().order() && !has_enclosing_paren(&snip) {\n+                    format!(\"({})\", snip)\n+                } else {\n+                    snip.into()\n+                },\n                 app,\n             );\n         },"}, {"sha": "1f4353fa4f72bd73a6028f80c49e71d1b552230e", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -172,6 +172,9 @@ fn check_variant(cx: &LateContext<'_>, threshold: u64, def: &EnumDef<'_>, item_n\n         let name = var.ident.name.as_str();\n \n         let variant_split = camel_case_split(name);\n+        if variant_split.len() == 1 {\n+            return;\n+        }\n \n         pre = pre\n             .iter()"}, {"sha": "24d7613e6f8ca6d2061d3d3c3c1e2c6958a9a983", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,12 +1,16 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n+use clippy_utils::get_enclosing_block;\n use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::{implements_trait, is_copy};\n use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind};\n+use rustc_hir::{\n+    def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, Ty, TyKind,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -146,6 +150,13 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                         let rty = cx.typeck_results().expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n                         let rcpy = is_copy(cx, rty);\n+                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                            {\n+                                return; // Don't lint\n+                            }\n+                        }\n                         // either operator autorefs or both args are copyable\n                         if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty.into()]) {\n                             span_lint_and_then(\n@@ -206,6 +217,14 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     // &foo == bar\n                     (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n                         let lty = cx.typeck_results().expr_ty(l);\n+                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                            let rty = cx.typeck_results().expr_ty(right);\n+                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                            {\n+                                return; // Don't lint\n+                            }\n+                        }\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy)\n                             && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n@@ -230,6 +249,14 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     // foo == &bar\n                     (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n                         let rty = cx.typeck_results().expr_ty(r);\n+                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                            let lty = cx.typeck_results().expr_ty(left);\n+                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                            {\n+                                return; // Don't lint\n+                            }\n+                        }\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy)\n                             && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n@@ -251,3 +278,43 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n         }\n     }\n }\n+\n+fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Option<(&'tcx Ty<'tcx>, &'tcx Ty<'tcx>)> {\n+    if_chain! {\n+        if let Some(block) = get_enclosing_block(cx, e.hir_id);\n+        if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n+        let item = cx.tcx.hir().expect_item(impl_def_id.expect_local());\n+        if let ItemKind::Impl(item) = &item.kind;\n+        if let Some(of_trait) = &item.of_trait;\n+        if let Some(seg) = of_trait.path.segments.last();\n+        if let Some(Res::Def(_, trait_id)) = seg.res;\n+        if trait_id == bin_op;\n+        if let Some(generic_args) = seg.args;\n+        if let Some(GenericArg::Type(other_ty)) = generic_args.args.last();\n+\n+        then {\n+            Some((item.self_ty, other_ty))\n+        }\n+        else {\n+            None\n+        }\n+    }\n+}\n+\n+fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: &TyS<'_>, hir_ty: &Ty<'_>) -> bool {\n+    if_chain! {\n+        if let ty::Adt(adt_def, _) = middle_ty.kind();\n+        if let Some(local_did) = adt_def.did.as_local();\n+        let item = cx.tcx.hir().expect_item(local_did);\n+        let middle_ty_id = item.def_id.to_def_id();\n+        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+        if let Res::Def(_, hir_ty_id) = path.res;\n+\n+        then {\n+            hir_ty_id == middle_ty_id\n+        }\n+        else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "eed25e9bc0ea8c7458a18480a2d956af5f9b1aaa", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -179,7 +179,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                             )\n                             .and_then(|snip| {\n                                 let i = snip.find(\"fn\")?;\n-                                Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n+                                Some(item.span.lo() + BytePos((i + snip[i..].find('(')?) as u32))\n                             })\n                             .expect(\"failed to create span for type parameters\");\n                             Span::new(pos, pos, item.span.ctxt(), item.span.parent())"}, {"sha": "4721b7f2b472b3ffaab9da2a2e21b8f486cf8457", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -247,7 +247,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(redundant_slicing::REDUNDANT_SLICING),\n     LintId::of(redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n     LintId::of(reference::DEREF_ADDROF),\n-    LintId::of(reference::REF_IN_DEREF),\n     LintId::of(regex::INVALID_REGEX),\n     LintId::of(repeat_once::REPEAT_ONCE),\n     LintId::of(returns::LET_AND_RETURN),"}, {"sha": "bd5ff613447cddf521113dfccbfe71d863fc1776", "filename": "src/tools/clippy/clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -71,7 +71,6 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n     LintId::of(redundant_slicing::REDUNDANT_SLICING),\n     LintId::of(reference::DEREF_ADDROF),\n-    LintId::of(reference::REF_IN_DEREF),\n     LintId::of(repeat_once::REPEAT_ONCE),\n     LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n     LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),"}, {"sha": "2d2693832e9716721feb10b87b1e9fba457e205a", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -423,7 +423,6 @@ store.register_lints(&[\n     redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n     ref_option_ref::REF_OPTION_REF,\n     reference::DEREF_ADDROF,\n-    reference::REF_IN_DEREF,\n     regex::INVALID_REGEX,\n     regex::TRIVIAL_REGEX,\n     repeat_once::REPEAT_ONCE,"}, {"sha": "f2a7e925dd3952e698461b003c7347330fc020f0", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -581,6 +581,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(needless_question_mark::NeedlessQuestionMark));\n     store.register_late_pass(move || Box::new(casts::Casts::new(msrv)));\n     store.register_early_pass(move || Box::new(unnested_or_patterns::UnnestedOrPatterns::new(msrv)));\n+    store.register_late_pass(move || Box::new(map_clone::MapClone::new(msrv)));\n \n     store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n     store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n@@ -591,7 +592,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             msrv,\n         ))\n     });\n-    store.register_late_pass(|| Box::new(map_clone::MapClone));\n     store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n     store.register_late_pass(|| Box::new(shadow::Shadow::default()));\n     store.register_late_pass(|| Box::new(unit_types::UnitTypes));\n@@ -703,7 +703,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(mut_key::MutableKeyType));\n     store.register_late_pass(|| Box::new(modulo_arithmetic::ModuloArithmetic));\n     store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n-    store.register_early_pass(|| Box::new(reference::RefInDeref));\n     store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n     store.register_late_pass(|| Box::new(to_string_in_display::ToStringInDisplay::new()));\n     store.register_early_pass(|| Box::new(unsafe_removed_from_name::UnsafeNameRemoval));\n@@ -935,6 +934,7 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::if_let_some_result\", \"clippy::match_result_ok\");\n     ls.register_renamed(\"clippy::disallowed_type\", \"clippy::disallowed_types\");\n     ls.register_renamed(\"clippy::disallowed_method\", \"clippy::disallowed_methods\");\n+    ls.register_renamed(\"clippy::ref_in_deref\", \"clippy::needless_borrow\");\n \n     // uplifted lints\n     ls.register_renamed(\"clippy::invalid_ref\", \"invalid_value\");"}, {"sha": "b09c23f31e97049cbf539d9143593d794d65a9c2", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -83,7 +83,7 @@ declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, ref generics, id) = item.kind {\n-            check_fn_inner(cx, sig.decl, Some(id), generics, item.span, true);\n+            check_fn_inner(cx, sig.decl, Some(id), None, generics, item.span, true);\n         }\n     }\n \n@@ -94,6 +94,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 cx,\n                 sig.decl,\n                 Some(id),\n+                None,\n                 &item.generics,\n                 item.span,\n                 report_extra_lifetimes,\n@@ -103,11 +104,11 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if let TraitItemKind::Fn(ref sig, ref body) = item.kind {\n-            let body = match *body {\n-                TraitFn::Required(_) => None,\n-                TraitFn::Provided(id) => Some(id),\n+            let (body, trait_sig) = match *body {\n+                TraitFn::Required(sig) => (None, Some(sig)),\n+                TraitFn::Provided(id) => (Some(id), None),\n             };\n-            check_fn_inner(cx, sig.decl, body, &item.generics, item.span, true);\n+            check_fn_inner(cx, sig.decl, body, trait_sig, &item.generics, item.span, true);\n         }\n     }\n }\n@@ -124,6 +125,7 @@ fn check_fn_inner<'tcx>(\n     cx: &LateContext<'tcx>,\n     decl: &'tcx FnDecl<'_>,\n     body: Option<BodyId>,\n+    trait_sig: Option<&[Ident]>,\n     generics: &'tcx Generics<'_>,\n     span: Span,\n     report_extra_lifetimes: bool,\n@@ -165,7 +167,7 @@ fn check_fn_inner<'tcx>(\n             }\n         }\n     }\n-    if could_use_elision(cx, decl, body, generics.params) {\n+    if could_use_elision(cx, decl, body, trait_sig, generics.params) {\n         span_lint(\n             cx,\n             NEEDLESS_LIFETIMES,\n@@ -179,10 +181,31 @@ fn check_fn_inner<'tcx>(\n     }\n }\n \n+// elision doesn't work for explicit self types, see rust-lang/rust#69064\n+fn explicit_self_type<'tcx>(cx: &LateContext<'tcx>, func: &FnDecl<'tcx>, ident: Option<Ident>) -> bool {\n+    if_chain! {\n+        if let Some(ident) = ident;\n+        if ident.name == kw::SelfLower;\n+        if !func.implicit_self.has_implicit_self();\n+\n+        if let Some(self_ty) = func.inputs.first();\n+        then {\n+            let mut visitor = RefVisitor::new(cx);\n+            visitor.visit_ty(self_ty);\n+\n+            !visitor.all_lts().is_empty()\n+        }\n+        else {\n+            false\n+        }\n+    }\n+}\n+\n fn could_use_elision<'tcx>(\n     cx: &LateContext<'tcx>,\n     func: &'tcx FnDecl<'_>,\n     body: Option<BodyId>,\n+    trait_sig: Option<&[Ident]>,\n     named_generics: &'tcx [GenericParam<'_>],\n ) -> bool {\n     // There are two scenarios where elision works:\n@@ -233,11 +256,24 @@ fn could_use_elision<'tcx>(\n     let input_lts = input_visitor.lts;\n     let output_lts = output_visitor.lts;\n \n+    if let Some(trait_sig) = trait_sig {\n+        if explicit_self_type(cx, func, trait_sig.first().copied()) {\n+            return false;\n+        }\n+    }\n+\n     if let Some(body_id) = body {\n+        let body = cx.tcx.hir().body(body_id);\n+\n+        let first_ident = body.params.first().and_then(|param| param.pat.simple_ident());\n+        if explicit_self_type(cx, func, first_ident) {\n+            return false;\n+        }\n+\n         let mut checker = BodyLifetimeChecker {\n             lifetimes_used_in_body: false,\n         };\n-        checker.visit_expr(&cx.tcx.hir().body(body_id).value);\n+        checker.visit_expr(&body.value);\n         if checker.lifetimes_used_in_body {\n             return false;\n         }"}, {"sha": "babc6fab3c0fb03d5c617c001001bdb80df97fe2", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -6,8 +6,8 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    Term, AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericArg, GenericBound, HirId,\n-    IsAsync, ItemKind, LifetimeName, TraitRef, Ty, TyKind, TypeBindingKind,\n+    AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericArg, GenericBound, HirId,\n+    IsAsync, ItemKind, LifetimeName, Term, TraitRef, Ty, TyKind, TypeBindingKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};"}, {"sha": "809aa168a7a0ee2f8152dc3f0b7884a9f20dba5e", "filename": "src/tools/clippy/clippy_lints/src/manual_bits.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_bits.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -72,6 +72,8 @@ impl<'tcx> LateLintPass<'tcx> for ManualBits {\n             }\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }\n \n fn get_one_size_of_ty<'tcx>("}, {"sha": "3f8eeb736fbd2e5c155054c7176c04dc0abe8bc4", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,15 +1,16 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_copy, is_type_diagnostic_item};\n-use clippy_utils::{is_trait_method, peel_blocks};\n+use clippy_utils::{is_trait_method, meets_msrv, msrvs, peel_blocks};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span};\n \n@@ -42,7 +43,17 @@ declare_clippy_lint! {\n     \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\"\n }\n \n-declare_lint_pass!(MapClone => [MAP_CLONE]);\n+pub struct MapClone {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl_lint_pass!(MapClone => [MAP_CLONE]);\n+\n+impl MapClone {\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n \n impl<'tcx> LateLintPass<'tcx> for MapClone {\n     fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n@@ -65,15 +76,15 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                         hir::BindingAnnotation::Unannotated, .., name, None\n                     ) = inner.kind {\n                         if ident_eq(name, closure_expr) {\n-                            lint(cx, e.span, args[0].span, true);\n+                            self.lint_explicit_closure(cx, e.span, args[0].span, true);\n                         }\n                     },\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n                         match closure_expr.kind {\n                             hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n                                 if ident_eq(name, inner) {\n                                     if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n-                                        lint(cx, e.span, args[0].span, true);\n+                                        self.lint_explicit_closure(cx, e.span, args[0].span, true);\n                                     }\n                                 }\n                             },\n@@ -90,7 +101,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                     if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n                                         if matches!(mutability, Mutability::Not) {\n                                             let copy = is_copy(cx, ty);\n-                                            lint(cx, e.span, args[0].span, copy);\n+                                            self.lint_explicit_closure(cx, e.span, args[0].span, copy);\n                                         }\n                                     } else {\n                                         lint_needless_cloning(cx, e.span, args[0].span);\n@@ -105,6 +116,8 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n             }\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }\n \n fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n@@ -127,31 +140,30 @@ fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n     );\n }\n \n-fn lint(cx: &LateContext<'_>, replace: Span, root: Span, copied: bool) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    if copied {\n-        span_lint_and_sugg(\n-            cx,\n-            MAP_CLONE,\n-            replace,\n-            \"you are using an explicit closure for copying elements\",\n-            \"consider calling the dedicated `copied` method\",\n-            format!(\n-                \"{}.copied()\",\n-                snippet_with_applicability(cx, root, \"..\", &mut applicability)\n-            ),\n-            applicability,\n-        );\n-    } else {\n+impl MapClone {\n+    fn lint_explicit_closure(&self, cx: &LateContext<'_>, replace: Span, root: Span, is_copy: bool) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        let message = if is_copy {\n+            \"you are using an explicit closure for copying elements\"\n+        } else {\n+            \"you are using an explicit closure for cloning elements\"\n+        };\n+        let sugg_method = if is_copy && meets_msrv(self.msrv.as_ref(), &msrvs::ITERATOR_COPIED) {\n+            \"copied\"\n+        } else {\n+            \"cloned\"\n+        };\n+\n         span_lint_and_sugg(\n             cx,\n             MAP_CLONE,\n             replace,\n-            \"you are using an explicit closure for cloning elements\",\n-            \"consider calling the dedicated `cloned` method\",\n+            message,\n+            &format!(\"consider calling the dedicated `{}` method\", sugg_method),\n             format!(\n-                \"{}.cloned()\",\n-                snippet_with_applicability(cx, root, \"..\", &mut applicability)\n+                \"{}.{}()\",\n+                snippet_with_applicability(cx, root, \"..\", &mut applicability),\n+                sugg_method,\n             ),\n             applicability,\n         );"}, {"sha": "2579404fb18cc5b152fd8448903475d4e1ba5bbf", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::sym;\n+use rustc_span::{sym, symbol::kw};\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n \n@@ -961,13 +961,13 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                 let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n                 if path_str == \"Err\" {\n                     let mut matching_wild = inner.iter().any(is_wild);\n-                    let mut ident_bind_name = String::from(\"_\");\n+                    let mut ident_bind_name = kw::Underscore;\n                     if !matching_wild {\n                         // Looking for unused bindings (i.e.: `_e`)\n                         for pat in inner.iter() {\n                             if let PatKind::Binding(_, id, ident, None) = pat.kind {\n                                 if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n-                                    ident_bind_name = ident.name.as_str().to_string();\n+                                    ident_bind_name = ident.name;\n                                     matching_wild = true;\n                                 }\n                             }\n@@ -982,7 +982,7 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                             span_lint_and_note(cx,\n                                 MATCH_WILD_ERR_ARM,\n                                 arm.pat.span,\n-                                &format!(\"`Err({})` matches all errors\", &ident_bind_name),\n+                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n                                 None,\n                                 \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n                             );"}, {"sha": "d813edab687e87a47fe08b6dc9fa46ecc00b42a0", "filename": "src/tools/clippy/clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n                 hir::ExprKind::MethodCall(method_name, call_args, _) => {\n                     if call_args.len() == 1\n-                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym!(as_ref))\n+                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym::as_ref)\n                         && {\n                             let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n                             let base_type = arg_type.peel_refs();"}, {"sha": "4b43448bf7b98a39f30d39ca9e1e76097e03f6ed", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -2180,8 +2180,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n                     if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n                         let assoc_ty = match projection_predicate.term {\n-                          ty::Term::Ty(ty) => ty,\n-                          ty::Term::Const(_c) => continue,\n+                            ty::Term::Ty(ty) => ty,\n+                            ty::Term::Const(_c) => continue,\n                         };\n                         // walk the associated type and check for Self\n                         if let Some(self_adt) = self_ty.ty_adt_def() {"}, {"sha": "d4c823d1c1ab77324efb77f0076831ff8131eb0e", "filename": "src/tools/clippy/clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionSome, ResultOk};\n-use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n+use rustc_hir::{AsyncGeneratorKind, Block, Body, Expr, ExprKind, GeneratorKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::TyS;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -88,7 +88,26 @@ impl LateLintPass<'_> for NeedlessQuestionMark {\n     }\n \n     fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n-        check(cx, body.value.peel_blocks());\n+        if let Some(GeneratorKind::Async(AsyncGeneratorKind::Fn)) = body.generator_kind {\n+            if let ExprKind::Block(\n+                Block {\n+                    expr:\n+                        Some(Expr {\n+                            kind: ExprKind::DropTemps(async_body),\n+                            ..\n+                        }),\n+                    ..\n+                },\n+                _,\n+            ) = body.value.kind\n+            {\n+                if let ExprKind::Block(Block { expr: Some(expr), .. }, ..) = async_body.kind {\n+                    check(cx, expr);\n+                }\n+            }\n+        } else {\n+            check(cx, body.value.peel_blocks());\n+        }\n     }\n }\n "}, {"sha": "c19cea661042d4c81a34572ec178f25aed6839d3", "filename": "src/tools/clippy/clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -101,7 +101,7 @@ fn check_lit(cx: &EarlyContext<'_>, lit: &Lit, span: Span, is_string: bool) {\n         // construct a replacement escape\n         // the maximum value is \\077, or \\x3f, so u8 is sufficient here\n         if let Ok(n) = u8::from_str_radix(&contents[from + 1..to], 8) {\n-            write!(&mut suggest_1, \"\\\\x{:02x}\", n).unwrap();\n+            write!(suggest_1, \"\\\\x{:02x}\", n).unwrap();\n         }\n \n         // append the null byte as \\x00 and the following digits literally"}, {"sha": "b5d65542de0bf1c068279149bb67df8615006a81", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 419, "deletions": 194, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,59 +1,44 @@\n //! Checks for usage of  `&Vec[_]` and `&String`.\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::ptr::get_spans;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::walk_ptrs_hir_ty;\n-use clippy_utils::{expr_path_res, is_lint_allowed, match_any_diagnostic_items, paths};\n+use clippy_utils::ty::expr_sig;\n+use clippy_utils::{\n+    expr_path_res, get_expr_use_or_unification_node, is_lint_allowed, match_any_diagnostic_items, path_to_local, paths,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::def::Res;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::hir_id::HirIdMap;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{\n-    BinOpKind, BodyId, Expr, ExprKind, FnDecl, FnRetTy, GenericArg, Impl, ImplItem, ImplItemKind, Item, ItemKind,\n-    Lifetime, MutTy, Mutability, Node, PathSegment, QPath, TraitFn, TraitItem, TraitItemKind, Ty, TyKind,\n+    self as hir, AnonConst, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, FnRetTy, GenericArg,\n+    ImplItemKind, ItemKind, Lifetime, LifetimeName, Mutability, Node, Param, ParamName, PatKind, QPath, TraitFn,\n+    TraitItem, TraitItemKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::nested_filter;\n+use rustc_middle::ty::{self, AssocItems, AssocKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n use rustc_span::{sym, MultiSpan};\n-use std::borrow::Cow;\n+use std::fmt;\n+use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// This lint checks for function arguments of type `&String`\n-    /// or `&Vec` unless the references are mutable. It will also suggest you\n-    /// replace `.clone()` calls with the appropriate `.to_owned()`/`to_string()`\n-    /// calls.\n+    /// This lint checks for function arguments of type `&String`, `&Vec`,\n+    /// `&PathBuf`, and `Cow<_>`. It will also suggest you replace `.clone()` calls\n+    /// with the appropriate `.to_owned()`/`to_string()` calls.\n     ///\n     /// ### Why is this bad?\n     /// Requiring the argument to be of the specific size\n     /// makes the function less useful for no benefit; slices in the form of `&[T]`\n     /// or `&str` usually suffice and can be obtained from other types, too.\n     ///\n     /// ### Known problems\n-    /// The lint does not follow data. So if you have an\n-    /// argument `x` and write `let y = x; y.clone()` the lint will not suggest\n-    /// changing that `.clone()` to `.to_owned()`.\n-    ///\n-    /// Other functions called from this function taking a `&String` or `&Vec`\n-    /// argument may also fail to compile if you change the argument. Applying\n-    /// this lint on them will fix the problem, but they may be in other crates.\n-    ///\n-    /// One notable example of a function that may cause issues, and which cannot\n-    /// easily be changed due to being in the standard library is `Vec::contains`.\n-    /// when called on a `Vec<Vec<T>>`. If a `&Vec` is passed to that method then\n-    /// it will compile, but if a `&[T]` is passed then it will not compile.\n-    ///\n-    /// ```ignore\n-    /// fn cannot_take_a_slice(v: &Vec<u8>) -> bool {\n-    ///     let vec_of_vecs: Vec<Vec<u8>> = some_other_fn();\n-    ///\n-    ///     vec_of_vecs.contains(v)\n-    /// }\n-    /// ```\n-    ///\n-    /// Also there may be `fn(&Vec)`-typed references pointing to your function.\n+    /// There may be `fn(&Vec)`-typed references pointing to your function.\n     /// If you have them, you will get a compiler error after applying this lint's\n     /// suggestions. You then have the choice to undo your changes or change the\n     /// type of the reference.\n@@ -155,32 +140,86 @@ declare_clippy_lint! {\n declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF, INVALID_NULL_PTR_USAGE]);\n \n impl<'tcx> LateLintPass<'tcx> for Ptr {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Fn(ref sig, _, body_id) = item.kind {\n-            check_fn(cx, sig.decl, Some(body_id));\n-        }\n-    }\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n+        if let TraitItemKind::Fn(sig, trait_method) = &item.kind {\n+            if matches!(trait_method, TraitFn::Provided(_)) {\n+                // Handled by check body.\n+                return;\n+            }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n-        if let ImplItemKind::Fn(ref sig, body_id) = item.kind {\n-            let parent_item = cx.tcx.hir().get_parent_item(item.hir_id());\n-            if let Some(Node::Item(it)) = cx.tcx.hir().find_by_def_id(parent_item) {\n-                if let ItemKind::Impl(Impl { of_trait: Some(_), .. }) = it.kind {\n-                    return; // ignore trait impls\n-                }\n+            check_mut_from_ref(cx, sig.decl);\n+            for arg in check_fn_args(\n+                cx,\n+                cx.tcx.fn_sig(item.def_id).skip_binder().inputs(),\n+                sig.decl.inputs,\n+                &[],\n+            ) {\n+                span_lint_and_sugg(\n+                    cx,\n+                    PTR_ARG,\n+                    arg.span,\n+                    &arg.build_msg(),\n+                    \"change this to\",\n+                    format!(\"{}{}\", arg.ref_prefix, arg.deref_ty.display(cx)),\n+                    Applicability::Unspecified,\n+                );\n             }\n-            check_fn(cx, sig.decl, Some(body_id));\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n-        if let TraitItemKind::Fn(ref sig, ref trait_method) = item.kind {\n-            let body_id = if let TraitFn::Provided(b) = *trait_method {\n-                Some(b)\n-            } else {\n-                None\n-            };\n-            check_fn(cx, sig.decl, body_id);\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        let hir = cx.tcx.hir();\n+        let mut parents = hir.parent_iter(body.value.hir_id);\n+        let (item_id, decl) = match parents.next() {\n+            Some((_, Node::Item(i))) => {\n+                if let ItemKind::Fn(sig, ..) = &i.kind {\n+                    (i.def_id, sig.decl)\n+                } else {\n+                    return;\n+                }\n+            },\n+            Some((_, Node::ImplItem(i))) => {\n+                if !matches!(parents.next(),\n+                    Some((_, Node::Item(i))) if matches!(&i.kind, ItemKind::Impl(i) if i.of_trait.is_none())\n+                ) {\n+                    return;\n+                }\n+                if let ImplItemKind::Fn(sig, _) = &i.kind {\n+                    (i.def_id, sig.decl)\n+                } else {\n+                    return;\n+                }\n+            },\n+            Some((_, Node::TraitItem(i))) => {\n+                if let TraitItemKind::Fn(sig, _) = &i.kind {\n+                    (i.def_id, sig.decl)\n+                } else {\n+                    return;\n+                }\n+            },\n+            _ => return,\n+        };\n+\n+        check_mut_from_ref(cx, decl);\n+        let sig = cx.tcx.fn_sig(item_id).skip_binder();\n+        let lint_args: Vec<_> = check_fn_args(cx, sig.inputs(), decl.inputs, body.params).collect();\n+        let results = check_ptr_arg_usage(cx, body, &lint_args);\n+\n+        for (result, args) in results.iter().zip(lint_args.iter()).filter(|(r, _)| !r.skip) {\n+            span_lint_and_then(cx, PTR_ARG, args.span, &args.build_msg(), |diag| {\n+                diag.multipart_suggestion(\n+                    \"change this to\",\n+                    iter::once((args.span, format!(\"{}{}\", args.ref_prefix, args.deref_ty.display(cx))))\n+                        .chain(result.replacements.iter().map(|r| {\n+                            (\n+                                r.expr_span,\n+                                format!(\"{}{}\", snippet_opt(cx, r.self_span).unwrap(), r.replacement),\n+                            )\n+                        }))\n+                        .collect(),\n+                    Applicability::Unspecified,\n+                );\n+            });\n         }\n     }\n \n@@ -247,154 +286,206 @@ fn check_invalid_ptr_usage<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     }\n }\n \n-#[allow(clippy::too_many_lines)]\n-fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, opt_body_id: Option<BodyId>) {\n-    let body = opt_body_id.map(|id| cx.tcx.hir().body(id));\n-\n-    for (idx, arg) in decl.inputs.iter().enumerate() {\n-        // Honor the allow attribute on parameters. See issue 5644.\n-        if let Some(body) = &body {\n-            if is_lint_allowed(cx, PTR_ARG, body.params[idx].hir_id) {\n-                continue;\n-            }\n-        }\n+#[derive(Default)]\n+struct PtrArgResult {\n+    skip: bool,\n+    replacements: Vec<PtrArgReplacement>,\n+}\n \n-        let (item_name, path) = if_chain! {\n-            if let TyKind::Rptr(_, MutTy { ty, mutbl: Mutability::Not }) = arg.kind;\n-            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-            if let Res::Def(_, did) = path.res;\n-            if let Some(item_name) = cx.tcx.get_diagnostic_name(did);\n-            then {\n-                (item_name, path)\n-            } else {\n-                continue\n-            }\n-        };\n+struct PtrArgReplacement {\n+    expr_span: Span,\n+    self_span: Span,\n+    replacement: &'static str,\n+}\n \n-        match item_name {\n-            sym::Vec => {\n-                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n-                    span_lint_and_then(\n-                        cx,\n-                        PTR_ARG,\n-                        arg.span,\n-                        \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n-                         with non-Vec-based slices\",\n-                        |diag| {\n-                            if let Some(ref snippet) = get_only_generic_arg_snippet(cx, arg) {\n-                                diag.span_suggestion(\n-                                    arg.span,\n-                                    \"change this to\",\n-                                    format!(\"&[{}]\", snippet),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n-                            for (clonespan, suggestion) in spans {\n-                                diag.span_suggestion(\n-                                    clonespan,\n-                                    &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(), |x| {\n-                                        Cow::Owned(format!(\"change `{}` to\", x))\n-                                    }),\n-                                    suggestion.into(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n-                        },\n-                    );\n-                }\n+struct PtrArg<'tcx> {\n+    idx: usize,\n+    span: Span,\n+    ty_did: DefId,\n+    ty_name: Symbol,\n+    method_renames: &'static [(&'static str, &'static str)],\n+    ref_prefix: RefPrefix,\n+    deref_ty: DerefTy<'tcx>,\n+    deref_assoc_items: Option<(DefId, &'tcx AssocItems<'tcx>)>,\n+}\n+impl PtrArg<'_> {\n+    fn build_msg(&self) -> String {\n+        format!(\n+            \"writing `&{}{}` instead of `&{}{}` involves a new object where a slice will do\",\n+            self.ref_prefix.mutability.prefix_str(),\n+            self.ty_name,\n+            self.ref_prefix.mutability.prefix_str(),\n+            self.deref_ty.argless_str(),\n+        )\n+    }\n+}\n+\n+struct RefPrefix {\n+    lt: LifetimeName,\n+    mutability: Mutability,\n+}\n+impl fmt::Display for RefPrefix {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use fmt::Write;\n+        f.write_char('&')?;\n+        match self.lt {\n+            LifetimeName::Param(ParamName::Plain(name)) => {\n+                name.fmt(f)?;\n+                f.write_char(' ')?;\n             },\n-            sym::String => {\n-                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n-                    span_lint_and_then(\n-                        cx,\n-                        PTR_ARG,\n-                        arg.span,\n-                        \"writing `&String` instead of `&str` involves a new object where a slice will do\",\n-                        |diag| {\n-                            diag.span_suggestion(arg.span, \"change this to\", \"&str\".into(), Applicability::Unspecified);\n-                            for (clonespan, suggestion) in spans {\n-                                diag.span_suggestion_short(\n-                                    clonespan,\n-                                    &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(), |x| {\n-                                        Cow::Owned(format!(\"change `{}` to\", x))\n-                                    }),\n-                                    suggestion.into(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n-                        },\n-                    );\n+            LifetimeName::Underscore => f.write_str(\"'_ \")?,\n+            LifetimeName::Static => f.write_str(\"'static \")?,\n+            _ => (),\n+        }\n+        f.write_str(self.mutability.prefix_str())\n+    }\n+}\n+\n+struct DerefTyDisplay<'a, 'tcx>(&'a LateContext<'tcx>, &'a DerefTy<'tcx>);\n+impl fmt::Display for DerefTyDisplay<'_, '_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use std::fmt::Write;\n+        match self.1 {\n+            DerefTy::Str => f.write_str(\"str\"),\n+            DerefTy::Path => f.write_str(\"Path\"),\n+            DerefTy::Slice(hir_ty, ty) => {\n+                f.write_char('[')?;\n+                match hir_ty.and_then(|s| snippet_opt(self.0, s)) {\n+                    Some(s) => f.write_str(&s)?,\n+                    None => ty.fmt(f)?,\n                 }\n+                f.write_char(']')\n             },\n-            sym::PathBuf => {\n-                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")]) {\n-                    span_lint_and_then(\n-                        cx,\n-                        PTR_ARG,\n-                        arg.span,\n-                        \"writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\",\n-                        |diag| {\n-                            diag.span_suggestion(\n-                                arg.span,\n+        }\n+    }\n+}\n+\n+enum DerefTy<'tcx> {\n+    Str,\n+    Path,\n+    Slice(Option<Span>, Ty<'tcx>),\n+}\n+impl<'tcx> DerefTy<'tcx> {\n+    fn argless_str(&self) -> &'static str {\n+        match *self {\n+            Self::Str => \"str\",\n+            Self::Path => \"Path\",\n+            Self::Slice(..) => \"[_]\",\n+        }\n+    }\n+\n+    fn display<'a>(&'a self, cx: &'a LateContext<'tcx>) -> DerefTyDisplay<'a, 'tcx> {\n+        DerefTyDisplay(cx, self)\n+    }\n+}\n+\n+fn check_fn_args<'cx, 'tcx: 'cx>(\n+    cx: &'cx LateContext<'tcx>,\n+    tys: &'tcx [Ty<'_>],\n+    hir_tys: &'tcx [hir::Ty<'_>],\n+    params: &'tcx [Param<'_>],\n+) -> impl Iterator<Item = PtrArg<'tcx>> + 'cx {\n+    tys.iter()\n+        .zip(hir_tys.iter())\n+        .enumerate()\n+        .filter_map(|(i, (ty, hir_ty))| {\n+            if_chain! {\n+                if let ty::Ref(_, ty, mutability) = *ty.kind();\n+                if let ty::Adt(adt, substs) = *ty.kind();\n+\n+                if let TyKind::Rptr(lt, ref ty) = hir_ty.kind;\n+                if let TyKind::Path(QPath::Resolved(None, path)) = ty.ty.kind;\n+\n+                // Check that the name as typed matches the actual name of the type.\n+                // e.g. `fn foo(_: &Foo)` shouldn't trigger the lint when `Foo` is an alias for `Vec`\n+                if let [.., name] = path.segments;\n+                if cx.tcx.item_name(adt.did) == name.ident.name;\n+\n+                if !is_lint_allowed(cx, PTR_ARG, hir_ty.hir_id);\n+                if params.get(i).map_or(true, |p| !is_lint_allowed(cx, PTR_ARG, p.hir_id));\n+\n+                then {\n+                    let (method_renames, deref_ty, deref_impl_id) = match cx.tcx.get_diagnostic_name(adt.did) {\n+                        Some(sym::Vec) => (\n+                            [(\"clone\", \".to_owned()\")].as_slice(),\n+                            DerefTy::Slice(\n+                                name.args\n+                                    .and_then(|args| args.args.first())\n+                                    .and_then(|arg| if let GenericArg::Type(ty) = arg {\n+                                        Some(ty.span)\n+                                    } else {\n+                                        None\n+                                    }),\n+                                substs.type_at(0),\n+                            ),\n+                            cx.tcx.lang_items().slice_impl()\n+                        ),\n+                        Some(sym::String) => (\n+                            [(\"clone\", \".to_owned()\"), (\"as_str\", \"\")].as_slice(),\n+                            DerefTy::Str,\n+                            cx.tcx.lang_items().str_impl()\n+                        ),\n+                        Some(sym::PathBuf) => (\n+                            [(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")].as_slice(),\n+                            DerefTy::Path,\n+                            None,\n+                        ),\n+                        Some(sym::Cow) => {\n+                            let ty_name = name.args\n+                                .and_then(|args| {\n+                                    args.args.iter().find_map(|a| match a {\n+                                        GenericArg::Type(x) => Some(x),\n+                                        _ => None,\n+                                    })\n+                                })\n+                                .and_then(|arg| snippet_opt(cx, arg.span))\n+                                .unwrap_or_else(|| substs.type_at(1).to_string());\n+                            span_lint_and_sugg(\n+                                cx,\n+                                PTR_ARG,\n+                                hir_ty.span,\n+                                \"using a reference to `Cow` is not recommended\",\n                                 \"change this to\",\n-                                \"&Path\".into(),\n+                                format!(\"&{}{}\", mutability.prefix_str(), ty_name),\n                                 Applicability::Unspecified,\n                             );\n-                            for (clonespan, suggestion) in spans {\n-                                diag.span_suggestion_short(\n-                                    clonespan,\n-                                    &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(), |x| {\n-                                        Cow::Owned(format!(\"change `{}` to\", x))\n-                                    }),\n-                                    suggestion.into(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n+                            return None;\n                         },\n-                    );\n-                }\n-            },\n-            sym::Cow => {\n-                if_chain! {\n-                    if let [ref bx] = *path.segments;\n-                    if let Some(params) = bx.args;\n-                    if !params.parenthesized;\n-                    if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n-                        GenericArg::Type(ty) => Some(ty),\n-                        _ => None,\n+                        _ => return None,\n+                    };\n+                    return Some(PtrArg {\n+                        idx: i,\n+                        span: hir_ty.span,\n+                        ty_did: adt.did,\n+                        ty_name: name.ident.name,\n+                        method_renames,\n+                        ref_prefix: RefPrefix {\n+                            lt: lt.name,\n+                            mutability,\n+                        },\n+                        deref_ty,\n+                        deref_assoc_items: deref_impl_id.map(|id| (id, cx.tcx.associated_items(id))),\n                     });\n-                    let replacement = snippet_opt(cx, inner.span);\n-                    if let Some(r) = replacement;\n-                    then {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            PTR_ARG,\n-                            arg.span,\n-                            \"using a reference to `Cow` is not recommended\",\n-                            \"change this to\",\n-                            \"&\".to_owned() + &r,\n-                            Applicability::Unspecified,\n-                        );\n-                    }\n                 }\n-            },\n-            _ => {},\n-        }\n-    }\n+            }\n+            None\n+        })\n+}\n \n+fn check_mut_from_ref(cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n     if let FnRetTy::Return(ty) = decl.output {\n         if let Some((out, Mutability::Mut, _)) = get_rptr_lm(ty) {\n             let mut immutables = vec![];\n-            for (_, ref mutbl, ref argspan) in decl\n+            for (_, mutbl, argspan) in decl\n                 .inputs\n                 .iter()\n                 .filter_map(get_rptr_lm)\n                 .filter(|&(lt, _, _)| lt.name == out.name)\n             {\n-                if *mutbl == Mutability::Mut {\n+                if mutbl == Mutability::Mut {\n                     return;\n                 }\n-                immutables.push(*argspan);\n+                immutables.push(argspan);\n             }\n             if immutables.is_empty() {\n                 return;\n@@ -413,24 +504,158 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, opt_body_id: Option<BodyId>\n     }\n }\n \n-fn get_only_generic_arg_snippet(cx: &LateContext<'_>, arg: &Ty<'_>) -> Option<String> {\n-    if_chain! {\n-        if let TyKind::Path(QPath::Resolved(_, path)) = walk_ptrs_hir_ty(arg).kind;\n-        if let Some(&PathSegment{args: Some(parameters), ..}) = path.segments.last();\n-        let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        }).collect();\n-        if types.len() == 1;\n-        then {\n-            snippet_opt(cx, types[0].span)\n-        } else {\n-            None\n+#[allow(clippy::too_many_lines)]\n+fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args: &[PtrArg<'tcx>]) -> Vec<PtrArgResult> {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        /// Map from a local id to which argument it came from (index into `Self::args` and\n+        /// `Self::results`)\n+        bindings: HirIdMap<usize>,\n+        /// The arguments being checked.\n+        args: &'cx [PtrArg<'tcx>],\n+        /// The results for each argument (len should match args.len)\n+        results: Vec<PtrArgResult>,\n+        /// The number of arguments which can't be linted. Used to return early.\n+        skip_count: usize,\n+    }\n+    impl<'tcx> Visitor<'tcx> for V<'_, 'tcx> {\n+        type NestedFilter = nested_filter::OnlyBodies;\n+        fn nested_visit_map(&mut self) -> Self::Map {\n+            self.cx.tcx.hir()\n+        }\n+\n+        fn visit_anon_const(&mut self, _: &'tcx AnonConst) {}\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.skip_count == self.args.len() {\n+                return;\n+            }\n+\n+            // Check if this is local we care about\n+            let args_idx = match path_to_local(e).and_then(|id| self.bindings.get(&id)) {\n+                Some(&i) => i,\n+                None => return walk_expr(self, e),\n+            };\n+            let args = &self.args[args_idx];\n+            let result = &mut self.results[args_idx];\n+\n+            // Helper function to handle early returns.\n+            let mut set_skip_flag = || {\n+                if result.skip {\n+                    self.skip_count += 1;\n+                }\n+                result.skip = true;\n+            };\n+\n+            match get_expr_use_or_unification_node(self.cx.tcx, e) {\n+                Some((Node::Stmt(_), _)) => (),\n+                Some((Node::Local(l), _)) => {\n+                    // Only trace simple bindings. e.g `let x = y;`\n+                    if let PatKind::Binding(BindingAnnotation::Unannotated, id, _, None) = l.pat.kind {\n+                        self.bindings.insert(id, args_idx);\n+                    } else {\n+                        set_skip_flag();\n+                    }\n+                },\n+                Some((Node::Expr(e), child_id)) => match e.kind {\n+                    ExprKind::Call(f, expr_args) => {\n+                        let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n+                        if expr_sig(self.cx, f)\n+                            .map(|sig| sig.input(i).skip_binder().peel_refs())\n+                            .map_or(true, |ty| match *ty.kind() {\n+                                ty::Param(_) => true,\n+                                ty::Adt(def, _) => def.did == args.ty_did,\n+                                _ => false,\n+                            })\n+                        {\n+                            // Passed to a function taking the non-dereferenced type.\n+                            set_skip_flag();\n+                        }\n+                    },\n+                    ExprKind::MethodCall(name, expr_args @ [self_arg, ..], _) => {\n+                        let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n+                        if i == 0 {\n+                            // Check if the method can be renamed.\n+                            let name = name.ident.as_str();\n+                            if let Some((_, replacement)) = args.method_renames.iter().find(|&&(x, _)| x == name) {\n+                                result.replacements.push(PtrArgReplacement {\n+                                    expr_span: e.span,\n+                                    self_span: self_arg.span,\n+                                    replacement,\n+                                });\n+                                return;\n+                            }\n+                        }\n+\n+                        let id = if let Some(x) = self.cx.typeck_results().type_dependent_def_id(e.hir_id) {\n+                            x\n+                        } else {\n+                            set_skip_flag();\n+                            return;\n+                        };\n+\n+                        match *self.cx.tcx.fn_sig(id).skip_binder().inputs()[i].peel_refs().kind() {\n+                            ty::Param(_) => {\n+                                set_skip_flag();\n+                            },\n+                            // If the types match check for methods which exist on both types. e.g. `Vec::len` and\n+                            // `slice::len`\n+                            ty::Adt(def, _)\n+                                if def.did == args.ty_did\n+                                    && (i != 0\n+                                        || self.cx.tcx.trait_of_item(id).is_some()\n+                                        || !args.deref_assoc_items.map_or(false, |(id, items)| {\n+                                            items\n+                                                .find_by_name_and_kind(self.cx.tcx, name.ident, AssocKind::Fn, id)\n+                                                .is_some()\n+                                        })) =>\n+                            {\n+                                set_skip_flag();\n+                            },\n+                            _ => (),\n+                        }\n+                    },\n+                    // Indexing is fine for currently supported types.\n+                    ExprKind::Index(e, _) if e.hir_id == child_id => (),\n+                    _ => set_skip_flag(),\n+                },\n+                _ => set_skip_flag(),\n+            }\n         }\n     }\n+\n+    let mut skip_count = 0;\n+    let mut results = args.iter().map(|_| PtrArgResult::default()).collect::<Vec<_>>();\n+    let mut v = V {\n+        cx,\n+        bindings: args\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, arg)| {\n+                let param = &body.params[arg.idx];\n+                match param.pat.kind {\n+                    PatKind::Binding(BindingAnnotation::Unannotated, id, _, None)\n+                        if !is_lint_allowed(cx, PTR_ARG, param.hir_id) =>\n+                    {\n+                        Some((id, i))\n+                    },\n+                    _ => {\n+                        skip_count += 1;\n+                        results[arg.idx].skip = true;\n+                        None\n+                    },\n+                }\n+            })\n+            .collect(),\n+        args,\n+        results,\n+        skip_count,\n+    };\n+    v.visit_expr(&body.value);\n+    v.results\n }\n \n-fn get_rptr_lm<'tcx>(ty: &'tcx Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability, Span)> {\n+fn get_rptr_lm<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability, Span)> {\n     if let TyKind::Rptr(ref lt, ref m) = ty.kind {\n         Some((lt, m.mutbl, ty.span))\n     } else {"}, {"sha": "811a7bb9c153a273e4d9ff5fbee2252555591a10", "filename": "src/tools/clippy/clippy_lints/src/reference.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,6 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n-use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_ast::ast::{Expr, ExprKind, Mutability, UnOp};\n use rustc_errors::Applicability;\n@@ -104,59 +103,3 @@ impl EarlyLintPass for DerefAddrOf {\n         }\n     }\n }\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for references in expressions that use\n-    /// auto dereference.\n-    ///\n-    /// ### Why is this bad?\n-    /// The reference is a no-op and is automatically\n-    /// dereferenced by the compiler and makes the code less clear.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// struct Point(u32, u32);\n-    /// let point = Point(30, 20);\n-    /// let x = (&point).0;\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # struct Point(u32, u32);\n-    /// # let point = Point(30, 20);\n-    /// let x = point.0;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub REF_IN_DEREF,\n-    complexity,\n-    \"Use of reference in auto dereference expression.\"\n-}\n-\n-declare_lint_pass!(RefInDeref => [REF_IN_DEREF]);\n-\n-impl EarlyLintPass for RefInDeref {\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n-        if_chain! {\n-            if let ExprKind::Field(ref object, _) = e.kind;\n-            if let ExprKind::Paren(ref parened) = object.kind;\n-            if let ExprKind::AddrOf(_, _, ref inner) = parened.kind;\n-            then {\n-                let applicability = if inner.span.from_expansion() {\n-                    Applicability::MaybeIncorrect\n-                } else {\n-                    Applicability::MachineApplicable\n-                };\n-                let sugg = Sugg::ast(cx, inner, \"_\").maybe_par();\n-                span_lint_and_sugg(\n-                    cx,\n-                    REF_IN_DEREF,\n-                    object.span,\n-                    \"creating a reference that is immediately dereferenced\",\n-                    \"try this\",\n-                    sugg.to_string(),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "5257f5302cd90d87c2ced61cd1f582cb2b4d1dd7", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::{SpanlessEq, SpanlessHash};\n use core::hash::{Hash, Hasher};\n use if_chain::if_chain;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n@@ -91,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'tcx>) {\n         let Generics { where_clause, .. } = &item.generics;\n-        let mut self_bounds_set = FxHashSet::default();\n+        let mut self_bounds_map = FxHashMap::default();\n \n         for predicate in where_clause.predicates {\n             if_chain! {\n@@ -108,27 +108,29 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n                         )\n                     ) = cx.tcx.hir().get_if_local(*def_id);\n                 then {\n-                    if self_bounds_set.is_empty() {\n+                    if self_bounds_map.is_empty() {\n                         for bound in self_bounds.iter() {\n-                            let Some((self_res, _)) = get_trait_res_span_from_bound(bound) else { continue };\n-                            self_bounds_set.insert(self_res);\n+                            let Some((self_res, self_segments, _)) = get_trait_info_from_bound(bound) else { continue };\n+                            self_bounds_map.insert(self_res, self_segments);\n                         }\n                     }\n \n                     bound_predicate\n                         .bounds\n                         .iter()\n-                        .filter_map(get_trait_res_span_from_bound)\n-                        .for_each(|(trait_item_res, span)| {\n-                            if self_bounds_set.get(&trait_item_res).is_some() {\n-                                span_lint_and_help(\n-                                    cx,\n-                                    TRAIT_DUPLICATION_IN_BOUNDS,\n-                                    span,\n-                                    \"this trait bound is already specified in trait declaration\",\n-                                    None,\n-                                    \"consider removing this trait bound\",\n-                                );\n+                        .filter_map(get_trait_info_from_bound)\n+                        .for_each(|(trait_item_res, trait_item_segments, span)| {\n+                            if let Some(self_segments) = self_bounds_map.get(&trait_item_res) {\n+                                if SpanlessEq::new(cx).eq_path_segments(self_segments, trait_item_segments) {\n+                                    span_lint_and_help(\n+                                        cx,\n+                                        TRAIT_DUPLICATION_IN_BOUNDS,\n+                                        span,\n+                                        \"this trait bound is already specified in trait declaration\",\n+                                        None,\n+                                        \"consider removing this trait bound\",\n+                                    );\n+                                }\n                             }\n                         });\n                 }\n@@ -137,14 +139,6 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n     }\n }\n \n-fn get_trait_res_span_from_bound(bound: &GenericBound<'_>) -> Option<(Res, Span)> {\n-    if let GenericBound::Trait(t, _) = bound {\n-        Some((t.trait_ref.path.res, t.span))\n-    } else {\n-        None\n-    }\n-}\n-\n impl TraitBounds {\n     fn check_type_repetition<'tcx>(self, cx: &LateContext<'tcx>, gen: &'tcx Generics<'_>) {\n         struct SpanlessTy<'cx, 'tcx> {\n@@ -231,7 +225,7 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n             let res = param\n                 .bounds\n                 .iter()\n-                .filter_map(get_trait_res_span_from_bound)\n+                .filter_map(get_trait_info_from_bound)\n                 .collect::<Vec<_>>();\n             map.insert(*ident, res);\n         }\n@@ -245,10 +239,10 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n             if let Some(segment) = segments.first();\n             if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n             then {\n-                for (res_where, _) in bound_predicate.bounds.iter().filter_map(get_trait_res_span_from_bound) {\n-                    if let Some((_, span_direct)) = trait_resolutions_direct\n+                for (res_where, _,  _) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n+                    if let Some((_, _, span_direct)) = trait_resolutions_direct\n                                                 .iter()\n-                                                .find(|(res_direct, _)| *res_direct == res_where) {\n+                                                .find(|(res_direct, _, _)| *res_direct == res_where) {\n                         span_lint_and_help(\n                             cx,\n                             TRAIT_DUPLICATION_IN_BOUNDS,\n@@ -263,3 +257,11 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n         }\n     }\n }\n+\n+fn get_trait_info_from_bound<'a>(bound: &'a GenericBound<'_>) -> Option<(Res, &'a [PathSegment<'a>], Span)> {\n+    if let GenericBound::Trait(t, _) = bound {\n+        Some((t.trait_ref.path.res, t.trait_ref.path.segments, t.span))\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "eee1229e1ef0356745ec361f76929e1570c322bf", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -98,10 +98,11 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n                         if trait_pred.self_ty() == inp;\n                         if let Some(return_ty_pred) = get_projection_pred(cx, generics, *trait_pred);\n                         then {\n-                            if ord_preds.iter().any(|ord| Some(ord.self_ty()) ==\n-                            return_ty_pred.term.ty()) {\n+                            if ord_preds.iter().any(|ord| Some(ord.self_ty()) == return_ty_pred.term.ty()) {\n                                 args_to_check.push((i, \"Ord\".to_string()));\n-                            } else if partial_ord_preds.iter().any(|pord| pord.self_ty() == return_ty_pred.term.ty().unwrap()) {\n+                            } else if partial_ord_preds.iter().any(|pord| {\n+                                pord.self_ty() == return_ty_pred.term.ty().unwrap()\n+                            }) {\n                                 args_to_check.push((i, \"PartialOrd\".to_string()));\n                             }\n                         }"}, {"sha": "1d4fe9cfd3cf40a8ac5459cf206f9c0704f711b0", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -291,7 +291,7 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n fn extend_with_struct_pat(\n     qself1: &Option<ast::QSelf>,\n     path1: &ast::Path,\n-    fps1: &mut Vec<ast::PatField>,\n+    fps1: &mut [ast::PatField],\n     rest1: bool,\n     start: usize,\n     alternatives: &mut Vec<P<Pat>>,\n@@ -332,7 +332,7 @@ fn extend_with_struct_pat(\n /// while also requiring `ps1[..n] ~ ps2[..n]` (pre) and `ps1[n + 1..] ~ ps2[n + 1..]` (post),\n /// where `~` denotes semantic equality.\n fn extend_with_matching_product(\n-    targets: &mut Vec<P<Pat>>,\n+    targets: &mut [P<Pat>],\n     start: usize,\n     alternatives: &mut Vec<P<Pat>>,\n     predicate: impl Fn(&PatKind, &[P<Pat>], usize) -> bool,"}, {"sha": "c9d99617c1e281f8315bfc2669fd71243155a3ad", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -156,7 +156,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),"}, {"sha": "f170ff69154b6532934489e96d089d670beb32dd", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -23,6 +23,7 @@ use rustc_hir::{\n     UnOp,\n };\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::nested_filter;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;"}, {"sha": "3547f0b4e0ae05266096e2a214e80fea4e3b85c4", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -19,7 +19,9 @@ use rustc_hir::{\n     self as hir, def::DefKind, intravisit, intravisit::Visitor, ExprKind, Item, ItemKind, Mutability, QPath,\n };\n use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n+use rustc_middle::hir::nested_filter;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::Ident;\n use rustc_span::{sym, Loc, Span, Symbol};\n use serde::{ser::SerializeStruct, Serialize, Serializer};\n use std::collections::BinaryHeap;\n@@ -578,9 +580,11 @@ fn get_lint_group_and_level_or_lint(\n     lint_name: &str,\n     item: &Item<'_>,\n ) -> Option<(String, &'static str)> {\n-    let result = cx\n-        .lint_store\n-        .check_lint_name(lint_name, Some(sym::clippy), &[]);\n+    let result = cx.lint_store.check_lint_name(\n+        lint_name,\n+        Some(sym::clippy),\n+        &[Ident::with_dummy_span(sym::clippy)].into_iter().collect(),\n+    );\n     if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n         if let Some(group) = get_lint_group(cx, lint_lst[0]) {\n             if EXCLUDED_LINT_GROUPS.contains(&group.as_str()) {"}, {"sha": "3f4043ad052a034279ec979ea0e67590dde0a19d", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -646,11 +646,11 @@ pub fn eq_generic_bound(l: &GenericBound, r: &GenericBound) -> bool {\n }\n \n fn eq_term(l: &Term, r: &Term) -> bool {\n-  match (l, r) {\n-    (Term::Ty(l), Term::Ty(r)) => eq_ty(l,r),\n-    (Term::Const(l), Term::Const(r)) => eq_anon_const(l,r),\n-    _ => false,\n-  }\n+    match (l, r) {\n+        (Term::Ty(l), Term::Ty(r)) => eq_ty(l, r),\n+        (Term::Const(l), Term::Const(r)) => eq_anon_const(l, r),\n+        _ => false,\n+    }\n }\n \n pub fn eq_assoc_constraint(l: &AssocConstraint, r: &AssocConstraint) -> bool {"}, {"sha": "a2f1f4696513e067febb58cc2b688faef4c04c73", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1827,7 +1827,8 @@ pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool\n }\n \n /// Gets the node where an expression is either used, or it's type is unified with another branch.\n-pub fn get_expr_use_or_unification_node<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n+/// Returns both the node and the `HirId` of the closest child node.\n+pub fn get_expr_use_or_unification_node<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<(Node<'tcx>, HirId)> {\n     let mut child_id = expr.hir_id;\n     let mut iter = tcx.hir().parent_iter(child_id);\n     loop {\n@@ -1839,9 +1840,9 @@ pub fn get_expr_use_or_unification_node<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>\n                 ExprKind::Match(_, [arm], _) if arm.hir_id == child_id => child_id = expr.hir_id,\n                 ExprKind::Block(..) | ExprKind::DropTemps(_) => child_id = expr.hir_id,\n                 ExprKind::If(_, then_expr, None) if then_expr.hir_id == child_id => break None,\n-                _ => break Some(Node::Expr(expr)),\n+                _ => break Some((Node::Expr(expr), child_id)),\n             },\n-            Some((_, node)) => break Some(node),\n+            Some((_, node)) => break Some((node, child_id)),\n         }\n     }\n }\n@@ -1850,18 +1851,21 @@ pub fn get_expr_use_or_unification_node<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>\n pub fn is_expr_used_or_unified(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     !matches!(\n         get_expr_use_or_unification_node(tcx, expr),\n-        None | Some(Node::Stmt(Stmt {\n-            kind: StmtKind::Expr(_)\n-                | StmtKind::Semi(_)\n-                | StmtKind::Local(Local {\n-                    pat: Pat {\n-                        kind: PatKind::Wild,\n+        None | Some((\n+            Node::Stmt(Stmt {\n+                kind: StmtKind::Expr(_)\n+                    | StmtKind::Semi(_)\n+                    | StmtKind::Local(Local {\n+                        pat: Pat {\n+                            kind: PatKind::Wild,\n+                            ..\n+                        },\n                         ..\n-                    },\n-                    ..\n-                }),\n-            ..\n-        }))\n+                    }),\n+                ..\n+            }),\n+            _\n+        ))\n     )\n }\n "}, {"sha": "908ff822712ffa0a171f9d043a78ed9b7c8fceb2", "filename": "src/tools/clippy/clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -51,7 +51,14 @@ impl<'a> NumericLiteral<'a> {\n     }\n \n     pub fn from_lit_kind(src: &'a str, lit_kind: &LitKind) -> Option<NumericLiteral<'a>> {\n-        if lit_kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n+        let unsigned_src = src.strip_prefix('-').map_or(src, |s| s);\n+        if lit_kind.is_numeric()\n+            && unsigned_src\n+                .trim_start()\n+                .chars()\n+                .next()\n+                .map_or(false, |c| c.is_digit(10))\n+        {\n             let (unsuffixed, suffix) = split_suffix(src, lit_kind);\n             let float = matches!(lit_kind, LitKind::Float(..));\n             Some(NumericLiteral::new(unsuffixed, suffix, float))"}, {"sha": "fa63ddff253cfd7afa686a48c2e4af3d82512079", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -386,7 +386,7 @@ fn binop_to_string(op: AssocOp, lhs: &str, rhs: &str) -> String {\n }\n \n /// Return `true` if `sugg` is enclosed in parenthesis.\n-fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n+pub fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n     let mut chars = sugg.as_ref().chars();\n     if chars.next() == Some('(') {\n         let mut depth = 1;"}, {"sha": "d057da73302a25bc76d3109fc13557a76daa17f9", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 109, "deletions": 4, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -5,19 +5,22 @@\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{TyKind, Unsafety};\n+use rustc_hir::{Expr, TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, AdtDef, IntTy, Predicate, Ty, TyCtxt, TypeFoldable, UintTy};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n+use rustc_middle::ty::{\n+    self, AdtDef, Binder, FnSig, IntTy, Predicate, PredicateKind, Ty, TyCtxt, TypeFoldable, UintTy,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use std::iter;\n \n-use crate::{match_def_path, must_use_attr};\n+use crate::{expr_path_res, match_def_path, must_use_attr};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -410,3 +413,105 @@ pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(P\n     })\n     .flatten()\n }\n+\n+/// A signature for a function like type.\n+#[derive(Clone, Copy)]\n+pub enum ExprFnSig<'tcx> {\n+    Sig(Binder<'tcx, FnSig<'tcx>>),\n+    Closure(Binder<'tcx, FnSig<'tcx>>),\n+    Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>),\n+}\n+impl<'tcx> ExprFnSig<'tcx> {\n+    /// Gets the argument type at the given offset.\n+    pub fn input(self, i: usize) -> Binder<'tcx, Ty<'tcx>> {\n+        match self {\n+            Self::Sig(sig) => sig.input(i),\n+            Self::Closure(sig) => sig.input(0).map_bound(|ty| ty.tuple_element_ty(i).unwrap()),\n+            Self::Trait(inputs, _) => inputs.map_bound(|ty| ty.tuple_element_ty(i).unwrap()),\n+        }\n+    }\n+\n+    /// Gets the result type, if one could be found. Note that the result type of a trait may not be\n+    /// specified.\n+    pub fn output(self) -> Option<Binder<'tcx, Ty<'tcx>>> {\n+        match self {\n+            Self::Sig(sig) | Self::Closure(sig) => Some(sig.output()),\n+            Self::Trait(_, output) => output,\n+        }\n+    }\n+}\n+\n+/// If the expression is function like, get the signature for it.\n+pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnSig<'tcx>> {\n+    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = expr_path_res(cx, expr) {\n+        Some(ExprFnSig::Sig(cx.tcx.fn_sig(id)))\n+    } else {\n+        let ty = cx.typeck_results().expr_ty_adjusted(expr).peel_refs();\n+        match *ty.kind() {\n+            ty::Closure(_, subs) => Some(ExprFnSig::Closure(subs.as_closure().sig())),\n+            ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.fn_sig(id).subst(cx.tcx, subs))),\n+            ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n+            ty::Dynamic(bounds, _) => {\n+                let lang_items = cx.tcx.lang_items();\n+                match bounds.principal() {\n+                    Some(bound)\n+                        if Some(bound.def_id()) == lang_items.fn_trait()\n+                            || Some(bound.def_id()) == lang_items.fn_once_trait()\n+                            || Some(bound.def_id()) == lang_items.fn_mut_trait() =>\n+                    {\n+                        let output = bounds\n+                            .projection_bounds()\n+                            .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n+                            .map(|p| p.map_bound(|p| p.term.ty().expect(\"return type was a const\")));\n+                        Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n+                    },\n+                    _ => None,\n+                }\n+            },\n+            ty::Param(_) | ty::Projection(..) => {\n+                let mut inputs = None;\n+                let mut output = None;\n+                let lang_items = cx.tcx.lang_items();\n+\n+                for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n+                    let mut is_input = false;\n+                    if let Some(ty) = pred\n+                        .kind()\n+                        .map_bound(|pred| match pred {\n+                            PredicateKind::Trait(p)\n+                                if (lang_items.fn_trait() == Some(p.def_id())\n+                                    || lang_items.fn_mut_trait() == Some(p.def_id())\n+                                    || lang_items.fn_once_trait() == Some(p.def_id()))\n+                                    && p.self_ty() == ty =>\n+                            {\n+                                is_input = true;\n+                                Some(p.trait_ref.substs.type_at(1))\n+                            },\n+                            PredicateKind::Projection(p)\n+                                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n+                                    && p.projection_ty.self_ty() == ty =>\n+                            {\n+                                is_input = false;\n+                                p.term.ty()\n+                            },\n+                            _ => None,\n+                        })\n+                        .transpose()\n+                    {\n+                        if is_input && inputs.is_none() {\n+                            inputs = Some(ty);\n+                        } else if !is_input && output.is_none() {\n+                            output = Some(ty);\n+                        } else {\n+                            // Multiple different fn trait impls. Is this even allowed?\n+                            return None;\n+                        }\n+                    }\n+                }\n+\n+                inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+            },\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "e23dc73ab08c1233e51d9b926923e2790fbabb5c", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-01-13\"\n+channel = \"nightly-2022-01-27\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "8f8f1140a3da62e86f030a16f10abacaccb9d6df", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -331,11 +331,10 @@ pub fn main() {\n         // - IF Clippy is run on the main crate, not on deps (`!cap_lints_allow`) THEN\n         //    - IF `--no-deps` is not set (`!no_deps`) OR\n         //    - IF `--no-deps` is set and Clippy is run on the specified primary package\n-        let clippy_tests_set = env::var(\"__CLIPPY_INTERNAL_TESTS\").map_or(false, |val| val == \"true\");\n         let cap_lints_allow = arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_some();\n         let in_primary_package = env::var(\"CARGO_PRIMARY_PACKAGE\").is_ok();\n \n-        let clippy_enabled = clippy_tests_set || (!cap_lints_allow && (!no_deps || in_primary_package));\n+        let clippy_enabled = !cap_lints_allow && (!no_deps || in_primary_package);\n         if clippy_enabled {\n             args.extend(clippy_args);\n         }"}, {"sha": "6505028db9fadc1f5e75e62e468bcde1d805d737", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -328,15 +328,9 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n     }\n }\n \n-fn prepare_env() {\n-    set_var(\"CLIPPY_DISABLE_DOCS_LINKS\", \"true\");\n-    set_var(\"__CLIPPY_INTERNAL_TESTS\", \"true\");\n-    //set_var(\"RUST_BACKTRACE\", \"0\");\n-}\n-\n #[test]\n fn compile_test() {\n-    prepare_env();\n+    set_var(\"CLIPPY_DISABLE_DOCS_LINKS\", \"true\");\n     let mut config = default_config();\n     run_ui(&mut config);\n     run_ui_test(&mut config);"}, {"sha": "1e3ec123a3c8b0b430eb253f739da3fd41868b71", "filename": "src/tools/clippy/tests/ui-toml/min_rust_version/min_rust_version.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,6 +1,7 @@\n-#![allow(clippy::redundant_clone)]\n-#![warn(clippy::manual_non_exhaustive)]\n+#![allow(clippy::redundant_clone, clippy::unnecessary_operation)]\n+#![warn(clippy::manual_non_exhaustive, clippy::borrow_as_ptr, clippy::manual_bits)]\n \n+use std::mem::{size_of, size_of_val};\n use std::ops::Deref;\n \n mod enums {\n@@ -68,11 +69,30 @@ fn check_index_refutable_slice() {\n     }\n }\n \n+fn map_clone_suggest_copied() {\n+    // This should still trigger the lint but suggest `cloned()` instead of `copied()`\n+    let _: Option<u64> = Some(&16).map(|b| *b);\n+}\n+\n+fn borrow_as_ptr() {\n+    let val = 1;\n+    let _p = &val as *const i32;\n+\n+    let mut val_mut = 1;\n+    let _p_mut = &mut val_mut as *mut i32;\n+}\n+\n+fn manual_bits() {\n+    size_of::<i8>() * 8;\n+    size_of_val(&0u32) * 8;\n+}\n+\n fn main() {\n     option_as_ref_deref();\n     match_like_matches();\n     match_same_arms();\n     match_same_arms2();\n     manual_strip_msrv();\n     check_index_refutable_slice();\n+    borrow_as_ptr();\n }"}, {"sha": "a1e7361c0cb32fe4bbe9e9c5a09320691b3b123a", "filename": "src/tools/clippy/tests/ui-toml/min_rust_version/min_rust_version.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -0,0 +1,10 @@\n+error: you are using an explicit closure for copying elements\n+  --> $DIR/min_rust_version.rs:74:26\n+   |\n+LL |     let _: Option<u64> = Some(&16).map(|b| *b);\n+   |                          ^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `cloned` method: `Some(&16).cloned()`\n+   |\n+   = note: `-D clippy::map-clone` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "eefeb1decb69e604519618c9567ab6ee990b3a81", "filename": "src/tools/clippy/tests/ui/borrow_interior_mutable_const/others.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,9 +1,5 @@\n #![warn(clippy::borrow_interior_mutable_const)]\n-#![allow(\n-    clippy::declare_interior_mutable_const,\n-    clippy::ref_in_deref,\n-    clippy::needless_borrow\n-)]\n+#![allow(clippy::declare_interior_mutable_const, clippy::needless_borrow)]\n #![allow(const_item_mutation)]\n \n use std::borrow::Cow;"}, {"sha": "9a908cf30e945cc100e1a98126448250704031f0", "filename": "src/tools/clippy/tests/ui/borrow_interior_mutable_const/others.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,5 +1,5 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:58:5\n+  --> $DIR/others.rs:54:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n@@ -8,103 +8,103 @@ LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:59:16\n+  --> $DIR/others.rs:55:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:62:22\n+  --> $DIR/others.rs:58:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:63:25\n+  --> $DIR/others.rs:59:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:64:27\n+  --> $DIR/others.rs:60:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:65:26\n+  --> $DIR/others.rs:61:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:76:14\n+  --> $DIR/others.rs:72:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:77:14\n+  --> $DIR/others.rs:73:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:78:19\n+  --> $DIR/others.rs:74:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:79:14\n+  --> $DIR/others.rs:75:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:80:13\n+  --> $DIR/others.rs:76:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:86:13\n+  --> $DIR/others.rs:82:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:91:5\n+  --> $DIR/others.rs:87:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:92:16\n+  --> $DIR/others.rs:88:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^"}, {"sha": "d3ad26921bffa8d4d15db41f488b73d30f8681d7", "filename": "src/tools/clippy/tests/ui/bytecount.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbytecount.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,3 +1,5 @@\n+#![allow(clippy::needless_borrow)]\n+\n #[deny(clippy::naive_bytecount)]\n fn main() {\n     let x = vec![0_u8; 16];"}, {"sha": "68d838c1f828aa550a01573b87a0dc75d76425cc", "filename": "src/tools/clippy/tests/ui/bytecount.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbytecount.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbytecount.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbytecount.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,23 +1,23 @@\n error: you appear to be counting bytes the naive way\n-  --> $DIR/bytecount.rs:5:13\n+  --> $DIR/bytecount.rs:7:13\n    |\n LL |     let _ = x.iter().filter(|&&a| a == 0).count(); // naive byte count\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the bytecount crate: `bytecount::count(x, 0)`\n    |\n note: the lint level is defined here\n-  --> $DIR/bytecount.rs:1:8\n+  --> $DIR/bytecount.rs:3:8\n    |\n LL | #[deny(clippy::naive_bytecount)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you appear to be counting bytes the naive way\n-  --> $DIR/bytecount.rs:7:13\n+  --> $DIR/bytecount.rs:9:13\n    |\n LL |     let _ = (&x[..]).iter().filter(|&a| *a == 0).count(); // naive byte count\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the bytecount crate: `bytecount::count((&x[..]), 0)`\n \n error: you appear to be counting bytes the naive way\n-  --> $DIR/bytecount.rs:19:13\n+  --> $DIR/bytecount.rs:21:13\n    |\n LL |     let _ = x.iter().filter(|a| b + 1 == **a).count(); // naive byte count\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the bytecount crate: `bytecount::count(x, b + 1)`"}, {"sha": "dc062762604e063a4d1dac5f9554a7276898e65e", "filename": "src/tools/clippy/tests/ui/clone_on_copy.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -7,7 +7,8 @@\n     clippy::no_effect,\n     clippy::unnecessary_operation,\n     clippy::vec_init_then_push,\n-    clippy::toplevel_ref_arg\n+    clippy::toplevel_ref_arg,\n+    clippy::needless_borrow\n )]\n \n use std::cell::RefCell;"}, {"sha": "8c39d0d55dd8bdbf23e48a37bdd194bbd930cc6b", "filename": "src/tools/clippy/tests/ui/clone_on_copy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -7,7 +7,8 @@\n     clippy::no_effect,\n     clippy::unnecessary_operation,\n     clippy::vec_init_then_push,\n-    clippy::toplevel_ref_arg\n+    clippy::toplevel_ref_arg,\n+    clippy::needless_borrow\n )]\n \n use std::cell::RefCell;"}, {"sha": "861543d0aa904566aac464ca4071ddd23aee4153", "filename": "src/tools/clippy/tests/ui/clone_on_copy.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,49 +1,49 @@\n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:24:5\n+  --> $DIR/clone_on_copy.rs:25:5\n    |\n LL |     42.clone();\n    |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n    |\n    = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:28:5\n+  --> $DIR/clone_on_copy.rs:29:5\n    |\n LL |     (&42).clone();\n    |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:31:5\n+  --> $DIR/clone_on_copy.rs:32:5\n    |\n LL |     rc.borrow().clone();\n    |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n \n error: using `clone` on type `u32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:34:5\n+  --> $DIR/clone_on_copy.rs:35:5\n    |\n LL |     x.clone().rotate_left(1);\n    |     ^^^^^^^^^ help: try removing the `clone` call: `x`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:48:5\n+  --> $DIR/clone_on_copy.rs:49:5\n    |\n LL |     m!(42).clone();\n    |     ^^^^^^^^^^^^^^ help: try removing the `clone` call: `m!(42)`\n \n error: using `clone` on type `[u32; 2]` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:58:5\n+  --> $DIR/clone_on_copy.rs:59:5\n    |\n LL |     x.clone()[0];\n    |     ^^^^^^^^^ help: try dereferencing it: `(*x)`\n \n error: using `clone` on type `char` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:68:14\n+  --> $DIR/clone_on_copy.rs:69:14\n    |\n LL |     is_ascii('z'.clone());\n    |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:72:14\n+  --> $DIR/clone_on_copy.rs:73:14\n    |\n LL |     vec.push(42.clone());\n    |              ^^^^^^^^^^ help: try removing the `clone` call: `42`"}, {"sha": "d92b8998e8805c2b0da6e1648ede17b1c0e71578", "filename": "src/tools/clippy/tests/ui/duration_subsec.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fduration_subsec.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fduration_subsec.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fduration_subsec.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::needless_borrow)]\n #![warn(clippy::duration_subsec)]\n \n use std::time::Duration;"}, {"sha": "08da804996d1b5660db6a9bb91c6e6a4141c6b72", "filename": "src/tools/clippy/tests/ui/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fduration_subsec.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::needless_borrow)]\n #![warn(clippy::duration_subsec)]\n \n use std::time::Duration;"}, {"sha": "b2bf7c4e360a0246b2459934e3c1b843eb5568d1", "filename": "src/tools/clippy/tests/ui/enum_variants.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -151,4 +151,11 @@ enum North {\n     NoRight,\n }\n \n+// #8324\n+enum Phase {\n+    PreLookup,\n+    Lookup,\n+    PostLookup,\n+}\n+\n fn main() {}"}, {"sha": "618f80cdcf84923d9ca035b35e177c9cc22079e4", "filename": "src/tools/clippy/tests/ui/eta.fixed", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -5,13 +5,10 @@\n     clippy::no_effect,\n     clippy::redundant_closure_call,\n     clippy::needless_pass_by_value,\n-    clippy::option_map_unit_fn\n-)]\n-#![warn(\n-    clippy::redundant_closure,\n-    clippy::redundant_closure_for_method_calls,\n+    clippy::option_map_unit_fn,\n     clippy::needless_borrow\n )]\n+#![warn(clippy::redundant_closure, clippy::redundant_closure_for_method_calls)]\n \n use std::path::{Path, PathBuf};\n \n@@ -34,7 +31,7 @@ fn main() {\n     Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n     let _: Option<Vec<u8>> = true.then(std::vec::Vec::new); // special case vec!\n     let d = Some(1u8).map(|a| foo(foo2(a))); //is adjusted?\n-    all(&[1, 2, 3], &2, below); //is adjusted\n+    all(&[1, 2, 3], &&2, below); //is adjusted\n     unsafe {\n         Some(1u8).map(|a| unsafe_fn(a)); // unsafe fn\n     }"}, {"sha": "a759e6eb514b42bacb0254c704fe251902711890", "filename": "src/tools/clippy/tests/ui/eta.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -5,13 +5,10 @@\n     clippy::no_effect,\n     clippy::redundant_closure_call,\n     clippy::needless_pass_by_value,\n-    clippy::option_map_unit_fn\n-)]\n-#![warn(\n-    clippy::redundant_closure,\n-    clippy::redundant_closure_for_method_calls,\n+    clippy::option_map_unit_fn,\n     clippy::needless_borrow\n )]\n+#![warn(clippy::redundant_closure, clippy::redundant_closure_for_method_calls)]\n \n use std::path::{Path, PathBuf};\n "}, {"sha": "cda84982c9b7508020113a57acf2474077147971", "filename": "src/tools/clippy/tests/ui/eta.stderr", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,134 +1,126 @@\n error: redundant closure\n-  --> $DIR/eta.rs:31:27\n+  --> $DIR/eta.rs:28:27\n    |\n LL |     let a = Some(1u8).map(|a| foo(a));\n    |                           ^^^^^^^^^^ help: replace the closure with the function itself: `foo`\n    |\n    = note: `-D clippy::redundant-closure` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:35:40\n+  --> $DIR/eta.rs:32:40\n    |\n LL |     let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n    |                                        ^^^^^^^^^ help: replace the closure with `Vec::new`: `std::vec::Vec::new`\n \n error: redundant closure\n-  --> $DIR/eta.rs:36:35\n+  --> $DIR/eta.rs:33:35\n    |\n LL |     let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n    |                                   ^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo2`\n \n-error: this expression borrows a reference (`&u8`) that is immediately dereferenced by the compiler\n-  --> $DIR/eta.rs:37:21\n-   |\n-LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n-   |                     ^^^ help: change this to: `&2`\n-   |\n-   = note: `-D clippy::needless-borrow` implied by `-D warnings`\n-\n error: redundant closure\n-  --> $DIR/eta.rs:37:26\n+  --> $DIR/eta.rs:34:26\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n    |                          ^^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `below`\n \n error: redundant closure\n-  --> $DIR/eta.rs:43:27\n+  --> $DIR/eta.rs:40:27\n    |\n LL |     let e = Some(1u8).map(|a| divergent(a));\n    |                           ^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `divergent`\n \n error: redundant closure\n-  --> $DIR/eta.rs:44:27\n+  --> $DIR/eta.rs:41:27\n    |\n LL |     let e = Some(1u8).map(|a| generic(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `generic`\n \n error: redundant closure\n-  --> $DIR/eta.rs:90:51\n+  --> $DIR/eta.rs:87:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n    |                                                   ^^^^^^^^^^^ help: replace the closure with the method itself: `TestStruct::foo`\n    |\n    = note: `-D clippy::redundant-closure-for-method-calls` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:91:51\n+  --> $DIR/eta.rs:88:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n    |                                                   ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `TestTrait::trait_foo`\n \n error: redundant closure\n-  --> $DIR/eta.rs:93:42\n+  --> $DIR/eta.rs:90:42\n    |\n LL |     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n    |                                          ^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::vec::Vec::clear`\n \n error: redundant closure\n-  --> $DIR/eta.rs:97:29\n+  --> $DIR/eta.rs:94:29\n    |\n LL |     let e = Some(\"str\").map(|s| s.to_string());\n    |                             ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::string::ToString::to_string`\n \n error: redundant closure\n-  --> $DIR/eta.rs:98:27\n+  --> $DIR/eta.rs:95:27\n    |\n LL |     let e = Some('a').map(|s| s.to_uppercase());\n    |                           ^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:100:65\n+  --> $DIR/eta.rs:97:65\n    |\n LL |     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n    |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_ascii_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:163:22\n+  --> $DIR/eta.rs:160:22\n    |\n LL |     requires_fn_once(|| x());\n    |                      ^^^^^^ help: replace the closure with the function itself: `x`\n \n error: redundant closure\n-  --> $DIR/eta.rs:170:27\n+  --> $DIR/eta.rs:167:27\n    |\n LL |     let a = Some(1u8).map(|a| foo_ptr(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo_ptr`\n \n error: redundant closure\n-  --> $DIR/eta.rs:175:27\n+  --> $DIR/eta.rs:172:27\n    |\n LL |     let a = Some(1u8).map(|a| closure(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `closure`\n \n error: redundant closure\n-  --> $DIR/eta.rs:207:28\n+  --> $DIR/eta.rs:204:28\n    |\n LL |     x.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:208:28\n+  --> $DIR/eta.rs:205:28\n    |\n LL |     y.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:209:28\n+  --> $DIR/eta.rs:206:28\n    |\n LL |     z.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:216:21\n+  --> $DIR/eta.rs:213:21\n    |\n LL |         Some(1).map(|n| closure(n));\n    |                     ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut closure`\n \n error: redundant closure\n-  --> $DIR/eta.rs:235:21\n+  --> $DIR/eta.rs:232:21\n    |\n LL |     map_str_to_path(|s| s.as_ref());\n    |                     ^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::convert::AsRef::as_ref`\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "3de2a51ffa5f326c516154723da1b8ff99c53f21", "filename": "src/tools/clippy/tests/ui/explicit_deref_methods.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_variables, clippy::clone_double_ref)]\n+#![allow(unused_variables, clippy::clone_double_ref, clippy::needless_borrow)]\n #![warn(clippy::explicit_deref_methods)]\n \n use std::ops::{Deref, DerefMut};"}, {"sha": "a08d75964220a06adcf52b519b4f9029f1bc3a19", "filename": "src/tools/clippy/tests/ui/explicit_deref_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_variables, clippy::clone_double_ref)]\n+#![allow(unused_variables, clippy::clone_double_ref, clippy::needless_borrow)]\n #![warn(clippy::explicit_deref_methods)]\n \n use std::ops::{Deref, DerefMut};"}, {"sha": "aa69781d15a6bc40f6222382fb0fe4d85c1a8b1f", "filename": "src/tools/clippy/tests/ui/for_loop_fixable.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffor_loop_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffor_loop_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffor_loop_fixable.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -23,7 +23,12 @@ impl Unrelated {\n     clippy::iter_next_loop,\n     clippy::for_kv_map\n )]\n-#[allow(clippy::linkedlist, clippy::unnecessary_mut_passed, clippy::similar_names)]\n+#[allow(\n+    clippy::linkedlist,\n+    clippy::unnecessary_mut_passed,\n+    clippy::similar_names,\n+    clippy::needless_borrow\n+)]\n #[allow(unused_variables)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];"}, {"sha": "7c063d99511d81950720ef67753c78f0cba81318", "filename": "src/tools/clippy/tests/ui/for_loop_fixable.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffor_loop_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffor_loop_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffor_loop_fixable.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -23,7 +23,12 @@ impl Unrelated {\n     clippy::iter_next_loop,\n     clippy::for_kv_map\n )]\n-#[allow(clippy::linkedlist, clippy::unnecessary_mut_passed, clippy::similar_names)]\n+#[allow(\n+    clippy::linkedlist,\n+    clippy::unnecessary_mut_passed,\n+    clippy::similar_names,\n+    clippy::needless_borrow\n+)]\n #[allow(unused_variables)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];"}, {"sha": "ddfe66d675f91efbc8f070116c570ef9eda5a496", "filename": "src/tools/clippy/tests/ui/for_loop_fixable.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffor_loop_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffor_loop_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffor_loop_fixable.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,93 +1,93 @@\n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:38:15\n+  --> $DIR/for_loop_fixable.rs:43:15\n    |\n LL |     for _v in vec.iter() {}\n    |               ^^^^^^^^^^ help: to write this more concisely, try: `&vec`\n    |\n    = note: `-D clippy::explicit-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:40:15\n+  --> $DIR/for_loop_fixable.rs:45:15\n    |\n LL |     for _v in vec.iter_mut() {}\n    |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&mut vec`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:43:15\n+  --> $DIR/for_loop_fixable.rs:48:15\n    |\n LL |     for _v in out_vec.into_iter() {}\n    |               ^^^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `out_vec`\n    |\n    = note: `-D clippy::explicit-into-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:48:15\n+  --> $DIR/for_loop_fixable.rs:53:15\n    |\n LL |     for _v in [1, 2, 3].iter() {}\n    |               ^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[1, 2, 3]`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:52:15\n+  --> $DIR/for_loop_fixable.rs:57:15\n    |\n LL |     for _v in [0; 32].iter() {}\n    |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[0; 32]`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:57:15\n+  --> $DIR/for_loop_fixable.rs:62:15\n    |\n LL |     for _v in ll.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&ll`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:60:15\n+  --> $DIR/for_loop_fixable.rs:65:15\n    |\n LL |     for _v in vd.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&vd`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:63:15\n+  --> $DIR/for_loop_fixable.rs:68:15\n    |\n LL |     for _v in bh.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bh`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:66:15\n+  --> $DIR/for_loop_fixable.rs:71:15\n    |\n LL |     for _v in hm.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&hm`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:69:15\n+  --> $DIR/for_loop_fixable.rs:74:15\n    |\n LL |     for _v in bt.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bt`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:72:15\n+  --> $DIR/for_loop_fixable.rs:77:15\n    |\n LL |     for _v in hs.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&hs`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:75:15\n+  --> $DIR/for_loop_fixable.rs:80:15\n    |\n LL |     for _v in bs.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bs`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:250:18\n+  --> $DIR/for_loop_fixable.rs:255:18\n    |\n LL |         for i in iterator.into_iter() {\n    |                  ^^^^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `iterator`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:270:18\n+  --> $DIR/for_loop_fixable.rs:275:18\n    |\n LL |         for _ in t.into_iter() {}\n    |                  ^^^^^^^^^^^^^ help: to write this more concisely, try: `&t`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:272:18\n+  --> $DIR/for_loop_fixable.rs:277:18\n    |\n LL |         for _ in r.into_iter() {}\n    |                  ^^^^^^^^^^^^^ help: to write this more concisely, try: `r`"}, {"sha": "d08f8f52495adf56f677098a395f10eb94fd5fca", "filename": "src/tools/clippy/tests/ui/format.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,6 +1,11 @@\n // run-rustfix\n \n-#![allow(clippy::print_literal, clippy::redundant_clone, clippy::to_string_in_format_args)]\n+#![allow(\n+    clippy::print_literal,\n+    clippy::redundant_clone,\n+    clippy::to_string_in_format_args,\n+    clippy::needless_borrow\n+)]\n #![warn(clippy::useless_format)]\n \n struct Foo(pub String);"}, {"sha": "4a10b580d2600171fed59d008a687756fcfef0aa", "filename": "src/tools/clippy/tests/ui/format.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,6 +1,11 @@\n // run-rustfix\n \n-#![allow(clippy::print_literal, clippy::redundant_clone, clippy::to_string_in_format_args)]\n+#![allow(\n+    clippy::print_literal,\n+    clippy::redundant_clone,\n+    clippy::to_string_in_format_args,\n+    clippy::needless_borrow\n+)]\n #![warn(clippy::useless_format)]\n \n struct Foo(pub String);"}, {"sha": "f25c7fb1ff1cbc8fda16579ded43a98d6f7775dc", "filename": "src/tools/clippy/tests/ui/format.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,25 +1,25 @@\n error: useless use of `format!`\n-  --> $DIR/format.rs:13:5\n+  --> $DIR/format.rs:18:5\n    |\n LL |     format!(\"foo\");\n    |     ^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"foo\".to_string()`\n    |\n    = note: `-D clippy::useless-format` implied by `-D warnings`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:14:5\n+  --> $DIR/format.rs:19:5\n    |\n LL |     format!(\"{{}}\");\n    |     ^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"{}\".to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:15:5\n+  --> $DIR/format.rs:20:5\n    |\n LL |     format!(\"{{}} abc {{}}\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"{} abc {}\".to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:16:5\n+  --> $DIR/format.rs:21:5\n    |\n LL | /     format!(\n LL | |         r##\"foo {{}}\n@@ -34,79 +34,79 @@ LL ~ \" bar\"##.to_string();\n    |\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:21:13\n+  --> $DIR/format.rs:26:13\n    |\n LL |     let _ = format!(\"\");\n    |             ^^^^^^^^^^^ help: consider using `String::new()`: `String::new()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:23:5\n+  --> $DIR/format.rs:28:5\n    |\n LL |     format!(\"{}\", \"foo\");\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"foo\".to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:27:5\n+  --> $DIR/format.rs:32:5\n    |\n LL |     format!(\"{:+}\", \"foo\"); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"foo\".to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:28:5\n+  --> $DIR/format.rs:33:5\n    |\n LL |     format!(\"{:<}\", \"foo\"); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"foo\".to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:33:5\n+  --> $DIR/format.rs:38:5\n    |\n LL |     format!(\"{}\", arg);\n    |     ^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `arg.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:37:5\n+  --> $DIR/format.rs:42:5\n    |\n LL |     format!(\"{:+}\", arg); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `arg.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:38:5\n+  --> $DIR/format.rs:43:5\n    |\n LL |     format!(\"{:<}\", arg); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `arg.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:65:5\n+  --> $DIR/format.rs:70:5\n    |\n LL |     format!(\"{}\", 42.to_string());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `42.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:67:5\n+  --> $DIR/format.rs:72:5\n    |\n LL |     format!(\"{}\", x.display().to_string());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `x.display().to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:71:18\n+  --> $DIR/format.rs:76:18\n    |\n LL |     let _ = Some(format!(\"{}\", a + \"bar\"));\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `a + \"bar\"`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:75:22\n+  --> $DIR/format.rs:80:22\n    |\n LL |     let _s: String = format!(\"{}\", &*v.join(\"/n\"));\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `(&*v.join(\"/n\")).to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:81:13\n+  --> $DIR/format.rs:86:13\n    |\n LL |     let _ = format!(\"{x}\");\n    |             ^^^^^^^^^^^^^^ help: consider using `.to_string()`: `x.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:83:13\n+  --> $DIR/format.rs:88:13\n    |\n LL |     let _ = format!(\"{y}\", y = x);\n    |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `x.to_string()`"}, {"sha": "b856f1375d303ad11520922ae7a78fc9e359c0be", "filename": "src/tools/clippy/tests/ui/needless_borrow.fixed", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -45,6 +45,33 @@ fn main() {\n         let b = &mut b;\n         x(b);\n     }\n+\n+    // Issue #8191\n+    let mut x = 5;\n+    let mut x = &mut x;\n+\n+    mut_ref(x);\n+    mut_ref(x);\n+    let y: &mut i32 = x;\n+    let y: &mut i32 = x;\n+\n+    let y = match 0 {\n+        // Don't lint. Removing the borrow would move 'x'\n+        0 => &mut x,\n+        _ => &mut *x,\n+    };\n+\n+    *x = 5;\n+\n+    let s = String::new();\n+    let _ = s.len();\n+    let _ = s.capacity();\n+    let _ = s.capacity();\n+\n+    let x = (1, 2);\n+    let _ = x.0;\n+    let x = &x as *const (i32, i32);\n+    let _ = unsafe { (*x).0 };\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "0bfe222a3dc170ee85bf20f1e2fadb2766891560", "filename": "src/tools/clippy/tests/ui/needless_borrow.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -45,6 +45,33 @@ fn main() {\n         let b = &mut b;\n         x(&b);\n     }\n+\n+    // Issue #8191\n+    let mut x = 5;\n+    let mut x = &mut x;\n+\n+    mut_ref(&mut x);\n+    mut_ref(&mut &mut x);\n+    let y: &mut i32 = &mut x;\n+    let y: &mut i32 = &mut &mut x;\n+\n+    let y = match 0 {\n+        // Don't lint. Removing the borrow would move 'x'\n+        0 => &mut x,\n+        _ => &mut *x,\n+    };\n+\n+    *x = 5;\n+\n+    let s = String::new();\n+    let _ = (&s).len();\n+    let _ = (&s).capacity();\n+    let _ = (&&s).capacity();\n+\n+    let x = (1, 2);\n+    let _ = (&x).0;\n+    let x = &x as *const (i32, i32);\n+    let _ = unsafe { (&*x).0 };\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "b90e8448db0a3ac377949addf360f56441a5b401", "filename": "src/tools/clippy/tests/ui/needless_borrow.stderr", "status": "modified", "additions": 65, "deletions": 11, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,64 +1,118 @@\n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:9:15\n    |\n LL |     let _ = x(&&a); // warn\n    |               ^^^ help: change this to: `&a`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:13:13\n    |\n LL |     mut_ref(&mut &mut b); // warn\n    |             ^^^^^^^^^^^ help: change this to: `&mut b`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:25:13\n    |\n LL |             &&a\n    |             ^^^ help: change this to: `&a`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:27:15\n    |\n LL |         46 => &&a,\n    |               ^^^ help: change this to: `&a`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:33:27\n    |\n LL |                     break &ref_a;\n    |                           ^^^^^^ help: change this to: `ref_a`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:40:15\n    |\n LL |     let _ = x(&&&a);\n    |               ^^^^ help: change this to: `&a`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:41:15\n    |\n LL |     let _ = x(&mut &&a);\n    |               ^^^^^^^^ help: change this to: `&a`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:42:15\n    |\n LL |     let _ = x(&&&mut b);\n    |               ^^^^^^^^ help: change this to: `&mut b`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:43:15\n    |\n LL |     let _ = x(&&ref_a);\n    |               ^^^^^^^ help: change this to: `ref_a`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:46:11\n    |\n LL |         x(&b);\n    |           ^^ help: change this to: `b`\n \n-error: aborting due to 10 previous errors\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:53:13\n+   |\n+LL |     mut_ref(&mut x);\n+   |             ^^^^^^ help: change this to: `x`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:54:13\n+   |\n+LL |     mut_ref(&mut &mut x);\n+   |             ^^^^^^^^^^^ help: change this to: `x`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:55:23\n+   |\n+LL |     let y: &mut i32 = &mut x;\n+   |                       ^^^^^^ help: change this to: `x`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:56:23\n+   |\n+LL |     let y: &mut i32 = &mut &mut x;\n+   |                       ^^^^^^^^^^^ help: change this to: `x`\n+\n+error: this expression borrows a value the compiler would automatically borrow\n+  --> $DIR/needless_borrow.rs:67:13\n+   |\n+LL |     let _ = (&s).len();\n+   |             ^^^^ help: change this to: `s`\n+\n+error: this expression borrows a value the compiler would automatically borrow\n+  --> $DIR/needless_borrow.rs:68:13\n+   |\n+LL |     let _ = (&s).capacity();\n+   |             ^^^^ help: change this to: `s`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:69:13\n+   |\n+LL |     let _ = (&&s).capacity();\n+   |             ^^^^^ help: change this to: `s`\n+\n+error: this expression borrows a value the compiler would automatically borrow\n+  --> $DIR/needless_borrow.rs:72:13\n+   |\n+LL |     let _ = (&x).0;\n+   |             ^^^^ help: change this to: `x`\n+\n+error: this expression borrows a value the compiler would automatically borrow\n+  --> $DIR/needless_borrow.rs:74:22\n+   |\n+LL |     let _ = unsafe { (&*x).0 };\n+   |                      ^^^^^ help: change this to: `(*x)`\n+\n+error: aborting due to 19 previous errors\n "}, {"sha": "f3eafe8e9279e2167bb2d7dfe7f94dd5deb3b15a", "filename": "src/tools/clippy/tests/ui/needless_lifetimes.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,5 +1,11 @@\n #![warn(clippy::needless_lifetimes)]\n-#![allow(dead_code, clippy::needless_pass_by_value, clippy::unnecessary_wraps, dyn_drop)]\n+#![allow(\n+    dead_code,\n+    clippy::boxed_local,\n+    clippy::needless_pass_by_value,\n+    clippy::unnecessary_wraps,\n+    dyn_drop\n+)]\n \n fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) {}\n \n@@ -369,4 +375,47 @@ mod issue6159 {\n     }\n }\n \n+mod issue7296 {\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    struct Foo;\n+    impl Foo {\n+        fn implicit<'a>(&'a self) -> &'a () {\n+            &()\n+        }\n+        fn implicit_mut<'a>(&'a mut self) -> &'a () {\n+            &()\n+        }\n+\n+        fn explicit<'a>(self: &'a Arc<Self>) -> &'a () {\n+            &()\n+        }\n+        fn explicit_mut<'a>(self: &'a mut Rc<Self>) -> &'a () {\n+            &()\n+        }\n+\n+        fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n+            &()\n+        }\n+    }\n+\n+    trait Bar {\n+        fn implicit<'a>(&'a self) -> &'a ();\n+        fn implicit_provided<'a>(&'a self) -> &'a () {\n+            &()\n+        }\n+\n+        fn explicit<'a>(self: &'a Arc<Self>) -> &'a ();\n+        fn explicit_provided<'a>(self: &'a Arc<Self>) -> &'a () {\n+            &()\n+        }\n+\n+        fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a ();\n+        fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n+            &()\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "ffa152427a97740c108221fccfbfad53096500aa", "filename": "src/tools/clippy/tests/ui/needless_lifetimes.stderr", "status": "modified", "additions": 68, "deletions": 26, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,154 +1,196 @@\n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:4:1\n+  --> $DIR/needless_lifetimes.rs:10:1\n    |\n LL | fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::needless-lifetimes` implied by `-D warnings`\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:6:1\n+  --> $DIR/needless_lifetimes.rs:12:1\n    |\n LL | fn distinct_and_static<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: &'static u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:16:1\n+  --> $DIR/needless_lifetimes.rs:22:1\n    |\n LL | fn in_and_out<'a>(x: &'a u8, _y: u8) -> &'a u8 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:50:1\n+  --> $DIR/needless_lifetimes.rs:56:1\n    |\n LL | fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:55:1\n+  --> $DIR/needless_lifetimes.rs:61:1\n    |\n LL | fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:67:1\n+  --> $DIR/needless_lifetimes.rs:73:1\n    |\n LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:91:1\n+  --> $DIR/needless_lifetimes.rs:97:1\n    |\n LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:121:5\n+  --> $DIR/needless_lifetimes.rs:127:5\n    |\n LL |     fn self_and_out<'s>(&'s self) -> &'s u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:130:5\n+  --> $DIR/needless_lifetimes.rs:136:5\n    |\n LL |     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:149:1\n+  --> $DIR/needless_lifetimes.rs:155:1\n    |\n LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:179:1\n+  --> $DIR/needless_lifetimes.rs:185:1\n    |\n LL | fn trait_obj_elided2<'a>(_arg: &'a dyn Drop) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:185:1\n+  --> $DIR/needless_lifetimes.rs:191:1\n    |\n LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:204:1\n+  --> $DIR/needless_lifetimes.rs:210:1\n    |\n LL | fn named_input_elided_output<'a>(_arg: &'a str) -> &str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:212:1\n+  --> $DIR/needless_lifetimes.rs:218:1\n    |\n LL | fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:248:1\n+  --> $DIR/needless_lifetimes.rs:254:1\n    |\n LL | fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:255:9\n+  --> $DIR/needless_lifetimes.rs:261:9\n    |\n LL |         fn needless_lt<'a>(x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:259:9\n+  --> $DIR/needless_lifetimes.rs:265:9\n    |\n LL |         fn needless_lt<'a>(_x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:272:9\n+  --> $DIR/needless_lifetimes.rs:278:9\n    |\n LL |         fn baz<'a>(&'a self) -> impl Foo + 'a {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:301:5\n+  --> $DIR/needless_lifetimes.rs:307:5\n    |\n LL |     fn impl_trait_elidable_nested_named_lifetimes<'a>(i: &'a i32, f: impl for<'b> Fn(&'b i32) -> &'b i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:304:5\n+  --> $DIR/needless_lifetimes.rs:310:5\n    |\n LL |     fn impl_trait_elidable_nested_anonymous_lifetimes<'a>(i: &'a i32, f: impl Fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:313:5\n+  --> $DIR/needless_lifetimes.rs:319:5\n    |\n LL |     fn generics_elidable<'a, T: Fn(&i32) -> &i32>(i: &'a i32, f: T) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:325:5\n+  --> $DIR/needless_lifetimes.rs:331:5\n    |\n LL |     fn where_clause_elidadable<'a, T>(i: &'a i32, f: T) -> &'a i32\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:340:5\n+  --> $DIR/needless_lifetimes.rs:346:5\n    |\n LL |     fn pointer_fn_elidable<'a>(i: &'a i32, f: fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:353:5\n+  --> $DIR/needless_lifetimes.rs:359:5\n    |\n LL |     fn nested_fn_pointer_3<'a>(_: &'a i32) -> fn(fn(&i32) -> &i32) -> i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:356:5\n+  --> $DIR/needless_lifetimes.rs:362:5\n    |\n LL |     fn nested_fn_pointer_4<'a>(_: &'a i32) -> impl Fn(fn(&i32)) {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 25 previous errors\n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/needless_lifetimes.rs:384:9\n+   |\n+LL |         fn implicit<'a>(&'a self) -> &'a () {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/needless_lifetimes.rs:387:9\n+   |\n+LL |         fn implicit_mut<'a>(&'a mut self) -> &'a () {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/needless_lifetimes.rs:398:9\n+   |\n+LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/needless_lifetimes.rs:404:9\n+   |\n+LL |         fn implicit<'a>(&'a self) -> &'a ();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/needless_lifetimes.rs:405:9\n+   |\n+LL |         fn implicit_provided<'a>(&'a self) -> &'a () {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/needless_lifetimes.rs:414:9\n+   |\n+LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a ();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/needless_lifetimes.rs:415:9\n+   |\n+LL |         fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 32 previous errors\n "}, {"sha": "ba9d15e59d0e45376374c23b07b87c661def3a17", "filename": "src/tools/clippy/tests/ui/needless_question_mark.fixed", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_question_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_question_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_question_mark.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -125,3 +125,16 @@ pub fn test2() {\n     let x = Some(3);\n     let _x = some_and_qmark_in_macro!(x?);\n }\n+\n+async fn async_option_bad(to: TO) -> Option<usize> {\n+    let _ = Some(3);\n+    to.magic\n+}\n+\n+async fn async_deref_ref(s: Option<&String>) -> Option<&str> {\n+    Some(s?)\n+}\n+\n+async fn async_result_bad(s: TR) -> Result<usize, bool> {\n+    s.magic\n+}"}, {"sha": "3a6523e8fe872a94b172c851d1c997f9a1ed9350", "filename": "src/tools/clippy/tests/ui/needless_question_mark.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_question_mark.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -125,3 +125,16 @@ pub fn test2() {\n     let x = Some(3);\n     let _x = some_and_qmark_in_macro!(x?);\n }\n+\n+async fn async_option_bad(to: TO) -> Option<usize> {\n+    let _ = Some(3);\n+    Some(to.magic?)\n+}\n+\n+async fn async_deref_ref(s: Option<&String>) -> Option<&str> {\n+    Some(s?)\n+}\n+\n+async fn async_result_bad(s: TR) -> Result<usize, bool> {\n+    Ok(s.magic?)\n+}"}, {"sha": "f8308e24e7712e62adbf9b248757a3c9b0b32abb", "filename": "src/tools/clippy/tests/ui/needless_question_mark.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_question_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_question_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_question_mark.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -77,5 +77,17 @@ LL |     let _x = some_and_qmark_in_macro!(x?);\n    |\n    = note: this error originates in the macro `some_and_qmark_in_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 12 previous errors\n+error: question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:131:5\n+   |\n+LL |     Some(to.magic?)\n+   |     ^^^^^^^^^^^^^^^ help: try removing question mark and `Some()`: `to.magic`\n+\n+error: question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:139:5\n+   |\n+LL |     Ok(s.magic?)\n+   |     ^^^^^^^^^^^^ help: try removing question mark and `Ok()`: `s.magic`\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "d8bf66603d9f5840f4878552bf4b34f4d62c5379", "filename": "src/tools/clippy/tests/ui/op_ref.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fop_ref.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,7 +1,7 @@\n #![allow(unused_variables, clippy::blacklisted_name)]\n #![warn(clippy::op_ref)]\n use std::collections::HashSet;\n-use std::ops::BitAnd;\n+use std::ops::{BitAnd, Mul};\n \n fn main() {\n     let tracked_fds: HashSet<i32> = HashSet::new();\n@@ -55,3 +55,40 @@ fn main() {\n     let y = Y(2);\n     let z = x & &y;\n }\n+\n+#[derive(Clone, Copy)]\n+struct A(i32);\n+#[derive(Clone, Copy)]\n+struct B(i32);\n+\n+impl Mul<&A> for B {\n+    type Output = i32;\n+    fn mul(self, rhs: &A) -> Self::Output {\n+        self.0 * rhs.0\n+    }\n+}\n+impl Mul<A> for B {\n+    type Output = i32;\n+    fn mul(self, rhs: A) -> Self::Output {\n+        // Should not lint because removing the reference would lead to unconditional recursion\n+        self * &rhs\n+    }\n+}\n+impl Mul<&A> for A {\n+    type Output = i32;\n+    fn mul(self, rhs: &A) -> Self::Output {\n+        self.0 * rhs.0\n+    }\n+}\n+impl Mul<A> for A {\n+    type Output = i32;\n+    fn mul(self, rhs: A) -> Self::Output {\n+        let one = B(1);\n+        let two = 2;\n+        let three = 3;\n+        let _ = one * &self;\n+        let _ = two + &three;\n+        // Removing the reference would lead to unconditional recursion\n+        self * &rhs\n+    }\n+}"}, {"sha": "fe36c01166ff714c959a9abcdae7f7a1ec6ed51d", "filename": "src/tools/clippy/tests/ui/op_ref.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fop_ref.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -18,5 +18,21 @@ LL |     let z = x & &y;\n    |                 |\n    |                 help: use the right value directly: `y`\n \n-error: aborting due to 2 previous errors\n+error: taken reference of right operand\n+  --> $DIR/op_ref.rs:89:17\n+   |\n+LL |         let _ = one * &self;\n+   |                 ^^^^^^-----\n+   |                       |\n+   |                       help: use the right value directly: `self`\n+\n+error: taken reference of right operand\n+  --> $DIR/op_ref.rs:90:17\n+   |\n+LL |         let _ = two + &three;\n+   |                 ^^^^^^------\n+   |                       |\n+   |                       help: use the right value directly: `three`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "ed72423780821792ae61ea24d6fb322547465e16", "filename": "src/tools/clippy/tests/ui/ptr_arg.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -9,7 +9,6 @@ fn do_vec(x: &Vec<i64>) {\n }\n \n fn do_vec_mut(x: &mut Vec<i64>) {\n-    // no error here\n     //Nothing here\n }\n \n@@ -18,7 +17,6 @@ fn do_str(x: &String) {\n }\n \n fn do_str_mut(x: &mut String) {\n-    // no error here\n     //Nothing here either\n }\n \n@@ -27,7 +25,6 @@ fn do_path(x: &PathBuf) {\n }\n \n fn do_path_mut(x: &mut PathBuf) {\n-    // no error here\n     //Nothing here either\n }\n \n@@ -52,7 +49,7 @@ fn cloned(x: &Vec<u8>) -> Vec<u8> {\n     let e = x.clone();\n     let f = e.clone(); // OK\n     let g = x;\n-    let h = g.clone(); // Alas, we cannot reliably detect this without following data.\n+    let h = g.clone();\n     let i = (e).clone();\n     x.clone()\n }\n@@ -156,6 +153,30 @@ mod issue6509 {\n     }\n }\n \n+fn mut_vec_slice_methods(v: &mut Vec<u32>) {\n+    v.copy_within(1..5, 10);\n+}\n+\n+fn mut_vec_vec_methods(v: &mut Vec<u32>) {\n+    v.clear();\n+}\n+\n+fn vec_contains(v: &Vec<u32>) -> bool {\n+    [vec![], vec![0]].as_slice().contains(v)\n+}\n+\n+fn fn_requires_vec(v: &Vec<u32>) -> bool {\n+    vec_contains(v)\n+}\n+\n+fn impl_fn_requires_vec(v: &Vec<u32>, f: impl Fn(&Vec<u32>)) {\n+    f(v);\n+}\n+\n+fn dyn_fn_requires_vec(v: &Vec<u32>, f: &dyn Fn(&Vec<u32>)) {\n+    f(v);\n+}\n+\n // No error for types behind an alias (#7699)\n type A = Vec<u8>;\n fn aliased(a: &A) {}"}, {"sha": "a9613daadde1023cd3953ff27dd9fdbbf4a0a4b0", "filename": "src/tools/clippy/tests/ui/ptr_arg.stderr", "status": "modified", "additions": 71, "deletions": 87, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,175 +1,159 @@\n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n+error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n   --> $DIR/ptr_arg.rs:7:14\n    |\n LL | fn do_vec(x: &Vec<i64>) {\n    |              ^^^^^^^^^ help: change this to: `&[i64]`\n    |\n    = note: `-D clippy::ptr-arg` implied by `-D warnings`\n \n+error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:11:18\n+   |\n+LL | fn do_vec_mut(x: &mut Vec<i64>) {\n+   |                  ^^^^^^^^^^^^^ help: change this to: `&mut [i64]`\n+\n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:16:14\n+  --> $DIR/ptr_arg.rs:15:14\n    |\n LL | fn do_str(x: &String) {\n    |              ^^^^^^^ help: change this to: `&str`\n \n+error: writing `&mut String` instead of `&mut str` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:19:18\n+   |\n+LL | fn do_str_mut(x: &mut String) {\n+   |                  ^^^^^^^^^^^ help: change this to: `&mut str`\n+\n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:25:15\n+  --> $DIR/ptr_arg.rs:23:15\n    |\n LL | fn do_path(x: &PathBuf) {\n    |               ^^^^^^^^ help: change this to: `&Path`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:38:18\n+error: writing `&mut PathBuf` instead of `&mut Path` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:27:19\n+   |\n+LL | fn do_path_mut(x: &mut PathBuf) {\n+   |                   ^^^^^^^^^^^^ help: change this to: `&mut Path`\n+\n+error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:35:18\n    |\n LL |     fn do_vec(x: &Vec<i64>);\n    |                  ^^^^^^^^^ help: change this to: `&[i64]`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:51:14\n+error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:48:14\n    |\n LL | fn cloned(x: &Vec<u8>) -> Vec<u8> {\n    |              ^^^^^^^^\n    |\n help: change this to\n    |\n-LL | fn cloned(x: &[u8]) -> Vec<u8> {\n-   |              ~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let e = x.to_owned();\n-   |             ~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     x.to_owned()\n-   |\n+LL ~ fn cloned(x: &[u8]) -> Vec<u8> {\n+LL ~     let e = x.to_owned();\n+LL |     let f = e.clone(); // OK\n+LL |     let g = x;\n+LL ~     let h = g.to_owned();\n+LL |     let i = (e).clone();\n+ ...\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:60:18\n+  --> $DIR/ptr_arg.rs:57:18\n    |\n LL | fn str_cloned(x: &String) -> String {\n    |                  ^^^^^^^\n    |\n help: change this to\n    |\n-LL | fn str_cloned(x: &str) -> String {\n-   |                  ~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let a = x.to_string();\n-   |             ~~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let b = x.to_string();\n-   |             ~~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     x.to_string()\n+LL ~ fn str_cloned(x: &str) -> String {\n+LL ~     let a = x.to_owned();\n+LL ~     let b = x.to_owned();\n+LL |     let c = b.clone();\n+LL |     let d = a.clone().clone().clone();\n+LL ~     x.to_owned()\n    |\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:68:19\n+  --> $DIR/ptr_arg.rs:65:19\n    |\n LL | fn path_cloned(x: &PathBuf) -> PathBuf {\n    |                   ^^^^^^^^\n    |\n help: change this to\n    |\n-LL | fn path_cloned(x: &Path) -> PathBuf {\n-   |                   ~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let a = x.to_path_buf();\n-   |             ~~~~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let b = x.to_path_buf();\n-   |             ~~~~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     x.to_path_buf()\n+LL ~ fn path_cloned(x: &Path) -> PathBuf {\n+LL ~     let a = x.to_path_buf();\n+LL ~     let b = x.to_path_buf();\n+LL |     let c = b.clone();\n+LL |     let d = a.clone().clone().clone();\n+LL ~     x.to_path_buf()\n    |\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:76:44\n+  --> $DIR/ptr_arg.rs:73:44\n    |\n LL | fn false_positive_capacity(x: &Vec<u8>, y: &String) {\n    |                                            ^^^^^^^\n    |\n help: change this to\n    |\n-LL | fn false_positive_capacity(x: &Vec<u8>, y: &str) {\n-   |                                            ~~~~\n-help: change `y.clone()` to\n+LL ~ fn false_positive_capacity(x: &Vec<u8>, y: &str) {\n+LL |     let a = x.capacity();\n+LL ~     let b = y.to_owned();\n+LL ~     let c = y;\n    |\n-LL |     let b = y.to_string();\n-   |             ~~~~~~~~~~~~~\n-help: change `y.as_str()` to\n-   |\n-LL |     let c = y;\n-   |             ~\n \n error: using a reference to `Cow` is not recommended\n-  --> $DIR/ptr_arg.rs:90:25\n+  --> $DIR/ptr_arg.rs:87:25\n    |\n LL | fn test_cow_with_ref(c: &Cow<[i32]>) {}\n    |                         ^^^^^^^^^^^ help: change this to: `&[i32]`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:143:21\n+error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:140:21\n    |\n LL |     fn foo_vec(vec: &Vec<u8>) {\n    |                     ^^^^^^^^\n    |\n help: change this to\n    |\n-LL |     fn foo_vec(vec: &[u8]) {\n-   |                     ~~~~~\n-help: change `vec.clone()` to\n-   |\n-LL |         let _ = vec.to_owned().pop();\n-   |                 ~~~~~~~~~~~~~~\n-help: change `vec.clone()` to\n+LL ~     fn foo_vec(vec: &[u8]) {\n+LL ~         let _ = vec.to_owned().pop();\n+LL ~         let _ = vec.to_owned().clone();\n    |\n-LL |         let _ = vec.to_owned().clone();\n-   |                 ~~~~~~~~~~~~~~\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:148:23\n+  --> $DIR/ptr_arg.rs:145:23\n    |\n LL |     fn foo_path(path: &PathBuf) {\n    |                       ^^^^^^^^\n    |\n help: change this to\n    |\n-LL |     fn foo_path(path: &Path) {\n-   |                       ~~~~~\n-help: change `path.clone()` to\n+LL ~     fn foo_path(path: &Path) {\n+LL ~         let _ = path.to_path_buf().pop();\n+LL ~         let _ = path.to_path_buf().clone();\n    |\n-LL |         let _ = path.to_path_buf().pop();\n-   |                 ~~~~~~~~~~~~~~~~~~\n-help: change `path.clone()` to\n-   |\n-LL |         let _ = path.to_path_buf().clone();\n-   |                 ~~~~~~~~~~~~~~~~~~\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:153:21\n+  --> $DIR/ptr_arg.rs:150:21\n    |\n LL |     fn foo_str(str: &PathBuf) {\n    |                     ^^^^^^^^\n    |\n help: change this to\n    |\n-LL |     fn foo_str(str: &Path) {\n-   |                     ~~~~~\n-help: change `str.clone()` to\n+LL ~     fn foo_str(str: &Path) {\n+LL ~         let _ = str.to_path_buf().pop();\n+LL ~         let _ = str.to_path_buf().clone();\n    |\n-LL |         let _ = str.to_path_buf().pop();\n-   |                 ~~~~~~~~~~~~~~~~~\n-help: change `str.clone()` to\n+\n+error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:156:29\n    |\n-LL |         let _ = str.to_path_buf().clone();\n-   |                 ~~~~~~~~~~~~~~~~~\n+LL | fn mut_vec_slice_methods(v: &mut Vec<u32>) {\n+   |                             ^^^^^^^^^^^^^ help: change this to: `&mut [u32]`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "a89845c1dd32b900c544ab169f6b91cc70640e74", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching_option.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -81,7 +81,7 @@ const fn issue6067() {\n     None::<()>.is_none();\n }\n \n-#[allow(clippy::deref_addrof, dead_code)]\n+#[allow(clippy::deref_addrof, dead_code, clippy::needless_borrow)]\n fn issue7921() {\n     if (&None::<()>).is_none() {}\n     if (&None::<()>).is_none() {}"}, {"sha": "d6f44403487efda300ab4b27ed7f7d0b62b6e798", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching_option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -96,7 +96,7 @@ const fn issue6067() {\n     };\n }\n \n-#[allow(clippy::deref_addrof, dead_code)]\n+#[allow(clippy::deref_addrof, dead_code, clippy::needless_borrow)]\n fn issue7921() {\n     if let None = *(&None::<()>) {}\n     if let None = *&None::<()> {}"}, {"sha": "8bddec576ed14ceb3eb1448d4f8f509ff4c5ed30", "filename": "src/tools/clippy/tests/ui/rename.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -54,6 +54,7 @@\n #![warn(clippy::match_result_ok)]\n #![warn(clippy::disallowed_types)]\n #![warn(clippy::disallowed_methods)]\n+#![warn(clippy::needless_borrow)]\n // uplifted lints\n #![warn(invalid_value)]\n #![warn(array_into_iter)]"}, {"sha": "d2010d71d2c118681cb7b8f56ddc347af2dfb57e", "filename": "src/tools/clippy/tests/ui/rename.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -54,6 +54,7 @@\n #![warn(clippy::if_let_some_result)]\n #![warn(clippy::disallowed_type)]\n #![warn(clippy::disallowed_method)]\n+#![warn(clippy::ref_in_deref)]\n // uplifted lints\n #![warn(clippy::invalid_ref)]\n #![warn(clippy::into_iter_on_array)]"}, {"sha": "45cb8b786f5f3d89ba5c357d47343d0a4311ee11", "filename": "src/tools/clippy/tests/ui/rename.stderr", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -138,59 +138,65 @@ error: lint `clippy::disallowed_method` has been renamed to `clippy::disallowed_\n LL | #![warn(clippy::disallowed_method)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_methods`\n \n+error: lint `clippy::ref_in_deref` has been renamed to `clippy::needless_borrow`\n+  --> $DIR/rename.rs:57:9\n+   |\n+LL | #![warn(clippy::ref_in_deref)]\n+   |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::needless_borrow`\n+\n error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n-  --> $DIR/rename.rs:58:9\n+  --> $DIR/rename.rs:59:9\n    |\n LL | #![warn(clippy::invalid_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n \n error: lint `clippy::into_iter_on_array` has been renamed to `array_into_iter`\n-  --> $DIR/rename.rs:59:9\n+  --> $DIR/rename.rs:60:9\n    |\n LL | #![warn(clippy::into_iter_on_array)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `array_into_iter`\n \n error: lint `clippy::unused_label` has been renamed to `unused_labels`\n-  --> $DIR/rename.rs:60:9\n+  --> $DIR/rename.rs:61:9\n    |\n LL | #![warn(clippy::unused_label)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`\n \n error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n-  --> $DIR/rename.rs:61:9\n+  --> $DIR/rename.rs:62:9\n    |\n LL | #![warn(clippy::drop_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n \n error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n-  --> $DIR/rename.rs:62:9\n+  --> $DIR/rename.rs:63:9\n    |\n LL | #![warn(clippy::temporary_cstring_as_ptr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n \n error: lint `clippy::panic_params` has been renamed to `non_fmt_panics`\n-  --> $DIR/rename.rs:63:9\n+  --> $DIR/rename.rs:64:9\n    |\n LL | #![warn(clippy::panic_params)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panics`\n \n error: lint `clippy::unknown_clippy_lints` has been renamed to `unknown_lints`\n-  --> $DIR/rename.rs:64:9\n+  --> $DIR/rename.rs:65:9\n    |\n LL | #![warn(clippy::unknown_clippy_lints)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unknown_lints`\n \n error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n-  --> $DIR/rename.rs:65:9\n+  --> $DIR/rename.rs:66:9\n    |\n LL | #![warn(clippy::invalid_atomic_ordering)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n \n error: lint `clippy::mem_discriminant_non_enum` has been renamed to `enum_intrinsics_non_enums`\n-  --> $DIR/rename.rs:66:9\n+  --> $DIR/rename.rs:67:9\n    |\n LL | #![warn(clippy::mem_discriminant_non_enum)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `enum_intrinsics_non_enums`\n \n-error: aborting due to 32 previous errors\n+error: aborting due to 33 previous errors\n "}, {"sha": "767518ab0c0f5e1c345cd2acbee0921cefead3ee", "filename": "src/tools/clippy/tests/ui/search_is_some_fixable_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -189,7 +189,7 @@ mod issue7392 {\n         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_none();\n     }\n \n-    fn test_string_1(s: &String) -> bool {\n+    fn test_string_1(s: &str) -> bool {\n         s.is_empty()\n     }\n "}, {"sha": "933ce5cf42d2e227f7897e7ce576f38786880abf", "filename": "src/tools/clippy/tests/ui/search_is_some_fixable_none.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -251,14 +251,6 @@ error: called `is_none()` after searching an `Iterator` with `find`\n LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y)`\n \n-error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/search_is_some_fixable_none.rs:192:25\n-   |\n-LL |     fn test_string_1(s: &String) -> bool {\n-   |                         ^^^^^^^ help: change this to: `&str`\n-   |\n-   = note: `-D clippy::ptr-arg` implied by `-D warnings`\n-\n error: called `is_none()` after searching an `Iterator` with `find`\n   --> $DIR/search_is_some_fixable_none.rs:208:17\n    |\n@@ -289,5 +281,5 @@ error: called `is_none()` after searching an `Iterator` with `find`\n LL |         let _ = v.iter().find(|fp| test_u32_2(*fp.field)).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|fp| test_u32_2(*fp.field))`\n \n-error: aborting due to 44 previous errors\n+error: aborting due to 43 previous errors\n "}, {"sha": "77fd52e4ce7698402433df5715745557b28d187b", "filename": "src/tools/clippy/tests/ui/search_is_some_fixable_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -188,7 +188,7 @@ mod issue7392 {\n         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_some();\n     }\n \n-    fn test_string_1(s: &String) -> bool {\n+    fn test_string_1(s: &str) -> bool {\n         s.is_empty()\n     }\n "}, {"sha": "8b424f18ef5b50c60f10d3c69837d748a0778ff6", "filename": "src/tools/clippy/tests/ui/search_is_some_fixable_some.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -234,14 +234,6 @@ error: called `is_some()` after searching an `Iterator` with `find`\n LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_some();\n    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|(&x, y)| x == *y)`\n \n-error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/search_is_some_fixable_some.rs:191:25\n-   |\n-LL |     fn test_string_1(s: &String) -> bool {\n-   |                         ^^^^^^^ help: change this to: `&str`\n-   |\n-   = note: `-D clippy::ptr-arg` implied by `-D warnings`\n-\n error: called `is_some()` after searching an `Iterator` with `find`\n   --> $DIR/search_is_some_fixable_some.rs:207:26\n    |\n@@ -272,5 +264,5 @@ error: called `is_some()` after searching an `Iterator` with `find`\n LL |         let _ = v.iter().find(|fp| test_u32_2(*fp.field)).is_some();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|fp| test_u32_2(*fp.field))`\n \n-error: aborting due to 44 previous errors\n+error: aborting due to 43 previous errors\n "}, {"sha": "7e3d357ae50dc6e43bae367593e0e1f79fba4fd1", "filename": "src/tools/clippy/tests/ui/slow_vector_initialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fslow_vector_initialization.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -53,7 +53,7 @@ fn resize_vector() {\n     vec1.resize(10, 0);\n }\n \n-fn do_stuff(vec: &mut Vec<u8>) {}\n+fn do_stuff(vec: &mut [u8]) {}\n \n fn extend_vector_with_manipulations_between() {\n     let len = 300;"}, {"sha": "21de19a26014755f493dff4dbf1927798c78aa70", "filename": "src/tools/clippy/tests/ui/trait_duplication_in_bounds.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,5 +1,6 @@\n #![deny(clippy::trait_duplication_in_bounds)]\n \n+use std::collections::BTreeMap;\n use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n \n fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n@@ -73,4 +74,25 @@ impl U for Life {\n     fn f() {}\n }\n \n+// should not warn\n+trait Iter: Iterator {\n+    fn into_group_btreemap<K, V>(self) -> BTreeMap<K, Vec<V>>\n+    where\n+        Self: Iterator<Item = (K, V)> + Sized,\n+        K: Ord + Eq,\n+    {\n+        unimplemented!();\n+    }\n+}\n+\n+struct Foo {}\n+\n+trait FooIter: Iterator<Item = Foo> {\n+    fn bar()\n+    where\n+        Self: Iterator<Item = Foo>,\n+    {\n+    }\n+}\n+\n fn main() {}"}, {"sha": "6f8c8e47dfbf1fe56589a06f80017513e69167e8", "filename": "src/tools/clippy/tests/ui/trait_duplication_in_bounds.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,5 +1,5 @@\n error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:5:15\n+  --> $DIR/trait_duplication_in_bounds.rs:6:15\n    |\n LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n    |               ^^^^^\n@@ -12,52 +12,60 @@ LL | #![deny(clippy::trait_duplication_in_bounds)]\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:5:23\n+  --> $DIR/trait_duplication_in_bounds.rs:6:23\n    |\n LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n    |                       ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:34:15\n+  --> $DIR/trait_duplication_in_bounds.rs:35:15\n    |\n LL |         Self: Default;\n    |               ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:48:15\n+  --> $DIR/trait_duplication_in_bounds.rs:49:15\n    |\n LL |         Self: Default + Clone;\n    |               ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:54:15\n+  --> $DIR/trait_duplication_in_bounds.rs:55:15\n    |\n LL |         Self: Default + Clone;\n    |               ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:54:25\n+  --> $DIR/trait_duplication_in_bounds.rs:55:25\n    |\n LL |         Self: Default + Clone;\n    |                         ^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:57:15\n+  --> $DIR/trait_duplication_in_bounds.rs:58:15\n    |\n LL |         Self: Default;\n    |               ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n-error: aborting due to 7 previous errors\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds.rs:93:15\n+   |\n+LL |         Self: Iterator<Item = Foo>,\n+   |               ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "b77c19f2ba5961e30409af2c95dd9640978f9ba3", "filename": "src/tools/clippy/tests/ui/unnecessary_cast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,13 +1,20 @@\n #![warn(clippy::unnecessary_cast)]\n #![allow(clippy::no_effect)]\n \n+#[rustfmt::skip]\n fn main() {\n     // Test cast_unnecessary\n     1i32 as i32;\n     1f32 as f32;\n     false as bool;\n     &1i32 as &i32;\n \n+    -1_i32 as i32;\n+    - 1_i32 as i32;\n+    -1f32 as f32;\n+    1_i32 as i32;\n+    1_f32 as f32;\n+\n     // macro version\n     macro_rules! foo {\n         ($a:ident, $b:ident) => {"}, {"sha": "a5a93c6110c6a0233f7b8304ceaebb730f878b15", "filename": "src/tools/clippy/tests/ui/unnecessary_cast.stderr", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,22 +1,52 @@\n error: casting integer literal to `i32` is unnecessary\n-  --> $DIR/unnecessary_cast.rs:6:5\n+  --> $DIR/unnecessary_cast.rs:7:5\n    |\n LL |     1i32 as i32;\n    |     ^^^^^^^^^^^ help: try: `1_i32`\n    |\n    = note: `-D clippy::unnecessary-cast` implied by `-D warnings`\n \n error: casting float literal to `f32` is unnecessary\n-  --> $DIR/unnecessary_cast.rs:7:5\n+  --> $DIR/unnecessary_cast.rs:8:5\n    |\n LL |     1f32 as f32;\n    |     ^^^^^^^^^^^ help: try: `1_f32`\n \n error: casting to the same type is unnecessary (`bool` -> `bool`)\n-  --> $DIR/unnecessary_cast.rs:8:5\n+  --> $DIR/unnecessary_cast.rs:9:5\n    |\n LL |     false as bool;\n    |     ^^^^^^^^^^^^^ help: try: `false`\n \n-error: aborting due to 3 previous errors\n+error: casting integer literal to `i32` is unnecessary\n+  --> $DIR/unnecessary_cast.rs:12:5\n+   |\n+LL |     -1_i32 as i32;\n+   |     ^^^^^^^^^^^^^ help: try: `-1_i32`\n+\n+error: casting integer literal to `i32` is unnecessary\n+  --> $DIR/unnecessary_cast.rs:13:5\n+   |\n+LL |     - 1_i32 as i32;\n+   |     ^^^^^^^^^^^^^^ help: try: `- 1_i32`\n+\n+error: casting float literal to `f32` is unnecessary\n+  --> $DIR/unnecessary_cast.rs:14:5\n+   |\n+LL |     -1f32 as f32;\n+   |     ^^^^^^^^^^^^ help: try: `-1_f32`\n+\n+error: casting integer literal to `i32` is unnecessary\n+  --> $DIR/unnecessary_cast.rs:15:5\n+   |\n+LL |     1_i32 as i32;\n+   |     ^^^^^^^^^^^^ help: try: `1_i32`\n+\n+error: casting float literal to `f32` is unnecessary\n+  --> $DIR/unnecessary_cast.rs:16:5\n+   |\n+LL |     1_f32 as f32;\n+   |     ^^^^^^^^^^^^ help: try: `1_f32`\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "d927bae976f799e05c567c1e02467e813a563a1e", "filename": "src/tools/clippy/tests/ui/unnecessary_ref.fixed", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_ref.fixed?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -1,23 +0,0 @@\n-// run-rustfix\n-\n-#![feature(stmt_expr_attributes)]\n-#![allow(unused_variables, dead_code)]\n-\n-struct Outer {\n-    inner: u32,\n-}\n-\n-#[deny(clippy::ref_in_deref)]\n-fn main() {\n-    let outer = Outer { inner: 0 };\n-    let inner = outer.inner;\n-}\n-\n-struct Apple;\n-impl Apple {\n-    fn hello(&self) {}\n-}\n-struct Package(pub *const Apple);\n-fn foobar(package: *const Package) {\n-    unsafe { &*(*package).0 }.hello();\n-}"}, {"sha": "86bfb76ec26192a905dd9babc6349dcd2febca60", "filename": "src/tools/clippy/tests/ui/unnecessary_ref.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_ref.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -1,23 +0,0 @@\n-// run-rustfix\n-\n-#![feature(stmt_expr_attributes)]\n-#![allow(unused_variables, dead_code)]\n-\n-struct Outer {\n-    inner: u32,\n-}\n-\n-#[deny(clippy::ref_in_deref)]\n-fn main() {\n-    let outer = Outer { inner: 0 };\n-    let inner = (&outer).inner;\n-}\n-\n-struct Apple;\n-impl Apple {\n-    fn hello(&self) {}\n-}\n-struct Package(pub *const Apple);\n-fn foobar(package: *const Package) {\n-    unsafe { &*(&*package).0 }.hello();\n-}"}, {"sha": "436f4bcf7380465ac7c96598d38b8b759568126f", "filename": "src/tools/clippy/tests/ui/unnecessary_ref.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_ref.stderr?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -1,22 +0,0 @@\n-error: creating a reference that is immediately dereferenced\n-  --> $DIR/unnecessary_ref.rs:13:17\n-   |\n-LL |     let inner = (&outer).inner;\n-   |                 ^^^^^^^^ help: try this: `outer`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/unnecessary_ref.rs:10:8\n-   |\n-LL | #[deny(clippy::ref_in_deref)]\n-   |        ^^^^^^^^^^^^^^^^^^^^\n-\n-error: creating a reference that is immediately dereferenced\n-  --> $DIR/unnecessary_ref.rs:22:16\n-   |\n-LL |     unsafe { &*(&*package).0 }.hello();\n-   |                ^^^^^^^^^^^ help: try this: `(*package)`\n-   |\n-   = note: `-D clippy::ref-in-deref` implied by `-D warnings`\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "e431661d180deb443298780b3445becb2bd1fd2e", "filename": "src/tools/clippy/tests/ui/useless_asref.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -67,7 +67,7 @@ fn not_ok() {\n         foo_rslice(mrrrrrslice);\n         foo_rslice(mrrrrrslice);\n     }\n-    #[allow(unused_parens, clippy::double_parens)]\n+    #[allow(unused_parens, clippy::double_parens, clippy::needless_borrow)]\n     foo_rrrrmr((&&&&MoreRef));\n \n     generic_not_ok(mrslice);"}, {"sha": "6ae931d7aa4812097f77622589501baaaf846b92", "filename": "src/tools/clippy/tests/ui/useless_asref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -67,7 +67,7 @@ fn not_ok() {\n         foo_rslice(mrrrrrslice.as_ref());\n         foo_rslice(mrrrrrslice);\n     }\n-    #[allow(unused_parens, clippy::double_parens)]\n+    #[allow(unused_parens, clippy::double_parens, clippy::needless_borrow)]\n     foo_rrrrmr((&&&&MoreRef).as_ref());\n \n     generic_not_ok(mrslice);"}, {"sha": "4466917441162f49b14ae65722cac9f1a7ae6378", "filename": "src/tools/clippy/tests/ui/write_literal.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -7,37 +7,37 @@ fn main() {\n     let mut v = Vec::new();\n \n     // these should be fine\n-    write!(&mut v, \"Hello\");\n-    writeln!(&mut v, \"Hello\");\n+    write!(v, \"Hello\");\n+    writeln!(v, \"Hello\");\n     let world = \"world\";\n-    writeln!(&mut v, \"Hello {}\", world);\n-    writeln!(&mut v, \"Hello {world}\", world = world);\n-    writeln!(&mut v, \"3 in hex is {:X}\", 3);\n-    writeln!(&mut v, \"2 + 1 = {:.4}\", 3);\n-    writeln!(&mut v, \"2 + 1 = {:5.4}\", 3);\n-    writeln!(&mut v, \"Debug test {:?}\", \"hello, world\");\n-    writeln!(&mut v, \"{0:8} {1:>8}\", \"hello\", \"world\");\n-    writeln!(&mut v, \"{1:8} {0:>8}\", \"hello\", \"world\");\n-    writeln!(&mut v, \"{foo:8} {bar:>8}\", foo = \"hello\", bar = \"world\");\n-    writeln!(&mut v, \"{bar:8} {foo:>8}\", foo = \"hello\", bar = \"world\");\n-    writeln!(&mut v, \"{number:>width$}\", number = 1, width = 6);\n-    writeln!(&mut v, \"{number:>0width$}\", number = 1, width = 6);\n-    writeln!(&mut v, \"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n-    writeln!(&mut v, \"10 / 4 is {}\", 2.5);\n-    writeln!(&mut v, \"2 + 1 = {}\", 3);\n+    writeln!(v, \"Hello {}\", world);\n+    writeln!(v, \"Hello {world}\", world = world);\n+    writeln!(v, \"3 in hex is {:X}\", 3);\n+    writeln!(v, \"2 + 1 = {:.4}\", 3);\n+    writeln!(v, \"2 + 1 = {:5.4}\", 3);\n+    writeln!(v, \"Debug test {:?}\", \"hello, world\");\n+    writeln!(v, \"{0:8} {1:>8}\", \"hello\", \"world\");\n+    writeln!(v, \"{1:8} {0:>8}\", \"hello\", \"world\");\n+    writeln!(v, \"{foo:8} {bar:>8}\", foo = \"hello\", bar = \"world\");\n+    writeln!(v, \"{bar:8} {foo:>8}\", foo = \"hello\", bar = \"world\");\n+    writeln!(v, \"{number:>width$}\", number = 1, width = 6);\n+    writeln!(v, \"{number:>0width$}\", number = 1, width = 6);\n+    writeln!(v, \"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n+    writeln!(v, \"10 / 4 is {}\", 2.5);\n+    writeln!(v, \"2 + 1 = {}\", 3);\n \n     // these should throw warnings\n-    write!(&mut v, \"Hello {}\", \"world\");\n-    writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n-    writeln!(&mut v, \"Hello {}\", \"world\");\n+    write!(v, \"Hello {}\", \"world\");\n+    writeln!(v, \"Hello {} {}\", world, \"world\");\n+    writeln!(v, \"Hello {}\", \"world\");\n \n     // positional args don't change the fact\n     // that we're using a literal -- this should\n     // throw a warning\n-    writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-    writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n+    writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+    writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n \n     // named args shouldn't change anything either\n-    writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-    writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+    writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+    writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n }"}, {"sha": "593e9493ec5904edacfc7eafd6277121141ac6a8", "filename": "src/tools/clippy/tests/ui/write_literal.stderr", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,134 +1,134 @@\n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:30:32\n+  --> $DIR/write_literal.rs:30:27\n    |\n-LL |     write!(&mut v, \"Hello {}\", \"world\");\n-   |                                ^^^^^^^\n+LL |     write!(v, \"Hello {}\", \"world\");\n+   |                           ^^^^^^^\n    |\n    = note: `-D clippy::write-literal` implied by `-D warnings`\n help: try this\n    |\n-LL -     write!(&mut v, \"Hello {}\", \"world\");\n-LL +     write!(&mut v, \"Hello world\");\n+LL -     write!(v, \"Hello {}\", \"world\");\n+LL +     write!(v, \"Hello world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:31:44\n+  --> $DIR/write_literal.rs:31:39\n    |\n-LL |     writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n-   |                                            ^^^^^^^\n+LL |     writeln!(v, \"Hello {} {}\", world, \"world\");\n+   |                                       ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n-LL +     writeln!(&mut v, \"Hello {} world\", world);\n+LL -     writeln!(v, \"Hello {} {}\", world, \"world\");\n+LL +     writeln!(v, \"Hello {} world\", world);\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:32:34\n+  --> $DIR/write_literal.rs:32:29\n    |\n-LL |     writeln!(&mut v, \"Hello {}\", \"world\");\n-   |                                  ^^^^^^^\n+LL |     writeln!(v, \"Hello {}\", \"world\");\n+   |                             ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"Hello {}\", \"world\");\n-LL +     writeln!(&mut v, \"Hello world\");\n+LL -     writeln!(v, \"Hello {}\", \"world\");\n+LL +     writeln!(v, \"Hello world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:37:33\n+  --> $DIR/write_literal.rs:37:28\n    |\n-LL |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-   |                                 ^^^^^^^\n+LL |     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+   |                            ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-LL +     writeln!(&mut v, \"hello {1}\", \"world\");\n+LL -     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+LL +     writeln!(v, \"hello {1}\", \"world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:37:42\n+  --> $DIR/write_literal.rs:37:37\n    |\n-LL |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-   |                                          ^^^^^^^\n+LL |     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+   |                                     ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-LL +     writeln!(&mut v, \"{0} world\", \"hello\");\n+LL -     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+LL +     writeln!(v, \"{0} world\", \"hello\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:38:33\n+  --> $DIR/write_literal.rs:38:28\n    |\n-LL |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n-   |                                 ^^^^^^^\n+LL |     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n+   |                            ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n-LL +     writeln!(&mut v, \"{1} hello\", \"world\");\n+LL -     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n+LL +     writeln!(v, \"{1} hello\", \"world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:38:42\n+  --> $DIR/write_literal.rs:38:37\n    |\n-LL |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n-   |                                          ^^^^^^^\n+LL |     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n+   |                                     ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n-LL +     writeln!(&mut v, \"world {0}\", \"hello\");\n+LL -     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n+LL +     writeln!(v, \"world {0}\", \"hello\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:41:37\n+  --> $DIR/write_literal.rs:41:32\n    |\n-LL |     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                     ^^^^^^^^^^^^^\n+LL |     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+   |                                ^^^^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(&mut v, \"hello {bar}\", bar = \"world\");\n+LL -     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+LL +     writeln!(v, \"hello {bar}\", bar = \"world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:41:52\n+  --> $DIR/write_literal.rs:41:47\n    |\n-LL |     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                                    ^^^^^^^^^^^^^\n+LL |     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+   |                                               ^^^^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(&mut v, \"{foo} world\", foo = \"hello\");\n+LL -     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+LL +     writeln!(v, \"{foo} world\", foo = \"hello\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:42:37\n+  --> $DIR/write_literal.rs:42:32\n    |\n-LL |     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                     ^^^^^^^^^^^^^\n+LL |     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+   |                                ^^^^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(&mut v, \"{bar} hello\", bar = \"world\");\n+LL -     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+LL +     writeln!(v, \"{bar} hello\", bar = \"world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:42:52\n+  --> $DIR/write_literal.rs:42:47\n    |\n-LL |     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                                    ^^^^^^^^^^^^^\n+LL |     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+   |                                               ^^^^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(&mut v, \"world {foo}\", foo = \"hello\");\n+LL -     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+LL +     writeln!(v, \"world {foo}\", foo = \"hello\");\n    | \n \n error: aborting due to 11 previous errors"}, {"sha": "ba0d7be5eaa68dfe5234f0499db72cc8d759af99", "filename": "src/tools/clippy/tests/ui/write_literal_2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal_2.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -6,20 +6,20 @@ use std::io::Write;\n fn main() {\n     let mut v = Vec::new();\n \n-    writeln!(&mut v, \"{}\", \"{hello}\");\n-    writeln!(&mut v, r\"{}\", r\"{hello}\");\n-    writeln!(&mut v, \"{}\", '\\'');\n-    writeln!(&mut v, \"{}\", '\"');\n-    writeln!(&mut v, r\"{}\", '\"'); // don't lint\n-    writeln!(&mut v, r\"{}\", '\\'');\n+    writeln!(v, \"{}\", \"{hello}\");\n+    writeln!(v, r\"{}\", r\"{hello}\");\n+    writeln!(v, \"{}\", '\\'');\n+    writeln!(v, \"{}\", '\"');\n+    writeln!(v, r\"{}\", '\"'); // don't lint\n+    writeln!(v, r\"{}\", '\\'');\n     writeln!(\n-        &mut v,\n+        v,\n         \"some {}\",\n         \"hello \\\n         world!\"\n     );\n     writeln!(\n-        &mut v,\n+        v,\n         \"some {}\\\n         {} \\\\ {}\",\n         \"1\", \"2\", \"3\","}, {"sha": "fc40fbfa9e239b7ab02eed9b3d372484647a67cb", "filename": "src/tools/clippy/tests/ui/write_literal_2.stderr", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_literal_2.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,62 +1,62 @@\n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:9:28\n+  --> $DIR/write_literal_2.rs:9:23\n    |\n-LL |     writeln!(&mut v, \"{}\", \"{hello}\");\n-   |                            ^^^^^^^^^\n+LL |     writeln!(v, \"{}\", \"{hello}\");\n+   |                       ^^^^^^^^^\n    |\n    = note: `-D clippy::write-literal` implied by `-D warnings`\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{}\", \"{hello}\");\n-LL +     writeln!(&mut v, \"{{hello}}\");\n+LL -     writeln!(v, \"{}\", \"{hello}\");\n+LL +     writeln!(v, \"{{hello}}\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:10:29\n+  --> $DIR/write_literal_2.rs:10:24\n    |\n-LL |     writeln!(&mut v, r\"{}\", r\"{hello}\");\n-   |                             ^^^^^^^^^^\n+LL |     writeln!(v, r\"{}\", r\"{hello}\");\n+   |                        ^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, r\"{}\", r\"{hello}\");\n-LL +     writeln!(&mut v, r\"{{hello}}\");\n+LL -     writeln!(v, r\"{}\", r\"{hello}\");\n+LL +     writeln!(v, r\"{{hello}}\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:11:28\n+  --> $DIR/write_literal_2.rs:11:23\n    |\n-LL |     writeln!(&mut v, \"{}\", '/'');\n-   |                            ^^^^\n+LL |     writeln!(v, \"{}\", '/'');\n+   |                       ^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{}\", '/'');\n-LL +     writeln!(&mut v, \"'\");\n+LL -     writeln!(v, \"{}\", '/'');\n+LL +     writeln!(v, \"'\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:12:28\n+  --> $DIR/write_literal_2.rs:12:23\n    |\n-LL |     writeln!(&mut v, \"{}\", '\"');\n-   |                            ^^^\n+LL |     writeln!(v, \"{}\", '\"');\n+   |                       ^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{}\", '\"');\n-LL +     writeln!(&mut v, \"/\"\");\n+LL -     writeln!(v, \"{}\", '\"');\n+LL +     writeln!(v, \"/\"\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:14:29\n+  --> $DIR/write_literal_2.rs:14:24\n    |\n-LL |     writeln!(&mut v, r\"{}\", '/'');\n-   |                             ^^^^\n+LL |     writeln!(v, r\"{}\", '/'');\n+   |                        ^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, r\"{}\", '/'');\n-LL +     writeln!(&mut v, r\"'\");\n+LL -     writeln!(v, r\"{}\", '/'');\n+LL +     writeln!(v, r\"'\");\n    | \n \n error: literal with an empty format string"}, {"sha": "446d6914d3461205a185daf7f71f6fabf399e3c7", "filename": "src/tools/clippy/tests/ui/write_with_newline.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_with_newline.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -10,50 +10,50 @@ fn main() {\n     let mut v = Vec::new();\n \n     // These should fail\n-    write!(&mut v, \"Hello\\n\");\n-    write!(&mut v, \"Hello {}\\n\", \"world\");\n-    write!(&mut v, \"Hello {} {}\\n\", \"world\", \"#2\");\n-    write!(&mut v, \"{}\\n\", 1265);\n-    write!(&mut v, \"\\n\");\n+    write!(v, \"Hello\\n\");\n+    write!(v, \"Hello {}\\n\", \"world\");\n+    write!(v, \"Hello {} {}\\n\", \"world\", \"#2\");\n+    write!(v, \"{}\\n\", 1265);\n+    write!(v, \"\\n\");\n \n     // These should be fine\n-    write!(&mut v, \"\");\n-    write!(&mut v, \"Hello\");\n-    writeln!(&mut v, \"Hello\");\n-    writeln!(&mut v, \"Hello\\n\");\n-    writeln!(&mut v, \"Hello {}\\n\", \"world\");\n-    write!(&mut v, \"Issue\\n{}\", 1265);\n-    write!(&mut v, \"{}\", 1265);\n-    write!(&mut v, \"\\n{}\", 1275);\n-    write!(&mut v, \"\\n\\n\");\n-    write!(&mut v, \"like eof\\n\\n\");\n-    write!(&mut v, \"Hello {} {}\\n\\n\", \"world\", \"#2\");\n-    writeln!(&mut v, \"\\ndon't\\nwarn\\nfor\\nmultiple\\nnewlines\\n\"); // #3126\n-    writeln!(&mut v, \"\\nbla\\n\\n\"); // #3126\n+    write!(v, \"\");\n+    write!(v, \"Hello\");\n+    writeln!(v, \"Hello\");\n+    writeln!(v, \"Hello\\n\");\n+    writeln!(v, \"Hello {}\\n\", \"world\");\n+    write!(v, \"Issue\\n{}\", 1265);\n+    write!(v, \"{}\", 1265);\n+    write!(v, \"\\n{}\", 1275);\n+    write!(v, \"\\n\\n\");\n+    write!(v, \"like eof\\n\\n\");\n+    write!(v, \"Hello {} {}\\n\\n\", \"world\", \"#2\");\n+    writeln!(v, \"\\ndon't\\nwarn\\nfor\\nmultiple\\nnewlines\\n\"); // #3126\n+    writeln!(v, \"\\nbla\\n\\n\"); // #3126\n \n     // Escaping\n-    write!(&mut v, \"\\\\n\"); // #3514\n-    write!(&mut v, \"\\\\\\n\"); // should fail\n-    write!(&mut v, \"\\\\\\\\n\");\n+    write!(v, \"\\\\n\"); // #3514\n+    write!(v, \"\\\\\\n\"); // should fail\n+    write!(v, \"\\\\\\\\n\");\n \n     // Raw strings\n-    write!(&mut v, r\"\\n\"); // #3778\n+    write!(v, r\"\\n\"); // #3778\n \n     // Literal newlines should also fail\n     write!(\n-        &mut v,\n+        v,\n         \"\n \"\n     );\n     write!(\n-        &mut v,\n+        v,\n         r\"\n \"\n     );\n \n     // Don't warn on CRLF (#4208)\n-    write!(&mut v, \"\\r\\n\");\n-    write!(&mut v, \"foo\\r\\n\");\n-    write!(&mut v, \"\\\\r\\n\"); //~ ERROR\n-    write!(&mut v, \"foo\\rbar\\n\");\n+    write!(v, \"\\r\\n\");\n+    write!(v, \"foo\\r\\n\");\n+    write!(v, \"\\\\r\\n\"); //~ ERROR\n+    write!(v, \"foo\\rbar\\n\");\n }"}, {"sha": "3314a2a6e242089ff826a4d412cff4185f0e2311", "filename": "src/tools/clippy/tests/ui/write_with_newline.stderr", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrite_with_newline.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,81 +1,81 @@\n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:13:5\n    |\n-LL |     write!(&mut v, \"Hello/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"Hello/n\");\n+   |     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::write-with-newline` implied by `-D warnings`\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"Hello/n\");\n-LL +     writeln!(&mut v, \"Hello\");\n+LL -     write!(v, \"Hello/n\");\n+LL +     writeln!(v, \"Hello\");\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:14:5\n    |\n-LL |     write!(&mut v, \"Hello {}/n\", \"world\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"Hello {}/n\", \"world\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"Hello {}/n\", \"world\");\n-LL +     writeln!(&mut v, \"Hello {}\", \"world\");\n+LL -     write!(v, \"Hello {}/n\", \"world\");\n+LL +     writeln!(v, \"Hello {}\", \"world\");\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:15:5\n    |\n-LL |     write!(&mut v, \"Hello {} {}/n\", \"world\", \"#2\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"Hello {} {}/n\", \"world\", \"#2\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"Hello {} {}/n\", \"world\", \"#2\");\n-LL +     writeln!(&mut v, \"Hello {} {}\", \"world\", \"#2\");\n+LL -     write!(v, \"Hello {} {}/n\", \"world\", \"#2\");\n+LL +     writeln!(v, \"Hello {} {}\", \"world\", \"#2\");\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:16:5\n    |\n-LL |     write!(&mut v, \"{}/n\", 1265);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"{}/n\", 1265);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"{}/n\", 1265);\n-LL +     writeln!(&mut v, \"{}\", 1265);\n+LL -     write!(v, \"{}/n\", 1265);\n+LL +     writeln!(v, \"{}\", 1265);\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:17:5\n    |\n-LL |     write!(&mut v, \"/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"/n\");\n+   |     ^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"/n\");\n-LL +     writeln!(&mut v);\n+LL -     write!(v, \"/n\");\n+LL +     writeln!(v);\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:36:5\n    |\n-LL |     write!(&mut v, \"//n\"); // should fail\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"//n\"); // should fail\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"//n\"); // should fail\n-LL +     writeln!(&mut v, \"/\"); // should fail\n+LL -     write!(v, \"//n\"); // should fail\n+LL +     writeln!(v, \"/\"); // should fail\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:43:5\n    |\n LL | /     write!(\n-LL | |         &mut v,\n+LL | |         v,\n LL | |         \"\n LL | | \"\n LL | |     );\n@@ -84,15 +84,15 @@ LL | |     );\n help: use `writeln!()` instead\n    |\n LL ~     writeln!(\n-LL |         &mut v,\n+LL |         v,\n LL ~         \"\"\n    |\n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:48:5\n    |\n LL | /     write!(\n-LL | |         &mut v,\n+LL | |         v,\n LL | |         r\"\n LL | | \"\n LL | |     );\n@@ -101,32 +101,32 @@ LL | |     );\n help: use `writeln!()` instead\n    |\n LL ~     writeln!(\n-LL |         &mut v,\n+LL |         v,\n LL ~         r\"\"\n    |\n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:57:5\n    |\n-LL |     write!(&mut v, \"/r/n\"); //~ ERROR\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"/r/n\"); //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"/r/n\"); //~ ERROR\n-LL +     writeln!(&mut v, \"/r\"); //~ ERROR\n+LL -     write!(v, \"/r/n\"); //~ ERROR\n+LL +     writeln!(v, \"/r\"); //~ ERROR\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:58:5\n    |\n-LL |     write!(&mut v, \"foo/rbar/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"foo/rbar/n\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"foo/rbar/n\");\n-LL +     writeln!(&mut v, \"foo/rbar\");\n+LL -     write!(v, \"foo/rbar/n\");\n+LL +     writeln!(v, \"foo/rbar\");\n    | \n \n error: aborting due to 10 previous errors"}, {"sha": "e7d94acd130d67b2877a6bf45c4a9b2351785bbf", "filename": "src/tools/clippy/tests/ui/writeln_empty_string.fixed", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwriteln_empty_string.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwriteln_empty_string.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwriteln_empty_string.fixed?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -8,13 +8,13 @@ fn main() {\n     let mut v = Vec::new();\n \n     // These should fail\n-    writeln!(&mut v);\n+    writeln!(v);\n \n     let mut suggestion = Vec::new();\n-    writeln!(&mut suggestion);\n+    writeln!(suggestion);\n \n     // These should be fine\n-    writeln!(&mut v);\n-    writeln!(&mut v, \" \");\n-    write!(&mut v, \"\");\n+    writeln!(v);\n+    writeln!(v, \" \");\n+    write!(v, \"\");\n }"}, {"sha": "662c62f02116e64d4a21213bface9d73b8bb11d4", "filename": "src/tools/clippy/tests/ui/writeln_empty_string.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwriteln_empty_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwriteln_empty_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwriteln_empty_string.rs?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -8,13 +8,13 @@ fn main() {\n     let mut v = Vec::new();\n \n     // These should fail\n-    writeln!(&mut v, \"\");\n+    writeln!(v, \"\");\n \n     let mut suggestion = Vec::new();\n-    writeln!(&mut suggestion, \"\");\n+    writeln!(suggestion, \"\");\n \n     // These should be fine\n-    writeln!(&mut v);\n-    writeln!(&mut v, \" \");\n-    write!(&mut v, \"\");\n+    writeln!(v);\n+    writeln!(v, \" \");\n+    write!(v, \"\");\n }"}, {"sha": "ac65aadfc0e8926f4cf5d04dcde1f0906d5672e9", "filename": "src/tools/clippy/tests/ui/writeln_empty_string.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwriteln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwriteln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwriteln_empty_string.stderr?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -1,16 +1,16 @@\n-error: using `writeln!(&mut v, \"\")`\n+error: using `writeln!(v, \"\")`\n   --> $DIR/writeln_empty_string.rs:11:5\n    |\n-LL |     writeln!(&mut v, \"\");\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(&mut v)`\n+LL |     writeln!(v, \"\");\n+   |     ^^^^^^^^^^^^^^^ help: replace it with: `writeln!(v)`\n    |\n    = note: `-D clippy::writeln-empty-string` implied by `-D warnings`\n \n-error: using `writeln!(&mut suggestion, \"\")`\n+error: using `writeln!(suggestion, \"\")`\n   --> $DIR/writeln_empty_string.rs:14:5\n    |\n-LL |     writeln!(&mut suggestion, \"\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(&mut suggestion)`\n+LL |     writeln!(suggestion, \"\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(suggestion)`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "83a200ca3c4f4d112999c1bf3ddfd9d40ebd6299", "filename": "src/tools/clippy/util/gh-pages/index.html", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/5ab502c6d308b0ccac8127c0464e432334755a60/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html?ref=5ab502c6d308b0ccac8127c0464e432334755a60", "patch": "@@ -522,6 +522,11 @@ <h2 class=\"panel-title\">\n                 }\n \n                 scrollToLintByURL($scope);\n+\n+                setTimeout(function () {\n+                    var el = document.getElementById('filter-input');\n+                    if (el) { el.focus() }\n+                }, 0);\n             })\n             .error(function (data) {\n                 $scope.error = data;"}]}