{"sha": "18c275b423f9f13c0e404ae3804967d2ab66337c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YzI3NWI0MjNmOWYxM2MwZTQwNGFlMzgwNDk2N2QyYWI2NjMzN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-02T12:48:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-02T12:48:26Z"}, "message": "Auto merge of #69635 - Dylan-DPC:rollup-2oh8uu5, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #68682 (Add documentation to compiler intrinsics)\n - #69544 (Unrevert \"Remove `checked_add` in `Layout::repeat`\")\n - #69617 (constify mem::forget)\n - #69622 (Rename `syntax` in librustc_ast/README.md)\n - #69623 (stash API: remove panic to fix ICE.)\n - #69624 (Toolstate: Don't block beta week on already broken tools.)\n\nFailed merges:\n\n - #69626 (Toolstate: don't duplicate nightly tool list.)\n\nr? @ghost", "tree": {"sha": "b034b874143aa0ce0aaf9329c2cc25fdbf0daf92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b034b874143aa0ce0aaf9329c2cc25fdbf0daf92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18c275b423f9f13c0e404ae3804967d2ab66337c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18c275b423f9f13c0e404ae3804967d2ab66337c", "html_url": "https://github.com/rust-lang/rust/commit/18c275b423f9f13c0e404ae3804967d2ab66337c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18c275b423f9f13c0e404ae3804967d2ab66337c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c839a7b4c26e58319b0c40448dd423facff34cd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c839a7b4c26e58319b0c40448dd423facff34cd0", "html_url": "https://github.com/rust-lang/rust/commit/c839a7b4c26e58319b0c40448dd423facff34cd0"}, {"sha": "f8fb3efe6f072f17807967006d91e256d8fbad63", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8fb3efe6f072f17807967006d91e256d8fbad63", "html_url": "https://github.com/rust-lang/rust/commit/f8fb3efe6f072f17807967006d91e256d8fbad63"}], "stats": {"total": 783, "additions": 688, "deletions": 95}, "files": [{"sha": "5c39f5d5bc3efe163826b7c88e2d0c4bf13d3316", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 133, "deletions": 63, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -6,7 +6,7 @@ use std::env;\n use std::fmt;\n use std::fs;\n use std::io::{Seek, SeekFrom};\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time;\n \n@@ -24,7 +24,7 @@ const OS: Option<&str> = None;\n \n type ToolstateData = HashMap<Box<str>, ToolState>;\n \n-#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq, PartialOrd)]\n #[serde(rename_all = \"kebab-case\")]\n /// Whether a tool can be compiled, tested or neither\n pub enum ToolState {\n@@ -143,10 +143,31 @@ pub struct ToolStateCheck;\n impl Step for ToolStateCheck {\n     type Output = ();\n \n-    /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n+    /// Checks tool state status.\n     ///\n-    /// This tool in `src/tools` will verify the validity of all our links in the\n-    /// documentation to ensure we don't have a bunch of dead ones.\n+    /// This is intended to be used in the `checktools.sh` script. To use\n+    /// this, set `save-toolstates` in `config.toml` so that tool status will\n+    /// be saved to a JSON file. Then, run `x.py test --no-fail-fast` for all\n+    /// of the tools to populate the JSON file. After that is done, this\n+    /// command can be run to check for any status failures, and exits with an\n+    /// error if there are any.\n+    ///\n+    /// This also handles publishing the results to the `history` directory of\n+    /// the toolstate repo https://github.com/rust-lang-nursery/rust-toolstate\n+    /// if the env var `TOOLSTATE_PUBLISH` is set. Note that there is a\n+    /// *separate* step of updating the `latest.json` file and creating GitHub\n+    /// issues and comments in `src/ci/publish_toolstate.sh`, which is only\n+    /// performed on master. (The shell/python code is intended to be migrated\n+    /// here eventually.)\n+    ///\n+    /// The rules for failure are:\n+    /// * If the PR modifies a tool, the status must be test-pass.\n+    ///   NOTE: There is intent to change this, see\n+    ///   https://github.com/rust-lang/rust/issues/65000.\n+    /// * All \"stable\" tools must be test-pass on the stable or beta branches.\n+    /// * During beta promotion week, a PR is not allowed to \"regress\" a\n+    ///   stable tool. That is, the status is not allowed to get worse\n+    ///   (test-pass to test-fail or build-fail).\n     fn run(self, builder: &Builder<'_>) {\n         if builder.config.dry_run {\n             return;\n@@ -171,6 +192,8 @@ impl Step for ToolStateCheck {\n         }\n \n         check_changed_files(&toolstates);\n+        checkout_toolstate_repo();\n+        let old_toolstate = read_old_toolstate();\n \n         for (tool, _) in STABLE_TOOLS.iter() {\n             let state = toolstates[*tool];\n@@ -180,11 +203,24 @@ impl Step for ToolStateCheck {\n                     did_error = true;\n                     eprintln!(\"error: Tool `{}` should be test-pass but is {}\", tool, state);\n                 } else if in_beta_week {\n-                    did_error = true;\n-                    eprintln!(\n-                        \"error: Tool `{}` should be test-pass but is {} during beta week.\",\n-                        tool, state\n-                    );\n+                    let old_state = old_toolstate\n+                        .iter()\n+                        .find(|ts| ts.tool == *tool)\n+                        .expect(\"latest.json missing tool\")\n+                        .state();\n+                    if state < old_state {\n+                        did_error = true;\n+                        eprintln!(\n+                            \"error: Tool `{}` has regressed from {} to {} during beta week.\",\n+                            tool, old_state, state\n+                        );\n+                    } else {\n+                        eprintln!(\n+                            \"warning: Tool `{}` is not test-pass (is `{}`), \\\n+                            this should be fixed before beta is branched.\",\n+                            tool, state\n+                        );\n+                    }\n                 }\n             }\n         }\n@@ -247,6 +283,70 @@ impl Builder<'_> {\n     }\n }\n \n+fn toolstate_repo() -> String {\n+    env::var(\"TOOLSTATE_REPO\")\n+        .unwrap_or_else(|_| \"https://github.com/rust-lang-nursery/rust-toolstate.git\".to_string())\n+}\n+\n+/// Directory where the toolstate repo is checked out.\n+const TOOLSTATE_DIR: &str = \"rust-toolstate\";\n+\n+/// Checks out the toolstate repo into `TOOLSTATE_DIR`.\n+fn checkout_toolstate_repo() {\n+    if let Ok(token) = env::var(\"TOOLSTATE_REPO_ACCESS_TOKEN\") {\n+        prepare_toolstate_config(&token);\n+    }\n+    if Path::new(TOOLSTATE_DIR).exists() {\n+        eprintln!(\"Cleaning old toolstate directory...\");\n+        t!(fs::remove_dir_all(TOOLSTATE_DIR));\n+    }\n+\n+    let status = Command::new(\"git\")\n+        .arg(\"clone\")\n+        .arg(\"--depth=1\")\n+        .arg(toolstate_repo())\n+        .arg(TOOLSTATE_DIR)\n+        .status();\n+    let success = match status {\n+        Ok(s) => s.success(),\n+        Err(_) => false,\n+    };\n+    if !success {\n+        panic!(\"git clone unsuccessful (status: {:?})\", status);\n+    }\n+}\n+\n+/// Sets up config and authentication for modifying the toolstate repo.\n+fn prepare_toolstate_config(token: &str) {\n+    fn git_config(key: &str, value: &str) {\n+        let status = Command::new(\"git\").arg(\"config\").arg(\"--global\").arg(key).arg(value).status();\n+        let success = match status {\n+            Ok(s) => s.success(),\n+            Err(_) => false,\n+        };\n+        if !success {\n+            panic!(\"git config key={} value={} successful (status: {:?})\", key, value, status);\n+        }\n+    }\n+\n+    // If changing anything here, then please check that src/ci/publish_toolstate.sh is up to date\n+    // as well.\n+    git_config(\"user.email\", \"7378925+rust-toolstate-update@users.noreply.github.com\");\n+    git_config(\"user.name\", \"Rust Toolstate Update\");\n+    git_config(\"credential.helper\", \"store\");\n+\n+    let credential = format!(\"https://{}:x-oauth-basic@github.com\\n\", token,);\n+    let git_credential_path = PathBuf::from(t!(env::var(\"HOME\"))).join(\".git-credentials\");\n+    t!(fs::write(&git_credential_path, credential));\n+}\n+\n+/// Reads the latest toolstate from the toolstate repo.\n+fn read_old_toolstate() -> Vec<RepoState> {\n+    let latest_path = Path::new(TOOLSTATE_DIR).join(\"_data\").join(\"latest.json\");\n+    let old_toolstate = t!(fs::read(latest_path));\n+    t!(serde_json::from_slice(&old_toolstate))\n+}\n+\n /// This function `commit_toolstate_change` provides functionality for pushing a change\n /// to the `rust-toolstate` repository.\n ///\n@@ -274,45 +374,7 @@ impl Builder<'_> {\n ///       * See <https://help.github.com/articles/about-commit-email-addresses/>\n ///           if a private email by GitHub is wanted.\n fn commit_toolstate_change(current_toolstate: &ToolstateData, in_beta_week: bool) {\n-    fn git_config(key: &str, value: &str) {\n-        let status = Command::new(\"git\").arg(\"config\").arg(\"--global\").arg(key).arg(value).status();\n-        let success = match status {\n-            Ok(s) => s.success(),\n-            Err(_) => false,\n-        };\n-        if !success {\n-            panic!(\"git config key={} value={} successful (status: {:?})\", key, value, status);\n-        }\n-    }\n-\n-    // If changing anything here, then please check that src/ci/publish_toolstate.sh is up to date\n-    // as well.\n-    git_config(\"user.email\", \"7378925+rust-toolstate-update@users.noreply.github.com\");\n-    git_config(\"user.name\", \"Rust Toolstate Update\");\n-    git_config(\"credential.helper\", \"store\");\n-\n-    let credential = format!(\n-        \"https://{}:x-oauth-basic@github.com\\n\",\n-        t!(env::var(\"TOOLSTATE_REPO_ACCESS_TOKEN\")),\n-    );\n-    let git_credential_path = PathBuf::from(t!(env::var(\"HOME\"))).join(\".git-credentials\");\n-    t!(fs::write(&git_credential_path, credential));\n-\n-    let status = Command::new(\"git\")\n-        .arg(\"clone\")\n-        .arg(\"--depth=1\")\n-        .arg(t!(env::var(\"TOOLSTATE_REPO\")))\n-        .status();\n-    let success = match status {\n-        Ok(s) => s.success(),\n-        Err(_) => false,\n-    };\n-    if !success {\n-        panic!(\"git clone successful (status: {:?})\", status);\n-    }\n-\n-    let old_toolstate = t!(fs::read(\"rust-toolstate/_data/latest.json\"));\n-    let old_toolstate: Vec<RepoState> = t!(serde_json::from_slice(&old_toolstate));\n+    let old_toolstate = read_old_toolstate();\n \n     let message = format!(\"({} CI update)\", OS.expect(\"linux/windows only\"));\n     let mut success = false;\n@@ -322,7 +384,7 @@ fn commit_toolstate_change(current_toolstate: &ToolstateData, in_beta_week: bool\n \n         // `git commit` failing means nothing to commit.\n         let status = t!(Command::new(\"git\")\n-            .current_dir(\"rust-toolstate\")\n+            .current_dir(TOOLSTATE_DIR)\n             .arg(\"commit\")\n             .arg(\"-a\")\n             .arg(\"-m\")\n@@ -334,7 +396,7 @@ fn commit_toolstate_change(current_toolstate: &ToolstateData, in_beta_week: bool\n         }\n \n         let status = t!(Command::new(\"git\")\n-            .current_dir(\"rust-toolstate\")\n+            .current_dir(TOOLSTATE_DIR)\n             .arg(\"push\")\n             .arg(\"origin\")\n             .arg(\"master\")\n@@ -347,14 +409,14 @@ fn commit_toolstate_change(current_toolstate: &ToolstateData, in_beta_week: bool\n         eprintln!(\"Sleeping for 3 seconds before retrying push\");\n         std::thread::sleep(std::time::Duration::from_secs(3));\n         let status = t!(Command::new(\"git\")\n-            .current_dir(\"rust-toolstate\")\n+            .current_dir(TOOLSTATE_DIR)\n             .arg(\"fetch\")\n             .arg(\"origin\")\n             .arg(\"master\")\n             .status());\n         assert!(status.success());\n         let status = t!(Command::new(\"git\")\n-            .current_dir(\"rust-toolstate\")\n+            .current_dir(TOOLSTATE_DIR)\n             .arg(\"reset\")\n             .arg(\"--hard\")\n             .arg(\"origin/master\")\n@@ -375,18 +437,12 @@ fn change_toolstate(\n     let mut regressed = false;\n     for repo_state in old_toolstate {\n         let tool = &repo_state.tool;\n-        let state = if cfg!(target_os = \"linux\") {\n-            &repo_state.linux\n-        } else if cfg!(windows) {\n-            &repo_state.windows\n-        } else {\n-            unimplemented!()\n-        };\n+        let state = repo_state.state();\n         let new_state = current_toolstate[tool.as_str()];\n \n-        if new_state != *state {\n+        if new_state != state {\n             eprintln!(\"The state of `{}` has changed from `{}` to `{}`\", tool, state, new_state);\n-            if (new_state as u8) < (*state as u8) {\n+            if new_state < state {\n                 if ![\"rustc-guide\", \"miri\", \"embedded-book\"].contains(&tool.as_str()) {\n                     regressed = true;\n                 }\n@@ -403,7 +459,9 @@ fn change_toolstate(\n \n     let toolstate_serialized = t!(serde_json::to_string(&current_toolstate));\n \n-    let history_path = format!(\"rust-toolstate/history/{}.tsv\", OS.expect(\"linux/windows only\"));\n+    let history_path = Path::new(TOOLSTATE_DIR)\n+        .join(\"history\")\n+        .join(format!(\"{}.tsv\", OS.expect(\"linux/windows only\")));\n     let mut file = t!(fs::read_to_string(&history_path));\n     let end_of_first_line = file.find('\\n').unwrap();\n     file.insert_str(end_of_first_line, &format!(\"\\n{}\\t{}\", commit.trim(), toolstate_serialized));\n@@ -418,3 +476,15 @@ struct RepoState {\n     commit: String,\n     datetime: String,\n }\n+\n+impl RepoState {\n+    fn state(&self) -> ToolState {\n+        if cfg!(target_os = \"linux\") {\n+            self.linux\n+        } else if cfg!(windows) {\n+            self.windows\n+        } else {\n+            unimplemented!()\n+        }\n+    }\n+}"}, {"sha": "71f7f971eabaf8c07145b1a7af81cc18a7adc88e", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -241,13 +241,11 @@ impl Layout {\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n     pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n-        // Warning, removing the checked_add here led to segfaults in #67174. Further\n-        // analysis in #69225 seems to indicate that this is an LTO-related\n-        // miscompilation, so #67174 might be able to be reapplied in the future.\n-        let padded_size = self\n-            .size()\n-            .checked_add(self.padding_needed_for(self.align()))\n-            .ok_or(LayoutErr { private: () })?;\n+        // This cannot overflow. Quoting from the invariant of Layout:\n+        // > `size`, when rounded up to the nearest multiple of `align`,\n+        // > must not overflow (i.e., the rounded value must be less than\n+        // > `usize::MAX`)\n+        let padded_size = self.size() + self.padding_needed_for(self.align());\n         let alloc_size = padded_size.checked_mul(n).ok_or(LayoutErr { private: () })?;\n \n         unsafe {"}, {"sha": "a889eff75c04438a0b677999fe038d5a6204b3b0", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 471, "deletions": 7, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -68,6 +68,7 @@ extern \"rust-intrinsic\" {\n     // memory, which is not valid for either `&` or `&mut`.\n \n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n@@ -77,6 +78,7 @@ extern \"rust-intrinsic\" {\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n@@ -86,6 +88,7 @@ extern \"rust-intrinsic\" {\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n@@ -97,6 +100,7 @@ extern \"rust-intrinsic\" {\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n@@ -108,6 +112,7 @@ extern \"rust-intrinsic\" {\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -117,6 +122,7 @@ extern \"rust-intrinsic\" {\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n@@ -128,6 +134,7 @@ extern \"rust-intrinsic\" {\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n@@ -139,6 +146,7 @@ extern \"rust-intrinsic\" {\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n@@ -150,6 +158,7 @@ extern \"rust-intrinsic\" {\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n@@ -162,6 +171,7 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n@@ -171,6 +181,7 @@ extern \"rust-intrinsic\" {\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n@@ -180,6 +191,7 @@ extern \"rust-intrinsic\" {\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n@@ -191,6 +203,7 @@ extern \"rust-intrinsic\" {\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n@@ -202,6 +215,7 @@ extern \"rust-intrinsic\" {\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -211,6 +225,7 @@ extern \"rust-intrinsic\" {\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n@@ -222,6 +237,7 @@ extern \"rust-intrinsic\" {\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n@@ -233,6 +249,7 @@ extern \"rust-intrinsic\" {\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n@@ -244,6 +261,7 @@ extern \"rust-intrinsic\" {\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n@@ -256,20 +274,23 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_cxchgweak_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `load` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n     pub fn atomic_load<T>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `load` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n     pub fn atomic_load_acq<T>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `load` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -279,20 +300,23 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_load_unordered<T>(src: *const T) -> T;\n \n     /// Stores the value at the specified memory location.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `store` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n     pub fn atomic_store<T>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `store` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n     pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `store` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -302,34 +326,39 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_store_unordered<T>(dst: *mut T, val: T);\n \n     /// Stores the value at the specified memory location, returning the old value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -338,34 +367,39 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// Adds to the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -374,34 +408,39 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// Subtract from the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -410,34 +449,39 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise and with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -446,34 +490,39 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise nand with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -482,34 +531,39 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise or with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -518,63 +572,208 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise xor with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n+    ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Maximum with the current value using a signed comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n     pub fn atomic_max<T>(dst: *mut T, src: T) -> T;\n+    /// Maximum with the current value using a signed comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n     pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Maximum with the current value using a signed comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n     pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Maximum with the current value using a signed comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n     pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Maximum with the current value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n     pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Minimum with the current value using a signed comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n     pub fn atomic_min<T>(dst: *mut T, src: T) -> T;\n+    /// Minimum with the current value using a signed comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n     pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Minimum with the current value using a signed comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n     pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Minimum with the current value using a signed comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n     pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Minimum with the current value using a signed comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n+    /// as the `order`. For example,\n+    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n     pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Minimum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n     pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;\n+    /// Minimum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n     pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Minimum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n     pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Minimum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n     pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Minimum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n     pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Maximum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n     pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;\n+    /// Maximum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n     pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Maximum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n     pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Maximum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n     pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Maximum with the current value using an unsigned comparison.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n+    /// as the `order`. For example,\n+    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n     pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n@@ -613,9 +812,37 @@ extern \"rust-intrinsic\" {\n \n extern \"rust-intrinsic\" {\n \n+    /// An atomic fence.\n+    ///\n+    /// The stabilized version of this intrinsic is available in\n+    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n+    /// by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// as the `order`.\n     pub fn atomic_fence();\n+    /// An atomic fence.\n+    ///\n+    /// The stabilized version of this intrinsic is available in\n+    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n+    /// by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// as the `order`.\n     pub fn atomic_fence_acq();\n+    /// An atomic fence.\n+    ///\n+    /// The stabilized version of this intrinsic is available in\n+    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n+    /// by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// as the `order`.\n     pub fn atomic_fence_rel();\n+    /// An atomic fence.\n+    ///\n+    /// The stabilized version of this intrinsic is available in\n+    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n+    /// by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// as the `order`.\n     pub fn atomic_fence_acqrel();\n \n     /// A compiler-only memory barrier.\n@@ -624,9 +851,51 @@ extern \"rust-intrinsic\" {\n     /// compiler, but no instructions will be emitted for it. This is\n     /// appropriate for operations on the same thread that may be preempted,\n     /// such as when interacting with signal handlers.\n+    ///\n+    /// The stabilized version of this intrinsic is available in\n+    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n+    /// by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// as the `order`.\n     pub fn atomic_singlethreadfence();\n+    /// A compiler-only memory barrier.\n+    ///\n+    /// Memory accesses will never be reordered across this barrier by the\n+    /// compiler, but no instructions will be emitted for it. This is\n+    /// appropriate for operations on the same thread that may be preempted,\n+    /// such as when interacting with signal handlers.\n+    ///\n+    /// The stabilized version of this intrinsic is available in\n+    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n+    /// by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// as the `order`.\n     pub fn atomic_singlethreadfence_acq();\n+    /// A compiler-only memory barrier.\n+    ///\n+    /// Memory accesses will never be reordered across this barrier by the\n+    /// compiler, but no instructions will be emitted for it. This is\n+    /// appropriate for operations on the same thread that may be preempted,\n+    /// such as when interacting with signal handlers.\n+    ///\n+    /// The stabilized version of this intrinsic is available in\n+    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n+    /// by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// as the `order`.\n     pub fn atomic_singlethreadfence_rel();\n+    /// A compiler-only memory barrier.\n+    ///\n+    /// Memory accesses will never be reordered across this barrier by the\n+    /// compiler, but no instructions will be emitted for it. This is\n+    /// appropriate for operations on the same thread that may be preempted,\n+    /// such as when interacting with signal handlers.\n+    ///\n+    /// The stabilized version of this intrinsic is available in\n+    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n+    /// by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// as the `order`.\n     pub fn atomic_singlethreadfence_acqrel();\n \n     /// Magic intrinsic that derives its meaning from attributes\n@@ -693,8 +962,15 @@ extern \"rust-intrinsic\" {\n     /// Moves a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::ptr::write`](../../std/ptr/fn.write.html).\n     pub fn move_val_init<T>(dst: *mut T, src: T);\n \n+    /// The minimum alignment of a type.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::align_of`](../../std/mem/fn.align_of.html).\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n     #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"none\")]\n@@ -705,15 +981,25 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::size_of_val`](../../std/mem/fn.size_of_val.html).\n     pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n+    /// The minimum alignment of the type of the value that `val` points to.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::min_align_of_val`](../../std/mem/fn.min_align_of_val.html).\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::any::type_name`](../../std/any/fn.type_name.html)\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"none\")]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::any::TypeId::of`](../../std/any/struct.TypeId.html#method.of)\n     #[rustc_const_unstable(feature = \"const_type_id\", issue = \"none\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n@@ -731,6 +1017,9 @@ extern \"rust-intrinsic\" {\n     /// which is unsafe unless `T` is `Copy`. Also, even if T is\n     /// `Copy`, an all-zero value may not correspond to any legitimate\n     /// state for the type in question.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::zeroed`](../../std/mem/fn.zeroed.html).\n     #[unstable(\n         feature = \"core_intrinsics\",\n         reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n@@ -748,6 +1037,9 @@ extern \"rust-intrinsic\" {\n     /// state, which means it may claim either dropped or\n     /// undropped. In the general case one must use `ptr::write` to\n     /// initialize memory previous set to the result of `uninit`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::MaybeUninit`](../../std/mem/union.MaybeUninit.html).\n     #[unstable(\n         feature = \"core_intrinsics\",\n         reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n@@ -997,6 +1289,9 @@ extern \"rust-intrinsic\" {\n     /// byte past the end of an allocated object. If either pointer is out of\n     /// bounds or arithmetic overflow occurs then any further use of the\n     /// returned value will result in undefined behavior.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::pointer::offset`](../../std/primitive.pointer.html#method.offset).\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Calculates the offset from a pointer, potentially wrapping.\n@@ -1010,6 +1305,9 @@ extern \"rust-intrinsic\" {\n     /// resulting pointer to point into or one byte past the end of an allocated\n     /// object, and it wraps with two's complement arithmetic. The resulting\n     /// value is not necessarily valid to be used to actually access memory.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::pointer::wrapping_offset`](../../std/primitive.pointer.html#method.wrapping_offset).\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n@@ -1035,10 +1333,12 @@ extern \"rust-intrinsic\" {\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Performs a volatile load from the `src` pointer.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n@@ -1051,92 +1351,200 @@ extern \"rust-intrinsic\" {\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::sqrt`](../../std/primitive.f32.html#method.sqrt)\n     pub fn sqrtf32(x: f32) -> f32;\n     /// Returns the square root of an `f64`\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::sqrt`](../../std/primitive.f64.html#method.sqrt)\n     pub fn sqrtf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an integer power.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::powi`](../../std/primitive.f32.html#method.powi)\n     pub fn powif32(a: f32, x: i32) -> f32;\n     /// Raises an `f64` to an integer power.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::powi`](../../std/primitive.f64.html#method.powi)\n     pub fn powif64(a: f64, x: i32) -> f64;\n \n     /// Returns the sine of an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::sin`](../../std/primitive.f32.html#method.sin)\n     pub fn sinf32(x: f32) -> f32;\n     /// Returns the sine of an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::sin`](../../std/primitive.f64.html#method.sin)\n     pub fn sinf64(x: f64) -> f64;\n \n     /// Returns the cosine of an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::cos`](../../std/primitive.f32.html#method.cos)\n     pub fn cosf32(x: f32) -> f32;\n     /// Returns the cosine of an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::cos`](../../std/primitive.f64.html#method.cos)\n     pub fn cosf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an `f32` power.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::powf`](../../std/primitive.f32.html#method.powf)\n     pub fn powf32(a: f32, x: f32) -> f32;\n     /// Raises an `f64` to an `f64` power.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::powf`](../../std/primitive.f64.html#method.powf)\n     pub fn powf64(a: f64, x: f64) -> f64;\n \n     /// Returns the exponential of an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::exp`](../../std/primitive.f32.html#method.exp)\n     pub fn expf32(x: f32) -> f32;\n     /// Returns the exponential of an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::exp`](../../std/primitive.f64.html#method.exp)\n     pub fn expf64(x: f64) -> f64;\n \n     /// Returns 2 raised to the power of an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::exp2`](../../std/primitive.f32.html#method.exp2)\n     pub fn exp2f32(x: f32) -> f32;\n     /// Returns 2 raised to the power of an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::exp2`](../../std/primitive.f64.html#method.exp2)\n     pub fn exp2f64(x: f64) -> f64;\n \n     /// Returns the natural logarithm of an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::ln`](../../std/primitive.f32.html#method.ln)\n     pub fn logf32(x: f32) -> f32;\n     /// Returns the natural logarithm of an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::ln`](../../std/primitive.f64.html#method.ln)\n     pub fn logf64(x: f64) -> f64;\n \n     /// Returns the base 10 logarithm of an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::log10`](../../std/primitive.f32.html#method.log10)\n     pub fn log10f32(x: f32) -> f32;\n     /// Returns the base 10 logarithm of an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::log10`](../../std/primitive.f64.html#method.log10)\n     pub fn log10f64(x: f64) -> f64;\n \n     /// Returns the base 2 logarithm of an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::log2`](../../std/primitive.f32.html#method.log2)\n     pub fn log2f32(x: f32) -> f32;\n     /// Returns the base 2 logarithm of an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::log2`](../../std/primitive.f64.html#method.log2)\n     pub fn log2f64(x: f64) -> f64;\n \n     /// Returns `a * b + c` for `f32` values.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::mul_add`](../../std/primitive.f32.html#method.mul_add)\n     pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n     /// Returns `a * b + c` for `f64` values.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::mul_add`](../../std/primitive.f64.html#method.mul_add)\n     pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;\n \n     /// Returns the absolute value of an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::abs`](../../std/primitive.f32.html#method.abs)\n     pub fn fabsf32(x: f32) -> f32;\n     /// Returns the absolute value of an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::abs`](../../std/primitive.f64.html#method.abs)\n     pub fn fabsf64(x: f64) -> f64;\n \n     /// Returns the minimum of two `f32` values.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::min`](../../std/primitive.f32.html#method.min)\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::min`](../../std/primitive.f64.html#method.min)\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::max`](../../std/primitive.f32.html#method.max)\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::max`](../../std/primitive.f64.html#method.max)\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n \n     /// Copies the sign from `y` to `x` for `f32` values.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::copysign`](../../std/primitive.f32.html#method.copysign)\n     pub fn copysignf32(x: f32, y: f32) -> f32;\n     /// Copies the sign from `y` to `x` for `f64` values.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::copysign`](../../std/primitive.f64.html#method.copysign)\n     pub fn copysignf64(x: f64, y: f64) -> f64;\n \n     /// Returns the largest integer less than or equal to an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::floor`](../../std/primitive.f32.html#method.floor)\n     pub fn floorf32(x: f32) -> f32;\n     /// Returns the largest integer less than or equal to an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::floor`](../../std/primitive.f64.html#method.floor)\n     pub fn floorf64(x: f64) -> f64;\n \n     /// Returns the smallest integer greater than or equal to an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::ceil`](../../std/primitive.f32.html#method.ceil)\n     pub fn ceilf32(x: f32) -> f32;\n     /// Returns the smallest integer greater than or equal to an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::ceil`](../../std/primitive.f64.html#method.ceil)\n     pub fn ceilf64(x: f64) -> f64;\n \n     /// Returns the integer part of an `f32`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::trunc`](../../std/primitive.f32.html#method.trunc)\n     pub fn truncf32(x: f32) -> f32;\n     /// Returns the integer part of an `f64`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::trunc`](../../std/primitive.f64.html#method.trunc)\n     pub fn truncf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n@@ -1152,8 +1560,14 @@ extern \"rust-intrinsic\" {\n     pub fn nearbyintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f32::round`](../../std/primitive.f32.html#method.round)\n     pub fn roundf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::f64::round`](../../std/primitive.f64.html#method.round)\n     pub fn roundf64(x: f64) -> f64;\n \n     /// Float addition that allows optimizations based on algebraic rules.\n@@ -1177,15 +1591,24 @@ extern \"rust-intrinsic\" {\n     pub fn frem_fast<T>(a: T, b: T) -> T;\n \n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n-    /// https://github.com/rust-lang/rust/issues/10184\n+    /// (<https://github.com/rust-lang/rust/issues/10184>)\n+    /// This is under stabilization at <https://github.com/rust-lang/rust/issues/67058>\n     pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n+    ///\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `count_ones` method. For example,\n+    /// [`std::u32::count_ones`](../../std/primitive.u32.html#method.count_ones)\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n     pub fn ctpop<T>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n     ///\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `leading_zeros` method. For example,\n+    /// [`std::u32::leading_zeros`](../../std/primitive.u32.html#method.leading_zeros)\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1231,6 +1654,10 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n     ///\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `trailing_zeros` method. For example,\n+    /// [`std::u32::trailing_zeros`](../../std/primitive.u32.html#method.trailing_zeros)\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1275,28 +1702,39 @@ extern \"rust-intrinsic\" {\n     pub fn cttz_nonzero<T>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n+    ///\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `swap_bytes` method. For example,\n+    /// [`std::u32::swap_bytes`](../../std/primitive.u32.html#method.swap_bytes)\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n     pub fn bswap<T>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n+    ///\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `reverse_bits` method. For example,\n+    /// [`std::u32::reverse_bits`](../../std/primitive.u32.html#method.reverse_bits)\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n     pub fn bitreverse<T>(x: T) -> T;\n \n     /// Performs checked integer addition.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,\n     /// [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_sub` method. For example,\n     /// [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn sub_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_mul` method. For example,\n     /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n@@ -1309,19 +1747,35 @@ extern \"rust-intrinsic\" {\n \n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::min_value()` and y = -1\n+    ///\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `checked_div` method. For example,\n+    /// [`std::u32::checked_div`](../../std/primitive.u32.html#method.checked_div)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_div<T>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n+    ///\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `checked_rem` method. For example,\n+    /// [`std::u32::checked_rem`](../../std/primitive.u32.html#method.checked_rem)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_rem<T>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n+    ///\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `checked_shl` method. For example,\n+    /// [`std::u32::checked_shl`](../../std/primitive.u32.html#method.checked_shl)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shl<T>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n+    ///\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `checked_shr` method. For example,\n+    /// [`std::u32::checked_shr`](../../std/primitive.u32.html#method.checked_shr)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shr<T>(x: T, y: T) -> T;\n \n@@ -1341,45 +1795,52 @@ extern \"rust-intrinsic\" {\n     pub fn unchecked_mul<T>(x: T, y: T) -> T;\n \n     /// Performs rotate left.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_left` method. For example,\n     /// [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     pub fn rotate_left<T>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_right` method. For example,\n     /// [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     pub fn rotate_right<T>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n-    /// primitives via the `wrapping_add` method. For example,\n-    /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n+    /// primitives via the `checked_add` method. For example,\n+    /// [`std::u32::checked_add`](../../std/primitive.u32.html#method.checked_add)\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_add<T>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n-    /// primitives via the `wrapping_sub` method. For example,\n-    /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n+    /// primitives via the `checked_sub` method. For example,\n+    /// [`std::u32::checked_sub`](../../std/primitive.u32.html#method.checked_sub)\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_sub<T>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n-    /// primitives via the `wrapping_mul` method. For example,\n-    /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n+    /// primitives via the `checked_mul` method. For example,\n+    /// [`std::u32::checked_mul`](../../std/primitive.u32.html#method.checked_mul)\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_mul<T>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, while saturating at numeric bounds.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,\n     /// [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     pub fn saturating_add<T>(a: T, b: T) -> T;\n     /// Computes `a - b`, while saturating at numeric bounds.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_sub` method. For example,\n     /// [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n@@ -1388,6 +1849,9 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the value of the discriminant for the variant in 'v',\n     /// cast to a `u64`; if `T` has no discriminant, returns 0.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::discriminant`](../../std/mem/fn.discriminant.html)\n     pub fn discriminant_value<T>(v: &T) -> u64;\n \n     /// Rust's \"try catch\" construct which invokes the function pointer `f` with"}, {"sha": "1120d6d4bc50eac3675de6734c060d11b85c25d6", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -109,8 +109,9 @@ pub use crate::intrinsics::transmute;\n /// [ub]: ../../reference/behavior-considered-undefined.html\n /// [`ManuallyDrop`]: struct.ManuallyDrop.html\n #[inline]\n+#[rustc_const_unstable(feature = \"const_forget\", issue = \"69616\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn forget<T>(t: T) {\n+pub const fn forget<T>(t: T) {\n     ManuallyDrop::new(t);\n }\n "}, {"sha": "3ba15968f893300b68fc884c6b4cf05394e2b9c1", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -2444,7 +2444,7 @@ unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n-/// returns the max value (signed comparison)\n+/// returns the max value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n@@ -2457,7 +2457,7 @@ unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n-/// returns the min value (signed comparison)\n+/// returns the min value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {"}, {"sha": "d62e5a5ece0bf7e43ba6e0fb9acaff2d1380062f", "filename": "src/librustc_ast/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_ast%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_ast%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2FREADME.md?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,4 +1,4 @@\n-The `syntax` crate contains those things concerned purely with syntax\n+The `rustc_ast` crate contains those things concerned purely with syntax\n \u2013 that is, the AST (\"abstract syntax tree\"), parser, pretty-printer,\n lexer, macro expander, and utilities for traversing ASTs.\n "}, {"sha": "5b00087de6fb72d8745e9dc445db4927e6a12c21", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -444,22 +444,12 @@ impl Handler {\n     }\n \n     /// Stash a given diagnostic with the given `Span` and `StashKey` as the key for later stealing.\n-    /// If the diagnostic with this `(span, key)` already exists, this will result in an ICE.\n     pub fn stash_diagnostic(&self, span: Span, key: StashKey, diag: Diagnostic) {\n         let mut inner = self.inner.borrow_mut();\n-        if let Some(mut old_diag) = inner.stashed_diagnostics.insert((span, key), diag) {\n-            // We are removing a previously stashed diagnostic which should not happen.\n-            old_diag.level = Bug;\n-            old_diag.note(&format!(\n-                \"{}:{}: already existing stashed diagnostic with (span = {:?}, key = {:?})\",\n-                file!(),\n-                line!(),\n-                span,\n-                key\n-            ));\n-            inner.emit_diag_at_span(old_diag, span);\n-            panic!(ExplicitBug);\n-        }\n+        // FIXME(Centril, #69537): Consider reintroducing panic on overwriting a stashed diagnostic\n+        // if/when we have a more robust macro-friendly replacement for `(span, key)` as a key.\n+        // See the PR for a discussion.\n+        inner.stashed_diagnostics.insert((span, key), diag);\n     }\n \n     /// Steal a previously stashed diagnostic with the given `Span` and `StashKey` as the key."}, {"sha": "69fc0c1cbb96b71b0a8fc3ed3aa0acbd42032aaa", "filename": "src/test/ui/issues/issue-69396-const-no-type-in-macro.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -0,0 +1,17 @@\n+macro_rules! suite {\n+    ( $( $fn:ident; )* ) => {\n+        $(\n+            const A = \"A\".$fn();\n+            //~^ ERROR the name `A` is defined multiple times\n+            //~| ERROR missing type for `const` item\n+            //~| ERROR the type placeholder `_` is not allowed within types\n+        )*\n+    }\n+}\n+\n+suite! {\n+    len;\n+    is_empty;\n+}\n+\n+fn main() {}"}, {"sha": "1af5368d2b6d934b909827f73e5e839d81527293", "filename": "src/test/ui/issues/issue-69396-const-no-type-in-macro.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -0,0 +1,53 @@\n+error[E0428]: the name `A` is defined multiple times\n+  --> $DIR/issue-69396-const-no-type-in-macro.rs:4:13\n+   |\n+LL |               const A = \"A\".$fn();\n+   |               ^^^^^^^^^^^^^^^^^^^^\n+   |               |\n+   |               `A` redefined here\n+   |               previous definition of the value `A` here\n+...\n+LL | / suite! {\n+LL | |     len;\n+LL | |     is_empty;\n+LL | | }\n+   | |_- in this macro invocation\n+   |\n+   = note: `A` must be defined only once in the value namespace of this module\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: missing type for `const` item\n+  --> $DIR/issue-69396-const-no-type-in-macro.rs:4:19\n+   |\n+LL |               const A = \"A\".$fn();\n+   |                     ^ help: provide a type for the item: `A: usize`\n+...\n+LL | / suite! {\n+LL | |     len;\n+LL | |     is_empty;\n+LL | | }\n+   | |_- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/issue-69396-const-no-type-in-macro.rs:4:19\n+   |\n+LL |               const A = \"A\".$fn();\n+   |                     ^\n+   |                     |\n+   |                     not allowed in type signatures\n+   |                     help: replace `_` with the correct type: `bool`\n+...\n+LL | / suite! {\n+LL | |     len;\n+LL | |     is_empty;\n+LL | | }\n+   | |_- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0121, E0428.\n+For more information about an error, try `rustc --explain E0121`."}]}