{"sha": "40fc1737b29b480c15318016a24874ef6f9ef75f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZmMxNzM3YjI5YjQ4MGMxNTMxODAxNmEyNDg3NGVmNmY5ZWY3NWY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-10T02:12:50Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-10T22:12:12Z"}, "message": "Get rid of places that expected foo.bar to implicitly bind.", "tree": {"sha": "526e68481fbd9dda5a7d48f8d3222db5f9603ced", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/526e68481fbd9dda5a7d48f8d3222db5f9603ced"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40fc1737b29b480c15318016a24874ef6f9ef75f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40fc1737b29b480c15318016a24874ef6f9ef75f", "html_url": "https://github.com/rust-lang/rust/commit/40fc1737b29b480c15318016a24874ef6f9ef75f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40fc1737b29b480c15318016a24874ef6f9ef75f/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25b152397d66144230c2d8374e17150fc79a24f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/25b152397d66144230c2d8374e17150fc79a24f7", "html_url": "https://github.com/rust-lang/rust/commit/25b152397d66144230c2d8374e17150fc79a24f7"}], "stats": {"total": 101, "additions": 52, "deletions": 49}, "files": [{"sha": "01298675688c38096430a4f4b98451fa86f6c6da", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/40fc1737b29b480c15318016a24874ef6f9ef75f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fc1737b29b480c15318016a24874ef6f9ef75f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=40fc1737b29b480c15318016a24874ef6f9ef75f", "patch": "@@ -119,7 +119,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n              alt m.node {\n                mac_invoc(pth, arg, body) {\n                  mac_invoc(fld.fold_path(pth),\n-                           option::map(arg, fld.fold_expr), body)\n+                           option::map(arg, |x| fld.fold_expr(x)), body)\n                }\n                mac_invoc_tt(pth, tt) { m.node }\n                mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n@@ -136,7 +136,7 @@ fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n          output: fld.fold_ty(decl.output),\n          purity: decl.purity,\n          cf: decl.cf,\n-         constraints: vec::map(decl.constraints, fld.fold_constr)}\n+         constraints: vec::map(decl.constraints, |x| fld.fold_constr(x))}\n }\n \n fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n@@ -160,7 +160,7 @@ fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = |x| fold_meta_item_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n-    ret {directives: vec::map(c.directives, fld.fold_crate_directive),\n+    ret {directives: vec::map(c.directives, |x| fld.fold_crate_directive(x)),\n          module: fld.fold_mod(c.module),\n          attrs: vec::map(c.attrs, fold_attribute),\n          config: vec::map(c.config, fold_meta_item)};\n@@ -174,7 +174,7 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n           }\n           cdir_dir_mod(id, cds, attrs) {\n             cdir_dir_mod(fld.fold_ident(id),\n-                         vec::map(cds, fld.fold_crate_directive),\n+                         vec::map(cds, |x| fld.fold_crate_directive(x)),\n                          /* FIXME (#2543) */ copy attrs)\n           }\n           cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n@@ -203,7 +203,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n                                   cf: fdec.cf,\n                                   constraints:\n                                       vec::map(fdec.constraints,\n-                                               fld.fold_constr)},\n+                                               |x| fld.fold_constr(x))},\n                                  fold_ty_params(typms, fld))\n                 }\n               },\n@@ -248,7 +248,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                                           fold_ty_params(typms, fld),\n                                           rp) }\n           item_enum(variants, typms, r) {\n-            item_enum(vec::map(variants, fld.fold_variant),\n+            item_enum(vec::map(variants, |x| fld.fold_variant(x)),\n                       fold_ty_params(typms, fld),\n                       r)\n           }\n@@ -265,7 +265,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n               item_class(\n                   /* FIXME (#2543) */ copy typms,\n                   vec::map(traits, |p| fold_trait_ref(p, fld)),\n-                  vec::map(items, fld.fold_class_item),\n+                  vec::map(items, |x| fld.fold_class_item(x)),\n                   {node: {body: ctor_body,\n                           dec: ctor_decl,\n                           id: ctor_id with ctor.node}\n@@ -276,7 +276,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                         rp,\n                         ifce.map(|p| fold_trait_ref(p, fld)),\n                         fld.fold_ty(ty),\n-                        vec::map(methods, fld.fold_method))\n+                        vec::map(methods, |x| fld.fold_method(x)))\n           }\n           item_trait(tps, rp, methods) {\n             item_trait(fold_ty_params(tps, fld),\n@@ -308,9 +308,9 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n \n \n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n-    ret {view_items: vec::map(b.view_items, fld.fold_view_item),\n-         stmts: vec::map(b.stmts, fld.fold_stmt),\n-         expr: option::map(b.expr, fld.fold_expr),\n+    ret {view_items: vec::map(b.view_items, |x| fld.fold_view_item(x)),\n+         stmts: vec::map(b.stmts, |x| fld.fold_stmt(x)),\n+         expr: option::map(b.expr, |x| fld.fold_expr(x)),\n          id: fld.new_id(b.id),\n          rules: b.rules};\n }\n@@ -324,21 +324,22 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n }\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n-    ret {pats: vec::map(a.pats, fld.fold_pat),\n-         guard: option::map(a.guard, fld.fold_expr),\n+    ret {pats: vec::map(a.pats, |x| fld.fold_pat(x)),\n+         guard: option::map(a.guard, |x| fld.fold_expr(x)),\n          body: fld.fold_block(a.body)};\n }\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     ret alt p {\n           pat_wild { pat_wild }\n           pat_ident(pth, sub) {\n-            pat_ident(fld.fold_path(pth), option::map(sub, fld.fold_pat))\n+            pat_ident(fld.fold_path(pth),\n+                      option::map(sub, |x| fld.fold_pat(x)))\n           }\n           pat_lit(e) { pat_lit(fld.fold_expr(e)) }\n           pat_enum(pth, pats) {\n               pat_enum(fld.fold_path(pth), option::map(pats,\n-                       |pats| vec::map(pats, fld.fold_pat)))\n+                       |pats| vec::map(pats, |x| fld.fold_pat(x))))\n           }\n           pat_rec(fields, etc) {\n             let mut fs = ~[];\n@@ -349,7 +350,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n             }\n             pat_rec(fs, etc)\n           }\n-          pat_tup(elts) { pat_tup(vec::map(elts, fld.fold_pat)) }\n+          pat_tup(elts) { pat_tup(vec::map(elts, |x| fld.fold_pat(x))) }\n           pat_box(inner) { pat_box(fld.fold_pat(inner)) }\n           pat_uniq(inner) { pat_uniq(fld.fold_pat(inner)) }\n           pat_range(e1, e2) {\n@@ -360,7 +361,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n \n fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n     alt d {\n-      decl_local(ls) { decl_local(vec::map(ls, fld.fold_local)) }\n+      decl_local(ls) { decl_local(vec::map(ls, |x| fld.fold_local(x))) }\n       decl_item(it) {\n         alt fld.fold_item(it) {\n           some(it_folded) { decl_item(it_folded) }\n@@ -400,15 +401,16 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_vstore(fld.fold_expr(e), v)\n           }\n           expr_vec(exprs, mutt) {\n-            expr_vec(fld.map_exprs(fld.fold_expr, exprs), mutt)\n+            expr_vec(fld.map_exprs(|x| fld.fold_expr(x), exprs), mutt)\n           }\n           expr_rec(fields, maybe_expr) {\n             expr_rec(vec::map(fields, fold_field),\n-                     option::map(maybe_expr, fld.fold_expr))\n+                     option::map(maybe_expr, |x| fld.fold_expr(x)))\n           }\n-          expr_tup(elts) { expr_tup(vec::map(elts, fld.fold_expr)) }\n+          expr_tup(elts) { expr_tup(vec::map(elts, |x| fld.fold_expr(x))) }\n           expr_call(f, args, blk) {\n-            expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args),\n+            expr_call(fld.fold_expr(f),\n+                      fld.map_exprs(|x| fld.fold_expr(x), args),\n                       blk)\n           }\n           expr_binary(binop, lhs, rhs) {\n@@ -422,7 +424,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_addr_of(m, ohs) { expr_addr_of(m, fld.fold_expr(ohs)) }\n           expr_if(cond, tr, fl) {\n             expr_if(fld.fold_expr(cond), fld.fold_block(tr),\n-                    option::map(fl, fld.fold_expr))\n+                    option::map(fl, |x| fld.fold_expr(x)))\n           }\n           expr_while(cond, body) {\n             expr_while(fld.fold_expr(cond), fld.fold_block(body))\n@@ -431,7 +433,8 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n               expr_loop(fld.fold_block(body))\n           }\n           expr_alt(expr, arms, mode) {\n-            expr_alt(fld.fold_expr(expr), vec::map(arms, fld.fold_arm), mode)\n+            expr_alt(fld.fold_expr(expr),\n+                     vec::map(arms, |x| fld.fold_arm(x)), mode)\n           }\n           expr_fn(proto, decl, body, captures) {\n             expr_fn(proto, fold_fn_decl(decl, fld),\n@@ -462,22 +465,22 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_field(el, id, tys) {\n             expr_field(fld.fold_expr(el), fld.fold_ident(id),\n-                       vec::map(tys, fld.fold_ty))\n+                       vec::map(tys, |x| fld.fold_ty(x)))\n           }\n           expr_index(el, er) {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n           }\n           expr_path(pth) { expr_path(fld.fold_path(pth)) }\n-          expr_fail(e) { expr_fail(option::map(e, fld.fold_expr)) }\n+          expr_fail(e) { expr_fail(option::map(e, |x| fld.fold_expr(x))) }\n           expr_break | expr_again { copy e }\n-          expr_ret(e) { expr_ret(option::map(e, fld.fold_expr)) }\n+          expr_ret(e) { expr_ret(option::map(e, |x| fld.fold_expr(x))) }\n           expr_log(i, lv, e) { expr_log(i, fld.fold_expr(lv),\n                                         fld.fold_expr(e)) }\n           expr_assert(e) { expr_assert(fld.fold_expr(e)) }\n           expr_check(m, e) { expr_check(m, fld.fold_expr(e)) }\n           expr_if_check(cond, tr, fl) {\n             expr_if_check(fld.fold_expr(cond), fld.fold_block(tr),\n-                          option::map(fl, fld.fold_expr))\n+                          option::map(fl, |x| fld.fold_expr(x)))\n           }\n           expr_mac(mac) { expr_mac(fold_mac(mac)) }\n         }\n@@ -505,7 +508,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_tup(tys) {ty_tup(vec::map(tys, |ty| fld.fold_ty(ty)))}\n       ty_path(path, id) {ty_path(fld.fold_path(path), fld.new_id(id))}\n       ty_constr(ty, constrs) {ty_constr(fld.fold_ty(ty),\n-                                vec::map(constrs, fld.fold_ty_constr))}\n+                                vec::map(constrs, |x| fld.fold_ty_constr(x)))}\n       ty_vstore(t, vs) {ty_vstore(fld.fold_ty(t), vs)}\n       ty_mac(mac) {ty_mac(fold_mac(mac))}\n     }\n@@ -524,13 +527,13 @@ fn noop_fold_ty_constr(c: ty_constr_, fld: ast_fold) -> ty_constr_ {\n }\n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n-    ret {view_items: vec::map(m.view_items, fld.fold_view_item),\n-         items: vec::filter_map(m.items, fld.fold_item)};\n+    ret {view_items: vec::map(m.view_items, |x| fld.fold_view_item(x)),\n+         items: vec::filter_map(m.items, |x| fld.fold_item(x))};\n }\n \n fn noop_fold_foreign_mod(nm: foreign_mod, fld: ast_fold) -> foreign_mod {\n-    ret {view_items: vec::map(nm.view_items, fld.fold_view_item),\n-         items: vec::map(nm.items, fld.fold_foreign_item)}\n+    ret {view_items: vec::map(nm.view_items, |x| fld.fold_view_item(x)),\n+         items: vec::map(nm.items, |x| fld.fold_foreign_item(x))}\n }\n \n fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n@@ -560,9 +563,9 @@ fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {\n \n fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n     ret {span: fld.new_span(p.span), global: p.global,\n-         idents: vec::map(p.idents, fld.fold_ident),\n+         idents: vec::map(p.idents, |x| fld.fold_ident(x)),\n          rp: p.rp,\n-         types: vec::map(p.types, fld.fold_ty)};\n+         types: vec::map(p.types, |x| fld.fold_ty(x))};\n }\n \n fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {"}, {"sha": "a044b45b3ae0303fa034fcf5ccac30117abbcc60", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40fc1737b29b480c15318016a24874ef6f9ef75f/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fc1737b29b480c15318016a24874ef6f9ef75f/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=40fc1737b29b480c15318016a24874ef6f9ef75f", "patch": "@@ -54,8 +54,8 @@ fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) ->\n     let filtered_items = vec::filter_map(m.items, item_filter);\n     let view_item_filter = |a| filter_view_item(cx, a);\n     let filtered_view_items = vec::filter_map(m.view_items, view_item_filter);\n-    ret {view_items: vec::map(filtered_view_items, fld.fold_view_item),\n-         items: vec::filter_map(filtered_items, fld.fold_item)};\n+    ret {view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(x)),\n+         items: vec::filter_map(filtered_items, |x| fld.fold_item(x))};\n }\n \n fn filter_foreign_item(cx: ctxt, &&item: @ast::foreign_item) ->\n@@ -72,7 +72,7 @@ fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n     let view_item_filter = |a| filter_view_item(cx, a);\n     let filtered_view_items = vec::filter_map(\n         nm.view_items, view_item_filter);\n-    ret {view_items: vec::map(filtered_view_items, fld.fold_view_item),\n+    ret {view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(x)),\n          items: filtered_items};\n }\n \n@@ -98,8 +98,8 @@ fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n     let filter = |a| filter_stmt(cx, a);\n     let filtered_stmts = vec::filter_map(b.stmts, filter);\n     ret {view_items: b.view_items,\n-         stmts: vec::map(filtered_stmts, fld.fold_stmt),\n-         expr: option::map(b.expr, fld.fold_expr),\n+         stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(x)),\n+         expr: option::map(b.expr, |x| fld.fold_expr(x)),\n          id: b.id,\n          rules: b.rules};\n }"}, {"sha": "6a3676227cc06ad7d6bbec47137dcb1b490304bd", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/40fc1737b29b480c15318016a24874ef6f9ef75f/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fc1737b29b480c15318016a24874ef6f9ef75f/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=40fc1737b29b480c15318016a24874ef6f9ef75f", "patch": "@@ -11,11 +11,11 @@ fn main() {\n     assert 15i32.add(6i32) == 21i32;\n     assert 15i64.add(6i64) == 21i64;\n     // times\n-    let bar = 15.times;\n-    let bar = 15i8.times;\n-    let bar = 15i16.times;\n-    let bar = 15i32.times;\n-    let bar = 15i64.times;\n+     15.times(|| false);\n+     15i8.times(|| false);\n+     15i16.times(|| false);\n+     15i32.times(|| false);\n+     15i64.times(|| false);\n \n // uints\n     // num\n@@ -25,11 +25,11 @@ fn main() {\n     assert 15u32.add(6u32) == 21u32;\n     assert 15u64.add(6u64) == 21u64;\n     // times\n-    let bar = 15u.times;\n-    let bar = 15u8.times;\n-    let bar = 15u16.times;\n-    let bar = 15u32.times;\n-    let bar = 15u64.times;\n+     15u.times(|| false);\n+     15u8.times(|| false);\n+     15u16.times(|| false);\n+     15u32.times(|| false);\n+     15u64.times(|| false);\n \n // floats\n     // num"}]}