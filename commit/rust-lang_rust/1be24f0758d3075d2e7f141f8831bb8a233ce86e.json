{"sha": "1be24f0758d3075d2e7f141f8831bb8a233ce86e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZTI0ZjA3NThkMzA3NWQyZTdmMTQxZjg4MzFiYjhhMjMzY2U4NmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-19T01:31:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-19T04:31:00Z"}, "message": "replace explicit calls to vec::each with vec::each_ref, partially demode str", "tree": {"sha": "28b93c29c3b427f7cd84142a49b1b86222d700eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28b93c29c3b427f7cd84142a49b1b86222d700eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1be24f0758d3075d2e7f141f8831bb8a233ce86e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1be24f0758d3075d2e7f141f8831bb8a233ce86e", "html_url": "https://github.com/rust-lang/rust/commit/1be24f0758d3075d2e7f141f8831bb8a233ce86e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1be24f0758d3075d2e7f141f8831bb8a233ce86e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e17a3b3194cc5dc213d13ff6499c93482215c223", "url": "https://api.github.com/repos/rust-lang/rust/commits/e17a3b3194cc5dc213d13ff6499c93482215c223", "html_url": "https://github.com/rust-lang/rust/commit/e17a3b3194cc5dc213d13ff6499c93482215c223"}], "stats": {"total": 1164, "additions": 564, "deletions": 600}, "files": [{"sha": "82d45cc3a297ceb304c66c551a20ec48b20763dc", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -425,8 +425,8 @@ fn compose_and_run_compiler(\n     let extra_link_args = ~[~\"-L\",\n                             aux_output_dir_name(config, testfile).to_str()];\n \n-    do vec::iter(props.aux_builds) |rel_ab| {\n-        let abs_ab = config.aux_base.push_rel(&Path(rel_ab));\n+    for vec::each_ref(props.aux_builds) |rel_ab| {\n+        let abs_ab = config.aux_base.push_rel(&Path(*rel_ab));\n         let aux_args =\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n                               |a,b| make_lib_name(a, b, testfile), &abs_ab);"}, {"sha": "b9c0122df3ffedf811858007c6f1ea3b2eec66ef", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -91,7 +91,7 @@ pure fn build_sized_opt<A>(size: Option<uint>,\n #[inline(always)]\n pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n-        for vec::each(lhs) |x| { push(x); }\n+        for vec::each_ref(lhs) |x| { push(*x); }\n         for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n     }\n }\n@@ -100,8 +100,8 @@ pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n /// Apply a function to each element of a vector and return the results\n pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n-        for vec::each(v) |elem| {\n-            push(f(elem));\n+        for vec::each_ref(v) |elem| {\n+            push(f(*elem));\n         }\n     }\n }"}, {"sha": "da7f1894a035497e4231857851124b9a15ce3a03", "filename": "src/libcore/either.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -33,8 +33,8 @@ fn lefts<T: Copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n     //! Extracts from a vector of either all the left values\n \n     let mut result: ~[T] = ~[];\n-    for vec::each(eithers) |elt| {\n-        match elt {\n+    for vec::each_ref(eithers) |elt| {\n+        match *elt {\n           Left(l) => vec::push(result, l),\n           _ => { /* fallthrough */ }\n         }\n@@ -46,8 +46,8 @@ fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     //! Extracts from a vector of either all the right values\n \n     let mut result: ~[U] = ~[];\n-    for vec::each(eithers) |elt| {\n-        match elt {\n+    for vec::each_ref(eithers) |elt| {\n+        match *elt {\n           Right(r) => vec::push(result, r),\n           _ => { /* fallthrough */ }\n         }\n@@ -66,8 +66,8 @@ fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n \n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n-    for vec::each(eithers) |elt| {\n-        match elt {\n+    for vec::each_ref(eithers) |elt| {\n+        match *elt {\n           Left(l) => vec::push(lefts, l),\n           Right(r) => vec::push(rights, r)\n         }"}, {"sha": "ab06814c0084c1dc4e93fb00eadee74beee10205", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -390,7 +390,9 @@ impl &SipState : Streaming {\n     fn result_str() -> ~str {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n-        for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n+        for vec::each_ref(r) |b| {\n+            s += uint::to_str(*b as uint, 16u);\n+        }\n         move s\n     }\n \n@@ -483,7 +485,9 @@ fn test_siphash() {\n \n     fn to_hex_str(r:  &[u8]/8) -> ~str {\n         let mut s = ~\"\";\n-        for vec::each(*r) |b| { s += uint::to_str(b as uint, 16u); }\n+        for vec::each_ref(*r) |b| {\n+            s += uint::to_str(*b as uint, 16u);\n+        }\n         return s;\n     }\n "}, {"sha": "6856c917e4f98d586bcb20d06d1c94c125ce61d2", "filename": "src/libcore/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -450,8 +450,8 @@ fn mk_file_writer(path: &Path, flags: ~[FileFlag])\n     fn wb() -> c_int { O_WRONLY as c_int }\n \n     let mut fflags: c_int = wb();\n-    for vec::each(flags) |f| {\n-        match f {\n+    for vec::each_ref(flags) |f| {\n+        match *f {\n           Append => fflags |= O_APPEND as c_int,\n           Create => fflags |= O_CREAT as c_int,\n           Truncate => fflags |= O_TRUNC as c_int,"}, {"sha": "6164283e85886ab2b162d3edd72749596b5b993a", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -7,7 +7,12 @@ type IMPL_T<A> = dvec::DVec<A>;\n  * Attempts to access this dvec during iteration will fail.\n  */\n pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n-    unsafe { self.swap(|v| { vec::each(v, f); move v }) }\n+    unsafe {\n+        do self.swap |v| {\n+            vec::each(v, f);\n+            move v\n+        }\n+    }\n }\n \n pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> Option<uint> {"}, {"sha": "2404f5deff73b81ed71831133974624be5a55e17", "filename": "src/libcore/os.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -210,8 +210,8 @@ mod global_env {\n \n         fn env() -> ~[(~str,~str)] {\n             let mut pairs = ~[];\n-            for vec::each(rustrt::rust_env_pairs()) |p| {\n-                let vs = str::splitn_char(p, '=', 1u);\n+            for vec::each_ref(rustrt::rust_env_pairs()) |p| {\n+                let vs = str::splitn_char(*p, '=', 1u);\n                 assert vec::len(vs) == 2u;\n                 vec::push(pairs, (copy vs[0], copy vs[1]));\n             }\n@@ -892,8 +892,8 @@ mod tests {\n     fn test_env_getenv() {\n         let e = env();\n         assert vec::len(e) > 0u;\n-        for vec::each(e) |p| {\n-            let (n, v) = copy p;\n+        for vec::each_ref(e) |p| {\n+            let (n, v) = copy *p;\n             log(debug, n);\n             let v2 = getenv(n);\n             // MingW seems to set some funky environment variables like\n@@ -985,7 +985,9 @@ mod tests {\n         // Just assuming that we've got some contents in the current directory\n         assert (vec::len(dirs) > 0u);\n \n-        for vec::each(dirs) |dir| { log(debug, dir); }\n+        for vec::each_ref(dirs) |dir| {\n+            log(debug, *dir);\n+        }\n     }\n \n     #[test]"}, {"sha": "4fc9c724843140a4413bbad1842481601dcff19e", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -1099,7 +1099,7 @@ impl<T: Send> PortSet<T> : Recv<T> {\n     pure fn peek() -> bool {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n-        for vec::each(self.ports) |p| {\n+        for vec::each_ref(self.ports) |p| {\n             if p.peek() { return true }\n         }\n         false"}, {"sha": "435f1a5d18dad4d0da5b5ff45ac785cc7ee86436", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -158,7 +158,7 @@ impl ReprVisitor {\n \n     fn write_escaped_slice(slice: &str) {\n         self.writer.write_char('\"');\n-        do str::chars_iter(slice) |ch| {\n+        for str::chars_each(slice) |ch| {\n             self.writer.write_escaped_char(ch);\n         }\n         self.writer.write_char('\"');\n@@ -563,7 +563,7 @@ impl ReprPrinterWrapper {\n             let vec_repr = *vec_repr_ptr;\n             let data_ptr = ptr::to_unsafe_ptr(&(*vec_repr).unboxed.data);\n             let slice: &str = transmute((data_ptr, (*vec_repr).unboxed.fill));\n-            do str::chars_iter(slice) |ch| {\n+            for str::chars_each(slice) |ch| {\n                 self.printer.writer.write_escaped_char(ch);\n             }\n             self.printer.writer.write_char('\"');\n@@ -686,7 +686,7 @@ impl ReprPrinterWrapper : TyVisitor {\n             self.printer.writer.write_char('\"');\n             let slice_ptr: *&str = transmute(copy self.printer.ptr);\n             let slice = *slice_ptr;\n-            do str::chars_iter(slice) |ch| {\n+            for str::chars_each(slice) |ch| {\n                 self.printer.writer.write_escaped_char(ch);\n             }\n             self.printer.writer.write_char('\"');"}, {"sha": "d11e90149d22daedd297c47dc1d26902c5f659a8", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -267,11 +267,11 @@ impl<T: Copy, E: Copy> Result<T, E> {\n  *     }\n  */\n fn map_vec<T,U:Copy,V:Copy>(\n-    ts: &[T], op: fn(T) -> Result<V,U>) -> Result<~[V],U> {\n+    ts: &[T], op: fn((&T)) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = ~[];\n     vec::reserve(vs, vec::len(ts));\n-    for vec::each(ts) |t| {\n+    for vec::each_ref(ts) |t| {\n         match op(t) {\n           Ok(v) => vec::push(vs, v),\n           Err(u) => return Err(u)"}, {"sha": "1bc0636ccda90e0bff6b03ce2cf883bcbda17fbe", "filename": "src/libcore/run.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -86,8 +86,8 @@ fn with_argv<T>(prog: &str, args: &[~str],\n                 cb: fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n     let mut tmps = ~[];\n-    for vec::each(args) |arg| {\n-        let t = @copy arg;\n+    for vec::each_ref(args) |arg| {\n+        let t = @copy *arg;\n         vec::push(tmps, t);\n         vec::push_all(argptrs, str::as_c_str(*t, |b| ~[b]));\n     }\n@@ -105,8 +105,8 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n-        for vec::each(es) |e| {\n-            let (k,v) = copy e;\n+        for vec::each_ref(es) |e| {\n+            let (k,v) = copy *e;\n             let t = @(fmt!(\"%s=%s\", k, v));\n             vec::push(tmps, t);\n             vec::push_all(ptrs, str::as_c_str(*t, |b| ~[b]));\n@@ -130,8 +130,8 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n         match *env {\n           Some(es) if !vec::is_empty(es) => {\n             let mut blk : ~[u8] = ~[];\n-            for vec::each(es) |e| {\n-                let (k,v) = e;\n+            for vec::each_ref(es) |e| {\n+                let (k,v) = *e;\n                 let t = fmt!(\"%s=%s\", k, v);\n                 let mut v : ~[u8] = ::unsafe::reinterpret_cast(&t);\n                 blk += v;"}, {"sha": "0a668157892049092dbe44031ba6aca218db1d06", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -312,7 +312,7 @@ mod linear {\n         }\n \n         pure fn each_ref(&self, blk: fn(k: &K, v: &V) -> bool) {\n-            for vec::each(self.buckets) |slot| {\n+            for vec::each_ref(self.buckets) |slot| {\n                 let mut broke = false;\n                 do slot.iter |bucket| {\n                     if !blk(&bucket.key, &bucket.value) {"}, {"sha": "c97588e0a3334fca0f02041abb75fb3d670ef740", "filename": "src/libcore/str.rs", "status": "modified", "additions": 72, "deletions": 62, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -72,12 +72,12 @@ export\n    map,\n    each, eachi,\n    each_char, each_chari,\n-   bytes_iter,\n-   chars_iter,\n-   split_char_iter,\n-   splitn_char_iter,\n-   words_iter,\n-   lines_iter,\n+   bytes_each,\n+   chars_each,\n+   split_char_each,\n+   splitn_char_each,\n+   words_each,\n+   lines_each,\n \n    // Searching\n    find, find_from, find_between,\n@@ -235,7 +235,9 @@ pure fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(buf, chs.len());\n-        for vec::each(chs) |ch| { push_char(buf, ch); }\n+        for vec::each_ref(chs) |ch| {\n+            push_char(buf, *ch);\n+        }\n     }\n     move buf\n }\n@@ -289,16 +291,18 @@ pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n /// Concatenate a vector of strings\n pure fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n-    for vec::each(v) |ss| { unsafe { push_str(s, ss) }; }\n+    for vec::each_ref(v) |ss| {\n+        unsafe { push_str(s, *ss) };\n+    }\n     move s\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n pure fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n-    for vec::each(v) |ss| {\n+    for vec::each_ref(v) |ss| {\n         if first { first = false; } else { unsafe { push_str(s, sep); } }\n-        unsafe { push_str(s, ss) };\n+        unsafe { push_str(s, *ss) };\n     }\n     move s\n }\n@@ -879,20 +883,20 @@ pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(result, len(ss));\n-        do chars_iter(ss) |cc| {\n+        for chars_each(ss) |cc| {\n             str::push_char(result, ff(cc));\n         }\n     }\n     move result\n }\n \n /// Iterate over the bytes in a string\n-pure fn bytes_iter(ss: &str, it: fn(u8)) {\n+pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n     while (pos < len) {\n-        it(ss[pos]);\n+        if !it(ss[pos]) { return; }\n         pos += 1u;\n     }\n }\n@@ -933,40 +937,40 @@ pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n }\n \n /// Iterate over the characters in a string\n-pure fn chars_iter(s: &str, it: fn(char)) {\n+pure fn chars_each(s: &str, it: fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n         let {ch, next} = char_range_at(s, pos);\n         pos = next;\n-        it(ch);\n+        if !it(ch) { return; }\n     }\n }\n \n /// Apply a function to each substring after splitting by character\n-pure fn split_char_iter(ss: &str, cc: char, ff: fn(&&~str)) {\n-   vec::iter(split_char(ss, cc), ff)\n+pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n+    vec::each_ref(split_char(ss, cc), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each substring after splitting by character, up to\n  * `count` times\n  */\n-pure fn splitn_char_iter(ss: &str, sep: char, count: uint,\n-                         ff: fn(&&~str)) {\n-   vec::iter(splitn_char(ss, sep, count), ff)\n+pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n+                         ff: fn(v: &str) -> bool) {\n+    vec::each_ref(splitn_char(ss, sep, count), |s| ff(*s))\n }\n \n /// Apply a function to each word\n-pure fn words_iter(ss: &str, ff: fn(&&~str)) {\n-    vec::iter(words(ss), ff)\n+pure fn words_each(ss: &str, ff: fn(v: &str) -> bool) {\n+    vec::each_ref(words(ss), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each line (by '\\n')\n  */\n-pure fn lines_iter(ss: &str, ff: fn(&&~str)) {\n-    vec::iter(lines(ss), ff)\n+pure fn lines_each(ss: &str, ff: fn(v: &str) -> bool) {\n+    vec::each_ref(lines(ss), |s| ff(*s))\n }\n \n /*\n@@ -1518,7 +1522,7 @@ pure fn is_utf16(v: &[u16]) -> bool {\n /// Converts to a vector of `u16` encoded as UTF-16\n pure fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n-    do chars_iter(s) |cch| {\n+    for chars_each(s) |cch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = cch as u32;\n \n@@ -1947,7 +1951,9 @@ pure fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(out, str::len(s));\n-        chars_iter(s, |c| push_str(out, char::escape_default(c)));\n+        for chars_each(s) |c| {\n+            push_str(out, char::escape_default(c));\n+        }\n     }\n     move out\n }\n@@ -1957,7 +1963,9 @@ pure fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(out, str::len(s));\n-        chars_iter(s, |c| push_str(out, char::escape_unicode(c)));\n+        for chars_each(s) |c| {\n+            push_str(out, char::escape_unicode(c));\n+        }\n     }\n     move out\n }\n@@ -2094,7 +2102,7 @@ mod raw {\n     /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n     unsafe fn push_bytes(&s: ~str, bytes: ~[u8]) {\n         reserve_at_least(s, s.len() + bytes.len());\n-        for vec::each(bytes) |byte| { push_byte(s, byte); }\n+        for vec::each_ref(bytes) |byte| { push_byte(s, *byte); }\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n@@ -3044,105 +3052,107 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_chars_iter() {\n+    fn test_chars_each() {\n         let mut i = 0;\n-        do chars_iter(~\"x\\u03c0y\") |ch| {\n+        for chars_each(~\"x\\u03c0y\") |ch| {\n             match i {\n               0 => assert ch == 'x',\n               1 => assert ch == '\\u03c0',\n               2 => assert ch == 'y',\n-              _ => fail ~\"test_chars_iter failed\"\n+              _ => fail ~\"test_chars_each failed\"\n             }\n             i += 1;\n         }\n \n-        chars_iter(~\"\", |_ch| fail ); // should not fail\n+        chars_each(~\"\", |_ch| fail ); // should not fail\n     }\n \n     #[test]\n-    fn test_bytes_iter() {\n+    fn test_bytes_each() {\n         let mut i = 0;\n \n-        do bytes_iter(~\"xyz\") |bb| {\n+        for bytes_each(~\"xyz\") |bb| {\n             match i {\n               0 => assert bb == 'x' as u8,\n               1 => assert bb == 'y' as u8,\n               2 => assert bb == 'z' as u8,\n-              _ => fail ~\"test_bytes_iter failed\"\n+              _ => fail ~\"test_bytes_each failed\"\n             }\n             i += 1;\n         }\n \n-        bytes_iter(~\"\", |bb| assert bb == 0u8);\n+        for bytes_each(~\"\") |bb| {\n+            assert bb == 0u8;\n+        }\n     }\n \n     #[test]\n-    fn test_split_char_iter() {\n+    fn test_split_char_each() {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n-        do split_char_iter(data, ' ') |xx| {\n+        for split_char_each(data, ' ') |xx| {\n             match ii {\n-              0 => assert ~\"\\nMary\" == xx,\n-              1 => assert ~\"had\"    == xx,\n-              2 => assert ~\"a\"      == xx,\n-              3 => assert ~\"little\" == xx,\n+              0 => assert \"\\nMary\" == xx,\n+              1 => assert \"had\"    == xx,\n+              2 => assert \"a\"      == xx,\n+              3 => assert \"little\" == xx,\n               _ => ()\n             }\n             ii += 1;\n         }\n     }\n \n     #[test]\n-    fn test_splitn_char_iter() {\n+    fn test_splitn_char_each() {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n-        do splitn_char_iter(data, ' ', 2u) |xx| {\n+        for splitn_char_each(data, ' ', 2u) |xx| {\n             match ii {\n-              0 => assert ~\"\\nMary\" == xx,\n-              1 => assert ~\"had\"    == xx,\n-              2 => assert ~\"a little lamb\\nLittle lamb\\n\" == xx,\n+              0 => assert \"\\nMary\" == xx,\n+              1 => assert \"had\"    == xx,\n+              2 => assert \"a little lamb\\nLittle lamb\\n\" == xx,\n               _ => ()\n             }\n             ii += 1;\n         }\n     }\n \n     #[test]\n-    fn test_words_iter() {\n+    fn test_words_each() {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n-        do words_iter(data) |ww| {\n+        for words_each(data) |ww| {\n             match ii {\n-              0 => assert ~\"Mary\"   == ww,\n-              1 => assert ~\"had\"    == ww,\n-              2 => assert ~\"a\"      == ww,\n-              3 => assert ~\"little\" == ww,\n+              0 => assert \"Mary\"   == ww,\n+              1 => assert \"had\"    == ww,\n+              2 => assert \"a\"      == ww,\n+              3 => assert \"little\" == ww,\n               _ => ()\n             }\n             ii += 1;\n         }\n \n-        words_iter(~\"\", |_x| fail); // should not fail\n+        words_each(~\"\", |_x| fail); // should not fail\n     }\n \n     #[test]\n-    fn test_lines_iter () {\n+    fn test_lines_each () {\n         let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n-        do lines_iter(lf) |x| {\n+        for lines_each(lf) |x| {\n             match ii {\n-                0 => assert ~\"\" == x,\n-                1 => assert ~\"Mary had a little lamb\" == x,\n-                2 => assert ~\"Little lamb\" == x,\n-                3 => assert ~\"\" == x,\n+                0 => assert \"\" == x,\n+                1 => assert \"Mary had a little lamb\" == x,\n+                2 => assert \"Little lamb\" == x,\n+                3 => assert \"\" == x,\n                 _ => ()\n             }\n             ii += 1;\n@@ -3220,8 +3230,8 @@ mod tests {\n                0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                0x000a_u16 ]) ];\n \n-        for vec::each(pairs) |p| {\n-            let (s, u) = copy p;\n+        for vec::each_ref(pairs) |p| {\n+            let (s, u) = copy *p;\n             assert to_utf16(s) == u;\n             assert from_utf16(u) == s;\n             assert from_utf16(to_utf16(s)) == s;"}, {"sha": "69c905f68fd951e448f60f4b040bddadbc355dce", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -75,7 +75,7 @@ impl<A: ToStr Copy, B: ToStr Copy, C: ToStr Copy> (A, B, C): ToStr {\n impl<A: ToStr> ~[A]: ToStr {\n     fn to_str() -> ~str {\n         let mut acc = ~\"[\", first = true;\n-        for vec::each(self) |elt| {\n+        for vec::each_ref(self) |elt| {\n             if first { first = false; }\n             else { str::push_str(acc, ~\", \"); }\n             str::push_str(acc, elt.to_str());"}, {"sha": "3b041adc030adfe82ebabc9faca25921799ec470", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 24, "deletions": 136, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -76,12 +76,9 @@ export zip, zip_slice;\n export swap;\n export reverse;\n export reversed;\n-export iter, iter_between, each, eachi, reach, reachi;\n+export each, eachi, reach, reachi;\n export each_ref, each_mut_ref, each_const_ref;\n export iter2;\n-export iteri;\n-export riter;\n-export riteri;\n export permute;\n export windowed;\n export as_imm_buf;\n@@ -857,16 +854,16 @@ pure fn connect<T: Copy>(v: &[~[T]], sep: T) -> ~[T] {\n /// Reduce a vector from left to right\n pure fn foldl<T: Copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n     let mut accum = z;\n-    do iter(v) |elt| {\n-        accum = p(accum, elt);\n+    for each_ref(v) |elt| {\n+        accum = p(accum, *elt);\n     }\n     return accum;\n }\n \n /// Reduce a vector from right to left\n pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n-    do riter(v) |elt| {\n+    for reach(v) |elt| {\n         accum = p(elt, accum);\n     }\n     return accum;\n@@ -1150,7 +1147,6 @@ fn reverse<T>(v: &[mut T]) {\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n }\n \n-\n /// Returns a vector with the order of elements reversed\n pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n@@ -1163,43 +1159,6 @@ pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     move rs\n }\n \n-/**\n- * Iterates over a slice\n- *\n- * Iterates over slice `v` and, for each element, calls function `f` with the\n- * element's value.\n- */\n-#[inline(always)]\n-pure fn iter<T>(v: &[T], f: fn(T)) {\n-    iter_between(v, 0u, vec::len(v), f)\n-}\n-\n-/*\n-Function: iter_between\n-\n-Iterates over a slice\n-\n-Iterates over slice `v` and, for each element, calls function `f` with the\n-element's value.\n-\n-*/\n-#[inline(always)]\n-pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n-    do as_imm_buf(v) |base_ptr, len| {\n-        assert start <= end;\n-        assert end <= len;\n-        unsafe {\n-            let mut n = end;\n-            let mut p = ptr::offset(base_ptr, start);\n-            while n > start {\n-                f(*p);\n-                p = ptr::offset(p, 1u);\n-                n -= 1u;\n-            }\n-        }\n-    }\n-}\n-\n /**\n  * Iterates over a vector, with option to break\n  *\n@@ -1344,43 +1303,6 @@ fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(U, T)) {\n     }\n }\n \n-/**\n- * Iterates over a vector's elements and indexes\n- *\n- * Iterates over vector `v` and, for each element, calls function `f` with the\n- * element's value and index.\n- */\n-#[inline(always)]\n-pure fn iteri<T>(v: &[T], f: fn(uint, T)) {\n-    let mut i = 0u;\n-    let l = len(v);\n-    while i < l { f(i, v[i]); i += 1u; }\n-}\n-\n-/**\n- * Iterates over a vector in reverse\n- *\n- * Iterates over vector `v` and, for each element, calls function `f` with the\n- * element's value.\n- */\n-pure fn riter<T>(v: &[T], f: fn(T)) {\n-    riteri(v, |_i, v| f(v))\n-}\n-\n-/**\n- * Iterates over a vector's elements and indexes in reverse\n- *\n- * Iterates over vector `v` and, for each element, calls function `f` with the\n- * element's value and index.\n- */\n-pure fn riteri<T>(v: &[T], f: fn(uint, T)) {\n-    let mut i = len(v);\n-    while 0u < i {\n-        i -= 1u;\n-        f(i, v[i]);\n-    };\n-}\n-\n /**\n  * Iterate over all permutations of vector `v`.\n  *\n@@ -1414,12 +1336,12 @@ pure fn permute<T: Copy>(v: &[const T], put: fn(~[T])) {\n pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     assert 1u <= nn;\n-    vec::iteri (xx, |ii, _x| {\n+    for vec::eachi (xx) |ii, _x| {\n         let len = vec::len(xx);\n         if ii+nn <= len unsafe {\n             vec::push(ww, vec::slice(xx, ii, ii+nn));\n         }\n-    });\n+    }\n     move ww\n }\n \n@@ -1626,10 +1548,6 @@ impl<T: Copy> &[const T]: CopyableVector<T> {\n \n trait ImmutableVector<T> {\n     pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U;\n-    pure fn iter(f: fn(T));\n-    pure fn iteri(f: fn(uint, T));\n-    pure fn riter(f: fn(T));\n-    pure fn riteri(f: fn(uint, T));\n     pure fn map<U>(f: fn(T) -> U) -> ~[U];\n     pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U];\n     fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n@@ -1650,38 +1568,6 @@ impl<T> &[T]: ImmutableVector<T> {\n     /// Reduce a vector from right to left\n     #[inline]\n     pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n-    /**\n-     * Iterates over a vector\n-     *\n-     * Iterates over vector `v` and, for each element, calls function `f` with\n-     * the element's value.\n-     */\n-    #[inline]\n-    pure fn iter(f: fn(T)) { iter(self, f) }\n-    /**\n-     * Iterates over a vector's elements and indexes\n-     *\n-     * Iterates over vector `v` and, for each element, calls function `f` with\n-     * the element's value and index.\n-     */\n-    #[inline]\n-    pure fn iteri(f: fn(uint, T)) { iteri(self, f) }\n-    /**\n-     * Iterates over a vector in reverse\n-     *\n-     * Iterates over vector `v` and, for each element, calls function `f` with\n-     * the element's value.\n-     */\n-    #[inline]\n-    pure fn riter(f: fn(T)) { riter(self, f) }\n-    /**\n-     * Iterates over a vector's elements and indexes in reverse\n-     *\n-     * Iterates over vector `v` and, for each element, calls function `f` with\n-     * the element's value and index.\n-     */\n-    #[inline]\n-    pure fn riteri(f: fn(uint, T)) { riteri(self, f) }\n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n     pure fn map<U>(f: fn(T) -> U) -> ~[U] { map(self, f) }\n@@ -2465,55 +2351,57 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_iter_empty() {\n-        let mut i = 0;\n-        iter::<int>(~[], |_v| i += 1);\n-        assert i == 0;\n+    fn test_each_empty() {\n+        for each_ref::<int>(~[]) |_v| {\n+            fail; // should never be executed\n+        }\n     }\n \n     #[test]\n     fn test_iter_nonempty() {\n         let mut i = 0;\n-        iter(~[1, 2, 3], |v| i += v);\n+        for each_ref(~[1, 2, 3]) |v| {\n+            i += *v;\n+        }\n         assert i == 6;\n     }\n \n     #[test]\n     fn test_iteri() {\n         let mut i = 0;\n-        iteri(~[1, 2, 3], |j, v| {\n+        for eachi(~[1, 2, 3]) |j, v| {\n             if i == 0 { assert v == 1; }\n             assert j + 1u == v as uint;\n             i += v;\n-        });\n+        }\n         assert i == 6;\n     }\n \n     #[test]\n-    fn test_riter_empty() {\n-        let mut i = 0;\n-        riter::<int>(~[], |_v| i += 1);\n-        assert i == 0;\n+    fn test_reach_empty() {\n+        for reach::<int>(~[]) |_v| {\n+            fail; // should never execute\n+        }\n     }\n \n     #[test]\n     fn test_riter_nonempty() {\n         let mut i = 0;\n-        riter(~[1, 2, 3], |v| {\n+        for reach(~[1, 2, 3]) |v| {\n             if i == 0 { assert v == 3; }\n             i += v\n-        });\n+        }\n         assert i == 6;\n     }\n \n     #[test]\n-    fn test_riteri() {\n+    fn test_reachi() {\n         let mut i = 0;\n-        riteri(~[0, 1, 2], |j, v| {\n+        for reachi(~[0, 1, 2]) |j, v| {\n             if i == 0 { assert v == 2; }\n             assert j == v as uint;\n             i += v;\n-        });\n+        }\n         assert i == 3;\n     }\n "}, {"sha": "505385aa9dfbb6ff59fd2f32ef51ccee7da639c6", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -642,6 +642,7 @@ mod tests {\n                 c.send(());\n             }\n         }\n+\n         // Readers try to catch the writer in the act\n         let mut children = ~[];\n         for 5.times {\n@@ -652,8 +653,10 @@ mod tests {\n                 }\n             }\n         }\n+\n         // Wait for children to pass their asserts\n-        for vec::each(children) |r| { future::get(&r); }\n+        for vec::each_ref(children) |r| { future::get(r); }\n+\n         // Wait for writer to finish\n         p.recv();\n         do arc.read |num| { assert *num == 10; }\n@@ -713,17 +716,17 @@ mod tests {\n                 assert *state == 42;\n                 *state = 31337;\n                 // send to other readers\n-                for vec::each(reader_convos) |x| {\n-                    match x {\n+                for vec::each_ref(reader_convos) |x| {\n+                    match *x {\n                         (rc, _) => rc.send(()),\n                     }\n                 }\n             }\n             let read_mode = arc.downgrade(write_mode);\n             do (&read_mode).read |state| {\n                 // complete handshake with other readers\n-                for vec::each(reader_convos) |x| {\n-                    match x {\n+                for vec::each_ref(reader_convos) |x| {\n+                    match *x {\n                         (_, rp) => rp.recv(),\n                     }\n                 }"}, {"sha": "788802ed58c09068f18bce507d1d838451807b73", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -292,16 +292,16 @@ fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                 }\n             }\n             let mut name_pos = 0u;\n-            for vec::each(names) |nm| {\n+            for vec::each_ref(names) |nm| {\n                 name_pos += 1u;\n-                let optid = match find_opt(opts, nm) {\n+                let optid = match find_opt(opts, *nm) {\n                   Some(id) => id,\n-                  None => return Err(UnrecognizedOption(name_str(&nm)))\n+                  None => return Err(UnrecognizedOption(name_str(nm)))\n                 };\n                 match opts[optid].hasarg {\n                   No => {\n                     if !option::is_none::<~str>(i_arg) {\n-                        return Err(UnexpectedArgument(name_str(&nm)));\n+                        return Err(UnexpectedArgument(name_str(nm)));\n                     }\n                     vec::push(vals[optid], Given);\n                   }\n@@ -318,7 +318,7 @@ fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                         vec::push(vals[optid],\n                                   Val(option::get::<~str>(i_arg)));\n                     } else if i + 1u == l {\n-                        return Err(ArgumentMissing(name_str(&nm)));\n+                        return Err(ArgumentMissing(name_str(nm)));\n                     } else { i += 1u; vec::push(vals[optid], Val(args[i])); }\n                   }\n                 }\n@@ -366,8 +366,8 @@ fn opt_present(+mm: Matches, nm: &str) -> bool {\n \n /// Returns true if any of several options were matched\n fn opts_present(+mm: Matches, names: &[~str]) -> bool {\n-    for vec::each(names) |nm| {\n-        match find_opt(mm.opts, mkname(nm)) {\n+    for vec::each_ref(names) |nm| {\n+        match find_opt(mm.opts, mkname(*nm)) {\n           Some(_) => return true,\n           None    => ()\n         }\n@@ -393,8 +393,8 @@ fn opt_str(+mm: Matches, nm: &str) -> ~str {\n  * option took an argument\n  */\n fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n-    for vec::each(names) |nm| {\n-        match opt_val(mm, nm) {\n+    for vec::each_ref(names) |nm| {\n+        match opt_val(mm, *nm) {\n           Val(s) => return s,\n           _ => ()\n         }\n@@ -411,8 +411,8 @@ fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n  */\n fn opt_strs(+mm: Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n-    for vec::each(opt_vals(mm, nm)) |v| {\n-        match v { Val(s) => vec::push(acc, s), _ => () }\n+    for vec::each_ref(opt_vals(mm, nm)) |v| {\n+        match *v { Val(s) => vec::push(acc, s), _ => () }\n     }\n     return acc;\n }"}, {"sha": "88b46f490ac09a68487c5d8b3e7906a61cdc9c8f", "filename": "src/libstd/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -179,7 +179,7 @@ fn to_writer_pretty(wr: io::Writer, j: Json, indent: uint) {\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n-    do str::chars_iter(s) |c| {\n+    for str::chars_each(s) |c| {\n         match c {\n           '\"' => escaped += ~\"\\\\\\\"\",\n           '\\\\' => escaped += ~\"\\\\\\\\\",\n@@ -834,8 +834,8 @@ mod tests {\n     fn mk_dict(items: &[(~str, Json)]) -> Json {\n         let d = map::str_hash();\n \n-        do vec::iter(items) |item| {\n-            let (key, value) = copy item;\n+        for vec::each_ref(items) |item| {\n+            let (key, value) = copy *item;\n             d.insert(key, value);\n         };\n "}, {"sha": "4b41b81d4e511434540181c0377895c711c36204", "filename": "src/libstd/map.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -435,9 +435,12 @@ fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n     items: &[(K, V)]) -> HashMap<K, V> {\n     let map = HashMap();\n-    do vec::iter(items) |item| {\n-        let (key, value) = item;\n-        map.insert(key, value);\n+    for vec::each_ref(items) |item| {\n+        match *item {\n+            (key, value) => {\n+                map.insert(key, value);\n+            }\n+        }\n     }\n     map\n }"}, {"sha": "13442994b657b7611c6f514fb8e6f0b6ecff6629", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -363,13 +363,13 @@ mod test {\n         let results = result::unwrap(ga_result);\n         log(debug, fmt!(\"test_get_addr: Number of results for %s: %?\",\n                         localhost_name, vec::len(results)));\n-        for vec::each(results) |r| {\n-            let ipv_prefix = match r {\n+        for vec::each_ref(results) |r| {\n+            let ipv_prefix = match *r {\n               Ipv4(_) => ~\"IPv4\",\n               Ipv6(_) => ~\"IPv6\"\n             };\n             log(debug, fmt!(\"test_get_addr: result %s: '%s'\",\n-                            ipv_prefix, format_addr(&r)));\n+                            ipv_prefix, format_addr(r)));\n         }\n         // at least one result.. this is going to vary from system\n         // to system, based on stuff like the contents of /etc/hosts"}, {"sha": "72b3c747e35b354896d7d5adcbe388b21ffa6bc3", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -91,7 +91,7 @@ trait Deserializer {\n \n fn emit_from_vec<S: Serializer, T>(s: S, v: ~[T], f: fn(T)) {\n     do s.emit_vec(vec::len(v)) {\n-        do vec::iteri(v) |i,e| {\n+        for vec::eachi(v) |i,e| {\n             do s.emit_vec_elt(i) {\n                 f(e)\n             }"}, {"sha": "fc34ca0cd10c33cfb2c9b6ee035960081bd82a7d", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -65,8 +65,8 @@ fn sha1() -> Sha1 {\n \n     fn add_input(st: &Sha1State, msg: &[u8]) {\n         assert (!st.computed);\n-        for vec::each(msg) |element| {\n-            st.msg_block[st.msg_block_idx] = element;\n+        for vec::each_ref(msg) |element| {\n+            st.msg_block[st.msg_block_idx] = *element;\n             st.msg_block_idx += 1u;\n             st.len_low += 8u32;\n             if st.len_low == 0u32 {\n@@ -240,7 +240,9 @@ fn sha1() -> Sha1 {\n         fn result_str() -> ~str {\n             let rr = mk_result(&self);\n             let mut s = ~\"\";\n-            for vec::each(rr) |b| { s += uint::to_str(b as uint, 16u); }\n+            for vec::each_ref(rr) |b| {\n+                s += uint::to_str(*b as uint, 16u);\n+            }\n             return s;\n         }\n     }\n@@ -329,7 +331,7 @@ mod tests {\n         // Test that it works when accepting the message all at once\n \n         let sh = sha1::sha1();\n-        for vec::each(tests) |t| {\n+        for vec::each_ref(tests) |t| {\n             sh.input_str(t.input);\n             let out = sh.result();\n             check_vec_eq(t.output, out);\n@@ -338,7 +340,7 @@ mod tests {\n \n \n         // Test that it works when accepting the message in pieces\n-        for vec::each(tests) |t| {\n+        for vec::each_ref(tests) |t| {\n             let len = str::len(t.input);\n             let mut left = len;\n             while left > 0u {"}, {"sha": "97bc1b0a115309e416c54241620ca844e78bc1ee", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -259,8 +259,8 @@ mod test_qsort {\n         let immut_names = vec::from_mut(names);\n \n         let pairs = vec::zip(expected, immut_names);\n-        for vec::each(pairs) |p| {\n-            let (a, b) = p;\n+        for vec::each_ref(pairs) |p| {\n+            let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n             assert (a == b);\n         }"}, {"sha": "53d41bce97776f346485e29b11b6dfc9f6baa741", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -941,7 +941,7 @@ mod tests {\n                     }\n                 }\n             }\n-            for vec::each(sibling_convos) |p| {\n+            for vec::each_ref(sibling_convos) |p| {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             do m2.lock { }\n@@ -950,7 +950,7 @@ mod tests {\n         };\n         assert result.is_err();\n         // child task must have finished by the time try returns\n-        for vec::each(p.recv()) |p| { p.recv(); } // wait on all its siblings\n+        for vec::each_ref(p.recv()) |p| { p.recv(); } // wait on all its siblings\n         do m.lock_cond |cond| {\n             let woken = cond.broadcast();\n             assert woken == 0;"}, {"sha": "6af6a5181eca026e1da323db9d2ade46099cf0d8", "filename": "src/libstd/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -39,8 +39,8 @@ fn color_supported() -> bool {\n                            ~\"screen-bce\", ~\"xterm-256color\"];\n     return match os::getenv(~\"TERM\") {\n           option::Some(env) => {\n-            for vec::each(supported_terms) |term| {\n-                if term == env { return true; }\n+            for vec::each_ref(supported_terms) |term| {\n+                if *term == env { return true; }\n             }\n             false\n           }"}, {"sha": "3d4549dd423c3f8b7335ec7b211c5d229bbcb29d", "filename": "src/libstd/test.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -226,8 +226,8 @@ fn print_failures(st: ConsoleTestState) {\n     let failures = copy st.failures;\n     let failures = vec::map(failures, |test| test.name);\n     let failures = sort::merge_sort(|x, y| str::le(*x, *y), failures);\n-    for vec::each(failures) |name| {\n-        st.out.write_line(fmt!(\"    %s\", name));\n+    for vec::each_ref(failures) |name| {\n+        st.out.write_line(fmt!(\"    %s\", *name));\n     }\n }\n \n@@ -535,30 +535,34 @@ mod tests {\n              ~\"test::sort_tests\"];\n         let tests =\n         {\n-        let testfn = fn~() { };\n-        let mut tests = ~[];\n-            for vec::each(names) |name| {\n-            let test = {name: name, testfn: copy testfn, ignore: false,\n-                        should_fail: false};\n-            tests += ~[test];\n-        }\n-        tests\n-    };\n-    let filtered = filter_tests(opts, tests);\n+            let testfn = fn~() { };\n+            let mut tests = ~[];\n+            for vec::each_ref(names) |name| {\n+                let test = {name: *name, testfn: copy testfn, ignore: false,\n+                            should_fail: false};\n+                vec::push(tests, test);\n+            }\n+            tests\n+        };\n+        let filtered = filter_tests(opts, tests);\n \n-    let expected =\n-        ~[~\"int::test_pow\", ~\"int::test_to_str\", ~\"sha1::test\",\n-          ~\"test::do_not_run_ignored_tests\",\n-          ~\"test::filter_for_ignored_option\",\n-          ~\"test::first_free_arg_should_be_a_filter\",\n-          ~\"test::ignored_tests_result_in_ignored\",\n-          ~\"test::parse_ignored_flag\",\n-          ~\"test::sort_tests\"];\n+        let expected =\n+            ~[~\"int::test_pow\", ~\"int::test_to_str\", ~\"sha1::test\",\n+              ~\"test::do_not_run_ignored_tests\",\n+              ~\"test::filter_for_ignored_option\",\n+              ~\"test::first_free_arg_should_be_a_filter\",\n+              ~\"test::ignored_tests_result_in_ignored\",\n+              ~\"test::parse_ignored_flag\",\n+              ~\"test::sort_tests\"];\n \n-    let pairs = vec::zip(expected, filtered);\n+        let pairs = vec::zip(expected, filtered);\n \n-    for vec::each(pairs) |p| { let (a, b) = copy p; assert (a == b.name); }\n-}\n+        for vec::each_ref(pairs) |p| {\n+            match *p {\n+                (a, b) => { assert (a == b.name); }\n+            }\n+        }\n+    }\n }\n \n "}, {"sha": "df3534fdf86252c075bf92cec3087e2b059083fe", "filename": "src/libstd/time.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -1023,27 +1023,31 @@ mod tests {\n             }\n         }\n \n-        [\n+        for vec::each_ref([\n             ~\"Sunday\",\n             ~\"Monday\",\n             ~\"Tuesday\",\n             ~\"Wednesday\",\n             ~\"Thursday\",\n             ~\"Friday\",\n             ~\"Saturday\"\n-        ]/_.iter(|day| assert test(day, ~\"%A\"));\n+        ]) |day| {\n+            assert test(*day, ~\"%A\");\n+        }\n \n-        [\n+        for vec::each_ref([\n             ~\"Sun\",\n             ~\"Mon\",\n             ~\"Tue\",\n             ~\"Wed\",\n             ~\"Thu\",\n             ~\"Fri\",\n             ~\"Sat\"\n-        ]/_.iter(|day| assert test(day, ~\"%a\"));\n+        ]) |day| {\n+            assert test(*day, ~\"%a\");\n+        }\n \n-        [\n+        for vec::each_ref([\n             ~\"January\",\n             ~\"February\",\n             ~\"March\",\n@@ -1056,9 +1060,11 @@ mod tests {\n             ~\"October\",\n             ~\"November\",\n             ~\"December\"\n-        ]/_.iter(|day| assert test(day, ~\"%B\"));\n+        ]) |day| {\n+            assert test(*day, ~\"%B\");\n+        }\n \n-        [\n+        for vec::each_ref([\n             ~\"Jan\",\n             ~\"Feb\",\n             ~\"Mar\",\n@@ -1071,7 +1077,9 @@ mod tests {\n             ~\"Oct\",\n             ~\"Nov\",\n             ~\"Dec\"\n-        ]/_.iter(|day| assert test(day, ~\"%b\"));\n+        ]) |day| {\n+            assert test(*day, ~\"%b\");\n+        }\n \n         assert test(~\"19\", ~\"%C\");\n         assert test(~\"Fri Feb 13 23:31:30 2009\", ~\"%c\");"}, {"sha": "9b6c2947a3b6a75b205737aaa82e1925afa6e50c", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -293,8 +293,10 @@ fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n     }\n     let d_id = ast_util::local_def(id);\n     let p = extend(cx, ident);\n-     // only need to handle methods\n-    do vec::iter(struct_def.methods) |m| { map_method(d_id, p, m, cx); }\n+    // only need to handle methods\n+    for vec::each_ref(struct_def.methods) |m| {\n+        map_method(d_id, p, *m, cx);\n+    }\n }\n \n fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {"}, {"sha": "a503641fdf3171d2ea571f8d864af6bfa7a27ea3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -429,13 +429,13 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             match vi.node {\n               view_item_use(_, _, id) => vfn(id),\n               view_item_import(vps) | view_item_export(vps) => {\n-                do vec::iter(vps) |vp| {\n-                    match vp.node {\n-                      view_path_simple(_, _, _, id) => vfn(id),\n-                      view_path_glob(_, id) => vfn(id),\n-                      view_path_list(_, _, id) => vfn(id)\n-                    }\n-                }\n+                  for vec::each_ref(vps) |vp| {\n+                      match vp.node {\n+                          view_path_simple(_, _, _, id) => vfn(id),\n+                          view_path_glob(_, id) => vfn(id),\n+                          view_path_list(_, _, id) => vfn(id)\n+                      }\n+                  }\n               }\n             }\n         },\n@@ -490,42 +490,44 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         },\n \n         visit_ty_params: fn@(ps: ~[ty_param]) {\n-            vec::iter(ps, |p| vfn(p.id))\n+            for vec::each_ref(ps) |p| {\n+                vfn(p.id);\n+            }\n         },\n \n         visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n                       _b: ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n             match fk {\n-              visit::fk_ctor(_, _, tps, self_id, parent_id) => {\n-                vec::iter(tps, |tp| vfn(tp.id));\n-                vfn(id);\n-                vfn(self_id);\n-                vfn(parent_id.node);\n-              }\n-              visit::fk_dtor(tps, _, self_id, parent_id) => {\n-                vec::iter(tps, |tp| vfn(tp.id));\n-                vfn(id);\n-                vfn(self_id);\n-                vfn(parent_id.node);\n-              }\n-              visit::fk_item_fn(_, tps, _) => {\n-                vec::iter(tps, |tp| vfn(tp.id));\n-              }\n-              visit::fk_method(_, tps, m) => {\n-                vfn(m.self_id);\n-                vec::iter(tps, |tp| vfn(tp.id));\n-              }\n-              visit::fk_anon(_, capture_clause)\n-              | visit::fk_fn_block(capture_clause) => {\n-                for vec::each(*capture_clause) |clause| {\n-                    vfn(clause.id);\n+                visit::fk_ctor(_, _, tps, self_id, parent_id) => {\n+                    for vec::each_ref(tps) |tp| { vfn(tp.id); }\n+                    vfn(id);\n+                    vfn(self_id);\n+                    vfn(parent_id.node);\n+                }\n+                visit::fk_dtor(tps, _, self_id, parent_id) => {\n+                    for vec::each_ref(tps) |tp| { vfn(tp.id); }\n+                    vfn(id);\n+                    vfn(self_id);\n+                    vfn(parent_id.node);\n+                }\n+                visit::fk_item_fn(_, tps, _) => {\n+                    for vec::each_ref(tps) |tp| { vfn(tp.id); }\n+                }\n+                visit::fk_method(_, tps, m) => {\n+                    vfn(m.self_id);\n+                    for vec::each_ref(tps) |tp| { vfn(tp.id); }\n+                }\n+                visit::fk_anon(_, capture_clause) |\n+                visit::fk_fn_block(capture_clause) => {\n+                    for vec::each_ref(*capture_clause) |clause| {\n+                        vfn(clause.id);\n+                    }\n                 }\n-              }\n             }\n \n-            do vec::iter(d.inputs) |arg| {\n+            for vec::each_ref(d.inputs) |arg| {\n                 vfn(arg.id)\n             }\n         },"}, {"sha": "da37e44b58c63105601a07fd9d266edd86e10314", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -228,7 +228,7 @@ fn finish<T: qq_helper>\n     let mut state = active;\n     let mut i = 0u, j = 0u;\n     let g_len = cx.gather.len();\n-    do str::chars_iter(*str) |ch| {\n+    for str::chars_each(*str) |ch| {\n         if (j < g_len && i == cx.gather[j].lo) {\n             assert ch == '$';\n             let repl = fmt!(\"$%u \", j);"}, {"sha": "a5103309e8cd118f6ccf388b4a22f32758612550", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -208,10 +208,10 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n pure fn follow(m: arb_depth<matchable>, idx_path: &[uint]) ->\n    arb_depth<matchable> {\n     let mut res: arb_depth<matchable> = m;\n-    for vec::each(idx_path) |idx| {\n+    for vec::each_ref(idx_path) |idx| {\n         res = match res {\n           leaf(_) => return res,/* end of the line */\n-          seq(new_ms, _) => new_ms[idx]\n+          seq(new_ms, _) => new_ms[*idx]\n         }\n     }\n     return res;"}, {"sha": "c7aa724d9fd7a1a8138d897f0f10d8dccb0f45a0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -1672,9 +1672,9 @@ fn print_arg_mode(s: ps, m: ast::mode) {\n fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n     if vec::len(*bounds) > 0u {\n         word(s.s, ~\":\");\n-        for vec::each(*bounds) |bound| {\n+        for vec::each_ref(*bounds) |bound| {\n             nbsp(s);\n-            match bound {\n+            match *bound {\n               ast::bound_copy => word(s.s, ~\"Copy\"),\n               ast::bound_send => word(s.s, ~\"Send\"),\n               ast::bound_const => word(s.s, ~\"Const\"),"}, {"sha": "befd24d80e51b95ac00534eaf538d0832c8077bf", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -262,8 +262,8 @@ fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n }\n \n fn visit_ty_param_bounds<E>(bounds: @~[ty_param_bound], e: E, v: vt<E>) {\n-    for vec::each(*bounds) |bound| {\n-        match bound {\n+    for vec::each_ref(*bounds) |bound| {\n+        match *bound {\n           bound_trait(t) => v.visit_ty(t, e, v),\n           bound_copy | bound_send | bound_const | bound_owned => ()\n         }"}, {"sha": "c56cf30d68966ed42bb4630ebc7cbebf43c29a02", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -539,7 +539,7 @@ fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n // gas doesn't!\n fn sanitize(s: ~str) -> ~str {\n     let mut result = ~\"\";\n-    do str::chars_iter(s) |c| {\n+    for str::chars_each(s) |c| {\n         match c {\n           '@' => result += ~\"_sbox_\",\n           '~' => result += ~\"_ubox_\","}, {"sha": "121b8e226ed916a529e48de9580b82de8106c164", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -99,8 +99,8 @@ fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> ~str {\n fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n                   data: crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n-    do vec::iter(decoder::get_crate_module_paths(cstore.intr, data)) |dp| {\n-        let (did, path) = dp;\n+    for vec::each_ref(decoder::get_crate_module_paths(cstore.intr, data)) |dp| {\n+        let (did, path) = *dp;\n         let d = {crate: cnum, node: did.node};\n         p(cstore).mod_path_map.insert(d, @path);\n     }"}, {"sha": "a4b830c68dcb4f8e242c43111abbcbdbb26c5d60", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -267,7 +267,9 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: ast_map::path,\n \n     do ebml_w.wr_tag(tag_path) {\n         ebml_w.wr_tagged_u32(tag_path_len, (vec::len(path) + 1u) as u32);\n-        do vec::iter(path) |pe| { encode_path_elt(ecx, ebml_w, pe); }\n+        for vec::each_ref(path) |pe| {\n+            encode_path_elt(ecx, ebml_w, *pe);\n+        }\n         encode_path_elt(ecx, ebml_w, name);\n     }\n }\n@@ -737,7 +739,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         let mut i = 0u;\n-        for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n+        for vec::each_ref(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n             match ms[i] {\n               required(ty_m) => {\n                 ebml_w.start_tag(tag_item_trait_method);\n@@ -767,8 +769,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         // method info, we output static methods with type signatures as\n         // written. Here, we output the *real* type signatures. I feel like\n         // maybe we should only ever handle the real type signatures.\n-        for vec::each(ms) |m| {\n-            let ty_m = ast_util::trait_method_to_ty_method(m);\n+        for vec::each_ref(ms) |m| {\n+            let ty_m = ast_util::trait_method_to_ty_method(*m);\n             if ty_m.self_ty.node != ast::sty_static { loop; }\n \n             vec::push(*index, {val: ty_m.id, pos: ebml_w.writer.tell()});\n@@ -888,7 +890,7 @@ fn encode_index<T>(ebml_w: ebml::Writer, buckets: ~[@~[entry<T>]],\n     for buckets.each |bucket| {\n         vec::push(bucket_locs, ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for vec::each(*bucket) |elt| {\n+        for vec::each_ref(*bucket) |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert elt.pos < 0xffff_ffff;\n             writer.write_be_u32(elt.pos as u32);"}, {"sha": "049a37a99e50a00ea7cbcef56f8fa375cbb6d371", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -365,8 +365,8 @@ fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n }\n \n fn enc_bounds(w: io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n-    for vec::each(*bs) |bound| {\n-        match bound {\n+    for vec::each_ref(*bs) |bound| {\n+        match *bound {\n           ty::bound_send => w.write_char('S'),\n           ty::bound_copy => w.write_char('C'),\n           ty::bound_const => w.write_char('K'),"}, {"sha": "98ba91628510bf2a5dcb69cd33bb4eac2128a8d1", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -108,16 +108,16 @@ fn compute_capture_vars(tcx: ty::ctxt,\n         implicit_mode = cap_copy;\n     }\n \n-    do vec::iter(*freevars) |fvar| {\n+    for vec::each_ref(*freevars) |fvar| {\n         let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n         match cap_map.find(fvar_def_id) {\n-          option::Some(_) => { /* was explicitly named, do nothing */ }\n-          option::None => {\n-            cap_map.insert(fvar_def_id, {def:fvar.def,\n-                                         span: fvar.span,\n-                                         cap_item: None,\n-                                         mode:implicit_mode});\n-          }\n+            option::Some(_) => { /* was explicitly named, do nothing */ }\n+            option::None => {\n+                cap_map.insert(fvar_def_id, {def:fvar.def,\n+                                             span: fvar.span,\n+                                             cap_item: None,\n+                                             mode:implicit_mode});\n+            }\n         }\n     }\n "}, {"sha": "af926046b4232cebfca9d40cae8a1b65743f7232", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -274,7 +274,7 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n         }\n         let variants = ty::enum_variants(tcx, eid);\n         if found.len() != (*variants).len() {\n-            for vec::each(*variants) |v| {\n+            for vec::each_ref(*variants) |v| {\n                 if !found.contains(variant(v.id)) {\n                     return Some(variant(v.id));\n                 }"}, {"sha": "392e3b4d55adc0d26ca7477faab35be47e4994b5", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -195,7 +195,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n \n         // Iterate over any free variables that may not have appeared in the\n         // capture list.  Ensure that they too are of the appropriate kind.\n-        for vec::each(*freevars::get_freevars(cx.tcx, fn_id)) |fv| {\n+        for vec::each_ref(*freevars::get_freevars(cx.tcx, fn_id)) |fv| {\n             let id = ast_util::def_id_of_def(fv.def).node;\n \n             // skip over free variables that appear in the cap clause\n@@ -211,7 +211,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             };\n \n             let ty = ty::node_id_to_type(cx.tcx, id);\n-            chk(cx, fn_id, Some(fv), is_move, ty, fv.span);\n+            chk(cx, fn_id, Some(*fv), is_move, ty, fv.span);\n         }\n     }\n \n@@ -227,8 +227,8 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n }\n \n fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n-    for vec::each(a.pats) |p| {\n-        do pat_util::pat_bindings(cx.tcx.def_map, p) |mode, id, span, _path| {\n+    for vec::each_ref(a.pats) |p| {\n+        do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _path| {\n             if mode == bind_by_value {\n                 let t = ty::node_id_to_type(cx.tcx, id);\n                 let reason = \"consider binding with `ref` or `move` instead\";"}, {"sha": "b62811eed3ebeae05e7424786e0ed9b0975a1425", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -451,7 +451,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n                        decl: ast::fn_decl) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n-        for vec::each(vec::append_one(tys, decl.output)) |ty| {\n+        for vec::each_ref(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n               ast::ty_path(_, id) => {\n                 match cx.def_map.get(id) {"}, {"sha": "bdd59455787e5af97b70f3747f051bfd81c8b7d2", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -4343,11 +4343,11 @@ impl Resolver {\n           let rib = self.type_ribs.get_elt(i);\n           match rib.kind {\n             MethodRibKind(node_id, _) =>\n-              for vec::each(self.crate.node.module.items) |item| {\n+              for vec::each_ref(self.crate.node.module.items) |item| {\n                 if item.id == node_id {\n                   match item.node {\n                     item_class(class_def, _) => {\n-                      for vec::each(class_def.fields) |field| {\n+                      for vec::each_ref(class_def.fields) |field| {\n                         match field.node.kind {\n                           syntax::ast::unnamed_field\n                             => {},\n@@ -4360,7 +4360,7 @@ impl Resolver {\n                             }\n                         }\n                       }\n-                      for vec::each(class_def.methods) |method| {\n+                      for vec::each_ref(class_def.methods) |method| {\n                         if str::eq_slice(self.session.str_of(method.ident),\n                                          name) {\n                           return true"}, {"sha": "b96990f24b8de0eca411779227651c373db21b74", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -124,13 +124,13 @@ fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n-enum opt {\n+enum Opt {\n     lit(@ast::expr),\n     var(/* disr val */int, /* variant dids */{enm: def_id, var: def_id}),\n     range(@ast::expr, @ast::expr)\n }\n-fn opt_eq(tcx: ty::ctxt, a: opt, b: opt) -> bool {\n-    match (a, b) {\n+fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n+    match (*a, *b) {\n       (lit(a), lit(b)) => const_eval::compare_lit_exprs(tcx, a, b) == 0,\n       (range(a1, a2), range(b1, b2)) => {\n         const_eval::compare_lit_exprs(tcx, a1, b1) == 0 &&\n@@ -145,11 +145,11 @@ enum opt_result {\n     single_result(Result),\n     range_result(Result, Result),\n }\n-fn trans_opt(bcx: block, o: opt) -> opt_result {\n+fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n     let _icx = bcx.insn_ctxt(\"alt::trans_opt\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n-    match o {\n+    match *o {\n         lit(lit_expr) => {\n             let datumblock = expr::trans_to_datum(bcx, lit_expr);\n             return single_result(datumblock.to_result());\n@@ -164,10 +164,10 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n     }\n }\n \n-fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n+fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n     let vdef = ast_util::variant_def_ids(tcx.def_map.get(pat_id));\n     let variants = ty::enum_variants(tcx, vdef.enm);\n-    for vec::each(*variants) |v| {\n+    for vec::each_ref(*variants) |v| {\n         if vdef.var == v.id { return var(v.disr_val, vdef); }\n     }\n     core::unreachable();\n@@ -221,7 +221,7 @@ fn matches_to_str(bcx: block, m: &[@Match]) -> ~str {\n }\n \n fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n           _ => ()\n@@ -285,7 +285,7 @@ fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n     let _indenter = indenter();\n \n     let mut result = ~[];\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         match e(br.pats[col]) {\n             Some(sub) => {\n                 let pats =\n@@ -337,7 +337,7 @@ fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n-fn enter_opt(bcx: block, m: &[@Match/&r], opt: opt, col: uint,\n+fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n              variant_size: uint, val: ValueRef)\n     -> ~[@Match/&r]\n {\n@@ -353,7 +353,7 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: opt, col: uint,\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n         match p.node {\n             ast::pat_enum(_, subpats) => {\n-                if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n                     Some(option::get_default(subpats,\n                                              vec::from_elem(variant_size,\n                                                             dummy)))\n@@ -362,17 +362,17 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: opt, col: uint,\n                 }\n             }\n             ast::pat_ident(_, _, None) if pat_is_variant(tcx.def_map, p) => {\n-                if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n                     Some(~[])\n                 } else {\n                     None\n                 }\n             }\n             ast::pat_lit(l) => {\n-                if opt_eq(tcx, lit(l), opt) { Some(~[]) } else { None }\n+                if opt_eq(tcx, &lit(l), opt) { Some(~[]) } else { None }\n             }\n             ast::pat_range(l1, l2) => {\n-                if opt_eq(tcx, range(l1, l2), opt) { Some(~[]) } else { None }\n+                if opt_eq(tcx, &range(l1, l2), opt) { Some(~[]) } else { None }\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n@@ -396,8 +396,8 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n         match p.node {\n             ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n                 let mut pats = ~[];\n-                for vec::each(fields) |fname| {\n-                    match fpats.find(|p| p.ident == fname) {\n+                for vec::each_ref(fields) |fname| {\n+                    match fpats.find(|p| p.ident == *fname) {\n                         None => vec::push(pats, dummy),\n                         Some(pat) => vec::push(pats, pat.pat)\n                     }\n@@ -487,14 +487,14 @@ fn enter_uniq(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n-fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[opt] {\n-    fn add_to_set(tcx: ty::ctxt, set: &DVec<opt>, val: opt) {\n-        if set.any(|l| opt_eq(tcx, l, val)) {return;}\n+fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n+    fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, val: Opt) {\n+        if set.any(|l| opt_eq(tcx, &l, &val)) {return;}\n         set.push(val);\n     }\n \n     let found = DVec();\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         let cur = br.pats[col];\n         if pat_is_variant(ccx.tcx.def_map, cur) {\n             add_to_set(ccx.tcx, &found, variant_opt(ccx.tcx, cur.id));\n@@ -544,7 +544,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n \n fn collect_record_or_struct_fields(m: &[@Match], col: uint) -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         match br.pats[col].node {\n           ast::pat_rec(fs, _) => extend(&mut fields, fs),\n           ast::pat_struct(_, fs, _) => extend(&mut fields, fs),\n@@ -566,7 +566,7 @@ fn collect_record_or_struct_fields(m: &[@Match], col: uint) -> ~[ast::ident] {\n fn root_pats_as_necessary(bcx: block, m: &[@Match],\n                           col: uint, val: ValueRef)\n {\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         let pat_id = br.pats[col].id;\n \n         match bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n@@ -586,7 +586,7 @@ fn root_pats_as_necessary(bcx: block, m: &[@Match],\n }\n \n fn any_box_pat(m: &[@Match], col: uint) -> bool {\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         match br.pats[col].node {\n           ast::pat_box(_) => return true,\n           _ => ()\n@@ -596,7 +596,7 @@ fn any_box_pat(m: &[@Match], col: uint) -> bool {\n }\n \n fn any_uniq_pat(m: &[@Match], col: uint) -> bool {\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         match br.pats[col].node {\n           ast::pat_uniq(_) => return true,\n           _ => ()\n@@ -606,7 +606,7 @@ fn any_uniq_pat(m: &[@Match], col: uint) -> bool {\n }\n \n fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         match br.pats[col].node {\n           ast::pat_tup(_) => return true,\n           _ => ()\n@@ -626,14 +626,16 @@ fn pick_col(m: &[@Match]) -> uint {\n         }\n     }\n     let scores = vec::to_mut(vec::from_elem(m[0].pats.len(), 0u));\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         let mut i = 0u;\n-        for vec::each(br.pats) |p| { scores[i] += score(p); i += 1u; }\n+        for vec::each_ref(br.pats) |p| { scores[i] += score(*p); i += 1u; }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n     let mut i = 0u;\n-    for vec::each(scores) |score| {\n+    for vec::each_ref(scores) |score| {\n+        let score = *score;\n+\n         // Irrefutable columns always go first, they'd only be duplicated in\n         // the branches.\n         if score == 0u { return i; }\n@@ -871,7 +873,7 @@ fn compile_submatch(bcx: block,\n                                 vec::view(vals, col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n-    for vec::each(m) |br| {\n+    for vec::each_ref(m) |br| {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 { pat_id = br.pats[col].id; }\n@@ -958,8 +960,8 @@ fn compile_submatch(bcx: block,\n             }\n         }\n     }\n-    for vec::each(opts) |o| {\n-        match o {\n+    for vec::each_ref(opts) |o| {\n+        match *o {\n             range(_, _) => { kind = compare; break }\n             _ => ()\n         }\n@@ -980,7 +982,7 @@ fn compile_submatch(bcx: block,\n     let mut i = 0u;\n \n     // Compile subtrees for each option\n-    for vec::each(opts) |opt| {\n+    for vec::each_ref(opts) |opt| {\n         i += 1u;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n@@ -1037,7 +1039,7 @@ fn compile_submatch(bcx: block,\n \n         let mut size = 0u;\n         let mut unpacked = ~[];\n-        match opt {\n+        match *opt {\n             var(_, vdef) => {\n                 let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n                 size = args.vals.len();\n@@ -1128,8 +1130,8 @@ fn trans_alt_inner(scope_cx: block,\n                                  arm: arm,\n                                  bindings_map: bindings_map};\n         vec::push(arm_datas, arm_data);\n-        for vec::each(arm.pats) |p| {\n-            vec::push(matches, @Match {pats: ~[p], data: arm_data});\n+        for vec::each_ref(arm.pats) |p| {\n+            vec::push(matches, @Match {pats: ~[*p], data: arm_data});\n         }\n     }\n \n@@ -1224,7 +1226,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             do expr::with_field_tys(tcx, pat_ty) |_has_dtor, field_tys| {\n-                for vec::each(fields) |f| {\n+                for vec::each_ref(fields) |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n                     let fldptr = GEPi(bcx, val, struct_field(ix));\n                     bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);"}, {"sha": "28de3e55569620fe745d662c8cd9ad576366d165", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -160,11 +160,7 @@ fn trans_foreign_call(cx: block, externs: HashMap<~str, ValueRef>,\n     let n = args.len() as int;\n     let llforeign: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n-    let mut call_args: ~[ValueRef] = ~[];\n-    for vec::each(args) |a| {\n-        vec::push(call_args, a);\n-    }\n-    return Call(cx, llforeign, call_args);\n+    return Call(cx, llforeign, args);\n }\n \n fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n@@ -532,7 +528,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           ty::ty_fn(ref fn_ty) => {\n             let mut j = 0u;\n             let v_id = variant.id;\n-            for vec::each(fn_ty.sig.inputs) |a| {\n+            for vec::each_ref(fn_ty.sig.inputs) |a| {\n                 let llfldp_a = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n                 let ty_subst = ty::subst_tps(ccx.tcx, tps, a.ty);\n                 cx = f(cx, llfldp_a, ty_subst);\n@@ -592,14 +588,14 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         Unreachable(unr_cx);\n         let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n         let next_cx = sub_block(cx, ~\"enum-iter-next\");\n-        for vec::each(*variants) |variant| {\n+        for vec::each_ref(*variants) |variant| {\n             let variant_cx =\n                 sub_block(cx,\n                                    ~\"enum-iter-variant-\" +\n                                        int::to_str(variant.disr_val, 10u));\n             AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n             let variant_cx =\n-                iter_variant(variant_cx, llunion_a_ptr, variant,\n+                iter_variant(variant_cx, llunion_a_ptr, *variant,\n                              substs.tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n         }\n@@ -747,8 +743,8 @@ fn need_invoke(bcx: block) -> bool {\n     loop {\n         match cur.kind {\n           block_scope(inf) => {\n-            for vec::each(inf.cleanups) |cleanup| {\n-                match cleanup {\n+            for vec::each_ref(inf.cleanups) |cleanup| {\n+                match *cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                     if cleanup_type == normal_exit_and_unwind {\n                         return true;\n@@ -1019,10 +1015,10 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n         ast::stmt_decl(d, _) => {\n             match d.node {\n                 ast::decl_local(locals) => {\n-                    for vec::each(locals) |local| {\n-                        bcx = init_local(bcx, local);\n+                    for vec::each_ref(locals) |local| {\n+                        bcx = init_local(bcx, *local);\n                         if cx.sess().opts.extra_debuginfo {\n-                            debuginfo::create_local_var(bcx, local);\n+                            debuginfo::create_local_var(bcx, *local);\n                         }\n                     }\n                 }\n@@ -1118,7 +1114,7 @@ fn trans_block_cleanups_(bcx: block,\n         bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0;\n     if bcx.unreachable && !no_lpads { return bcx; }\n     let mut bcx = bcx;\n-    do vec::riter(cleanups) |cu| {\n+    for vec::reach(cleanups) |cu| {\n             match cu {\n               clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during\n@@ -1230,12 +1226,14 @@ fn with_scope_datumblock(bcx: block, opt_node_info: Option<node_info>,\n }\n \n fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n-    for vec::each(b.node.stmts) |s| {\n+    for vec::each_ref(b.node.stmts) |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n             match d.node {\n               ast::decl_local(locals) => {\n-                for vec::each(locals) |local| { it(local); }\n+                for vec::each_ref(locals) |local| {\n+                    it(*local);\n+                }\n               }\n               _ => {/* fall through */ }\n             }\n@@ -1464,7 +1462,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n \n     // Populate the llargs field of the function context with the ValueRefs\n     // that we get from llvm::LLVMGetParam for each argument.\n-    for vec::each(args) |arg| {\n+    for vec::each_ref(args) |arg| {\n         let llarg = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n         assert (llarg as int != 0);\n         // Note that this uses local_mem even for things passed by value.\n@@ -1499,7 +1497,7 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n       _ => {}\n     }\n \n-    for vec::each(arg_tys) |arg| {\n+    for vec::each_ref(arg_tys) |arg| {\n         let id = args[arg_n].id;\n         let argval = match fcx.llargs.get(id) {\n           local_mem(v) => v,\n@@ -1782,14 +1780,14 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n                   id: ast::node_id, tps: ~[ast::ty_param], degen: bool,\n                   path: @ast_map::path, vi: @~[ty::variant_info],\n                   i: &mut uint) {\n-    for vec::each(enum_definition.variants) |variant| {\n+    for vec::each_ref(enum_definition.variants) |variant| {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n         match variant.node.kind {\n             ast::tuple_variant_kind(args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, variant, args, disr_val,\n+                trans_enum_variant(ccx, id, *variant, args, disr_val,\n                                    degen, None, llfn);\n             }\n             ast::tuple_variant_kind(_) => {\n@@ -1829,7 +1827,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n                      vec::append(*path, ~[path_name(item.ident)]),\n                      decl, body, llfndecl, no_self, None, item.id);\n         } else {\n-            for vec::each(body.node.stmts) |stmt| {\n+            for vec::each_ref(body.node.stmts) |stmt| {\n                 match stmt.node {\n                   ast::stmt_decl(@{node: ast::decl_item(i), _}, _) => {\n                     trans_item(ccx, *i);\n@@ -1910,7 +1908,9 @@ fn trans_trait(ccx: @crate_ctxt, tps: ~[ast::ty_param],\n // and control visibility.\n fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n-    for vec::each(m.items) |item| { trans_item(ccx, *item); }\n+    for vec::each_ref(m.items) |item| {\n+        trans_item(ccx, **item);\n+    }\n }\n \n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n@@ -2236,7 +2236,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n                                              node: it.id});\n         let mut i = 0;\n         let path = item_path(ccx, it);\n-        for vec::each(enum_definition.variants) |variant| {\n+        for vec::each_ref(enum_definition.variants) |variant| {\n             let p = vec::append(path, ~[path_name(variant.node.name),\n                                         path_name(special_idents::descrim)]);\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n@@ -2352,21 +2352,21 @@ fn push_rtcall(ccx: @crate_ctxt, name: ~str, did: ast::def_id) {\n fn gather_local_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n         visit_item: |item| match item.node {\n-          ast::item_fn(*) => {\n-            let attr_metas = attr::attr_metas(\n-                attr::find_attrs_by_name(item.attrs, ~\"rt\"));\n-            do vec::iter(attr_metas) |attr_meta| {\n-                match attr::get_meta_item_list(attr_meta) {\n-                  Some(list) => {\n-                    let name = attr::get_meta_item_name(vec::head(list));\n-                    push_rtcall(ccx, name, {crate: ast::local_crate,\n-                                            node: item.id});\n-                  }\n-                  None => ()\n+            ast::item_fn(*) => {\n+                let attr_metas = attr::attr_metas(\n+                    attr::find_attrs_by_name(item.attrs, ~\"rt\"));\n+                for vec::each_ref(attr_metas) |attr_meta| {\n+                    match attr::get_meta_item_list(*attr_meta) {\n+                        Some(list) => {\n+                            let name = attr::get_meta_item_name(vec::head(list));\n+                            push_rtcall(ccx, name, {crate: ast::local_crate,\n+                                                    node: item.id});\n+                        }\n+                        None => ()\n+                    }\n                 }\n             }\n-          }\n-          _ => ()\n+            _ => ()\n         },\n         ..*visit::default_simple_visitor()\n     }));\n@@ -2412,9 +2412,9 @@ fn gather_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n     // for an rtcall.\n     let expected_rtcalls =\n         ~[~\"exchange_free\", ~\"exchange_malloc\", ~\"fail_\", ~\"free\", ~\"malloc\"];\n-    for vec::each(expected_rtcalls) |name| {\n-        if !ccx.rtcalls.contains_key(name) {\n-            fail fmt!(\"no definition for runtime call %s\", name);\n+    for vec::each_ref(expected_rtcalls) |name| {\n+        if !ccx.rtcalls.contains_key(*name) {\n+            fail fmt!(\"no definition for runtime call %s\", *name);\n         }\n     }\n }"}, {"sha": "6d687b3a8cd0d717094016f1f3c620fcdc499f9e", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -435,7 +435,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n // XXX: Use a small-vector optimization to avoid allocations here.\n fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     let mut v: ~[ValueRef] = ~[];\n-    for vec::each(ixs) |i| { vec::push(v, C_i32(i as i32)); }\n+    for vec::each_ref(ixs) |i| { vec::push(v, C_i32(*i as i32)); }\n     count_insn(cx, \"gepi\");\n     return InBoundsGEP(cx, base, v);\n }"}, {"sha": "6db93f1cc93f4ac4f880735f1bb1106e9d46c218", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -450,7 +450,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n     match args {\n       ArgExprs(arg_exprs) => {\n         let last = arg_exprs.len() - 1u;\n-        do vec::iteri(arg_exprs) |i, arg_expr| {\n+        for vec::eachi(arg_exprs) |i, arg_expr| {\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx, arg_tys[i], arg_expr, &mut temp_cleanups,\n                                if i == last { ret_flag } else { None })\n@@ -466,8 +466,8 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n     // now that all arguments have been successfully built, we can revoke any\n     // temporary cleanups, as they are only needed if argument construction\n     // should fail (for example, cleanup of copy mode args).\n-    do vec::iter(temp_cleanups) |c| {\n-        revoke_clean(bcx, c)\n+    for vec::each_ref(temp_cleanups) |c| {\n+        revoke_clean(bcx, *c)\n     }\n \n     return {bcx: bcx, args: llargs, retslot: llretslot};"}, {"sha": "72b3d4d8dfd7e0aa5017037151f7b7e07ca16dad", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -209,7 +209,7 @@ fn store_environment(bcx: block,\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n-    do vec::iteri(bound_values) |i, bv| {\n+    for vec::eachi(bound_values) |i, bv| {\n         debug!(\"Copy %s into closure\", bv.to_str(ccx));\n \n         if !ccx.sess.no_asm_comments() {\n@@ -232,7 +232,9 @@ fn store_environment(bcx: block,\n         }\n \n     }\n-    for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n+    for vec::each_ref(temp_cleanups) |cleanup| {\n+        revoke_clean(bcx, *cleanup);\n+    }\n \n     return {llbox: llbox, cdata_ty: cdata_ty, bcx: bcx};\n }\n@@ -251,8 +253,8 @@ fn build_closure(bcx0: block,\n \n     // Package up the captured upvars\n     let mut env_vals = ~[];\n-    do vec::iter(cap_vars) |cap_var| {\n-        debug!(\"Building closure: captured variable %?\", cap_var);\n+    for vec::each_ref(cap_vars) |cap_var| {\n+        debug!(\"Building closure: captured variable %?\", *cap_var);\n         let datum = expr::trans_local_var(bcx, id, cap_var.def);\n         match cap_var.mode {\n             capture::cap_ref => {\n@@ -316,7 +318,7 @@ fn load_environment(fcx: fn_ctxt,\n \n     // Populate the upvars from the environment.\n     let mut i = 0u;\n-    do vec::iter(cap_vars) |cap_var| {\n+    for vec::each_ref(cap_vars) |cap_var| {\n         match cap_var.mode {\n           capture::cap_drop => { /* ignore */ }\n           _ => {"}, {"sha": "ba47aa64065d54e86410d54a23ce6fa5b91c7b35", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -1174,12 +1174,14 @@ fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n \n fn path_str(sess: session::session, p: path) -> ~str {\n     let mut r = ~\"\", first = true;\n-    for vec::each(p) |e| {\n-        match e { ast_map::path_name(s) | ast_map::path_mod(s) => {\n-          if first { first = false; }\n-          else { r += ~\"::\"; }\n-          r += sess.str_of(s);\n-        } }\n+    for vec::each_ref(p) |e| {\n+        match *e {\n+            ast_map::path_name(s) | ast_map::path_mod(s) => {\n+                if first { first = false; }\n+                else { r += ~\"::\"; }\n+                r += sess.str_of(s);\n+            }\n+        }\n     }\n     r\n }\n@@ -1267,10 +1269,10 @@ fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n     let mut vtable_off = n_bound, i = 0u;\n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n-    for vec::each(*ps.bounds) |bounds| {\n+    for vec::each_ref(*ps.bounds) |bounds| {\n         if i >= n_param { break; }\n-        for vec::each(*bounds) |bound| {\n-            match bound { ty::bound_trait(_) => vtable_off += 1u, _ => () }\n+        for vec::each_ref(**bounds) |bound| {\n+            match *bound { ty::bound_trait(_) => vtable_off += 1u, _ => () }\n         }\n         i += 1u;\n     }"}, {"sha": "bb4314bc37aa2cb1833fb75ffbaea95d22b5b5cf", "filename": "src/rustc/middle/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -11,9 +11,9 @@ fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n     do block_locals(b) |local| {\n         bcx = alloc_local(bcx, local);\n     };\n-    for vec::each(b.node.stmts) |s| {\n+    for vec::each_ref(b.node.stmts) |s| {\n         debuginfo::update_source_pos(bcx, b.span);\n-        bcx = trans_stmt(bcx, *s);\n+        bcx = trans_stmt(bcx, **s);\n     }\n     match b.node.expr {\n         Some(e) => {\n@@ -83,9 +83,9 @@ fn trans_if(bcx: block,\n fn join_blocks(parent_bcx: block, in_cxs: ~[block]) -> block {\n     let out = sub_block(parent_bcx, ~\"join\");\n     let mut reachable = false;\n-    for vec::each(in_cxs) |bcx| {\n+    for vec::each_ref(in_cxs) |bcx| {\n         if !bcx.unreachable {\n-            Br(bcx, out.llbb);\n+            Br(*bcx, out.llbb);\n             reachable = true;\n         }\n     }"}, {"sha": "6ba2257d421ccfcab0ecee10623c32d7d56b96e7", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -971,7 +971,7 @@ fn trans_rec_or_struct(bcx: block,\n         Ignore => {\n             // just evaluate the values for each field and drop them\n             // on the floor\n-            for vec::each(fields) |fld| {\n+            for vec::each_ref(fields) |fld| {\n                 bcx = trans_into(bcx, fld.node.expr, Ignore);\n             }\n             return bcx;\n@@ -1027,7 +1027,9 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: Dest) -> block {\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n-            for vec::each(elts) |ex| { bcx = trans_into(bcx, ex, Ignore); }\n+            for vec::each_ref(elts) |ex| {\n+                bcx = trans_into(bcx, *ex, Ignore);\n+            }\n             return bcx;\n         }\n         SaveIn(pos) => pos,\n@@ -1040,7 +1042,9 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: Dest) -> block {\n         add_clean_temp_mem(bcx, dest, e_ty);\n         vec::push(temp_cleanups, dest);\n     }\n-    for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n+    for vec::each_ref(temp_cleanups) |cleanup| {\n+        revoke_clean(bcx, *cleanup);\n+    }\n     return bcx;\n }\n "}, {"sha": "65f8dd6e49323cdf6ca5deb190d98b4a6a4f0fd6", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -164,10 +164,10 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             classify(T_i64(), cls, i, off);\n         } else {\n             let mut field_off = off;\n-            for vec::each(tys) |ty| {\n-                field_off = align(field_off, ty);\n-                classify(ty, cls, i, field_off);\n-                field_off += ty_size(ty);\n+            for vec::each_ref(tys) |ty| {\n+                field_off = align(field_off, *ty);\n+                classify(*ty, cls, i, field_off);\n+                field_off += ty_size(*ty);\n             }\n         }\n     }\n@@ -282,8 +282,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n fn llreg_ty(cls: ~[x86_64_reg_class]) -> TypeRef {\n     fn llvec_len(cls: ~[x86_64_reg_class]) -> uint {\n         let mut len = 1u;\n-        for vec::each(cls) |c| {\n-            if c != sseup_class {\n+        for vec::each_ref(cls) |c| {\n+            if *c != sseup_class {\n                 break;\n             }\n             len += 1u;\n@@ -376,8 +376,8 @@ fn x86_64_tys(atys: ~[TypeRef],\n \n     let mut arg_tys = ~[];\n     let mut attrs = ~[];\n-    for vec::each(atys) |t| {\n-        let (ty, attr) = x86_64_ty(t, is_pass_byval, ByValAttribute);\n+    for vec::each_ref(atys) |t| {\n+        let (ty, attr) = x86_64_ty(*t, is_pass_byval, ByValAttribute);\n         vec::push(arg_tys, ty);\n         vec::push(attrs, attr);\n     }\n@@ -410,7 +410,7 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n     let fnty = T_fn(atys, rty);\n     let llfn = decl(fnty);\n \n-    do vec::iteri(tys.attrs) |i, a| {\n+    for vec::eachi(tys.attrs) |i, a| {\n         match a {\n             option::Some(attr) => {\n                 let llarg = get_param(llfn, i);\n@@ -640,7 +640,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n             match tys.x86_64_tys {\n                 Some(x86_64) => {\n-                  do vec::iteri(x86_64.attrs) |i, a| {\n+                  for vec::eachi(x86_64.attrs) |i, a| {\n                         match a {\n                             Some(attr) => {\n                                 llvm::LLVMAddInstrAttribute(\n@@ -762,7 +762,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n       ast::foreign_abi_stdcall => lib::llvm::X86StdcallCallConv\n     };\n \n-    for vec::each(foreign_mod.items) |foreign_item| {\n+    for vec::each_ref(foreign_mod.items) |foreign_item| {\n       match foreign_item.node {\n         ast::foreign_item_fn(*) => {\n           let id = foreign_item.id;\n@@ -771,9 +771,9 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n               let tys = c_stack_tys(ccx, id);\n               if attr::attrs_contains_name(foreign_item.attrs,\n                                            ~\"rust_stack\") {\n-                  build_direct_fn(ccx, llwrapfn, foreign_item, tys, cc);\n+                  build_direct_fn(ccx, llwrapfn, *foreign_item, tys, cc);\n               } else {\n-                  let llshimfn = build_shim_fn(ccx, foreign_item, tys, cc);\n+                  let llshimfn = build_shim_fn(ccx, *foreign_item, tys, cc);\n                   build_wrap_fn(ccx, tys, llshimfn, llwrapfn);\n               }\n           } else {"}, {"sha": "d42d7cff94db5af9188f3a865697624e5797dcb0", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -31,11 +31,11 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n-    for vec::each(methods) |method| {\n+    for vec::each_ref(methods) |method| {\n         if method.tps.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(sub_path, path_name(method.ident));\n-            trans_method(ccx, path, method, None, llfn);\n+            trans_method(ccx, path, *method, None, llfn);\n         }\n     }\n }"}, {"sha": "a60985d9bdd2618f2ccccc7fa499a14c3d597006", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -243,8 +243,8 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n         let mut i = 0u;\n         vec::map2(*bounds, substs, |bounds, subst| {\n             let mut v = ~[];\n-            for vec::each(*bounds) |bound| {\n-                match bound {\n+            for vec::each_ref(*bounds) |bound| {\n+                match *bound {\n                   ty::bound_trait(_) => {\n                     vec::push(v, meth::vtable_id(ccx, vts[i]));\n                     i += 1u;"}, {"sha": "c7739ad07b8cf78bfb33d1e285ea7f2b26a2366d", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -33,11 +33,11 @@ fn find_reachable(crate_mod: _mod, exp_map: resolve::ExportMap,\n \n fn traverse_exports(cx: ctx, vis: ~[@view_item]) -> bool {\n     let mut found_export = false;\n-    for vec::each(vis) |vi| {\n+    for vec::each_ref(vis) |vi| {\n         match vi.node {\n           view_item_export(vps) => {\n             found_export = true;\n-            for vec::each(vps) |vp| {\n+            for vec::each_ref(vps) |vp| {\n                 match vp.node {\n                   view_path_simple(_, _, _, id) | view_path_glob(_, id) |\n                   view_path_list(_, _, id) => {\n@@ -54,7 +54,9 @@ fn traverse_exports(cx: ctx, vis: ~[@view_item]) -> bool {\n \n fn traverse_export(cx: ctx, exp_id: node_id) {\n     do option::iter(cx.exp_map.find(exp_id)) |defs| {\n-        for vec::each(defs) |def| { traverse_def_id(cx, def.id); }\n+        for vec::each_ref(defs) |def| {\n+            traverse_def_id(cx, def.id);\n+        }\n     }\n }\n \n@@ -82,7 +84,9 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n fn traverse_public_mod(cx: ctx, m: _mod) {\n     if !traverse_exports(cx, m.view_items) {\n         // No exports, so every local item is exported\n-        for vec::each(m.items) |item| { traverse_public_item(cx, item); }\n+        for vec::each_ref(m.items) |item| {\n+            traverse_public_item(cx, *item);\n+        }\n     }\n }\n \n@@ -93,7 +97,9 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       item_mod(m) => traverse_public_mod(cx, m),\n       item_foreign_mod(nm) => {\n           if !traverse_exports(cx, nm.view_items) {\n-              for vec::each(nm.items) |item| { cx.rmap.insert(item.id, ()); }\n+              for vec::each_ref(nm.items) |item| {\n+                  cx.rmap.insert(item.id, ());\n+              }\n           }\n       }\n       item_fn(_, _, tps, blk) => {\n@@ -103,7 +109,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         }\n       }\n       item_impl(tps, _, _, ms) => {\n-        for vec::each(ms) |m| {\n+        for vec::each_ref(ms) |m| {\n             if tps.len() > 0u || m.tps.len() > 0u ||\n                attr::find_inline_attr(m.attrs) != attr::ia_none {\n                 cx.rmap.insert(m.id, ());\n@@ -126,7 +132,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n                 traverse_inline_body(cx, dtor.node.body);\n             }\n         }\n-        for vec::each(struct_def.methods) |m| {\n+        for vec::each_ref(struct_def.methods) |m| {\n             cx.rmap.insert(m.id, ());\n             if tps.len() > 0 ||\n                     attr::find_inline_attr(m.attrs) != attr::ia_none {"}, {"sha": "fe064c251d601620d278ae1319e3a1cfd2612c05", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -314,16 +314,16 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n \n         ty::ty_rec(fields) => {\n             let mut s = ~[shape_struct], sub = ~[];\n-            for vec::each(fields) |f| {\n+            for vec::each_ref(fields) |f| {\n                 sub += shape_of(ccx, f.mt.ty);\n             }\n             add_substr(s, sub);\n             s\n         }\n         ty::ty_tup(elts) => {\n             let mut s = ~[shape_struct], sub = ~[];\n-            for vec::each(elts) |elt| {\n-                sub += shape_of(ccx, elt);\n+            for vec::each_ref(elts) |elt| {\n+                sub += shape_of(ccx, *elt);\n             }\n             add_substr(s, sub);\n             s\n@@ -376,7 +376,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n \n fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info) -> ~[u8] {\n     let mut s = ~[];\n-    for vec::each(v.args) |t| { s += shape_of(ccx, t); }\n+    for vec::each_ref(v.args) |t| { s += shape_of(ccx, *t); }\n     return s;\n }\n \n@@ -391,10 +391,10 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     while i < ccx.shape_cx.tag_order.len() {\n         let {did, substs} = ccx.shape_cx.tag_order[i];\n         let variants = @ty::substd_enum_variants(ccx.tcx, did, &substs);\n-        do vec::iter(*variants) |v| {\n+        for vec::each_ref(*variants) |v| {\n             offsets += ~[vec::len(data) as u16];\n \n-            let variant_shape = shape_of_variant(ccx, v);\n+            let variant_shape = shape_of_variant(ccx, *v);\n             add_substr(data, variant_shape);\n \n             let zname = str::to_bytes(ccx.sess.str_of(v.name)) + ~[0u8];\n@@ -435,7 +435,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n         let lv = largest_variants(ccx, variants);\n         add_u16(lv_table, vec::len(lv) as u16);\n-        for vec::each(lv) |v| { add_u16(lv_table, v as u16); }\n+        for vec::each_ref(lv) |v| { add_u16(lv_table, *v as u16); }\n \n         // Determine whether the enum has dynamic size.\n         assert !vec::any(*variants, |v| {\n@@ -451,7 +451,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         inf += ~[size_align.align];\n \n         // Now write in the offset of each variant.\n-        for vec::each(*variants) |_v| {\n+        for vec::each_ref(*variants) |_v| {\n             add_u16(inf, header_sz + inf_sz + offsets[i]);\n             i += 1u;\n         }\n@@ -478,17 +478,17 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         // variant that contains (T,T) must be as least as large as\n         // any variant that contains just T.\n         let mut ranges = ~[];\n-        for vec::each(*variants) |variant| {\n+        for vec::each_ref(*variants) |variant| {\n             let mut bounded = true;\n             let mut min_size = 0u, min_align = 0u;\n-            for vec::each(variant.args) |elem_t| {\n-                if ty::type_has_params(elem_t) {\n+            for vec::each_ref(variant.args) |elem_t| {\n+                if ty::type_has_params(*elem_t) {\n                     // NB: We could do better here; this causes us to\n                     // conservatively assume that (int, T) has minimum size 0,\n                     // when in fact it has minimum size sizeof(int).\n                     bounded = false;\n                 } else {\n-                    let llty = type_of::type_of(ccx, elem_t);\n+                    let llty = type_of::type_of(ccx, *elem_t);\n                     min_size += llsize_of_real(ccx, llty);\n                     min_align += llalign_of_pref(ccx, llty);\n                 }\n@@ -550,11 +550,11 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         -> size_align {\n         let mut max_size = 0u16;\n         let mut max_align = 1u8;\n-        for vec::each(largest_variants) |vid| {\n+        for vec::each_ref(largest_variants) |vid| {\n             // We increment a \"virtual data pointer\" to compute the size.\n             let mut lltys = ~[];\n-            for vec::each(variants[vid].args) |typ| {\n-                lltys += ~[type_of::type_of(ccx, typ)];\n+            for vec::each_ref(variants[*vid].args) |typ| {\n+                lltys += ~[type_of::type_of(ccx, *typ)];\n             }\n \n             let llty = trans::common::T_struct(lltys);\n@@ -724,7 +724,7 @@ fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n         // Compute max(variant sizes).\n         let mut max_size = 0u;\n         let variants = ty::enum_variants(cx.tcx, tid);\n-        for vec::each(*variants) |variant| {\n+        for vec::each_ref(*variants) |variant| {\n             let tup_ty = simplify_type(cx.tcx,\n                                        ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions."}, {"sha": "ae202f6be88ca2d97cf7026008e05a4a208e1851", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -334,8 +334,8 @@ fn write_content(bcx: block,\n                         add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n                         vec::push(temp_cleanups, lleltptr);\n                     }\n-                    for vec::each(temp_cleanups) |cleanup| {\n-                        revoke_clean(bcx, cleanup);\n+                    for vec::each_ref(temp_cleanups) |cleanup| {\n+                        revoke_clean(bcx, *cleanup);\n                     }\n                 }\n             }\n@@ -372,8 +372,8 @@ fn write_content(bcx: block,\n                         vec::push(temp_cleanups, lleltptr);\n                     }\n \n-                    for vec::each(temp_cleanups) |cleanup| {\n-                        revoke_clean(bcx, cleanup);\n+                    for vec::each_ref(temp_cleanups) |cleanup| {\n+                        revoke_clean(bcx, *cleanup);\n                     }\n \n                     return bcx;"}, {"sha": "7feca7a2aa8d29081339d93b326d7d878d2b9538", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -143,7 +143,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n \n       ty::ty_rec(fields) => {\n         let mut tys: ~[TypeRef] = ~[];\n-        for vec::each(fields) |f| {\n+        for vec::each_ref(fields) |f| {\n             let mt_ty = f.mt.ty;\n             vec::push(tys, type_of(cx, mt_ty));\n         }\n@@ -157,8 +157,8 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_type => T_ptr(cx.tydesc_type),\n       ty::ty_tup(elts) => {\n         let mut tys = ~[];\n-        for vec::each(elts) |elt| {\n-            vec::push(tys, type_of(cx, elt));\n+        for vec::each_ref(elts) |elt| {\n+            vec::push(tys, type_of(cx, *elt));\n         }\n         T_struct(tys)\n       }"}, {"sha": "38015a9b50e7fdf213c720b7ec1fcea666442cb5", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -47,7 +47,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     let cx = {ccx: ccx, uses: vec::to_mut(vec::from_elem(n_tps, 0u))};\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n       ty::ty_fn(ref fn_ty) => {\n-        for vec::each(fn_ty.sig.inputs) |arg| {\n+        for vec::each_ref(fn_ty.sig.inputs) |arg| {\n             if arg.mode == expl(by_val) { type_needs(cx, use_repr, arg.ty); }\n         }\n       }\n@@ -142,9 +142,9 @@ fn type_needs_inner(cx: ctx, use_: uint, ty: ty::t,\n               ty::ty_enum(did, substs) => {\n                 if option::is_none(list::find(enums_seen, |id| *id == did)) {\n                     let seen = @Cons(did, enums_seen);\n-                    for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n-                        for vec::each(v.args) |aty| {\n-                            let t = ty::subst(cx.ccx.tcx, &substs, aty);\n+                    for vec::each_ref(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n+                        for vec::each_ref(v.args) |aty| {\n+                            let t = ty::subst(cx.ccx.tcx, &substs, *aty);\n                             type_needs_inner(cx, use_, t, seen);\n                         }\n                     }\n@@ -209,7 +209,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n           ty::proto_bare | ty::proto_vstore(ty::vstore_uniq) => {}\n           ty::proto_vstore(ty::vstore_box) |\n           ty::proto_vstore(ty::vstore_slice(_)) => {\n-            for vec::each(*freevars::get_freevars(cx.ccx.tcx, e.id)) |fv| {\n+            for vec::each_ref(*freevars::get_freevars(cx.ccx.tcx, e.id)) |fv| {\n                 let node_id = ast_util::def_id_of_def(fv.def).node;\n                 node_type_needs(cx, use_repr, node_id);\n             }\n@@ -247,14 +247,16 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         node_type_needs(cx, use_tydesc, val.id);\n       }\n       expr_call(f, _, _) => {\n-        vec::iter(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id)), |a| {\n-            match a.mode {\n-              expl(by_move) | expl(by_copy) | expl(by_val) => {\n-                type_needs(cx, use_repr, a.ty);\n+          for vec::each_ref(\n+              ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id))\n+          ) |a| {\n+              match a.mode {\n+                  expl(by_move) | expl(by_copy) | expl(by_val) => {\n+                      type_needs(cx, use_repr, a.ty);\n+                  }\n+                  _ => ()\n               }\n-              _ => ()\n-            }\n-        })\n+          }\n       }\n       expr_match(*) | expr_block(_) | expr_if(*) |\n       expr_while(*) | expr_fail(_) | expr_break(_) | expr_again(_) |"}, {"sha": "bf4c6a96ba2b4fe636cd98b40b1e384e0346fa7c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -773,8 +773,8 @@ impl FnVid : to_bytes::IterBytes {\n \n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let mut kind = kind_noncopyable();\n-    for vec::each(*bounds) |bound| {\n-        match bound {\n+    for vec::each_ref(*bounds) |bound| {\n+        match *bound {\n           bound_copy => {\n             kind = raise_kind(kind, kind_implicitly_copyable());\n           }\n@@ -1604,10 +1604,10 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       ty_class(did, ref substs) => {\n          // Any class with a dtor needs a drop\n          option::is_some(ty_dtor(cx, did)) || {\n-             for vec::each(ty::class_items_as_fields(cx, did, substs)) |f| {\n-             if type_needs_drop(cx, f.mt.ty) { accum = true; }\n-           }\n-           accum\n+             for vec::each_ref(ty::class_items_as_fields(cx, did, substs)) |f| {\n+                 if type_needs_drop(cx, f.mt.ty) { accum = true; }\n+             }\n+             accum\n          }\n       }\n       ty_tup(elts) => {\n@@ -1616,7 +1616,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       }\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n-          for vec::each(*variants) |variant| {\n+          for vec::each_ref(*variants) |variant| {\n               for variant.args.each |aty| {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = subst(cx, substs, aty);\n@@ -1680,7 +1680,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             true\n           }\n           ty_enum(did, ref substs) => {\n-            for vec::each(*enum_variants(cx, did)) |v| {\n+            for vec::each_ref(*enum_variants(cx, did)) |v| {\n                 for v.args.each |aty| {\n                     let t = subst(cx, substs, aty);\n                     needs_unwind_cleanup |=\n@@ -2041,7 +2041,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         if vec::len(*variants) == 0u {\n             lowest = kind_send_only() | kind_owned();\n         } else {\n-            for vec::each(*variants) |variant| {\n+            for vec::each_ref(*variants) |variant| {\n                 for variant.args.each |aty| {\n                     // Perform any type parameter substitutions.\n                     let arg_ty = subst(cx, substs, aty);\n@@ -2261,7 +2261,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n     if test(sty) { return true; }\n     match *sty {\n       ty_enum(did, ref substs) => {\n-        for vec::each(*enum_variants(cx, did)) |variant| {\n+        for vec::each_ref(*enum_variants(cx, did)) |variant| {\n             for variant.args.each |aty| {\n                 let sty = subst(cx, substs, aty);\n                 if type_structurally_contains(cx, sty, test) { return true; }\n@@ -2350,7 +2350,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       // Structural types\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n-        for vec::each(*variants) |variant| {\n+        for vec::each_ref(*variants) |variant| {\n             let tup_ty = mk_tup(cx, variant.args);\n \n             // Perform any type parameter substitutions.\n@@ -2672,7 +2672,7 @@ pure fn hash_type_structure(st: &sty) -> uint {\n     }\n     pure fn hash_subtys(id: uint, subtys: ~[t]) -> uint {\n         let mut h = id;\n-        for vec::each(subtys) |s| { h = (h << 2u) + type_id(s) }\n+        for vec::each_ref(subtys) |s| { h = (h << 2u) + type_id(*s) }\n         h\n     }\n     pure fn hash_substs(h: uint, substs: &substs) -> uint {\n@@ -2713,12 +2713,12 @@ pure fn hash_type_structure(st: &sty) -> uint {\n       ty_tup(ts) => hash_subtys(25u, ts),\n       ty_rec(fields) => {\n         let mut h = 26u;\n-        for vec::each(fields) |f| { h = hash_subty(h, f.mt.ty); }\n+        for vec::each_ref(fields) |f| { h = hash_subty(h, f.mt.ty); }\n         h\n       }\n       ty_fn(ref f) => {\n         let mut h = 27u;\n-        for vec::each(f.sig.inputs) |a| {\n+        for vec::each_ref(f.sig.inputs) |a| {\n             h = hash_subty(h, a.ty);\n         }\n         hash_subty(h, f.sig.output)"}, {"sha": "b9218c064f49af26ab6262e7b35c4d26f29bdd43", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -57,7 +57,6 @@ use std::smallintmap;\n use std::map;\n use std::map::{HashMap, int_hash};\n use std::serialization::{serialize_uint, deserialize_uint};\n-use vec::each;\n use syntax::print::pprust::*;\n use util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n                   bound_region_to_str, vstore_to_str, expr_repr};"}, {"sha": "278e811ae3bc0b0e231e07e8792e099976fd5e96", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -292,8 +292,8 @@ impl LookupContext {\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n         let bounds = tcx.ty_param_bounds.get(param_ty.def_id.node);\n-        for vec::each(*bounds) |bound| {\n-            let bound_t = match bound {\n+        for vec::each_ref(*bounds) |bound| {\n+            let bound_t = match *bound {\n                 ty::bound_trait(bound_t) => bound_t,\n \n                 ty::bound_copy | ty::bound_send |"}, {"sha": "b569980f893df480a34a4497acb3dd0c53a76d85", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -48,8 +48,8 @@ fn lookup_vtables(fcx: @fn_ctxt,\n     let tcx = fcx.ccx.tcx;\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n-        for vec::each(*bounds[i]) |bound| {\n-            match bound {\n+        for vec::each_ref(*bounds[i]) |bound| {\n+            match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n                 vec::push(result, lookup_vtable(fcx, expr, ty, i_ty,\n@@ -121,8 +121,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n     match ty::get(ty).sty {\n         ty::ty_param({idx: n, def_id: did}) => {\n             let mut n_bound = 0;\n-            for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n-                match bound {\n+            for vec::each_ref(*tcx.ty_param_bounds.get(did.node)) |bound| {\n+                match *bound {\n                     ty::bound_send | ty::bound_copy | ty::bound_const |\n                     ty::bound_owned => {\n                         /* ignore */\n@@ -156,7 +156,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n \n             relate_trait_tys(fcx, expr, trait_ty, ty);\n             if !allow_unsafe && !is_early {\n-                for vec::each(*ty::trait_methods(tcx, did)) |m| {\n+                for vec::each_ref(*ty::trait_methods(tcx, did)) |m| {\n                     if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n                         tcx.sess.span_err(\n                             expr.span,\n@@ -214,8 +214,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                         // it's the same trait as trait_ty, we need to\n                         // unify it with trait_ty in order to get all\n                         // the ty vars sorted out.\n-                        for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n-                            match ty::get(of_ty).sty {\n+                        for vec::each_ref(ty::impl_traits(tcx, im.did)) |of_ty| {\n+                            match ty::get(*of_ty).sty {\n                                 ty::ty_trait(id, _, _) => {\n                                     // Not the trait we're looking for\n                                     if id != trait_id { loop; }\n@@ -271,8 +271,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                             debug!(\"(checking vtable) @2 relating trait \\\n                                     ty %s to of_ty %s\",\n                                    fcx.infcx().ty_to_str(trait_ty),\n-                                   fcx.infcx().ty_to_str(of_ty));\n-                            let of_ty = ty::subst(tcx, &substs, of_ty);\n+                                   fcx.infcx().ty_to_str(*of_ty));\n+                            let of_ty = ty::subst(tcx, &substs, *of_ty);\n                             relate_trait_tys(fcx, expr, trait_ty, of_ty);\n \n                             // Recall that trait_ty -- the trait type"}, {"sha": "9b373438c041cb1ea038025f9c33ee1187609b19", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -137,20 +137,20 @@ fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n     match e.node {\n       ast::expr_fn(_, decl, _, _) |\n       ast::expr_fn_block(decl, _, _) => {\n-        do vec::iter(decl.inputs) |input| {\n-            let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n-\n-            // Just in case we never constrained the mode to anything,\n-            // constrain it to the default for the type in question.\n-            match (r_ty, input.mode) {\n-              (Some(t), ast::infer(_)) => {\n-                let tcx = wbcx.fcx.ccx.tcx;\n-                let m_def = ty::default_arg_mode_for_ty(tcx, t);\n-                ty::set_default_mode(tcx, input.mode, m_def);\n+          for vec::each_ref(decl.inputs) |input| {\n+              let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n+\n+              // Just in case we never constrained the mode to anything,\n+              // constrain it to the default for the type in question.\n+              match (r_ty, input.mode) {\n+                  (Some(t), ast::infer(_)) => {\n+                      let tcx = wbcx.fcx.ccx.tcx;\n+                      let m_def = ty::default_arg_mode_for_ty(tcx, t);\n+                      ty::set_default_mode(tcx, input.mode, m_def);\n+                  }\n+                  _ => ()\n               }\n-              _ => ()\n-            }\n-        }\n+          }\n       }\n \n       ast::expr_binary(*) | ast::expr_unary(*) | ast::expr_assign_op(*)"}, {"sha": "1b4953aa17b64f9d7cdef6b18db9b9433509c000", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -358,12 +358,12 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n     if did.crate == ast::local_crate {\n         ensure_trait_methods(ccx, did.node, tpt.ty);\n     }\n-    for vec::each(*ty::trait_methods(tcx, did)) |trait_m| {\n+    for vec::each_ref(*ty::trait_methods(tcx, did)) |trait_m| {\n         match vec::find(impl_ms, |impl_m| trait_m.ident == impl_m.mty.ident) {\n           Some({mty: impl_m, span, _}) => {\n             compare_impl_method(\n                 ccx.tcx, span, impl_m, vec::len(tps),\n-                trait_m, tpt.substs, selfty);\n+                *trait_m, tpt.substs, selfty);\n           }\n           None => {\n               // If we couldn't find an implementation for trait_m in"}, {"sha": "5540b923197810f350f94368ecdbdc1db55670fb", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -1098,8 +1098,8 @@ impl RegionVarBindings {\n         let upper_bounds =\n             self.collect_concrete_regions(graph, node_idx, Outgoing);\n \n-        for vec::each(lower_bounds) |lower_bound| {\n-            for vec::each(upper_bounds) |upper_bound| {\n+        for vec::each_ref(lower_bounds) |lower_bound| {\n+            for vec::each_ref(upper_bounds) |upper_bound| {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n \n@@ -1148,8 +1148,8 @@ impl RegionVarBindings {\n         let upper_bounds = self.collect_concrete_regions(graph, node_idx,\n                                                          Outgoing);\n \n-        for vec::each(upper_bounds) |upper_bound_1| {\n-            for vec::each(upper_bounds) |upper_bound_2| {\n+        for vec::each_ref(upper_bounds) |upper_bound_1| {\n+            for vec::each_ref(upper_bounds) |upper_bound_2| {\n                 match self.glb_concrete_regions(upper_bound_1.region,\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}"}, {"sha": "44f2b59f94b0391adcc1eeaf15de887188a7a417", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -74,10 +74,13 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n         map::HashMap::<node_id, ()>()\n     };\n \n-    do vec::each(edges) |e| {\n-        let (i, j) = e;\n-        map::set_add(graph[i], j);\n-        map::set_add(graph[j], i);\n+    do vec::each_ref(edges) |e| {\n+        match *e {\n+            (i, j) => {\n+                map::set_add(graph[i], j);\n+                map::set_add(graph[j], i);\n+            }\n+        }\n         true\n     }\n \n@@ -407,7 +410,7 @@ fn main(args: ~[~str]) {\n     let stop = time::precise_time_s();\n \n     let mut total_edges = 0u;\n-    vec::each(graph, |edges| { total_edges += edges.len(); true });\n+    vec::each_ref(graph, |edges| { total_edges += edges.len(); true });\n \n     io::stdout().write_line(fmt!(\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2u,"}, {"sha": "533068aeb2f6f8f9875881729380decf83e69029", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -73,7 +73,10 @@ fn run(args: &[~str]) {\n         server(from_parent, to_parent);\n     }\n \n-    vec::iter(worker_results, |r| { future::get(&r); } );\n+    for vec::each_ref(worker_results) |r| {\n+        future::get(r);\n+    }\n+\n     //error!(\"sending stop message\");\n     to_child.send(stop);\n     move_out!(to_child);"}, {"sha": "afcecda27d10ef2bf4ababf18eb9e3f10bee4546", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -70,7 +70,10 @@ fn run(args: &[~str]) {\n         server(from_parent, to_parent);\n     }\n \n-    vec::iter(worker_results, |r| { future::get(&r); } );\n+    for vec::each_ref(worker_results) |r| {\n+        future::get(r);\n+    }\n+\n     //error!(\"sending stop message\");\n     to_child.send(stop);\n     move_out!(to_child);"}, {"sha": "3b084c6b68205d6e4f4dcf1071680aeba03fb7f0", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -44,7 +44,9 @@ fn run(args: ~[~str]) {\n             }\n         };\n     }\n-    vec::iter(worker_results, |r| { future::get(&r); } );\n+    for vec::each_ref(worker_results) |r| {\n+        future::get(r);\n+    }\n     comm::send(to_child, stop);\n     let result = comm::recv(from_child);\n     let end = std::time::precise_time_s();"}, {"sha": "0c9c7fc1c3a0f1f85bdd9b741a79439168be21ef", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -7,10 +7,10 @@ use std::sort;\n \n fn print_complements() {\n     let all = ~[Blue, Red, Yellow];\n-    for vec::each(all) |aa| {\n-        for vec::each(all) |bb| {\n-            io::println(show_color(aa) + ~\" + \" + show_color(bb) +\n-                ~\" -> \" + show_color(transform(aa,bb)));\n+    for vec::each_ref(all) |aa| {\n+        for vec::each_ref(all) |bb| {\n+            io::println(show_color(*aa) + ~\" + \" + show_color(*bb) +\n+                ~\" -> \" + show_color(transform(*aa, *bb)));\n         }\n     }\n }\n@@ -162,16 +162,16 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // save each creature's meeting stats\n     let mut report = ~[];\n-    for vec::each(to_creature) |_to_one| {\n+    for vec::each_ref(to_creature) |_to_one| {\n         vec::push(report, comm::recv(from_creatures_log));\n     }\n \n     // print each color in the set\n     io::println(show_color_list(set));\n \n     // print each creature's stats\n-    for vec::each(report) |rep| {\n-        io::println(rep);\n+    for vec::each_ref(report) |rep| {\n+        io::println(*rep);\n     }\n \n     // print the total number of creatures met"}, {"sha": "628234f4c9919808479b010001eb62cf9cd639df", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -31,9 +31,9 @@ fn calc(children: uint, parent_ch: comm::Chan<msg>) {\n \n     match comm::recv(port) {\n         start => {\n-          do vec::iter (child_chs) |child_ch| {\n-              comm::send(child_ch, start);\n-          }\n+            for vec::each_ref(child_chs) |child_ch| {\n+                comm::send(*child_ch, start);\n+            }\n         }\n         _ => fail ~\"task-perf-one-million failed (port not in start state)\"\n     }"}, {"sha": "c36c59c61df64fefb0a39e88e956190052147591", "filename": "src/test/compile-fail/block-must-not-have-result-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -1,7 +1,7 @@\n // error-pattern:mismatched types: expected `()` but found `bool`\n \n fn main() {\n-    for vec::each(~[0]) |_i| {\n+    for vec::each_ref(~[0]) |_i| {\n         true\n     }\n }\n\\ No newline at end of file"}, {"sha": "5cff6c5dda77ed3b928edb5be7882b5a751ddf1a", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -1,6 +1,6 @@\n fn want_slice(v: &[int]) -> int {\n     let mut sum = 0;\n-    for vec::each(v) |i| { sum += i; }\n+    for vec::each_ref(v) |i| { sum += *i; }\n     return sum;\n }\n "}, {"sha": "6f97b0044d2dbc1ba7f5277d98d544f4949be814", "filename": "src/test/compile-fail/issue-2151.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    do vec::iter(fail) |i| {\n+    for vec::each_ref(fail) |i| {\n         log (debug, i * 2);\n         //~^ ERROR the type of this value must be known\n    };"}, {"sha": "c511b757f3dd5d242a15000d27c21b232fd78223", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n     let a: ~[int] = ~[];\n-    vec::each(a, fn@(_x: int) -> bool { //~ ERROR not all control paths return a value\n+    vec::each_ref(a, fn@(_x: &int) -> bool {\n+        //~^ ERROR not all control paths return a value\n     });\n }"}, {"sha": "7f10ea8e8f755492901b1dc6e1d180ad1ac6e86b", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -2,9 +2,9 @@ fn concat<T: Copy>(v: ~[const ~[const T]]) -> ~[T] {\n     let mut r = ~[];\n \n     // Earlier versions of our type checker accepted this:\n-    vec::iter(v, |&&inner: ~[T]| {\n+    vec::each_ref(v, |inner: &~[T]| {\n         //~^ ERROR values differ in mutability\n-        r += inner;\n+        r += *inner; true\n     });\n \n     return r;"}, {"sha": "ee2c24a35bbec619ec68c19e4a8ce826cab0129c", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be24f0758d3075d2e7f141f8831bb8a233ce86e/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=1be24f0758d3075d2e7f141f8831bb8a233ce86e", "patch": "@@ -3,8 +3,8 @@ fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Statement form does not require parentheses:\n-    do vec::iter(v) |i| {\n-        log(info, i);\n+    for vec::each_ref(v) |i| {\n+        log(info, *i);\n     }\n \n     // Usable at all:"}]}