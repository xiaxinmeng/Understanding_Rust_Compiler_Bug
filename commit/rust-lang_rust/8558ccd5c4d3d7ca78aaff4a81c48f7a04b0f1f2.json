{"sha": "8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NThjY2Q1YzRkM2Q3Y2E3OGFhZmY0YTgxYzQ4ZjdhMDRiMGYxZjI=", "commit": {"author": {"name": "cohenarthur", "email": "arthur.cohen@epita.fr", "date": "2020-04-23T20:32:20Z"}, "committer": {"name": "cohenarthur", "email": "arthur.cohen@epita.fr", "date": "2020-04-29T09:18:31Z"}, "message": "safety-ptr: Add SAFETY on some unsafe blocks from libcore/ptr\n\nAdd documentation example to slice_from_raw_parts_mut()\nAdd SAFETY explanations to some unsafe blocks in libcore/ptr\n\n* libcore/ptr/mod.rs\n* libcore/ptr/unique.rs\n* libcore/ptr/non_null.rs\n\nsafety-mod.rs: Add SAFETY to slice_from_raw_parts(),\nslice_from_raw_parts_mut()\n\nslice_from_raw_parts_mut: Add documentation example\n\nsafety-ptr-unique.rs: Add SAFETY to new() and cast()\n\nsafety-ptr-non_null.rs: Add SAFETY to new()\n\nsafety-ptr-non_null.rs: Add SAFETY to cast()\n\nsafety-ptr-non_null.rs: Add SAFETY to from() impls\n\nsafety-ptr-unique.rs: Add SAFETY to from() impls\n\nsafety-ptr-non_null.rs: Add SAFETY to new()\n\nsafety-ptr-unique.rs: Add SAFETY to new()\n\nsafety-ptr-mod.rs: Fix safety explanation\n\nhttps://github.com/rust-lang/rust/pull/71507#discussion_r414488884\n\nsafety-prt-non_null.rs: Fix SAFETY comment syntax\n\nsafety-ptr-unique.rs: Fix syntax for empty()\n\nsafety-ptr-non_null.rs: Fix misuse of non-null for align_of()\n\nsafety-ptr-non_null.rs: Remove incorrect SAFETY comment\n\nsafety-ptr-unique.rs: Remove unsound SAFETY comment\n\nsafety-ptr-mod.rs: Add std comment on slice_from_raw_parts guarantee\n\nsafety-ptr-unique.rs: Remove incorrect safety comment\n\nCreating a Unique from a NonNull has strict guarantees that the current\nimplementation does not guarantee\n\nhttps://github.com/rust-lang/rust/pull/71507#discussion_r415035952\n\nsafety-ptr: Re-adding ignore-tidy directive", "tree": {"sha": "77a4a3f3bcab9ee44f6ed067816edcdc9d3c5368", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77a4a3f3bcab9ee44f6ed067816edcdc9d3c5368"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2", "html_url": "https://github.com/rust-lang/rust/commit/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4a11d4dd971be4a2e055e4f92fece030615a692", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4a11d4dd971be4a2e055e4f92fece030615a692", "html_url": "https://github.com/rust-lang/rust/commit/b4a11d4dd971be4a2e055e4f92fece030615a692"}], "stats": {"total": 46, "additions": 43, "deletions": 3}, "files": [{"sha": "58f779106f716547b1cddb43e46c4a3f82fc7bd0", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2", "patch": "@@ -254,6 +254,9 @@ pub(crate) struct FatPtr<T> {\n #[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n+    // SAFETY: Accessing the value from the `Repr` union is safe since *const [T]\n+    // and FatPtr have the same memory layouts. Only std can make this\n+    // guarantee.\n     unsafe { Repr { raw: FatPtr { data, len } }.rust }\n }\n \n@@ -267,10 +270,28 @@ pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n ///\n /// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n /// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::ptr;\n+///\n+/// let x = &mut [5, 6, 7];\n+/// let raw_pointer = x.as_mut_ptr();\n+/// let slice = ptr::slice_from_raw_parts_mut(raw_pointer, 3);\n+///\n+/// unsafe {\n+///     (*slice)[2] = 99; // assign a value at an index in the slice\n+/// };\n+///\n+/// assert_eq!(unsafe { &*slice }[2], 99);\n+/// ```\n #[inline]\n #[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n+    // SAFETY: Accessing the value from the `Repr` union is safe since *mut [T]\n+    // and FatPtr have the same memory layouts\n     unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n }\n "}, {"sha": "7d08503215ed022bfb1920d791d9855ac1665d79", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2", "patch": "@@ -7,8 +7,6 @@ use crate::mem;\n use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n \n-// ignore-tidy-undocumented-unsafe\n-\n /// `*mut T` but non-zero and covariant.\n ///\n /// This is often the correct thing to use when building data structures using\n@@ -69,6 +67,9 @@ impl<T: Sized> NonNull<T> {\n     #[rustc_const_stable(feature = \"const_nonnull_dangling\", since = \"1.32.0\")]\n     #[inline]\n     pub const fn dangling() -> Self {\n+        // SAFETY: mem::align_of() returns a non-zero usize which is then casted\n+        // to a *mut T. Therefore, `ptr` is not null and the conditions for\n+        // calling new_unchecked() are respected.\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n             NonNull::new_unchecked(ptr)\n@@ -93,7 +94,12 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        if !ptr.is_null() { Some(unsafe { Self::new_unchecked(ptr) }) } else { None }\n+        if !ptr.is_null() {\n+            // SAFETY: The pointer is already checked and is not null\n+            Some(unsafe { Self::new_unchecked(ptr) })\n+        } else {\n+            None\n+        }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n@@ -131,6 +137,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[rustc_const_stable(feature = \"const_nonnull_cast\", since = \"1.32.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> NonNull<U> {\n+        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n         unsafe { NonNull::new_unchecked(self.as_ptr() as *mut U) }\n     }\n }\n@@ -205,6 +212,8 @@ impl<T: ?Sized> hash::Hash for NonNull<T> {\n impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n     #[inline]\n     fn from(unique: Unique<T>) -> Self {\n+        // SAFETY: A Unique pointer cannot be null, so the conditions for\n+        // new_unchecked() are respected.\n         unsafe { NonNull::new_unchecked(unique.as_ptr()) }\n     }\n }\n@@ -213,6 +222,7 @@ impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n impl<T: ?Sized> From<&mut T> for NonNull<T> {\n     #[inline]\n     fn from(reference: &mut T) -> Self {\n+        // SAFETY: A mutable reference cannot be null.\n         unsafe { NonNull { pointer: reference as *mut T } }\n     }\n }\n@@ -221,6 +231,8 @@ impl<T: ?Sized> From<&mut T> for NonNull<T> {\n impl<T: ?Sized> From<&T> for NonNull<T> {\n     #[inline]\n     fn from(reference: &T) -> Self {\n+        // SAFETY: A reference cannot be null, so the conditions for\n+        // new_unchecked() are respected.\n         unsafe { NonNull { pointer: reference as *const T } }\n     }\n }"}, {"sha": "7d823f91fecb838f9cd0b523a89fcfebb7ddbd64", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=8558ccd5c4d3d7ca78aaff4a81c48f7a04b0f1f2", "patch": "@@ -74,6 +74,8 @@ impl<T: Sized> Unique<T> {\n     // FIXME: rename to dangling() to match NonNull?\n     #[inline]\n     pub const fn empty() -> Self {\n+        // SAFETY: mem::align_of() returns a valid, non-null pointer. The\n+        // conditions to call new_unchecked() are thus respected.\n         unsafe { Unique::new_unchecked(mem::align_of::<T>() as *mut T) }\n     }\n }\n@@ -94,6 +96,7 @@ impl<T: ?Sized> Unique<T> {\n     #[inline]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n         if !ptr.is_null() {\n+            // SAFETY: The pointer has already been checked and is not null.\n             Some(unsafe { Unique { pointer: ptr as _, _marker: PhantomData } })\n         } else {\n             None\n@@ -129,6 +132,9 @@ impl<T: ?Sized> Unique<T> {\n     /// Casts to a pointer of another type.\n     #[inline]\n     pub const fn cast<U>(self) -> Unique<U> {\n+        // SAFETY: Unique::new_unchecked() creates a new unique and needs\n+        // the given pointer to not be null.\n+        // Since we are passing self as a pointer, it cannot be null.\n         unsafe { Unique::new_unchecked(self.as_ptr() as *mut U) }\n     }\n }\n@@ -168,6 +174,7 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n impl<T: ?Sized> From<&mut T> for Unique<T> {\n     #[inline]\n     fn from(reference: &mut T) -> Self {\n+        // SAFETY: A mutable reference cannot be null\n         unsafe { Unique { pointer: reference as *mut T, _marker: PhantomData } }\n     }\n }"}]}