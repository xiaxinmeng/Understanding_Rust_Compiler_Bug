{"sha": "5047ab0b0cc84af577d1a0816d2496986397e967", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNDdhYjBiMGNjODRhZjU3N2QxYTA4MTZkMjQ5Njk4NjM5N2U5Njc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-17T18:30:11Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-17T20:55:32Z"}, "message": "rustc: Flatten annotations", "tree": {"sha": "0c1b2e8e939f58793e26d79dfd0fc7f4829e9c81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c1b2e8e939f58793e26d79dfd0fc7f4829e9c81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5047ab0b0cc84af577d1a0816d2496986397e967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5047ab0b0cc84af577d1a0816d2496986397e967", "html_url": "https://github.com/rust-lang/rust/commit/5047ab0b0cc84af577d1a0816d2496986397e967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5047ab0b0cc84af577d1a0816d2496986397e967/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a90df393f9acb9633e0581711a3bc43f97bfe946", "url": "https://api.github.com/repos/rust-lang/rust/commits/a90df393f9acb9633e0581711a3bc43f97bfe946", "html_url": "https://github.com/rust-lang/rust/commit/a90df393f9acb9633e0581711a3bc43f97bfe946"}], "stats": {"total": 896, "additions": 307, "deletions": 589}, "files": [{"sha": "6bde1e42feeec4f3a07c975c7f5d4e50bbf8bb58", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -21,20 +21,10 @@ type def_id = tup(crate_num, def_num);\n type ty_param = ident;\n \n // Annotations added during successive passes.\n-tag ann {\n-    ann_none(uint);\n-    ann_type(uint,\n-             middle::ty::t,\n-             option::t[vec[middle::ty::t]], /* ty param substs */\n-             option::t[@ts_ann]); /* pre- and postcondition for typestate */\n-}\n-\n-fn ann_tag(&ann a) -> uint {\n-    ret alt (a) {\n-        case (ann_none(?t)) { t }\n-        case (ann_type(?t, _, _, _)) { t }\n-    };\n-}\n+type ann = rec(uint id,\n+               middle::ty::t ty,\n+               option::t[vec[middle::ty::t]] tps,\n+               option::t[@ts_ann] ts);\n \n tag def {\n     def_fn(def_id);"}, {"sha": "df08e4c8d740f83a5c834f55ca57a7010b11a38f", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -147,7 +147,11 @@ fn new_parser(session::session sess,\n             fn get_chpos() -> uint {ret rdr.get_chpos();}\n \n             fn get_ann() -> ast::ann {\n-                auto rv = ast::ann_none(next_ann_var);\n+                // TODO: Remove ty, tps, and ts. ty and tps should be unused\n+                // by now.\n+                auto rv = rec(id=next_ann_var, ty=0u,\n+                              tps=none[vec[middle::ty::t]],\n+                              ts=none[@middle::tstate::ann::ts_ann]);\n                 next_ann_var += 1u;\n                 ret rv;\n             }"}, {"sha": "2dc56f922dcfa5ff33cdfb19d3ed90ab1094c586", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -193,7 +193,7 @@ fn resolve_names(&@env e, &ast::crate c) {\n             case (ast::expr_path(?p, ?a)) {\n                 auto df = lookup_path_strict(*e, *sc, exp.span, p.node.idents,\n                                              ns_value);\n-                e.def_map.insert(ast::ann_tag(a), df);\n+                e.def_map.insert(a.id, df);\n             }\n             case (_) {}\n         }\n@@ -203,7 +203,7 @@ fn resolve_names(&@env e, &ast::crate c) {\n             case (ast::ty_path(?p, ?a)) {\n                 auto new_def = lookup_path_strict(*e, *sc, t.span,\n                                                   p.node.idents, ns_type);\n-                e.def_map.insert(ast::ann_tag(a), new_def);\n+                e.def_map.insert(a.id, new_def);\n             }\n             case (_) {}\n         }\n@@ -219,7 +219,7 @@ fn resolve_names(&@env e, &ast::crate c) {\n                                               ns_value);\n                 alt (fnd) {\n                     case (ast::def_variant(?did, ?vid)) {\n-                        e.def_map.insert(ast::ann_tag(a), fnd);\n+                        e.def_map.insert(a.id, fnd);\n                     }\n                     case (_) {\n                         e.sess.span_err(p.span, \"not a tag variant: \" +"}, {"sha": "632fdaedd5aaa2d7110dc4e9155044c17bb4319f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -3804,7 +3804,7 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n     fn walk_expr(env e, &@ast::expr expr) {\n         alt (expr.node) {\n             case (ast::expr_path(?path, ?ann)) {\n-                alt (e.def_map.get(ast::ann_tag(ann))) {\n+                alt (e.def_map.get(ann.id)) {\n                     case (ast::def_arg(?did)) {\n                         vec::push[ast::def_id](e.refs, did);\n                     }\n@@ -4126,7 +4126,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             auto lldiscrim = cx.build.Load(lldiscrimptr);\n \n             auto vdef = ast::variant_def_ids\n-                (cx.fcx.lcx.ccx.tcx.def_map.get(ast::ann_tag(ann)));\n+                (cx.fcx.lcx.ccx.tcx.def_map.get(ann.id));\n             auto variant_tag = 0;\n \n             auto variants = tag_variants(cx.fcx.lcx.ccx, vdef._0);\n@@ -4205,7 +4205,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat,\n \n             // Get the appropriate variant for this tag.\n             auto vdef = ast::variant_def_ids\n-                (cx.fcx.lcx.ccx.tcx.def_map.get(ast::ann_tag(ann)));\n+                (cx.fcx.lcx.ccx.tcx.def_map.get(ann.id));\n \n             auto lltagptr = cx.build.PointerCast(llval,\n                 T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n@@ -4368,7 +4368,7 @@ fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n }\n \n fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n-    alt (cx.fcx.lcx.ccx.tcx.def_map.get(ast::ann_tag(ann))) {\n+    alt (cx.fcx.lcx.ccx.tcx.def_map.get(ann.id)) {\n         case (ast::def_arg(?did)) {\n             alt (cx.fcx.llargs.find(did)) {\n                 case (none[ValueRef]) {"}, {"sha": "dbe411b0b66e7b7aa1548b8f895ba443b7845323", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 18, "deletions": 72, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -7,7 +7,6 @@ import std::option::some;\n import std::option::maybe;\n \n import front::ast;\n-import front::ast::ann_tag;\n import front::ast::def;\n import front::ast::def_fn;\n import front::ast::_fn;\n@@ -17,8 +16,6 @@ import front::ast::expr_path;\n import front::ast::ident;\n import front::ast::controlflow;\n import front::ast::ann;\n-import front::ast::ann_none;\n-import front::ast::ann_type;\n import front::ast::ts_ann;\n import front::ast::stmt;\n import front::ast::expr;\n@@ -188,27 +185,15 @@ fn ann_to_ts_ann(ann a, uint nv) -> @ts_ann {\n }\n \n \n-fn ann_to_ts_ann_fail(ann a) -> option::t[@ts_ann] {\n-  alt (a) {\n-    case (ann_none(_)) { \n-          log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n-          fail;\n-      }\n-    case (ann_type(_,_,_,?ty)) {\n-          ret ty;\n-      }\n-  }\n-}\n+fn ann_to_ts_ann_fail(ann a) -> option::t[@ts_ann] { ret a.ts; }\n \n fn ann_to_ts_ann_strict(ann a) -> @ts_ann {\n     alt (ann_to_ts_ann_fail(a)) {\n-        case (none[@ts_ann])         {    \n-            log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n+        case (none[@ts_ann]) {\n+            log(\"ann_to_ts_ann_strict: didn't expect none here\");\n             fail;\n         }\n-        case (some[@ts_ann](?t))        {     \n-            ret t;\n-        }\n+        case (some[@ts_ann](?t)) { ret t; }\n     }\n }\n \n@@ -320,18 +305,9 @@ fn block_poststate(&block b) -> poststate {\n \n /* returns a new annotation where the pre_and_post is p */\n fn with_pp(ann a, pre_and_post p) -> ann {\n-  alt (a) {\n-    case (ann_none(_)) {\n-      log(\"with_pp: the impossible happened\");\n-      fail; /* shouldn't happen b/c code is typechecked */\n-    }\n-    case (ann_type(?i, ?t, ?ps, _)) {\n-        ret (ann_type(i, t, ps,\n-                    some[@ts_ann]\n-                    (@rec(conditions=p,\n-                          states=empty_states(pps_len(p))))));\n-    }\n-  }\n+    ret rec(id=a.id, ty=a.ty, tps=a.tps,\n+            ts=some[@ts_ann](@rec(conditions=p,\n+                                  states=empty_states(pps_len(p)))));\n }\n \n fn set_prestate_ann(&ann a, &prestate pre) -> bool {\n@@ -379,50 +355,22 @@ fn fixed_point_states(&fn_ctxt fcx,\n }\n \n fn init_ann(&fn_info fi, &ann a) -> ann {\n-    alt (a) {\n-        case (ann_none(_)) {\n-            //            log(\"init_ann: shouldn't see ann_none\");\n-            // fail;\n-            log(\"warning: init_ann: saw ann_none\");\n-            ret a; // Would be better to fail so we can catch bugs that\n-            // result in an uninitialized ann -- but don't want to have to\n-            // write code to handle native_mods properly\n-        }\n-        case (ann_type(?i, ?t, ?ps, _)) {\n-            ret ann_type(i, t, ps, some[@ts_ann](@empty_ann(num_locals(fi))));\n-        }\n-    }\n+    ret rec(id=a.id, ty=a.ty, tps=a.tps,\n+            ts=some[@ts_ann](@empty_ann(num_locals(fi))));\n }\n \n fn init_blank_ann(&() ignore, &ann a) -> ann {\n-    alt (a) {\n-        case (ann_none(_)) {\n-            //            log(\"init_blank_ann: shouldn't see ann_none\");\n-            //fail;\n-            log(\"warning: init_blank_ann: saw ann_none\");\n-            ret a;\n-        }\n-        case (ann_type(?i, ?t, ?ps,_)) {\n-            ret ann_type(i, t, ps, some[@ts_ann](@empty_ann(0u)));\n-        }\n-    }\n+    ret rec(id=a.id, ty=a.ty, tps=a.tps, ts=some[@ts_ann](@empty_ann(0u)));\n }\n \n fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n     log(\"init_block:\");\n     log_block(respan(sp, b));\n-    alt(b.a) {\n-        case (ann_none(_)) {\n-            log(\"init_block: shouldn't see ann_none\");\n-            fail;\n-        }\n-        case (ann_type(_, _, _, _)) {\n-            auto fld0 = new_identity_fold[fn_info]();\n \n-            fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n-            ret fold_block[fn_info](fi, fld0, respan(sp, b)); \n-        }\n-    }\n+    auto fld0 = new_identity_fold[fn_info]();\n+\n+    fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n+    ret fold_block[fn_info](fi, fld0, respan(sp, b)); \n }\n \n fn num_locals(fn_info m) -> uint {\n@@ -445,7 +393,7 @@ fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n    There's no case for fail b/c we assume e is the callee and it\n    seems unlikely that one would apply \"fail\" to arguments. */\n fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n-    auto f = ann_tag(expr_ann(e));\n+    auto f = expr_ann(e).id;\n     alt (ccx.tcx.def_map.find(f)) {\n         case (some[def](def_fn(?d)))        { ret controlflow_def_id(ccx, d); }\n         case (some[def](def_obj_field(?d))) { ret controlflow_def_id(ccx, d); }\n@@ -454,19 +402,17 @@ fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n }\n \n fn ann_to_def_strict(&crate_ctxt ccx, &ann a) -> def {\n-    alt (ccx.tcx.def_map.find(ann_tag(a))) {\n+    alt (ccx.tcx.def_map.find(a.id)) {\n         case (none[def]) { \n-            log_err(\"ann_to_def: node_id \" +\n-                    uistr(ann_tag(a)) +\n-                    \" has no def\");\n+            log_err(\"ann_to_def: node_id \" + uistr(a.id) + \" has no def\");\n             fail;\n         }\n         case (some[def](?d)) { ret d; }\n     }\n }\n \n fn ann_to_def(&crate_ctxt ccx, &ann a) -> option::t[def] {\n-    ret ccx.tcx.def_map.find(ann_tag(a));\n+    ret ccx.tcx.def_map.find(a.id);\n }\n \n //"}, {"sha": "9ba40b345b22ff7ed6ea7e8fb6cd508c281f2b0d", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -80,8 +80,6 @@ import front::ast::controlflow;\n import front::ast::return;\n import front::ast::noreturn;\n import front::ast::_fn;\n-import front::ast::ann_none;\n-import front::ast::ann_type;\n import front::ast::_obj;\n import front::ast::_mod;\n import front::ast::crate;"}, {"sha": "434ec2fe3dcca6433c4e72bbe7dc80a0b4b03942", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -92,8 +92,6 @@ import front::ast::init_op;\n import front::ast::controlflow;\n import front::ast::return;\n import front::ast::noreturn;\n-import front::ast::ann_none;\n-import front::ast::ann_type;\n import front::ast::_obj;\n import front::ast::_mod;\n import front::ast::crate;\n@@ -243,7 +241,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n   /*\n   log_err(\"states:\");\n   log_expr_err(*e);\n-  log_err(ast.ann_tag(middle.ty.expr_ann(e)));\n+  log_err(middle::ty::expr_ann(e).id);\n   */\n \n   /* FIXME could get rid of some of the copy/paste */"}, {"sha": "0526304f06653677f1619251b7efc4f08ca67cd4", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -1452,7 +1452,7 @@ fn eq_ty(&t a, &t b) -> bool { ret a == b; }\n \n fn ann_to_ty_param_substs_opt_and_ty(&node_type_table ntt, &ast::ann ann)\n         -> ty_param_substs_opt_and_ty {\n-    alt (ntt.(ast::ann_tag(ann))) {\n+    alt (ntt.(ann.id)) {\n         case (none[ty::ty_param_substs_opt_and_ty]) {\n             log_err \"ann_to_ty_param_substs_opt_and_ty() called on an \" +\n                 \"untyped node\";\n@@ -1495,19 +1495,25 @@ fn ann_to_monotype(ctxt cx, &node_type_table ntt, ast::ann a) -> t {\n }\n \n \n-// Turns a type into an ann_type, using defaults for other fields.\n+// Turns a type and optional type parameters into an annotation, using\n+// defaults for other fields.\n+fn mk_ann_type(uint node_id, t typ, option::t[vec[t]] tps) -> ast::ann {\n+    ret rec(id=node_id, ty=typ, tps=tps, ts=none[@ts_ann]);\n+}\n+\n+// Turns a type into an annotation, using defaults for other fields.\n fn triv_ann(uint node_id, t typ) -> ast::ann {\n-    ret ast::ann_type(node_id, typ, none[vec[t]], none[@ts_ann]);\n+    ret mk_ann_type(node_id, typ, none[vec[t]]);\n }\n \n // Creates a nil type annotation.\n fn plain_ann(uint node_id, ctxt tcx) -> ast::ann {\n-    ret ast::ann_type(node_id, mk_nil(tcx), none[vec[t]], none[@ts_ann]);\n+    ret triv_ann(node_id, mk_nil(tcx));\n }\n \n // Creates a _|_ type annotation.\n fn bot_ann(uint node_id, ctxt tcx) -> ast::ann {\n-    ret ast::ann_type(node_id, mk_bot(tcx), none[vec[t]], none[@ts_ann]);\n+    ret triv_ann(node_id, mk_bot(tcx));\n }\n \n "}, {"sha": "3e86111dc4022622239f4d3cf010e990b409326f", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 206, "deletions": 275, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -1,6 +1,5 @@\n import front::ast;\n import front::ast::ann;\n-import front::ast::ann_none;\n import front::ast::mutability;\n import front::creader;\n import middle::fold;\n@@ -18,6 +17,7 @@ import middle::ty::block_ty;\n import middle::ty::expr_ty;\n import middle::ty::field;\n import middle::ty::method;\n+import middle::ty::mk_ann_type;\n import middle::ty::mo_val;\n import middle::ty::mo_alias;\n import middle::ty::mo_either;\n@@ -319,7 +319,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         }\n \n         case (ast::ty_path(?path, ?ann)) {\n-            alt (tcx.def_map.get(ast::ann_tag(ann))) {\n+            alt (tcx.def_map.get(ann.id)) {\n                 case (ast::def_ty(?id)) {\n                     typ = instantiate(tcx, getter, id, path.node.types);\n                 }\n@@ -650,11 +650,10 @@ mod collect {\n             auto tpt = tup(ty_param_count, result_ty);\n             cx.type_cache.insert(variant.node.id, tpt);\n             auto variant_t = rec(\n-                ann=triv_ann(ast::ann_tag(variant.node.ann), result_ty)\n+                ann=triv_ann(variant.node.ann.id, result_ty)\n                 with variant.node\n             );\n-            write_type_only(cx.node_types, ast::ann_tag(variant.node.ann),\n-                            result_ty);\n+            write_type_only(cx.node_types, variant.node.ann.id, result_ty);\n             result += [fold::respan(variant.span, variant_t)];\n         }\n \n@@ -705,7 +704,7 @@ mod collect {\n             }\n             case (ast::item_tag(_, ?variants, ?ty_params, ?tag_id, ?ann)) {\n                 auto tpt = ty_of_item(cx, it);\n-                write_type_only(cx.node_types, ast::ann_tag(ann), tpt._1);\n+                write_type_only(cx.node_types, ann.id, tpt._1);\n \n                 get_tag_variant_types(cx, tag_id, variants, ty_params);\n             }\n@@ -717,7 +716,7 @@ mod collect {\n                 // we write into the table for this item.\n                 auto tpt = ty_of_obj_ctor(cx, ident, object, odid.ctor,\n                                           ty_params);\n-                write_type_only(cx.node_types, ast::ann_tag(ann), tpt._1);\n+                write_type_only(cx.node_types, ann.id, tpt._1);\n \n                 // Write the methods into the type table.\n                 //\n@@ -728,7 +727,7 @@ mod collect {\n                 auto i = 0u;\n                 while (i < vec::len[@ast::method](object.methods)) {\n                     write_type_only(cx.node_types,\n-                                    ast::ann_tag(object.methods.(i).node.ann),\n+                                    object.methods.(i).node.ann.id,\n                                     ty::method_ty_to_fn_ty(cx.tcx,\n                                         method_types.(i)));\n                     i += 1u;\n@@ -742,8 +741,7 @@ mod collect {\n                 i = 0u;\n                 while (i < vec::len[ty::arg](args)) {\n                     auto fld = object.fields.(i);\n-                    write_type_only(cx.node_types, ast::ann_tag(fld.ann),\n-                                    args.(i).ty);\n+                    write_type_only(cx.node_types, fld.ann.id, args.(i).ty);\n                     i += 1u;\n                 }\n \n@@ -755,8 +753,7 @@ mod collect {\n                         let vec[arg] no_args = [];\n                         auto t = ty::mk_fn(cx.tcx, ast::proto_fn, no_args,\n                                            ty::mk_nil(cx.tcx));\n-                        write_type_only(cx.node_types,\n-                                        ast::ann_tag(m.node.ann), t);\n+                        write_type_only(cx.node_types, m.node.ann.id, t);\n                     }\n                 }\n             }\n@@ -765,8 +762,7 @@ mod collect {\n                 // of the item in passing. All we have to do here is to write\n                 // it into the node type table.\n                 auto tpt = ty_of_item(cx, it);\n-                write_type_only(cx.node_types, ast::ann_tag(ty::item_ann(it)),\n-                                tpt._1);\n+                write_type_only(cx.node_types, ty::item_ann(it).id, tpt._1);\n             }\n         }\n     }\n@@ -784,7 +780,7 @@ mod collect {\n                 // FIXME: Native types have no annotation. Should they? --pcw\n             }\n             case (ast::native_item_fn(_,_,_,_,_,?a)) {\n-                write_type_only(cx.node_types, ast::ann_tag(a), tpt._1);\n+                write_type_only(cx.node_types, a.id, tpt._1);\n             }\n         }\n     }\n@@ -1094,20 +1090,20 @@ mod Pushdown {\n             case (ast::pat_wild(?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n+                write_type(fcx.ccx.node_types, ann.id,\n                            tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n+                write_type(fcx.ccx.node_types, ann.id,\n                            tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_bind(?id, ?did, ?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n                 fcx.locals.insert(did, t);\n-                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n+                write_type(fcx.ccx.node_types, ann.id,\n                            tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_tag(?id, ?subpats, ?ann)) {\n@@ -1142,7 +1138,7 @@ mod Pushdown {\n                 }\n \n                 auto arg_tys;\n-                alt (fcx.ccx.tcx.def_map.get(ast::ann_tag(ann))) {\n+                alt (fcx.ccx.tcx.def_map.get(ann.id)) {\n                     case (ast::def_variant(_, ?vdefid)) {\n                         arg_tys = variant_arg_types(fcx.ccx, pat.span, vdefid,\n                                                     tparams);\n@@ -1161,13 +1157,11 @@ mod Pushdown {\n                 let ty_param_substs_and_ty res_t = Demand::full(fcx, pat.span,\n                       expected, tt, tps, NO_AUTODEREF);\n \n-                auto a_1 = ast::ann_type(ast::ann_tag(ann),\n-                                               res_t._1,\n-                                               some[vec[ty::t]](res_t._0),\n-                                         none[@ts_ann]);\n+                auto a_1 = mk_ann_type(ann.id, res_t._1,\n+                                       some[vec[ty::t]](res_t._0));\n \n                 // TODO: push down type from \"expected\".\n-                write_type(fcx.ccx.node_types, ast::ann_tag(a_1),\n+                write_type(fcx.ccx.node_types, ann.id,\n                     ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.node_types,\n                                                           a_1));\n                     \n@@ -1208,9 +1202,8 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_vec(es_1, mut,\n-                                    triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_vec(es_1, mut, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n@@ -1231,8 +1224,8 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_tup(elts_1, triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_tup(elts_1, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n \n@@ -1289,16 +1282,14 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_rec(fields_1, base_1,\n-                                    triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_rec(fields_1, base_1, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_bind(sube, es,\n-                                     triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_bind(sube, es, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_call(?sube, ?es, ?ann)) {\n                 // NB: we call 'Demand::autoderef' and pass in adk only in\n@@ -1307,45 +1298,40 @@ mod Pushdown {\n                 // so there's no need.\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_call(sube, es,\n-                                     triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_call(sube, es, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_self_method(id,\n-                                            triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_self_method(id, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_binary(bop, lhs, rhs,\n-                                       triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_binary(bop, lhs, rhs, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // Demand::autoderef.\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_unary(uop, sube,\n-                                      triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_unary(uop, sube, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_lit(lit, triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_lit(lit, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_cast(sube, ast_ty,\n-                                     triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_cast(sube, ast_ty, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n@@ -1360,75 +1346,68 @@ mod Pushdown {\n                         else_1 = some[@ast::expr](e_1);\n                     }\n                 }\n-                e_1 = ast::expr_if(cond, then_1, else_1,\n-                                   triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_if(cond, then_1, else_1, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_for(decl, seq, bloc,\n-                                    triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_for(decl, seq, bloc, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_for_each(decl, seq, bloc,\n-                                         triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                                         triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_while(cond, bloc,\n-                                      triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_while(cond, bloc, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_do_while(bloc, cond,\n-                                         triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_do_while(bloc, cond, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_block(bloc, triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_block(bloc, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n-                e_1 = ast::expr_assign(lhs_1, rhs_1,\n-                                       triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_assign(lhs_1, rhs_1, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n                 e_1 = ast::expr_assign_op(op, lhs_1, rhs_1,\n-                                          triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                                          triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_field(lhs, rhs,\n-                                      triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_field(lhs, rhs, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_index(base, index,\n-                                      triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_index(base, index, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_path(?pth, ?ann)) {\n                 auto tp_substs_0 = ty::ann_to_type_params(fcx.ccx.node_types,\n@@ -1442,37 +1421,25 @@ mod Pushdown {\n                 // Fill in the type parameter substitutions if they weren't\n                 // provided by the programmer.\n                 auto ty_params_opt;\n-                alt (ann) {\n-                    case (ast::ann_none(_)) {\n-                        log_err \"pushdown_expr(): no type annotation for \" +\n-                            \"path expr; did you pass it to check_expr()?\";\n-                        fail;\n+                alt (ann.tps) {\n+                    case (none[vec[ty::t]]) {\n+                        ty_params_opt = none[vec[ty::t]];\n                     }\n-                    case (ast::ann_type(_, _, ?tps_opt, _)) {\n-                        alt (tps_opt) {\n-                            case (none[vec[ty::t]]) {\n-                                ty_params_opt = none[vec[ty::t]];\n-                            }\n-                            case (some[vec[ty::t]](?tps)) {\n-                                ty_params_opt = some[vec[ty::t]](tps);\n-                            }\n-                        }\n+                    case (some[vec[ty::t]](?tps)) {\n+                        ty_params_opt = some[vec[ty::t]](tps);\n                     }\n                 }\n \n-                e_1 = ast::expr_path(pth,\n-                                     ast::ann_type(ast::ann_tag(ann), t,\n-                                                   ty_params_opt,\n-                                                   none[@ts_ann]));\n-                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n-                           tup(ty_params_opt, t));\n+                e_1 = ast::expr_path(pth, mk_ann_type(ann.id, t,\n+                                                      ty_params_opt));\n+                write_type(fcx.ccx.node_types, ann.id, tup(ty_params_opt, t));\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_ext(p, args, body, expanded,\n-                                    triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                                    triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             /* FIXME: should this check the type annotations? */\n             case (ast::expr_fail(_))  { e_1 = e.node; }\n@@ -1488,8 +1455,8 @@ mod Pushdown {\n             case (ast::expr_port(?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_port(triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_port(triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n@@ -1506,8 +1473,8 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_chan(es_1, triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_chan(es_1, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (ast::expr_alt(?discrim, ?arms_0, ?ann)) {\n@@ -1520,9 +1487,8 @@ mod Pushdown {\n                     auto arm_1 = rec(pat=arm_0.pat, block=block_1);\n                     arms_1 += [arm_1];\n                 }\n-                e_1 = ast::expr_alt(discrim, arms_1,\n-                                    triv_ann(ast::ann_tag(ann), t));\n-                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n+                e_1 = ast::expr_alt(discrim, arms_1, triv_ann(ann.id, t));\n+                write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (ast::expr_recv(?lval_0, ?expr_0, ?ann)) {\n@@ -1562,19 +1528,18 @@ mod Pushdown {\n                 auto e_1 = pushdown_expr(fcx, expected, e_0);\n                 auto block_ = rec(stmts=bloc.node.stmts,\n                                   expr=some[@ast::expr](e_1),\n-                                  a=plain_ann(ast::ann_tag(bloc.node.a),\n+                                  a=plain_ann(bloc.node.a.id,\n                                               fcx.ccx.tcx));\n                 write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                               ast::ann_tag(bloc.node.a));\n+                               bloc.node.a.id);\n                 ret fold::respan[ast::block_](bloc.span, block_);\n             }\n             case (none[@ast::expr]) {\n                 Demand::simple(fcx, bloc.span, expected,\n                               ty::mk_nil(fcx.ccx.tcx));\n-                auto new_ann = plain_ann(ast::ann_tag(bloc.node.a),\n-                                         fcx.ccx.tcx);\n+                auto new_ann = plain_ann(bloc.node.a.id, fcx.ccx.tcx);\n                 write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                               ast::ann_tag(bloc.node.a));\n+                               bloc.node.a.id);\n                 ret fold::respan(bloc.span, rec(a=new_ann with bloc.node));\n                                             \n             }\n@@ -1602,10 +1567,8 @@ fn writeback_local(&option::t[@fn_ctxt] env, &span sp, &@ast::local local)\n         }\n     }\n \n-    auto local_wb = @rec(ann=triv_ann(ast::ann_tag(local.ann), local_ty)\n-                         with *local\n-    );\n-    write_type_only(fcx.ccx.node_types, ast::ann_tag(local.ann), local_ty);\n+    auto local_wb = @rec(ann=triv_ann(local.ann.id, local_ty) with *local);\n+    write_type_only(fcx.ccx.node_types, local.ann.id, local_ty);\n     ret @fold::respan[ast::decl_](sp, ast::decl_local(local_wb));\n }\n \n@@ -1619,23 +1582,15 @@ fn resolve_local_types_in_annotation(&option::t[@fn_ctxt] env, &ast::ann ann)\n     }\n \n     auto fcx = option::get[@fn_ctxt](env);\n-    alt (ann) {\n-        case (ast::ann_none(_)) {\n-            log \"warning: no type for expression\";\n-            ret ann;\n-        }\n-        case (ast::ann_type(?tg, ?typ, ?tps, ?ts_info)) {\n-            auto tt = ann_to_type(fcx.ccx.node_types, ann);\n-            if (!ty::type_contains_locals(fcx.ccx.tcx, tt)) {\n-                ret ann;\n-            }\n-            auto f = bind resolver(fcx, _);\n-            auto new_type = ty::fold_ty(fcx.ccx.tcx, f,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-            write_type(fcx.ccx.node_types, tg, tup(tps, new_type));\n-            ret ast::ann_type(tg, new_type, tps, ts_info);\n-        }\n-    }\n+\n+    auto tt = ann_to_type(fcx.ccx.node_types, ann);\n+    if (!ty::type_contains_locals(fcx.ccx.tcx, tt)) { ret ann; }\n+\n+    auto f = bind resolver(fcx, _);\n+    auto new_type = ty::fold_ty(fcx.ccx.tcx, f,\n+                                ann_to_type(fcx.ccx.node_types, ann));\n+    write_type(fcx.ccx.node_types, ann.id, tup(ann.tps, new_type));\n+    ret mk_ann_type(ann.id, new_type, ann.tps);\n }\n \n fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast::block block)\n@@ -1670,8 +1625,7 @@ fn replace_expr_type(&node_type_table ntt,\n         new_tps = none[vec[ty::t]];\n     }\n \n-    write_type(ntt, ast::ann_tag(ty::expr_ann(expr)),\n-               tup(new_tps, new_tyt._1));\n+    write_type(ntt, ty::expr_ann(expr).id, tup(new_tps, new_tyt._1));\n }\n \n \n@@ -1697,22 +1651,22 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n     alt (pat.node) {\n         case (ast::pat_wild(?ann)) {\n             auto typ = next_ty_var(fcx.ccx);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), typ);\n+            write_type_only(fcx.ccx.node_types, ann.id, typ);\n         }\n         case (ast::pat_lit(?lt, ?ann)) {\n             auto typ = check_lit(fcx.ccx, lt);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), typ);\n+            write_type_only(fcx.ccx.node_types, ann.id, typ);\n         }\n         case (ast::pat_bind(?id, ?def_id, ?a)) {\n             auto typ = next_ty_var(fcx.ccx);\n-            auto ann = triv_ann(ast::ann_tag(a), typ);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), typ);\n+            auto ann = triv_ann(a.id, typ);\n+            write_type_only(fcx.ccx.node_types, ann.id, typ);\n         }\n         case (ast::pat_tag(?p, ?subpats, ?old_ann)) {\n             auto vdef = ast::variant_def_ids\n-                (fcx.ccx.tcx.def_map.get(ast::ann_tag(old_ann)));\n+                (fcx.ccx.tcx.def_map.get(old_ann.id));\n             auto t = ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n-                                         fcx.ccx.type_cache, vdef._1)._1;\n+                                          fcx.ccx.type_cache, vdef._1)._1;\n             auto len = vec::len[ast::ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n \n@@ -1742,8 +1696,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n                         check_pat(fcx, subpat);\n                     }\n \n-                    write_type(fcx.ccx.node_types, ast::ann_tag(old_ann),\n-                               path_tpot);\n+                    write_type(fcx.ccx.node_types, old_ann.id, path_tpot);\n                 }\n \n                 // Nullary variants have tag types.\n@@ -1761,8 +1714,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n                         fail;   // TODO: recover\n                     }\n \n-                    write_type(fcx.ccx.node_types, ast::ann_tag(old_ann),\n-                               path_tpot);\n+                    write_type(fcx.ccx.node_types, old_ann.id, path_tpot);\n                 }\n             }\n         }\n@@ -1798,7 +1750,7 @@ fn require_pure_call(@crate_ctxt ccx,\n             alt (callee.node) {\n                 case (ast::expr_path(_, ?ann)) {\n                     auto d_id;\n-                    alt (ccx.tcx.def_map.get(ast::ann_tag(ann))) {\n+                    alt (ccx.tcx.def_map.get(ann.id)) {\n                         case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n                     }\n                     alt (get_function_purity(ccx, d_id)) {\n@@ -1909,9 +1861,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         auto rhs_1 = Pushdown::pushdown_expr(fcx,\n             expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_1), rhs_0);\n \n-        auto ann = triv_ann(ast::ann_tag(a),\n+        auto ann = triv_ann(a.id,\n                             expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_1));\n-        write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n+        write_type_only(fcx.ccx.node_types, a.id,\n                         expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_1));\n         ret tup(lhs_1, rhs_1, ann);\n     }\n@@ -1940,8 +1892,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n     alt (expr.node) {\n         case (ast::expr_lit(?lit, ?a)) {\n             auto typ = check_lit(fcx.ccx, lit);\n-            auto ann = triv_ann(ast::ann_tag(a), typ);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+            auto ann = triv_ann(a.id, typ);\n+            write_type_only(fcx.ccx.node_types, a.id, typ);\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_lit(lit, ann));\n         }\n \n@@ -1971,8 +1923,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (_) { /* fall through */ }\n             }\n \n-            auto ann = triv_ann(ast::ann_tag(a), t);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t);\n+            auto ann = triv_ann(a.id, t);\n+            write_type_only(fcx.ccx.node_types, a.id, t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_binary(binop, lhs_1,\n                                                            rhs_1, ann));\n@@ -2003,27 +1955,25 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (_) { oper_t = strip_boxes(fcx.ccx.tcx, oper_t); }\n             }\n \n-            auto ann = triv_ann(ast::ann_tag(a), oper_t);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), oper_t);\n+            auto ann = triv_ann(a.id, oper_t);\n+            write_type_only(fcx.ccx.node_types, a.id, oper_t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_unary(unop, oper_1, ann));\n         }\n \n         case (ast::expr_path(?pth, ?old_ann)) {\n             auto t = ty::mk_nil(fcx.ccx.tcx);\n-            auto defn = fcx.ccx.tcx.def_map.get(ast::ann_tag(old_ann));\n+            auto defn = fcx.ccx.tcx.def_map.get(old_ann.id);\n \n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n \n             if (ty::def_has_ty_params(defn)) {\n                 auto path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n                 auto did = ast::def_id_of_def(defn);\n-                write_type(fcx.ccx.node_types, ast::ann_tag(old_ann),\n-                           path_tpot);\n+                write_type(fcx.ccx.node_types, old_ann.id, path_tpot);\n                 ret @fold::respan[ast::expr_](expr.span,\n-                    ast::expr_path(pth,\n-                        ast::ann_type(ast::ann_tag(old_ann), path_tpot._1,\n-                                      path_tpot._0, none[@ts_ann])));\n+                    ast::expr_path(pth, mk_ann_type(old_ann.id, path_tpot._1,\n+                                                    path_tpot._0)));\n             }\n \n             // The definition doesn't take type parameters. If the programmer\n@@ -2034,40 +1984,38 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 fail;\n             }\n \n-            auto e = ast::expr_path(pth, triv_ann(ast::ann_tag(old_ann),\n-                                                  tpt._1));\n-            write_type_only(fcx.ccx.node_types,\n-                            ast::ann_tag(old_ann), tpt._1);\n+            auto e = ast::expr_path(pth, triv_ann(old_ann.id, tpt._1));\n+            write_type_only(fcx.ccx.node_types, old_ann.id, tpt._1);\n             ret @fold::respan[ast::expr_](expr.span, e);\n         }\n \n         case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n             auto exp_ = check_expr(fcx, expanded);\n             auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, exp_);\n-            auto ann = triv_ann(ast::ann_tag(a), t);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t);\n+            auto ann = triv_ann(a.id, t);\n+            write_type_only(fcx.ccx.node_types, a.id, t);\n             ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_ext(p, args, body, exp_,\n-                                                     ann));\n+                                          ast::expr_ext(p, args, body, exp_,\n+                                                        ann));\n         }\n \n         case (ast::expr_fail(?a)) {\n-            auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n+            auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n+            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_fail(new_ann));\n         }\n \n         case (ast::expr_break(?a)) {\n-            auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n+            // TODO: should be something like 'a or noret\n+            auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n+            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_break(new_ann));\n         }\n \n         case (ast::expr_cont(?a)) {\n-            // TODO: should be something like 'a or noret\n-            auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n+            auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n+            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_cont(new_ann));\n         }\n \n@@ -2080,9 +2028,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                          + \"returning non-nil\");\n                     }\n \n-                    auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                   ast::ann_tag(a));\n+                    auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n+                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n                     ret @fold::respan[ast::expr_]\n                         (expr.span,\n@@ -2094,9 +2041,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     auto expr_1 = Pushdown::pushdown_expr(fcx, fcx.ret_ty,\n                                                          expr_0);\n \n-                    auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                   ast::ann_tag(a));\n+                    auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n+                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n                     ret @fold::respan[ast::expr_]\n                         (expr.span, ast::expr_ret(some(expr_1), new_ann));\n@@ -2115,9 +2061,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                          + \"putting non-nil\");\n                     }\n \n-                    auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                   ast::ann_tag(a));\n+                    auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n+                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n                     ret @fold::respan[ast::expr_]\n                         (expr.span, ast::expr_put(none[@ast::expr], new_ann));\n@@ -2128,9 +2073,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     auto expr_1 = Pushdown::pushdown_expr(fcx, fcx.ret_ty,\n                                                          expr_0);\n \n-                    auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                   ast::ann_tag(a));\n+                    auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n+                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n                     ret @fold::respan[ast::expr_]\n                         (expr.span, ast::expr_put(some(expr_1), new_ann));\n@@ -2143,17 +2087,18 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             assert (ast::is_call_expr(e));\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = Pushdown::pushdown_expr(fcx, fcx.ret_ty, expr_0);\n-            auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n+\n+            auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n+            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n             ret @fold::respan(expr.span, ast::expr_be(expr_1, new_ann));\n         }\n \n         case (ast::expr_log(?l, ?e, ?a)) {\n             auto expr_t = check_expr(fcx, e);\n \n-            auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n+            auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n+            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_log(l, expr_t, new_ann));\n@@ -2170,7 +2115,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     alt (operator.node) {\n                         case (ast::expr_path(?oper_name, ?ann)) {\n                             auto d_id;\n-                            alt (fcx.ccx.tcx.def_map.get(ast::ann_tag(ann))) {\n+                            alt (fcx.ccx.tcx.def_map.get(ann.id)) {\n                                 case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n                             }\n                             for (@ast::expr operand in operands) {\n@@ -2183,10 +2128,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n                             require_pure_function(fcx.ccx, d_id, expr.span);\n \n-                            auto new_ann = plain_ann(ast::ann_tag(a),\n-                                                     fcx.ccx.tcx);\n+                            auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n                             write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                           ast::ann_tag(a));\n+                                           a.id);\n \n                             ret @fold::respan[ast::expr_]\n                                 (expr.span, ast::expr_check(expr_t, new_ann));\n@@ -2210,8 +2154,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             Demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx),\n                           expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t));\n \n-            auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n+            auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n+            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_assert(expr_t, new_ann));\n@@ -2259,8 +2203,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n             auto rhs_1 = Pushdown::pushdown_expr(fcx, item_t, rhs_0);\n \n-            auto ann = triv_ann(ast::ann_tag(a), chan_t);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), chan_t);\n+            auto ann = triv_ann(a.id, chan_t);\n+            write_type_only(fcx.ccx.node_types, a.id, chan_t);\n             auto newexpr = ast::expr_send(lhs_1, rhs_1, ann);\n             ret @fold::respan[ast::expr_](expr.span, newexpr);\n         }\n@@ -2286,8 +2230,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n             auto lhs_1 = Pushdown::pushdown_expr(fcx, item_t, lhs_0);\n \n-            auto ann = triv_ann(ast::ann_tag(a), item_t);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), item_t);\n+            auto ann = triv_ann(a.id, item_t);\n+            write_type_only(fcx.ccx.node_types, a.id, item_t);\n             auto newexpr = ast::expr_recv(lhs_1, rhs_1, ann);\n             ret @fold::respan[ast::expr_](expr.span, newexpr);\n         }\n@@ -2319,8 +2263,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             auto thn_1 = Pushdown::pushdown_block(fcx, elsopt_t, thn_0);\n \n-            auto ann = triv_ann(ast::ann_tag(a), elsopt_t);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), elsopt_t);\n+            auto ann = triv_ann(a.id, elsopt_t);\n+            write_type_only(fcx.ccx.node_types, a.id, elsopt_t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_if(cond_1, thn_1,\n                                                     elsopt_1, ann));\n@@ -2335,8 +2279,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             // of the seq.\n \n             auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            auto ann = triv_ann(ast::ann_tag(a), typ);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+            auto ann = triv_ann(a.id, typ);\n+            write_type_only(fcx.ccx.node_types, a.id, typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_for(decl_1, seq_1,\n                                                       body_1, ann));\n@@ -2348,8 +2292,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto body_1 = check_block(fcx, body);\n \n             auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            auto ann = triv_ann(ast::ann_tag(a), typ);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+            auto ann = triv_ann(a.id, typ);\n+            write_type_only(fcx.ccx.node_types, a.id, typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_for_each(decl_1, seq_1,\n                                                            body_1, ann));\n@@ -2363,8 +2307,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto body_1 = check_block(fcx, body);\n \n             auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            auto ann = triv_ann(ast::ann_tag(a), typ);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+            auto ann = triv_ann(a.id, typ);\n+            write_type_only(fcx.ccx.node_types, a.id, typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_while(cond_1, body_1,\n                                                           ann));\n@@ -2378,8 +2322,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto body_1 = check_block(fcx, body);\n \n             auto typ = block_ty(fcx.ccx.tcx, fcx.ccx.node_types, body_1);\n-            auto ann = triv_ann(ast::ann_tag(a), typ);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+            auto ann = triv_ann(a.id, typ);\n+            write_type_only(fcx.ccx.node_types, a.id, typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_do_while(body_1, cond_1,\n                                                              ann));\n@@ -2430,8 +2374,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             auto expr_1 = Pushdown::pushdown_expr(fcx, pattern_ty, expr_0);\n \n-            auto ann = triv_ann(ast::ann_tag(a), result_ty);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), result_ty);\n+            auto ann = triv_ann(a.id, result_ty);\n+            write_type_only(fcx.ccx.node_types, a.id, result_ty);\n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_alt(expr_1, arms_1, ann));\n         }\n@@ -2442,13 +2386,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             alt (b_0.node.expr) {\n                 case (some[@ast::expr](?expr)) {\n                     auto typ = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n-                    ann = triv_ann(ast::ann_tag(a), typ);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+                    ann = triv_ann(a.id, typ);\n+                    write_type_only(fcx.ccx.node_types, a.id, typ);\n                 }\n                 case (none[@ast::expr]) {\n                     auto typ = ty::mk_nil(fcx.ccx.tcx);\n-                    ann = triv_ann(ast::ann_tag(a), typ);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+                    ann = triv_ann(a.id, typ);\n+                    write_type_only(fcx.ccx.node_types, a.id, typ);\n                 }\n             }\n             ret @fold::respan(expr.span, ast::expr_block(b_0, ann));\n@@ -2488,8 +2432,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto t_1 = ty::mk_fn(fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n-            auto ann = triv_ann(ast::ann_tag(a), t_1);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t_1);\n+            auto ann = triv_ann(a.id, t_1);\n+            write_type_only(fcx.ccx.node_types, a.id, t_1);\n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_bind(result._0, result._1,\n                                                          ann));\n@@ -2518,8 +2462,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 }\n             }\n \n-            auto ann = triv_ann(ast::ann_tag(a), rt_1);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), rt_1);\n+            auto ann = triv_ann(a.id, rt_1);\n+            write_type_only(fcx.ccx.node_types, a.id, rt_1);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_call(f_1, args_1, ann));\n         }\n@@ -2549,16 +2493,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (ty::ty_obj(?methods)) {\n                     for (ty::method method in methods) {\n                         if (method.ident == id) {\n-                            t = ty::method_ty_to_fn_ty(fcx.ccx.tcx,\n-                                                      method);\n+                            t = ty::method_ty_to_fn_ty(fcx.ccx.tcx, method);\n                         }\n                     }\n                 }\n                 case (_) { fail; }\n             }\n \n-            auto ann = triv_ann(ast::ann_tag(a), t);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t);\n+            auto ann = triv_ann(a.id, t);\n+            write_type_only(fcx.ccx.node_types, a.id, t);\n \n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n@@ -2592,8 +2535,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             // FIXME: Other typechecks needed\n \n             auto typ = ty::mk_task(fcx.ccx.tcx);\n-            auto ann = triv_ann(ast::ann_tag(a), typ);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+            auto ann = triv_ann(a.id, typ);\n+            write_type_only(fcx.ccx.node_types, a.id, typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_spawn(dom, name,\n                                                           f_1, args_1, ann));\n@@ -2613,8 +2556,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     \" as \" + ty_to_str(fcx.ccx.tcx, t_1));\n             }\n \n-            auto ann = triv_ann(ast::ann_tag(a), t_1);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t_1);\n+            auto ann = triv_ann(a.id, t_1);\n+            write_type_only(fcx.ccx.node_types, a.id, t_1);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_cast(e_1, t, ann));\n         }\n@@ -2639,8 +2582,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto typ = ty::mk_vec(fcx.ccx.tcx, rec(ty=t, mut=mut));\n-            auto ann = triv_ann(ast::ann_tag(a), typ);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+            auto ann = triv_ann(a.id, typ);\n+            write_type_only(fcx.ccx.node_types, a.id, typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_vec(args_1, mut, ann));\n         }\n@@ -2658,8 +2601,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n-            auto ann = triv_ann(ast::ann_tag(a), typ);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+            auto ann = triv_ann(a.id, typ);\n+            write_type_only(fcx.ccx.node_types, a.id, typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_tup(elts_1, ann));\n         }\n@@ -2692,8 +2635,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             alt (base) {\n                 case (none[@ast::expr]) {\n                     auto typ = ty::mk_rec(fcx.ccx.tcx, fields_t);\n-                    ann = triv_ann(ast::ann_tag(a), typ);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+                    ann = triv_ann(a.id, typ);\n+                    write_type_only(fcx.ccx.node_types, a.id, typ);\n                 }\n \n                 case (some[@ast::expr](?bexpr)) {\n@@ -2714,9 +2657,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                         }\n                     }\n \n-                    ann = triv_ann(ast::ann_tag(a), bexpr_t);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n-                                    bexpr_t);\n+                    ann = triv_ann(a.id, bexpr_t);\n+                    write_type_only(fcx.ccx.node_types, a.id, bexpr_t);\n \n                     for (ty::field f in fields_t) {\n                         auto found = false;\n@@ -2753,8 +2695,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = triv_ann(ast::ann_tag(a), args.(ix).ty);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n+                    auto ann = triv_ann(a.id, args.(ix).ty);\n+                    write_type_only(fcx.ccx.node_types, a.id,\n                                     args.(ix).ty);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_field(base_1,\n@@ -2769,8 +2711,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    auto ann = triv_ann(ast::ann_tag(a), fields.(ix).mt.ty);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n+                    auto ann = triv_ann(a.id, fields.(ix).mt.ty);\n+                    write_type_only(fcx.ccx.node_types, a.id,\n                                     fields.(ix).mt.ty);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_field(base_1,\n@@ -2788,8 +2730,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     auto meth = methods.(ix);\n                     auto t = ty::mk_fn(fcx.ccx.tcx, meth.proto,\n                                       meth.inputs, meth.output);\n-                    auto ann = triv_ann(ast::ann_tag(a), t);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t);\n+                    auto ann = triv_ann(a.id, t);\n+                    write_type_only(fcx.ccx.node_types, a.id, t);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_field(base_1,\n                                                                field,\n@@ -2819,9 +2761,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n-                    auto ann = triv_ann(ast::ann_tag(a), mt.ty);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n-                                    mt.ty);\n+                    auto ann = triv_ann(a.id, mt.ty);\n+                    write_type_only(fcx.ccx.node_types, a.id, mt.ty);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_index(base_1,\n                                                                idx_1,\n@@ -2835,8 +2776,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n                     auto typ = ty::mk_mach(fcx.ccx.tcx, common::ty_u8);\n-                    auto ann = triv_ann(ast::ann_tag(a), typ);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n+                    auto ann = triv_ann(a.id, typ);\n+                    write_type_only(fcx.ccx.node_types, a.id, typ);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_index(base_1,\n                                                                idx_1,\n@@ -2854,8 +2795,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         case (ast::expr_port(?a)) {\n             auto t = next_ty_var(fcx.ccx);\n             auto pt = ty::mk_port(fcx.ccx.tcx, t);\n-            auto ann = triv_ann(ast::ann_tag(a), pt);\n-            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), pt);\n+            auto ann = triv_ann(a.id, pt);\n+            write_type_only(fcx.ccx.node_types, a.id, pt);\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_port(ann));\n         }\n \n@@ -2865,8 +2806,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             alt (struct(fcx.ccx.tcx, port_t)) {\n                 case (ty::ty_port(?subtype)) {\n                     auto ct = ty::mk_chan(fcx.ccx.tcx, subtype);\n-                    auto ann = triv_ann(ast::ann_tag(a), ct);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), ct);\n+                    auto ann = triv_ann(a.id, ct);\n+                    write_type_only(fcx.ccx.node_types, a.id, ct);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_chan(expr_1, ann));\n                 }\n@@ -2912,14 +2853,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n             }\n \n             auto a_res = local.ann;\n-            alt (a_res) {\n-                case (ann_none(_)) {\n-                    a_res = triv_ann(ast::ann_tag(a_res), t);\n-                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a_res),\n-                                    t);\n-                }\n-                case (_) {}\n-            }\n+            write_type_only(fcx.ccx.node_types, a_res.id, t);\n \n             auto initopt = local.init;\n             alt (local.init) {\n@@ -2958,19 +2892,17 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) -> @ast::stmt {\n                 case (ast::decl_local(_)) {\n                     auto decl_1 = check_decl_local(fcx, decl);\n \n-                    auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                   ast::ann_tag(a));\n+                    auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n+                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n                     ret @fold::respan[ast::stmt_](stmt.span,\n                            ast::stmt_decl(decl_1, new_ann));\n                 }\n \n                 case (ast::decl_item(_)) {\n                     // Ignore for now. We'll return later.\n-                    auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                   ast::ann_tag(a));\n+                    auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n+                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n                     ret @fold::respan[ast::stmt_](stmt.span,\n                            ast::stmt_decl(decl, new_ann));\n@@ -2985,8 +2917,8 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) -> @ast::stmt {\n             expr_t = Pushdown::pushdown_expr(fcx,\n                 expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t), expr_t);\n \n-            auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n+            auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n+            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n             ret @fold::respan(stmt.span, ast::stmt_expr(expr_t, new_ann));\n         }\n@@ -3012,9 +2944,8 @@ fn check_block(&@fn_ctxt fcx, &ast::block block) -> ast::block {\n         }\n     }\n \n-    auto new_ann = plain_ann(ast::ann_tag(block.node.a), fcx.ccx.tcx);\n-    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n-                   ast::ann_tag(block.node.a));\n+    auto new_ann = plain_ann(block.node.a.id, fcx.ccx.tcx);\n+    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, block.node.a.id);\n \n     ret fold::respan(block.span, rec(stmts=stmts, expr=expr, a=new_ann));\n }\n@@ -3097,8 +3028,8 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, &ast::ident ident, &ast::_fn f,\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n     auto typ = ty::mk_fn(ccx.tcx, f.proto, inputs, output_ty);\n-    auto fn_ann = triv_ann(ast::ann_tag(ann), typ);\n-    write_type_only(ccx.node_types, ast::ann_tag(ann), typ);\n+    auto fn_ann = triv_ann(ann.id, typ);\n+    write_type_only(ccx.node_types, ann.id, typ);\n \n     auto item = ast::item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold::respan[ast::item_](sp, item);"}, {"sha": "a183ed3d1221a088c0d32eae592980d77de8bc07", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 55, "deletions": 199, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -77,8 +77,6 @@ import front::ast::init_op;\n import front::ast::initializer;\n import front::ast::local;\n import front::ast::_fn;\n-import front::ast::ann_none;\n-import front::ast::ann_type;\n import front::ast::_obj;\n import front::ast::_mod;\n import front::ast::crate;\n@@ -389,42 +387,19 @@ fn mk_f_to_fn_info(@ast::crate c) -> fn_info_map {\n }\n /**** Helpers ****/\n fn ann_to_ts_ann(ann a, uint nv) -> ts_ann {\n-  alt (a) {\n-    case (ann_none(_))      { ret empty_ann(nv); }\n-    case (ann_type(_,_,_,?t)) {\n-      alt (t) {\n+    alt (a.ts) {\n         /* Kind of inconsistent. empty_ann()s everywhere\n-         or an option of a ts_ann? */\n+           or an option of a ts_ann? */\n         case (none[@ts_ann])     { ret empty_ann(nv); }\n         case (some[@ts_ann](?t)) { ret *t; }\n-      }\n     }\n-  }\n }\n \n-fn ann_to_ts_ann_fail(ann a) -> option::t[@ts_ann] {\n-  alt (a) {\n-      case (ann_none(_)) { \n-          log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n-          fail;\n-      }\n-      case (ann_type(_,_,_,?t)) {\n-          ret t;\n-      }\n-  }\n-}\n+fn ann_to_ts_ann_fail(ann a) -> option::t[@ts_ann] { ret a.ts; }\n \n fn ann_to_ts_ann_fail_more(ann a) -> @ts_ann {\n-  alt (a) {\n-      case (ann_none(_)) { \n-          log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n-          fail;\n-      }\n-      case (ann_type(_,_,_,?t)) {\n-          assert (! is_none[@ts_ann](t));\n-          ret get[@ts_ann](t);\n-      }\n-  }\n+    assert (! is_none[@ts_ann](a.ts));\n+    ret get[@ts_ann](a.ts);\n }\n \n fn ann_to_poststate(ann a) -> poststate {\n@@ -447,44 +422,24 @@ fn stmt_to_ann(&stmt s) -> option::t[@ts_ann] {\n \n /* fails if e has no annotation */\n fn expr_states(@expr e) -> pre_and_post_state {\n-  alt (expr_ann(e)) {\n-    case (ann_none(_)) {\n-      log_err \"expr_pp: the impossible happened (no annotation)\";\n-      fail;\n-    }\n-    case (ann_type(_, _, _, ?maybe_pp)) {\n-      alt (maybe_pp) {\n+    alt (a.ts) {\n         case (none[@ts_ann]) {\n-          log_err \"expr_pp: the impossible happened (no pre/post)\";\n-          fail;\n-        }\n-        case (some[@ts_ann](?p)) {\n-          ret p.states;\n+            log_err \"expr_pp: the impossible happened (no pre/post)\";\n+            fail;\n         }\n-      }\n+        case (some[@ts_ann](?p)) { ret p.states; }\n     }\n-  }\n }\n \n /* fails if e has no annotation */\n fn expr_pp(@expr e) -> pre_and_post {\n-  alt (expr_ann(e)) {\n-    case (ann_none(_)) {\n-      log_err \"expr_pp: the impossible happened (no annotation)\";\n-      fail;\n-    }\n-    case (ann_type(_, _, _, ?maybe_pp)) {\n-      alt (maybe_pp) {\n+    alt (expr_ann(e).ts) {\n         case (none[@ts_ann]) {\n-          log_err \"expr_pp: the impossible happened (no pre/post)\";\n-          fail;\n-        }\n-        case (some[@ts_ann](?p)) {\n-          ret p.conditions;\n+            log_err \"expr_pp: the impossible happened (no pre/post)\";\n+            fail;\n         }\n-      }\n+        case (some[@ts_ann](?p)) { ret p.conditions; }\n     }\n-  }\n }\n \n fn stmt_pp(&stmt s) -> pre_and_post {\n@@ -502,42 +457,22 @@ fn stmt_pp(&stmt s) -> pre_and_post {\n /* fails if b has no annotation */\n /* FIXME: factor out code in the following two functions (block_ts_ann) */\n fn block_pp(&block b) -> pre_and_post {\n-    alt (b.node.a) {\n-       case (ann_none(_)) {\n-           log_err \"block_pp: the impossible happened (no ann)\";\n-           fail;\n-       }\n-       case (ann_type(_, _,_,?t)) {\n-           alt (t) {\n-               case (none[@ts_ann]) {\n-                   log_err \"block_pp: the impossible happened (no ty)\";\n-                   fail;\n-               }\n-               case (some[@ts_ann](?ts)) {\n-                   ret ts.conditions;\n-               }\n-           }\n-       }\n+    alt (b.node.a.ts) {\n+        case (none[@ts_ann]) {\n+            log_err \"block_pp: the impossible happened (no ty)\";\n+            fail;\n+        }\n+        case (some[@ts_ann](?ts)) { ret ts.conditions; }\n     }\n }\n \n fn block_states(&block b) -> pre_and_post_state {\n-    alt (b.node.a) {\n-       case (ann_none(_)) {\n-           log_err \"block_pp: the impossible happened (no ann)\";\n+    alt (b.node.a.ts) {\n+       case (none[@ts_ann]) {\n+           log_err \"block_states: the impossible happened (no ty)\";\n            fail;\n        }\n-       case (ann_type(_, _,_,?t)) {\n-           alt (t) {\n-               case (none[@ts_ann]) {\n-                   log_err \"block_states: the impossible happened (no ty)\";\n-                   fail;\n-               }\n-               case (some[@ts_ann](?ts)) {\n-                   ret ts.states;\n-               }\n-           }\n-       }\n+       case (some[@ts_ann](?ts)) { ret ts.states; }\n     }\n }\n \n@@ -602,18 +537,9 @@ fn block_poststate(&block b) -> poststate {\n \n /* returns a new annotation where the pre_and_post is p */\n fn with_pp(ann a, pre_and_post p) -> ann {\n-  alt (a) {\n-    case (ann_none(_)) {\n-      log(\"with_pp: the impossible happened\");\n-      fail; /* shouldn't happen b/c code is typechecked */\n-    }\n-    case (ann_type(?tg, ?t, ?ps, _)) {\n-      ret (ann_type(tg, t, ps,\n-                    some[@ts_ann]\n-                    (@rec(conditions=p,\n-                          states=empty_states(pps_len(p))))));\n-    }\n-  }\n+    ret rec(id=ann.id, ty=ann.ty, tps=ann.tps,\n+            ts=some[@ts_ann](@rec(conditions=p,\n+                                  states=empty_states(pps_len(p)))));\n }\n \n // Given a list of pres and posts for exprs e0 ... en,\n@@ -834,7 +760,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         case (expr_path(?p, ?a)) {\n             auto res = empty_pre_post(num_local_vars);\n \n-            alt (dm.get(ast::ann_tag(a))) {\n+            alt (dm.get(a.id)) {\n                 case (def_local(?d_id)) {\n                     auto i = bit_num(d_id, enclosing);\n                     require_and_preserve(i, res);\n@@ -881,7 +807,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-                    alt (dm.get(ast::ann_tag(a_lhs))) {\n+                    alt (dm.get(a_lhs.id))) {\n                         case (def_local(?d_id)) {\n                             find_pre_post_expr(dm, fm, enclosing, rhs);\n                             set_pre_and_post(a, expr_pp(rhs));\n@@ -902,7 +828,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-                    alt (dm.get(ast::ann_tag(a_lhs))) {\n+                    alt (dm.get(a_lhs.id)) {\n                         case (def_local(?d_id)) {\n                             find_pre_post_expr(dm, fm, enclosing, rhs);\n                             set_pre_and_post(a, expr_pp(rhs));\n@@ -1291,76 +1217,36 @@ fn find_pre_post_state_item(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n }\n \n fn set_prestate_ann(@ann a, prestate pre) -> bool {\n-  alt (*a) {\n-    case (ann_type(_, _,_,?ts_a)) {\n-      assert (! is_none[@ts_ann](ts_a));\n-      ret set_prestate(get[@ts_ann](ts_a), pre);\n-    }\n-    case (ann_none(_)) {\n-      log(\"set_prestate_ann: expected an ann_type here\");\n-      fail;\n-    }\n-  }\n+    assert (! is_none[@ts_ann](a.ts));\n+    ret set_prestate(get[@ts_ann](a.ts), pre);\n }\n \n \n fn extend_prestate_ann(ann a, prestate pre) -> bool {\n-  alt (a) {\n-    case (ann_type(_,_,_,?ts_a)) {\n-      assert (! is_none[@ts_ann](ts_a));\n-      ret extend_prestate((get[@ts_ann](ts_a)).states.prestate, pre);\n-    }\n-    case (ann_none(_)) {\n-      log(\"set_prestate_ann: expected an ann_type here\");\n-      fail;\n-    }\n-  }\n+    assert (! is_none[@ts_ann](a.ts));\n+    ret extend_prestate((get[@ts_ann](a.ts)).states.prestate, pre);\n }\n \n fn set_poststate_ann(ann a, poststate post) -> bool {\n-  alt (a) {\n-    case (ann_type(_, _,_,?ts_a)) {\n-      assert (! is_none[@ts_ann](ts_a));\n-      ret set_poststate(get[@ts_ann](ts_a), post);\n-    }\n-    case (ann_none(_)) {\n-      log(\"set_poststate_ann: expected an ann_type here\");\n-      fail;\n-    }\n-  }\n+    assert (! is_none[@ts_ann](a.ts));\n+    ret set_poststate(get[@ts_ann](a.ts), post);\n }\n \n fn extend_poststate_ann(ann a, poststate post) -> bool {\n-  alt (a) {\n-    case (ann_type(_, _,_,?ts_a)) {\n-      assert (! is_none[@ts_ann](ts_a));\n-      ret extend_poststate((*get[@ts_ann](ts_a)).states.poststate, post);\n-    }\n-    case (ann_none(_)) {\n-      log(\"set_poststate_ann: expected an ann_type here\");\n-      fail;\n-    }\n-  }\n+    assert (! is_none[@ts_ann](a.ts));\n+    ret extend_poststate((*get[@ts_ann](a.ts)).states.poststate, post);\n }\n \n fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n-    alt (a) {\n-        case (ann_type(_, _,_,?ts_a)) {\n-            assert (! is_none[@ts_ann](ts_a));\n-            auto t = *get[@ts_ann](ts_a);\n-            /*  log(\"set_pre_and_post, old =\");\n-            log_pp(t.conditions);\n-            log(\"new =\");\n-            log_pp(pp);\n-            */\n-            set_precondition(t, pp.precondition);\n-            set_postcondition(t, pp.postcondition);\n-        }\n-        case (ann_none(_)) {\n-            log_err(\"set_pre_and_post: expected an ann_type here\");\n-            fail;\n-        }\n-    }\n+    assert (! is_none[@ts_ann](a.ts));\n+    auto t = *get[@ts_ann](a.ts);\n+    /*  log(\"set_pre_and_post, old =\");\n+    log_pp(t.conditions);\n+    log(\"new =\");\n+    log_pp(pp);\n+    */\n+    set_precondition(t, pp.precondition);\n+    set_postcondition(t, pp.postcondition);\n }\n \n fn seq_states(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n@@ -1518,7 +1404,7 @@ fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n \n         alt (lhs.node) {\n             case (expr_path(_, ?a_lhs)) {\n-                alt (dm.get(ast::ann_tag(a_lhs))) {\n+                alt (dm.get(a_lhs.id)) {\n                     case (def_local(?d_id)) {\n                         // assignment to local var\n                         changed = pure_exp(a_lhs, pres) || changed;\n@@ -1546,7 +1432,7 @@ fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n \n         alt (lhs.node) {\n             case (expr_path(?p, ?a_lhs)) {\n-                alt (dm.get(ast::ann_tag(a_lhs))) {\n+                alt (dm.get(a_lhs.id)) {\n                     case (def_local(?d_id)) {\n                         // receive to local var\n                         changed = pure_exp(a_lhs, pres) || changed;\n@@ -2040,52 +1926,22 @@ fn check_obj_state(def_map dm, &fn_info_map f_info_map,\n }\n \n fn init_ann(&fn_info fi, &ann a) -> ann {\n-    alt (a) {\n-        case (ann_none(_)) {\n-            //            log(\"init_ann: shouldn't see ann_none\");\n-            // fail;\n-            log(\"warning: init_ann: saw ann_none\");\n-            ret a; // Would be better to fail so we can catch bugs that\n-            // result in an uninitialized ann -- but don't want to have to\n-            // write code to handle native_mods properly\n-        }\n-        case (ann_type(?tg, ?t,?ps,_)) {\n-            ret ann_type(tg, t, ps,\n-                         some[@ts_ann](@empty_ann(num_locals(fi))));\n-        }\n-    }\n+    ret rec(id=a.id, ty=a.ty, tps=a.tps,\n+            ts=some[@ts_ann](@empty_ann(num_locals(fi))));\n }\n \n fn init_blank_ann(&() ignore, &ann a) -> ann {\n-    alt (a) {\n-        case (ann_none(_)) {\n-            //            log(\"init_blank_ann: shouldn't see ann_none\");\n-            //fail;\n-            log(\"warning: init_blank_ann: saw ann_none\");\n-            ret a;\n-        }\n-        case (ann_type(?tg, ?t,?ps,_)) {\n-            ret ann_type(tg, t, ps, some[@ts_ann](@empty_ann(0u)));\n-        }\n-    }\n+    ret rec(id=a.id, ty=a.ty, tps=a.tps, ts=some[@ts_ann](@empty_ann(0u)));\n }\n \n fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n     log(\"init_block:\");\n     log_block(respan(sp, b));\n-    alt(b.a) {\n-        case (ann_none(_)) {\n-            log(\"init_block: shouldn't see ann_none\");\n-            fail;\n-        }\n-        case (ann_type(_, _, ?ps, _)) {\n-            auto fld0 = fold::new_identity_fold[fn_info]();\n \n-            fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n-            ret fold::fold_block[fn_info](fi, fld0, respan(sp, b)); \n-        }\n-    }\n-    \n+    auto fld0 = fold::new_identity_fold[fn_info]();\n+\n+    fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n+    ret fold::fold_block[fn_info](fi, fld0, respan(sp, b)); \n }\n \n fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &ast::_fn f,"}, {"sha": "497baa70c4d398780e8f1a8cdd6df2a60d4eb855", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047ab0b0cc84af577d1a0816d2496986397e967/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=5047ab0b0cc84af577d1a0816d2496986397e967", "patch": "@@ -175,17 +175,6 @@ fn log_block_err(&ast::block b) -> () {\n     log_err(block_to_str(b));\n }\n \n-fn log_ann(&ast::ann a) -> () {\n-    alt (a) {\n-        case (ast::ann_none(_)) {\n-            log(\"ann_none\");\n-        }\n-        case (ast::ann_type(_,_,_,_)) {\n-            log(\"ann_type\");\n-        }\n-    }\n-}\n-\n fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n  let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);"}]}