{"sha": "c153fc1da1c16fd7673aa70af06652f9161bf9e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNTNmYzFkYTFjMTZmZDc2NzNhYTcwYWYwNjY1MmY5MTYxYmY5ZTc=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-25T22:35:51Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-26T15:42:45Z"}, "message": "New section of the book: nightly rust\n\nNow that feature flags are only on nightly, it's good to split this stuff out.", "tree": {"sha": "a43559323f409529195d0aa53ff4f0b176e358c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a43559323f409529195d0aa53ff4f0b176e358c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c153fc1da1c16fd7673aa70af06652f9161bf9e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c153fc1da1c16fd7673aa70af06652f9161bf9e7", "html_url": "https://github.com/rust-lang/rust/commit/c153fc1da1c16fd7673aa70af06652f9161bf9e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c153fc1da1c16fd7673aa70af06652f9161bf9e7/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1501f33e76f6f9621aa08fb0cbbc5f85a5ac7f0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1501f33e76f6f9621aa08fb0cbbc5f85a5ac7f0f", "html_url": "https://github.com/rust-lang/rust/commit/1501f33e76f6f9621aa08fb0cbbc5f85a5ac7f0f"}], "stats": {"total": 1139, "additions": 542, "deletions": 597}, "files": [{"sha": "f5dd92f5a3dbe751bb4bb61bd0bde72e6e216207", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -29,7 +29,12 @@ and will be able to understand most Rust code and write more complex programs.\n \n In a similar fashion to \"Intermediate,\" this section is full of individual,\n deep-dive chapters, which stand alone and can be read in any order. These\n-chapters focus on the most complex features, as well as some things that\n-are only available in upcoming versions of Rust.\n+chapters focus on the most complex features,\n \n-After reading \"Advanced,\" you'll be a Rust expert!\n+<h2 class=\"section-header\"><a href=\"unstable.html\">Unstable</a></h2>\n+\n+In a similar fashion to \"Intermediate,\" this section is full of individual,\n+deep-dive chapters, which stand alone and can be read in any order.\n+\n+This chapter contains things that are only available on the nightly channel of\n+Rust."}, {"sha": "140086e32d080e6f819d43326782a7244c56fe83", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -36,6 +36,12 @@\n     * [FFI](ffi.md)\n     * [Unsafe Code](unsafe.md)\n     * [Advanced Macros](advanced-macros.md)\n+* [Unstable Rust](unstable.md)\n     * [Compiler Plugins](plugins.md)\n+    * [Inline Assembly](inline-assembly.md)\n+    * [No stdlib](no-stdlib.md)\n+    * [Intrinsics](intrinsics.md)\n+    * [Lang items](lang-items.md)\n+    * [Link args](link-args.md)\n * [Conclusion](conclusion.md)\n * [Glossary](glossary.md)"}, {"sha": "fef458caaaf3343a1aa2e198888d005bc2ba8221", "filename": "src/doc/trpl/advanced-macros.md", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -206,8 +206,6 @@ the [Bitwise Cyclic Tag](http://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton\n within Rust's macro system.\n \n ```rust\n-#![feature(trace_macros)]\n-\n macro_rules! bct {\n     // cmd 0:  d ... => ...\n     (0, $($ps:tt),* ; $_d:tt)\n@@ -229,13 +227,6 @@ macro_rules! bct {\n     ( $($ps:tt),* ; )\n         => (());\n }\n-\n-fn main() {\n-    trace_macros!(true);\n-# /* just check the definition\n-    bct!(0, 0, 1, 1, 1 ; 1, 0, 1);\n-# */\n-}\n ```\n \n Exercise: use macros to reduce duplication in the above definition of the"}, {"sha": "3dff72b3794defdc930f1cc32f9bfb0a234bc45f", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -366,31 +366,6 @@ A few examples of how this model can be used are:\n \n On OSX, frameworks behave with the same semantics as a dynamic library.\n \n-## The `link_args` attribute\n-\n-There is one other way to tell rustc how to customize linking, and that is via\n-the `link_args` attribute. This attribute is applied to `extern` blocks and\n-specifies raw flags which need to get passed to the linker when producing an\n-artifact. An example usage would be:\n-\n-``` no_run\n-#![feature(link_args)]\n-\n-#[link_args = \"-foo -bar -baz\"]\n-extern {}\n-# fn main() {}\n-```\n-\n-Note that this feature is currently hidden behind the `feature(link_args)` gate\n-because this is not a sanctioned way of performing linking. Right now rustc\n-shells out to the system linker, so it makes sense to provide extra command line\n-arguments, but this will not always be the case. In the future rustc may use\n-LLVM directly to link native libraries in which case `link_args` will have no\n-meaning.\n-\n-It is highly recommended to *not* use this attribute, and rather use the more\n-formal `#[link(...)]` attribute on `extern` blocks instead.\n-\n # Unsafe blocks\n \n Some operations, like dereferencing unsafe pointers or calling functions that have been marked"}, {"sha": "1a4592f980fa720c5a5cbbac5548b86d39cf741b", "filename": "src/doc/trpl/inline-assembly.md", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finline-assembly.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -0,0 +1,141 @@\n+% Inline Assembly\n+\n+For extremely low-level manipulations and performance reasons, one\n+might wish to control the CPU directly. Rust supports using inline\n+assembly to do this via the `asm!` macro. The syntax roughly matches\n+that of GCC & Clang:\n+\n+```ignore\n+asm!(assembly template\n+   : output operands\n+   : input operands\n+   : clobbers\n+   : options\n+   );\n+```\n+\n+Any use of `asm` is feature gated (requires `#![feature(asm)]` on the\n+crate to allow) and of course requires an `unsafe` block.\n+\n+> **Note**: the examples here are given in x86/x86-64 assembly, but\n+> all platforms are supported.\n+\n+## Assembly template\n+\n+The `assembly template` is the only required parameter and must be a\n+literal string (i.e. `\"\"`)\n+\n+```\n+#![feature(asm)]\n+\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn foo() {\n+    unsafe {\n+        asm!(\"NOP\");\n+    }\n+}\n+\n+// other platforms\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+fn foo() { /* ... */ }\n+\n+fn main() {\n+    // ...\n+    foo();\n+    // ...\n+}\n+```\n+\n+(The `feature(asm)` and `#[cfg]`s are omitted from now on.)\n+\n+Output operands, input operands, clobbers and options are all optional\n+but you must add the right number of `:` if you skip them:\n+\n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+asm!(\"xor %eax, %eax\"\n+    :\n+    :\n+    : \"eax\"\n+   );\n+# } }\n+```\n+\n+Whitespace also doesn't matter:\n+\n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+asm!(\"xor %eax, %eax\" ::: \"eax\");\n+# } }\n+```\n+\n+## Operands\n+\n+Input and output operands follow the same format: `:\n+\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n+expressions must be mutable lvalues:\n+\n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn add(a: i32, b: i32) -> i32 {\n+    let mut c = 0;\n+    unsafe {\n+        asm!(\"add $2, $0\"\n+             : \"=r\"(c)\n+             : \"0\"(a), \"r\"(b)\n+             );\n+    }\n+    c\n+}\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn add(a: i32, b: i32) -> i32 { a + b }\n+\n+fn main() {\n+    assert_eq!(add(3, 14159), 14162)\n+}\n+```\n+\n+## Clobbers\n+\n+Some instructions modify registers which might otherwise have held\n+different values so we use the clobbers list to indicate to the\n+compiler not to assume any values loaded into those registers will\n+stay valid.\n+\n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+// Put the value 0x200 in eax\n+asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n+# } }\n+```\n+\n+Input and output registers need not be listed since that information\n+is already communicated by the given constraints. Otherwise, any other\n+registers used either implicitly or explicitly should be listed.\n+\n+If the assembly changes the condition code register `cc` should be\n+specified as one of the clobbers. Similarly, if the assembly modifies\n+memory, `memory` should also be specified.\n+\n+## Options\n+\n+The last section, `options` is specific to Rust. The format is comma\n+separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n+specify some extra info about the inline assembly:\n+\n+Current valid options are:\n+\n+1. *volatile* - specifying this is analogous to\n+   `__asm__ __volatile__ (...)` in gcc/clang.\n+2. *alignstack* - certain instructions expect the stack to be\n+   aligned a certain way (i.e. SSE) and specifying this indicates to\n+   the compiler to insert its usual stack alignment code\n+3. *intel* - use intel syntax instead of the default AT&T.\n+"}, {"sha": "25f7c54493188d93e76d85b7d2407722f355571f", "filename": "src/doc/trpl/intrinsics.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fintrinsics.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -0,0 +1,25 @@\n+% Intrinsics\n+\n+> **Note**: intrinsics will forever have an unstable interface, it is\n+> recommended to use the stable interfaces of libcore rather than intrinsics\n+> directly.\n+\n+These are imported as if they were FFI functions, with the special\n+`rust-intrinsic` ABI. For example, if one was in a freestanding\n+context, but wished to be able to `transmute` between types, and\n+perform efficient pointer arithmetic, one would import those functions\n+via a declaration like\n+\n+```\n+# #![feature(intrinsics)]\n+# fn main() {}\n+\n+extern \"rust-intrinsic\" {\n+    fn transmute<T, U>(x: T) -> U;\n+\n+    fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+}\n+```\n+\n+As with any other FFI functions, these are always `unsafe` to call.\n+"}, {"sha": "30ab59cc0291a057d5e8561007209507f67fc9f7", "filename": "src/doc/trpl/lang-items.md", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -0,0 +1,79 @@\n+% Lang items\n+\n+> **Note**: lang items are often provided by crates in the Rust distribution,\n+> and lang items themselves have an unstable interface. It is recommended to use\n+> officially distributed crates instead of defining your own lang items.\n+\n+The `rustc` compiler has certain pluggable operations, that is,\n+functionality that isn't hard-coded into the language, but is\n+implemented in libraries, with a special marker to tell the compiler\n+it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n+various different values of `...`, i.e. various different 'lang\n+items'.\n+\n+For example, `Box` pointers require two lang items, one for allocation\n+and one for deallocation. A freestanding program that uses the `Box`\n+sugar for dynamic allocations via `malloc` and `free`:\n+\n+```\n+#![feature(lang_items, box_syntax, start, no_std)]\n+#![no_std]\n+\n+extern crate libc;\n+\n+extern {\n+    fn abort() -> !;\n+}\n+\n+#[lang = \"owned_box\"]\n+pub struct Box<T>(*mut T);\n+\n+#[lang=\"exchange_malloc\"]\n+unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n+    let p = libc::malloc(size as libc::size_t) as *mut u8;\n+\n+    // malloc failed\n+    if p as usize == 0 {\n+        abort();\n+    }\n+\n+    p\n+}\n+#[lang=\"exchange_free\"]\n+unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n+    libc::free(ptr as *mut libc::c_void)\n+}\n+\n+#[start]\n+fn main(argc: isize, argv: *const *const u8) -> isize {\n+    let x = box 1;\n+\n+    0\n+}\n+\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+```\n+\n+Note the use of `abort`: the `exchange_malloc` lang item is assumed to\n+return a valid pointer, and so needs to do the check internally.\n+\n+Other features provided by lang items include:\n+\n+- overloadable operators via traits: the traits corresponding to the\n+  `==`, `<`, dereferencing (`*`) and `+` (etc.) operators are all\n+  marked with lang items; those specific four are `eq`, `ord`,\n+  `deref`, and `add` respectively.\n+- stack unwinding and general failure; the `eh_personality`, `fail`\n+  and `fail_bounds_checks` lang items.\n+- the traits in `std::marker` used to indicate types of\n+  various kinds; lang items `send`, `sync` and `copy`.\n+- the marker types and variance indicators found in\n+  `std::marker`; lang items `covariant_type`,\n+  `contravariant_lifetime`, etc.\n+\n+Lang items are loaded lazily by the compiler; e.g. if one never uses\n+`Box` then there is no need to define functions for `exchange_malloc`\n+and `exchange_free`. `rustc` will emit an error when an item is needed\n+but not found in the current crate or any that it depends on."}, {"sha": "ee5159afb8e6f41502e00d4857ae9178a84a5ecf", "filename": "src/doc/trpl/link-args.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Flink-args.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Flink-args.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flink-args.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -0,0 +1,25 @@\n+% Link args\n+\n+There is one other way to tell rustc how to customize linking, and that is via\n+the `link_args` attribute. This attribute is applied to `extern` blocks and\n+specifies raw flags which need to get passed to the linker when producing an\n+artifact. An example usage would be:\n+\n+``` no_run\n+#![feature(link_args)]\n+\n+#[link_args = \"-foo -bar -baz\"]\n+extern {}\n+# fn main() {}\n+```\n+\n+Note that this feature is currently hidden behind the `feature(link_args)` gate\n+because this is not a sanctioned way of performing linking. Right now rustc\n+shells out to the system linker, so it makes sense to provide extra command line\n+arguments, but this will not always be the case. In the future rustc may use\n+LLVM directly to link native libraries in which case `link_args` will have no\n+meaning.\n+\n+It is highly recommended to *not* use this attribute, and rather use the more\n+formal `#[link(...)]` attribute on `extern` blocks instead.\n+"}, {"sha": "539a0729ba336011f59e9ff469951faf79bc307f", "filename": "src/doc/trpl/no-stdlib.md", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fno-stdlib.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -0,0 +1,168 @@\n+% No stdlib\n+\n+By default, `std` is linked to every Rust crate. In some contexts,\n+this is undesirable, and can be avoided with the `#![no_std]`\n+attribute attached to the crate.\n+\n+```ignore\n+// a minimal library\n+#![crate_type=\"lib\"]\n+#![feature(no_std)]\n+#![no_std]\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+Obviously there's more to life than just libraries: one can use\n+`#[no_std]` with an executable, controlling the entry point is\n+possible in two ways: the `#[start]` attribute, or overriding the\n+default shim for the C `main` function with your own.\n+\n+The function marked `#[start]` is passed the command line parameters\n+in the same format as C:\n+\n+```\n+#![feature(lang_items, start, no_std)]\n+#![no_std]\n+\n+// Pull in the system libc library for what crt0.o likely requires\n+extern crate libc;\n+\n+// Entry point for this program\n+#[start]\n+fn start(_argc: isize, _argv: *const *const u8) -> isize {\n+    0\n+}\n+\n+// These functions and traits are used by the compiler, but not\n+// for a bare-bones hello world. These are normally\n+// provided by libstd.\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+To override the compiler-inserted `main` shim, one has to disable it\n+with `#![no_main]` and then create the appropriate symbol with the\n+correct ABI and the correct name, which requires overriding the\n+compiler's name mangling too:\n+\n+```ignore\n+#![feature(no_std)]\n+#![no_std]\n+#![no_main]\n+#![feature(lang_items, start)]\n+\n+extern crate libc;\n+\n+#[no_mangle] // ensure that this symbol is called `main` in the output\n+pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n+    0\n+}\n+\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+\n+The compiler currently makes a few assumptions about symbols which are available\n+in the executable to call. Normally these functions are provided by the standard\n+library, but without it you must define your own.\n+\n+The first of these three functions, `stack_exhausted`, is invoked whenever stack\n+overflow is detected.  This function has a number of restrictions about how it\n+can be called and what it must do, but if the stack limit register is not being\n+maintained then a thread always has an \"infinite stack\" and this function\n+shouldn't get triggered.\n+\n+The second of these three functions, `eh_personality`, is used by the\n+failure mechanisms of the compiler. This is often mapped to GCC's\n+personality function (see the\n+[libstd implementation](../std/rt/unwind/index.html) for more\n+information), but crates which do not trigger a panic can be assured\n+that this function is never called. The final function, `panic_fmt`, is\n+also used by the failure mechanisms of the compiler.\n+\n+## Using libcore\n+\n+> **Note**: the core library's structure is unstable, and it is recommended to\n+> use the standard library instead wherever possible.\n+\n+With the above techniques, we've got a bare-metal executable running some Rust\n+code. There is a good deal of functionality provided by the standard library,\n+however, that is necessary to be productive in Rust. If the standard library is\n+not sufficient, then [libcore](../core/index.html) is designed to be used\n+instead.\n+\n+The core library has very few dependencies and is much more portable than the\n+standard library itself. Additionally, the core library has most of the\n+necessary functionality for writing idiomatic and effective Rust code.\n+\n+As an example, here is a program that will calculate the dot product of two\n+vectors provided from C, using idiomatic Rust practices.\n+\n+```\n+#![feature(lang_items, start, no_std)]\n+#![no_std]\n+\n+# extern crate libc;\n+extern crate core;\n+\n+use core::prelude::*;\n+\n+use core::mem;\n+\n+#[no_mangle]\n+pub extern fn dot_product(a: *const u32, a_len: u32,\n+                          b: *const u32, b_len: u32) -> u32 {\n+    use core::raw::Slice;\n+\n+    // Convert the provided arrays into Rust slices.\n+    // The core::raw module guarantees that the Slice\n+    // structure has the same memory layout as a &[T]\n+    // slice.\n+    //\n+    // This is an unsafe operation because the compiler\n+    // cannot tell the pointers are valid.\n+    let (a_slice, b_slice): (&[u32], &[u32]) = unsafe {\n+        mem::transmute((\n+            Slice { data: a, len: a_len as usize },\n+            Slice { data: b, len: b_len as usize },\n+        ))\n+    };\n+\n+    // Iterate over the slices, collecting the result\n+    let mut ret = 0;\n+    for (i, j) in a_slice.iter().zip(b_slice.iter()) {\n+        ret += (*i) * (*j);\n+    }\n+    return ret;\n+}\n+\n+#[lang = \"panic_fmt\"]\n+extern fn panic_fmt(args: &core::fmt::Arguments,\n+                    file: &str,\n+                    line: u32) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+# #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n+# fn main() {}\n+```\n+\n+Note that there is one extra lang item here which differs from the examples\n+above, `panic_fmt`. This must be defined by consumers of libcore because the\n+core library declares panics, but it does not define it. The `panic_fmt`\n+lang item is this crate's definition of panic, and it must be guaranteed to\n+never return.\n+\n+As can be seen in this example, the core library is intended to provide the\n+power of Rust in all circumstances, regardless of platform requirements. Further\n+libraries, such as liballoc, add functionality to libcore which make other\n+platform-specific assumptions, but continue to be more portable than the\n+standard library itself.\n+"}, {"sha": "9eb22a7f6985a51bb6e026aaf73896f1a630135a", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -1,29 +1,5 @@\n % Compiler Plugins\n \n-<div class=\"unstable-feature\">\n-\n-<p>\n-<b>Warning:</b> Plugins are an advanced, unstable feature! For many details,\n-the only available documentation is the <a\n-href=\"../syntax/index.html\"><code>libsyntax</code></a> and <a\n-href=\"../rustc/index.html\"><code>librustc</code></a> API docs, or even the source\n-code itself. These internal compiler APIs are also subject to change at any\n-time.\n-</p>\n-\n-<p>\n-For defining new syntax it is often much easier to use Rust's <a\n-href=\"macros.html\">built-in macro system</a>.\n-</p>\n-\n-<p style=\"margin-bottom: 0\">\n-The code in this document uses language features not covered in the Rust\n-Guide.  See the <a href=\"../reference.html\">Reference Manual</a> for more\n-information.\n-</p>\n-\n-</div>\n-\n # Introduction\n \n `rustc` can load compiler plugins, which are user-provided libraries that"}, {"sha": "bc337f30515a86579c5ae15bea80f931e4100f43", "filename": "src/doc/trpl/tracing-macros.md", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Ftracing-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Ftracing-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftracing-macros.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -0,0 +1,90 @@\n+% Tracing Macros\n+\n+The `trace_macros` feature allows you to use a special feature: tracing macro\n+invocations.\n+\n+In the advanced macros chapter, we defined a `bct` macro:\n+\n+```rust\n+macro_rules! bct {\n+    // cmd 0:  d ... => ...\n+    (0, $($ps:tt),* ; $_d:tt)\n+        => (bct!($($ps),*, 0 ; ));\n+    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n+        => (bct!($($ps),*, 0 ; $($ds),*));\n+\n+    // cmd 1p:  1 ... => 1 ... p\n+    (1, $p:tt, $($ps:tt),* ; 1)\n+        => (bct!($($ps),*, 1, $p ; 1, $p));\n+    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n+\n+    // cmd 1p:  0 ... => 0 ...\n+    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; $($ds),*));\n+\n+    // halt on empty data string\n+    ( $($ps:tt),* ; )\n+        => (());\n+}\n+```\n+\n+This is pretty complex! we can see the output\n+\n+ ```rust\n+#![feature(trace_macros)]\n+\n+macro_rules! bct {\n+    // cmd 0:  d ... => ...\n+    (0, $($ps:tt),* ; $_d:tt)\n+        => (bct!($($ps),*, 0 ; ));\n+    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n+        => (bct!($($ps),*, 0 ; $($ds),*));\n+\n+    // cmd 1p:  1 ... => 1 ... p\n+    (1, $p:tt, $($ps:tt),* ; 1)\n+        => (bct!($($ps),*, 1, $p ; 1, $p));\n+    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n+\n+    // cmd 1p:  0 ... => 0 ...\n+    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; $($ds),*));\n+\n+    // halt on empty data string\n+    ( $($ps:tt),* ; )\n+        => (());\n+}\n+\n+fn main() {\n+    trace_macros!(true);\n+\n+    bct!(0, 0, 1, 1, 1 ; 1, 0, 1);\n+}\n+\n+This will print out a wall of text:\n+\n+```text\n+bct! { 0 , 0 , 1 , 1 , 1 ; 1 , 0 , 1 }\n+bct! { 0 , 1 , 1 , 1 , 0 ; 0 , 1 }\n+bct! { 1 , 1 , 1 , 0 , 0 ; 1 }\n+bct! { 1 , 0 , 0 , 1 , 1 ; 1 , 1 }\n+bct! { 0 , 1 , 1 , 1 , 0 ; 1 , 1 , 0 }\n+bct! { 1 , 1 , 1 , 0 , 0 ; 1 , 0 }\n+bct! { 1 , 0 , 0 , 1 , 1 ; 1 , 0 , 1 }\n+bct! { 0 , 1 , 1 , 1 , 0 ; 1 , 0 , 1 , 0 }\n+bct! { 1 , 1 , 1 , 0 , 0 ; 0 , 1 , 0 }\n+bct! { 1 , 0 , 0 , 1 , 1 ; 0 , 1 , 0 }\n+bct! { 0 , 1 , 1 , 1 , 0 ; 0 , 1 , 0 }\n+```\n+\n+And eventually, error:\n+\n+```text\n+18:45 error: recursion limit reached while expanding the macro `bct`\n+    => (bct!($($ps),*, 1, $p ; $($ds),*));\n+        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+```\n+\n+The `trace_macros!` call is what produces this output, showing how we match\n+each time."}, {"sha": "3ca3cfd05886ee8add73eaa419c16f7c3c4c34b5", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 0, "deletions": 536, "changes": 536, "blob_url": "https://github.com/rust-lang/rust/blob/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/c153fc1da1c16fd7673aa70af06652f9161bf9e7/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=c153fc1da1c16fd7673aa70af06652f9161bf9e7", "patch": "@@ -181,539 +181,3 @@ code:\n   that clean-up is always run, even when the thread panics.\n - ensure that any data stored behind a raw pointer is destroyed at the\n   appropriate time.\n-\n-As an example, we give a reimplementation of owned boxes by wrapping\n-`malloc` and `free`. Rust's move semantics and lifetimes mean this\n-reimplementation is as safe as the `Box` type.\n-\n-```\n-# #![feature(libc)]\n-#![feature(unsafe_destructor)]\n-\n-extern crate libc;\n-use libc::{c_void, size_t, malloc, free};\n-use std::mem;\n-use std::ptr;\n-\n-// Define a wrapper around the handle returned by the foreign code.\n-// Unique<T> has the same semantics as Box<T>\n-//\n-// NB: For simplicity and correctness, we require that T has kind Send\n-// (owned boxes relax this restriction).\n-pub struct Unique<T: Send> {\n-    // It contains a single raw, mutable pointer to the object in question.\n-    ptr: *mut T\n-}\n-\n-// Implement methods for creating and using the values in the box.\n-\n-impl<T: Send> Unique<T> {\n-    pub fn new(value: T) -> Unique<T> {\n-        unsafe {\n-            let ptr = malloc(mem::size_of::<T>() as size_t) as *mut T;\n-            // we *need* valid pointer.\n-            assert!(!ptr.is_null());\n-            // `*ptr` is uninitialized, and `*ptr = value` would\n-            // attempt to destroy it `overwrite` moves a value into\n-            // this memory without attempting to drop the original\n-            // value.\n-            ptr::write(&mut *ptr, value);\n-            Unique{ptr: ptr}\n-        }\n-    }\n-\n-    // the 'r lifetime results in the same semantics as `&*x` with\n-    // Box<T>\n-    pub fn borrow<'r>(&'r self) -> &'r T {\n-        // By construction, self.ptr is valid\n-        unsafe { &*self.ptr }\n-    }\n-\n-    // the 'r lifetime results in the same semantics as `&mut *x` with\n-    // Box<T>\n-    pub fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\n-        unsafe { &mut *self.ptr }\n-    }\n-}\n-\n-// A key ingredient for safety, we associate a destructor with\n-// Unique<T>, making the struct manage the raw pointer: when the\n-// struct goes out of scope, it will automatically free the raw pointer.\n-//\n-// NB: This is an unsafe destructor; rustc will not normally allow\n-// destructors to be associated with parameterized types (due to\n-// historically failing to check them soundly).  Note that the\n-// `#[unsafe_destructor]` feature gate is currently required to use\n-// unsafe destructors.\n-#[unsafe_destructor]\n-impl<T: Send> Drop for Unique<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            // Copy the object out from the pointer onto the stack,\n-            // where it is covered by normal Rust destructor semantics\n-            // and cleans itself up, if necessary\n-            ptr::read(self.ptr);\n-\n-            // clean-up our allocation\n-            free(self.ptr as *mut c_void)\n-        }\n-    }\n-}\n-\n-// A comparison between the built-in `Box` and this reimplementation\n-fn main() {\n-    {\n-        let mut x = Box::new(5);\n-        *x = 10;\n-    } // `x` is freed here\n-\n-    {\n-        let mut y = Unique::new(5);\n-        *y.borrow_mut() = 10;\n-    } // `y` is freed here\n-}\n-```\n-\n-Notably, the only way to construct a `Unique` is via the `new`\n-function, and this function ensures that the internal pointer is valid\n-and hidden in the private field. The two `borrow` methods are safe\n-because the compiler statically guarantees that objects are never used\n-before creation or after destruction (unless you use some `unsafe`\n-code...).\n-\n-# Inline assembly\n-\n-For extremely low-level manipulations and performance reasons, one\n-might wish to control the CPU directly. Rust supports using inline\n-assembly to do this via the `asm!` macro. The syntax roughly matches\n-that of GCC & Clang:\n-\n-```ignore\n-asm!(assembly template\n-   : output operands\n-   : input operands\n-   : clobbers\n-   : options\n-   );\n-```\n-\n-Any use of `asm` is feature gated (requires `#![feature(asm)]` on the\n-crate to allow) and of course requires an `unsafe` block.\n-\n-> **Note**: the examples here are given in x86/x86-64 assembly, but\n-> all platforms are supported.\n-\n-## Assembly template\n-\n-The `assembly template` is the only required parameter and must be a\n-literal string (i.e. `\"\"`)\n-\n-```\n-#![feature(asm)]\n-\n-#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn foo() {\n-    unsafe {\n-        asm!(\"NOP\");\n-    }\n-}\n-\n-// other platforms\n-#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-fn foo() { /* ... */ }\n-\n-fn main() {\n-    // ...\n-    foo();\n-    // ...\n-}\n-```\n-\n-(The `feature(asm)` and `#[cfg]`s are omitted from now on.)\n-\n-Output operands, input operands, clobbers and options are all optional\n-but you must add the right number of `:` if you skip them:\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\"\n-    :\n-    :\n-    : \"eax\"\n-   );\n-# } }\n-```\n-\n-Whitespace also doesn't matter:\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\" ::: \"eax\");\n-# } }\n-```\n-\n-## Operands\n-\n-Input and output operands follow the same format: `:\n-\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n-expressions must be mutable lvalues:\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn add(a: i32, b: i32) -> i32 {\n-    let mut c = 0;\n-    unsafe {\n-        asm!(\"add $2, $0\"\n-             : \"=r\"(c)\n-             : \"0\"(a), \"r\"(b)\n-             );\n-    }\n-    c\n-}\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn add(a: i32, b: i32) -> i32 { a + b }\n-\n-fn main() {\n-    assert_eq!(add(3, 14159), 14162)\n-}\n-```\n-\n-## Clobbers\n-\n-Some instructions modify registers which might otherwise have held\n-different values so we use the clobbers list to indicate to the\n-compiler not to assume any values loaded into those registers will\n-stay valid.\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-// Put the value 0x200 in eax\n-asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n-# } }\n-```\n-\n-Input and output registers need not be listed since that information\n-is already communicated by the given constraints. Otherwise, any other\n-registers used either implicitly or explicitly should be listed.\n-\n-If the assembly changes the condition code register `cc` should be\n-specified as one of the clobbers. Similarly, if the assembly modifies\n-memory, `memory` should also be specified.\n-\n-## Options\n-\n-The last section, `options` is specific to Rust. The format is comma\n-separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n-specify some extra info about the inline assembly:\n-\n-Current valid options are:\n-\n-1. *volatile* - specifying this is analogous to\n-   `__asm__ __volatile__ (...)` in gcc/clang.\n-2. *alignstack* - certain instructions expect the stack to be\n-   aligned a certain way (i.e. SSE) and specifying this indicates to\n-   the compiler to insert its usual stack alignment code\n-3. *intel* - use intel syntax instead of the default AT&T.\n-\n-# Avoiding the standard library\n-\n-By default, `std` is linked to every Rust crate. In some contexts,\n-this is undesirable, and can be avoided with the `#![no_std]`\n-attribute attached to the crate.\n-\n-```ignore\n-// a minimal library\n-#![crate_type=\"lib\"]\n-#![feature(no_std)]\n-#![no_std]\n-# // fn main() {} tricked you, rustdoc!\n-```\n-\n-Obviously there's more to life than just libraries: one can use\n-`#[no_std]` with an executable, controlling the entry point is\n-possible in two ways: the `#[start]` attribute, or overriding the\n-default shim for the C `main` function with your own.\n-\n-The function marked `#[start]` is passed the command line parameters\n-in the same format as C:\n-\n-```\n-# #![feature(libc)]\n-#![feature(lang_items, start, no_std)]\n-#![no_std]\n-\n-// Pull in the system libc library for what crt0.o likely requires\n-extern crate libc;\n-\n-// Entry point for this program\n-#[start]\n-fn start(_argc: isize, _argv: *const *const u8) -> isize {\n-    0\n-}\n-\n-// These functions and traits are used by the compiler, but not\n-// for a bare-bones hello world. These are normally\n-// provided by libstd.\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-# // fn main() {} tricked you, rustdoc!\n-```\n-\n-To override the compiler-inserted `main` shim, one has to disable it\n-with `#![no_main]` and then create the appropriate symbol with the\n-correct ABI and the correct name, which requires overriding the\n-compiler's name mangling too:\n-\n-```ignore\n-# #![feature(libc)]\n-#![feature(no_std)]\n-#![no_std]\n-#![no_main]\n-#![feature(lang_items, start)]\n-\n-extern crate libc;\n-\n-#[no_mangle] // ensure that this symbol is called `main` in the output\n-pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n-    0\n-}\n-\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-# // fn main() {} tricked you, rustdoc!\n-```\n-\n-\n-The compiler currently makes a few assumptions about symbols which are available\n-in the executable to call. Normally these functions are provided by the standard\n-library, but without it you must define your own.\n-\n-The first of these three functions, `stack_exhausted`, is invoked whenever stack\n-overflow is detected.  This function has a number of restrictions about how it\n-can be called and what it must do, but if the stack limit register is not being\n-maintained then a thread always has an \"infinite stack\" and this function\n-shouldn't get triggered.\n-\n-The second of these three functions, `eh_personality`, is used by the\n-failure mechanisms of the compiler. This is often mapped to GCC's\n-personality function (see the\n-[libstd implementation](../std/rt/unwind/index.html) for more\n-information), but crates which do not trigger a panic can be assured\n-that this function is never called. The final function, `panic_fmt`, is\n-also used by the failure mechanisms of the compiler.\n-\n-## Using libcore\n-\n-> **Note**: the core library's structure is unstable, and it is recommended to\n-> use the standard library instead wherever possible.\n-\n-With the above techniques, we've got a bare-metal executable running some Rust\n-code. There is a good deal of functionality provided by the standard library,\n-however, that is necessary to be productive in Rust. If the standard library is\n-not sufficient, then [libcore](../core/index.html) is designed to be used\n-instead.\n-\n-The core library has very few dependencies and is much more portable than the\n-standard library itself. Additionally, the core library has most of the\n-necessary functionality for writing idiomatic and effective Rust code.\n-\n-As an example, here is a program that will calculate the dot product of two\n-vectors provided from C, using idiomatic Rust practices.\n-\n-```\n-# #![feature(libc, core)]\n-#![feature(lang_items, start, no_std)]\n-#![no_std]\n-\n-# extern crate libc;\n-extern crate core;\n-\n-use core::prelude::*;\n-\n-use core::mem;\n-\n-#[no_mangle]\n-pub extern fn dot_product(a: *const u32, a_len: u32,\n-                          b: *const u32, b_len: u32) -> u32 {\n-    use core::raw::Slice;\n-\n-    // Convert the provided arrays into Rust slices.\n-    // The core::raw module guarantees that the Slice\n-    // structure has the same memory layout as a &[T]\n-    // slice.\n-    //\n-    // This is an unsafe operation because the compiler\n-    // cannot tell the pointers are valid.\n-    let (a_slice, b_slice): (&[u32], &[u32]) = unsafe {\n-        mem::transmute((\n-            Slice { data: a, len: a_len as usize },\n-            Slice { data: b, len: b_len as usize },\n-        ))\n-    };\n-\n-    // Iterate over the slices, collecting the result\n-    let mut ret = 0;\n-    for (i, j) in a_slice.iter().zip(b_slice.iter()) {\n-        ret += (*i) * (*j);\n-    }\n-    return ret;\n-}\n-\n-#[lang = \"panic_fmt\"]\n-extern fn panic_fmt(args: &core::fmt::Arguments,\n-                    file: &str,\n-                    line: u32) -> ! {\n-    loop {}\n-}\n-\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-# #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n-# fn main() {}\n-```\n-\n-Note that there is one extra lang item here which differs from the examples\n-above, `panic_fmt`. This must be defined by consumers of libcore because the\n-core library declares panics, but it does not define it. The `panic_fmt`\n-lang item is this crate's definition of panic, and it must be guaranteed to\n-never return.\n-\n-As can be seen in this example, the core library is intended to provide the\n-power of Rust in all circumstances, regardless of platform requirements. Further\n-libraries, such as liballoc, add functionality to libcore which make other\n-platform-specific assumptions, but continue to be more portable than the\n-standard library itself.\n-\n-# Interacting with the compiler internals\n-\n-> **Note**: this section is specific to the `rustc` compiler; these\n-> parts of the language may never be fully specified and so details may\n-> differ wildly between implementations (and even versions of `rustc`\n-> itself).\n->\n-> Furthermore, this is just an overview; the best form of\n-> documentation for specific instances of these features are their\n-> definitions and uses in `std`.\n-\n-The Rust language currently has two orthogonal mechanisms for allowing\n-libraries to interact directly with the compiler and vice versa:\n-\n-- intrinsics, functions built directly into the compiler providing\n-  very basic low-level functionality,\n-- lang-items, special functions, types and traits in libraries marked\n-  with specific `#[lang]` attributes\n-\n-## Intrinsics\n-\n-> **Note**: intrinsics will forever have an unstable interface, it is\n-> recommended to use the stable interfaces of libcore rather than intrinsics\n-> directly.\n-\n-These are imported as if they were FFI functions, with the special\n-`rust-intrinsic` ABI. For example, if one was in a freestanding\n-context, but wished to be able to `transmute` between types, and\n-perform efficient pointer arithmetic, one would import those functions\n-via a declaration like\n-\n-```\n-# #![feature(intrinsics)]\n-# fn main() {}\n-\n-extern \"rust-intrinsic\" {\n-    fn transmute<T, U>(x: T) -> U;\n-\n-    fn offset<T>(dst: *const T, offset: isize) -> *const T;\n-}\n-```\n-\n-As with any other FFI functions, these are always `unsafe` to call.\n-\n-## Lang items\n-\n-> **Note**: lang items are often provided by crates in the Rust distribution,\n-> and lang items themselves have an unstable interface. It is recommended to use\n-> officially distributed crates instead of defining your own lang items.\n-\n-The `rustc` compiler has certain pluggable operations, that is,\n-functionality that isn't hard-coded into the language, but is\n-implemented in libraries, with a special marker to tell the compiler\n-it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n-various different values of `...`, i.e. various different 'lang\n-items'.\n-\n-For example, `Box` pointers require two lang items, one for allocation\n-and one for deallocation. A freestanding program that uses the `Box`\n-sugar for dynamic allocations via `malloc` and `free`:\n-\n-```\n-# #![feature(libc)]\n-#![feature(lang_items, box_syntax, start, no_std)]\n-#![no_std]\n-\n-extern crate libc;\n-\n-extern {\n-    fn abort() -> !;\n-}\n-\n-#[lang = \"owned_box\"]\n-pub struct Box<T>(*mut T);\n-\n-#[lang=\"exchange_malloc\"]\n-unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n-    let p = libc::malloc(size as libc::size_t) as *mut u8;\n-\n-    // malloc failed\n-    if p as usize == 0 {\n-        abort();\n-    }\n-\n-    p\n-}\n-#[lang=\"exchange_free\"]\n-unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n-    libc::free(ptr as *mut libc::c_void)\n-}\n-\n-#[start]\n-fn main(argc: isize, argv: *const *const u8) -> isize {\n-    let x = box 1;\n-\n-    0\n-}\n-\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-```\n-\n-Note the use of `abort`: the `exchange_malloc` lang item is assumed to\n-return a valid pointer, and so needs to do the check internally.\n-\n-Other features provided by lang items include:\n-\n-- overloadable operators via traits: the traits corresponding to the\n-  `==`, `<`, dereferencing (`*`) and `+` (etc.) operators are all\n-  marked with lang items; those specific four are `eq`, `ord`,\n-  `deref`, and `add` respectively.\n-- stack unwinding and general failure; the `eh_personality`, `fail`\n-  and `fail_bounds_checks` lang items.\n-- the traits in `std::marker` used to indicate types of\n-  various kinds; lang items `send`, `sync` and `copy`.\n-- the marker types and variance indicators found in\n-  `std::marker`; lang items `covariant_type`,\n-  `contravariant_lifetime`, etc.\n-\n-Lang items are loaded lazily by the compiler; e.g. if one never uses\n-`Box` then there is no need to define functions for `exchange_malloc`\n-and `exchange_free`. `rustc` will emit an error when an item is needed\n-but not found in the current crate or any that it depends on."}]}