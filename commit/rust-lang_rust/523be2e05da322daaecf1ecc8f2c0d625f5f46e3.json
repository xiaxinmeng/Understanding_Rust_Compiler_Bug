{"sha": "523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "node_id": "C_kwDOAAsO6NoAKDUyM2JlMmUwNWRhMzIyZGFhZWNmMWVjYzhmMmMwZDYyNWY1ZjQ2ZTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-21T03:04:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-21T03:04:43Z"}, "message": "Auto merge of #93138 - matthiaskrgr:rollup-m8akifd, r=matthiaskrgr\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #91032 (Introduce drop range tracking to generator interior analysis)\n - #92856 (Exclude \"test\" from doc_auto_cfg)\n - #92860 (Fix errors on blanket impls by ignoring the children of generated impls)\n - #93038 (Fix star handling in block doc comments)\n - #93061 (Only suggest adding `!` to expressions that can be macro invocation)\n - #93067 (rustdoc mobile: fix scroll offset when jumping to internal id)\n - #93086 (Add tests to ensure that `let_chains` works with `if_let_guard`)\n - #93087 (Fix src/test/run-make/raw-dylib-alt-calling-convention)\n - #93091 (\u2b06 chalk to 0.76.0)\n - #93094 (src/test/rustdoc-json: Check for `struct_field`s in `variant_tuple_struct.rs`)\n - #93098 (Show a more informative panic message when `DefPathHash` does not exist)\n - #93099 (rustdoc: auto create output directory when \"--output-format json\")\n - #93102 (Pretty printer algorithm revamp step 3)\n - #93104 (Support --bless for pp-exact pretty printer tests)\n - #93114 (update comment for `ensure_monomorphic_enough`)\n - #93128 (Add script to prevent point releases with same number as existing ones)\n - #93136 (Backport the 1.58.1 release notes to master)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "95681d8d7471bb843edca4f3e988d4ec176e1b6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95681d8d7471bb843edca4f3e988d4ec176e1b6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "html_url": "https://github.com/rust-lang/rust/commit/523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "url": "https://api.github.com/repos/rust-lang/rust/commits/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "html_url": "https://github.com/rust-lang/rust/commit/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b"}, {"sha": "dd164313d52fbe174c05a37b2f90f184d09a2422", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd164313d52fbe174c05a37b2f90f184d09a2422", "html_url": "https://github.com/rust-lang/rust/commit/dd164313d52fbe174c05a37b2f90f184d09a2422"}], "stats": {"total": 2218, "additions": 1902, "deletions": 316}, "files": [{"sha": "1f872569ab144efe104b5fe5c86df8948c096b4c", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -128,6 +128,9 @@ jobs:\n       - name: ensure backported commits are in upstream branches\n         run: src/ci/scripts/verify-backported-commits.sh\n         if: success() && !env.SKIP_JOB\n+      - name: ensure the stable version number is correct\n+        run: src/ci/scripts/verify-stable-version-number.sh\n+        if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n         env:\n@@ -502,6 +505,9 @@ jobs:\n       - name: ensure backported commits are in upstream branches\n         run: src/ci/scripts/verify-backported-commits.sh\n         if: success() && !env.SKIP_JOB\n+      - name: ensure the stable version number is correct\n+        run: src/ci/scripts/verify-stable-version-number.sh\n+        if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n         env:\n@@ -612,6 +618,9 @@ jobs:\n       - name: ensure backported commits are in upstream branches\n         run: src/ci/scripts/verify-backported-commits.sh\n         if: success() && !env.SKIP_JOB\n+      - name: ensure the stable version number is correct\n+        run: src/ci/scripts/verify-stable-version-number.sh\n+        if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n         env:"}, {"sha": "e0d2abc08fc469f3ec4106acb63b62ca36ed4ad0", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -544,9 +544,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.75.0\"\n+version = \"0.76.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d54e3b5f9e3425e6b119ff07568d8d006bfa5a8d6f78a9cbc3530b1e962e316c\"\n+checksum = \"58c24b8052ea1e3adbb6f9ab7ba5fcc18b9d12591c042de4c833f709ce81e0e0\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -556,9 +556,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.75.0\"\n+version = \"0.76.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bdc891073396b167163db77123b0a3c00088edc00466cecc5531f33e3e989523\"\n+checksum = \"0eca186b6ea9af798312f4b568fd094c82e7946ac08be5dc5fea22decc6d2ed8\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -569,9 +569,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.75.0\"\n+version = \"0.76.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2b79e5a1d04b79311e90c69356a2c62027853906a7e33b3e070b93c055fc3e8a\"\n+checksum = \"f3cad5c3f1edd4b4a2c9bda24ae558ceb4f88336f88f944c2e35d0bfeb13c818\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -580,13 +580,14 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.75.0\"\n+version = \"0.76.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a5d2a1db6605aba70a58820bd80ac422b218913a510f1a40beef9efc5371ea1d\"\n+checksum = \"94533188d3452bc72cbd5618d166f45fc7646b674ad3fe9667d557bc25236dee\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n  \"ena\",\n+ \"indexmap\",\n  \"itertools 0.10.1\",\n  \"petgraph\",\n  \"rustc-hash\",\n@@ -4413,13 +4414,15 @@ dependencies = [\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_graphviz\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_lint\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\","}, {"sha": "f44291c1fa30296e0abfaaf7447f74fa34a21805", "filename": "RELEASES.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1,3 +1,18 @@\n+Version 1.58.1 (2022-01-19)\n+===========================\n+\n+* Fix race condition in `std::fs::remove_dir_all` ([CVE-2022-21658])\n+* [Handle captured arguments in the `useless_format` Clippy lint][clippy/8295]\n+* [Move `non_send_fields_in_send_ty` Clippy lint to nursery][clippy/8075]\n+* [Fix wrong error message displayed when some imports are missing][91254]\n+* [Fix rustfmt not formatting generated files from stdin][92912]\n+\n+[CVE-2022-21658]: https://www.cve.org/CVERecord?id=CVE-2022-21658]\n+[91254]: https://github.com/rust-lang/rust/pull/91254\n+[92912]: https://github.com/rust-lang/rust/pull/92912\n+[clippy/8075]: https://github.com/rust-lang/rust-clippy/pull/8075\n+[clippy/8295]: https://github.com/rust-lang/rust-clippy/pull/8295\n+\n Version 1.58.0 (2022-01-13)\n ==========================\n "}, {"sha": "82c40868d18f5c47f14b7364dccb0cda6f850fb8", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 77, "deletions": 128, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -137,7 +137,7 @@ mod ring;\n use ring::RingBuffer;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n-use std::fmt;\n+use std::iter;\n \n /// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]\n@@ -175,27 +175,10 @@ impl Token {\n     }\n }\n \n-impl fmt::Display for Token {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Token::String(ref s) => write!(f, \"STR({},{})\", s, s.len()),\n-            Token::Break(_) => f.write_str(\"BREAK\"),\n-            Token::Begin(_) => f.write_str(\"BEGIN\"),\n-            Token::End => f.write_str(\"END\"),\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone)]\n-enum PrintStackBreak {\n+enum PrintFrame {\n     Fits,\n-    Broken(Breaks),\n-}\n-\n-#[derive(Copy, Clone)]\n-struct PrintStackElem {\n-    offset: isize,\n-    pbreak: PrintStackBreak,\n+    Broken { offset: isize, breaks: Breaks },\n }\n \n const SIZE_INFINITY: isize = 0xffff;\n@@ -220,7 +203,7 @@ pub struct Printer {\n     /// advancing.\n     scan_stack: VecDeque<usize>,\n     /// Stack of blocks-in-progress being flushed by print\n-    print_stack: Vec<PrintStackElem>,\n+    print_stack: Vec<PrintFrame>,\n     /// Buffered indentation to avoid writing trailing whitespace\n     pending_indentation: isize,\n     /// The token most recently popped from the left boundary of the\n@@ -260,8 +243,8 @@ impl Printer {\n     }\n \n     /// Be very careful with this!\n-    pub fn replace_last_token_still_buffered(&mut self, t: Token) {\n-        self.buf.last_mut().unwrap().token = t;\n+    pub fn replace_last_token_still_buffered(&mut self, token: Token) {\n+        self.buf.last_mut().unwrap().token = token;\n     }\n \n     fn scan_eof(&mut self) {\n@@ -271,53 +254,53 @@ impl Printer {\n         }\n     }\n \n-    fn scan_begin(&mut self, b: BeginToken) {\n+    fn scan_begin(&mut self, token: BeginToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n             self.buf.clear();\n         }\n-        let right = self.buf.push(BufEntry { token: Token::Begin(b), size: -self.right_total });\n-        self.scan_stack.push_front(right);\n+        let right = self.buf.push(BufEntry { token: Token::Begin(token), size: -self.right_total });\n+        self.scan_stack.push_back(right);\n     }\n \n     fn scan_end(&mut self) {\n         if self.scan_stack.is_empty() {\n             self.print_end();\n         } else {\n             let right = self.buf.push(BufEntry { token: Token::End, size: -1 });\n-            self.scan_stack.push_front(right);\n+            self.scan_stack.push_back(right);\n         }\n     }\n \n-    fn scan_break(&mut self, b: BreakToken) {\n+    fn scan_break(&mut self, token: BreakToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n             self.buf.clear();\n         } else {\n             self.check_stack(0);\n         }\n-        let right = self.buf.push(BufEntry { token: Token::Break(b), size: -self.right_total });\n-        self.scan_stack.push_front(right);\n-        self.right_total += b.blank_space;\n+        let right = self.buf.push(BufEntry { token: Token::Break(token), size: -self.right_total });\n+        self.scan_stack.push_back(right);\n+        self.right_total += token.blank_space;\n     }\n \n-    fn scan_string(&mut self, s: Cow<'static, str>) {\n+    fn scan_string(&mut self, string: Cow<'static, str>) {\n         if self.scan_stack.is_empty() {\n-            self.print_string(&s);\n+            self.print_string(&string);\n         } else {\n-            let len = s.len() as isize;\n-            self.buf.push(BufEntry { token: Token::String(s), size: len });\n+            let len = string.len() as isize;\n+            self.buf.push(BufEntry { token: Token::String(string), size: len });\n             self.right_total += len;\n             self.check_stream();\n         }\n     }\n \n     fn check_stream(&mut self) {\n         while self.right_total - self.left_total > self.space {\n-            if *self.scan_stack.back().unwrap() == self.buf.index_of_first() {\n-                self.scan_stack.pop_back().unwrap();\n+            if *self.scan_stack.front().unwrap() == self.buf.index_of_first() {\n+                self.scan_stack.pop_front().unwrap();\n                 self.buf.first_mut().unwrap().size = SIZE_INFINITY;\n             }\n             self.advance_left();\n@@ -328,152 +311,118 @@ impl Printer {\n     }\n \n     fn advance_left(&mut self) {\n-        let mut left_size = self.buf.first().unwrap().size;\n-\n-        while left_size >= 0 {\n-            let left = self.buf.first().unwrap().token.clone();\n+        while self.buf.first().unwrap().size >= 0 {\n+            let left = self.buf.pop_first().unwrap();\n \n-            let len = match left {\n-                Token::Break(b) => b.blank_space,\n-                Token::String(ref s) => {\n-                    let len = s.len() as isize;\n-                    assert_eq!(len, left_size);\n-                    len\n+            match &left.token {\n+                Token::String(string) => {\n+                    self.left_total += string.len() as isize;\n+                    self.print_string(string);\n                 }\n-                _ => 0,\n-            };\n-\n-            self.print(left, left_size);\n+                Token::Break(token) => {\n+                    self.left_total += token.blank_space;\n+                    self.print_break(*token, left.size);\n+                }\n+                Token::Begin(token) => self.print_begin(*token, left.size),\n+                Token::End => self.print_end(),\n+            }\n \n-            self.left_total += len;\n+            self.last_printed = Some(left.token);\n \n-            self.buf.advance_left();\n             if self.buf.is_empty() {\n                 break;\n             }\n-\n-            left_size = self.buf.first().unwrap().size;\n         }\n     }\n \n-    fn check_stack(&mut self, mut k: usize) {\n-        while let Some(&x) = self.scan_stack.front() {\n-            let mut entry = &mut self.buf[x];\n+    fn check_stack(&mut self, mut depth: usize) {\n+        while let Some(&index) = self.scan_stack.back() {\n+            let mut entry = &mut self.buf[index];\n             match entry.token {\n                 Token::Begin(_) => {\n-                    if k == 0 {\n+                    if depth == 0 {\n                         break;\n                     }\n-                    self.scan_stack.pop_front().unwrap();\n+                    self.scan_stack.pop_back().unwrap();\n                     entry.size += self.right_total;\n-                    k -= 1;\n+                    depth -= 1;\n                 }\n                 Token::End => {\n                     // paper says + not =, but that makes no sense.\n-                    self.scan_stack.pop_front().unwrap();\n+                    self.scan_stack.pop_back().unwrap();\n                     entry.size = 1;\n-                    k += 1;\n+                    depth += 1;\n                 }\n                 _ => {\n-                    self.scan_stack.pop_front().unwrap();\n+                    self.scan_stack.pop_back().unwrap();\n                     entry.size += self.right_total;\n-                    if k == 0 {\n+                    if depth == 0 {\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn print_newline(&mut self, amount: isize) {\n-        self.out.push('\\n');\n-        self.pending_indentation = 0;\n-        self.indent(amount);\n-    }\n-\n-    fn indent(&mut self, amount: isize) {\n-        self.pending_indentation += amount;\n+    fn get_top(&self) -> PrintFrame {\n+        *self\n+            .print_stack\n+            .last()\n+            .unwrap_or(&PrintFrame::Broken { offset: 0, breaks: Breaks::Inconsistent })\n     }\n \n-    fn get_top(&self) -> PrintStackElem {\n-        *self.print_stack.last().unwrap_or({\n-            &PrintStackElem { offset: 0, pbreak: PrintStackBreak::Broken(Breaks::Inconsistent) }\n-        })\n-    }\n-\n-    fn print_begin(&mut self, b: BeginToken, l: isize) {\n-        if l > self.space {\n-            let col = self.margin - self.space + b.offset;\n-            self.print_stack\n-                .push(PrintStackElem { offset: col, pbreak: PrintStackBreak::Broken(b.breaks) });\n+    fn print_begin(&mut self, token: BeginToken, size: isize) {\n+        if size > self.space {\n+            let col = self.margin - self.space + token.offset;\n+            self.print_stack.push(PrintFrame::Broken { offset: col, breaks: token.breaks });\n         } else {\n-            self.print_stack.push(PrintStackElem { offset: 0, pbreak: PrintStackBreak::Fits });\n+            self.print_stack.push(PrintFrame::Fits);\n         }\n     }\n \n     fn print_end(&mut self) {\n         self.print_stack.pop().unwrap();\n     }\n \n-    fn print_break(&mut self, b: BreakToken, l: isize) {\n-        let top = self.get_top();\n-        match top.pbreak {\n-            PrintStackBreak::Fits => {\n-                self.space -= b.blank_space;\n-                self.indent(b.blank_space);\n-            }\n-            PrintStackBreak::Broken(Breaks::Consistent) => {\n-                self.print_newline(top.offset + b.offset);\n-                self.space = self.margin - (top.offset + b.offset);\n-            }\n-            PrintStackBreak::Broken(Breaks::Inconsistent) => {\n-                if l > self.space {\n-                    self.print_newline(top.offset + b.offset);\n-                    self.space = self.margin - (top.offset + b.offset);\n-                } else {\n-                    self.indent(b.blank_space);\n-                    self.space -= b.blank_space;\n+    fn print_break(&mut self, token: BreakToken, size: isize) {\n+        let break_offset =\n+            match self.get_top() {\n+                PrintFrame::Fits => None,\n+                PrintFrame::Broken { offset, breaks: Breaks::Consistent } => Some(offset),\n+                PrintFrame::Broken { offset, breaks: Breaks::Inconsistent } => {\n+                    if size > self.space { Some(offset) } else { None }\n                 }\n-            }\n+            };\n+        if let Some(offset) = break_offset {\n+            self.out.push('\\n');\n+            self.pending_indentation = offset + token.offset;\n+            self.space = self.margin - (offset + token.offset);\n+        } else {\n+            self.pending_indentation += token.blank_space;\n+            self.space -= token.blank_space;\n         }\n     }\n \n-    fn print_string(&mut self, s: &str) {\n-        let len = s.len() as isize;\n-        // assert!(len <= space);\n-        self.space -= len;\n-\n+    fn print_string(&mut self, string: &str) {\n         // Write the pending indent. A more concise way of doing this would be:\n         //\n         //   write!(self.out, \"{: >n$}\", \"\", n = self.pending_indentation as usize)?;\n         //\n         // But that is significantly slower. This code is sufficiently hot, and indents can get\n         // sufficiently large, that the difference is significant on some workloads.\n         self.out.reserve(self.pending_indentation as usize);\n-        self.out.extend(std::iter::repeat(' ').take(self.pending_indentation as usize));\n+        self.out.extend(iter::repeat(' ').take(self.pending_indentation as usize));\n         self.pending_indentation = 0;\n-        self.out.push_str(s);\n-    }\n \n-    fn print(&mut self, token: Token, l: isize) {\n-        match &token {\n-            Token::Begin(b) => self.print_begin(*b, l),\n-            Token::End => self.print_end(),\n-            Token::Break(b) => self.print_break(*b, l),\n-            Token::String(s) => {\n-                let len = s.len() as isize;\n-                assert_eq!(len, l);\n-                self.print_string(s);\n-            }\n-        }\n-        self.last_printed = Some(token);\n+        self.out.push_str(string);\n+        self.space -= string.len() as isize;\n     }\n \n     // Convenience functions to talk to the printer.\n \n     /// \"raw box\"\n-    pub fn rbox(&mut self, indent: usize, b: Breaks) {\n-        self.scan_begin(BeginToken { offset: indent as isize, breaks: b })\n+    pub fn rbox(&mut self, indent: usize, breaks: Breaks) {\n+        self.scan_begin(BeginToken { offset: indent as isize, breaks })\n     }\n \n     /// Inconsistent breaking box\n@@ -500,8 +449,8 @@ impl Printer {\n     }\n \n     pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) {\n-        let s = wrd.into();\n-        self.scan_string(s)\n+        let string = wrd.into();\n+        self.scan_string(string)\n     }\n \n     fn spaces(&mut self, n: usize) {"}, {"sha": "8187394fe30e004ebabfc17ba75208d53d668bd1", "filename": "compiler/rustc_ast_pretty/src/pp/ring.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -32,11 +32,6 @@ impl<T> RingBuffer<T> {\n         index\n     }\n \n-    pub fn advance_left(&mut self) {\n-        self.data.pop_front().unwrap();\n-        self.offset += 1;\n-    }\n-\n     pub fn clear(&mut self) {\n         self.data.clear();\n     }\n@@ -53,6 +48,12 @@ impl<T> RingBuffer<T> {\n         self.data.front_mut()\n     }\n \n+    pub fn pop_first(&mut self) -> Option<T> {\n+        let first = self.data.pop_front()?;\n+        self.offset += 1;\n+        Some(first)\n+    }\n+\n     pub fn last(&self) -> Option<&T> {\n         self.data.back()\n     }"}, {"sha": "6a3378a3896e3a0b58fdb74afed1dd6b486f5e53", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -3,7 +3,11 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use std::convert::TryInto;\n use std::ops::ControlFlow;\n \n-/// Returns `true` if a used generic parameter requires substitution.\n+/// Checks whether a type contains generic parameters which require substitution.\n+///\n+/// In case it does, returns a `TooGeneric` const eval error. Note that due to polymorphization\n+/// types may be \"concrete enough\" even though they still contain generic parameters in\n+/// case these parameters are unused.\n crate fn ensure_monomorphic_enough<'tcx, T>(tcx: TyCtxt<'tcx>, ty: T) -> InterpResult<'tcx>\n where\n     T: TypeFoldable<'tcx>,"}, {"sha": "e839f7fc7779a6763ff53369a87c2747f2076d7f", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -449,13 +449,17 @@ impl Definitions {\n     }\n \n     #[inline(always)]\n-    pub fn local_def_path_hash_to_def_id(&self, hash: DefPathHash) -> LocalDefId {\n+    pub fn local_def_path_hash_to_def_id(\n+        &self,\n+        hash: DefPathHash,\n+        err: &mut dyn FnMut() -> !,\n+    ) -> LocalDefId {\n         debug_assert!(hash.stable_crate_id() == self.stable_crate_id);\n         self.table\n             .def_path_hash_to_index\n             .get(&hash)\n             .map(|local_def_index| LocalDefId { local_def_index })\n-            .unwrap()\n+            .unwrap_or_else(|| err())\n     }\n \n     pub fn def_path_hash_to_def_index_map(&self) -> &DefPathHashMap {"}, {"sha": "b1334410237e769c2cd4b2816bd8159dc5e4fd69", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -29,7 +29,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.75.0\"\n+chalk-ir = \"0.76.0\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_session = { path = \"../rustc_session\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "d20be0a34d2d5f525f456c9c604d3426678e8d2f", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -266,7 +266,9 @@ impl DepNodeExt for DepNode {\n     /// has been removed.\n     fn extract_def_id<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n         if self.kind.fingerprint_style(tcx) == FingerprintStyle::DefPathHash {\n-            Some(tcx.def_path_hash_to_def_id(DefPathHash(self.hash.into())))\n+            Some(tcx.def_path_hash_to_def_id(DefPathHash(self.hash.into()), &mut || {\n+                panic!(\"Failed to extract DefId: {:?} {}\", self.kind, self.hash)\n+            }))\n         } else {\n             None\n         }"}, {"sha": "75dd223d014d485804e5a3a1dd97815d76770c46", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -308,7 +308,7 @@ pub struct ScopeTree {\n     /// The reason is that semantically, until the `box` expression returns,\n     /// the values are still owned by their containing expressions. So\n     /// we'll see that `&x`.\n-    pub yield_in_scope: FxHashMap<Scope, YieldData>,\n+    pub yield_in_scope: FxHashMap<Scope, Vec<YieldData>>,\n \n     /// The number of visit_expr and visit_pat calls done in the body.\n     /// Used to sanity check visit_expr/visit_pat call count when\n@@ -423,8 +423,8 @@ impl ScopeTree {\n \n     /// Checks whether the given scope contains a `yield`. If so,\n     /// returns `Some(YieldData)`. If not, returns `None`.\n-    pub fn yield_in_scope(&self, scope: Scope) -> Option<YieldData> {\n-        self.yield_in_scope.get(&scope).cloned()\n+    pub fn yield_in_scope(&self, scope: Scope) -> Option<&Vec<YieldData>> {\n+        self.yield_in_scope.get(&scope)\n     }\n \n     /// Gives the number of expressions visited in a body."}, {"sha": "a7d7ee5efc8f2b6bbccfa9a04472a5d22003db5d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1322,15 +1322,18 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Converts a `DefPathHash` to its corresponding `DefId` in the current compilation\n     /// session, if it still exists. This is used during incremental compilation to\n     /// turn a deserialized `DefPathHash` into its current `DefId`.\n-    pub fn def_path_hash_to_def_id(self, hash: DefPathHash) -> DefId {\n+    pub fn def_path_hash_to_def_id(self, hash: DefPathHash, err: &mut dyn FnMut() -> !) -> DefId {\n         debug!(\"def_path_hash_to_def_id({:?})\", hash);\n \n         let stable_crate_id = hash.stable_crate_id();\n \n         // If this is a DefPathHash from the local crate, we can look up the\n         // DefId in the tcx's `Definitions`.\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n-            self.untracked_resolutions.definitions.local_def_path_hash_to_def_id(hash).to_def_id()\n+            self.untracked_resolutions\n+                .definitions\n+                .local_def_path_hash_to_def_id(hash, err)\n+                .to_def_id()\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId."}, {"sha": "fdf93e5893247aa94bc69cef4af37127b8dd80e4", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -366,7 +366,8 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             let target_scopes = visitor.fixup_scopes.drain(start_point..);\n \n             for scope in target_scopes {\n-                let mut yield_data = visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap();\n+                let mut yield_data =\n+                    visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap().last_mut().unwrap();\n                 let count = yield_data.expr_and_pat_count;\n                 let span = yield_data.span;\n \n@@ -429,7 +430,13 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             };\n             let data =\n                 YieldData { span, expr_and_pat_count: visitor.expr_and_pat_count, source: *source };\n-            visitor.scope_tree.yield_in_scope.insert(scope, data);\n+            match visitor.scope_tree.yield_in_scope.get_mut(&scope) {\n+                Some(yields) => yields.push(data),\n+                None => {\n+                    visitor.scope_tree.yield_in_scope.insert(scope, vec![data]);\n+                }\n+            }\n+\n             if visitor.pessimistic_yield {\n                 debug!(\"resolve_expr in pessimistic_yield - marking scope {:?} for fixup\", scope);\n                 visitor.fixup_scopes.push(scope);"}, {"sha": "5f6d9b050b2e54442546faf071c2177b316469dd", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -761,7 +761,9 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n         // If we get to this point, then all of the query inputs were green,\n         // which means that the definition with this hash is guaranteed to\n         // still exist in the current compilation session.\n-        Ok(d.tcx().def_path_hash_to_def_id(def_path_hash))\n+        Ok(d.tcx().def_path_hash_to_def_id(def_path_hash, &mut || {\n+            panic!(\"Failed to convert DefPathHash {:?}\", def_path_hash)\n+        }))\n     }\n }\n "}, {"sha": "2c678e71ae179de0defee914d8f3e454bd9f319a", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -2517,6 +2517,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.visit_expr(elem);\n                 self.resolve_anon_const(ct, IsRepeatExpr::Yes);\n             }\n+            ExprKind::Index(ref elem, ref idx) => {\n+                self.resolve_expr(elem, Some(expr));\n+                self.visit_expr(idx);\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "7b4fe6f0e07b380d71788be7c3db469284bb9219", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -970,7 +970,13 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         };\n \n         match (res, source) {\n-            (Res::Def(DefKind::Macro(MacroKind::Bang), _), _) => {\n+            (\n+                Res::Def(DefKind::Macro(MacroKind::Bang), _),\n+                PathSource::Expr(Some(Expr {\n+                    kind: ExprKind::Index(..) | ExprKind::Call(..), ..\n+                }))\n+                | PathSource::Struct,\n+            ) => {\n                 err.span_label(span, fallback_label);\n                 err.span_suggestion_verbose(\n                     span.shrink_to_hi(),\n@@ -982,6 +988,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     err.note(\"if you want the `try` keyword, you need Rust 2018 or later\");\n                 }\n             }\n+            (Res::Def(DefKind::Macro(MacroKind::Bang), _), _) => {\n+                err.span_label(span, fallback_label);\n+            }\n             (Res::Def(DefKind::TyAlias, def_id), PathSource::Trait(_)) => {\n                 err.span_label(span, \"type aliases cannot be used as traits\");\n                 if self.r.session.is_nightly_build() {"}, {"sha": "25f228c78903181197beb7765456177f287e5a91", "filename": "compiler/rustc_traits/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2FCargo.toml?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -12,9 +12,9 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.75.0\"\n-chalk-engine = \"0.75.0\"\n-chalk-solve = \"0.75.0\"\n+chalk-ir = \"0.76.0\"\n+chalk-engine = \"0.76.0\"\n+chalk-solve = \"0.76.0\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "57930a28a35a159ba9267aac1e0e3a129e47ba62", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -15,6 +15,7 @@ rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n+rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n rustc_target = { path = \"../rustc_target\" }\n@@ -27,3 +28,4 @@ rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n rustc_lint = { path = \"../rustc_lint\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }"}, {"sha": "56b6dd9a284468311638cf1a30effccdbdfe8489", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -3,6 +3,7 @@\n //! is calculated in `rustc_const_eval::transform::generator` and may be a subset of the\n //! types computed here.\n \n+use self::drop_ranges::DropRanges;\n use super::FnCtxt;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::pluralize;\n@@ -19,6 +20,8 @@ use rustc_span::Span;\n use smallvec::SmallVec;\n use tracing::debug;\n \n+mod drop_ranges;\n+\n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     types: FxIndexSet<ty::GeneratorInteriorTypeCause<'tcx>>,\n@@ -34,6 +37,7 @@ struct InteriorVisitor<'a, 'tcx> {\n     guard_bindings: SmallVec<[SmallVec<[HirId; 4]>; 1]>,\n     guard_bindings_set: HirIdSet,\n     linted_values: HirIdSet,\n+    drop_ranges: DropRanges,\n }\n \n impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n@@ -48,9 +52,11 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n     ) {\n         use rustc_span::DUMMY_SP;\n \n+        let ty = self.fcx.resolve_vars_if_possible(ty);\n+\n         debug!(\n-            \"generator_interior: attempting to record type {:?} {:?} {:?} {:?}\",\n-            ty, scope, expr, source_span\n+            \"attempting to record type ty={:?}; hir_id={:?}; scope={:?}; expr={:?}; source_span={:?}; expr_count={:?}\",\n+            ty, hir_id, scope, expr, source_span, self.expr_count,\n         );\n \n         let live_across_yield = scope\n@@ -63,29 +69,34 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                     //\n                     // See the mega-comment at `yield_in_scope` for a proof.\n \n-                    debug!(\n-                        \"comparing counts yield: {} self: {}, source_span = {:?}\",\n-                        yield_data.expr_and_pat_count, self.expr_count, source_span\n-                    );\n+                    yield_data\n+                        .iter()\n+                        .find(|yield_data| {\n+                            debug!(\n+                                \"comparing counts yield: {} self: {}, source_span = {:?}\",\n+                                yield_data.expr_and_pat_count, self.expr_count, source_span\n+                            );\n+\n+                            if self.drop_ranges.is_dropped_at(hir_id, yield_data.expr_and_pat_count)\n+                            {\n+                                debug!(\"value is dropped at yield point; not recording\");\n+                                return false;\n+                            }\n \n-                    // If it is a borrowing happening in the guard,\n-                    // it needs to be recorded regardless because they\n-                    // do live across this yield point.\n-                    if guard_borrowing_from_pattern\n-                        || yield_data.expr_and_pat_count >= self.expr_count\n-                    {\n-                        Some(yield_data)\n-                    } else {\n-                        None\n-                    }\n+                            // If it is a borrowing happening in the guard,\n+                            // it needs to be recorded regardless because they\n+                            // do live across this yield point.\n+                            guard_borrowing_from_pattern\n+                                || yield_data.expr_and_pat_count >= self.expr_count\n+                        })\n+                        .cloned()\n                 })\n             })\n             .unwrap_or_else(|| {\n                 Some(YieldData { span: DUMMY_SP, expr_and_pat_count: 0, source: self.kind.into() })\n             });\n \n         if let Some(yield_data) = live_across_yield {\n-            let ty = self.fcx.resolve_vars_if_possible(ty);\n             debug!(\n                 \"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n                 expr, scope, ty, self.expr_count, yield_data.span\n@@ -154,7 +165,6 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 self.expr_count,\n                 expr.map(|e| e.span)\n             );\n-            let ty = self.fcx.resolve_vars_if_possible(ty);\n             if let Some((unresolved_type, unresolved_type_span)) =\n                 self.fcx.unresolved_type_vars(&ty)\n             {\n@@ -186,6 +196,7 @@ pub fn resolve_interior<'a, 'tcx>(\n         guard_bindings: <_>::default(),\n         guard_bindings_set: <_>::default(),\n         linted_values: <_>::default(),\n+        drop_ranges: drop_ranges::compute_drop_ranges(fcx, def_id, body),\n     };\n     intravisit::walk_body(&mut visitor, body);\n \n@@ -313,6 +324,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         let mut guard_borrowing_from_pattern = false;\n+\n         match &expr.kind {\n             ExprKind::Call(callee, args) => match &callee.kind {\n                 ExprKind::Path(qpath) => {"}, {"sha": "21a8d7b5634569975ce0029d50e243a38db5194f", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,269 @@\n+//! Drop range analysis finds the portions of the tree where a value is guaranteed to be dropped\n+//! (i.e. moved, uninitialized, etc.). This is used to exclude the types of those values from the\n+//! generator type. See `InteriorVisitor::record` for where the results of this analysis are used.\n+//!\n+//! There are three phases to this analysis:\n+//! 1. Use `ExprUseVisitor` to identify the interesting values that are consumed and borrowed.\n+//! 2. Use `DropRangeVisitor` to find where the interesting values are dropped or reinitialized,\n+//!    and also build a control flow graph.\n+//! 3. Use `DropRanges::propagate_to_fixpoint` to flow the dropped/reinitialized information through\n+//!    the CFG and find the exact points where we know a value is definitely dropped.\n+//!\n+//! The end result is a data structure that maps the post-order index of each node in the HIR tree\n+//! to a set of values that are known to be dropped at that location.\n+\n+use self::cfg_build::build_control_flow_graph;\n+use self::record_consumed_borrow::find_consumed_and_borrowed;\n+use crate::check::FnCtxt;\n+use hir::def_id::DefId;\n+use hir::{Body, HirId, HirIdMap, Node};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n+use rustc_middle::ty;\n+use std::collections::BTreeMap;\n+use std::fmt::Debug;\n+\n+mod cfg_build;\n+mod cfg_propagate;\n+mod cfg_visualize;\n+mod record_consumed_borrow;\n+\n+pub fn compute_drop_ranges<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    def_id: DefId,\n+    body: &'tcx Body<'tcx>,\n+) -> DropRanges {\n+    let consumed_borrowed_places = find_consumed_and_borrowed(fcx, def_id, body);\n+\n+    let num_exprs = fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0);\n+    let mut drop_ranges = build_control_flow_graph(\n+        fcx.tcx.hir(),\n+        fcx.tcx,\n+        &fcx.typeck_results.borrow(),\n+        consumed_borrowed_places,\n+        body,\n+        num_exprs,\n+    );\n+\n+    drop_ranges.propagate_to_fixpoint();\n+\n+    DropRanges { tracked_value_map: drop_ranges.tracked_value_map, nodes: drop_ranges.nodes }\n+}\n+\n+/// Applies `f` to consumable node in the HIR subtree pointed to by `place`.\n+///\n+/// This includes the place itself, and if the place is a reference to a local\n+/// variable then `f` is also called on the HIR node for that variable as well.\n+///\n+/// For example, if `place` points to `foo()`, then `f` is called once for the\n+/// result of `foo`. On the other hand, if `place` points to `x` then `f` will\n+/// be called both on the `ExprKind::Path` node that represents the expression\n+/// as well as the HirId of the local `x` itself.\n+fn for_each_consumable<'tcx>(hir: Map<'tcx>, place: TrackedValue, mut f: impl FnMut(TrackedValue)) {\n+    f(place);\n+    let node = hir.find(place.hir_id());\n+    if let Some(Node::Expr(expr)) = node {\n+        match expr.kind {\n+            hir::ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+            )) => {\n+                f(TrackedValue::Variable(*hir_id));\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct PostOrderId {\n+        DEBUG_FORMAT = \"id({})\",\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct TrackedValueIndex {\n+        DEBUG_FORMAT = \"hidx({})\",\n+    }\n+}\n+\n+/// Identifies a value whose drop state we need to track.\n+#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\n+enum TrackedValue {\n+    /// Represents a named variable, such as a let binding, parameter, or upvar.\n+    ///\n+    /// The HirId points to the variable's definition site.\n+    Variable(HirId),\n+    /// A value produced as a result of an expression.\n+    ///\n+    /// The HirId points to the expression that returns this value.\n+    Temporary(HirId),\n+}\n+\n+impl TrackedValue {\n+    fn hir_id(&self) -> HirId {\n+        match self {\n+            TrackedValue::Variable(hir_id) | TrackedValue::Temporary(hir_id) => *hir_id,\n+        }\n+    }\n+}\n+\n+/// Represents a reason why we might not be able to convert a HirId or Place\n+/// into a tracked value.\n+#[derive(Debug)]\n+enum TrackedValueConversionError {\n+    /// Place projects are not currently supported.\n+    ///\n+    /// The reasoning around these is kind of subtle, so we choose to be more\n+    /// conservative around these for now. There is not reason in theory we\n+    /// cannot support these, we just have not implemented it yet.\n+    PlaceProjectionsNotSupported,\n+}\n+\n+impl TryFrom<&PlaceWithHirId<'_>> for TrackedValue {\n+    type Error = TrackedValueConversionError;\n+\n+    fn try_from(place_with_id: &PlaceWithHirId<'_>) -> Result<Self, Self::Error> {\n+        if !place_with_id.place.projections.is_empty() {\n+            debug!(\n+                \"TrackedValue from PlaceWithHirId: {:?} has projections, which are not supported.\",\n+                place_with_id\n+            );\n+            return Err(TrackedValueConversionError::PlaceProjectionsNotSupported);\n+        }\n+\n+        match place_with_id.place.base {\n+            PlaceBase::Rvalue | PlaceBase::StaticItem => {\n+                Ok(TrackedValue::Temporary(place_with_id.hir_id))\n+            }\n+            PlaceBase::Local(hir_id)\n+            | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => {\n+                Ok(TrackedValue::Variable(hir_id))\n+            }\n+        }\n+    }\n+}\n+\n+pub struct DropRanges {\n+    tracked_value_map: FxHashMap<TrackedValue, TrackedValueIndex>,\n+    nodes: IndexVec<PostOrderId, NodeInfo>,\n+}\n+\n+impl DropRanges {\n+    pub fn is_dropped_at(&self, hir_id: HirId, location: usize) -> bool {\n+        self.tracked_value_map\n+            .get(&TrackedValue::Temporary(hir_id))\n+            .or(self.tracked_value_map.get(&TrackedValue::Variable(hir_id)))\n+            .cloned()\n+            .map_or(false, |tracked_value_id| {\n+                self.expect_node(location.into()).drop_state.contains(tracked_value_id)\n+            })\n+    }\n+\n+    /// Returns a reference to the NodeInfo for a node, panicking if it does not exist\n+    fn expect_node(&self, id: PostOrderId) -> &NodeInfo {\n+        &self.nodes[id]\n+    }\n+}\n+\n+/// Tracks information needed to compute drop ranges.\n+struct DropRangesBuilder {\n+    /// The core of DropRangesBuilder is a set of nodes, which each represent\n+    /// one expression. We primarily refer to them by their index in a\n+    /// post-order traversal of the HIR tree,  since this is what\n+    /// generator_interior uses to talk about yield positions.\n+    ///\n+    /// This IndexVec keeps the relevant details for each node. See the\n+    /// NodeInfo struct for more details, but this information includes things\n+    /// such as the set of control-flow successors, which variables are dropped\n+    /// or reinitialized, and whether each variable has been inferred to be\n+    /// known-dropped or potentially reintiialized at each point.\n+    nodes: IndexVec<PostOrderId, NodeInfo>,\n+    /// We refer to values whose drop state we are tracking by the HirId of\n+    /// where they are defined. Within a NodeInfo, however, we store the\n+    /// drop-state in a bit vector indexed by a HirIdIndex\n+    /// (see NodeInfo::drop_state). The hir_id_map field stores the mapping\n+    /// from HirIds to the HirIdIndex that is used to represent that value in\n+    /// bitvector.\n+    tracked_value_map: FxHashMap<TrackedValue, TrackedValueIndex>,\n+\n+    /// When building the control flow graph, we don't always know the\n+    /// post-order index of the target node at the point we encounter it.\n+    /// For example, this happens with break and continue. In those cases,\n+    /// we store a pair of the PostOrderId of the source and the HirId\n+    /// of the target. Once we have gathered all of these edges, we make a\n+    /// pass over the set of deferred edges (see process_deferred_edges in\n+    /// cfg_build.rs), look up the PostOrderId for the target (since now the\n+    /// post-order index for all nodes is known), and add missing control flow\n+    /// edges.\n+    deferred_edges: Vec<(PostOrderId, HirId)>,\n+    /// This maps HirIds of expressions to their post-order index. It is\n+    /// used in process_deferred_edges to correctly add back-edges.\n+    post_order_map: HirIdMap<PostOrderId>,\n+}\n+\n+impl Debug for DropRangesBuilder {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"DropRanges\")\n+            .field(\"hir_id_map\", &self.tracked_value_map)\n+            .field(\"post_order_maps\", &self.post_order_map)\n+            .field(\"nodes\", &self.nodes.iter_enumerated().collect::<BTreeMap<_, _>>())\n+            .finish()\n+    }\n+}\n+\n+/// DropRanges keeps track of what values are definitely dropped at each point in the code.\n+///\n+/// Values of interest are defined by the hir_id of their place. Locations in code are identified\n+/// by their index in the post-order traversal. At its core, DropRanges maps\n+/// (hir_id, post_order_id) -> bool, where a true value indicates that the value is definitely\n+/// dropped at the point of the node identified by post_order_id.\n+impl DropRangesBuilder {\n+    /// Returns the number of values (hir_ids) that are tracked\n+    fn num_values(&self) -> usize {\n+        self.tracked_value_map.len()\n+    }\n+\n+    fn node_mut(&mut self, id: PostOrderId) -> &mut NodeInfo {\n+        let size = self.num_values();\n+        self.nodes.ensure_contains_elem(id, || NodeInfo::new(size));\n+        &mut self.nodes[id]\n+    }\n+\n+    fn add_control_edge(&mut self, from: PostOrderId, to: PostOrderId) {\n+        trace!(\"adding control edge from {:?} to {:?}\", from, to);\n+        self.node_mut(from.into()).successors.push(to.into());\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct NodeInfo {\n+    /// IDs of nodes that can follow this one in the control flow\n+    ///\n+    /// If the vec is empty, then control proceeds to the next node.\n+    successors: Vec<PostOrderId>,\n+\n+    /// List of hir_ids that are dropped by this node.\n+    drops: Vec<TrackedValueIndex>,\n+\n+    /// List of hir_ids that are reinitialized by this node.\n+    reinits: Vec<TrackedValueIndex>,\n+\n+    /// Set of values that are definitely dropped at this point.\n+    drop_state: BitSet<TrackedValueIndex>,\n+}\n+\n+impl NodeInfo {\n+    fn new(num_values: usize) -> Self {\n+        Self {\n+            successors: vec![],\n+            drops: vec![],\n+            reinits: vec![],\n+            drop_state: BitSet::new_filled(num_values),\n+        }\n+    }\n+}"}, {"sha": "fc957b899909d59a0d4de658eabf0508837f4509", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,473 @@\n+use super::{\n+    for_each_consumable, record_consumed_borrow::ConsumedAndBorrowedPlaces, DropRangesBuilder,\n+    NodeInfo, PostOrderId, TrackedValue, TrackedValueIndex,\n+};\n+use hir::{\n+    intravisit::{self, Visitor},\n+    Body, Expr, ExprKind, Guard, HirId,\n+};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::{\n+    hir::map::Map,\n+    ty::{TyCtxt, TypeckResults},\n+};\n+use std::mem::swap;\n+\n+/// Traverses the body to find the control flow graph and locations for the\n+/// relevant places are dropped or reinitialized.\n+///\n+/// The resulting structure still needs to be iterated to a fixed point, which\n+/// can be done with propagate_to_fixpoint in cfg_propagate.\n+pub(super) fn build_control_flow_graph<'tcx>(\n+    hir: Map<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    typeck_results: &TypeckResults<'tcx>,\n+    consumed_borrowed_places: ConsumedAndBorrowedPlaces,\n+    body: &'tcx Body<'tcx>,\n+    num_exprs: usize,\n+) -> DropRangesBuilder {\n+    let mut drop_range_visitor =\n+        DropRangeVisitor::new(hir, tcx, typeck_results, consumed_borrowed_places, num_exprs);\n+    intravisit::walk_body(&mut drop_range_visitor, body);\n+\n+    drop_range_visitor.drop_ranges.process_deferred_edges();\n+\n+    drop_range_visitor.drop_ranges\n+}\n+\n+/// This struct is used to gather the information for `DropRanges` to determine the regions of the\n+/// HIR tree for which a value is dropped.\n+///\n+/// We are interested in points where a variables is dropped or initialized, and the control flow\n+/// of the code. We identify locations in code by their post-order traversal index, so it is\n+/// important for this traversal to match that in `RegionResolutionVisitor` and `InteriorVisitor`.\n+///\n+/// We make several simplifying assumptions, with the goal of being more conservative than\n+/// necessary rather than less conservative (since being less conservative is unsound, but more\n+/// conservative is still safe). These assumptions are:\n+///\n+/// 1. Moving a variable `a` counts as a move of the whole variable.\n+/// 2. Moving a partial path like `a.b.c` is ignored.\n+/// 3. Reinitializing through a field (e.g. `a.b.c = 5`) counds as a reinitialization of all of\n+///    `a`.\n+///\n+/// Some examples:\n+///\n+/// Rule 1:\n+/// ```rust\n+/// let mut a = (vec![0], vec![0]);\n+/// drop(a);\n+/// // `a` is not considered initialized.\n+/// ```\n+///\n+/// Rule 2:\n+/// ```rust\n+/// let mut a = (vec![0], vec![0]);\n+/// drop(a.0);\n+/// drop(a.1);\n+/// // `a` is still considered initialized.\n+/// ```\n+///\n+/// Rule 3:\n+/// ```rust\n+/// let mut a = (vec![0], vec![0]);\n+/// drop(a);\n+/// a.1 = vec![1];\n+/// // all of `a` is considered initialized\n+/// ```\n+\n+struct DropRangeVisitor<'a, 'tcx> {\n+    hir: Map<'tcx>,\n+    places: ConsumedAndBorrowedPlaces,\n+    drop_ranges: DropRangesBuilder,\n+    expr_index: PostOrderId,\n+    tcx: TyCtxt<'tcx>,\n+    typeck_results: &'a TypeckResults<'tcx>,\n+}\n+\n+impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n+    fn new(\n+        hir: Map<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a TypeckResults<'tcx>,\n+        places: ConsumedAndBorrowedPlaces,\n+        num_exprs: usize,\n+    ) -> Self {\n+        debug!(\"consumed_places: {:?}\", places.consumed);\n+        let drop_ranges = DropRangesBuilder::new(\n+            places.consumed.iter().flat_map(|(_, places)| places.iter().cloned()),\n+            hir,\n+            num_exprs,\n+        );\n+        Self { hir, places, drop_ranges, expr_index: PostOrderId::from_u32(0), typeck_results, tcx }\n+    }\n+\n+    fn record_drop(&mut self, value: TrackedValue) {\n+        if self.places.borrowed.contains(&value) {\n+            debug!(\"not marking {:?} as dropped because it is borrowed at some point\", value);\n+        } else {\n+            debug!(\"marking {:?} as dropped at {:?}\", value, self.expr_index);\n+            let count = self.expr_index;\n+            self.drop_ranges.drop_at(value, count);\n+        }\n+    }\n+\n+    /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n+    /// expressions. This method consumes a little deeper into the expression when needed.\n+    fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n+        debug!(\"consuming expr {:?}, count={:?}\", expr.hir_id, self.expr_index);\n+        let places = self\n+            .places\n+            .consumed\n+            .get(&expr.hir_id)\n+            .map_or(vec![], |places| places.iter().cloned().collect());\n+        for place in places {\n+            for_each_consumable(self.hir, place, |value| self.record_drop(value));\n+        }\n+    }\n+\n+    /// Marks an expression as being reinitialized.\n+    ///\n+    /// Note that we always approximated on the side of things being more\n+    /// initialized than they actually are, as opposed to less. In cases such\n+    /// as `x.y = ...`, we would consider all of `x` as being initialized\n+    /// instead of just the `y` field.\n+    ///\n+    /// This is because it is always safe to consider something initialized\n+    /// even when it is not, but the other way around will cause problems.\n+    ///\n+    /// In the future, we will hopefully tighten up these rules to be more\n+    /// precise.\n+    fn reinit_expr(&mut self, expr: &hir::Expr<'_>) {\n+        // Walk the expression to find the base. For example, in an expression\n+        // like `*a[i].x`, we want to find the `a` and mark that as\n+        // reinitialized.\n+        match expr.kind {\n+            ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+            )) => {\n+                // This is the base case, where we have found an actual named variable.\n+\n+                let location = self.expr_index;\n+                debug!(\"reinitializing {:?} at {:?}\", hir_id, location);\n+                self.drop_ranges.reinit_at(TrackedValue::Variable(*hir_id), location);\n+            }\n+\n+            ExprKind::Field(base, _) => self.reinit_expr(base),\n+\n+            // Most expressions do not refer to something where we need to track\n+            // reinitializations.\n+            //\n+            // Some of these may be interesting in the future\n+            ExprKind::Path(..)\n+            | ExprKind::Box(..)\n+            | ExprKind::ConstBlock(..)\n+            | ExprKind::Array(..)\n+            | ExprKind::Call(..)\n+            | ExprKind::MethodCall(..)\n+            | ExprKind::Tup(..)\n+            | ExprKind::Binary(..)\n+            | ExprKind::Unary(..)\n+            | ExprKind::Lit(..)\n+            | ExprKind::Cast(..)\n+            | ExprKind::Type(..)\n+            | ExprKind::DropTemps(..)\n+            | ExprKind::Let(..)\n+            | ExprKind::If(..)\n+            | ExprKind::Loop(..)\n+            | ExprKind::Match(..)\n+            | ExprKind::Closure(..)\n+            | ExprKind::Block(..)\n+            | ExprKind::Assign(..)\n+            | ExprKind::AssignOp(..)\n+            | ExprKind::Index(..)\n+            | ExprKind::AddrOf(..)\n+            | ExprKind::Break(..)\n+            | ExprKind::Continue(..)\n+            | ExprKind::Ret(..)\n+            | ExprKind::InlineAsm(..)\n+            | ExprKind::Struct(..)\n+            | ExprKind::Repeat(..)\n+            | ExprKind::Yield(..)\n+            | ExprKind::Err => (),\n+        }\n+    }\n+\n+    /// For an expression with an uninhabited return type (e.g. a function that returns !),\n+    /// this adds a self edge to to the CFG to model the fact that the function does not\n+    /// return.\n+    fn handle_uninhabited_return(&mut self, expr: &Expr<'tcx>) {\n+        let ty = self.typeck_results.expr_ty(expr);\n+        let ty = self.tcx.erase_regions(ty);\n+        let m = self.tcx.parent_module(expr.hir_id).to_def_id();\n+        let param_env = self.tcx.param_env(m.expect_local());\n+        if self.tcx.is_ty_uninhabited_from(m, ty, param_env) {\n+            // This function will not return. We model this fact as an infinite loop.\n+            self.drop_ranges.add_control_edge(self.expr_index + 1, self.expr_index + 1);\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        let mut reinit = None;\n+        match expr.kind {\n+            ExprKind::Assign(lhs, rhs, _) => {\n+                self.visit_expr(lhs);\n+                self.visit_expr(rhs);\n+\n+                reinit = Some(lhs);\n+            }\n+\n+            ExprKind::If(test, if_true, if_false) => {\n+                self.visit_expr(test);\n+\n+                let fork = self.expr_index;\n+\n+                self.drop_ranges.add_control_edge(fork, self.expr_index + 1);\n+                self.visit_expr(if_true);\n+                let true_end = self.expr_index;\n+\n+                self.drop_ranges.add_control_edge(fork, self.expr_index + 1);\n+                if let Some(if_false) = if_false {\n+                    self.visit_expr(if_false);\n+                }\n+\n+                self.drop_ranges.add_control_edge(true_end, self.expr_index + 1);\n+            }\n+            ExprKind::Match(scrutinee, arms, ..) => {\n+                // We walk through the match expression almost like a chain of if expressions.\n+                // Here's a diagram to follow along with:\n+                //\n+                //           \u250c\u2500\u2510\n+                //     match \u2502A\u2502 {\n+                //       \u250c\u2500\u2500\u2500\u2534\u2500\u2518\n+                //       \u2502\n+                //      \u250c\u25bc\u250c\u2500\u2500\u2500\u25ba\u250c\u2500\u2510   \u250c\u2500\u2510\n+                //      \u2502B\u2502 if \u2502C\u2502 =>\u2502D\u2502,\n+                //      \u2514\u2500\u2518    \u251c\u2500\u2534\u2500\u2500\u25ba\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                //          \u250c\u2500\u2500\u2518              \u2502\n+                //       \u250c\u2500\u2500\u2518                 \u2502\n+                //       \u2502                    \u2502\n+                //      \u250c\u25bc\u250c\u2500\u2500\u2500\u25ba\u250c\u2500\u2510   \u250c\u2500\u2510      \u2502\n+                //      \u2502E\u2502 if \u2502F\u2502 =>\u2502G\u2502,     \u2502\n+                //      \u2514\u2500\u2518    \u251c\u2500\u2534\u2500\u2500\u25ba\u2514\u2500\u2534\u2510     \u2502\n+                //             \u2502        \u2502     \u2502\n+                //     }       \u25bc        \u25bc     \u2502\n+                //     \u250c\u2500\u2510\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                //     \u2502H\u2502\n+                //     \u2514\u2500\u2518\n+                //\n+                // The order we want is that the scrutinee (A) flows into the first pattern (B),\n+                // which flows into the guard (C). Then the guard either flows into the arm body\n+                // (D) or into the start of the next arm (E). Finally, the body flows to the end\n+                // of the match block (H).\n+                //\n+                // The subsequent arms follow the same ordering. First we go to the pattern, then\n+                // the guard (if present, otherwise it flows straight into the body), then into\n+                // the body and then to the end of the match expression.\n+                //\n+                // The comments below show which edge is being added.\n+                self.visit_expr(scrutinee);\n+\n+                let (guard_exit, arm_end_ids) = arms.iter().fold(\n+                    (self.expr_index, vec![]),\n+                    |(incoming_edge, mut arm_end_ids), hir::Arm { pat, body, guard, .. }| {\n+                        // A -> B, or C -> E\n+                        self.drop_ranges.add_control_edge(incoming_edge, self.expr_index + 1);\n+                        self.visit_pat(pat);\n+                        // B -> C and E -> F are added implicitly due to the traversal order.\n+                        match guard {\n+                            Some(Guard::If(expr)) => self.visit_expr(expr),\n+                            Some(Guard::IfLet(pat, expr)) => {\n+                                self.visit_pat(pat);\n+                                self.visit_expr(expr);\n+                            }\n+                            None => (),\n+                        }\n+                        // Likewise, C -> D and F -> G are added implicitly.\n+\n+                        // Save C, F, so we can add the other outgoing edge.\n+                        let to_next_arm = self.expr_index;\n+\n+                        // The default edge does not get added since we also have an explicit edge,\n+                        // so we also need to add an edge to the next node as well.\n+                        //\n+                        // This adds C -> D, F -> G\n+                        self.drop_ranges.add_control_edge(self.expr_index, self.expr_index + 1);\n+                        self.visit_expr(body);\n+\n+                        // Save the end of the body so we can add the exit edge once we know where\n+                        // the exit is.\n+                        arm_end_ids.push(self.expr_index);\n+\n+                        // Pass C to the next iteration, as well as vec![D]\n+                        //\n+                        // On the last round through, we pass F and vec![D, G] so that we can\n+                        // add all the exit edges.\n+                        (to_next_arm, arm_end_ids)\n+                    },\n+                );\n+                // F -> H\n+                self.drop_ranges.add_control_edge(guard_exit, self.expr_index + 1);\n+\n+                arm_end_ids.into_iter().for_each(|arm_end| {\n+                    // D -> H, G -> H\n+                    self.drop_ranges.add_control_edge(arm_end, self.expr_index + 1)\n+                });\n+            }\n+\n+            ExprKind::Loop(body, ..) => {\n+                let loop_begin = self.expr_index + 1;\n+                if body.stmts.is_empty() && body.expr.is_none() {\n+                    // For empty loops we won't have updated self.expr_index after visiting the\n+                    // body, meaning we'd get an edge from expr_index to expr_index + 1, but\n+                    // instead we want an edge from expr_index + 1 to expr_index + 1.\n+                    self.drop_ranges.add_control_edge(loop_begin, loop_begin);\n+                } else {\n+                    self.visit_block(body);\n+                    self.drop_ranges.add_control_edge(self.expr_index, loop_begin);\n+                }\n+            }\n+            ExprKind::Break(hir::Destination { target_id: Ok(target), .. }, ..)\n+            | ExprKind::Continue(hir::Destination { target_id: Ok(target), .. }, ..) => {\n+                self.drop_ranges.add_control_edge_hir_id(self.expr_index, target);\n+            }\n+\n+            ExprKind::Call(f, args) => {\n+                self.visit_expr(f);\n+                for arg in args {\n+                    self.visit_expr(arg);\n+                }\n+\n+                self.handle_uninhabited_return(expr);\n+            }\n+            ExprKind::MethodCall(_, _, exprs, _) => {\n+                for expr in exprs {\n+                    self.visit_expr(expr);\n+                }\n+\n+                self.handle_uninhabited_return(expr);\n+            }\n+\n+            ExprKind::AddrOf(..)\n+            | ExprKind::Array(..)\n+            | ExprKind::AssignOp(..)\n+            | ExprKind::Binary(..)\n+            | ExprKind::Block(..)\n+            | ExprKind::Box(..)\n+            | ExprKind::Break(..)\n+            | ExprKind::Cast(..)\n+            | ExprKind::Closure(..)\n+            | ExprKind::ConstBlock(..)\n+            | ExprKind::Continue(..)\n+            | ExprKind::DropTemps(..)\n+            | ExprKind::Err\n+            | ExprKind::Field(..)\n+            | ExprKind::Index(..)\n+            | ExprKind::InlineAsm(..)\n+            | ExprKind::Let(..)\n+            | ExprKind::Lit(..)\n+            | ExprKind::Path(..)\n+            | ExprKind::Repeat(..)\n+            | ExprKind::Ret(..)\n+            | ExprKind::Struct(..)\n+            | ExprKind::Tup(..)\n+            | ExprKind::Type(..)\n+            | ExprKind::Unary(..)\n+            | ExprKind::Yield(..) => intravisit::walk_expr(self, expr),\n+        }\n+\n+        self.expr_index = self.expr_index + 1;\n+        self.drop_ranges.add_node_mapping(expr.hir_id, self.expr_index);\n+        self.consume_expr(expr);\n+        if let Some(expr) = reinit {\n+            self.reinit_expr(expr);\n+        }\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n+        intravisit::walk_pat(self, pat);\n+\n+        // Increment expr_count here to match what InteriorVisitor expects.\n+        self.expr_index = self.expr_index + 1;\n+    }\n+}\n+\n+impl DropRangesBuilder {\n+    fn new(\n+        tracked_values: impl Iterator<Item = TrackedValue>,\n+        hir: Map<'_>,\n+        num_exprs: usize,\n+    ) -> Self {\n+        let mut tracked_value_map = FxHashMap::<_, TrackedValueIndex>::default();\n+        let mut next = <_>::from(0u32);\n+        for value in tracked_values {\n+            for_each_consumable(hir, value, |value| {\n+                if !tracked_value_map.contains_key(&value) {\n+                    tracked_value_map.insert(value, next);\n+                    next = next + 1;\n+                }\n+            });\n+        }\n+        debug!(\"hir_id_map: {:?}\", tracked_value_map);\n+        let num_values = tracked_value_map.len();\n+        Self {\n+            tracked_value_map,\n+            nodes: IndexVec::from_fn_n(|_| NodeInfo::new(num_values), num_exprs + 1),\n+            deferred_edges: <_>::default(),\n+            post_order_map: <_>::default(),\n+        }\n+    }\n+\n+    fn tracked_value_index(&self, tracked_value: TrackedValue) -> TrackedValueIndex {\n+        *self.tracked_value_map.get(&tracked_value).unwrap()\n+    }\n+\n+    /// Adds an entry in the mapping from HirIds to PostOrderIds\n+    ///\n+    /// Needed so that `add_control_edge_hir_id` can work.\n+    fn add_node_mapping(&mut self, node_hir_id: HirId, post_order_id: PostOrderId) {\n+        self.post_order_map.insert(node_hir_id, post_order_id);\n+    }\n+\n+    /// Like add_control_edge, but uses a hir_id as the target.\n+    ///\n+    /// This can be used for branches where we do not know the PostOrderId of the target yet,\n+    /// such as when handling `break` or `continue`.\n+    fn add_control_edge_hir_id(&mut self, from: PostOrderId, to: HirId) {\n+        self.deferred_edges.push((from, to));\n+    }\n+\n+    fn drop_at(&mut self, value: TrackedValue, location: PostOrderId) {\n+        let value = self.tracked_value_index(value);\n+        self.node_mut(location.into()).drops.push(value);\n+    }\n+\n+    fn reinit_at(&mut self, value: TrackedValue, location: PostOrderId) {\n+        let value = match self.tracked_value_map.get(&value) {\n+            Some(value) => *value,\n+            // If there's no value, this is never consumed and therefore is never dropped. We can\n+            // ignore this.\n+            None => return,\n+        };\n+        self.node_mut(location.into()).reinits.push(value);\n+    }\n+\n+    /// Looks up PostOrderId for any control edges added by HirId and adds a proper edge for them.\n+    ///\n+    /// Should be called after visiting the HIR but before solving the control flow, otherwise some\n+    /// edges will be missed.\n+    fn process_deferred_edges(&mut self) {\n+        let mut edges = vec![];\n+        swap(&mut edges, &mut self.deferred_edges);\n+        edges.into_iter().for_each(|(from, to)| {\n+            let to = *self.post_order_map.get(&to).expect(\"Expression ID not found\");\n+            trace!(\"Adding deferred edge from {:?} to {:?}\", from, to);\n+            self.add_control_edge(from, to)\n+        });\n+    }\n+}"}, {"sha": "139d17d2e1ca186d72705afb98d310597a1c09f5", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_propagate.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,92 @@\n+use super::{DropRangesBuilder, PostOrderId};\n+use rustc_index::{bit_set::BitSet, vec::IndexVec};\n+use std::collections::BTreeMap;\n+\n+impl DropRangesBuilder {\n+    pub fn propagate_to_fixpoint(&mut self) {\n+        trace!(\"before fixpoint: {:#?}\", self);\n+        let preds = self.compute_predecessors();\n+\n+        trace!(\"predecessors: {:#?}\", preds.iter_enumerated().collect::<BTreeMap<_, _>>());\n+\n+        let mut new_state = BitSet::new_empty(self.num_values());\n+        let mut changed_nodes = BitSet::new_empty(self.nodes.len());\n+        let mut unchanged_mask = BitSet::new_filled(self.nodes.len());\n+        changed_nodes.insert(0u32.into());\n+\n+        let mut propagate = || {\n+            let mut changed = false;\n+            unchanged_mask.insert_all();\n+            for id in self.nodes.indices() {\n+                trace!(\"processing {:?}, changed_nodes: {:?}\", id, changed_nodes);\n+                // Check if any predecessor has changed, and if not then short-circuit.\n+                //\n+                // We handle the start node specially, since it doesn't have any predecessors,\n+                // but we need to start somewhere.\n+                if match id.index() {\n+                    0 => !changed_nodes.contains(id),\n+                    _ => !preds[id].iter().any(|pred| changed_nodes.contains(*pred)),\n+                } {\n+                    trace!(\"short-circuiting because none of {:?} have changed\", preds[id]);\n+                    unchanged_mask.remove(id);\n+                    continue;\n+                }\n+\n+                if id.index() == 0 {\n+                    new_state.clear();\n+                } else {\n+                    // If we are not the start node and we have no predecessors, treat\n+                    // everything as dropped because there's no way to get here anyway.\n+                    new_state.insert_all();\n+                };\n+\n+                for pred in &preds[id] {\n+                    new_state.intersect(&self.nodes[*pred].drop_state);\n+                }\n+\n+                for drop in &self.nodes[id].drops {\n+                    new_state.insert(*drop);\n+                }\n+\n+                for reinit in &self.nodes[id].reinits {\n+                    new_state.remove(*reinit);\n+                }\n+\n+                if self.nodes[id].drop_state.intersect(&new_state) {\n+                    changed_nodes.insert(id);\n+                    changed = true;\n+                } else {\n+                    unchanged_mask.remove(id);\n+                }\n+            }\n+\n+            changed_nodes.intersect(&unchanged_mask);\n+            changed\n+        };\n+\n+        while propagate() {\n+            trace!(\"drop_state changed, re-running propagation\");\n+        }\n+\n+        trace!(\"after fixpoint: {:#?}\", self);\n+    }\n+\n+    fn compute_predecessors(&self) -> IndexVec<PostOrderId, Vec<PostOrderId>> {\n+        let mut preds = IndexVec::from_fn_n(|_| vec![], self.nodes.len());\n+        for (id, node) in self.nodes.iter_enumerated() {\n+            // If the node has no explicit successors, we assume that control\n+            // will from this node into the next one.\n+            //\n+            // If there are successors listed, then we assume that all\n+            // possible successors are given and we do not include the default.\n+            if node.successors.len() == 0 && id.index() != self.nodes.len() - 1 {\n+                preds[id + 1].push(id);\n+            } else {\n+                for succ in &node.successors {\n+                    preds[*succ].push(id);\n+                }\n+            }\n+        }\n+        preds\n+    }\n+}"}, {"sha": "20aad7aedf77580e84e1f1e2a2caaa3dd0383fa6", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_visualize.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,77 @@\n+//! Implementation of GraphWalk for DropRanges so we can visualize the control\n+//! flow graph when needed for debugging.\n+\n+use rustc_graphviz as dot;\n+\n+use super::{DropRangesBuilder, PostOrderId};\n+\n+/// Writes the CFG for DropRangesBuilder to a .dot file for visualization.\n+///\n+/// It is not normally called, but is kept around to easily add debugging\n+/// code when needed.\n+#[allow(dead_code)]\n+pub(super) fn write_graph_to_file(drop_ranges: &DropRangesBuilder, filename: &str) {\n+    dot::render(drop_ranges, &mut std::fs::File::create(filename).unwrap()).unwrap();\n+}\n+\n+impl<'a> dot::GraphWalk<'a> for DropRangesBuilder {\n+    type Node = PostOrderId;\n+\n+    type Edge = (PostOrderId, PostOrderId);\n+\n+    fn nodes(&'a self) -> dot::Nodes<'a, Self::Node> {\n+        self.nodes.iter_enumerated().map(|(i, _)| i).collect()\n+    }\n+\n+    fn edges(&'a self) -> dot::Edges<'a, Self::Edge> {\n+        self.nodes\n+            .iter_enumerated()\n+            .flat_map(|(i, node)| {\n+                if node.successors.len() == 0 {\n+                    vec![(i, i + 1)]\n+                } else {\n+                    node.successors.iter().map(move |&s| (i, s)).collect()\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    fn source(&'a self, edge: &Self::Edge) -> Self::Node {\n+        edge.0\n+    }\n+\n+    fn target(&'a self, edge: &Self::Edge) -> Self::Node {\n+        edge.1\n+    }\n+}\n+\n+impl<'a> dot::Labeller<'a> for DropRangesBuilder {\n+    type Node = PostOrderId;\n+\n+    type Edge = (PostOrderId, PostOrderId);\n+\n+    fn graph_id(&'a self) -> dot::Id<'a> {\n+        dot::Id::new(\"drop_ranges\").unwrap()\n+    }\n+\n+    fn node_id(&'a self, n: &Self::Node) -> dot::Id<'a> {\n+        dot::Id::new(format!(\"id{}\", n.index())).unwrap()\n+    }\n+\n+    fn node_label(&'a self, n: &Self::Node) -> dot::LabelText<'a> {\n+        dot::LabelText::LabelStr(\n+            format!(\n+                \"{:?}, local_id: {}\",\n+                n,\n+                self.post_order_map\n+                    .iter()\n+                    .find(|(_hir_id, &post_order_id)| post_order_id == *n)\n+                    .map_or(\"<unknown>\".into(), |(hir_id, _)| format!(\n+                        \"{}\",\n+                        hir_id.local_id.index()\n+                    ))\n+            )\n+            .into(),\n+        )\n+    }\n+}"}, {"sha": "059a135a6fb6517018424292aa9ee3858e2614c8", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,118 @@\n+use super::TrackedValue;\n+use crate::{\n+    check::FnCtxt,\n+    expr_use_visitor::{self, ExprUseVisitor},\n+};\n+use hir::{def_id::DefId, Body, HirId, HirIdMap};\n+use rustc_data_structures::stable_set::FxHashSet;\n+use rustc_hir as hir;\n+use rustc_middle::hir::map::Map;\n+\n+pub(super) fn find_consumed_and_borrowed<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    def_id: DefId,\n+    body: &'tcx Body<'tcx>,\n+) -> ConsumedAndBorrowedPlaces {\n+    let mut expr_use_visitor = ExprUseDelegate::new(fcx.tcx.hir());\n+    expr_use_visitor.consume_body(fcx, def_id, body);\n+    expr_use_visitor.places\n+}\n+\n+pub(super) struct ConsumedAndBorrowedPlaces {\n+    /// Records the variables/expressions that are dropped by a given expression.\n+    ///\n+    /// The key is the hir-id of the expression, and the value is a set or hir-ids for variables\n+    /// or values that are consumed by that expression.\n+    ///\n+    /// Note that this set excludes \"partial drops\" -- for example, a statement like `drop(x.y)` is\n+    /// not considered a drop of `x`, although it would be a drop of `x.y`.\n+    pub(super) consumed: HirIdMap<FxHashSet<TrackedValue>>,\n+    /// A set of hir-ids of values or variables that are borrowed at some point within the body.\n+    pub(super) borrowed: FxHashSet<TrackedValue>,\n+}\n+\n+/// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n+///\n+/// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n+/// record the parent expression, which is the point where the drop actually takes place.\n+struct ExprUseDelegate<'tcx> {\n+    hir: Map<'tcx>,\n+    places: ConsumedAndBorrowedPlaces,\n+}\n+\n+impl<'tcx> ExprUseDelegate<'tcx> {\n+    fn new(hir: Map<'tcx>) -> Self {\n+        Self {\n+            hir,\n+            places: ConsumedAndBorrowedPlaces {\n+                consumed: <_>::default(),\n+                borrowed: <_>::default(),\n+            },\n+        }\n+    }\n+\n+    fn consume_body(&mut self, fcx: &'_ FnCtxt<'_, 'tcx>, def_id: DefId, body: &'tcx Body<'tcx>) {\n+        // Run ExprUseVisitor to find where values are consumed.\n+        ExprUseVisitor::new(\n+            self,\n+            &fcx.infcx,\n+            def_id.expect_local(),\n+            fcx.param_env,\n+            &fcx.typeck_results.borrow(),\n+        )\n+        .consume_body(body);\n+    }\n+\n+    fn mark_consumed(&mut self, consumer: HirId, target: TrackedValue) {\n+        if !self.places.consumed.contains_key(&consumer) {\n+            self.places.consumed.insert(consumer, <_>::default());\n+        }\n+        self.places.consumed.get_mut(&consumer).map(|places| places.insert(target));\n+    }\n+}\n+\n+impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n+    fn consume(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        diag_expr_id: HirId,\n+    ) {\n+        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n+            Some(parent) => parent,\n+            None => place_with_id.hir_id,\n+        };\n+        debug!(\n+            \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n+            place_with_id, diag_expr_id, parent\n+        );\n+        place_with_id\n+            .try_into()\n+            .map_or((), |tracked_value| self.mark_consumed(parent, tracked_value));\n+    }\n+\n+    fn borrow(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: HirId,\n+        _bk: rustc_middle::ty::BorrowKind,\n+    ) {\n+        place_with_id\n+            .try_into()\n+            .map_or(false, |tracked_value| self.places.borrowed.insert(tracked_value));\n+    }\n+\n+    fn mutate(\n+        &mut self,\n+        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: HirId,\n+    ) {\n+    }\n+\n+    fn fake_read(\n+        &mut self,\n+        _place: expr_use_visitor::Place<'tcx>,\n+        _cause: rustc_middle::mir::FakeReadCause,\n+        _diag_expr_id: HirId,\n+    ) {\n+    }\n+}"}, {"sha": "ec88bdf4a370f8a8508d9da6f24e7e827aebdbeb", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n         // This attribute causes us to dump some writeback information\n-        // in the form of errors, which is uSymbol for unit tests.\n+        // in the form of errors, which is used for unit tests.\n         let rustc_dump_user_substs =\n             self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_dump_user_substs);\n "}, {"sha": "cc282fc2f0e443183ce6acb9da18abd03e2cc21f", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -206,6 +206,10 @@ x--expand-yaml-anchors--remove:\n         run: src/ci/scripts/verify-backported-commits.sh\n         <<: *step\n \n+      - name: ensure the stable version number is correct\n+        run: src/ci/scripts/verify-stable-version-number.sh\n+        <<: *step\n+\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n         env:"}, {"sha": "82eb3833ccf98d2788653357fbbb3d4e560f2745", "filename": "src/ci/scripts/verify-stable-version-number.sh", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Fci%2Fscripts%2Fverify-stable-version-number.sh", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Fci%2Fscripts%2Fverify-stable-version-number.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fverify-stable-version-number.sh?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,30 @@\n+#!/bin/bash\n+# On the stable channel, check whether we're trying to build artifacts with the\n+# same version number of a release that's already been published, and fail the\n+# build if that's the case.\n+#\n+# It's a mistake whenever that happens: the release process won't start if it\n+# detects a duplicate version number, and the artifacts would have to be\n+# rebuilt anyway.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+if [[ \"$(cat src/ci/channel)\" != \"stable\" ]]; then\n+    echo \"This script only works on the stable channel. Skipping the check.\"\n+    exit 0\n+fi\n+\n+version=\"$(cat src/version)\"\n+url=\"https://static.rust-lang.org/dist/channel-rust-${version}.toml\"\n+\n+if curl --silent --fail \"${url}\" >/dev/null; then\n+    echo \"The version number ${version} matches an existing release.\"\n+    echo\n+    echo \"If you're trying to prepare a point release, remember to change the\"\n+    echo \"version number in the src/version file.\"\n+    exit 1\n+else\n+    echo \"The version number ${version} does not match any released version!\"\n+    exit 0\n+fi"}, {"sha": "b72d2624177552907a01c2d70a1909e5170cb4e9", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -8,6 +8,7 @@ use std::mem;\n use std::ops;\n \n use rustc_ast::{LitKind, MetaItem, MetaItemKind, NestedMetaItem};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_feature::Features;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{sym, Symbol};\n@@ -43,23 +44,22 @@ crate struct InvalidCfgError {\n \n impl Cfg {\n     /// Parses a `NestedMetaItem` into a `Cfg`.\n-    fn parse_nested(nested_cfg: &NestedMetaItem) -> Result<Cfg, InvalidCfgError> {\n+    fn parse_nested(\n+        nested_cfg: &NestedMetaItem,\n+        exclude: &FxHashSet<Cfg>,\n+    ) -> Result<Option<Cfg>, InvalidCfgError> {\n         match nested_cfg {\n-            NestedMetaItem::MetaItem(ref cfg) => Cfg::parse(cfg),\n+            NestedMetaItem::MetaItem(ref cfg) => Cfg::parse_without(cfg, exclude),\n             NestedMetaItem::Literal(ref lit) => {\n                 Err(InvalidCfgError { msg: \"unexpected literal\", span: lit.span })\n             }\n         }\n     }\n \n-    /// Parses a `MetaItem` into a `Cfg`.\n-    ///\n-    /// The `MetaItem` should be the content of the `#[cfg(...)]`, e.g., `unix` or\n-    /// `target_os = \"redox\"`.\n-    ///\n-    /// If the content is not properly formatted, it will return an error indicating what and where\n-    /// the error is.\n-    crate fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+    crate fn parse_without(\n+        cfg: &MetaItem,\n+        exclude: &FxHashSet<Cfg>,\n+    ) -> Result<Option<Cfg>, InvalidCfgError> {\n         let name = match cfg.ident() {\n             Some(ident) => ident.name,\n             None => {\n@@ -70,9 +70,15 @@ impl Cfg {\n             }\n         };\n         match cfg.kind {\n-            MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n+            MetaItemKind::Word => {\n+                let cfg = Cfg::Cfg(name, None);\n+                if exclude.contains(&cfg) { Ok(None) } else { Ok(Some(cfg)) }\n+            }\n             MetaItemKind::NameValue(ref lit) => match lit.kind {\n-                LitKind::Str(value, _) => Ok(Cfg::Cfg(name, Some(value))),\n+                LitKind::Str(value, _) => {\n+                    let cfg = Cfg::Cfg(name, Some(value));\n+                    if exclude.contains(&cfg) { Ok(None) } else { Ok(Some(cfg)) }\n+                }\n                 _ => Err(InvalidCfgError {\n                     // FIXME: if the main #[cfg] syntax decided to support non-string literals,\n                     // this should be changed as well.\n@@ -81,23 +87,40 @@ impl Cfg {\n                 }),\n             },\n             MetaItemKind::List(ref items) => {\n-                let mut sub_cfgs = items.iter().map(Cfg::parse_nested);\n-                match name {\n+                let sub_cfgs =\n+                    items.iter().filter_map(|i| Cfg::parse_nested(i, exclude).transpose());\n+                let ret = match name {\n                     sym::all => sub_cfgs.fold(Ok(Cfg::True), |x, y| Ok(x? & y?)),\n                     sym::any => sub_cfgs.fold(Ok(Cfg::False), |x, y| Ok(x? | y?)),\n                     sym::not => {\n+                        let mut sub_cfgs = sub_cfgs.collect::<Vec<_>>();\n                         if sub_cfgs.len() == 1 {\n-                            Ok(!sub_cfgs.next().unwrap()?)\n+                            Ok(!sub_cfgs.pop().unwrap()?)\n                         } else {\n                             Err(InvalidCfgError { msg: \"expected 1 cfg-pattern\", span: cfg.span })\n                         }\n                     }\n                     _ => Err(InvalidCfgError { msg: \"invalid predicate\", span: cfg.span }),\n+                };\n+                match ret {\n+                    Ok(c) => Ok(Some(c)),\n+                    Err(e) => Err(e),\n                 }\n             }\n         }\n     }\n \n+    /// Parses a `MetaItem` into a `Cfg`.\n+    ///\n+    /// The `MetaItem` should be the content of the `#[cfg(...)]`, e.g., `unix` or\n+    /// `target_os = \"redox\"`.\n+    ///\n+    /// If the content is not properly formatted, it will return an error indicating what and where\n+    /// the error is.\n+    crate fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+        Self::parse_without(cfg, &FxHashSet::default()).map(|ret| ret.unwrap())\n+    }\n+\n     /// Checks whether the given configuration can be matched in the current session.\n     ///\n     /// Equivalent to `attr::cfg_matches`."}, {"sha": "993503005d7df07ed2409b1c5906665cf482ad88", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -831,8 +831,9 @@ impl AttributesExt for [ast::Attribute] {\n                 self.iter()\n                     .filter(|attr| attr.has_name(sym::cfg))\n                     .filter_map(|attr| single(attr.meta_item_list()?))\n-                    .filter_map(|attr| Cfg::parse(attr.meta_item()?).ok())\n-                    .filter(|cfg| !hidden_cfg.contains(cfg))\n+                    .filter_map(|attr| {\n+                        Cfg::parse_without(attr.meta_item()?, hidden_cfg).ok().flatten()\n+                    })\n                     .fold(Cfg::True, |cfg, new_cfg| cfg & new_cfg)\n             } else {\n                 Cfg::True"}, {"sha": "bdd8aa430b2d1cc0ae948709b7ff0b86b55cba97", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1731,12 +1731,19 @@ details.rustdoc-toggle[open] > summary.hideme::after {\n }\n \n @media (max-width: 700px) {\n+\t/* When linking to an item with an `id` (for instance, by clicking a link in the sidebar,\n+\t   or visiting a URL with a fragment like `#method.new`, we don't want the item to be obscured\n+\t   by the topbar. Anything with an `id` gets scroll-margin-top equal to .mobile-topbar's size.\n+\t*/\n+\t*[id] {\n+\t\tscroll-margin-top: 45px;\n+\t}\n+\n \t.rustdoc {\n \t\tpadding-top: 0px;\n \t\t/* Sidebar should overlay main content, rather than pushing main content to the right.\n \t\t   Turn off `display: flex` on the body element. */\n \t\tdisplay: block;\n-\t\tscroll-margin-top: 45px;\n \t}\n \n \tmain {"}, {"sha": "8f484766d9a5b0722cba71d202fe911287cfc403", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -7,7 +7,7 @@\n mod conversions;\n \n use std::cell::RefCell;\n-use std::fs::File;\n+use std::fs::{create_dir_all, File};\n use std::path::PathBuf;\n use std::rc::Rc;\n \n@@ -18,13 +18,14 @@ use rustc_session::Session;\n \n use rustdoc_json_types as types;\n \n-use crate::clean;\n use crate::clean::types::{ExternalCrate, ExternalLocation};\n use crate::config::RenderOptions;\n+use crate::docfs::PathError;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n use crate::json::conversions::{from_item_id, IntoWithTcx};\n+use crate::{clean, try_err};\n \n #[derive(Clone)]\n crate struct JsonRenderer<'tcx> {\n@@ -171,8 +172,21 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n     /// the hashmap because certain items (traits and types) need to have their mappings for trait\n     /// implementations filled out before they're inserted.\n     fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n+        let local_blanket_impl = match item.def_id {\n+            clean::ItemId::Blanket { impl_id, .. } => impl_id.is_local(),\n+            clean::ItemId::Auto { .. }\n+            | clean::ItemId::DefId(_)\n+            | clean::ItemId::Primitive(_, _) => false,\n+        };\n+\n         // Flatten items that recursively store other items\n-        item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n+        // FIXME(CraftSpider): We skip children of local blanket implementations, as we'll have\n+        //     already seen the actual generic impl, and the generated ones don't need documenting.\n+        //     This is necessary due to the visibility, return type, and self arg of the generated\n+        //     impls not quite matching, and will no longer be necessary when the mismatch is fixed.\n+        if !local_blanket_impl {\n+            item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n+        }\n \n         let id = item.def_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n@@ -256,10 +270,13 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .collect(),\n             format_version: types::FORMAT_VERSION,\n         };\n-        let mut p = self.out_path.clone();\n+        let out_dir = self.out_path.clone();\n+        try_err!(create_dir_all(&out_dir), out_dir);\n+\n+        let mut p = out_dir;\n         p.push(output.index.get(&output.root).unwrap().name.clone().unwrap());\n         p.set_extension(\"json\");\n-        let file = File::create(&p).map_err(|error| Error { error: error.to_string(), file: p })?;\n+        let file = try_err!(File::create(&p), p);\n         serde_json::ser::to_writer(&file, &output).unwrap();\n         Ok(())\n     }"}, {"sha": "2cbb3324a5e0499051584b0e1281f6e86061f26b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -141,6 +141,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     })\n                     .collect::<Vec<_>>()\n             })\n+            .chain([Cfg::Cfg(sym::test, None)].into_iter())\n             .collect();\n \n         self.cx.cache.exact_paths = self.exact_paths;"}, {"sha": "4af8b43ea848d15290a7100ceb39cfa9bb2b8ca6", "filename": "src/test/run-make/raw-dylib-alt-calling-convention/Makefile", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2FMakefile?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1,12 +1,17 @@\n # Test the behavior of #[link(.., kind = \"raw-dylib\")] with alternative calling conventions.\n \n-# only-i686-pc-windows-msvc\n+# only-x86\n+# only-windows\n \n -include ../../run-make-fulldeps/tools.mk\n \n all:\n \t$(call COMPILE_OBJ,\"$(TMPDIR)\"/extern.obj,extern.c)\n+ifdef IS_MSVC\n \t$(CC) \"$(TMPDIR)\"/extern.obj -link -dll -out:\"$(TMPDIR)\"/extern.dll\n+else\n+\t$(CC) \"$(TMPDIR)\"/extern.obj -shared -o \"$(TMPDIR)\"/extern.dll\n+endif\n \t$(RUSTC) --crate-type lib --crate-name raw_dylib_alt_calling_convention_test lib.rs\n \t$(RUSTC) --crate-type bin driver.rs -L \"$(TMPDIR)\"\n \t\"$(TMPDIR)\"/driver > \"$(TMPDIR)\"/output.txt"}, {"sha": "165792b0490156848568a1a3e8beca39dc241bba", "filename": "src/test/run-make/raw-dylib-alt-calling-convention/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Flib.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -62,9 +62,12 @@ pub fn library_function() {\n         fastcall_fn_2(16, 3.5);\n         fastcall_fn_3(3.5);\n         fastcall_fn_4(1, 2, 3.0);\n-        fastcall_fn_5(S { x: 1, y: 2 }, 16);\n+        // FIXME: 91167\n+        // rustc generates incorrect code for the calls to fastcall_fn_5 and fastcall_fn_7\n+        // on i686-pc-windows-gnu; commenting these out until the indicated issue is fixed.\n+        //fastcall_fn_5(S { x: 1, y: 2 }, 16);\n         fastcall_fn_6(Some(&S { x: 10, y: 12 }));\n-        fastcall_fn_7(S2 { x: 15, y: 16 }, 3);\n+        //fastcall_fn_7(S2 { x: 15, y: 16 }, 3);\n         fastcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] });\n         fastcall_fn_9(1, 3.0);\n     }"}, {"sha": "348bad63ed0ded02bf309200f3e633f62992ea0b", "filename": "src/test/run-make/raw-dylib-alt-calling-convention/output.txt", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Foutput.txt", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Foutput.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Foutput.txt?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -11,8 +11,6 @@ fastcall_fn_1(14)\n fastcall_fn_2(16, 3.5)\n fastcall_fn_3(3.5)\n fastcall_fn_4(1, 2, 3.0)\n-fastcall_fn_5(S { x: 1, y: 2 }, 16)\n fastcall_fn_6(S { x: 10, y: 12 })\n-fastcall_fn_7(S2 { x: 15, y: 16 }, 3)\n fastcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] })\n fastcall_fn_9(1, 3.0)"}, {"sha": "680822b6ecb8c075eb457b4f43ac3388e184cddd", "filename": "src/test/rustdoc-gui/sidebar-mobile.goml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -29,3 +29,9 @@ assert-css: (\".sidebar\", {\"display\": \"block\", \"left\": \"-1000px\"})\n \n // Check that the topbar is visible\n assert-property: (\".mobile-topbar\", {\"clientHeight\": \"45\"})\n+\n+// Check that clicking an element from the sidebar scrolls to the right place\n+// so the target is not obscured by the topbar.\n+click: \".sidebar-menu-toggle\"\n+click: \".sidebar-links a\"\n+assert-position: (\"#method\\.must_use\", {\"y\": 45})"}, {"sha": "fcd92887c0bfbcbc8eba9af7ba22a1271598995d", "filename": "src/test/rustdoc-json/enums/variant_struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_struct.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -2,8 +2,8 @@\n // @has - \"$.index[*][?(@.name=='EnumStruct')].kind\" \\\"enum\\\"\n pub enum EnumStruct {\n     // @has - \"$.index[*][?(@.name=='VariantS')].inner.variant_kind\" \\\"struct\\\"\n-    // @has - \"$.index[*][?(@.name=='x')]\"\n-    // @has - \"$.index[*][?(@.name=='y')]\"\n+    // @has - \"$.index[*][?(@.name=='x')].kind\" \\\"struct_field\\\"\n+    // @has - \"$.index[*][?(@.name=='y')].kind\" \\\"struct_field\\\"\n     VariantS {\n         x: u32,\n         y: String,"}, {"sha": "ac3e72e2905d287a31bc15efa41c15253019264d", "filename": "src/test/rustdoc-json/enums/variant_tuple_struct.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_tuple_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_tuple_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_tuple_struct.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -2,5 +2,7 @@\n // @has - \"$.index[*][?(@.name=='EnumTupleStruct')].kind\" \\\"enum\\\"\n pub enum EnumTupleStruct {\n     // @has - \"$.index[*][?(@.name=='VariantA')].inner.variant_kind\" \\\"tuple\\\"\n+    // @has - \"$.index[*][?(@.name=='0')].kind\" \\\"struct_field\\\"\n+    // @has - \"$.index[*][?(@.name=='1')].kind\" \\\"struct_field\\\"\n     VariantA(u32, String),\n }"}, {"sha": "963ea2fe5aea87e87ec0714bce7bf8833a1e4acf", "filename": "src/test/rustdoc-json/impls/blanket_with_local.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc-json%2Fimpls%2Fblanket_with_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc-json%2Fimpls%2Fblanket_with_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fimpls%2Fblanket_with_local.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,14 @@\n+// Test for the ICE in rust/83718\n+// A blanket impl plus a local type together shouldn't result in mismatched ID issues\n+\n+// @has blanket_with_local.json \"$.index[*][?(@.name=='Load')]\"\n+pub trait Load {\n+    fn load() {}\n+}\n+\n+impl<P> Load for P {\n+    fn load() {}\n+}\n+\n+// @has - \"$.index[*][?(@.name=='Wrapper')]\"\n+pub struct Wrapper {}"}, {"sha": "57dd0529535f6ce0b421cc7c763a0f29dacfc3ec", "filename": "src/test/rustdoc/doc-auto-cfg.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc%2Fdoc-auto-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc%2Fdoc-auto-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-auto-cfg.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -3,6 +3,12 @@\n #![crate_name = \"foo\"]\n \n // @has foo/fn.foo.html\n-// @has - '//*[@class=\"item-info\"]/*[@class=\"stab portability\"]' 'non-test'\n-#[cfg(not(test))]\n+// @has - '//*[@class=\"item-info\"]/*[@class=\"stab portability\"]' 'non-doctest'\n+#[cfg(not(doctest))]\n pub fn foo() {}\n+\n+// @has foo/fn.bar.html\n+// @has - '//*[@class=\"item-info\"]/*[@class=\"stab portability\"]' 'doc'\n+// @!has - '//*[@class=\"item-info\"]/*[@class=\"stab portability\"]' 'test'\n+#[cfg(any(test, doc))]\n+pub fn bar() {}"}, {"sha": "636957fe9980d51df43f2fcc587461a0e2601e63", "filename": "src/test/rustdoc/doc-cfg-hide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc%2Fdoc-cfg-hide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Frustdoc%2Fdoc-cfg-hide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg-hide.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -26,7 +26,7 @@ pub struct Hyperdulia;\n \n // @has 'oud/struct.Oystercatcher.html'\n // @count   - '//*[@class=\"stab portability\"]' 1\n-// @matches - '//*[@class=\"stab portability\"]' 'crate features solecism and oystercatcher'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature oystercatcher only'\n // compile-flags:--cfg feature=\"oystercatcher\"\n #[cfg(all(feature = \"solecism\", feature = \"oystercatcher\"))]\n pub struct Oystercatcher;"}, {"sha": "c5453b67ef5b6cbfc90462a2a54fe3e24e10ae20", "filename": "src/test/ui/async-await/async-fn-nonsend.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -18,7 +18,7 @@ async fn fut() {}\n async fn fut_arg<T>(_: T) {}\n \n async fn local_dropped_before_await() {\n-    // FIXME: it'd be nice for this to be allowed in a `Send` `async fn`\n+    // this is okay now because of the drop\n     let x = non_send();\n     drop(x);\n     fut().await;\n@@ -35,21 +35,40 @@ async fn non_send_temporary_in_match() {\n     }\n }\n \n+fn get_formatter() -> std::fmt::Formatter<'static> {\n+    panic!()\n+}\n+\n async fn non_sync_with_method_call() {\n-    // FIXME: it'd be nice for this to work.\n+    let f: &mut std::fmt::Formatter = &mut get_formatter();\n+    // It would by nice for this to work.\n+    if non_sync().fmt(f).unwrap() == () {\n+        fut().await;\n+    }\n+}\n+\n+async fn non_sync_with_method_call_panic() {\n     let f: &mut std::fmt::Formatter = panic!();\n     if non_sync().fmt(f).unwrap() == () {\n         fut().await;\n     }\n }\n \n+async fn non_sync_with_method_call_infinite_loop() {\n+    let f: &mut std::fmt::Formatter = loop {};\n+    if non_sync().fmt(f).unwrap() == () {\n+        fut().await;\n+    }\n+}\n+\n fn assert_send(_: impl Send) {}\n \n pub fn pass_assert() {\n     assert_send(local_dropped_before_await());\n-    //~^ ERROR future cannot be sent between threads safely\n     assert_send(non_send_temporary_in_match());\n     //~^ ERROR future cannot be sent between threads safely\n     assert_send(non_sync_with_method_call());\n     //~^ ERROR future cannot be sent between threads safely\n+    assert_send(non_sync_with_method_call_panic());\n+    assert_send(non_sync_with_method_call_infinite_loop());\n }"}, {"sha": "40ad46b48620d86454d6cb450d2cbd9d6d9cbfb2", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1,28 +1,5 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:49:17\n-   |\n-LL |     assert_send(local_dropped_before_await());\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ future returned by `local_dropped_before_await` is not `Send`\n-   |\n-   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n-note: future is not `Send` as this value is used across an await\n-  --> $DIR/async-fn-nonsend.rs:24:10\n-   |\n-LL |     let x = non_send();\n-   |         - has type `impl Debug` which is not `Send`\n-LL |     drop(x);\n-LL |     fut().await;\n-   |          ^^^^^^ await occurs here, with `x` maybe used later\n-LL | }\n-   | - `x` is later dropped here\n-note: required by a bound in `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:46:24\n-   |\n-LL | fn assert_send(_: impl Send) {}\n-   |                        ^^^^ required by this bound in `assert_send`\n-\n-error: future cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:51:17\n+  --> $DIR/async-fn-nonsend.rs:68:17\n    |\n LL |     assert_send(non_send_temporary_in_match());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ future returned by `non_send_temporary_in_match` is not `Send`\n@@ -32,41 +9,41 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/async-fn-nonsend.rs:33:25\n    |\n LL |     match Some(non_send()) {\n-   |                ---------- has type `impl Debug` which is not `Send`\n+   |           ---------------- has type `Option<impl Debug>` which is not `Send`\n LL |         Some(_) => fut().await,\n-   |                         ^^^^^^ await occurs here, with `non_send()` maybe used later\n+   |                         ^^^^^^ await occurs here, with `Some(non_send())` maybe used later\n ...\n LL | }\n-   | - `non_send()` is later dropped here\n+   | - `Some(non_send())` is later dropped here\n note: required by a bound in `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:46:24\n+  --> $DIR/async-fn-nonsend.rs:64:24\n    |\n LL | fn assert_send(_: impl Send) {}\n    |                        ^^^^ required by this bound in `assert_send`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:53:17\n+  --> $DIR/async-fn-nonsend.rs:70:17\n    |\n LL |     assert_send(non_sync_with_method_call());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ future returned by `non_sync_with_method_call` is not `Send`\n    |\n    = help: the trait `Send` is not implemented for `dyn std::fmt::Write`\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/async-fn-nonsend.rs:42:14\n+  --> $DIR/async-fn-nonsend.rs:46:14\n    |\n-LL |     let f: &mut std::fmt::Formatter = panic!();\n-   |         - has type `&mut Formatter<'_>` which is not `Send`\n-LL |     if non_sync().fmt(f).unwrap() == () {\n+LL |     let f: &mut std::fmt::Formatter = &mut get_formatter();\n+   |                                            --------------- has type `Formatter<'_>` which is not `Send`\n+...\n LL |         fut().await;\n-   |              ^^^^^^ await occurs here, with `f` maybe used later\n+   |              ^^^^^^ await occurs here, with `get_formatter()` maybe used later\n LL |     }\n LL | }\n-   | - `f` is later dropped here\n+   | - `get_formatter()` is later dropped here\n note: required by a bound in `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:46:24\n+  --> $DIR/async-fn-nonsend.rs:64:24\n    |\n LL | fn assert_send(_: impl Send) {}\n    |                        ^^^^ required by this bound in `assert_send`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "73f0ca8153cb9d9c68d72842a12a4ee8cb4b6121", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,29 @@\n+// edition:2021\n+#![feature(negative_impls)]\n+#![allow(unused)]\n+\n+fn main() {\n+    gimme_send(foo());\n+    //~^ ERROR cannot be sent between threads safely\n+}\n+\n+fn gimme_send<T: Send>(t: T) {\n+    drop(t);\n+}\n+\n+struct NotSend {}\n+\n+impl Drop for NotSend {\n+    fn drop(&mut self) {}\n+}\n+\n+impl !Send for NotSend {}\n+\n+async fn foo() {\n+    let mut x = (NotSend {},);\n+    drop(x.0);\n+    x.0 = NotSend {};\n+    bar().await;\n+}\n+\n+async fn bar() {}"}, {"sha": "2097642eb24abb5d6d9fc91939c589e281f5d1e7", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.stderr?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,27 @@\n+error[E0277]: `NotSend` cannot be sent between threads safely\n+  --> $DIR/partial-drop-partial-reinit.rs:6:16\n+   |\n+LL |     gimme_send(foo());\n+   |     ---------- ^^^^^ `NotSend` cannot be sent between threads safely\n+   |     |\n+   |     required by a bound introduced by this call\n+...\n+LL | async fn foo() {\n+   |                - within this `impl Future<Output = ()>`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `NotSend`\n+   = note: required because it appears within the type `(NotSend,)`\n+   = note: required because it appears within the type `{ResumeTy, (NotSend,), impl Future<Output = ()>, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/partial-drop-partial-reinit.rs:22:16: 27:2]`\n+   = note: required because it appears within the type `from_generator::GenFuture<[static generator@$DIR/partial-drop-partial-reinit.rs:22:16: 27:2]>`\n+   = note: required because it appears within the type `impl Future<Output = [async output]>`\n+   = note: required because it appears within the type `impl Future<Output = ()>`\n+note: required by a bound in `gimme_send`\n+  --> $DIR/partial-drop-partial-reinit.rs:10:18\n+   |\n+LL | fn gimme_send<T: Send>(t: T) {\n+   |                  ^^^^ required by this bound in `gimme_send`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d313691b388577ffb80a60888bf95c513ad5a3aa", "filename": "src/test/ui/async-await/unresolved_type_param.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -10,20 +10,12 @@ async fn foo() {\n     //~^ ERROR type inside `async fn` body must be known in this context\n     //~| ERROR type inside `async fn` body must be known in this context\n     //~| ERROR type inside `async fn` body must be known in this context\n-    //~| ERROR type inside `async fn` body must be known in this context\n-    //~| ERROR type inside `async fn` body must be known in this context\n-    //~| NOTE cannot infer type for type parameter `T`\n-    //~| NOTE cannot infer type for type parameter `T`\n     //~| NOTE cannot infer type for type parameter `T`\n     //~| NOTE cannot infer type for type parameter `T`\n     //~| NOTE cannot infer type for type parameter `T`\n     //~| NOTE the type is part of the `async fn` body because of this `await`\n     //~| NOTE the type is part of the `async fn` body because of this `await`\n     //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE in this expansion of desugaring of `await`\n-    //~| NOTE in this expansion of desugaring of `await`\n     //~| NOTE in this expansion of desugaring of `await`\n     //~| NOTE in this expansion of desugaring of `await`\n     //~| NOTE in this expansion of desugaring of `await`"}, {"sha": "d19a3226ef9a44c71a47d82bafbee82411f09bc3", "filename": "src/test/ui/async-await/unresolved_type_param.stderr", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -34,30 +34,6 @@ note: the type is part of the `async fn` body because of this `await`\n LL |     bar().await;\n    |          ^^^^^^\n \n-error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n-   |\n-LL |     bar().await;\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n-   |\n-note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n-   |\n-LL |     bar().await;\n-   |          ^^^^^^\n-\n-error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n-   |\n-LL |     bar().await;\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n-   |\n-note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n-   |\n-LL |     bar().await;\n-   |          ^^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0698`."}, {"sha": "6319a29f5b7d0e3806a7e5c0a5c51395d9abc642", "filename": "src/test/ui/generator/drop-control-flow.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,121 @@\n+// build-pass\n+\n+// A test to ensure generators capture values that were conditionally dropped,\n+// and also that values that are dropped along all paths to a yield do not get\n+// included in the generator type.\n+\n+#![feature(generators, negative_impls)]\n+#![allow(unused_assignments, dead_code)]\n+\n+struct Ptr;\n+impl<'a> Drop for Ptr {\n+    fn drop(&mut self) {}\n+}\n+\n+struct NonSend;\n+impl !Send for NonSend {}\n+\n+fn assert_send<T: Send>(_: T) {}\n+\n+// This test case is reduced from src/test/ui/drop/dynamic-drop-async.rs\n+fn one_armed_if(arg: bool) {\n+    let _ = || {\n+        let arr = [Ptr];\n+        if arg {\n+            drop(arr);\n+        }\n+        yield;\n+    };\n+}\n+\n+fn two_armed_if(arg: bool) {\n+    assert_send(|| {\n+        let arr = [Ptr];\n+        if arg {\n+            drop(arr);\n+        } else {\n+            drop(arr);\n+        }\n+        yield;\n+    })\n+}\n+\n+fn if_let(arg: Option<i32>) {\n+    let _ = || {\n+        let arr = [Ptr];\n+        if let Some(_) = arg {\n+            drop(arr);\n+        }\n+        yield;\n+    };\n+}\n+\n+fn init_in_if(arg: bool) {\n+    assert_send(|| {\n+        let mut x = NonSend;\n+        drop(x);\n+        if arg {\n+            x = NonSend;\n+        } else {\n+            yield;\n+        }\n+    })\n+}\n+\n+fn init_in_match_arm(arg: Option<i32>) {\n+    assert_send(|| {\n+        let mut x = NonSend;\n+        drop(x);\n+        match arg {\n+            Some(_) => x = NonSend,\n+            None => yield,\n+        }\n+    })\n+}\n+\n+fn reinit() {\n+    let _ = || {\n+        let mut arr = [Ptr];\n+        drop(arr);\n+        arr = [Ptr];\n+        yield;\n+    };\n+}\n+\n+fn loop_uninit() {\n+    let _ = || {\n+        let mut arr = [Ptr];\n+        let mut count = 0;\n+        drop(arr);\n+        while count < 3 {\n+            yield;\n+            arr = [Ptr];\n+            count += 1;\n+        }\n+    };\n+}\n+\n+fn nested_loop() {\n+    let _ = || {\n+        let mut arr = [Ptr];\n+        let mut count = 0;\n+        drop(arr);\n+        while count < 3 {\n+            for _ in 0..3 {\n+                yield;\n+            }\n+            arr = [Ptr];\n+            count += 1;\n+        }\n+    };\n+}\n+\n+fn main() {\n+    one_armed_if(true);\n+    if_let(Some(41));\n+    init_in_if(true);\n+    init_in_match_arm(Some(41));\n+    reinit();\n+    loop_uninit();\n+    nested_loop();\n+}"}, {"sha": "f484cbb8d67d575aa046e0fa9b7d9f69e7fc3bca", "filename": "src/test/ui/generator/drop-yield-twice.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,15 @@\n+#![feature(negative_impls, generators)]\n+\n+struct Foo(i32);\n+impl !Send for Foo {}\n+\n+fn main() {\n+    assert_send(|| { //~ ERROR generator cannot be sent between threads safely\n+        let guard = Foo(42);\n+        yield;\n+        drop(guard);\n+        yield;\n+    })\n+}\n+\n+fn assert_send<T: Send>(_: T) {}"}, {"sha": "f821f2f40055f35dea715a44b55bd4f0870c787e", "filename": "src/test/ui/generator/drop-yield-twice.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.stderr?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,25 @@\n+error: generator cannot be sent between threads safely\n+  --> $DIR/drop-yield-twice.rs:7:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/drop-yield-twice.rs:7:17: 12:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/drop-yield-twice.rs:9:9\n+   |\n+LL |         let guard = Foo(42);\n+   |             ----- has type `Foo` which is not `Send`\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+...\n+LL |     })\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/drop-yield-twice.rs:15:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: aborting due to previous error\n+"}, {"sha": "39710febdb95cf892ea4bdbdbbfa8dd086fc8b06", "filename": "src/test/ui/generator/issue-57478.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+#![feature(negative_impls, generators)]\n+\n+struct Foo;\n+impl !Send for Foo {}\n+\n+fn main() {\n+    assert_send(|| {\n+        let guard = Foo;\n+        drop(guard);\n+        yield;\n+    })\n+}\n+\n+fn assert_send<T: Send>(_: T) {}"}, {"sha": "36f6e78cb3bfe12333526c3ac56b2a4969f319f9", "filename": "src/test/ui/generator/partial-drop.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,40 @@\n+#![feature(negative_impls, generators)]\n+\n+struct Foo;\n+impl !Send for Foo {}\n+\n+struct Bar {\n+    foo: Foo,\n+    x: i32,\n+}\n+\n+fn main() {\n+    assert_send(|| {\n+        //~^ ERROR generator cannot be sent between threads safely\n+        // FIXME: it would be nice to make this work.\n+        let guard = Bar { foo: Foo, x: 42 };\n+        drop(guard.foo);\n+        yield;\n+    });\n+\n+    assert_send(|| {\n+        //~^ ERROR generator cannot be sent between threads safely\n+        // FIXME: it would be nice to make this work.\n+        let guard = Bar { foo: Foo, x: 42 };\n+        drop(guard);\n+        guard.foo = Foo;\n+        guard.x = 23;\n+        yield;\n+    });\n+\n+    assert_send(|| {\n+        //~^ ERROR generator cannot be sent between threads safely\n+        // FIXME: it would be nice to make this work.\n+        let guard = Bar { foo: Foo, x: 42 };\n+        let Bar { foo, x } = guard;\n+        drop(foo);\n+        yield;\n+    });\n+}\n+\n+fn assert_send<T: Send>(_: T) {}"}, {"sha": "9a1b0734d8c865111a2397a6f82c9053a86e1c7e", "filename": "src/test/ui/generator/partial-drop.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,71 @@\n+error: generator cannot be sent between threads safely\n+  --> $DIR/partial-drop.rs:12:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/partial-drop.rs:12:17: 18:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/partial-drop.rs:17:9\n+   |\n+LL |         let guard = Bar { foo: Foo, x: 42 };\n+   |             ----- has type `Bar` which is not `Send`\n+LL |         drop(guard.foo);\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+LL |     });\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/partial-drop.rs:40:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: generator cannot be sent between threads safely\n+  --> $DIR/partial-drop.rs:20:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/partial-drop.rs:20:17: 28:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/partial-drop.rs:27:9\n+   |\n+LL |         let guard = Bar { foo: Foo, x: 42 };\n+   |             ----- has type `Bar` which is not `Send`\n+...\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+LL |     });\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/partial-drop.rs:40:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: generator cannot be sent between threads safely\n+  --> $DIR/partial-drop.rs:30:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/partial-drop.rs:30:17: 37:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/partial-drop.rs:36:9\n+   |\n+LL |         let guard = Bar { foo: Foo, x: 42 };\n+   |             ----- has type `Bar` which is not `Send`\n+...\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+LL |     });\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/partial-drop.rs:40:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "260b341a525252998d318274e104a66f7d2410bd", "filename": "src/test/ui/generator/reinit-in-match-guard.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Freinit-in-match-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fgenerator%2Freinit-in-match-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Freinit-in-match-guard.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,25 @@\n+// build-pass\n+\n+#![feature(generators)]\n+\n+#![allow(unused_assignments, dead_code)]\n+\n+fn main() {\n+    let _ = || {\n+        let mut x = vec![22_usize];\n+        std::mem::drop(x);\n+        match y() {\n+            true if {\n+                x = vec![];\n+                false\n+            } => {}\n+            _ => {\n+                yield;\n+            }\n+        }\n+    };\n+}\n+\n+fn y() -> bool {\n+    true\n+}"}, {"sha": "17d05dd09636cf290fba900c4010137c6598fc2f", "filename": "src/test/ui/hygiene/rustc-macro-transparency.stderr", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -11,16 +11,10 @@ LL |     struct SemiTransparent;\n    |     ----------------------- similarly named unit struct `SemiTransparent` defined here\n ...\n LL |     semitransparent;\n-   |     ^^^^^^^^^^^^^^^ not a value\n-   |\n-help: use `!` to invoke the macro\n-   |\n-LL |     semitransparent!;\n-   |                    +\n-help: a unit struct with a similar name exists\n-   |\n-LL |     SemiTransparent;\n-   |     ~~~~~~~~~~~~~~~\n+   |     ^^^^^^^^^^^^^^^\n+   |     |\n+   |     not a value\n+   |     help: a unit struct with a similar name exists: `SemiTransparent`\n \n error[E0423]: expected value, found macro `opaque`\n   --> $DIR/rustc-macro-transparency.rs:30:5\n@@ -29,16 +23,10 @@ LL |     struct Opaque;\n    |     -------------- similarly named unit struct `Opaque` defined here\n ...\n LL |     opaque;\n-   |     ^^^^^^ not a value\n-   |\n-help: use `!` to invoke the macro\n-   |\n-LL |     opaque!;\n-   |           +\n-help: a unit struct with a similar name exists\n-   |\n-LL |     Opaque;\n-   |     ~~~~~~\n+   |     ^^^^^^\n+   |     |\n+   |     not a value\n+   |     help: a unit struct with a similar name exists (notice the capitalization): `Opaque`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "81a08579bb7bcdf24b62cc49d11ab6045da67b47", "filename": "src/test/ui/lint/must_not_suspend/dedup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -13,7 +13,7 @@ async fn wheeee<T>(t: T) {\n }\n \n async fn yes() {\n-    wheeee(No {}).await; //~ ERROR `No` held across\n+    wheeee(&No {}).await; //~ ERROR `No` held across\n }\n \n fn main() {"}, {"sha": "13fa3ae3008d2039640a2812fddf9947417d3a00", "filename": "src/test/ui/lint/must_not_suspend/dedup.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.stderr?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1,19 +1,19 @@\n error: `No` held across a suspend point, but should not be\n-  --> $DIR/dedup.rs:16:12\n+  --> $DIR/dedup.rs:16:13\n    |\n-LL |     wheeee(No {}).await;\n-   |            ^^^^^ ------ the value is held across this suspend point\n+LL |     wheeee(&No {}).await;\n+   |             ^^^^^ ------ the value is held across this suspend point\n    |\n note: the lint level is defined here\n   --> $DIR/dedup.rs:3:9\n    |\n LL | #![deny(must_not_suspend)]\n    |         ^^^^^^^^^^^^^^^^\n help: consider using a block (`{ ... }`) to shrink the value's scope, ending before the suspend point\n-  --> $DIR/dedup.rs:16:12\n+  --> $DIR/dedup.rs:16:13\n    |\n-LL |     wheeee(No {}).await;\n-   |            ^^^^^\n+LL |     wheeee(&No {}).await;\n+   |             ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "54e01608498f820e583e718920d9f700d927e13e", "filename": "src/test/ui/resolve/resolve-hint-macro.fixed", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.fixed?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+fn main() {\n+    assert_eq!(1, 1);\n+    //~^ ERROR expected function, found macro `assert_eq`\n+    assert_eq! { 1, 1 };\n+    //~^ ERROR expected struct, variant or union type, found macro `assert_eq`\n+    //~| ERROR expected identifier, found `1`\n+    //~| ERROR expected identifier, found `1`\n+    assert![true];\n+    //~^ ERROR expected value, found macro `assert`\n+}"}, {"sha": "f16e8c0755384fa50fe26e143364ab10fc23a4a2", "filename": "src/test/ui/resolve/resolve-hint-macro.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1,4 +1,11 @@\n+// run-rustfix\n fn main() {\n     assert_eq(1, 1);\n     //~^ ERROR expected function, found macro `assert_eq`\n+    assert_eq { 1, 1 };\n+    //~^ ERROR expected struct, variant or union type, found macro `assert_eq`\n+    //~| ERROR expected identifier, found `1`\n+    //~| ERROR expected identifier, found `1`\n+    assert[true];\n+    //~^ ERROR expected value, found macro `assert`\n }"}, {"sha": "bc69ddd8ffea2a917760947de49b2fea67f3f441", "filename": "src/test/ui/resolve/resolve-hint-macro.stderr", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.stderr?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1,5 +1,21 @@\n+error: expected identifier, found `1`\n+  --> $DIR/resolve-hint-macro.rs:5:17\n+   |\n+LL |     assert_eq { 1, 1 };\n+   |     ---------   ^ expected identifier\n+   |     |\n+   |     while parsing this struct\n+\n+error: expected identifier, found `1`\n+  --> $DIR/resolve-hint-macro.rs:5:20\n+   |\n+LL |     assert_eq { 1, 1 };\n+   |     ---------      ^ expected identifier\n+   |     |\n+   |     while parsing this struct\n+\n error[E0423]: expected function, found macro `assert_eq`\n-  --> $DIR/resolve-hint-macro.rs:2:5\n+  --> $DIR/resolve-hint-macro.rs:3:5\n    |\n LL |     assert_eq(1, 1);\n    |     ^^^^^^^^^ not a function\n@@ -9,6 +25,29 @@ help: use `!` to invoke the macro\n LL |     assert_eq!(1, 1);\n    |              +\n \n-error: aborting due to previous error\n+error[E0574]: expected struct, variant or union type, found macro `assert_eq`\n+  --> $DIR/resolve-hint-macro.rs:5:5\n+   |\n+LL |     assert_eq { 1, 1 };\n+   |     ^^^^^^^^^ not a struct, variant or union type\n+   |\n+help: use `!` to invoke the macro\n+   |\n+LL |     assert_eq! { 1, 1 };\n+   |              +\n+\n+error[E0423]: expected value, found macro `assert`\n+  --> $DIR/resolve-hint-macro.rs:9:5\n+   |\n+LL |     assert[true];\n+   |     ^^^^^^ not a value\n+   |\n+help: use `!` to invoke the macro\n+   |\n+LL |     assert![true];\n+   |           +\n+\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0423`.\n+Some errors have detailed explanations: E0423, E0574.\n+For more information about an error, try `rustc --explain E0423`."}, {"sha": "945c665e35d28539e2d6d4c60509d9b4cda4f289", "filename": "src/test/ui/rfc-2497-if-let-chains/irrefutable-lets.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1,6 +1,6 @@\n // check-pass\n \n-#![feature(let_chains)]\n+#![feature(if_let_guard, let_chains)]\n \n use std::ops::Range;\n \n@@ -16,6 +16,16 @@ fn main() {\n         && let None = local_start {\n     }\n \n+    match opt {\n+        Some(ref first) if let second = first && let _third = second => {},\n+        _ => {}\n+    }\n+    match opt {\n+        Some(ref first) if let Range { start: local_start, end: _ } = first\n+            && let None = local_start => {},\n+        _ => {}\n+    }\n+\n     while let first = &opt && let Some(ref second) = first && let None = second.start {\n     }\n     while let Some(ref first) = opt && let second = first && let _third = second {"}, {"sha": "e061174f667d97a68384d77c36e295d0d52979de", "filename": "src/test/ui/rfc-2497-if-let-chains/then-else-blocks.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fthen-else-blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fthen-else-blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fthen-else-blocks.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n \n-#![feature(let_chains)]\n+#![feature(if_let_guard, let_chains)]\n \n fn check_if_let(opt: Option<Option<Option<i32>>>, value: i32) -> bool {\n     if let Some(first) = opt\n@@ -15,6 +15,17 @@ fn check_if_let(opt: Option<Option<Option<i32>>>, value: i32) -> bool {\n     }\n }\n \n+fn check_let_guard(opt: Option<Option<Option<i32>>>, value: i32) -> bool {\n+    match opt {\n+        Some(first) if let Some(second) = first && let Some(third) = second && third == value => {\n+            true\n+        }\n+        _ => {\n+            false\n+        }\n+    }\n+}\n+\n fn check_while_let(opt: Option<Option<Option<i32>>>, value: i32) -> bool {\n     while let Some(first) = opt\n         && let Some(second) = first\n@@ -30,6 +41,9 @@ fn main() {\n     assert_eq!(check_if_let(Some(Some(Some(1))), 1), true);\n     assert_eq!(check_if_let(Some(Some(Some(1))), 9), false);\n \n+    assert_eq!(check_let_guard(Some(Some(Some(1))), 1), true);\n+    assert_eq!(check_let_guard(Some(Some(Some(1))), 9), false);\n+\n     assert_eq!(check_while_let(Some(Some(Some(1))), 1), true);\n     assert_eq!(check_while_let(Some(Some(Some(1))), 9), false);\n }"}, {"sha": "2278501308539f3433c068e71e5d331eb7c90c4f", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523be2e05da322daaecf1ecc8f2c0d625f5f46e3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=523be2e05da322daaecf1ecc8f2c0d625f5f46e3", "patch": "@@ -500,7 +500,19 @@ impl<'test> TestCx<'test> {\n             expected = expected.replace(&cr, \"\");\n         }\n \n-        self.compare_source(&expected, &actual);\n+        if !self.config.bless {\n+            self.compare_source(&expected, &actual);\n+        } else if expected != actual {\n+            let filepath_buf;\n+            let filepath = match &self.props.pp_exact {\n+                Some(file) => {\n+                    filepath_buf = self.testpaths.file.parent().unwrap().join(file);\n+                    &filepath_buf\n+                }\n+                None => &self.testpaths.file,\n+            };\n+            fs::write(filepath, &actual).unwrap();\n+        }\n \n         // If we're only making sure that the output matches then just stop here\n         if self.props.pretty_compare_only {"}]}