{"sha": "d08aadcc9aff233165a063df73c6436e0969f79c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOGFhZGNjOWFmZjIzMzE2NWEwNjNkZjczYzY0MzZlMDk2OWY3OWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-06T19:03:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:11Z"}, "message": "Update all uv tests to pass again", "tree": {"sha": "4a3f07578b611d4ea4ab6423dfa220a0beca77e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a3f07578b611d4ea4ab6423dfa220a0beca77e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d08aadcc9aff233165a063df73c6436e0969f79c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d08aadcc9aff233165a063df73c6436e0969f79c", "html_url": "https://github.com/rust-lang/rust/commit/d08aadcc9aff233165a063df73c6436e0969f79c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d08aadcc9aff233165a063df73c6436e0969f79c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0df8b0057c8beaf108dfb34e53829b74fd2a7abc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0df8b0057c8beaf108dfb34e53829b74fd2a7abc", "html_url": "https://github.com/rust-lang/rust/commit/0df8b0057c8beaf108dfb34e53829b74fd2a7abc"}], "stats": {"total": 2047, "additions": 706, "deletions": 1341}, "files": [{"sha": "d5bfd729eb56a57ca9e4e7750c3f9f2c09cdb147", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=d08aadcc9aff233165a063df73c6436e0969f79c", "patch": "@@ -189,28 +189,27 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n \n #[cfg(test)]\n mod test {\n-    use Loop;\n     use std::rt::io::net::ip::{SocketAddr, Ipv4Addr};\n     use super::*;\n+    use super::super::run_uv_loop;\n \n     #[test]\n     fn getaddrinfo_test() {\n-        let mut loop_ = Loop::new();\n-        let mut req = GetAddrInfoRequest::new();\n-        do req.getaddrinfo(&loop_, Some(\"localhost\"), None, None) |_, addrinfo, _| {\n-            let sockaddrs = accum_addrinfo(addrinfo);\n-            let mut found_local = false;\n-            let local_addr = &SocketAddr {\n-                ip: Ipv4Addr(127, 0, 0, 1),\n-                port: 0\n-            };\n-            for addr in sockaddrs.iter() {\n-                found_local = found_local || addr.address == *local_addr;\n+        do run_uv_loop |l| {\n+            match GetAddrInfoRequest::run(l, Some(\"localhost\"), None, None) {\n+                Ok(infos) => {\n+                    let mut found_local = false;\n+                    let local_addr = &SocketAddr {\n+                        ip: Ipv4Addr(127, 0, 0, 1),\n+                        port: 0\n+                    };\n+                    for addr in infos.iter() {\n+                        found_local = found_local || addr.address == *local_addr;\n+                    }\n+                    assert!(found_local);\n+                }\n+                Err(e) => fail!(\"{:?}\", e),\n             }\n-            assert!(found_local);\n         }\n-        loop_.run();\n-        loop_.close();\n-        req.delete();\n     }\n }"}, {"sha": "334e154a397f45fe3ce463f5e16cb6ceceb91d41", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=d08aadcc9aff233165a063df73c6436e0969f79c", "patch": "@@ -126,62 +126,56 @@ impl Drop for AsyncWatcher {\n #[cfg(test)]\n mod test_remote {\n     use std::cell::Cell;\n-    use std::rt::test::*;\n+    use std::rt::rtio::Callback;\n     use std::rt::thread::Thread;\n     use std::rt::tube::Tube;\n-    use std::rt::rtio::EventLoop;\n-    use std::rt::local::Local;\n-    use std::rt::sched::Scheduler;\n \n+    use super::*;\n+    use super::super::run_uv_loop;\n+\n+    // Make sure that we can fire watchers in remote threads\n     #[test]\n     fn test_uv_remote() {\n-        do run_in_mt_newsched_task {\n-            let mut tube = Tube::new();\n-            let tube_clone = tube.clone();\n-            let remote_cell = Cell::new_empty();\n-            do Local::borrow |sched: &mut Scheduler| {\n-                let tube_clone = tube_clone.clone();\n-                let tube_clone_cell = Cell::new(tube_clone);\n-                let remote = do sched.event_loop.remote_callback {\n-                    // This could be called multiple times\n-                    if !tube_clone_cell.is_empty() {\n-                        tube_clone_cell.take().send(1);\n-                    }\n-                };\n-                remote_cell.put_back(remote);\n+        struct MyCallback(Option<Tube<int>>);\n+        impl Callback for MyCallback {\n+            fn call(&mut self) {\n+                // this can get called more than once, but we only want to send\n+                // once\n+                if self.is_some() {\n+                    self.take_unwrap().send(1);\n+                }\n             }\n+        }\n+\n+        do run_uv_loop |l| {\n+            let mut tube = Tube::new();\n+            let cb = ~MyCallback(Some(tube.clone()));\n+            let watcher = Cell::new(AsyncWatcher::new(l, cb as ~Callback));\n+\n             let thread = do Thread::start {\n-                remote_cell.take().fire();\n+                watcher.take().fire();\n             };\n \n-            assert!(tube.recv() == 1);\n+            assert_eq!(tube.recv(), 1);\n             thread.join();\n         }\n     }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use super::*;\n-    use Loop;\n-    use std::unstable::run_in_bare_thread;\n-    use std::rt::thread::Thread;\n-    use std::cell::Cell;\n \n     #[test]\n     fn smoke_test() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let watcher = AsyncWatcher::new(&mut loop_, |w, _| w.close(||()) );\n-            let watcher_cell = Cell::new(watcher);\n-            let thread = do Thread::start {\n-                let mut watcher = watcher_cell.take();\n-                watcher.send();\n-            };\n-            loop_.run();\n-            loop_.close();\n-            thread.join();\n+        static mut hits: uint = 0;\n+\n+        struct MyCallback;\n+        impl Callback for MyCallback {\n+            fn call(&mut self) {\n+                unsafe { hits += 1; }\n+            }\n+        }\n+\n+        do run_uv_loop |l| {\n+            let mut watcher = AsyncWatcher::new(l, ~MyCallback as ~Callback);\n+            watcher.fire();\n         }\n+        assert!(unsafe { hits > 0 });\n     }\n }"}, {"sha": "3b4760e0ff4e1f241a1a82aa1ecc0455daf20b5f", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 103, "deletions": 264, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=d08aadcc9aff233165a063df73c6436e0969f79c", "patch": "@@ -455,297 +455,136 @@ impl rtio::RtioFileStream for FileWatcher {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n-    //use std::rt::test::*;\n-    use std::libc::{STDOUT_FILENO, c_int};\n-    use std::vec;\n-    use std::str;\n-    use std::unstable::run_in_bare_thread;\n-    use super::super::{Loop, Buf, slice_to_uv_buf};\n+    use std::libc::c_int;\n     use std::libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n-\n-    #[test]\n-    fn file_test_full_simple() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let create_flags = O_RDWR | O_CREAT;\n-            let read_flags = O_RDONLY;\n-            // 0644 BZZT! WRONG! 0600! See below.\n-            let mode = S_IWUSR |S_IRUSR;\n-                // these aren't defined in std::libc :(\n-                //map_mode(S_IRGRP) |\n-                //map_mode(S_IROTH);\n-            let path_str = \"./tmp/file_full_simple.txt\";\n-            let write_val = \"hello\".as_bytes().to_owned();\n-            let write_buf  = slice_to_uv_buf(write_val);\n-            let write_buf_ptr: *Buf = &write_buf;\n-            let read_buf_len = 1028;\n-            let read_mem = vec::from_elem(read_buf_len, 0u8);\n-            let read_buf = slice_to_uv_buf(read_mem);\n-            let read_buf_ptr: *Buf = &read_buf;\n-            let open_req = FsRequest::new();\n-            do open_req.open(&loop_, &path_str.to_c_str(), create_flags as int,\n-                             mode as int) |req, uverr| {\n-                assert!(uverr.is_none());\n-                let fd = req.get_result();\n-                let buf = unsafe { *write_buf_ptr };\n-                let write_req = FsRequest::new();\n-                do write_req.write(&req.get_loop(), fd, buf, -1) |req, uverr| {\n-                    let close_req = FsRequest::new();\n-                    do close_req.close(&req.get_loop(), fd) |req, _| {\n-                        assert!(uverr.is_none());\n-                        let loop_ = req.get_loop();\n-                        let open_req = FsRequest::new();\n-                        do open_req.open(&loop_, &path_str.to_c_str(),\n-                                         read_flags as int,0) |req, uverr| {\n-                            assert!(uverr.is_none());\n-                            let loop_ = req.get_loop();\n-                            let fd = req.get_result();\n-                            let read_buf = unsafe { *read_buf_ptr };\n-                            let read_req = FsRequest::new();\n-                            do read_req.read(&loop_, fd, read_buf, 0) |req, uverr| {\n-                                assert!(uverr.is_none());\n-                                let loop_ = req.get_loop();\n-                                // we know nread >=0 because uverr is none..\n-                                let nread = req.get_result() as uint;\n-                                // nread == 0 would be EOF\n-                                if nread > 0 {\n-                                    let read_str = unsafe {\n-                                        let read_buf = *read_buf_ptr;\n-                                        str::from_utf8(\n-                                            vec::from_buf(\n-                                                read_buf.base, nread))\n-                                    };\n-                                    assert!(read_str == ~\"hello\");\n-                                    let close_req = FsRequest::new();\n-                                    do close_req.close(&loop_, fd) |req,uverr| {\n-                                        assert!(uverr.is_none());\n-                                        let loop_ = &req.get_loop();\n-                                        let unlink_req = FsRequest::new();\n-                                        do unlink_req.unlink(loop_,\n-                                                             &path_str.to_c_str())\n-                                        |_,uverr| {\n-                                            assert!(uverr.is_none());\n-                                        };\n-                                    };\n-                                };\n-                            };\n-                        };\n-                    };\n-                };\n-            };\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n+    use std::rt::io;\n+    use std::str;\n+    use std::vec;\n+    use super::*;\n+    use super::super::{run_uv_loop};\n \n     #[test]\n     fn file_test_full_simple_sync() {\n-        do run_in_bare_thread {\n-            // setup\n-            let mut loop_ = Loop::new();\n-            let create_flags = O_RDWR |\n-                O_CREAT;\n+        do run_uv_loop |l| {\n+            let create_flags = O_RDWR | O_CREAT;\n             let read_flags = O_RDONLY;\n-            // 0644\n-            let mode = S_IWUSR |\n-                S_IRUSR;\n-                //S_IRGRP |\n-                //S_IROTH;\n+            let mode = S_IWUSR | S_IRUSR;\n             let path_str = \"./tmp/file_full_simple_sync.txt\";\n-            let write_val = \"hello\".as_bytes().to_owned();\n-            let write_buf = slice_to_uv_buf(write_val);\n-            // open/create\n-            let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n-                                            create_flags as int, mode as int);\n-            assert!(result.is_ok());\n-            let fd = result.unwrap();\n-            // write\n-            let write_req = FsRequest::new();\n-            let result = write_req.write_sync(&loop_, fd, write_buf, -1);\n-            assert!(result.is_ok());\n-            // close\n-            let close_req = FsRequest::new();\n-            let result = close_req.close_sync(&loop_, fd);\n-            assert!(result.is_ok());\n-            // re-open\n-            let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n-                                                   read_flags as int,0);\n-            assert!(result.is_ok());\n-            let len = 1028;\n-            let fd = result.unwrap();\n-            // read\n-            let read_mem: ~[u8] = vec::from_elem(len, 0u8);\n-            let buf = slice_to_uv_buf(read_mem);\n-            let read_req = FsRequest::new();\n-            let result = read_req.read_sync(&loop_, fd, buf, 0);\n-            assert!(result.is_ok());\n-            let nread = result.unwrap();\n-            // nread == 0 would be EOF.. we know it's >= zero because otherwise\n-            // the above assert would fail\n-            if nread > 0 {\n-                let read_str = str::from_utf8(\n-                    read_mem.slice(0, nread as uint));\n-                assert!(read_str == ~\"hello\");\n+\n+            {\n+                // open/create\n+                let result = FsRequest::open(l, &path_str.to_c_str(),\n+                                             create_flags as int, mode as int);\n+                assert!(result.is_ok());\n+                let result = result.unwrap();\n+                let fd = result.fd;\n+\n+                // write\n+                let result = FsRequest::write(l, fd, \"hello\".as_bytes(), -1);\n+                assert!(result.is_ok());\n+\n                 // close\n-                let close_req = FsRequest::new();\n-                let result = close_req.close_sync(&loop_, fd);\n+                let result = FsRequest::close(l, fd, true);\n                 assert!(result.is_ok());\n+            }\n+\n+            {\n+                // re-open\n+                let result = FsRequest::open(l, &path_str.to_c_str(),\n+                                             read_flags as int, 0);\n+                assert!(result.is_ok());\n+                let result = result.unwrap();\n+                let fd = result.fd;\n+\n+                // read\n+                let mut read_mem = vec::from_elem(1000, 0u8);\n+                let result = FsRequest::read(l, fd, read_mem, 0);\n+                assert!(result.is_ok());\n+\n+                let nread = result.unwrap();\n+                assert!(nread > 0);\n+                let read_str = str::from_utf8(read_mem.slice(0, nread as uint));\n+                assert_eq!(read_str, ~\"hello\");\n+\n+                // close\n+                let result = FsRequest::close(l, fd, true);\n+                assert!(result.is_ok());\n+\n                 // unlink\n-                let unlink_req = FsRequest::new();\n-                let result = unlink_req.unlink_sync(&loop_, &path_str.to_c_str());\n+                let result = FsRequest::unlink(l, &path_str.to_c_str());\n                 assert!(result.is_ok());\n-            } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n-            loop_.close();\n+            }\n         }\n     }\n \n-    fn naive_print(loop_: &Loop, input: &str) {\n-        let write_val = input.as_bytes();\n-        let write_buf = slice_to_uv_buf(write_val);\n-        let write_req = FsRequest::new();\n-        write_req.write_sync(loop_, STDOUT_FILENO, write_buf, -1);\n-    }\n-\n     #[test]\n-    fn file_test_write_to_stdout() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            naive_print(&loop_, \"zanzibar!\\n\");\n-            loop_.run();\n-            loop_.close();\n-        };\n-    }\n-    #[test]\n-    fn file_test_stat_simple() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let path = \"./tmp/file_test_stat_simple.txt\";\n-            let create_flags = O_RDWR |\n-                O_CREAT;\n-            let mode = S_IWUSR |\n-                S_IRUSR;\n-            let write_val = \"hello\".as_bytes().to_owned();\n-            let write_buf  = slice_to_uv_buf(write_val);\n-            let write_buf_ptr: *Buf = &write_buf;\n-            let open_req = FsRequest::new();\n-            do open_req.open(&loop_, &path.to_c_str(), create_flags as int,\n-                             mode as int) |req, uverr| {\n-                assert!(uverr.is_none());\n-                let fd = req.get_result();\n-                let buf = unsafe { *write_buf_ptr };\n-                let write_req = FsRequest::new();\n-                do write_req.write(&req.get_loop(), fd, buf, 0) |req, uverr| {\n-                    assert!(uverr.is_none());\n-                    let loop_ = req.get_loop();\n-                    let stat_req = FsRequest::new();\n-                    do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n-                        assert!(uverr.is_none());\n-                        let loop_ = req.get_loop();\n-                        let stat = req.get_stat();\n-                        let sz: uint = stat.st_size as uint;\n-                        assert!(sz > 0);\n-                        let close_req = FsRequest::new();\n-                        do close_req.close(&loop_, fd) |req, uverr| {\n-                            assert!(uverr.is_none());\n-                            let loop_ = req.get_loop();\n-                            let unlink_req = FsRequest::new();\n-                            do unlink_req.unlink(&loop_,\n-                                                 &path.to_c_str()) |req,uverr| {\n-                                assert!(uverr.is_none());\n-                                let loop_ = req.get_loop();\n-                                let stat_req = FsRequest::new();\n-                                do stat_req.stat(&loop_,\n-                                                 &path.to_c_str()) |_, uverr| {\n-                                    // should cause an error because the\n-                                    // file doesn't exist anymore\n-                                    assert!(uverr.is_some());\n-                                };\n-                            };\n-                        };\n-                    };\n-                };\n-            };\n-            loop_.run();\n-            loop_.close();\n+    fn file_test_stat() {\n+        do run_uv_loop |l| {\n+            let path = &\"./tmp/file_test_stat_simple\".to_c_str();\n+            let create_flags = (O_RDWR | O_CREAT) as int;\n+            let mode = (S_IWUSR | S_IRUSR) as int;\n+\n+            let result = FsRequest::open(l, path, create_flags, mode);\n+            assert!(result.is_ok());\n+            let file = result.unwrap();\n+\n+            let result = FsRequest::write(l, file.fd, \"hello\".as_bytes(), 0);\n+            assert!(result.is_ok());\n+\n+            let result = FsRequest::stat(l, path);\n+            assert!(result.is_ok());\n+            assert_eq!(result.unwrap().size, 5);\n+\n+            fn free<T>(_: T) {}\n+            free(file);\n+\n+            let result = FsRequest::unlink(l, path);\n+            assert!(result.is_ok());\n         }\n     }\n \n     #[test]\n     fn file_test_mk_rm_dir() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let path = \"./tmp/mk_rm_dir\";\n-            let mode = S_IWUSR |\n-                S_IRUSR;\n-            let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n-                               mode as c_int) |req,uverr| {\n-                assert!(uverr.is_none());\n-                let loop_ = req.get_loop();\n-                let stat_req = FsRequest::new();\n-                do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n-                    assert!(uverr.is_none());\n-                    let loop_ = req.get_loop();\n-                    let stat = req.get_stat();\n-                    naive_print(&loop_, format!(\"{:?}\", stat));\n-                    assert!(stat.is_dir());\n-                    let rmdir_req = FsRequest::new();\n-                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n-                        assert!(uverr.is_none());\n-                        let loop_ = req.get_loop();\n-                        let stat_req = FsRequest::new();\n-                        do stat_req.stat(&loop_, &path.to_c_str()) |_req, uverr| {\n-                            assert!(uverr.is_some());\n-                        }\n-                    }\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n+        do run_uv_loop |l| {\n+            let path = &\"./tmp/mk_rm_dir\".to_c_str();\n+            let mode = S_IWUSR | S_IRUSR;\n+\n+            let result = FsRequest::mkdir(l, path, mode);\n+            assert!(result.is_ok());\n+\n+            let result = FsRequest::stat(l, path);\n+            assert!(result.is_ok());\n+            assert!(result.unwrap().kind == io::TypeDirectory);\n+\n+            let result = FsRequest::rmdir(l, path);\n+            assert!(result.is_ok());\n+\n+            let result = FsRequest::stat(l, path);\n+            assert!(result.is_err());\n         }\n     }\n+\n     #[test]\n     fn file_test_mkdir_chokes_on_double_create() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let path = \"./tmp/double_create_dir\";\n-            let mode = S_IWUSR |\n-                S_IRUSR;\n-            let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path.to_c_str(), mode as c_int) |req,uverr| {\n-                assert!(uverr.is_none());\n-                let loop_ = req.get_loop();\n-                let mkdir_req = FsRequest::new();\n-                do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n-                                   mode as c_int) |req,uverr| {\n-                    assert!(uverr.is_some());\n-                    let loop_ = req.get_loop();\n-                    let _stat = req.get_stat();\n-                    let rmdir_req = FsRequest::new();\n-                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n-                        assert!(uverr.is_none());\n-                        let _loop = req.get_loop();\n-                    }\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n+        do run_uv_loop |l| {\n+            let path = &\"./tmp/double_create_dir\".to_c_str();\n+            let mode = S_IWUSR | S_IRUSR;\n+\n+            let result = FsRequest::mkdir(l, path, mode as c_int);\n+            assert!(result.is_ok());\n+            let result = FsRequest::mkdir(l, path, mode as c_int);\n+            assert!(result.is_err());\n+            let result = FsRequest::rmdir(l, path);\n+            assert!(result.is_ok());\n         }\n     }\n+\n     #[test]\n     fn file_test_rmdir_chokes_on_nonexistant_path() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let path = \"./tmp/never_existed_dir\";\n-            let rmdir_req = FsRequest::new();\n-            do rmdir_req.rmdir(&loop_, &path.to_c_str()) |_req, uverr| {\n-                assert!(uverr.is_some());\n-            }\n-            loop_.run();\n-            loop_.close();\n+        do run_uv_loop |l| {\n+            let path = &\"./tmp/never_existed_dir\".to_c_str();\n+            let result = FsRequest::rmdir(l, path);\n+            assert!(result.is_err());\n         }\n     }\n }"}, {"sha": "5bedba08fb0eeab494ad3f7211c45735787ba8f4", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=d08aadcc9aff233165a063df73c6436e0969f79c", "patch": "@@ -50,15 +50,13 @@ use std::str::raw::from_c_str;\n use std::vec;\n use std::ptr;\n use std::str;\n-use std::libc::{c_void, c_int, size_t, malloc, free};\n+use std::libc::{c_void, c_int, malloc, free};\n use std::cast::transmute;\n use std::ptr::null;\n use std::unstable::finally::Finally;\n \n use std::rt::io::IoError;\n \n-//#[cfg(test)] use unstable::run_in_bare_thread;\n-\n pub use self::async::AsyncWatcher;\n pub use self::file::{FsRequest, FileWatcher};\n pub use self::idle::IdleWatcher;\n@@ -302,62 +300,58 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n }\n \n-// XXX: Do these conversions without copying\n-\n-/// Transmute an owned vector to a Buf\n-pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        let data = malloc(v.len() as size_t) as *u8;\n-        assert!(data.is_not_null());\n-        do v.as_imm_buf |b, l| {\n-            let data = data as *mut u8;\n-            ptr::copy_memory(data, b, l)\n+fn run_uv_loop(f: proc(&mut Loop)) {\n+    use std::rt::local::Local;\n+    use std::rt::test::run_in_uv_task;\n+    use std::rt::sched::Scheduler;\n+    use std::cell::Cell;\n+\n+    let f = Cell::new(f);\n+    do run_in_uv_task {\n+        let mut io = None;\n+        do Local::borrow |sched: &mut Scheduler| {\n+            sched.event_loop.io(|i| unsafe {\n+                let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n+                    cast::transmute(i);\n+                io = Some(uvio);\n+            });\n         }\n-        uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n+        f.take()(io.unwrap().uv_loop());\n     }\n }\n \n-/// Transmute a Buf that was once a ~[u8] back to ~[u8]\n-pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n-    #[fixed_stack_segment]; #[inline(never)];\n+#[cfg(test)]\n+mod test {\n+    use std::cast::transmute;\n+    use std::ptr;\n+    use std::unstable::run_in_bare_thread;\n \n-    if !(buf.len == 0 && buf.base.is_null()) {\n-        let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n-        unsafe { free(buf.base as *c_void) };\n-        return Some(v);\n-    } else {\n-        // No buffer\n-        uvdebug!(\"No buffer!\");\n-        return None;\n-    }\n-}\n-/*\n-#[test]\n-fn test_slice_to_uv_buf() {\n-    let slice = [0, .. 20];\n-    let buf = slice_to_uv_buf(slice);\n+    use super::{slice_to_uv_buf, Loop};\n \n-    assert!(buf.len == 20);\n+    #[test]\n+    fn test_slice_to_uv_buf() {\n+        let slice = [0, .. 20];\n+        let buf = slice_to_uv_buf(slice);\n \n-    unsafe {\n-        let base = transmute::<*u8, *mut u8>(buf.base);\n-        (*base) = 1;\n-        (*ptr::mut_offset(base, 1)) = 2;\n-    }\n+        assert_eq!(buf.len, 20);\n \n-    assert!(slice[0] == 1);\n-    assert!(slice[1] == 2);\n-}\n+        unsafe {\n+            let base = transmute::<*u8, *mut u8>(buf.base);\n+            (*base) = 1;\n+            (*ptr::mut_offset(base, 1)) = 2;\n+        }\n \n+        assert!(slice[0] == 1);\n+        assert!(slice[1] == 2);\n+    }\n \n-#[test]\n-fn loop_smoke_test() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        loop_.run();\n-        loop_.close();\n+\n+    #[test]\n+    fn loop_smoke_test() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            loop_.run();\n+            loop_.close();\n+        }\n     }\n }\n-*/"}, {"sha": "9fd771b973950573957964af38dde1ce49294887", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 474, "deletions": 265, "changes": 739, "blob_url": "https://github.com/rust-lang/rust/blob/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=d08aadcc9aff233165a063df73c6436e0969f79c", "patch": "@@ -705,350 +705,559 @@ impl Drop for UdpWatcher {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n-    use std::util::ignore;\n     use std::cell::Cell;\n-    use std::vec;\n-    use std::unstable::run_in_bare_thread;\n-    use std::rt::thread::Thread;\n+    use std::comm::oneshot;\n     use std::rt::test::*;\n-    use super::super::{Loop, AllocCallback};\n-    use super::super::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n+    use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,\n+                        RtioUdpSocket};\n+    use std::task;\n+\n+    use super::*;\n+    use super::super::{Loop, run_uv_loop};\n \n     #[test]\n     fn connect_close_ip4() {\n-        do run_in_bare_thread() {\n-            let mut loop_ = Loop::new();\n-            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            // Connect to a port where nobody is listening\n-            let addr = next_test_ip4();\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                uvdebug!(\"tcp_watcher.connect!\");\n-                assert!(status.is_some());\n-                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n-                stream_watcher.close(||());\n+        do run_uv_loop |l| {\n+            match TcpWatcher::connect(l, next_test_ip4()) {\n+                Ok(*) => fail!(),\n+                Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n             }\n-            loop_.run();\n-            loop_.close();\n         }\n     }\n \n     #[test]\n     fn connect_close_ip6() {\n-        do run_in_bare_thread() {\n-            let mut loop_ = Loop::new();\n-            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            // Connect to a port where nobody is listening\n-            let addr = next_test_ip6();\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                uvdebug!(\"tcp_watcher.connect!\");\n-                assert!(status.is_some());\n-                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n-                stream_watcher.close(||());\n+        do run_uv_loop |l| {\n+            match TcpWatcher::connect(l, next_test_ip6()) {\n+                Ok(*) => fail!(),\n+                Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n             }\n-            loop_.run();\n-            loop_.close();\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip4() {\n-        do run_in_bare_thread() {\n-            let mut loop_ = Loop::new();\n-            let mut udp_watcher = { UdpWatcher::new(&mut loop_) };\n-            let addr = next_test_ip4();\n-            udp_watcher.bind(addr);\n-            udp_watcher.close(||());\n-            loop_.run();\n-            loop_.close();\n+        do run_uv_loop |l| {\n+            match UdpWatcher::bind(l, next_test_ip4()) {\n+                Ok(*) => {}\n+                Err(*) => fail!()\n+            }\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip6() {\n-        do run_in_bare_thread() {\n-            let mut loop_ = Loop::new();\n-            let mut udp_watcher = { UdpWatcher::new(&mut loop_) };\n-            let addr = next_test_ip6();\n-            udp_watcher.bind(addr);\n-            udp_watcher.close(||());\n-            loop_.run();\n-            loop_.close();\n+        do run_uv_loop |l| {\n+            match UdpWatcher::bind(l, next_test_ip6()) {\n+                Ok(*) => {}\n+                Err(*) => fail!()\n+            }\n         }\n     }\n \n     #[test]\n     fn listen_ip4() {\n-        do run_in_bare_thread() {\n-            static MAX: int = 10;\n-            let mut loop_ = Loop::new();\n-            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+        do run_uv_loop |l| {\n+            let (port, chan) = oneshot();\n+            let chan = Cell::new(chan);\n             let addr = next_test_ip4();\n-            server_tcp_watcher.bind(addr);\n-            let loop_ = loop_;\n-            uvdebug!(\"listening\");\n-            let mut stream = server_tcp_watcher.as_stream();\n-            let res = do stream.listen |mut server_stream_watcher, status| {\n-                uvdebug!(\"listened!\");\n-                assert!(status.is_none());\n-                let mut loop_ = loop_;\n-                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-                server_stream_watcher.accept(client_tcp_watcher);\n-                let count_cell = Cell::new(0);\n-                let server_stream_watcher = server_stream_watcher;\n-                uvdebug!(\"starting read\");\n-                let alloc: AllocCallback = |size| {\n-                    vec_to_uv_buf(vec::from_elem(size, 0u8))\n+\n+            let handle = l.handle;\n+            do spawn {\n+                let w = match TcpListener::bind(&mut Loop::wrap(handle), addr) {\n+                    Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n+                };\n+                let mut w = match w.listen() {\n+                    Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n                 };\n-                do client_tcp_watcher.read_start(alloc) |stream_watcher, nread, buf, status| {\n-\n-                    uvdebug!(\"i'm reading!\");\n-                    let buf = vec_from_uv_buf(buf);\n-                    let mut count = count_cell.take();\n-                    if status.is_none() {\n-                        uvdebug!(\"got {} bytes\", nread);\n-                        let buf = buf.unwrap();\n-                        for byte in buf.slice(0, nread as uint).iter() {\n-                            assert!(*byte == count as u8);\n-                            uvdebug!(\"{}\", *byte as uint);\n-                            count += 1;\n+                chan.take().send(());\n+                match w.accept() {\n+                    Ok(mut stream) => {\n+                        let mut buf = [0u8, ..10];\n+                        match stream.read(buf) {\n+                            Ok(10) => {} e => fail!(\"{:?}\", e),\n                         }\n-                    } else {\n-                        assert_eq!(count, MAX);\n-                        do stream_watcher.close {\n-                            server_stream_watcher.close(||());\n+                        for i in range(0, 10u8) {\n+                            assert_eq!(buf[i], i + 1);\n                         }\n                     }\n-                    count_cell.put_back(count);\n+                    Err(e) => fail!(\"{:?}\", e)\n                 }\n-            };\n+            }\n \n-            assert!(res.is_ok());\n-\n-            let client_thread = do Thread::start {\n-                uvdebug!(\"starting client thread\");\n-                let mut loop_ = Loop::new();\n-                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n-                    uvdebug!(\"connecting\");\n-                    assert!(status.is_none());\n-                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n-                    let buf = slice_to_uv_buf(msg);\n-                    let msg_cell = Cell::new(msg);\n-                    do stream_watcher.write(buf) |stream_watcher, status| {\n-                        uvdebug!(\"writing\");\n-                        assert!(status.is_none());\n-                        let msg_cell = Cell::new(msg_cell.take());\n-                        stream_watcher.close(||ignore(msg_cell.take()));\n-                    }\n-                }\n-                loop_.run();\n-                loop_.close();\n+            port.recv();\n+            let mut w = match TcpWatcher::connect(&mut Loop::wrap(handle), addr) {\n+                Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n             };\n-\n-            let mut loop_ = loop_;\n-            loop_.run();\n-            loop_.close();\n-            client_thread.join();\n-        };\n+            match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n+                Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n+            }\n+        }\n     }\n \n     #[test]\n     fn listen_ip6() {\n-        do run_in_bare_thread() {\n-            static MAX: int = 10;\n-            let mut loop_ = Loop::new();\n-            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+        do run_uv_loop |l| {\n+            let (port, chan) = oneshot();\n+            let chan = Cell::new(chan);\n             let addr = next_test_ip6();\n-            server_tcp_watcher.bind(addr);\n-            let loop_ = loop_;\n-            uvdebug!(\"listening\");\n-            let mut stream = server_tcp_watcher.as_stream();\n-            let res = do stream.listen |mut server_stream_watcher, status| {\n-                uvdebug!(\"listened!\");\n-                assert!(status.is_none());\n-                let mut loop_ = loop_;\n-                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-                server_stream_watcher.accept(client_tcp_watcher);\n-                let count_cell = Cell::new(0);\n-                let server_stream_watcher = server_stream_watcher;\n-                uvdebug!(\"starting read\");\n-                let alloc: AllocCallback = |size| {\n-                    vec_to_uv_buf(vec::from_elem(size, 0u8))\n+\n+            let handle = l.handle;\n+            do spawn {\n+                let w = match TcpListener::bind(&mut Loop::wrap(handle), addr) {\n+                    Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n+                };\n+                let mut w = match w.listen() {\n+                    Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n                 };\n-                do client_tcp_watcher.read_start(alloc)\n-                    |stream_watcher, nread, buf, status| {\n-\n-                    uvdebug!(\"i'm reading!\");\n-                    let buf = vec_from_uv_buf(buf);\n-                    let mut count = count_cell.take();\n-                    if status.is_none() {\n-                        uvdebug!(\"got {} bytes\", nread);\n-                        let buf = buf.unwrap();\n-                        let r = buf.slice(0, nread as uint);\n-                        for byte in r.iter() {\n-                            assert!(*byte == count as u8);\n-                            uvdebug!(\"{}\", *byte as uint);\n-                            count += 1;\n+                chan.take().send(());\n+                match w.accept() {\n+                    Ok(mut stream) => {\n+                        let mut buf = [0u8, ..10];\n+                        match stream.read(buf) {\n+                            Ok(10) => {} e => fail!(\"{:?}\", e),\n                         }\n-                    } else {\n-                        assert_eq!(count, MAX);\n-                        do stream_watcher.close {\n-                            server_stream_watcher.close(||());\n+                        for i in range(0, 10u8) {\n+                            assert_eq!(buf[i], i + 1);\n                         }\n                     }\n-                    count_cell.put_back(count);\n+                    Err(e) => fail!(\"{:?}\", e)\n                 }\n+            }\n+\n+            port.recv();\n+            let mut w = match TcpWatcher::connect(&mut Loop::wrap(handle), addr) {\n+                Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n             };\n-            assert!(res.is_ok());\n-\n-            let client_thread = do Thread::start {\n-                uvdebug!(\"starting client thread\");\n-                let mut loop_ = Loop::new();\n-                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n-                    uvdebug!(\"connecting\");\n-                    assert!(status.is_none());\n-                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n-                    let buf = slice_to_uv_buf(msg);\n-                    let msg_cell = Cell::new(msg);\n-                    do stream_watcher.write(buf) |stream_watcher, status| {\n-                        uvdebug!(\"writing\");\n-                        assert!(status.is_none());\n-                        let msg_cell = Cell::new(msg_cell.take());\n-                        stream_watcher.close(||ignore(msg_cell.take()));\n+            match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n+                Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn udp_recv_ip4() {\n+        do run_uv_loop |l| {\n+            let (port, chan) = oneshot();\n+            let chan = Cell::new(chan);\n+            let client = next_test_ip4();\n+            let server = next_test_ip4();\n+\n+            let handle = l.handle;\n+            do spawn {\n+                match UdpWatcher::bind(&mut Loop::wrap(handle), server) {\n+                    Ok(mut w) => {\n+                        chan.take().send(());\n+                        let mut buf = [0u8, ..10];\n+                        match w.recvfrom(buf) {\n+                            Ok((10, addr)) => assert_eq!(addr, client),\n+                            e => fail!(\"{:?}\", e),\n+                        }\n+                        for i in range(0, 10u8) {\n+                            assert_eq!(buf[i], i + 1);\n+                        }\n                     }\n+                    Err(e) => fail!(\"{:?}\", e)\n                 }\n-                loop_.run();\n-                loop_.close();\n+            }\n+\n+            port.recv();\n+            let mut w = match UdpWatcher::bind(&mut Loop::wrap(handle), client) {\n+                Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n             };\n+            match w.sendto([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n+                Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn udp_recv_ip6() {\n+        do run_uv_loop |l| {\n+            let (port, chan) = oneshot();\n+            let chan = Cell::new(chan);\n+            let client = next_test_ip6();\n+            let server = next_test_ip6();\n+\n+            let handle = l.handle;\n+            do spawn {\n+                match UdpWatcher::bind(&mut Loop::wrap(handle), server) {\n+                    Ok(mut w) => {\n+                        chan.take().send(());\n+                        let mut buf = [0u8, ..10];\n+                        match w.recvfrom(buf) {\n+                            Ok((10, addr)) => assert_eq!(addr, client),\n+                            e => fail!(\"{:?}\", e),\n+                        }\n+                        for i in range(0, 10u8) {\n+                            assert_eq!(buf[i], i + 1);\n+                        }\n+                    }\n+                    Err(e) => fail!(\"{:?}\", e)\n+                }\n+            }\n \n-            let mut loop_ = loop_;\n-            loop_.run();\n-            loop_.close();\n-            client_thread.join();\n+            port.recv();\n+            let mut w = match UdpWatcher::bind(&mut Loop::wrap(handle), client) {\n+                Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n+            };\n+            match w.sendto([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n+                Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n+            }\n         }\n     }\n \n     #[test]\n-    fn udp_recv_ip4() {\n-        do run_in_bare_thread() {\n-            static MAX: int = 10;\n-            let mut loop_ = Loop::new();\n+    fn test_read_read_read() {\n+        do run_uv_loop |l| {\n+            let addr = next_test_ip4();\n+            static MAX: uint = 500000;\n+            let (port, chan) = oneshot();\n+            let port = Cell::new(port);\n+            let chan = Cell::new(chan);\n+\n+            let handle = l.handle;\n+            do spawntask {\n+                let l = &mut Loop::wrap(handle);\n+                let listener = TcpListener::bind(l, addr).unwrap();\n+                let mut acceptor = listener.listen().unwrap();\n+                chan.take().send(());\n+                let mut stream = acceptor.accept().unwrap();\n+                let buf = [1, .. 2048];\n+                let mut total_bytes_written = 0;\n+                while total_bytes_written < MAX {\n+                    stream.write(buf);\n+                    total_bytes_written += buf.len();\n+                }\n+            }\n+\n+            do spawntask {\n+                let l = &mut Loop::wrap(handle);\n+                port.take().recv();\n+                let mut stream = TcpWatcher::connect(l, addr).unwrap();\n+                let mut buf = [0, .. 2048];\n+                let mut total_bytes_read = 0;\n+                while total_bytes_read < MAX {\n+                    let nread = stream.read(buf).unwrap();\n+                    uvdebug!(\"read {} bytes\", nread);\n+                    total_bytes_read += nread;\n+                    for i in range(0u, nread) {\n+                        assert_eq!(buf[i], 1);\n+                    }\n+                }\n+                uvdebug!(\"read {} bytes total\", total_bytes_read);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(windows))] // FIXME(#10102) the server never sees the second send\n+    fn test_udp_twice() {\n+        do run_uv_loop |l| {\n             let server_addr = next_test_ip4();\n             let client_addr = next_test_ip4();\n+            let (port, chan) = oneshot();\n+            let port = Cell::new(port);\n+            let chan = Cell::new(chan);\n+\n+            let handle = l.handle;\n+            do spawntask {\n+                let l = &mut Loop::wrap(handle);\n+                let mut client = UdpWatcher::bind(l, client_addr).unwrap();\n+                port.take().recv();\n+                assert!(client.sendto([1], server_addr).is_ok());\n+                assert!(client.sendto([2], server_addr).is_ok());\n+            }\n \n-            let mut server = UdpWatcher::new(&loop_);\n-            assert!(server.bind(server_addr).is_ok());\n+            do spawntask {\n+                let l = &mut Loop::wrap(handle);\n+                let mut server = UdpWatcher::bind(l, server_addr).unwrap();\n+                chan.take().send(());\n+                let mut buf1 = [0];\n+                let mut buf2 = [0];\n+                let (nread1, src1) = server.recvfrom(buf1).unwrap();\n+                let (nread2, src2) = server.recvfrom(buf2).unwrap();\n+                assert_eq!(nread1, 1);\n+                assert_eq!(nread2, 1);\n+                assert_eq!(src1, client_addr);\n+                assert_eq!(src2, client_addr);\n+                assert_eq!(buf1[0], 1);\n+                assert_eq!(buf2[0], 2);\n+            }\n+        }\n+    }\n \n-            uvdebug!(\"starting read\");\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0u8))\n-            };\n+    #[test]\n+    fn test_udp_many_read() {\n+        do run_uv_loop |l| {\n+            let server_out_addr = next_test_ip4();\n+            let server_in_addr = next_test_ip4();\n+            let client_out_addr = next_test_ip4();\n+            let client_in_addr = next_test_ip4();\n+            static MAX: uint = 500_000;\n+\n+            let (p1, c1) = oneshot();\n+            let (p2, c2) = oneshot();\n+\n+            let first = Cell::new((p1, c2));\n+            let second = Cell::new((p2, c1));\n+\n+            let handle = l.handle;\n+            do spawntask {\n+                let l = &mut Loop::wrap(handle);\n+                let mut server_out = UdpWatcher::bind(l, server_out_addr).unwrap();\n+                let mut server_in = UdpWatcher::bind(l, server_in_addr).unwrap();\n+                let (port, chan) = first.take();\n+                chan.send(());\n+                port.recv();\n+                let msg = [1, .. 2048];\n+                let mut total_bytes_sent = 0;\n+                let mut buf = [1];\n+                while buf[0] == 1 {\n+                    // send more data\n+                    assert!(server_out.sendto(msg, client_in_addr).is_ok());\n+                    total_bytes_sent += msg.len();\n+                    // check if the client has received enough\n+                    let res = server_in.recvfrom(buf);\n+                    assert!(res.is_ok());\n+                    let (nread, src) = res.unwrap();\n+                    assert_eq!(nread, 1);\n+                    assert_eq!(src, client_out_addr);\n+                }\n+                assert!(total_bytes_sent >= MAX);\n+            }\n \n-            do server.recv_start(alloc) |mut server, nread, buf, src, flags, status| {\n-                server.recv_stop();\n-                uvdebug!(\"i'm reading!\");\n-                assert!(status.is_none());\n-                assert_eq!(flags, 0);\n-                assert_eq!(src, client_addr);\n-\n-                let buf = vec_from_uv_buf(buf);\n-                let mut count = 0;\n-                uvdebug!(\"got {} bytes\", nread);\n-\n-                let buf = buf.unwrap();\n-                for &byte in buf.slice(0, nread as uint).iter() {\n-                    assert!(byte == count as u8);\n-                    uvdebug!(\"{}\", byte as uint);\n-                    count += 1;\n+            do spawntask {\n+                let l = &mut Loop::wrap(handle);\n+                let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n+                let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n+                let (port, chan) = second.take();\n+                port.recv();\n+                chan.send(());\n+                let mut total_bytes_recv = 0;\n+                let mut buf = [0, .. 2048];\n+                while total_bytes_recv < MAX {\n+                    // ask for more\n+                    assert!(client_out.sendto([1], server_in_addr).is_ok());\n+                    // wait for data\n+                    let res = client_in.recvfrom(buf);\n+                    assert!(res.is_ok());\n+                    let (nread, src) = res.unwrap();\n+                    assert_eq!(src, server_out_addr);\n+                    total_bytes_recv += nread;\n+                    for i in range(0u, nread) {\n+                        assert_eq!(buf[i], 1);\n+                    }\n                 }\n-                assert_eq!(count, MAX);\n+                // tell the server we're done\n+                assert!(client_out.sendto([0], server_in_addr).is_ok());\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_and_block() {\n+        do run_uv_loop |l| {\n+            let addr = next_test_ip4();\n+            let (port, chan) = oneshot();\n+            let port = Cell::new(port);\n+            let chan = Cell::new(chan);\n+\n+            let handle = l.handle;\n+            do spawntask {\n+                let l = &mut Loop::wrap(handle);\n+                let listener = TcpListener::bind(l, addr).unwrap();\n+                let mut acceptor = listener.listen().unwrap();\n+                let (port2, chan2) = stream();\n+                chan.take().send(port2);\n+                let mut stream = acceptor.accept().unwrap();\n+                let mut buf = [0, .. 2048];\n+\n+                let expected = 32;\n+                let mut current = 0;\n+                let mut reads = 0;\n+\n+                while current < expected {\n+                    let nread = stream.read(buf).unwrap();\n+                    for i in range(0u, nread) {\n+                        let val = buf[i] as uint;\n+                        assert_eq!(val, current % 8);\n+                        current += 1;\n+                    }\n+                    reads += 1;\n+\n+                    chan2.send(());\n+                }\n+\n+                // Make sure we had multiple reads\n+                assert!(reads > 1);\n+            }\n+\n+            do spawntask {\n+                let l = &mut Loop::wrap(handle);\n+                let port2 = port.take().recv();\n+                let mut stream = TcpWatcher::connect(l, addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                port2.recv();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                port2.recv();\n+            }\n+        }\n+    }\n \n-                server.close(||{});\n+    #[test]\n+    fn test_simple_tcp_server_and_client_on_diff_threads() {\n+        let addr = next_test_ip4();\n+\n+        do task::spawn_sched(task::SingleThreaded) {\n+            do run_uv_loop |l| {\n+                let listener = TcpListener::bind(l, addr).unwrap();\n+                let mut acceptor = listener.listen().unwrap();\n+                let mut stream = acceptor.accept().unwrap();\n+                let mut buf = [0, .. 2048];\n+                let nread = stream.read(buf).unwrap();\n+                assert_eq!(nread, 8);\n+                for i in range(0u, nread) {\n+                    assert_eq!(buf[i], i as u8);\n+                }\n             }\n+        }\n \n-            let thread = do Thread::start {\n-                let mut loop_ = Loop::new();\n-                let mut client = UdpWatcher::new(&loop_);\n-                assert!(client.bind(client_addr).is_ok());\n-                let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-                let buf = slice_to_uv_buf(msg);\n-                do client.send(buf, server_addr) |client, status| {\n-                    uvdebug!(\"writing\");\n-                    assert!(status.is_none());\n-                    client.close(||{});\n+        do task::spawn_sched(task::SingleThreaded) {\n+            do run_uv_loop |l| {\n+                let mut stream = TcpWatcher::connect(l, addr);\n+                while stream.is_err() {\n+                    stream = TcpWatcher::connect(l, addr);\n                 }\n+                stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            }\n+        }\n+    }\n \n-                loop_.run();\n-                loop_.close();\n-            };\n+    // On one thread, create a udp socket. Then send that socket to another\n+    // thread and destroy the socket on the remote thread. This should make sure\n+    // that homing kicks in for the socket to go back home to the original\n+    // thread, close itself, and then come back to the last thread.\n+    #[test]\n+    fn test_homing_closes_correctly() {\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        do task::spawn_sched(task::SingleThreaded) {\n+            let chan = Cell::new(chan.take());\n+            do run_uv_loop |l| {\n+                let listener = UdpWatcher::bind(l, next_test_ip4()).unwrap();\n+                chan.take().send(listener);\n+            }\n+        }\n \n-            loop_.run();\n-            loop_.close();\n-            thread.join();\n+        do task::spawn_sched(task::SingleThreaded) {\n+            let port = Cell::new(port.take());\n+            do run_uv_loop |_l| {\n+                port.take().recv();\n+            }\n         }\n     }\n \n+    // This is a bit of a crufty old test, but it has its uses.\n     #[test]\n-    fn udp_recv_ip6() {\n-        do run_in_bare_thread() {\n-            static MAX: int = 10;\n-            let mut loop_ = Loop::new();\n-            let server_addr = next_test_ip6();\n-            let client_addr = next_test_ip6();\n-\n-            let mut server = UdpWatcher::new(&loop_);\n-            assert!(server.bind(server_addr).is_ok());\n-\n-            uvdebug!(\"starting read\");\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0u8))\n+    fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n+        use std::cast;\n+        use std::rt::local::Local;\n+        use std::rt::rtio::{EventLoop, IoFactory};\n+        use std::rt::sched::Scheduler;\n+        use std::rt::sched::{Shutdown, TaskFromFriend};\n+        use std::rt::sleeper_list::SleeperList;\n+        use std::rt::task::Task;\n+        use std::rt::task::UnwindResult;\n+        use std::rt::thread::Thread;\n+        use std::rt::work_queue::WorkQueue;\n+        use std::unstable::run_in_bare_thread;\n+        use uvio::UvEventLoop;\n+\n+        do run_in_bare_thread {\n+            let sleepers = SleeperList::new();\n+            let work_queue1 = WorkQueue::new();\n+            let work_queue2 = WorkQueue::new();\n+            let queues = ~[work_queue1.clone(), work_queue2.clone()];\n+\n+            let loop1 = ~UvEventLoop::new() as ~EventLoop;\n+            let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n+                                             sleepers.clone());\n+            let loop2 = ~UvEventLoop::new() as ~EventLoop;\n+            let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n+                                             sleepers.clone());\n+\n+            let handle1 = Cell::new(sched1.make_handle());\n+            let handle2 = Cell::new(sched2.make_handle());\n+            let tasksFriendHandle = Cell::new(sched2.make_handle());\n+\n+            let on_exit: ~fn(UnwindResult) = |exit_status| {\n+                handle1.take().send(Shutdown);\n+                handle2.take().send(Shutdown);\n+                assert!(exit_status.is_success());\n             };\n \n-            do server.recv_start(alloc) |mut server, nread, buf, src, flags, status| {\n-                server.recv_stop();\n-                uvdebug!(\"i'm reading!\");\n-                assert!(status.is_none());\n-                assert_eq!(flags, 0);\n-                assert_eq!(src, client_addr);\n-\n-                let buf = vec_from_uv_buf(buf);\n-                let mut count = 0;\n-                uvdebug!(\"got {} bytes\", nread);\n-\n-                let buf = buf.unwrap();\n-                for &byte in buf.slice(0, nread as uint).iter() {\n-                    assert!(byte == count as u8);\n-                    uvdebug!(\"{}\", byte as uint);\n-                    count += 1;\n+            unsafe fn local_io() -> &'static mut IoFactory {\n+                do Local::borrow |sched: &mut Scheduler| {\n+                    let mut io = None;\n+                    sched.event_loop.io(|i| io = Some(i));\n+                    cast::transmute(io.unwrap())\n                 }\n-                assert_eq!(count, MAX);\n-\n-                server.close(||{});\n             }\n \n-            let thread = do Thread::start {\n-                let mut loop_ = Loop::new();\n-                let mut client = UdpWatcher::new(&loop_);\n-                assert!(client.bind(client_addr).is_ok());\n-                let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-                let buf = slice_to_uv_buf(msg);\n-                do client.send(buf, server_addr) |client, status| {\n-                    uvdebug!(\"writing\");\n-                    assert!(status.is_none());\n-                    client.close(||{});\n+            let test_function: ~fn() = || {\n+                let io = unsafe { local_io() };\n+                let addr = next_test_ip4();\n+                let maybe_socket = io.udp_bind(addr);\n+                // this socket is bound to this event loop\n+                assert!(maybe_socket.is_ok());\n+\n+                // block self on sched1\n+                do task::unkillable { // FIXME(#8674)\n+                    let scheduler: ~Scheduler = Local::take();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        // unblock task\n+                        do task.wake().map |task| {\n+                            // send self to sched2\n+                            tasksFriendHandle.take().send(TaskFromFriend(task));\n+                        };\n+                        // sched1 should now sleep since it has nothing else to do\n+                    }\n                 }\n+                // sched2 will wake up and get the task as we do nothing else,\n+                // the function ends and the socket goes out of scope sched2\n+                // will start to run the destructor the destructor will first\n+                // block the task, set it's home as sched1, then enqueue it\n+                // sched2 will dequeue the task, see that it has a home, and\n+                // send it to sched1 sched1 will wake up, exec the close\n+                // function on the correct loop, and then we're done\n+            };\n+\n+            let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None,\n+                                                test_function);\n+            main_task.death.on_exit = Some(on_exit);\n+            let main_task = Cell::new(main_task);\n+\n+            let null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool,\n+                                                         None) || {});\n \n-                loop_.run();\n-                loop_.close();\n+            let sched1 = Cell::new(sched1);\n+            let sched2 = Cell::new(sched2);\n+\n+            let thread1 = do Thread::start {\n+                sched1.take().bootstrap(main_task.take());\n+            };\n+            let thread2 = do Thread::start {\n+                sched2.take().bootstrap(null_task.take());\n             };\n \n-            loop_.run();\n-            loop_.close();\n-            thread.join();\n+            thread1.join();\n+            thread2.join();\n         }\n     }\n+\n }"}, {"sha": "bf24ec405c2f907e79ab3f7b280ed1440e38ddaa", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 35, "deletions": 75, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=d08aadcc9aff233165a063df73c6436e0969f79c", "patch": "@@ -123,92 +123,52 @@ impl Drop for TimerWatcher {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use Loop;\n-    use std::unstable::run_in_bare_thread;\n+    use std::rt::rtio::RtioTimer;\n+    use super::super::run_uv_loop;\n \n     #[test]\n-    fn smoke_test() {\n-        do run_in_bare_thread {\n-            let mut count = 0;\n-            let count_ptr: *mut int = &mut count;\n-            let mut loop_ = Loop::new();\n-            let mut timer = TimerWatcher::new(&mut loop_);\n-            do timer.start(10, 0) |timer, status| {\n-                assert!(status.is_none());\n-                unsafe { *count_ptr += 1 };\n-                timer.close(||());\n-            }\n-            loop_.run();\n-            loop_.close();\n-            assert!(count == 1);\n+    fn oneshot() {\n+        do run_uv_loop |l| {\n+            let mut timer = TimerWatcher::new(l);\n+            let port = timer.oneshot(1);\n+            port.recv();\n+            let port = timer.oneshot(1);\n+            port.recv();\n         }\n     }\n \n     #[test]\n-    fn start_twice() {\n-        do run_in_bare_thread {\n-            let mut count = 0;\n-            let count_ptr: *mut int = &mut count;\n-            let mut loop_ = Loop::new();\n-            let mut timer = TimerWatcher::new(&mut loop_);\n-            do timer.start(10, 0) |timer, status| {\n-                let mut timer = timer;\n-                assert!(status.is_none());\n-                unsafe { *count_ptr += 1 };\n-                do timer.start(10, 0) |timer, status| {\n-                    assert!(status.is_none());\n-                    unsafe { *count_ptr += 1 };\n-                    timer.close(||());\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n-            assert!(count == 2);\n+    fn override() {\n+        do run_uv_loop |l| {\n+            let mut timer = TimerWatcher::new(l);\n+            let oport = timer.oneshot(1);\n+            let pport = timer.period(1);\n+            timer.sleep(1);\n+            assert_eq!(oport.try_recv(), None);\n+            assert_eq!(pport.try_recv(), None);\n+            timer.oneshot(1).recv();\n         }\n     }\n \n     #[test]\n-    fn repeat_stop() {\n-        do run_in_bare_thread {\n-            let mut count = 0;\n-            let count_ptr: *mut int = &mut count;\n-            let mut loop_ = Loop::new();\n-            let mut timer = TimerWatcher::new(&mut loop_);\n-            do timer.start(1, 2) |timer, status| {\n-                assert!(status.is_none());\n-                unsafe {\n-                    *count_ptr += 1;\n-\n-                    if *count_ptr == 10 {\n-\n-                        // Stop the timer and do something else\n-                        let mut timer = timer;\n-                        timer.stop();\n-                        // Freeze timer so it can be captured\n-                        let timer = timer;\n-\n-                        let mut loop_ = timer.event_loop();\n-                        let mut timer2 = TimerWatcher::new(&mut loop_);\n-                        do timer2.start(10, 0) |timer2, _| {\n-\n-                            *count_ptr += 1;\n-\n-                            timer2.close(||());\n-\n-                            // Restart the original timer\n-                            let mut timer = timer;\n-                            do timer.start(1, 0) |timer, _| {\n-                                *count_ptr += 1;\n-                                timer.close(||());\n-                            }\n-                        }\n-                    }\n-                };\n-            }\n-            loop_.run();\n-            loop_.close();\n-            assert!(count == 12);\n+    fn period() {\n+        do run_uv_loop |l| {\n+            let mut timer = TimerWatcher::new(l);\n+            let port = timer.period(1);\n+            port.recv();\n+            port.recv();\n+            let port = timer.period(1);\n+            port.recv();\n+            port.recv();\n         }\n     }\n \n+    #[test]\n+    fn sleep() {\n+        do run_uv_loop |l| {\n+            let mut timer = TimerWatcher::new(l);\n+            timer.sleep(1);\n+            timer.sleep(1);\n+        }\n+    }\n }"}, {"sha": "e9d8aab2e8b661eabae40eaf0802b3100eecaf5d", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 0, "deletions": 630, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08aadcc9aff233165a063df73c6436e0969f79c/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=d08aadcc9aff233165a063df73c6436e0969f79c", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n use std::c_str::CString;\n-use std::cast::transmute;\n-use std::cast;\n use std::comm::{SharedChan, GenericChan};\n use std::libc::c_int;\n use std::libc;\n@@ -23,7 +21,6 @@ use std::rt::local::Local;\n use std::rt::rtio::*;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::task::Task;\n-use std::str;\n use std::libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n                 S_IRUSR, S_IWUSR};\n use std::rt::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n@@ -33,10 +30,6 @@ use std::task;\n use ai = std::rt::io::net::addrinfo;\n \n #[cfg(test)] use std::unstable::run_in_bare_thread;\n-#[cfg(test)] use std::rt::test::{spawntask,\n-                                 next_test_ip4,\n-                                 run_in_mt_newsched_task};\n-#[cfg(test)] use std::rt::comm::oneshot;\n \n use super::*;\n use addrinfo::GetAddrInfoRequest;\n@@ -370,626 +363,3 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n }\n-\n-// this function is full of lies\n-unsafe fn local_io() -> &'static mut IoFactory {\n-    do Local::borrow |sched: &mut Scheduler| {\n-        let mut io = None;\n-        sched.event_loop.io(|i| io = Some(i));\n-        cast::transmute(io.unwrap())\n-    }\n-}\n-\n-#[test]\n-fn test_simple_io_no_connect() {\n-    do run_in_mt_newsched_task {\n-        unsafe {\n-            let io = local_io();\n-            let addr = next_test_ip4();\n-            let maybe_chan = io.tcp_connect(addr);\n-            assert!(maybe_chan.is_err());\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_simple_udp_io_bind_only() {\n-    do run_in_mt_newsched_task {\n-        unsafe {\n-            let io = local_io();\n-            let addr = next_test_ip4();\n-            let maybe_socket = io.udp_bind(addr);\n-            assert!(maybe_socket.is_ok());\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n-    use std::rt::sleeper_list::SleeperList;\n-    use std::rt::work_queue::WorkQueue;\n-    use std::rt::thread::Thread;\n-    use std::rt::task::Task;\n-    use std::rt::sched::{Shutdown, TaskFromFriend};\n-    use std::rt::task::UnwindResult;\n-    do run_in_bare_thread {\n-        let sleepers = SleeperList::new();\n-        let work_queue1 = WorkQueue::new();\n-        let work_queue2 = WorkQueue::new();\n-        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n-\n-        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n-        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n-                                         sleepers.clone());\n-        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n-        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n-                                         sleepers.clone());\n-\n-        let handle1 = Cell::new(sched1.make_handle());\n-        let handle2 = Cell::new(sched2.make_handle());\n-        let tasksFriendHandle = Cell::new(sched2.make_handle());\n-\n-        let on_exit: ~fn(UnwindResult) = |exit_status| {\n-            handle1.take().send(Shutdown);\n-            handle2.take().send(Shutdown);\n-            assert!(exit_status.is_success());\n-        };\n-\n-        let test_function: ~fn() = || {\n-            let io = unsafe { local_io() };\n-            let addr = next_test_ip4();\n-            let maybe_socket = io.udp_bind(addr);\n-            // this socket is bound to this event loop\n-            assert!(maybe_socket.is_ok());\n-\n-            // block self on sched1\n-            do task::unkillable { // FIXME(#8674)\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    // unblock task\n-                    do task.wake().map |task| {\n-                      // send self to sched2\n-                      tasksFriendHandle.take().send(TaskFromFriend(task));\n-                    };\n-                    // sched1 should now sleep since it has nothing else to do\n-                }\n-            }\n-            // sched2 will wake up and get the task\n-            // as we do nothing else, the function ends and the socket goes out of scope\n-            // sched2 will start to run the destructor\n-            // the destructor will first block the task, set it's home as sched1, then enqueue it\n-            // sched2 will dequeue the task, see that it has a home, and send it to sched1\n-            // sched1 will wake up, exec the close function on the correct loop, and then we're done\n-        };\n-\n-        let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None, test_function);\n-        main_task.death.on_exit = Some(on_exit);\n-        let main_task = Cell::new(main_task);\n-\n-        let null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool, None) || {});\n-\n-        let sched1 = Cell::new(sched1);\n-        let sched2 = Cell::new(sched2);\n-\n-        let thread1 = do Thread::start {\n-            sched1.take().bootstrap(main_task.take());\n-        };\n-        let thread2 = do Thread::start {\n-            sched2.take().bootstrap(null_task.take());\n-        };\n-\n-        thread1.join();\n-        thread2.join();\n-    }\n-}\n-\n-#[test]\n-fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n-    use std::rt::sleeper_list::SleeperList;\n-    use std::rt::work_queue::WorkQueue;\n-    use std::rt::thread::Thread;\n-    use std::rt::task::Task;\n-    use std::rt::comm::oneshot;\n-    use std::rt::sched::Shutdown;\n-    use std::rt::task::UnwindResult;\n-    do run_in_bare_thread {\n-        let sleepers = SleeperList::new();\n-        let work_queue1 = WorkQueue::new();\n-        let work_queue2 = WorkQueue::new();\n-        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n-\n-        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n-        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n-                                         sleepers.clone());\n-        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n-        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n-                                         sleepers.clone());\n-\n-        let handle1 = Cell::new(sched1.make_handle());\n-        let handle2 = Cell::new(sched2.make_handle());\n-\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        let body1: ~fn() = || {\n-            let io = unsafe { local_io() };\n-            let addr = next_test_ip4();\n-            let socket = io.udp_bind(addr);\n-            assert!(socket.is_ok());\n-            chan.take().send(socket);\n-        };\n-\n-        let body2: ~fn() = || {\n-            let socket = port.take().recv();\n-            assert!(socket.is_ok());\n-            /* The socket goes out of scope and the destructor is called.\n-             * The destructor:\n-             *  - sends itself back to sched1\n-             *  - frees the socket\n-             *  - resets the home of the task to whatever it was previously\n-             */\n-        };\n-\n-        let on_exit: ~fn(UnwindResult) = |exit| {\n-            handle1.take().send(Shutdown);\n-            handle2.take().send(Shutdown);\n-            assert!(exit.is_success());\n-        };\n-\n-        let task1 = Cell::new(~Task::new_root(&mut sched1.stack_pool, None, body1));\n-\n-        let mut task2 = ~Task::new_root(&mut sched2.stack_pool, None, body2);\n-        task2.death.on_exit = Some(on_exit);\n-        let task2 = Cell::new(task2);\n-\n-        let sched1 = Cell::new(sched1);\n-        let sched2 = Cell::new(sched2);\n-\n-        let thread1 = do Thread::start {\n-            sched1.take().bootstrap(task1.take());\n-        };\n-        let thread2 = do Thread::start {\n-            sched2.take().bootstrap(task2.take());\n-        };\n-\n-        thread1.join();\n-        thread2.join();\n-    }\n-}\n-\n-#[test]\n-fn test_simple_tcp_server_and_client() {\n-    do run_in_mt_newsched_task {\n-        let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        // Start the server first so it's listening when we connect\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let listener = io.tcp_bind(addr).unwrap();\n-                let mut acceptor = listener.listen().unwrap();\n-                chan.take().send(());\n-                let mut stream = acceptor.accept().unwrap();\n-                let mut buf = [0, .. 2048];\n-                let nread = stream.read(buf).unwrap();\n-                assert_eq!(nread, 8);\n-                for i in range(0u, nread) {\n-                    uvdebug!(\"{}\", buf[i]);\n-                    assert_eq!(buf[i], i as u8);\n-                }\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                port.take().recv();\n-                let io = local_io();\n-                let mut stream = io.tcp_connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_simple_tcp_server_and_client_on_diff_threads() {\n-    use std::rt::sleeper_list::SleeperList;\n-    use std::rt::work_queue::WorkQueue;\n-    use std::rt::thread::Thread;\n-    use std::rt::task::Task;\n-    use std::rt::sched::{Shutdown};\n-    use std::rt::task::UnwindResult;\n-    do run_in_bare_thread {\n-        let sleepers = SleeperList::new();\n-\n-        let server_addr = next_test_ip4();\n-        let client_addr = server_addr.clone();\n-\n-        let server_work_queue = WorkQueue::new();\n-        let client_work_queue = WorkQueue::new();\n-        let queues = ~[server_work_queue.clone(), client_work_queue.clone()];\n-\n-        let sloop = ~UvEventLoop::new() as ~EventLoop;\n-        let mut server_sched = ~Scheduler::new(sloop, server_work_queue,\n-                                               queues.clone(), sleepers.clone());\n-        let cloop = ~UvEventLoop::new() as ~EventLoop;\n-        let mut client_sched = ~Scheduler::new(cloop, client_work_queue,\n-                                               queues.clone(), sleepers.clone());\n-\n-        let server_handle = Cell::new(server_sched.make_handle());\n-        let client_handle = Cell::new(client_sched.make_handle());\n-\n-        let server_on_exit: ~fn(UnwindResult) = |exit_status| {\n-            server_handle.take().send(Shutdown);\n-            assert!(exit_status.is_success());\n-        };\n-\n-        let client_on_exit: ~fn(UnwindResult) = |exit_status| {\n-            client_handle.take().send(Shutdown);\n-            assert!(exit_status.is_success());\n-        };\n-\n-        let server_fn: ~fn() = || {\n-            let io = unsafe { local_io() };\n-            let listener = io.tcp_bind(server_addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n-            let mut stream = acceptor.accept().unwrap();\n-            let mut buf = [0, .. 2048];\n-            let nread = stream.read(buf).unwrap();\n-            assert_eq!(nread, 8);\n-            for i in range(0u, nread) {\n-                assert_eq!(buf[i], i as u8);\n-            }\n-        };\n-\n-        let client_fn: ~fn() = || {\n-            let io = unsafe { local_io() };\n-            let mut stream = io.tcp_connect(client_addr);\n-            while stream.is_err() {\n-                stream = io.tcp_connect(client_addr);\n-            }\n-            stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n-        };\n-\n-        let mut server_task = ~Task::new_root(&mut server_sched.stack_pool, None, server_fn);\n-        server_task.death.on_exit = Some(server_on_exit);\n-        let server_task = Cell::new(server_task);\n-\n-        let mut client_task = ~Task::new_root(&mut client_sched.stack_pool, None, client_fn);\n-        client_task.death.on_exit = Some(client_on_exit);\n-        let client_task = Cell::new(client_task);\n-\n-        let server_sched = Cell::new(server_sched);\n-        let client_sched = Cell::new(client_sched);\n-\n-        let server_thread = do Thread::start {\n-            server_sched.take().bootstrap(server_task.take());\n-        };\n-        let client_thread = do Thread::start {\n-            client_sched.take().bootstrap(client_task.take());\n-        };\n-\n-        server_thread.join();\n-        client_thread.join();\n-    }\n-}\n-\n-#[test]\n-fn test_simple_udp_server_and_client() {\n-    do run_in_mt_newsched_task {\n-        let server_addr = next_test_ip4();\n-        let client_addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut server_socket = io.udp_bind(server_addr).unwrap();\n-                chan.take().send(());\n-                let mut buf = [0, .. 2048];\n-                let (nread,src) = server_socket.recvfrom(buf).unwrap();\n-                assert_eq!(nread, 8);\n-                for i in range(0u, nread) {\n-                    uvdebug!(\"{}\", buf[i]);\n-                    assert_eq!(buf[i], i as u8);\n-                }\n-                assert_eq!(src, client_addr);\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut client_socket = io.udp_bind(client_addr).unwrap();\n-                port.take().recv();\n-                client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n-            }\n-        }\n-    }\n-}\n-\n-#[test] #[ignore(reason = \"busted\")]\n-fn test_read_and_block() {\n-    do run_in_mt_newsched_task {\n-        let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        do spawntask {\n-            let io = unsafe { local_io() };\n-            let listener = io.tcp_bind(addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n-            chan.take().send(());\n-            let mut stream = acceptor.accept().unwrap();\n-            let mut buf = [0, .. 2048];\n-\n-            let expected = 32;\n-            let mut current = 0;\n-            let mut reads = 0;\n-\n-            while current < expected {\n-                let nread = stream.read(buf).unwrap();\n-                for i in range(0u, nread) {\n-                    let val = buf[i] as uint;\n-                    assert_eq!(val, current % 8);\n-                    current += 1;\n-                }\n-                reads += 1;\n-\n-                do task::unkillable { // FIXME(#8674)\n-                    let scheduler: ~Scheduler = Local::take();\n-                    // Yield to the other task in hopes that it\n-                    // will trigger a read callback while we are\n-                    // not ready for it\n-                    do scheduler.deschedule_running_task_and_then |sched, task| {\n-                        let task = Cell::new(task);\n-                        sched.enqueue_blocked_task(task.take());\n-                    }\n-                }\n-            }\n-\n-            // Make sure we had multiple reads\n-            assert!(reads > 1);\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                port.take().recv();\n-                let io = local_io();\n-                let mut stream = io.tcp_connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            }\n-        }\n-\n-    }\n-}\n-\n-#[test]\n-fn test_read_read_read() {\n-    do run_in_mt_newsched_task {\n-        let addr = next_test_ip4();\n-        static MAX: uint = 500000;\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let listener = io.tcp_bind(addr).unwrap();\n-                let mut acceptor = listener.listen().unwrap();\n-                chan.take().send(());\n-                let mut stream = acceptor.accept().unwrap();\n-                let buf = [1, .. 2048];\n-                let mut total_bytes_written = 0;\n-                while total_bytes_written < MAX {\n-                    stream.write(buf);\n-                    total_bytes_written += buf.len();\n-                }\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                port.take().recv();\n-                let io = local_io();\n-                let mut stream = io.tcp_connect(addr).unwrap();\n-                let mut buf = [0, .. 2048];\n-                let mut total_bytes_read = 0;\n-                while total_bytes_read < MAX {\n-                    let nread = stream.read(buf).unwrap();\n-                    uvdebug!(\"read {} bytes\", nread);\n-                    total_bytes_read += nread;\n-                    for i in range(0u, nread) {\n-                        assert_eq!(buf[i], 1);\n-                    }\n-                }\n-                uvdebug!(\"read {} bytes total\", total_bytes_read);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))] // FIXME(#10102) the server never sees the second send\n-fn test_udp_twice() {\n-    do run_in_mt_newsched_task {\n-        let server_addr = next_test_ip4();\n-        let client_addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut client = io.udp_bind(client_addr).unwrap();\n-                port.take().recv();\n-                assert!(client.sendto([1], server_addr).is_ok());\n-                assert!(client.sendto([2], server_addr).is_ok());\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut server = io.udp_bind(server_addr).unwrap();\n-                chan.take().send(());\n-                let mut buf1 = [0];\n-                let mut buf2 = [0];\n-                let (nread1, src1) = server.recvfrom(buf1).unwrap();\n-                let (nread2, src2) = server.recvfrom(buf2).unwrap();\n-                assert_eq!(nread1, 1);\n-                assert_eq!(nread2, 1);\n-                assert_eq!(src1, client_addr);\n-                assert_eq!(src2, client_addr);\n-                assert_eq!(buf1[0], 1);\n-                assert_eq!(buf2[0], 2);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_udp_many_read() {\n-    do run_in_mt_newsched_task {\n-        let server_out_addr = next_test_ip4();\n-        let server_in_addr = next_test_ip4();\n-        let client_out_addr = next_test_ip4();\n-        let client_in_addr = next_test_ip4();\n-        static MAX: uint = 500_000;\n-\n-        let (p1, c1) = oneshot();\n-        let (p2, c2) = oneshot();\n-\n-        let first = Cell::new((p1, c2));\n-        let second = Cell::new((p2, c1));\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut server_out = io.udp_bind(server_out_addr).unwrap();\n-                let mut server_in = io.udp_bind(server_in_addr).unwrap();\n-                let (port, chan) = first.take();\n-                chan.send(());\n-                port.recv();\n-                let msg = [1, .. 2048];\n-                let mut total_bytes_sent = 0;\n-                let mut buf = [1];\n-                while buf[0] == 1 {\n-                    // send more data\n-                    assert!(server_out.sendto(msg, client_in_addr).is_ok());\n-                    total_bytes_sent += msg.len();\n-                    // check if the client has received enough\n-                    let res = server_in.recvfrom(buf);\n-                    assert!(res.is_ok());\n-                    let (nread, src) = res.unwrap();\n-                    assert_eq!(nread, 1);\n-                    assert_eq!(src, client_out_addr);\n-                }\n-                assert!(total_bytes_sent >= MAX);\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut client_out = io.udp_bind(client_out_addr).unwrap();\n-                let mut client_in = io.udp_bind(client_in_addr).unwrap();\n-                let (port, chan) = second.take();\n-                port.recv();\n-                chan.send(());\n-                let mut total_bytes_recv = 0;\n-                let mut buf = [0, .. 2048];\n-                while total_bytes_recv < MAX {\n-                    // ask for more\n-                    assert!(client_out.sendto([1], server_in_addr).is_ok());\n-                    // wait for data\n-                    let res = client_in.recvfrom(buf);\n-                    assert!(res.is_ok());\n-                    let (nread, src) = res.unwrap();\n-                    assert_eq!(src, server_out_addr);\n-                    total_bytes_recv += nread;\n-                    for i in range(0u, nread) {\n-                        assert_eq!(buf[i], 1);\n-                    }\n-                }\n-                // tell the server we're done\n-                assert!(client_out.sendto([0], server_in_addr).is_ok());\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_timer_sleep_simple() {\n-    do run_in_mt_newsched_task {\n-        unsafe {\n-            let io = local_io();\n-            let timer = io.timer_init();\n-            do timer.map |mut t| { t.sleep(1) };\n-        }\n-    }\n-}\n-\n-fn file_test_uvio_full_simple_impl() {\n-    use std::rt::io::{Open, ReadWrite, Read};\n-    unsafe {\n-        let io = local_io();\n-        let write_val = \"hello uvio!\";\n-        let path = \"./tmp/file_test_uvio_full.txt\";\n-        {\n-            let create_fm = Open;\n-            let create_fa = ReadWrite;\n-            let mut fd = io.fs_open(&path.to_c_str(), create_fm, create_fa).unwrap();\n-            let write_buf = write_val.as_bytes();\n-            fd.write(write_buf);\n-        }\n-        {\n-            let ro_fm = Open;\n-            let ro_fa = Read;\n-            let mut fd = io.fs_open(&path.to_c_str(), ro_fm, ro_fa).unwrap();\n-            let mut read_vec = [0, .. 1028];\n-            let nread = fd.read(read_vec).unwrap();\n-            let read_val = str::from_utf8(read_vec.slice(0, nread as uint));\n-            assert!(read_val == write_val.to_owned());\n-        }\n-        io.fs_unlink(&path.to_c_str());\n-    }\n-}\n-\n-#[test]\n-fn file_test_uvio_full_simple() {\n-    do run_in_mt_newsched_task {\n-        file_test_uvio_full_simple_impl();\n-    }\n-}\n-\n-fn uvio_naive_print(input: &str) {\n-    unsafe {\n-        use std::libc::{STDOUT_FILENO};\n-        let io = local_io();\n-        {\n-            let mut fd = io.fs_from_raw_fd(STDOUT_FILENO, DontClose);\n-            let write_buf = input.as_bytes();\n-            fd.write(write_buf);\n-        }\n-    }\n-}\n-\n-#[test]\n-fn file_test_uvio_write_to_stdout() {\n-    do run_in_mt_newsched_task {\n-        uvio_naive_print(\"jubilation\\n\");\n-    }\n-}"}]}