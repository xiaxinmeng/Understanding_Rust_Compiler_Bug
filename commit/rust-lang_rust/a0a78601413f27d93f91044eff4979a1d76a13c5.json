{"sha": "a0a78601413f27d93f91044eff4979a1d76a13c5", "node_id": "C_kwDOAAsO6NoAKGEwYTc4NjAxNDEzZjI3ZDkzZjkxMDQ0ZWZmNDk3OWExZDc2YTEzYzU", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-11T06:55:41Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-11T09:17:16Z"}, "message": "Refactor", "tree": {"sha": "578a6655be8fc30e2f71466b705ef8c3fd8bb0eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/578a6655be8fc30e2f71466b705ef8c3fd8bb0eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0a78601413f27d93f91044eff4979a1d76a13c5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmRcspwACgkQ4laYqTBY\nYXF+2RAArvr/QWNwMZjKi3m6DqJO2WA9PftjKxf9udB16QCZE5P90qcTTr9QEKav\nr6cq/aWozfX23p7pAJNTQYubdVu5x3j8v53YdzSspbA0k/RS86a8qROAFl0WMerI\nIdZ12TAY6TxZ1mEljqtOBKjgcr4dhBrZAc3o9OZ2oLcH3BBJRbQOXKCrlZcgeVoo\nyNFNj3H2CqtrQv4o6Gcmypzi8vun1TZn53bhJ7u0MHf376V6KOmBZ9EmI4g3S1MR\n3CWcZCTLgtVG2itjqMdwtIMfzhub5BiHGH+7Ui6xQ2OUvwzmTqBnsjGLzSlrDVL0\newqobm0+572/U6Ru6OYaE3xDwKcGI9DBeF7kYP2iuPbtVOJsxYturRmPdQTcsRyL\n2TeB9wZZSoMua32LFy3/ztuFi5MxomUbj2NAJrJemnPueQTovmVzgVTMZRZnyUSm\nphd+Nq6a8W+axtnocJDFDkPd1YoUcRRKVEfPAGlSKWvZsfYPCY+i1uUcr2RBi21z\nn5vC6s0kL7Twy/8BHrDHkZywt/lc2VTZn4kxuGGR740XE1u+lCRj6Cp2UxRZqbLB\n/H9fSZ4XGQnOrwEhUlSD/RUbanLSypHPkhATPMzTeYgH85lnQLSU7E3Vux2ZbitX\nYPoHSim6neeDknEkYs+wbCeRZWSAaSurT5N6FdawoYtTDRZXmPg=\n=thbT\n-----END PGP SIGNATURE-----", "payload": "tree 578a6655be8fc30e2f71466b705ef8c3fd8bb0eb\nparent a4966c92829f945d3846eb0ca0e240ac7f7c8c60\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1683788141 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1683796636 +0900\n\nRefactor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0a78601413f27d93f91044eff4979a1d76a13c5", "html_url": "https://github.com/rust-lang/rust/commit/a0a78601413f27d93f91044eff4979a1d76a13c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0a78601413f27d93f91044eff4979a1d76a13c5/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4966c92829f945d3846eb0ca0e240ac7f7c8c60", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4966c92829f945d3846eb0ca0e240ac7f7c8c60", "html_url": "https://github.com/rust-lang/rust/commit/a4966c92829f945d3846eb0ca0e240ac7f7c8c60"}], "stats": {"total": 131, "additions": 67, "deletions": 64}, "files": [{"sha": "2c8205d14b027f711da8a403cc05c51538197319", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 65, "deletions": 61, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a0a78601413f27d93f91044eff4979a1d76a13c5/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a78601413f27d93f91044eff4979a1d76a13c5/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=a0a78601413f27d93f91044eff4979a1d76a13c5", "patch": "@@ -289,80 +289,84 @@ impl DefCollector<'_> {\n         let module_id = self.def_map.root;\n \n         let attrs = item_tree.top_level_attrs(self.db, self.def_map.krate);\n-        if attrs.cfg().map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false)) {\n-            self.inject_prelude(&attrs);\n-\n-            // Process other crate-level attributes.\n-            for attr in &*attrs {\n-                let attr_name = match attr.path.as_ident() {\n-                    Some(name) => name,\n-                    None => continue,\n-                };\n+        if let Some(cfg) = attrs.cfg() {\n+            if self.cfg_options.check(&cfg) == Some(false) {\n+                return;\n+            }\n+        }\n \n-                if *attr_name == hir_expand::name![recursion_limit] {\n-                    if let Some(limit) = attr.string_value() {\n-                        if let Ok(limit) = limit.parse() {\n-                            self.def_map.recursion_limit = Some(limit);\n-                        }\n-                    }\n-                    continue;\n-                }\n+        self.inject_prelude(&attrs);\n \n-                if *attr_name == hir_expand::name![crate_type] {\n-                    if let Some(\"proc-macro\") = attr.string_value().map(SmolStr::as_str) {\n-                        self.is_proc_macro = true;\n-                    }\n-                    continue;\n-                }\n+        // Process other crate-level attributes.\n+        for attr in &*attrs {\n+            let attr_name = match attr.path.as_ident() {\n+                Some(name) => name,\n+                None => continue,\n+            };\n \n-                if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n-                    self.def_map.rustc_coherence_is_core = true;\n-                    continue;\n+            if *attr_name == hir_expand::name![recursion_limit] {\n+                if let Some(limit) = attr.string_value() {\n+                    if let Ok(limit) = limit.parse() {\n+                        self.def_map.recursion_limit = Some(limit);\n+                    }\n                 }\n+                continue;\n+            }\n \n-                if *attr_name == hir_expand::name![feature] {\n-                    let hygiene = &Hygiene::new_unhygienic();\n-                    let features = attr\n-                        .parse_path_comma_token_tree(self.db.upcast(), hygiene)\n-                        .into_iter()\n-                        .flatten()\n-                        .filter_map(|feat| match feat.segments() {\n-                            [name] => Some(name.to_smol_str()),\n-                            _ => None,\n-                        });\n-                    self.def_map.unstable_features.extend(features);\n+            if *attr_name == hir_expand::name![crate_type] {\n+                if let Some(\"proc-macro\") = attr.string_value().map(SmolStr::as_str) {\n+                    self.is_proc_macro = true;\n                 }\n+                continue;\n+            }\n \n-                let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n-                    || *attr_name == hir_expand::name![register_tool];\n-                if !attr_is_register_like {\n-                    continue;\n-                }\n+            if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n+                self.def_map.rustc_coherence_is_core = true;\n+                continue;\n+            }\n \n-                let registered_name = match attr.single_ident_value() {\n-                    Some(ident) => ident.as_name(),\n-                    _ => continue,\n-                };\n+            if *attr_name == hir_expand::name![feature] {\n+                let hygiene = &Hygiene::new_unhygienic();\n+                let features = attr\n+                    .parse_path_comma_token_tree(self.db.upcast(), hygiene)\n+                    .into_iter()\n+                    .flatten()\n+                    .filter_map(|feat| match feat.segments() {\n+                        [name] => Some(name.to_smol_str()),\n+                        _ => None,\n+                    });\n+                self.def_map.unstable_features.extend(features);\n+            }\n \n-                if *attr_name == hir_expand::name![register_attr] {\n-                    self.def_map.registered_attrs.push(registered_name.to_smol_str());\n-                    cov_mark::hit!(register_attr);\n-                } else {\n-                    self.def_map.registered_tools.push(registered_name.to_smol_str());\n-                    cov_mark::hit!(register_tool);\n-                }\n+            let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n+                || *attr_name == hir_expand::name![register_tool];\n+            if !attr_is_register_like {\n+                continue;\n             }\n \n-            ModCollector {\n-                def_collector: self,\n-                macro_depth: 0,\n-                module_id,\n-                tree_id: TreeId::new(file_id.into(), None),\n-                item_tree: &item_tree,\n-                mod_dir: ModDir::root(),\n+            let registered_name = match attr.single_ident_value() {\n+                Some(ident) => ident.as_name(),\n+                _ => continue,\n+            };\n+\n+            if *attr_name == hir_expand::name![register_attr] {\n+                self.def_map.registered_attrs.push(registered_name.to_smol_str());\n+                cov_mark::hit!(register_attr);\n+            } else {\n+                self.def_map.registered_tools.push(registered_name.to_smol_str());\n+                cov_mark::hit!(register_tool);\n             }\n-            .collect_in_top_module(item_tree.top_level_items());\n         }\n+\n+        ModCollector {\n+            def_collector: self,\n+            macro_depth: 0,\n+            module_id,\n+            tree_id: TreeId::new(file_id.into(), None),\n+            item_tree: &item_tree,\n+            mod_dir: ModDir::root(),\n+        }\n+        .collect_in_top_module(item_tree.top_level_items());\n     }\n \n     fn seed_with_inner(&mut self, tree_id: TreeId) {"}, {"sha": "f747b63d75c2e5288dbf0acbb55bbf1bcb003ded", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0a78601413f27d93f91044eff4979a1d76a13c5/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a78601413f27d93f91044eff4979a1d76a13c5/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=a0a78601413f27d93f91044eff4979a1d76a13c5", "patch": "@@ -4,7 +4,6 @@ use hir_def::{\n     attr::{AttrsWithOwner, Documentation},\n     item_scope::ItemInNs,\n     path::ModPath,\n-    per_ns::PerNs,\n     resolver::HasResolver,\n     AttrDefId, GenericParamId, ModuleDefId,\n };\n@@ -155,14 +154,14 @@ fn resolve_doc_path(\n             .syntax_node()\n             .descendants()\n             .find_map(ast::Path::cast)?;\n-        if ast_path.to_string() != link {\n+        if ast_path.syntax().text() != link {\n             return None;\n         }\n         ModPath::from_src(db.upcast(), ast_path, &Hygiene::new_unhygienic())?\n     };\n \n     let resolved = resolver.resolve_module_path_in_items(db.upcast(), &modpath);\n-    let resolved = if resolved == PerNs::none() {\n+    let resolved = if resolved.is_none() {\n         resolver.resolve_module_path_in_trait_assoc_items(db.upcast(), &modpath)?\n     } else {\n         resolved"}]}