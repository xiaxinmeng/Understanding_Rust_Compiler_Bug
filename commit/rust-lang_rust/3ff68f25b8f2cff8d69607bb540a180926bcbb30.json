{"sha": "3ff68f25b8f2cff8d69607bb540a180926bcbb30", "node_id": "C_kwDOAAsO6NoAKDNmZjY4ZjI1YjhmMmNmZjhkNjk2MDdiYjU0MGExODA5MjZiY2JiMzA", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-01-06T11:30:16Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-01-06T11:30:16Z"}, "message": "Expand attribute macros on impl and trait items", "tree": {"sha": "b48f37f0d689d696004c86dc890adb8fbffe2aec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b48f37f0d689d696004c86dc890adb8fbffe2aec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ff68f25b8f2cff8d69607bb540a180926bcbb30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff68f25b8f2cff8d69607bb540a180926bcbb30", "html_url": "https://github.com/rust-lang/rust/commit/3ff68f25b8f2cff8d69607bb540a180926bcbb30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ff68f25b8f2cff8d69607bb540a180926bcbb30/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eddda6f4c581383a8ead83d4731e888acb1c957", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eddda6f4c581383a8ead83d4731e888acb1c957", "html_url": "https://github.com/rust-lang/rust/commit/3eddda6f4c581383a8ead83d4731e888acb1c957"}], "stats": {"total": 273, "additions": 200, "deletions": 73}, "files": [{"sha": "505b07cc8ac92d01f52f633dee3b306221049c74", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=3ff68f25b8f2cff8d69607bb540a180926bcbb30", "patch": "@@ -12,7 +12,8 @@ use cfg::{CfgExpr, CfgOptions};\n use drop_bomb::DropBomb;\n use either::Either;\n use hir_expand::{\n-    ast_id_map::AstIdMap, hygiene::Hygiene, AstId, ExpandResult, HirFileId, InFile, MacroDefId,\n+    ast_id_map::AstIdMap, hygiene::Hygiene, AstId, ExpandError, ExpandResult, HirFileId, InFile,\n+    MacroCallId, MacroDefId,\n };\n use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n@@ -124,6 +125,23 @@ impl Expander {\n             }\n         };\n \n+        Ok(self.enter_expand_inner(db, call_id, err))\n+    }\n+\n+    pub fn enter_expand_id<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+    ) -> ExpandResult<Option<(Mark, T)>> {\n+        self.enter_expand_inner(db, call_id, None)\n+    }\n+\n+    fn enter_expand_inner<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+        mut err: Option<ExpandError>,\n+    ) -> ExpandResult<Option<(Mark, T)>> {\n         if err.is_none() {\n             err = db.macro_expand_error(call_id);\n         }\n@@ -138,17 +156,17 @@ impl Expander {\n                     tracing::warn!(\"no error despite `parse_or_expand` failing\");\n                 }\n \n-                return Ok(ExpandResult::only_err(err.unwrap_or_else(|| {\n+                return ExpandResult::only_err(err.unwrap_or_else(|| {\n                     mbe::ExpandError::Other(\"failed to parse macro invocation\".into())\n-                })));\n+                }));\n             }\n         };\n \n         let node = match T::cast(raw_node) {\n             Some(it) => it,\n             None => {\n                 // This can happen without being an error, so only forward previous errors.\n-                return Ok(ExpandResult { value: None, err });\n+                return ExpandResult { value: None, err };\n             }\n         };\n \n@@ -164,7 +182,7 @@ impl Expander {\n         self.current_file_id = file_id;\n         self.ast_id_map = db.ast_id_map(file_id);\n \n-        Ok(ExpandResult { value: Some((mark, node)), err })\n+        ExpandResult { value: Some((mark, node)), err }\n     }\n \n     pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {"}, {"sha": "7a9e414ece5140ef64d3e7a2522eba680d8cd5cb", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=3ff68f25b8f2cff8d69607bb540a180926bcbb30", "patch": "@@ -30,6 +30,7 @@ pub trait ChildBySource {\n impl ChildBySource for TraitId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let data = db.trait_data(*self);\n+        // FIXME attribute macros\n         for (_name, item) in data.items.iter() {\n             match *item {\n                 AssocItemId::FunctionId(func) => {\n@@ -61,6 +62,7 @@ impl ChildBySource for TraitId {\n impl ChildBySource for ImplId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let data = db.impl_data(*self);\n+        // FIXME attribute macros\n         for &item in data.items.iter() {\n             match item {\n                 AssocItemId::FunctionId(func) => {"}, {"sha": "753084fb4bc783fa89c9655c60295d4668df386b", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=3ff68f25b8f2cff8d69607bb540a180926bcbb30", "patch": "@@ -2,19 +2,20 @@\n \n use std::sync::Arc;\n \n-use hir_expand::{name::Name, InFile};\n+use hir_expand::{name::Name, AstId, ExpandResult, InFile};\n use syntax::ast;\n \n use crate::{\n     attr::Attrs,\n-    body::Expander,\n+    body::{Expander, Mark},\n     db::DefDatabase,\n     intern::Interned,\n     item_tree::{self, AssocItem, FnFlags, ItemTreeId, ModItem, Param},\n+    nameres::attr_resolution::ResolvedAttr,\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n-    AssocItemId, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId, Intern,\n-    ItemContainerId, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+    AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n+    Intern, ItemContainerId, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -348,14 +349,29 @@ fn collect_items(\n     let item_tree = tree_id.item_tree(db);\n     let crate_graph = db.crate_graph();\n     let cfg_options = &crate_graph[module.krate].cfg_options;\n+    let def_map = module.def_map(db);\n \n     let mut items = Vec::new();\n-    for item in assoc_items {\n+    'items: for item in assoc_items {\n         let attrs = item_tree.attrs(db, module.krate, ModItem::from(item).into());\n         if !attrs.is_cfg_enabled(cfg_options) {\n             continue;\n         }\n \n+        for attr in &*attrs {\n+            let ast_id = AstIdWithPath {\n+                path: (*attr.path).clone(),\n+                ast_id: AstId::new(expander.current_file_id(), item.ast_id(&item_tree).upcast()),\n+            };\n+            if let Ok(ResolvedAttr::Macro(call_id)) =\n+                def_map.resolve_attr_macro(db, module.local_id, ast_id, attr)\n+            {\n+                let res = expander.enter_expand_id(db, call_id);\n+                items.extend(collect_macro_items(db, module, expander, container, limit, res));\n+                continue 'items;\n+            }\n+        }\n+\n         match item {\n             AssocItem::Function(id) => {\n                 let item = &item_tree[id];\n@@ -385,28 +401,34 @@ fn collect_items(\n                 let res = expander.enter_expand(db, call);\n \n                 if let Ok(res) = res {\n-                    if let Some((mark, mac)) = res.value {\n-                        let src: InFile<ast::MacroItems> = expander.to_source(mac);\n-                        let tree_id = item_tree::TreeId::new(src.file_id, None);\n-                        let item_tree = tree_id.item_tree(db);\n-                        let iter =\n-                            item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n-                        items.extend(collect_items(\n-                            db,\n-                            module,\n-                            expander,\n-                            iter,\n-                            tree_id,\n-                            container,\n-                            limit - 1,\n-                        ));\n-\n-                        expander.exit(db, mark);\n-                    }\n+                    items.extend(collect_macro_items(db, module, expander, container, limit, res));\n                 }\n             }\n         }\n     }\n \n     items\n }\n+\n+fn collect_macro_items(\n+    db: &dyn DefDatabase,\n+    module: ModuleId,\n+    expander: &mut Expander,\n+    container: ItemContainerId,\n+    limit: usize,\n+    res: ExpandResult<Option<(Mark, ast::MacroItems)>>,\n+) -> Vec<(Name, AssocItemId)> {\n+    if let Some((mark, mac)) = res.value {\n+        let src: InFile<ast::MacroItems> = expander.to_source(mac);\n+        let tree_id = item_tree::TreeId::new(src.file_id, None);\n+        let item_tree = tree_id.item_tree(db);\n+        let iter = item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n+        let items = collect_items(db, module, expander, iter, tree_id, container, limit - 1);\n+\n+        expander.exit(db, mark);\n+\n+        return items;\n+    }\n+\n+    Vec::new()\n+}"}, {"sha": "c51201f6752209bd1ff887f4edbce0853f9a0c07", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=3ff68f25b8f2cff8d69607bb540a180926bcbb30", "patch": "@@ -920,6 +920,17 @@ impl From<AssocItem> for ModItem {\n     }\n }\n \n+impl AssocItem {\n+    pub fn ast_id(self, tree: &ItemTree) -> FileAstId<ast::AssocItem> {\n+        match self {\n+            AssocItem::Function(id) => tree[id].ast_id.upcast(),\n+            AssocItem::TypeAlias(id) => tree[id].ast_id.upcast(),\n+            AssocItem::Const(id) => tree[id].ast_id.upcast(),\n+            AssocItem::MacroCall(id) => tree[id].ast_id.upcast(),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Eq, PartialEq)]\n pub struct Variant {\n     pub name: Name,"}, {"sha": "f793f0e002307e3dfb7405daa3a5f4e00ed15856", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=3ff68f25b8f2cff8d69607bb540a180926bcbb30", "patch": "@@ -47,6 +47,7 @@\n //! path and, upon success, we run macro expansion and \"collect module\" phase on\n //! the result\n \n+pub mod attr_resolution;\n pub mod diagnostics;\n mod collector;\n mod mod_resolution;\n@@ -64,7 +65,7 @@ use la_arena::Arena;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use stdx::format_to;\n-use syntax::ast;\n+use syntax::{ast, SmolStr};\n \n use crate::{\n     db::DefDatabase,\n@@ -107,6 +108,11 @@ pub struct DefMap {\n     /// (the primary purpose is to resolve derive helpers and fetch a proc-macros name)\n     exported_proc_macros: FxHashMap<MacroDefId, ProcMacroDef>,\n \n+    /// Custom attributes registered with `#![register_attr]`.\n+    registered_attrs: Vec<SmolStr>,\n+    /// Custom tool modules registered with `#![register_tool]`.\n+    registered_tools: Vec<SmolStr>,\n+\n     edition: Edition,\n     diagnostics: Vec<DefDiagnostic>,\n }\n@@ -271,6 +277,8 @@ impl DefMap {\n             prelude: None,\n             root,\n             modules,\n+            registered_attrs: Vec::new(),\n+            registered_tools: Vec::new(),\n             diagnostics: Vec::new(),\n         }\n     }\n@@ -443,6 +451,8 @@ impl DefMap {\n             extern_prelude,\n             diagnostics,\n             modules,\n+            registered_attrs,\n+            registered_tools,\n             block: _,\n             edition: _,\n             krate: _,\n@@ -454,6 +464,8 @@ impl DefMap {\n         exported_proc_macros.shrink_to_fit();\n         diagnostics.shrink_to_fit();\n         modules.shrink_to_fit();\n+        registered_attrs.shrink_to_fit();\n+        registered_tools.shrink_to_fit();\n         for (_, module) in modules.iter_mut() {\n             module.children.shrink_to_fit();\n             module.scope.shrink_to_fit();"}, {"sha": "4a7211b5c9830c3ac41e33b8ee3c5917ab998f1f", "filename": "crates/hir_def/src/nameres/attr_resolution.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=3ff68f25b8f2cff8d69607bb540a180926bcbb30", "patch": "@@ -0,0 +1,90 @@\n+//! Post-nameres attribute resolution.\n+\n+use hir_expand::MacroCallId;\n+use syntax::{ast, SmolStr};\n+\n+use crate::{\n+    attr::Attr,\n+    attr_macro_as_call_id, builtin_attr,\n+    db::DefDatabase,\n+    item_scope::BuiltinShadowMode,\n+    nameres::path_resolution::ResolveMode,\n+    path::{ModPath, PathKind},\n+    AstIdWithPath, LocalModuleId, UnresolvedMacro,\n+};\n+\n+use super::DefMap;\n+\n+pub enum ResolvedAttr {\n+    /// Attribute resolved to an attribute macro.\n+    Macro(MacroCallId),\n+    /// Attribute resolved to something else that does not require expansion.\n+    Other,\n+}\n+\n+impl DefMap {\n+    pub(crate) fn resolve_attr_macro(\n+        &self,\n+        db: &dyn DefDatabase,\n+        original_module: LocalModuleId,\n+        ast_id: AstIdWithPath<ast::Item>,\n+        attr: &Attr,\n+    ) -> Result<ResolvedAttr, UnresolvedMacro> {\n+        // NB: does not currently work for derive helpers as they aren't recorded in the `DefMap`\n+\n+        if self.is_builtin_or_registered_attr(&ast_id.path) {\n+            return Ok(ResolvedAttr::Other);\n+        }\n+\n+        let resolved_res = self.resolve_path_fp_with_macro(\n+            db,\n+            ResolveMode::Other,\n+            original_module,\n+            &ast_id.path,\n+            BuiltinShadowMode::Module,\n+        );\n+        let def = match resolved_res.resolved_def.take_macros() {\n+            Some(def) => {\n+                if def.is_attribute() {\n+                    def\n+                } else {\n+                    return Ok(ResolvedAttr::Other);\n+                }\n+            }\n+            None => return Err(UnresolvedMacro { path: ast_id.path.clone() }),\n+        };\n+\n+        Ok(ResolvedAttr::Macro(attr_macro_as_call_id(&ast_id, attr, db, self.krate, def)))\n+    }\n+\n+    pub(crate) fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {\n+        if path.kind != PathKind::Plain {\n+            return false;\n+        }\n+\n+        let segments = path.segments();\n+\n+        if let Some(name) = segments.first() {\n+            let name = name.to_smol_str();\n+            let pred = |n: &_| *n == name;\n+\n+            let registered = self.registered_tools.iter().map(SmolStr::as_str);\n+            let is_tool = builtin_attr::TOOL_MODULES.iter().copied().chain(registered).any(pred);\n+            // FIXME: tool modules can be shadowed by actual modules\n+            if is_tool {\n+                return true;\n+            }\n+\n+            if segments.len() == 1 {\n+                let registered = self.registered_attrs.iter().map(SmolStr::as_str);\n+                let is_inert = builtin_attr::INERT_ATTRIBUTES\n+                    .iter()\n+                    .map(|it| it.name)\n+                    .chain(registered)\n+                    .any(pred);\n+                return is_inert;\n+            }\n+        }\n+        false\n+    }\n+}"}, {"sha": "e8246d4fb9a975438dfbab184ad010739541c1f8", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 5, "deletions": 44, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=3ff68f25b8f2cff8d69607bb540a180926bcbb30", "patch": "@@ -20,11 +20,11 @@ use itertools::Itertools;\n use la_arena::Idx;\n use limit::Limit;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use syntax::{ast, SmolStr};\n+use syntax::ast;\n \n use crate::{\n     attr::{Attr, AttrId, AttrInput, Attrs},\n-    attr_macro_as_call_id, builtin_attr,\n+    attr_macro_as_call_id,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n     intern::Interned,\n@@ -97,8 +97,6 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n         from_glob_import: Default::default(),\n         skip_attrs: Default::default(),\n         derive_helpers_in_scope: Default::default(),\n-        registered_attrs: Default::default(),\n-        registered_tools: Default::default(),\n     };\n     if tree_id.is_block() {\n         collector.seed_with_inner(tree_id);\n@@ -251,10 +249,6 @@ struct DefCollector<'a> {\n     /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n     /// attributes.\n     derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<Name>>,\n-    /// Custom attributes registered with `#![register_attr]`.\n-    registered_attrs: Vec<SmolStr>,\n-    /// Custom tool modules registered with `#![register_tool]`.\n-    registered_tools: Vec<SmolStr>,\n }\n \n impl DefCollector<'_> {\n@@ -291,10 +285,10 @@ impl DefCollector<'_> {\n                 };\n \n                 if *attr_name == hir_expand::name![register_attr] {\n-                    self.registered_attrs.push(registered_name.to_smol_str());\n+                    self.def_map.registered_attrs.push(registered_name.to_smol_str());\n                     cov_mark::hit!(register_attr);\n                 } else {\n-                    self.registered_tools.push(registered_name.to_smol_str());\n+                    self.def_map.registered_tools.push(registered_name.to_smol_str());\n                     cov_mark::hit!(register_tool);\n                 }\n             }\n@@ -1791,7 +1785,7 @@ impl ModCollector<'_, '_> {\n             });\n \n         for attr in iter {\n-            if self.is_builtin_or_registered_attr(&attr.path) {\n+            if self.def_collector.def_map.is_builtin_or_registered_attr(&attr.path) {\n                 continue;\n             }\n             tracing::debug!(\"non-builtin attribute {}\", attr.path);\n@@ -1819,37 +1813,6 @@ impl ModCollector<'_, '_> {\n         Ok(())\n     }\n \n-    fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {\n-        if path.kind != PathKind::Plain {\n-            return false;\n-        }\n-\n-        let segments = path.segments();\n-\n-        if let Some(name) = segments.first() {\n-            let name = name.to_smol_str();\n-            let pred = |n: &_| *n == name;\n-\n-            let registered = self.def_collector.registered_tools.iter().map(SmolStr::as_str);\n-            let is_tool = builtin_attr::TOOL_MODULES.iter().copied().chain(registered).any(pred);\n-            // FIXME: tool modules can be shadowed by actual modules\n-            if is_tool {\n-                return true;\n-            }\n-\n-            if segments.len() == 1 {\n-                let registered = self.def_collector.registered_attrs.iter().map(SmolStr::as_str);\n-                let is_inert = builtin_attr::INERT_ATTRIBUTES\n-                    .iter()\n-                    .map(|it| it.name)\n-                    .chain(registered)\n-                    .any(pred);\n-                return is_inert;\n-            }\n-        }\n-        false\n-    }\n-\n     /// If `attrs` registers a procedural macro, collects its definition.\n     fn collect_proc_macro_def(&mut self, func_name: &Name, ast_id: AstId<ast::Fn>, attrs: &Attrs) {\n         // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere\n@@ -2101,8 +2064,6 @@ mod tests {\n             from_glob_import: Default::default(),\n             skip_attrs: Default::default(),\n             derive_helpers_in_scope: Default::default(),\n-            registered_attrs: Default::default(),\n-            registered_tools: Default::default(),\n         };\n         collector.seed_with_top_level();\n         collector.collect();"}, {"sha": "749581b1ce9b250d82de9a1c07885a870b15c253", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff68f25b8f2cff8d69607bb540a180926bcbb30/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=3ff68f25b8f2cff8d69607bb540a180926bcbb30", "patch": "@@ -108,6 +108,17 @@ impl HasName for Macro {\n \n impl HasAttrs for Macro {}\n \n+impl From<ast::AssocItem> for ast::Item {\n+    fn from(assoc: ast::AssocItem) -> Self {\n+        match assoc {\n+            ast::AssocItem::Const(it) => ast::Item::Const(it),\n+            ast::AssocItem::Fn(it) => ast::Item::Fn(it),\n+            ast::AssocItem::MacroCall(it) => ast::Item::MacroCall(it),\n+            ast::AssocItem::TypeAlias(it) => ast::Item::TypeAlias(it),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum AttrKind {\n     Inner,"}]}