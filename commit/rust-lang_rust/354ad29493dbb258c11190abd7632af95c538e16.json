{"sha": "354ad29493dbb258c11190abd7632af95c538e16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NGFkMjk0OTNkYmIyNThjMTExOTBhYmQ3NjMyYWY5NWM1MzhlMTY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-16T13:08:44Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-16T13:08:44Z"}, "message": "Filter out non-type completions in the respective completions modules instead", "tree": {"sha": "09418c3c079d2a849cc99aaeddf5feaab39317f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09418c3c079d2a849cc99aaeddf5feaab39317f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/354ad29493dbb258c11190abd7632af95c538e16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/354ad29493dbb258c11190abd7632af95c538e16", "html_url": "https://github.com/rust-lang/rust/commit/354ad29493dbb258c11190abd7632af95c538e16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/354ad29493dbb258c11190abd7632af95c538e16/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79703efc7fddce3f0080d3d97c200d6a2a2ffaa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/79703efc7fddce3f0080d3d97c200d6a2a2ffaa9", "html_url": "https://github.com/rust-lang/rust/commit/79703efc7fddce3f0080d3d97c200d6a2a2ffaa9"}], "stats": {"total": 165, "additions": 94, "deletions": 71}, "files": [{"sha": "b7eabaabbb054c78552c2b3eb61ae68203663e62", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=354ad29493dbb258c11190abd7632af95c538e16", "patch": "@@ -2688,18 +2688,6 @@ impl ScopeDef {\n \n         items\n     }\n-\n-    pub fn is_value_def(&self) -> bool {\n-        matches!(\n-            self,\n-            ScopeDef::ModuleDef(ModuleDef::Function(_))\n-                | ScopeDef::ModuleDef(ModuleDef::Variant(_))\n-                | ScopeDef::ModuleDef(ModuleDef::Const(_))\n-                | ScopeDef::ModuleDef(ModuleDef::Static(_))\n-                | ScopeDef::GenericParam(GenericParam::ConstParam(_))\n-                | ScopeDef::Local(_)\n-        )\n-    }\n }\n \n impl From<ItemInNs> for ScopeDef {"}, {"sha": "aef70f26ac577ca8a8ef5551bcccd80304563606", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=354ad29493dbb258c11190abd7632af95c538e16", "patch": "@@ -109,9 +109,6 @@ impl Completions {\n         local_name: hir::Name,\n         resolution: &hir::ScopeDef,\n     ) {\n-        if ctx.expects_type() && resolution.is_value_def() {\n-            return;\n-        }\n         self.add_opt(render_resolution(RenderContext::new(ctx), local_name, resolution));\n     }\n "}, {"sha": "1643eeed4081cce4089c1d65044c6ca78f19e23a", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 58, "deletions": 27, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=354ad29493dbb258c11190abd7632af95c538e16", "patch": "@@ -19,6 +19,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n         Some(res) => res,\n         None => return,\n     };\n+\n     let context_module = ctx.scope.module();\n \n     if ctx.expects_item() || ctx.expects_assoc_item() {\n@@ -60,29 +61,39 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     }\n                 }\n \n-                if let hir::ScopeDef::MacroDef(macro_def) = def {\n-                    if !macro_def.is_fn_like() {\n-                        // Don't suggest attribute macros and derives.\n-                        continue;\n+                let add_resolution = match def {\n+                    // Don't suggest attribute macros and derives.\n+                    hir::ScopeDef::MacroDef(mac) => mac.is_fn_like(),\n+                    // no values in type places\n+                    hir::ScopeDef::ModuleDef(hir::ModuleDef::Function(_))\n+                    | hir::ScopeDef::ModuleDef(hir::ModuleDef::Variant(_))\n+                    | hir::ScopeDef::ModuleDef(hir::ModuleDef::Static(_))\n+                    | hir::ScopeDef::Local(_) => !ctx.expects_type(),\n+                    // unless its a constant in a generic arg list position\n+                    hir::ScopeDef::ModuleDef(hir::ModuleDef::Const(_)) => {\n+                        !ctx.expects_type() || ctx.expects_generic_arg()\n                     }\n-                }\n+                    _ => true,\n+                };\n \n-                acc.add_resolution(ctx, name, &def);\n+                if add_resolution {\n+                    acc.add_resolution(ctx, name, &def);\n+                }\n             }\n         }\n         hir::PathResolution::Def(def @ hir::ModuleDef::Adt(_))\n         | hir::PathResolution::Def(def @ hir::ModuleDef::TypeAlias(_))\n         | hir::PathResolution::Def(def @ hir::ModuleDef::BuiltinType(_)) => {\n             if let hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n-                add_enum_variants(ctx, acc, e);\n+                add_enum_variants(acc, ctx, e);\n             }\n             let ty = match def {\n                 hir::ModuleDef::Adt(adt) => adt.ty(ctx.db),\n                 hir::ModuleDef::TypeAlias(a) => {\n                     let ty = a.ty(ctx.db);\n                     if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n                         cov_mark::hit!(completes_variant_through_alias);\n-                        add_enum_variants(ctx, acc, e);\n+                        add_enum_variants(acc, ctx, e);\n                     }\n                     ty\n                 }\n@@ -107,11 +118,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n                         return None;\n                     }\n-                    match item {\n-                        hir::AssocItem::Function(func) => acc.add_function(ctx, func, None),\n-                        hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n-                        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n-                    }\n+                    add_assoc_item(acc, ctx, item);\n                     None::<()>\n                 });\n \n@@ -133,11 +140,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n                     continue;\n                 }\n-                match item {\n-                    hir::AssocItem::Function(func) => acc.add_function(ctx, func, None),\n-                    hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n-                    hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n-                }\n+                add_assoc_item(acc, ctx, item);\n             }\n         }\n         hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n@@ -149,7 +152,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 };\n \n                 if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n-                    add_enum_variants(ctx, acc, e);\n+                    add_enum_variants(acc, ctx, e);\n                 }\n \n                 let traits_in_scope = ctx.scope.traits_in_scope();\n@@ -162,11 +165,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     // We might iterate candidates of a trait multiple times here, so deduplicate\n                     // them.\n                     if seen.insert(item) {\n-                        match item {\n-                            hir::AssocItem::Function(func) => acc.add_function(ctx, func, None),\n-                            hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n-                            hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n-                        }\n+                        add_assoc_item(acc, ctx, item);\n                     }\n                     None::<()>\n                 });\n@@ -176,10 +175,22 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     }\n }\n \n-fn add_enum_variants(ctx: &CompletionContext, acc: &mut Completions, e: hir::Enum) {\n-    for variant in e.variants(ctx.db) {\n-        acc.add_enum_variant(ctx, variant, None);\n+fn add_assoc_item(acc: &mut Completions, ctx: &CompletionContext, item: hir::AssocItem) {\n+    match item {\n+        hir::AssocItem::Function(func) if !ctx.expects_type() => acc.add_function(ctx, func, None),\n+        hir::AssocItem::Const(ct) if !ctx.expects_type() || ctx.expects_generic_arg() => {\n+            acc.add_const(ctx, ct)\n+        }\n+        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+        _ => (),\n+    }\n+}\n+\n+fn add_enum_variants(acc: &mut Completions, ctx: &CompletionContext, e: hir::Enum) {\n+    if ctx.expects_type() {\n+        return;\n     }\n+    e.variants(ctx.db).into_iter().for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n }\n \n #[cfg(test)]\n@@ -927,4 +938,24 @@ fn main() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn completes_types_and_const_in_arg_list() {\n+        check(\n+            r#\"\n+mod foo {\n+    pub const CONST: () = ();\n+    pub type Type = ();\n+}\n+\n+struct Foo<T>(t);\n+\n+fn foo(_: Foo<foo::$0>) {}\n+\"#,\n+            expect![[r#\"\n+                ta Type\n+                ct CONST\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "b5af1c810309130f9a62264be545bd9e406c50fa", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=354ad29493dbb258c11190abd7632af95c538e16", "patch": "@@ -36,12 +36,14 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         return;\n     }\n \n-    if let Some(hir::Adt::Enum(e)) =\n-        ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n-    {\n-        super::complete_enum_variants(acc, ctx, e, |acc, ctx, variant, path| {\n-            acc.add_qualified_enum_variant(ctx, variant, path)\n-        });\n+    if !ctx.expects_type() {\n+        if let Some(hir::Adt::Enum(e)) =\n+            ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n+        {\n+            super::complete_enum_variants(acc, ctx, e, |acc, ctx, variant, path| {\n+                acc.add_qualified_enum_variant(ctx, variant, path)\n+            });\n+        }\n     }\n \n     if let Some(ImmediateLocation::GenericArgList(arg_list)) = &ctx.completion_location {\n@@ -59,12 +61,25 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     }\n \n     ctx.scope.process_all_names(&mut |name, res| {\n-        if let ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) = res {\n+        if let ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) | ScopeDef::Label(_) =\n+            res\n+        {\n             cov_mark::hit!(skip_lifetime_completion);\n             return;\n         }\n         let add_resolution = match res {\n+            // Don't suggest attribute macros and derives.\n             ScopeDef::MacroDef(mac) => mac.is_fn_like(),\n+            // no values in type places\n+            ScopeDef::ModuleDef(hir::ModuleDef::Function(_))\n+            | ScopeDef::ModuleDef(hir::ModuleDef::Variant(_))\n+            | ScopeDef::ModuleDef(hir::ModuleDef::Static(_))\n+            | ScopeDef::Local(_) => !ctx.expects_type(),\n+            // unless its a constant in a generic arg list position\n+            ScopeDef::ModuleDef(hir::ModuleDef::Const(_))\n+            | ScopeDef::GenericParam(hir::GenericParam::ConstParam(_)) => {\n+                !ctx.expects_type() || ctx.expects_generic_arg()\n+            }\n             _ => true,\n         };\n         if add_resolution {\n@@ -794,36 +809,27 @@ $0\n     }\n \n     #[test]\n-    fn completes_assoc_types_in_dynimpl_trait() {\n+    fn completes_types_and_const_in_arg_list() {\n         check(\n             r#\"\n-trait Foo {\n-    type Bar;\n+enum Bar {\n+    Baz\n }\n-\n-fn foo(_: impl Foo<B$0>) {}\n-\"#,\n-            expect![[r#\"\n-                ta Bar =  type Bar;\n-                tt Foo\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_assoc_types_in_trait_bound() {\n-        check(\n-            r#\"\n trait Foo {\n     type Bar;\n }\n \n-fn foo<T: Foo<B$0>>(_: T) {}\n+const CONST: () = ();\n+\n+fn foo<T: Foo<$0>, const CONST_PARAM: usize>(_: T) {}\n \"#,\n             expect![[r#\"\n-                ta Bar =  type Bar;\n+                ta Bar =       type Bar;\n                 tp T\n+                cp CONST_PARAM\n                 tt Foo\n+                en Bar\n+                ct CONST\n             \"#]],\n         );\n     }"}, {"sha": "a8437d81c7336a0700231d05332b7afe34ee24b3", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=354ad29493dbb258c11190abd7632af95c538e16", "patch": "@@ -276,6 +276,10 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.completion_location, Some(ImmediateLocation::ItemList))\n     }\n \n+    pub(crate) fn expects_generic_arg(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::GenericArgList(_)))\n+    }\n+\n     pub(crate) fn has_block_expr_parent(&self) -> bool {\n         matches!(self.completion_location, Some(ImmediateLocation::BlockExpr))\n     }"}, {"sha": "add2961245ea2f2758a0e6f984514ae9305bc1be", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354ad29493dbb258c11190abd7632af95c538e16/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=354ad29493dbb258c11190abd7632af95c538e16", "patch": "@@ -55,9 +55,6 @@ pub(crate) fn render_resolution_with_import(\n     import_edit: ImportEdit,\n ) -> Option<CompletionItem> {\n     let resolution = hir::ScopeDef::from(import_edit.import.original_item);\n-    if ctx.completion.expects_type() && resolution.is_value_def() {\n-        return None;\n-    }\n     let local_name = match resolution {\n         hir::ScopeDef::ModuleDef(hir::ModuleDef::Function(f)) => f.name(ctx.completion.db),\n         hir::ScopeDef::ModuleDef(hir::ModuleDef::Const(c)) => c.name(ctx.completion.db)?,"}]}