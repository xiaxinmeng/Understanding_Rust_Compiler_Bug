{"sha": "508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwOGM0OGNlMTBiYzdkN2U1ZDRmZjdjMWYxMDUzZjExMzg2N2I5YmM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-28T13:15:29Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-29T08:36:40Z"}, "message": "Reduce move ops to a construct-in-place when possible", "tree": {"sha": "4517abaae4cc96cefb1eb8a3da35bd4c9418a39b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4517abaae4cc96cefb1eb8a3da35bd4c9418a39b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc", "html_url": "https://github.com/rust-lang/rust/commit/508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15e34deba3efa7c064bf9ffe0fa1eff47f9b117e", "url": "https://api.github.com/repos/rust-lang/rust/commits/15e34deba3efa7c064bf9ffe0fa1eff47f9b117e", "html_url": "https://github.com/rust-lang/rust/commit/15e34deba3efa7c064bf9ffe0fa1eff47f9b117e"}], "stats": {"total": 55, "additions": 35, "deletions": 20}, "files": [{"sha": "bcb685340c3e146679c855232a7d6c9a3210ecf2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc", "patch": "@@ -3207,6 +3207,25 @@ fn trans_callee(cx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n     }\n }\n \n+fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n+    alt e.node {\n+      ast::expr_path(_) | ast::expr_index(_, _) |\n+      ast::expr_unary(ast::deref., _) { true }\n+      ast::expr_field(base, ident) {\n+        let basety = ty::type_autoderef(tcx, ty::expr_ty(tcx, base));\n+        alt ty::struct(tcx, basety) {\n+          ty::ty_obj(_) { false }\n+          ty::ty_rec(_) { true }\n+        }\n+      }\n+      ast::expr_call(f, _) {\n+          let fty = ty::expr_ty(tcx, f);\n+          ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fty))\n+      }\n+      _ { false }\n+    }\n+}\n+\n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n@@ -4149,20 +4168,6 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n         add_clean_temp(bcx, r.val, e_ty);\n         ret r;\n       }\n-      ast::expr_move(dst, src) {\n-        let lhs_res = trans_lval(cx, dst);\n-        assert (lhs_res.is_mem);\n-        // FIXME Fill in lhs_res.bcx.sp\n-\n-        let rhs_res = trans_lval(lhs_res.bcx, src);\n-        let t = ty::expr_ty(bcx_tcx(cx), src);\n-        // FIXME: calculate copy init-ness in typestate.\n-\n-        let bcx =\n-            move_val(rhs_res.bcx, DROP_EXISTING, lhs_res.val, rhs_res,\n-                     t);\n-        ret rslt(bcx, C_nil());\n-      }\n       ast::expr_bind(f, args) { ret trans_bind(cx, f, args, e.id); }\n       ast::expr_cast(val, _) { ret trans_cast(cx, val, e.id); }\n       ast::expr_anon_obj(anon_obj) {\n@@ -4325,6 +4330,19 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n         assert is_mem;\n         ret trans_expr_save_in(bcx, src, lhs_addr, DROP_EXISTING);\n       }\n+      ast::expr_move(dst, src) {\n+        assert dest == ignore;\n+        let {bcx, val: addr, is_mem} = trans_lval(bcx, dst);\n+        assert is_mem;\n+        // FIXME: calculate copy init-ness in typestate.\n+        if expr_is_lval(bcx_tcx(bcx), src) {\n+            ret trans_expr_save_in(bcx, src, addr, DROP_EXISTING);\n+        } else {\n+            let srclv = trans_lval(bcx, src);\n+            let t = ty::expr_ty(bcx_tcx(bcx), src);\n+            ret move_val(srclv.bcx, DROP_EXISTING, addr, srclv, t);\n+        }\n+      }\n       ast::expr_swap(dst, src) {\n         assert dest == ignore;\n         let lhs_res = trans_lval(bcx, dst);\n@@ -4665,15 +4683,12 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n \n     alt local.node.init {\n       some(init) {\n-        alt init.op {\n-          ast::init_assign. {\n+        if init.op == ast::init_assign ||\n+           !expr_is_lval(bcx_tcx(bcx), init.expr) {\n             bcx = trans_expr_save_in(bcx, init.expr, llptr, INIT);\n-          }\n-          // FIXME[DPS] do a save_in when expr isn't lval\n-          ast::init_move. {\n+        } else { // This is a move from an lval, must perform an actual move\n             let sub = trans_lval(bcx, init.expr);\n             bcx = move_val(sub.bcx, INIT, llptr, sub, ty);\n-          }\n         }\n       }\n       _ { bcx = zero_alloca(bcx, llptr, ty); }"}]}