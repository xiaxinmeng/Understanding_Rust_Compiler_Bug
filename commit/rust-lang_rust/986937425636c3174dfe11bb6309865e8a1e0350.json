{"sha": "986937425636c3174dfe11bb6309865e8a1e0350", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NjkzNzQyNTYzNmMzMTc0ZGZlMTFiYjYzMDk4NjVlOGExZTAzNTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-31T20:17:03Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T14:44:48Z"}, "message": "librustc: Remove a bunch of `@str` from the compiler around metadata\nhandling", "tree": {"sha": "2e306059c873fafc89ffa8df1a94f2c57f8fa350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e306059c873fafc89ffa8df1a94f2c57f8fa350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/986937425636c3174dfe11bb6309865e8a1e0350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/986937425636c3174dfe11bb6309865e8a1e0350", "html_url": "https://github.com/rust-lang/rust/commit/986937425636c3174dfe11bb6309865e8a1e0350", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/986937425636c3174dfe11bb6309865e8a1e0350/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b890237e798030ce337933b14f777a1c3810d1ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/b890237e798030ce337933b14f777a1c3810d1ea", "html_url": "https://github.com/rust-lang/rust/commit/b890237e798030ce337933b14f777a1c3810d1ea"}], "stats": {"total": 174, "additions": 101, "deletions": 73}, "files": [{"sha": "669c3248a1fd743e0ee4dcb1f2867e04c5c4ad67", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -473,10 +473,10 @@ pub fn build_link_meta(sess: Session,\n                        symbol_hasher: &mut Sha256)\n                        -> LinkMeta {\n     // This calculates CMH as defined above\n-    fn crate_hash(symbol_hasher: &mut Sha256, crateid: &CrateId) -> @str {\n+    fn crate_hash(symbol_hasher: &mut Sha256, crateid: &CrateId) -> ~str {\n         symbol_hasher.reset();\n         symbol_hasher.input_str(crateid.to_str());\n-        truncated_hash_result(symbol_hasher).to_managed()\n+        truncated_hash_result(symbol_hasher)\n     }\n \n     let crateid = match attr::find_crateid(attrs) {\n@@ -963,7 +963,7 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n \n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     for &(cnum, ref path) in crates.iter() {\n-        let name = sess.cstore.get_crate_data(cnum).name;\n+        let name = sess.cstore.get_crate_data(cnum).name.clone();\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n                 sess.err(format!(\"could not find rlib for: `{}`\", name));\n@@ -1221,7 +1221,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n                 // If we're not doing LTO, then our job is simply to just link\n                 // against the archive.\n                 if sess.lto() {\n-                    let name = sess.cstore.get_crate_data(cnum).name;\n+                    let name = sess.cstore.get_crate_data(cnum).name.clone();\n                     time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n                          (), |()| {\n                         let dst = tmpdir.join(cratepath.filename().unwrap());"}, {"sha": "3fbcd377b8b1cdd9b6203a749d82421680213285", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -42,7 +42,7 @@ pub fn run(sess: session::Session, llmod: ModuleRef,\n     // module that we've got.\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     for (cnum, path) in crates.move_iter() {\n-        let name = sess.cstore.get_crate_data(cnum).name;\n+        let name = sess.cstore.get_crate_data(cnum).name.clone();\n         let path = match path {\n             Some(p) => p,\n             None => {"}, {"sha": "e9732f5c9960dc10a4e867397724b934536b57b0", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -210,5 +210,5 @@ pub static tag_macro_def: uint = 0x112;\n #[deriving(Clone)]\n pub struct LinkMeta {\n     crateid: CrateId,\n-    crate_hash: @str,\n+    crate_hash: ~str,\n }"}, {"sha": "9c2c5a5745848e8bae7c5a98530150defda9fdc8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -76,7 +76,7 @@ impl<'a> visit::Visitor<()> for ReadCrateVisitor<'a> {\n struct cache_entry {\n     cnum: ast::CrateNum,\n     span: Span,\n-    hash: @str,\n+    hash: ~str,\n     crateid: CrateId,\n }\n \n@@ -146,45 +146,49 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n \n     match extract_crate_info(i) {\n         Some(info) => {\n-            let cnum = resolve_crate(e, info.ident, info.name, info.version,\n-                                     @\"\", i.span);\n+            let cnum = resolve_crate(e,\n+                                     info.ident.clone(),\n+                                     info.name.clone(),\n+                                     info.version.clone(),\n+                                     ~\"\",\n+                                     i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n         None => ()\n     }\n }\n \n struct CrateInfo {\n-    ident: @str,\n-    name: @str,\n-    version: @str,\n+    ident: ~str,\n+    name: ~str,\n+    version: ~str,\n     id: ast::NodeId,\n }\n \n fn extract_crate_info(i: &ast::ViewItem) -> Option<CrateInfo> {\n     match i.node {\n         ast::ViewItemExternMod(ref ident, ref path_opt, id) => {\n-            let ident = token::ident_to_str(ident);\n+            let ident = token::get_ident(ident.name);\n             debug!(\"resolving extern mod stmt. ident: {:?} path_opt: {:?}\",\n-                   ident, path_opt);\n+                   ident.get(), path_opt);\n             let (name, version) = match *path_opt {\n                 Some((ref path_str, _)) => {\n                     let crateid: Option<CrateId> = from_str(path_str.get());\n                     match crateid {\n-                        None => (@\"\", @\"\"),\n+                        None => (~\"\", ~\"\"),\n                         Some(crateid) => {\n                             let version = match crateid.version {\n-                                None => @\"\",\n-                                Some(ref ver) => ver.to_managed(),\n+                                None => ~\"\",\n+                                Some(ref ver) => ver.to_str(),\n                             };\n-                            (crateid.name.to_managed(), version)\n+                            (crateid.name.to_str(), version)\n                         }\n                     }\n                 }\n-                None => (ident, @\"\"),\n+                None => (ident.get().to_str(), ~\"\"),\n             };\n             Some(CrateInfo {\n-                  ident: ident,\n+                  ident: ident.get().to_str(),\n                   name: name,\n                   version: version,\n                   id: id,\n@@ -278,14 +282,14 @@ fn visit_item(e: &Env, i: &ast::Item) {\n     }\n }\n \n-fn existing_match(e: &Env, name: @str, version: @str, hash: &str) -> Option<ast::CrateNum> {\n+fn existing_match(e: &Env, name: ~str, version: ~str, hash: &str) -> Option<ast::CrateNum> {\n     let crate_cache = e.crate_cache.borrow();\n     for c in crate_cache.get().iter() {\n         let crateid_version = match c.crateid.version {\n-            None => @\"0.0\",\n-            Some(ref ver) => ver.to_managed(),\n+            None => ~\"0.0\",\n+            Some(ref ver) => ver.to_str(),\n         };\n-        if (name.is_empty() || c.crateid.name.to_managed() == name) &&\n+        if (name.is_empty() || c.crateid.name == name) &&\n             (version.is_empty() || crateid_version == version) &&\n             (hash.is_empty() || c.hash.as_slice() == hash) {\n             return Some(c.cnum);\n@@ -295,19 +299,19 @@ fn existing_match(e: &Env, name: @str, version: @str, hash: &str) -> Option<ast:\n }\n \n fn resolve_crate(e: &mut Env,\n-                 ident: @str,\n-                 name: @str,\n-                 version: @str,\n-                 hash: @str,\n+                 ident: ~str,\n+                 name: ~str,\n+                 version: ~str,\n+                 hash: ~str,\n                  span: Span)\n               -> ast::CrateNum {\n-    match existing_match(e, name, version, hash) {\n+    match existing_match(e, name.clone(), version.clone(), hash.clone()) {\n       None => {\n         let load_ctxt = loader::Context {\n             sess: e.sess,\n             span: span,\n             ident: ident,\n-            name: name,\n+            name: name.clone(),\n             version: version,\n             hash: hash,\n             os: e.os,\n@@ -368,10 +372,13 @@ fn resolve_crate_deps(e: &mut Env, cdata: &[u8]) -> cstore::cnum_map {\n     let r = decoder::get_crate_deps(cdata);\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n-        let cname_str = token::ident_to_str(&dep.name);\n+        let cname_str = token::get_ident(dep.name.name);\n         debug!(\"resolving dep crate {} ver: {} hash: {}\",\n                cname_str, dep.vers, dep.hash);\n-        match existing_match(e, cname_str, dep.vers, dep.hash) {\n+        match existing_match(e,\n+                             cname_str.get().to_str(),\n+                             dep.vers.clone(),\n+                             dep.hash.clone()) {\n           Some(local_cnum) => {\n             debug!(\"already have it\");\n             // We've already seen this crate\n@@ -383,8 +390,12 @@ fn resolve_crate_deps(e: &mut Env, cdata: &[u8]) -> cstore::cnum_map {\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n             let fake_span = DUMMY_SP;\n-            let local_cnum = resolve_crate(e, cname_str, cname_str, dep.vers,\n-                                           dep.hash, fake_span);\n+            let local_cnum = resolve_crate(e,\n+                                           cname_str.get().to_str(),\n+                                           cname_str.get().to_str(),\n+                                           dep.vers.clone(),\n+                                           dep.hash.clone(),\n+                                           fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n         }\n@@ -415,8 +426,12 @@ impl Loader {\n impl CrateLoader for Loader {\n     fn load_crate(&mut self, crate: &ast::ViewItem) -> MacroCrate {\n         let info = extract_crate_info(crate).unwrap();\n-        let cnum = resolve_crate(&mut self.env, info.ident, info.name,\n-                                 info.version, @\"\", crate.span);\n+        let cnum = resolve_crate(&mut self.env,\n+                                 info.ident.clone(),\n+                                 info.name.clone(),\n+                                 info.version.clone(),\n+                                 ~\"\",\n+                                 crate.span);\n         let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n         MacroCrate {\n             lib: library.dylib,"}, {"sha": "45eccc94ed8006ee3e2e32b2d2e88e38b9a764a5", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -32,7 +32,7 @@ pub enum MetadataBlob {\n }\n \n pub struct crate_metadata {\n-    name: @str,\n+    name: ~str,\n     data: MetadataBlob,\n     cnum_map: cnum_map,\n     cnum: ast::CrateNum\n@@ -89,12 +89,12 @@ impl CStore {\n         *metas.get().get(&cnum)\n     }\n \n-    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> @str {\n+    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> ~str {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn get_crate_vers(&self, cnum: ast::CrateNum) -> @str {\n+    pub fn get_crate_vers(&self, cnum: ast::CrateNum) -> ~str {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_vers(cdata.data())\n     }\n@@ -192,7 +192,7 @@ impl CStore {\n \n     // returns hashes of crates directly used by this crate. Hashes are sorted by\n     // (crate name, crate version, crate hash) in lexicographic order (not semver)\n-    pub fn get_dep_hashes(&self) -> ~[@str] {\n+    pub fn get_dep_hashes(&self) -> ~[~str] {\n         let mut result = ~[];\n \n         let extern_mod_crate_map = self.extern_mod_crate_map.borrow();\n@@ -202,7 +202,7 @@ impl CStore {\n             let vers = decoder::get_crate_vers(cdata.data());\n             debug!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n             result.push(crate_hash {\n-                name: cdata.name,\n+                name: cdata.name.clone(),\n                 vers: vers,\n                 hash: hash\n             });\n@@ -215,15 +215,23 @@ impl CStore {\n             debug!(\"  hash[{}]: {}\", x.name, x.hash);\n         }\n \n-        result.map(|ch| ch.hash)\n+        let mut hashes = ~[];\n+        for ch in result.move_iter() {\n+            let crate_hash {\n+                hash,\n+                ..\n+            } = ch;\n+            hashes.push(hash)\n+        }\n+        hashes\n     }\n }\n \n #[deriving(Clone, TotalEq, TotalOrd)]\n struct crate_hash {\n-    name: @str,\n-    vers: @str,\n-    hash: @str,\n+    name: ~str,\n+    vers: ~str,\n+    hash: ~str,\n }\n \n impl crate_metadata {"}, {"sha": "edaa2208a1ff85981ff899abcf04375f56273565", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -1113,18 +1113,18 @@ pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n pub struct CrateDep {\n     cnum: ast::CrateNum,\n     name: ast::Ident,\n-    vers: @str,\n-    hash: @str\n+    vers: ~str,\n+    hash: ~str\n }\n \n pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n     let mut deps: ~[CrateDep] = ~[];\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::Doc, tag_: uint) -> @str {\n+    fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n         let d = reader::get_doc(doc, tag_);\n-        d.as_str_slice().to_managed()\n+        d.as_str_slice().to_str()\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         deps.push(CrateDep {cnum: crate_num,\n@@ -1149,17 +1149,17 @@ fn list_crate_deps(data: &[u8], out: &mut io::Writer) {\n     write!(out, \"\\n\");\n }\n \n-pub fn get_crate_hash(data: &[u8]) -> @str {\n+pub fn get_crate_hash(data: &[u8]) -> ~str {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    hashdoc.as_str_slice().to_managed()\n+    hashdoc.as_str_slice().to_str()\n }\n \n-pub fn get_crate_vers(data: &[u8]) -> @str {\n+pub fn get_crate_vers(data: &[u8]) -> ~str {\n     let attrs = decoder::get_crate_attributes(data);\n     match attr::find_crateid(attrs) {\n-        None => @\"0.0\",\n-        Some(crateid) => crateid.version_or_default().to_managed(),\n+        None => ~\"0.0\",\n+        Some(crateid) => crateid.version_or_default().to_str(),\n     }\n }\n "}, {"sha": "8e0f4dc9cd8abe4b84dc12bcad2cdb49ebb962ab", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -1614,7 +1614,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n     ebml_w.start_tag(tag_crate_deps);\n     let r = get_ordered_deps(ecx, cstore);\n     for dep in r.iter() {\n-        encode_crate_dep(ecx, ebml_w, *dep);\n+        encode_crate_dep(ecx, ebml_w, (*dep).clone());\n     }\n     ebml_w.end_tag();\n }"}, {"sha": "8e557560b95f1f83403b1481041805018a575cac", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -46,10 +46,10 @@ pub enum Os {\n pub struct Context {\n     sess: Session,\n     span: Span,\n-    ident: @str,\n-    name: @str,\n-    version: @str,\n-    hash: @str,\n+    ident: ~str,\n+    name: ~str,\n+    version: ~str,\n+    hash: ~str,\n     os: Os,\n     intr: @IdentInterner\n }\n@@ -80,7 +80,7 @@ impl Context {\n \n     fn find_library_crate(&self) -> Option<Library> {\n         let filesearch = self.sess.filesearch;\n-        let crate_name = self.name;\n+        let crate_name = self.name.clone();\n         let (dyprefix, dysuffix) = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n@@ -109,8 +109,10 @@ impl Context {\n                     } else if candidate {\n                         match get_metadata_section(self.os, path) {\n                             Some(cvec) =>\n-                                if crate_matches(cvec.as_slice(), self.name,\n-                                                 self.version, self.hash) {\n+                                if crate_matches(cvec.as_slice(),\n+                                                 self.name.clone(),\n+                                                 self.version.clone(),\n+                                                 self.hash.clone()) {\n                                     debug!(\"found {} with matching crate_id\",\n                                            path.display());\n                                     let (rlib, dylib) = if file.ends_with(\".rlib\") {\n@@ -235,9 +237,9 @@ pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n }\n \n fn crate_matches(crate_data: &[u8],\n-                 name: @str,\n-                 version: @str,\n-                 hash: @str) -> bool {\n+                 name: ~str,\n+                 version: ~str,\n+                 hash: ~str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     match attr::find_crateid(attrs) {\n         None => false,\n@@ -246,8 +248,9 @@ fn crate_matches(crate_data: &[u8],\n                 let chash = decoder::get_crate_hash(crate_data);\n                 if chash != hash { return false; }\n             }\n-            name == crateid.name.to_managed() &&\n-                (version.is_empty() || version == crateid.version_or_default().to_managed())\n+            name == crateid.name &&\n+                (version.is_empty() ||\n+                 crateid.version_or_default() == version)\n         }\n     }\n }"}, {"sha": "bbe5bdc967bb82ac0720218634893a13b810b9a4", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -1797,9 +1797,9 @@ fn trans_log_level<'a>(bcx: &'a Block<'a>)\n             let external_srcs = ccx.external_srcs.borrow();\n             srccrate = match external_srcs.get().find(&bcx.fcx.id) {\n                 Some(&src) => {\n-                    ccx.sess.cstore.get_crate_data(src.crate).name\n+                    ccx.sess.cstore.get_crate_data(src.crate).name.clone()\n                 }\n-                None => ccx.link_meta.crateid.name.to_managed(),\n+                None => ccx.link_meta.crateid.name.to_str(),\n             };\n         };\n         let mut modpath = ~[PathMod(ccx.sess.ident_of(srccrate))];"}, {"sha": "49f1b073f873e1292232958e533570e007e92280", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -337,8 +337,10 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             Ret(bcx, td);\n         }\n         \"type_id\" => {\n-            let hash = ty::hash_crate_independent(ccx.tcx, substs.tys[0],\n-                                                  ccx.link_meta.crate_hash);\n+            let hash = ty::hash_crate_independent(\n+                ccx.tcx,\n+                substs.tys[0],\n+                ccx.link_meta.crate_hash.clone());\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n             let val = C_named_struct(type_of::type_of(ccx, output_type), [C_u64(hash)]);"}, {"sha": "681eabb797dc27939e4efe9c420cf07a874edda0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986937425636c3174dfe11bb6309865e8a1e0350/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=986937425636c3174dfe11bb6309865e8a1e0350", "patch": "@@ -4834,7 +4834,7 @@ pub fn trait_method_of_method(tcx: ctxt,\n \n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n-pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n+pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n     use std::hash::{SipState, Streaming};\n \n     let mut hash = SipState::new(0, 0);\n@@ -4865,7 +4865,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n     };\n     let did = |hash: &mut SipState, did: DefId| {\n         let h = if ast_util::is_local(did) {\n-            local_hash\n+            local_hash.clone()\n         } else {\n             tcx.sess.cstore.get_crate_hash(did.crate)\n         };"}]}