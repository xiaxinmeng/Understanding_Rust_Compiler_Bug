{"sha": "1c448574bc668b0de70ed75223bf8798d17bf058", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNDQ4NTc0YmM2NjhiMGRlNzBlZDc1MjIzYmY4Nzk4ZDE3YmYwNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-28T21:15:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-28T21:15:17Z"}, "message": "Auto merge of #37791 - petrochenkov:where, r=nikomatsakis\n\nSupport `?Sized` in where clauses\n\nImplemented as described in https://github.com/rust-lang/rust/issues/20503#issuecomment-258677026 - `?Trait` bounds are moved on type parameter definitions when possible, reported as errors otherwise.\n(It'd be nice to unify bounds and where clauses in HIR, but this is mostly blocked by rustdoc now - it needs to render bounds in pleasant way and the best way to do it so far is to mirror what was written in source code.)\n\nFixes https://github.com/rust-lang/rust/issues/20503\nr? @nikomatsakis", "tree": {"sha": "626a2bd26b17e8151a0f3537f6fe6107d54b3ee1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/626a2bd26b17e8151a0f3537f6fe6107d54b3ee1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c448574bc668b0de70ed75223bf8798d17bf058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c448574bc668b0de70ed75223bf8798d17bf058", "html_url": "https://github.com/rust-lang/rust/commit/1c448574bc668b0de70ed75223bf8798d17bf058", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c448574bc668b0de70ed75223bf8798d17bf058/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39c267a8d5ab141faaf5d4b33a20cac62cdc4507", "url": "https://api.github.com/repos/rust-lang/rust/commits/39c267a8d5ab141faaf5d4b33a20cac62cdc4507", "html_url": "https://github.com/rust-lang/rust/commit/39c267a8d5ab141faaf5d4b33a20cac62cdc4507"}, {"sha": "7d15250b0e5180137f5055b2e4333d5aac6579fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d15250b0e5180137f5055b2e4333d5aac6579fe", "html_url": "https://github.com/rust-lang/rust/commit/7d15250b0e5180137f5055b2e4333d5aac6579fe"}], "stats": {"total": 196, "additions": 161, "deletions": 35}, "files": [{"sha": "f9f46558dece36dd6bda04595ba70099248143ed", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1c448574bc668b0de70ed75223bf8798d17bf058", "patch": "@@ -46,6 +46,7 @@ use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n+use util::nodemap::NodeMap;\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -508,7 +509,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_param(&mut self, tp: &TyParam) -> hir::TyParam {\n+    fn lower_ty_param(&mut self, tp: &TyParam, add_bounds: &[TyParamBound]) -> hir::TyParam {\n         let mut name = tp.ident.name;\n \n         // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n@@ -518,18 +519,26 @@ impl<'a> LoweringContext<'a> {\n             name = Symbol::gensym(\"Self\");\n         }\n \n+        let mut bounds = self.lower_bounds(&tp.bounds);\n+        if !add_bounds.is_empty() {\n+            bounds = bounds.into_iter().chain(self.lower_bounds(add_bounds).into_iter()).collect();\n+        }\n+\n         hir::TyParam {\n             id: tp.id,\n             name: name,\n-            bounds: self.lower_bounds(&tp.bounds),\n+            bounds: bounds,\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n             span: tp.span,\n             pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n         }\n     }\n \n-    fn lower_ty_params(&mut self, tps: &P<[TyParam]>) -> hir::HirVec<hir::TyParam> {\n-        tps.iter().map(|tp| self.lower_ty_param(tp)).collect()\n+    fn lower_ty_params(&mut self, tps: &P<[TyParam]>, add_bounds: &NodeMap<Vec<TyParamBound>>)\n+                       -> hir::HirVec<hir::TyParam> {\n+        tps.iter().map(|tp| {\n+            self.lower_ty_param(tp, add_bounds.get(&tp.id).map_or(&[][..], |x| &x))\n+        }).collect()\n     }\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n@@ -561,8 +570,47 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_generics(&mut self, g: &Generics) -> hir::Generics {\n+        // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n+        let mut add_bounds = NodeMap();\n+        for pred in &g.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n+                'next_bound: for bound in &bound_pred.bounds {\n+                    if let TraitTyParamBound(_, TraitBoundModifier::Maybe) = *bound {\n+                        let report_error = |this: &mut Self| {\n+                            this.diagnostic().span_err(bound_pred.bounded_ty.span,\n+                                                       \"`?Trait` bounds are only permitted at the \\\n+                                                        point where a type parameter is declared\");\n+                        };\n+                        // Check if the where clause type is a plain type parameter.\n+                        match bound_pred.bounded_ty.node {\n+                            TyKind::Path(None, ref path)\n+                                    if !path.global && path.segments.len() == 1 &&\n+                                        bound_pred.bound_lifetimes.is_empty() => {\n+                                if let Some(Def::TyParam(def_id)) =\n+                                        self.resolver.get_resolution(bound_pred.bounded_ty.id)\n+                                                     .map(|d| d.base_def) {\n+                                    if let Some(node_id) =\n+                                            self.resolver.definitions().as_local_node_id(def_id) {\n+                                        for ty_param in &g.ty_params {\n+                                            if node_id == ty_param.id {\n+                                                add_bounds.entry(ty_param.id).or_insert(Vec::new())\n+                                                                            .push(bound.clone());\n+                                                continue 'next_bound;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                report_error(self)\n+                            }\n+                            _ => report_error(self)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         hir::Generics {\n-            ty_params: self.lower_ty_params(&g.ty_params),\n+            ty_params: self.lower_ty_params(&g.ty_params, &add_bounds),\n             lifetimes: self.lower_lifetime_defs(&g.lifetimes),\n             where_clause: self.lower_where_clause(&g.where_clause),\n             span: g.span,\n@@ -588,7 +636,11 @@ impl<'a> LoweringContext<'a> {\n                 hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     bound_lifetimes: self.lower_lifetime_defs(bound_lifetimes),\n                     bounded_ty: self.lower_ty(bounded_ty),\n-                    bounds: bounds.iter().map(|x| self.lower_ty_param_bound(x)).collect(),\n+                    bounds: bounds.iter().filter_map(|bound| match *bound {\n+                        // Ignore `?Trait` bounds, they were copied into type parameters already.\n+                        TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n+                        _ => Some(self.lower_ty_param_bound(bound))\n+                    }).collect(),\n                     span: span,\n                 })\n             }\n@@ -677,7 +729,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_bounds(&mut self, bounds: &TyParamBounds) -> hir::TyParamBounds {\n+    fn lower_bounds(&mut self, bounds: &[TyParamBound]) -> hir::TyParamBounds {\n         bounds.iter().map(|bound| self.lower_ty_param_bound(bound)).collect()\n     }\n "}, {"sha": "fa07006aa63e1da6312dbb2d2d744df1424a2426", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=1c448574bc668b0de70ed75223bf8798d17bf058", "patch": "@@ -86,6 +86,19 @@ impl<'a> AstValidator<'a> {\n             _ => {}\n         }\n     }\n+\n+    fn no_questions_in_bounds(&self, bounds: &TyParamBounds, where_: &str, is_trait: bool) {\n+        for bound in bounds {\n+            if let TraitTyParamBound(ref poly, TraitBoundModifier::Maybe) = *bound {\n+                let mut err = self.err_handler().struct_span_err(poly.span,\n+                                    &format!(\"`?Trait` is not permitted in {}\", where_));\n+                if is_trait {\n+                    err.note(&format!(\"traits are `?{}` by default\", poly.trait_ref.path));\n+                }\n+                err.emit();\n+            }\n+        }\n+    }\n }\n \n impl<'a> Visitor for AstValidator<'a> {\n@@ -130,6 +143,10 @@ impl<'a> Visitor for AstValidator<'a> {\n                     err.emit();\n                 });\n             }\n+            TyKind::ObjectSum(_, ref bounds) |\n+            TyKind::PolyTraitRef(ref bounds) => {\n+                self.no_questions_in_bounds(bounds, \"trait object types\", false);\n+            }\n             _ => {}\n         }\n \n@@ -189,7 +206,8 @@ impl<'a> Visitor for AstValidator<'a> {\n                     }\n                 }\n             }\n-            ItemKind::Trait(.., ref trait_items) => {\n+            ItemKind::Trait(.., ref bounds, ref trait_items) => {\n+                self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n                         self.check_trait_fn_not_const(sig.constness);"}, {"sha": "bdd1606805fefa2573a98230d581b3f858916e4f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1c448574bc668b0de70ed75223bf8798d17bf058", "patch": "@@ -88,13 +88,6 @@ pub enum PathStyle {\n     Expr,\n }\n \n-/// How to parse a bound, whether to allow bound modifiers such as `?`.\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum BoundParsingMode {\n-    Bare,\n-    Modified,\n-}\n-\n #[derive(Clone, Copy, PartialEq)]\n pub enum SemiColonMode {\n     Break,\n@@ -1041,7 +1034,7 @@ impl<'a> Parser<'a> {\n                                                      trait_ref: trait_ref,\n                                                      span: mk_sp(lo, hi)};\n             let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n-                self.parse_ty_param_bounds(BoundParsingMode::Bare)?\n+                self.parse_ty_param_bounds()?\n             } else {\n                 P::new()\n             };\n@@ -1059,7 +1052,7 @@ impl<'a> Parser<'a> {\n         The `impl` has already been consumed.\n         */\n \n-        let bounds = self.parse_ty_param_bounds(BoundParsingMode::Modified)?;\n+        let bounds = self.parse_ty_param_bounds()?;\n \n         if !bounds.iter().any(|b| if let TraitTyParamBound(..) = *b { true } else { false }) {\n             self.span_err(self.prev_span, \"at least one trait must be specified\");\n@@ -1271,7 +1264,7 @@ impl<'a> Parser<'a> {\n             return Ok(lhs);\n         }\n \n-        let bounds = self.parse_ty_param_bounds(BoundParsingMode::Bare)?;\n+        let bounds = self.parse_ty_param_bounds()?;\n \n         // In type grammar, `+` is treated like a binary operator,\n         // and hence both L and R side are required.\n@@ -4148,24 +4141,20 @@ impl<'a> Parser<'a> {\n \n     // Parses a sequence of bounds if a `:` is found,\n     // otherwise returns empty list.\n-    fn parse_colon_then_ty_param_bounds(&mut self,\n-                                        mode: BoundParsingMode)\n-                                        -> PResult<'a, TyParamBounds>\n+    fn parse_colon_then_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n     {\n         if !self.eat(&token::Colon) {\n             Ok(P::new())\n         } else {\n-            self.parse_ty_param_bounds(mode)\n+            self.parse_ty_param_bounds()\n         }\n     }\n \n     // matches bounds    = ( boundseq )?\n     // where   boundseq  = ( polybound + boundseq ) | polybound\n     // and     polybound = ( 'for' '<' 'region '>' )? bound\n     // and     bound     = 'region | trait_ref\n-    fn parse_ty_param_bounds(&mut self,\n-                             mode: BoundParsingMode)\n-                             -> PResult<'a, TyParamBounds>\n+    fn parse_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n     {\n         let mut result = vec![];\n         loop {\n@@ -4187,13 +4176,7 @@ impl<'a> Parser<'a> {\n                 token::ModSep | token::Ident(..) => {\n                     let poly_trait_ref = self.parse_poly_trait_ref()?;\n                     let modifier = if ate_question {\n-                        if mode == BoundParsingMode::Modified {\n-                            TraitBoundModifier::Maybe\n-                        } else {\n-                            self.span_err(question_span,\n-                                          \"unexpected `?`\");\n-                            TraitBoundModifier::None\n-                        }\n+                        TraitBoundModifier::Maybe\n                     } else {\n                         TraitBoundModifier::None\n                     };\n@@ -4215,7 +4198,7 @@ impl<'a> Parser<'a> {\n         let span = self.span;\n         let ident = self.parse_ident()?;\n \n-        let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Modified)?;\n+        let bounds = self.parse_colon_then_ty_param_bounds()?;\n \n         let default = if self.check(&token::Eq) {\n             self.bump();\n@@ -4439,7 +4422,7 @@ impl<'a> Parser<'a> {\n                     let bounded_ty = self.parse_ty()?;\n \n                     if self.eat(&token::Colon) {\n-                        let bounds = self.parse_ty_param_bounds(BoundParsingMode::Bare)?;\n+                        let bounds = self.parse_ty_param_bounds()?;\n                         let hi = self.prev_span.hi;\n                         let span = mk_sp(lo, hi);\n \n@@ -4901,7 +4884,7 @@ impl<'a> Parser<'a> {\n         let mut tps = self.parse_generics()?;\n \n         // Parse supertrait bounds.\n-        let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare)?;\n+        let bounds = self.parse_colon_then_ty_param_bounds()?;\n \n         tps.where_clause = self.parse_where_clause()?;\n "}, {"sha": "f10526200ff141c675cda3b11162dff196f11ba7", "filename": "src/test/compile-fail/maybe-bounds-where-cpass.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where-cpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where-cpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where-cpass.rs?ref=1c448574bc668b0de70ed75223bf8798d17bf058", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+struct S<T>(*const T) where T: ?Sized;\n+\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n+    let u = vec![1, 2, 3];\n+    let _s: S<[u8]> = S(&u[..]);\n+}"}, {"sha": "211fac2ee234c2c047d8f7c0df3a1e809d1b331f", "filename": "src/test/compile-fail/maybe-bounds-where.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where.rs?ref=1c448574bc668b0de70ed75223bf8798d17bf058", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S1<T>(T) where (T): ?Sized;\n+//~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+struct S2<T>(T) where u8: ?Sized;\n+//~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+struct S3<T>(T) where &'static T: ?Sized;\n+//~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+trait Trait<'a> {}\n+\n+struct S4<T>(T) where for<'a> T: ?Trait<'a>;\n+//~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+struct S5<T>(*const T) where T: ?Trait<'static> + ?Sized;\n+//~^ ERROR type parameter has more than one relaxed default bound\n+//~| WARN default bound relaxed for a type parameter\n+\n+impl<T> S1<T> {\n+    fn f() where T: ?Sized {}\n+    //~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+}\n+\n+fn main() {\n+    let u = vec![1, 2, 3];\n+    let _s: S5<[u8]> = S5(&u[..]); // OK\n+}"}, {"sha": "b0b412bbf89ecc37657608cf734f1be909b812af", "filename": "src/test/compile-fail/maybe-bounds.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c448574bc668b0de70ed75223bf8798d17bf058/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds.rs?ref=1c448574bc668b0de70ed75223bf8798d17bf058", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Tr: ?Sized {} //~ ERROR `?Trait` is not permitted in supertraits\n+                    //~^ NOTE traits are `?Sized` by default\n+\n+type A1 = Tr + ?Sized; //~ ERROR `?Trait` is not permitted in trait object types\n+type A2 = for<'a> Tr + ?Sized; //~ ERROR `?Trait` is not permitted in trait object types\n+\n+fn main() {}"}]}