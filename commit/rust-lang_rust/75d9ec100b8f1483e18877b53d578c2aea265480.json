{"sha": "75d9ec100b8f1483e18877b53d578c2aea265480", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZDllYzEwMGI4ZjE0ODNlMTg4NzdiNTNkNTc4YzJhZWEyNjU0ODA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-08T06:29:20Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-08T06:29:20Z"}, "message": "Merge pull request #2545 from mozilla/incoming\n\nIncoming", "tree": {"sha": "f1e1eba060d897bc2bafdc419d1fae37ca23f634", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1e1eba060d897bc2bafdc419d1fae37ca23f634"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75d9ec100b8f1483e18877b53d578c2aea265480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75d9ec100b8f1483e18877b53d578c2aea265480", "html_url": "https://github.com/rust-lang/rust/commit/75d9ec100b8f1483e18877b53d578c2aea265480", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75d9ec100b8f1483e18877b53d578c2aea265480/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95b9d538b8bda04e222c95d478b97c19d77bb5c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b9d538b8bda04e222c95d478b97c19d77bb5c6", "html_url": "https://github.com/rust-lang/rust/commit/95b9d538b8bda04e222c95d478b97c19d77bb5c6"}, {"sha": "cdcae39ba37b212d4f85e251082205cedc6b38ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdcae39ba37b212d4f85e251082205cedc6b38ef", "html_url": "https://github.com/rust-lang/rust/commit/cdcae39ba37b212d4f85e251082205cedc6b38ef"}], "stats": {"total": 488, "additions": 274, "deletions": 214}, "files": [{"sha": "b2e6446d7ee01961638a33420ba4211558347a3d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -12,16 +12,16 @@ type path = [path_elt];\n fn path_to_str_with_sep(p: path, sep: str) -> str {\n     let strs = vec::map(p) {|e|\n         alt e {\n-          path_mod(s) { s }\n-          path_name(s) { s }\n+          path_mod(s) { /* FIXME: bad */ copy s }\n+          path_name(s) { /* FIXME: bad */ copy s }\n         }\n     };\n     str::connect(strs, sep)\n }\n \n fn path_ident_to_str(p: path, i: ident) -> str {\n     if vec::is_empty(p) {\n-        i\n+        /* FIXME: bad */ copy i\n     } else {\n         #fmt[\"%s::%s\", path_to_str(p), i]\n     }\n@@ -59,7 +59,7 @@ type ctx = {map: map, mut path: path,\n             mut local_id: uint, diag: span_handler};\n type vt = visit::vt<ctx>;\n \n-fn extend(cx: ctx, elt: str) -> @path {\n+fn extend(cx: ctx, +elt: str) -> @path {\n     @(cx.path + [path_name(elt)])\n }\n \n@@ -89,15 +89,15 @@ fn map_crate(diag: span_handler, c: crate) -> map {\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n fn map_decoded_item(diag: span_handler,\n-                    map: map, path: path, ii: inlined_item) {\n+                    map: map, +path: path, ii: inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.  (In particular, I think these ids are only used in\n     // alias analysis, which we will not be running on the inlined items, and\n     // even if we did I think it only needs an ordering between local\n     // variables that are simultaneously in scope).\n     let cx = {map: map,\n-              mut path: path,\n+              mut path: /* FIXME: bad */ copy path,\n               mut local_id: 0u,\n               diag: diag};\n     let v = mk_ast_map_visitor();\n@@ -123,21 +123,27 @@ fn map_decoded_item(diag: span_handler,\n fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n           sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n     for decl.inputs.each {|a|\n-        cx.map.insert(a.id, node_arg(a, cx.local_id));\n+        cx.map.insert(a.id, node_arg(/* FIXME: bad */ copy a, cx.local_id));\n         cx.local_id += 1u;\n     }\n     alt fk {\n       visit::fk_ctor(nm, tps, self_id, parent_id) {\n-          let ct = @{node: {id: id, self_id: self_id,\n-                           dec: decl, body: body},\n+          let ct = @{node: {id: id,\n+                            self_id: self_id,\n+                            dec: /* FIXME: bad */ copy decl,\n+                            body: /* FIXME: bad */ copy body},\n                     span: sp};\n-          cx.map.insert(id, node_ctor(nm, tps, class_ctor(ct, parent_id),\n-                                      @cx.path));\n+          cx.map.insert(id, node_ctor(/* FIXME: bad */ copy nm,\n+                                      /* FIXME: bad */ copy tps,\n+                                      class_ctor(ct, parent_id),\n+                                      @/* FIXME: bad */ copy cx.path));\n        }\n       visit::fk_dtor(tps, self_id, parent_id) {\n-          let dt = @{node: {id: id, self_id: self_id, body: body},\n-                    span: sp};\n-          cx.map.insert(id, node_dtor(tps, dt, parent_id, @cx.path));\n+          let dt = @{node: {id: id, self_id: self_id,\n+                     body: /* FIXME: bad */ copy body}, span: sp};\n+          cx.map.insert(id, node_dtor(/* FIXME: bad */ copy tps, dt,\n+                                      parent_id,\n+                                      @/* FIXME: bad */ copy cx.path));\n        }\n \n        _ {}\n@@ -146,7 +152,7 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n }\n \n fn map_block(b: blk, cx: ctx, v: vt) {\n-    cx.map.insert(b.node.id, node_block(b));\n+    cx.map.insert(b.node.id, node_block(/* FIXME: bad */ copy b));\n     visit::visit_block(b, cx, v);\n }\n \n@@ -180,25 +186,29 @@ fn map_method(impl_did: def_id, impl_path: @path,\n }\n \n fn map_item(i: @item, cx: ctx, v: vt) {\n-    let item_path = @cx.path;\n+    let item_path = @/* FIXME: bad */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     alt i.node {\n       item_impl(_, _, _, _, ms) {\n         let impl_did = ast_util::local_def(i.id);\n         for ms.each {|m|\n-            map_method(impl_did, extend(cx, i.ident), m, cx);\n+            map_method(impl_did, extend(cx, /* FIXME: bad */ copy i.ident), m,\n+                       cx);\n         }\n       }\n       item_res(decl, tps, _, dtor_id, ctor_id, _) {\n-        cx.map.insert(ctor_id, node_ctor(i.ident, tps,\n-                                         res_ctor(decl, ctor_id, i.span),\n+        cx.map.insert(ctor_id, node_ctor(/* FIXME: bad */ copy i.ident,\n+                                         /* FIXME: bad */ copy tps,\n+                                         res_ctor(/* FIXME: bad */ copy decl,\n+                                                  ctor_id, i.span),\n                                          item_path));\n         cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n       item_enum(vs, _, _) {\n         for vs.each {|v|\n             cx.map.insert(v.node.id, node_variant(\n-                v, i, extend(cx, i.ident)));\n+                /* FIXME: bad */ copy v, i,\n+                extend(cx, /* FIXME: bad */ copy i.ident)));\n         }\n       }\n       item_native_mod(nm) {\n@@ -207,7 +217,9 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           either::right(abi) { abi }\n         };\n         for nm.items.each {|nitem|\n-            cx.map.insert(nitem.id, node_native_item(nitem, abi, @cx.path));\n+            cx.map.insert(nitem.id,\n+                          node_native_item(nitem, abi,\n+                                           @/* FIXME: bad */ copy cx.path));\n         }\n       }\n       item_class(tps, ifces, items, ctor, dtor, _) {\n@@ -217,17 +229,17 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           vec::iter(ifces) {|p| cx.map.insert(p.id,\n                                   node_item(i, item_path)); };\n           let d_id = ast_util::local_def(i.id);\n-          let p = extend(cx, i.ident);\n+          let p = extend(cx, /* FIXME: bad */ copy i.ident);\n            // only need to handle methods\n           vec::iter(ms) {|m| map_method(d_id, p, m, cx); }\n       }\n       _ { }\n     }\n     alt i.node {\n       item_mod(_) | item_native_mod(_) {\n-        cx.path += [path_mod(i.ident)];\n+        cx.path += [path_mod(/* FIXME: bad */ copy i.ident)];\n       }\n-      _ { cx.path += [path_name(i.ident)]; }\n+      _ { cx.path += [path_name(/* FIXME: bad */ copy i.ident)]; }\n     }\n     visit::visit_item(i, cx, v);\n     vec::pop(cx.path);\n@@ -238,7 +250,7 @@ fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n       view_item_export(vps) {\n         for vps.each {|vp|\n             let (id, name) = alt vp.node {\n-              view_path_simple(nm, _, id) { (id, nm) }\n+              view_path_simple(nm, _, id) { (id, /* FIXME: bad */ copy nm) }\n               view_path_glob(pth, id) | view_path_list(pth, _, id) {\n                 (id, path_to_ident(pth))\n               }"}, {"sha": "c81f6d9590fcbb1ee4999609f5cc685a5609f4c5", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -156,7 +156,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n             for variants.each {|v|\n                 if v.node.name == i {\n                    local = true;\n-                   parent_enum = some(it.ident);\n+                   parent_enum = some(/* FIXME: bad */ copy it.ident);\n                 }\n             }\n           }\n@@ -247,12 +247,12 @@ fn block_from_expr(e: @expr) -> blk {\n     ret {node: blk_, span: e.span};\n }\n \n-fn default_block(stmts1: [@stmt], expr1: option<@expr>, id1: node_id) ->\n+fn default_block(+stmts1: [@stmt], expr1: option<@expr>, id1: node_id) ->\n    blk_ {\n     {view_items: [], stmts: stmts1, expr: expr1, id: id1, rules: default_blk}\n }\n \n-fn ident_to_path(s: span, i: ident) -> @path {\n+fn ident_to_path(s: span, +i: ident) -> @path {\n     @{span: s, global: false, idents: [i],\n       rp: none, types: []}\n }\n@@ -265,7 +265,7 @@ pure fn is_unguarded(&&a: arm) -> bool {\n }\n \n pure fn unguarded_pat(a: arm) -> option<[@pat]> {\n-    if is_unguarded(a) { some(a.pats) } else { none }\n+    if is_unguarded(a) { some(/* FIXME: bad */ copy a.pats) } else { none }\n }\n \n // Provides an extra node_id to hang callee information on, in case the\n@@ -275,8 +275,8 @@ fn op_expr_callee_id(e: @expr) -> node_id { e.id - 1 }\n \n pure fn class_item_ident(ci: @class_member) -> ident {\n     alt ci.node {\n-      instance_var(i,_,_,_,_) { i }\n-      class_method(it) { it.ident }\n+      instance_var(i,_,_,_,_) { /* FIXME: bad */ copy i }\n+      class_method(it) { /* FIXME: bad */ copy it.ident }\n     }\n }\n \n@@ -294,7 +294,11 @@ fn split_class_items(cs: [@class_member]) -> ([ivar], [@method]) {\n     for cs.each {|c|\n       alt c.node {\n         instance_var(i, t, cm, id, vis) {\n-          vs += [{ident: i, ty: t, cm: cm, id: id, vis: vis}];\n+          vs += [{ident: /* FIXME: bad */ copy i,\n+                  ty: t,\n+                  cm: cm,\n+                  id: id,\n+                  vis: vis}];\n         }\n         class_method(m) { ms += [m]; }\n       }\n@@ -312,10 +316,10 @@ pure fn class_member_visibility(ci: @class_member) -> visibility {\n impl inlined_item_methods for inlined_item {\n     fn ident() -> ident {\n         alt self {\n-          ii_item(i) { i.ident }\n-          ii_native(i) { i.ident }\n-          ii_method(_, m) { m.ident }\n-          ii_ctor(_, nm, _, _) { nm }\n+          ii_item(i) { /* FIXME: bad */ copy i.ident }\n+          ii_native(i) { /* FIXME: bad */ copy i.ident }\n+          ii_method(_, m) { /* FIXME: bad */ copy m.ident }\n+          ii_ctor(_, nm, _, _) { /* FIXME: bad */ copy nm }\n         }\n     }\n "}, {"sha": "af780bc5e383605a006ca521dff7137d0d46ff65", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -46,21 +46,22 @@ export require_unique_names;\n \n /* Constructors */\n \n-fn mk_name_value_item_str(name: ast::ident, value: str) -> @ast::meta_item {\n+fn mk_name_value_item_str(+name: ast::ident, +value: str) -> @ast::meta_item {\n     let value_lit = dummy_spanned(ast::lit_str(value));\n     ret mk_name_value_item(name, value_lit);\n }\n \n-fn mk_name_value_item(name: ast::ident, value: ast::lit) -> @ast::meta_item {\n+fn mk_name_value_item(+name: ast::ident, +value: ast::lit)\n+        -> @ast::meta_item {\n     ret @dummy_spanned(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(name: ast::ident, items: [@ast::meta_item]) ->\n+fn mk_list_item(+name: ast::ident, +items: [@ast::meta_item]) ->\n    @ast::meta_item {\n     ret @dummy_spanned(ast::meta_list(name, items));\n }\n \n-fn mk_word_item(name: ast::ident) -> @ast::meta_item {\n+fn mk_word_item(+name: ast::ident) -> @ast::meta_item {\n     ret @dummy_spanned(ast::meta_word(name));\n }\n \n@@ -89,9 +90,9 @@ fn get_attr_name(attr: ast::attribute) -> ast::ident {\n \n fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     alt meta.node {\n-      ast::meta_word(n) { n }\n-      ast::meta_name_value(n, _) { n }\n-      ast::meta_list(n, _) { n }\n+      ast::meta_word(n) { /* FIXME bad */ copy n }\n+      ast::meta_name_value(n, _) { /* FIXME bad */ copy n }\n+      ast::meta_list(n, _) { /* FIXME bad */ copy n }\n     }\n }\n \n@@ -102,7 +103,14 @@ containing a string, otherwise none\n fn get_meta_item_value_str(meta: @ast::meta_item) -> option<str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n-        alt v.node { ast::lit_str(s) { option::some(s) } _ { option::none } }\n+        alt v.node {\n+            ast::lit_str(s) {\n+                option::some(/* FIXME bad */ copy s)\n+            }\n+            _ {\n+                option::none\n+            }\n+        }\n       }\n       _ { option::none }\n     }\n@@ -111,7 +119,7 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> option<str> {\n #[doc = \"Gets a list of inner meta items from a list meta_item type\"]\n fn get_meta_item_list(meta: @ast::meta_item) -> option<[@ast::meta_item]> {\n     alt meta.node {\n-      ast::meta_list(_, l) { option::some(l) }\n+      ast::meta_list(_, l) { option::some(/* FIXME bad */ copy l) }\n       _ { option::none }\n     }\n }\n@@ -126,7 +134,7 @@ fn get_name_value_str_pair(\n     alt attr::get_meta_item_value_str(item) {\n       some(value) {\n         let name = attr::get_meta_item_name(item);\n-        some((name, value))\n+        some((name, /* FIXME bad */ copy value))\n       }\n       none { none }\n     }\n@@ -138,7 +146,7 @@ fn get_name_value_str_pair(\n #[doc = \"\n Search a list of attributes and return only those with a specific name\n \"]\n-fn find_attrs_by_name(attrs: [ast::attribute], name: ast::ident) ->\n+fn find_attrs_by_name(attrs: [ast::attribute], +name: ast::ident) ->\n    [ast::attribute] {\n     let filter = (\n         fn@(a: ast::attribute) -> option<ast::attribute> {\n@@ -153,7 +161,7 @@ fn find_attrs_by_name(attrs: [ast::attribute], name: ast::ident) ->\n #[doc = \"\n Searcha list of meta items and return only those with a specific name\n \"]\n-fn find_meta_items_by_name(metas: [@ast::meta_item], name: ast::ident) ->\n+fn find_meta_items_by_name(metas: [@ast::meta_item], +name: ast::ident) ->\n    [@ast::meta_item] {\n     let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n         if get_meta_item_name(m) == name {\n@@ -201,16 +209,16 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains_name(metas: [@ast::meta_item], name: ast::ident) -> bool {\n+fn contains_name(metas: [@ast::meta_item], +name: ast::ident) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     ret vec::len(matches) > 0u;\n }\n \n-fn attrs_contains_name(attrs: [ast::attribute], name: ast::ident) -> bool {\n+fn attrs_contains_name(attrs: [ast::attribute], +name: ast::ident) -> bool {\n     vec::is_not_empty(find_attrs_by_name(attrs, name))\n }\n \n-fn first_attr_value_str_by_name(attrs: [ast::attribute], name: ast::ident)\n+fn first_attr_value_str_by_name(attrs: [ast::attribute], +name: ast::ident)\n     -> option<str> {\n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n@@ -221,20 +229,20 @@ fn first_attr_value_str_by_name(attrs: [ast::attribute], name: ast::ident)\n \n fn last_meta_item_by_name(\n     items: [@ast::meta_item],\n-    name: str\n+    +name: str\n ) -> option<@ast::meta_item> {\n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n fn last_meta_item_value_str_by_name(\n     items: [@ast::meta_item],\n-    name: str\n+    +name: str\n ) -> option<str> {\n     alt last_meta_item_by_name(items, name) {\n       some(item) {\n         alt attr::get_meta_item_value_str(item) {\n-          some(value) { some(value) }\n+          some(value) { some(/* FIXME bad */ copy value) }\n           none { none }\n         }\n       }\n@@ -244,7 +252,7 @@ fn last_meta_item_value_str_by_name(\n \n fn last_meta_item_list_by_name(\n     items: [@ast::meta_item],\n-    name: str\n+    +name: str\n ) -> option<[@ast::meta_item]> {\n     alt last_meta_item_by_name(items, name) {\n       some(item) {\n@@ -259,13 +267,13 @@ fn last_meta_item_list_by_name(\n \n // FIXME: This needs to sort by meta_item variant in addition to the item name\n // (See [Fixme-sorting])\n-fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n+fn sort_meta_items(+items: [@ast::meta_item]) -> [@ast::meta_item] {\n     fn lteq(&&ma: @ast::meta_item, &&mb: @ast::meta_item) -> bool {\n         fn key(m: @ast::meta_item) -> ast::ident {\n             alt m.node {\n-              ast::meta_word(name) { name }\n-              ast::meta_name_value(name, _) { name }\n-              ast::meta_list(name, _) { name }\n+              ast::meta_word(name) { /* FIXME bad */ copy name }\n+              ast::meta_name_value(name, _) { /* FIXME bad */ copy name }\n+              ast::meta_list(name, _) { /* FIXME bad */ copy name }\n             }\n         }\n         ret key(ma) <= key(mb);\n@@ -280,13 +288,14 @@ fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->\n    [@ast::meta_item] {\n \n-    let filter = fn@(&&item: @ast::meta_item) -> option<@ast::meta_item> {\n+    ret vec::filter_map(items, {\n+        |item|\n         if get_meta_item_name(item) != name {\n-            option::some(item)\n-        } else { option::none }\n-    };\n-\n-    ret vec::filter_map(items, filter);\n+            option::some(/* FIXME bad */ copy item)\n+        } else {\n+            option::none\n+        }\n+    });\n }\n \n fn find_linkage_attrs(attrs: [ast::attribute]) -> [ast::attribute] {\n@@ -307,7 +316,7 @@ linkage\n fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n     find_linkage_attrs(attrs).flat_map {|attr|\n         alt check attr.node.value.node {\n-          ast::meta_list(_, items) { items }\n+          ast::meta_list(_, items) { /* FIXME bad */ copy items }\n         }\n     }\n }\n@@ -362,6 +371,8 @@ fn require_unique_names(diagnostic: span_handler,\n     let map = map::str_hash();\n     for metas.each {|meta|\n         let name = get_meta_item_name(meta);\n+\n+        // FIXME: How do I silence the warnings? --pcw\n         if map.contains_key(name) {\n             diagnostic.span_fatal(meta.span,\n                                   #fmt[\"duplicate meta item `%s`\", name]);"}, {"sha": "97911f9d8b88105b525f13054cebca96322a06eb", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -51,7 +51,7 @@ type loc = {file: filemap, line: uint, col: uint};\n \n fn new_codemap() -> codemap { @{files: dvec()} }\n \n-fn new_filemap_w_substr(filename: filename, substr: file_substr,\n+fn new_filemap_w_substr(+filename: filename, +substr: file_substr,\n                         src: @str,\n                         start_pos_ch: uint, start_pos_byte: uint)\n    -> filemap {\n@@ -60,7 +60,7 @@ fn new_filemap_w_substr(filename: filename, substr: file_substr,\n           mut lines: [{ch: start_pos_ch, byte: start_pos_byte}]};\n }\n \n-fn new_filemap(filename: filename, src: @str,\n+fn new_filemap(+filename: filename, src: @str,\n                start_pos_ch: uint, start_pos_byte: uint)\n     -> filemap {\n     ret new_filemap_w_substr(filename, fss_none, src,\n@@ -123,14 +123,16 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n     let loc = lookup_char_pos(map, pos);\n     alt (loc.file.substr) {\n       fss_none {\n-        {filename: loc.file.name, line: loc.line, col: loc.col,\n+        {filename: /* FIXME bad */ copy loc.file.name,\n+         line: loc.line,\n+         col: loc.col,\n          file: some(loc.file)}\n       }\n       fss_internal(sp) {\n         lookup_char_pos_adj(map, sp.lo + (pos - loc.file.start_pos.ch))\n       }\n       fss_external(eloc) {\n-        {filename: eloc.filename,\n+        {filename: /* FIXME bad */ copy eloc.filename,\n          line: eloc.line + loc.line - 1u,\n          col: if loc.line == 1u {eloc.col + loc.col} else {loc.col},\n          file: none}\n@@ -176,7 +178,7 @@ type file_lines = {file: filemap, lines: [uint]};\n \n fn span_to_filename(sp: span, cm: codemap::codemap) -> filename {\n     let lo = lookup_char_pos(cm, sp.lo);\n-    ret lo.file.name;\n+    ret /* FIXME bad */ copy lo.file.name;\n }\n \n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {"}, {"sha": "b65c6524d120627f258085f5ee8f8e9df653bdde", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -201,7 +201,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     // arbitrarily only print up to six lines of the error\n     let max_lines = 6u;\n     let mut elided = false;\n-    let mut display_lines = lines.lines;\n+    let mut display_lines = /* FIXME bad */ copy lines.lines;\n     if vec::len(display_lines) > max_lines {\n         display_lines = vec::slice(display_lines, 0u, max_lines);\n         elided = true;\n@@ -250,9 +250,11 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n \n fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n     option::iter (sp.expn_info) {|ei|\n-        let ss = option::map_default(ei.callie.span, \"\",\n-                               bind codemap::span_to_str(_, cm));\n-        print_diagnostic(ss, note,\n+        let ss = option::map_default(ei.callie.span, @\"\", {\n+            |span|\n+            @codemap::span_to_str(span, cm)\n+        });\n+        print_diagnostic(*ss, note,\n                          #fmt(\"in expansion of #%s\", ei.callie.name));\n         let ss = codemap::span_to_str(ei.call_site, cm);\n         print_diagnostic(ss, note, \"expansion site\");"}, {"sha": "0680194ea6b4b079c50b19b28643dd66359bc5fd", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -34,8 +34,9 @@ fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), \"file\");\n-    let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n-    ret make_new_lit(cx, sp, ast::lit_str(loc.file.name));\n+    let { file: @{ name: filename, _ }, _ } =\n+        codemap::lookup_char_pos(cx.codemap(), sp.lo);\n+    ret make_new_lit(cx, sp, ast::lit_str(filename));\n }\n \n fn expand_stringify(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n@@ -66,12 +67,15 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     let file = expr_to_str(cx, args[0], \"#include_str requires a string\");\n \n-    alt io::read_whole_file_str(res_rel_file(cx, sp, file)) {\n-      result::ok(src) { ret make_new_lit(cx, sp, ast::lit_str(src)); }\n+    let res = io::read_whole_file_str(res_rel_file(cx, sp, file));\n+    alt res {\n+      result::ok(_) { /* Continue. */ }\n       result::err(e) {\n-        cx.parse_sess().span_diagnostic.handler().fatal(e)\n+        cx.parse_sess().span_diagnostic.handler().fatal(e);\n       }\n     }\n+\n+    ret make_new_lit(cx, sp, ast::lit_str(result::unwrap(res)));\n }\n \n fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n@@ -93,7 +97,7 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     }\n }\n \n-fn res_rel_file(cx: ext_ctxt, sp: codemap::span, arg: path) -> path {\n+fn res_rel_file(cx: ext_ctxt, sp: codemap::span, +arg: path) -> path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !path::path_is_absolute(arg) {\n         let cu = codemap::span_to_filename(sp, cx.codemap());"}, {"sha": "04a3c95ce1c0e010244331c179666cc4caad18e7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -88,10 +88,11 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n                   let fold_meta_item = bind fold_meta_item_(_, fld);\n-                  meta_list(id, vec::map(mis, fold_meta_item))\n+                  meta_list(/* FIXME: bad */ copy id,\n+                            vec::map(mis, fold_meta_item))\n                 }\n                 meta_name_value(id, s) {\n-                  meta_name_value(fld.fold_ident(id), s)\n+                  meta_name_value(fld.fold_ident(id), /* FIXME: bad */ copy s)\n                 }\n               },\n           span: fld.new_span(mi.span)};\n@@ -121,8 +122,8 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n                mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n                mac_embed_block(blk) { mac_embed_block(fld.fold_block(blk)) }\n                mac_ellipsis { mac_ellipsis }\n-               mac_aq(_,_) { /* fixme */ m.node }\n-               mac_var(_) { /* fixme */ m.node }\n+               mac_aq(_,_) { /* FIXME: bad */ copy m.node }\n+               mac_var(_) { /* FIXME: bad */ copy m.node }\n              },\n          span: fld.new_span(m.span)};\n }\n@@ -143,7 +144,7 @@ fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n }\n \n fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n-    {ident: tp.ident,\n+    {ident: /* FIXME: bad */ copy tp.ident,\n      id: fld.new_id(tp.id),\n      bounds: @vec::map(*tp.bounds, fold_ty_param_bound(_, fld))}\n }\n@@ -166,19 +167,20 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n    crate_directive_ {\n     ret alt cd {\n           cdir_src_mod(id, attrs) {\n-            cdir_src_mod(fld.fold_ident(id), attrs)\n+            cdir_src_mod(fld.fold_ident(id), /* FIXME: bad */ copy attrs)\n           }\n           cdir_dir_mod(id, cds, attrs) {\n             cdir_dir_mod(fld.fold_ident(id),\n-                         vec::map(cds, fld.fold_crate_directive), attrs)\n+                         vec::map(cds, fld.fold_crate_directive),\n+                         /* FIXME: bad */ copy attrs)\n           }\n           cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n-          cdir_syntax(_) { cd }\n+          cdir_syntax(_) { copy cd }\n         }\n }\n \n fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n-    ret vi;\n+    ret /* FIXME: bad */ copy vi;\n }\n \n \n@@ -220,7 +222,8 @@ fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n     -> @class_member {\n     @{node: alt ci.node {\n         instance_var(ident, t, cm, id, p) {\n-           instance_var(ident, fld.fold_ty(t), cm, id, p)\n+           instance_var(/* FIXME: bad */ copy ident, fld.fold_ty(t), cm, id,\n+                        p)\n         }\n         class_method(m) { class_method(fld.fold_method(m)) }\n       },\n@@ -256,7 +259,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                         id: dtor_id with dtor.node}\n                     with dtor}};\n               item_class(\n-                  typms,\n+                  /* FIXME: bad */ copy typms,\n                   vec::map(ifaces, {|p| fold_iface_ref(p, fld) }),\n                   vec::map(items, fld.fold_class_item),\n                   {node: {body: ctor_body,\n@@ -274,7 +277,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_iface(tps, rp, methods) {\n             item_iface(fold_ty_params(tps, fld),\n                        rp,\n-                       methods)\n+                       /* FIXME: bad */ copy methods)\n           }\n           item_res(decl, typms, body, did, cid, rp) {\n             item_res(fold_fn_decl(decl, fld),\n@@ -293,7 +296,7 @@ fn fold_iface_ref(&&p: @iface_ref, fld: ast_fold) -> @iface_ref {\n \n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n     ret @{ident: fld.fold_ident(m.ident),\n-          attrs: m.attrs,\n+          attrs: /* FIXME: bad */ copy m.attrs,\n           tps: fold_ty_params(m.tps, fld),\n           decl: fold_fn_decl(m.decl, fld),\n           body: fld.fold_block(m.body),\n@@ -328,7 +331,7 @@ fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     ret alt p {\n-          pat_wild { p }\n+          pat_wild { pat_wild }\n           pat_ident(pth, sub) {\n             pat_ident(fld.fold_path(pth), option::map(sub, fld.fold_pat))\n           }\n@@ -340,7 +343,8 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_rec(fields, etc) {\n             let mut fs = [];\n             for fields.each {|f|\n-                fs += [{ident: f.ident, pat: fld.fold_pat(f.pat)}];\n+                fs += [{ident: /* FIXME: bad */ copy f.ident,\n+                        pat: fld.fold_pat(f.pat)}];\n             }\n             pat_rec(fs, etc)\n           }\n@@ -410,7 +414,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_unary(binop, ohs) { expr_unary(binop, fld.fold_expr(ohs)) }\n           expr_loop_body(f) { expr_loop_body(fld.fold_expr(f)) }\n-          expr_lit(_) { e }\n+          expr_lit(_) { copy e }\n           expr_cast(expr, ty) { expr_cast(fld.fold_expr(expr), ty) }\n           expr_addr_of(m, ohs) { expr_addr_of(m, fld.fold_expr(ohs)) }\n           expr_if(cond, tr, fl) {\n@@ -462,7 +466,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_path(pth) { expr_path(fld.fold_path(pth)) }\n           expr_fail(e) { expr_fail(option::map(e, fld.fold_expr)) }\n-          expr_break | expr_cont { e }\n+          expr_break | expr_cont { copy e }\n           expr_ret(e) { expr_ret(option::map(e, fld.fold_expr)) }\n           expr_log(i, lv, e) { expr_log(i, fld.fold_expr(lv),\n                                         fld.fold_expr(e)) }\n@@ -487,7 +491,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n          span: fld.new_span(f.span)}\n     }\n     alt t {\n-      ty_nil | ty_bot {t}\n+      ty_nil | ty_bot | ty_infer {copy t}\n       ty_box(mt) {ty_box(fold_mt(mt, fld))}\n       ty_uniq(mt) {ty_uniq(fold_mt(mt, fld))}\n       ty_vec(mt) {ty_vec(fold_mt(mt, fld))}\n@@ -501,17 +505,18 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n                                 vec::map(constrs, fld.fold_ty_constr))}\n       ty_vstore(t, vs) {ty_vstore(fld.fold_ty(t), vs)}\n       ty_mac(mac) {ty_mac(fold_mac(mac))}\n-      ty_infer {t}\n     }\n }\n \n fn noop_fold_constr(c: constr_, fld: ast_fold) -> constr_ {\n-    {path: fld.fold_path(c.path), args: c.args, id: fld.new_id(c.id)}\n+    {path: fld.fold_path(c.path), args: /* FIXME: bad */ copy c.args,\n+     id: fld.new_id(c.id)}\n }\n \n fn noop_fold_ty_constr(c: ty_constr_, fld: ast_fold) -> ty_constr_ {\n     let rslt: ty_constr_ =\n-        {path: fld.fold_path(c.path), args: c.args, id: fld.new_id(c.id)};\n+        {path: fld.fold_path(c.path), args: /* FIXME: bad */ copy c.args,\n+         id: fld.new_id(c.id)};\n     rslt\n }\n // ...nor do modules\n@@ -539,14 +544,16 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n       some(e) {some(fld.fold_expr(e))}\n       none {none}\n     };\n-    ret {name: v.name,\n+    ret {name: /* FIXME: bad */ copy v.name,\n          attrs: attrs,\n          args: args, id: fld.new_id(v.id),\n          disr_expr: de,\n          vis: v.vis};\n }\n \n-fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident { ret i; }\n+fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {\n+    ret /* FIXME: bad */ copy i;\n+}\n \n fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n     ret {span: fld.new_span(p.span), global: p.global,\n@@ -639,8 +646,8 @@ impl of ast_fold for ast_fold_precursor {\n     fn fold_class_item(&&ci: @class_member) -> @class_member {\n         @{node: alt ci.node {\n            instance_var(nm, t, mt, id, p) {\n-               instance_var(nm, (self as ast_fold).fold_ty(t),\n-                            mt, id, p)\n+               instance_var(/* FIXME: bad */ copy nm,\n+                            (self as ast_fold).fold_ty(t), mt, id, p)\n            }\n            class_method(m) {\n                class_method(self.fold_method(m, self as ast_fold))"}, {"sha": "65f7de6ea160867237bc89f789f8b0e526a24681", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -46,14 +46,11 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n     let lo = p.span.lo;\n     let prefix = path::dirname(p.reader.filemap.name);\n     let leading_attrs = p.parse_inner_attrs_and_next();\n-    let crate_attrs = leading_attrs.inner;\n-    let first_cdir_attr = leading_attrs.next;\n+    let { inner: crate_attrs, next: first_cdir_attr } = leading_attrs;\n     let cdirs = p.parse_crate_directives(token::EOF, first_cdir_attr);\n     sess.chpos = p.reader.chpos;\n     sess.byte_pos = sess.byte_pos + p.reader.pos;\n-    let cx =\n-        @{sess: sess,\n-          cfg: p.cfg};\n+    let cx = @{sess: sess, cfg: /* FIXME: bad */ copy p.cfg};\n     let (companionmod, _) = path::splitext(path::basename(input));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n         cx, cdirs, prefix, option::some(companionmod));\n@@ -63,7 +60,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n                           {directives: cdirs,\n                            module: m,\n                            attrs: crate_attrs + attrs,\n-                           config: p.cfg});\n+                           config: /* FIXME: bad */ copy p.cfg});\n }\n \n fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,\n@@ -131,7 +128,7 @@ fn next_node_id(sess: parse_sess) -> node_id {\n }\n \n fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n-                              name: str, ss: codemap::file_substr,\n+                              +name: str, +ss: codemap::file_substr,\n                               source: @str) -> parser {\n     let ftype = parser::SOURCE_FILE;\n     let filemap = codemap::new_filemap_w_substr\n@@ -143,20 +140,17 @@ fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n     ret parser(sess, cfg, rdr, ftype);\n }\n \n-fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: str,\n+fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, +path: str,\n                         ftype: parser::file_type) ->\n    parser {\n-    let src = alt io::read_whole_file_str(path) {\n-      result::ok(src) {\n-        // FIXME: This copy is unfortunate (#2319)\n-        @src\n-      }\n-      result::err(e) {\n-        sess.span_diagnostic.handler().fatal(e)\n-      }\n-    };\n-    let filemap = codemap::new_filemap(path, src,\n-                                       sess.chpos, sess.byte_pos);\n+    let res = io::read_whole_file_str(path);\n+    alt res {\n+      result::ok(_) { /* Continue. */ }\n+      result::err(e) { sess.span_diagnostic.handler().fatal(e); }\n+    }\n+    // FIXME: This copy is unfortunate (#2319).\n+    let src = @copy result::unwrap(res);\n+    let filemap = codemap::new_filemap(path, src, sess.chpos, sess.byte_pos);\n     sess.cm.files.push(filemap);\n     let itr = @interner::mk(str::hash, str::eq);\n     let rdr = lexer::new_reader(sess.span_diagnostic, filemap, itr);"}, {"sha": "0c2718c3b4b5850a4615d2092c75699ab3fe2cc5", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -209,6 +209,16 @@ impl parser_common for parser {\n         ret v;\n     }\n \n+    fn parse_unspanned_seq<T: copy>(bra: token::token, ket: token::token,\n+                                    sep: seq_sep, f: fn(parser) -> T) -> [T] {\n+        self.expect(bra);\n+        let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n+        self.bump();\n+        ret result;\n+    }\n+\n+    // NB: Do not use this function unless you actually plan to place the\n+    // spanned list in the AST.\n     fn parse_seq<T: copy>(bra: token::token, ket: token::token, sep: seq_sep,\n                           f: fn(parser) -> T) -> spanned<[T]> {\n         let lo = self.span.lo;\n@@ -218,4 +228,4 @@ impl parser_common for parser {\n         self.bump();\n         ret spanned(lo, hi, result);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "254d5cc5d5d09d626fd6015d698d0e52ab27f816", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -44,7 +44,7 @@ optional suffix then adding the .rs extension.\n fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n     -> ([@ast::view_item], [@ast::item], [ast::attribute]) {\n \n-    fn companion_file(prefix: str, suffix: option<str>) -> str {\n+    fn companion_file(+prefix: str, suffix: option<str>) -> str {\n         ret alt suffix {\n           option::some(s) { path::connect(prefix, s) }\n           option::none { prefix }\n@@ -66,8 +66,7 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n         #debug(\"found companion mod\");\n         let p0 = new_parser_from_file(cx.sess, cx.cfg, modpath, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n-        let first_item_outer_attrs = inner_attrs.next;\n-        let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n+        let m0 = p0.parse_mod_items(token::EOF, inner_attrs.next);\n         cx.sess.chpos = p0.reader.chpos;\n         cx.sess.byte_pos = cx.sess.byte_pos + p0.reader.pos;\n         ret (m0.view_items, m0.items, inner_attrs.inner);\n@@ -102,7 +101,8 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         let first_item_outer_attrs = inner_attrs.next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n \n-        let i = p0.mk_item(cdir.span.lo, cdir.span.hi, id,\n+        let i = p0.mk_item(cdir.span.lo, cdir.span.hi,\n+                           /* FIXME: bad */ copy id,\n                            ast::item_mod(m0), ast::public, mod_attrs);\n         // Thread defids, chpos and byte_pos through the parsers\n         cx.sess.chpos = p0.reader.chpos;\n@@ -118,7 +118,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         let (m0, a0) = eval_crate_directives_to_mod(\n             cx, cdirs, full_path, none);\n         let i =\n-            @{ident: id,\n+            @{ident: /* FIXME: bad */ copy id,\n               attrs: attrs + a0,\n               id: cx.sess.next_id,\n               node: ast::item_mod(m0),"}, {"sha": "df27b2388e07337939d1fc078fe33dad18422b12", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 80, "deletions": 73, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -150,8 +150,8 @@ class parser {\n \n     fn parse_ty_fn_decl(purity: ast::purity) -> fn_decl {\n         let inputs =\n-            self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA)) { |p|\n+            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                     seq_sep(token::COMMA)) { |p|\n             let mode = p.parse_arg_mode();\n             let name = if is_plain_ident(p.token)\n                 && p.look_ahead(1u) == token::COLON {\n@@ -170,13 +170,14 @@ class parser {\n         // story on constrained types.\n         let constrs: [@constr] = [];\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n-        ret {inputs: inputs.node, output: ret_ty,\n+        ret {inputs: inputs, output: ret_ty,\n              purity: purity, cf: ret_style,\n              constraints: constrs};\n     }\n \n     fn parse_ty_methods() -> [ty_method] {\n-        (self.parse_seq(token::LBRACE, token::RBRACE, seq_sep_none()) { |p|\n+        self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n+                                 seq_sep_none()) { |p|\n             let attrs = p.parse_outer_attributes();\n             let flo = p.span.lo;\n             let pur = p.parse_fn_purity();\n@@ -186,7 +187,7 @@ class parser {\n             self.expect(token::SEMI);\n             {ident: ident, attrs: attrs, decl: {purity: pur with d}, tps: tps,\n              span: mk_sp(flo, fhi)}\n-        }).node\n+        }\n     }\n \n     fn parse_mt() -> mt {\n@@ -241,21 +242,21 @@ class parser {\n     fn parse_ty_constr(fn_args: [arg]) -> @constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n-        let args: {node: [@constr_arg], span: span} =\n-            self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA),\n-                           {|p| p.parse_constr_arg(fn_args)});\n-        ret @spanned(lo, args.span.hi,\n-                     {path: path, args: args.node, id: self.get_id()});\n+        let args =\n+            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                     seq_sep(token::COMMA),\n+                                     {|p| p.parse_constr_arg(fn_args)});\n+        ret @spanned(lo, self.span.hi,\n+                     {path: path, args: args, id: self.get_id()});\n     }\n \n     fn parse_constr_in_type() -> @ty_constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n         let args: [@ty_constr_arg] =\n-            self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA),\n-                           {|p| p.parse_type_constr_arg()}).node;\n+            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                     seq_sep(token::COMMA),\n+                                     {|p| p.parse_type_constr_arg()});\n         let hi = self.span.lo;\n         let tc: ty_constr_ = {path: path, args: args, id: self.get_id()};\n         ret @spanned(lo, hi, tc);\n@@ -370,15 +371,15 @@ class parser {\n             self.bump();\n             ty_ptr(self.parse_mt())\n         } else if self.token == token::LBRACE {\n-            let elems = self.parse_seq(token::LBRACE, token::RBRACE,\n-                                       seq_sep_opt(token::COMMA),\n-                                       {|p| p.parse_ty_field()});\n-            if vec::len(elems.node) == 0u {\n+            let elems = self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n+                                                 seq_sep_opt(token::COMMA),\n+                                                 {|p| p.parse_ty_field()});\n+            if vec::len(elems) == 0u {\n                 self.unexpected_last(token::RBRACE);\n             }\n-            let hi = elems.span.hi;\n+            let hi = self.span.hi;\n \n-            let t = ty_rec(elems.node);\n+            let t = ty_rec(elems);\n             if self.token == token::COLON {\n                 self.bump();\n                 ty_constr(@{id: self.get_id(),\n@@ -813,11 +814,11 @@ class parser {\n             ex = ex_ext.node;\n         } else if self.eat_keyword(\"bind\") {\n             let e = self.parse_expr_res(RESTRICT_NO_CALL_EXPRS);\n-            let es = self.parse_seq(token::LPAREN, token::RPAREN,\n-                                    seq_sep(token::COMMA),\n-                                    {|p| p.parse_expr_or_hole()});\n-            hi = es.span.hi;\n-            ex = expr_bind(e, es.node);\n+            let es = self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                              seq_sep(token::COMMA),\n+                                              {|p| p.parse_expr_or_hole()});\n+            hi = self.span.hi;\n+            ex = expr_bind(e, es);\n         } else if self.eat_keyword(\"fail\") {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n@@ -920,37 +921,37 @@ class parser {\n         let sep = seq_sep(token::COMMA);\n         let mut e = none;\n         if (self.token == token::LPAREN || self.token == token::LBRACKET) {\n+            let lo = self.span.lo;\n             let es =\n                 if self.token == token::LPAREN {\n-                self.parse_seq(token::LPAREN, token::RPAREN,\n-                               sep, {|p| p.parse_expr()})\n-        } else {\n-            self.parse_seq(token::LBRACKET, token::RBRACKET,\n-                           sep, {|p| p.parse_expr()})\n-        };\n-        let hi = es.span.hi;\n-        e = some(self.mk_expr(es.span.lo, hi,\n-                              expr_vec(es.node, m_imm)));\n-    }\n-    let mut b = none;\n-    if self.token == token::LBRACE {\n-        self.bump();\n-        let lo = self.span.lo;\n-        let mut depth = 1u;\n-        while (depth > 0u) {\n-            alt (self.token) {\n-              token::LBRACE {depth += 1u;}\n-              token::RBRACE {depth -= 1u;}\n-              token::EOF {self.fatal(\"unexpected EOF in macro body\");}\n-              _ {}\n-            }\n+                    self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                             sep, {|p| p.parse_expr()})\n+                } else {\n+                    self.parse_unspanned_seq(token::LBRACKET, token::RBRACKET,\n+                                             sep, {|p| p.parse_expr()})\n+                };\n+            let hi = self.span.hi;\n+            e = some(self.mk_expr(lo, hi, expr_vec(es, m_imm)));\n+        }\n+        let mut b = none;\n+        if self.token == token::LBRACE {\n             self.bump();\n+            let lo = self.span.lo;\n+            let mut depth = 1u;\n+            while (depth > 0u) {\n+                alt (self.token) {\n+                  token::LBRACE {depth += 1u;}\n+                  token::RBRACE {depth -= 1u;}\n+                  token::EOF {self.fatal(\"unexpected EOF in macro body\");}\n+                  _ {}\n+                }\n+                self.bump();\n+            }\n+            let hi = self.last_span.lo;\n+            b = some({span: mk_sp(lo,hi)});\n         }\n-        let hi = self.last_span.lo;\n-        b = some({span: mk_sp(lo,hi)});\n+        ret self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n     }\n-    ret self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n-}\n \n     fn parse_dot_or_call_expr() -> pexpr {\n         let b = self.parse_bottom_expr();\n@@ -989,16 +990,17 @@ class parser {\n             alt copy self.token {\n               // expr(...)\n               token::LPAREN if self.permits_call() {\n-                let es_opt = self.parse_seq(token::LPAREN, token::RPAREN,\n-                                            seq_sep(token::COMMA),\n-                                            {|p| p.parse_expr_or_hole()});\n-                hi = es_opt.span.hi;\n+                let es_opt =\n+                    self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                             seq_sep(token::COMMA),\n+                                             {|p| p.parse_expr_or_hole()});\n+                hi = self.span.hi;\n \n                 let nd =\n-                    if vec::any(es_opt.node, {|e| option::is_none(e) }) {\n-                    expr_bind(self.to_expr(e), es_opt.node)\n+                    if vec::any(es_opt, {|e| option::is_none(e) }) {\n+                    expr_bind(self.to_expr(e), es_opt)\n             } else {\n-                let es = vec::map(es_opt.node) {|e| option::get(e) };\n+                let es = vec::map(es_opt) {|e| option::get(e) };\n                 expr_call(self.to_expr(e), es, false)\n             };\n             e = self.mk_pexpr(lo, hi, nd);\n@@ -1458,11 +1460,12 @@ class parser {\n                         self.expect(token::RPAREN);\n                       }\n                       _ {\n-                        let a = self.parse_seq(token::LPAREN, token::RPAREN,\n-                                               seq_sep(token::COMMA),\n-                                               {|p| p.parse_pat()});\n-                        args = a.node;\n-                        hi = a.span.hi;\n+                        args =\n+                            self.parse_unspanned_seq(token::LPAREN,\n+                                                     token::RPAREN,\n+                                                     seq_sep(token::COMMA),\n+                                                     {|p| p.parse_pat()});\n+                        hi = self.span.hi;\n                       }\n                     }\n                   }\n@@ -1761,8 +1764,8 @@ class parser {\n         -> (fn_decl, capture_clause) {\n \n         let args_or_capture_items: [arg_or_capture_item] =\n-            self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA), parse_arg_fn).node;\n+            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                     seq_sep(token::COMMA), parse_arg_fn);\n \n         let inputs = either::lefts(args_or_capture_items);\n         let capture_clause = @either::rights(args_or_capture_items);\n@@ -1788,9 +1791,10 @@ class parser {\n             if self.eat(token::OROR) {\n                 []\n             } else {\n-                self.parse_seq(token::BINOP(token::OR),\n-                               token::BINOP(token::OR), seq_sep(token::COMMA),\n-                               {|p| p.parse_fn_block_arg()}).node\n+                self.parse_unspanned_seq(token::BINOP(token::OR),\n+                                         token::BINOP(token::OR),\n+                                         seq_sep(token::COMMA),\n+                                         {|p| p.parse_fn_block_arg()})\n             }\n         };\n         let output = if self.eat(token::RARROW) {\n@@ -2242,10 +2246,12 @@ class parser {\n             let mut args = [], disr_expr = none;\n             if self.token == token::LPAREN {\n                 all_nullary = false;\n-                let arg_tys = self.parse_seq(token::LPAREN, token::RPAREN,\n+                let arg_tys =\n+                    self.parse_unspanned_seq(token::LPAREN,\n+                                             token::RPAREN,\n                                              seq_sep(token::COMMA),\n                                              {|p| p.parse_ty(false)});\n-                for arg_tys.node.each {|ty|\n+                for arg_tys.each {|ty|\n                     args += [{ty: ty, id: self.get_id()}];\n                 }\n             } else if self.eat(token::EQ) {\n@@ -2385,9 +2391,10 @@ class parser {\n                   // foo::bar::{a,b,c}\n                   token::LBRACE {\n                     let idents =\n-                        self.parse_seq(token::LBRACE, token::RBRACE,\n-                                       seq_sep(token::COMMA),\n-                                       {|p| p.parse_path_list_ident()}).node;\n+                        self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n+                                                 seq_sep(token::COMMA),\n+                                                 {|p|\n+                                                  p.parse_path_list_ident()});\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n                                  rp: none, types: []};"}, {"sha": "fa0286ded812c566177972c23126e865e4ebe902", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d9ec100b8f1483e18877b53d578c2aea265480/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=75d9ec100b8f1483e18877b53d578c2aea265480", "patch": "@@ -28,7 +28,7 @@ enum fn_kind {\n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n       fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _, _)\n-          | fk_ctor(name, _, _, _) { name }\n+          | fk_ctor(name, _, _, _) { /* FIXME: bad */ copy name }\n       fk_anon(*) | fk_fn_block(*) { \"anon\" }\n       fk_dtor(*)                  { \"drop\" }\n     }\n@@ -37,7 +37,9 @@ fn name_of_fn(fk: fn_kind) -> ident {\n fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n     alt fk {\n       fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps, _)\n-          | fk_ctor(_, tps, _, _) | fk_dtor(tps, _, _) { tps }\n+              | fk_ctor(_, tps, _, _) | fk_dtor(tps, _, _) {\n+          /* FIXME: bad */ copy tps\n+      }\n       fk_anon(*) | fk_fn_block(*) { [] }\n     }\n }\n@@ -115,7 +117,9 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n       item_fn(decl, tp, body) {\n-        v.visit_fn(fk_item_fn(i.ident, tp), decl, body, i.span, i.id, e, v);\n+        v.visit_fn(fk_item_fn(/* FIXME: bad */ copy i.ident,\n+                              /* FIXME: bad */ copy tp), decl, body,\n+                   i.span, i.id, e, v);\n       }\n       item_mod(m) { v.visit_mod(m, i.span, i.id, e, v); }\n       item_native_mod(nm) {\n@@ -127,8 +131,10 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         v.visit_ty_params(tps, e, v);\n       }\n       item_res(decl, tps, body, dtor_id, _, rp) {\n-        v.visit_fn(fk_res(i.ident, tps, rp), decl, body, i.span,\n-                   dtor_id, e, v);\n+        v.visit_fn(fk_res(/* FIXME: bad */ copy i.ident,\n+                          /* FIXME: bad */ copy tps,\n+                          rp),\n+                   decl, body, i.span, dtor_id, e, v);\n       }\n       item_enum(variants, tps, _) {\n         v.visit_ty_params(tps, e, v);\n@@ -281,22 +287,23 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n-    v.visit_fn(fk_method(m.ident, m.tps, m), m.decl, m.body, m.span,\n-               m.id, e, v);\n+    v.visit_fn(fk_method(/* FIXME: bad */ copy m.ident,\n+                         /* FIXME: bad */ copy m.tps, m),\n+               m.decl, m.body, m.span, m.id, e, v);\n }\n \n // Similar logic to the comment on visit_method_helper - Tim\n fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: [ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_ctor(nm, tps, ctor.node.self_id,\n-                              parent_id), ctor.node.dec,\n+    v.visit_fn(fk_ctor(/* FIXME: bad */ copy nm, /* FIXME: bad */ copy tps,\n+                       ctor.node.self_id, parent_id), ctor.node.dec,\n                ctor.node.body, ctor.span, ctor.node.id, e, v)\n \n }\n \n fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: [ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_dtor(tps, dtor.node.self_id,\n+    v.visit_fn(fk_dtor(/* FIXME: bad */ copy tps, dtor.node.self_id,\n                        parent_id), ast_util::dtor_dec(),\n                dtor.node.body, dtor.span, dtor.node.id, e, v)\n "}]}