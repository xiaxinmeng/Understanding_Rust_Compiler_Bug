{"sha": "344b7bca860ff9559b60d54350312e4ac1e88481", "node_id": "C_kwDOAAsO6NoAKDM0NGI3YmNhODYwZmY5NTU5YjYwZDU0MzUwMzEyZTRhYzFlODg0ODE", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-10-14T17:21:59Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-10-14T17:21:59Z"}, "message": "Don't lint `ptr_arg` when used as an incompatible trait object", "tree": {"sha": "5a0d35351bc9dafcd5fdfd7bfe2a229d4e838b23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a0d35351bc9dafcd5fdfd7bfe2a229d4e838b23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/344b7bca860ff9559b60d54350312e4ac1e88481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/344b7bca860ff9559b60d54350312e4ac1e88481", "html_url": "https://github.com/rust-lang/rust/commit/344b7bca860ff9559b60d54350312e4ac1e88481", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/344b7bca860ff9559b60d54350312e4ac1e88481/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a6eca5f852830cb5e9a520f79ce02e6aae9a1b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a6eca5f852830cb5e9a520f79ce02e6aae9a1b1", "html_url": "https://github.com/rust-lang/rust/commit/9a6eca5f852830cb5e9a520f79ce02e6aae9a1b1"}], "stats": {"total": 96, "additions": 93, "deletions": 3}, "files": [{"sha": "b589ac4a12203330db36e5712fe72c6ddc8a6698", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/344b7bca860ff9559b60d54350312e4ac1e88481/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/344b7bca860ff9559b60d54350312e4ac1e88481/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=344b7bca860ff9559b60d54350312e4ac1e88481", "patch": "@@ -15,13 +15,17 @@ use rustc_hir::{\n     ImplItemKind, ItemKind, Lifetime, LifetimeName, Mutability, Node, Param, ParamName, PatKind, QPath, TraitFn,\n     TraitItem, TraitItemKind, TyKind, Unsafety,\n };\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Binder, ExistentialPredicate, List, PredicateKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n use rustc_span::symbol::Symbol;\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use std::fmt;\n use std::iter;\n \n@@ -384,6 +388,17 @@ enum DerefTy<'tcx> {\n     Slice(Option<Span>, Ty<'tcx>),\n }\n impl<'tcx> DerefTy<'tcx> {\n+    fn ty(&self, cx: &LateContext<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            Self::Str => cx.tcx.types.str_,\n+            Self::Path => cx.tcx.mk_adt(\n+                cx.tcx.adt_def(cx.tcx.get_diagnostic_item(sym::Path).unwrap()),\n+                List::empty(),\n+            ),\n+            Self::Slice(_, ty) => cx.tcx.mk_slice(ty),\n+        }\n+    }\n+\n     fn argless_str(&self) -> &'static str {\n         match *self {\n             Self::Str => \"str\",\n@@ -581,6 +596,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                         let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n                         if expr_sig(self.cx, f).and_then(|sig| sig.input(i)).map_or(true, |ty| {\n                             match *ty.skip_binder().peel_refs().kind() {\n+                                ty::Dynamic(preds, _, _) => !matches_preds(self.cx, args.deref_ty.ty(self.cx), preds),\n                                 ty::Param(_) => true,\n                                 ty::Adt(def, _) => def.did() == args.ty_did,\n                                 _ => false,\n@@ -614,6 +630,9 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                         };\n \n                         match *self.cx.tcx.fn_sig(id).skip_binder().inputs()[i].peel_refs().kind() {\n+                            ty::Dynamic(preds, _, _) if !matches_preds(self.cx, args.deref_ty.ty(self.cx), preds) => {\n+                                set_skip_flag();\n+                            },\n                             ty::Param(_) => {\n                                 set_skip_flag();\n                             },\n@@ -665,6 +684,31 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n     v.results\n }\n \n+fn matches_preds<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    preds: &'tcx [Binder<'tcx, ExistentialPredicate<'tcx>>],\n+) -> bool {\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        preds.iter().all(|&p| match cx.tcx.erase_late_bound_regions(p) {\n+            ExistentialPredicate::Trait(p) => infcx\n+                .type_implements_trait(p.def_id, ty, p.substs, cx.param_env)\n+                .must_apply_modulo_regions(),\n+            ExistentialPredicate::Projection(p) => infcx.predicate_must_hold_modulo_regions(&Obligation::new(\n+                ObligationCause::dummy(),\n+                cx.param_env,\n+                cx.tcx.mk_predicate(Binder::bind_with_vars(\n+                    PredicateKind::Projection(p.with_self_ty(cx.tcx, ty)),\n+                    List::empty(),\n+                )),\n+            )),\n+            ExistentialPredicate::AutoTrait(p) => infcx\n+                .type_implements_trait(p, ty, List::empty(), cx.param_env)\n+                .must_apply_modulo_regions(),\n+        })\n+    })\n+}\n+\n fn get_rptr_lm<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability, Span)> {\n     if let TyKind::Rptr(lt, ref m) = ty.kind {\n         Some((lt, m.mutbl, ty.span))"}, {"sha": "5f54101ca15ad176b070974d1be290bc9aaf0374", "filename": "tests/ui/ptr_arg.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/344b7bca860ff9559b60d54350312e4ac1e88481/tests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/344b7bca860ff9559b60d54350312e4ac1e88481/tests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.rs?ref=344b7bca860ff9559b60d54350312e4ac1e88481", "patch": "@@ -3,7 +3,7 @@\n #![warn(clippy::ptr_arg)]\n \n use std::borrow::Cow;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n fn do_vec(x: &Vec<i64>) {\n     //Nothing here\n@@ -207,3 +207,31 @@ fn cow_conditional_to_mut(a: &mut Cow<str>) {\n         a.to_mut().push_str(\"foo\");\n     }\n }\n+\n+// Issue #9542\n+fn dyn_trait_ok(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+    trait T {}\n+    impl<U> T for Vec<U> {}\n+    impl T for String {}\n+    impl T for PathBuf {}\n+    fn takes_dyn(_: &mut dyn T) {}\n+\n+    takes_dyn(a);\n+    takes_dyn(b);\n+    takes_dyn(c);\n+}\n+\n+fn dyn_trait(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+    trait T {}\n+    impl<U> T for Vec<U> {}\n+    impl<U> T for [U] {}\n+    impl T for String {}\n+    impl T for str {}\n+    impl T for PathBuf {}\n+    impl T for Path {}\n+    fn takes_dyn(_: &mut dyn T) {}\n+\n+    takes_dyn(a);\n+    takes_dyn(b);\n+    takes_dyn(c);\n+}"}, {"sha": "6b4de98ce88c6d567f0553562356a78599670590", "filename": "tests/ui/ptr_arg.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/344b7bca860ff9559b60d54350312e4ac1e88481/tests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/344b7bca860ff9559b60d54350312e4ac1e88481/tests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.stderr?ref=344b7bca860ff9559b60d54350312e4ac1e88481", "patch": "@@ -162,5 +162,23 @@ error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a sl\n LL | fn mut_vec_slice_methods(v: &mut Vec<u32>) {\n    |                             ^^^^^^^^^^^^^ help: change this to: `&mut [u32]`\n \n-error: aborting due to 17 previous errors\n+error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:224:17\n+   |\n+LL | fn dyn_trait(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+   |                 ^^^^^^^^^^^^^ help: change this to: `&mut [u32]`\n+\n+error: writing `&mut String` instead of `&mut str` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:224:35\n+   |\n+LL | fn dyn_trait(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+   |                                   ^^^^^^^^^^^ help: change this to: `&mut str`\n+\n+error: writing `&mut PathBuf` instead of `&mut Path` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:224:51\n+   |\n+LL | fn dyn_trait(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+   |                                                   ^^^^^^^^^^^^ help: change this to: `&mut Path`\n+\n+error: aborting due to 20 previous errors\n "}]}