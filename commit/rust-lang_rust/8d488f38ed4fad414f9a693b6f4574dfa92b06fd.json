{"sha": "8d488f38ed4fad414f9a693b6f4574dfa92b06fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNDg4ZjM4ZWQ0ZmFkNDE0ZjlhNjkzYjZmNDU3NGRmYTkyYjA2ZmQ=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-10T21:29:10Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-16T17:13:30Z"}, "message": "std::vec: Fix hazards with uint overflows in unsafe code\n\nIssue #8742\n\nAdd the method `.reserve_additional(n: uint)`: Check for overflow in\nself.len() + n, and reserve that many elements (rounded up to next power\nof two). Does nothing if self.len() + n < self.capacity() already.", "tree": {"sha": "30b7952ee285cc1355402d72f151d38dc82ddd71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30b7952ee285cc1355402d72f151d38dc82ddd71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d488f38ed4fad414f9a693b6f4574dfa92b06fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d488f38ed4fad414f9a693b6f4574dfa92b06fd", "html_url": "https://github.com/rust-lang/rust/commit/8d488f38ed4fad414f9a693b6f4574dfa92b06fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d488f38ed4fad414f9a693b6f4574dfa92b06fd/comments", "author": null, "committer": null, "parents": [{"sha": "2017cc3ce45a4c1827c5ccee400199bca8f22594", "url": "https://api.github.com/repos/rust-lang/rust/commits/2017cc3ce45a4c1827c5ccee400199bca8f22594", "html_url": "https://github.com/rust-lang/rust/commit/2017cc3ce45a4c1827c5ccee400199bca8f22594"}], "stats": {"total": 35, "additions": 29, "deletions": 6}, "files": [{"sha": "50f194e1f4cddd72965458608935d66e1c07b1ab", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8d488f38ed4fad414f9a693b6f4574dfa92b06fd/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d488f38ed4fad414f9a693b6f4574dfa92b06fd/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=8d488f38ed4fad414f9a693b6f4574dfa92b06fd", "patch": "@@ -1245,6 +1245,7 @@ pub trait OwnedVector<T> {\n \n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n+    fn reserve_additional(&mut self, n: uint);\n     fn capacity(&self) -> uint;\n     fn shrink_to_fit(&mut self);\n \n@@ -1300,6 +1301,11 @@ impl<T> OwnedVector<T> for ~[T] {\n      * # Arguments\n      *\n      * * n - The number of elements to reserve space for\n+     *\n+     * # Failure\n+     *\n+     * This method always succeeds in reserving space for `n` elements, or it does\n+     * not return.\n      */\n     fn reserve(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n@@ -1340,7 +1346,26 @@ impl<T> OwnedVector<T> for ~[T] {\n      */\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(uint::next_power_of_two(n));\n+        self.reserve(uint::next_power_of_two_opt(n).unwrap_or(n));\n+    }\n+\n+    /**\n+     * Reserves capacity for at least `n` additional elements in the given vector.\n+     *\n+     * # Failure\n+     *\n+     * Fails if the new required capacity overflows uint.\n+     *\n+     * May also fail if `reserve` fails.\n+     */\n+    #[inline]\n+    fn reserve_additional(&mut self, n: uint) {\n+        if self.capacity() - self.len() < n {\n+            match self.len().checked_add(&n) {\n+                None => fail!(\"vec::reserve_additional: `uint` overflow\"),\n+                Some(new_cap) => self.reserve_at_least(new_cap)\n+            }\n+        }\n     }\n \n     /// Returns the number of elements the vector can hold without reallocating.\n@@ -1376,17 +1401,15 @@ impl<T> OwnedVector<T> for ~[T] {\n                 let repr: **Box<Vec<()>> = cast::transmute(&mut *self);\n                 let fill = (**repr).data.fill;\n                 if (**repr).data.alloc <= fill {\n-                    let new_len = self.len() + 1;\n-                    self.reserve_at_least(new_len);\n+                    self.reserve_additional(1);\n                 }\n \n                 push_fast(self, t);\n             } else {\n                 let repr: **Vec<()> = cast::transmute(&mut *self);\n                 let fill = (**repr).fill;\n                 if (**repr).alloc <= fill {\n-                    let new_len = self.len() + 1;\n-                    self.reserve_at_least(new_len);\n+                    self.reserve_additional(1);\n                 }\n \n                 push_fast(self, t);\n@@ -1432,7 +1455,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let self_len = self.len();\n         let rhs_len = rhs.len();\n         let new_len = self_len + rhs_len;\n-        self.reserve_at_least(new_len);\n+        self.reserve_additional(rhs.len());\n         unsafe { // Note: infallible.\n             let self_p = vec::raw::to_mut_ptr(*self);\n             let rhs_p = vec::raw::to_ptr(rhs);"}]}