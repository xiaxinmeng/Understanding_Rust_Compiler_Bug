{"sha": "9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNmJjM2M0Mzg2YmY1ZjdmMTg4NWZkYWFiNGVmMDFmZGM5MzAwN2U=", "commit": {"author": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2019-02-03T20:59:51Z"}, "committer": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2019-02-03T21:46:53Z"}, "message": "Apply review suggestions and fix tests", "tree": {"sha": "7448960e14021442c23172156f0a894e9d86850a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7448960e14021442c23172156f0a894e9d86850a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e", "html_url": "https://github.com/rust-lang/rust/commit/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e/comments", "author": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01a704cf3650710a3e3db221759207539de61613", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a704cf3650710a3e3db221759207539de61613", "html_url": "https://github.com/rust-lang/rust/commit/01a704cf3650710a3e3db221759207539de61613"}], "stats": {"total": 241, "additions": 163, "deletions": 78}, "files": [{"sha": "fe2de61c59446140d4ce0012b8e53140bd656bff", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e", "patch": "@@ -5,14 +5,14 @@\n use fmt;\n use marker::Unpin;\n \n-/// A `RawWaker` allows the implementor of a task executor to create a `Waker`\n+/// A `RawWaker` allows the implementor of a task executor to create a [`Waker`]\n /// which provides customized wakeup behavior.\n ///\n /// [vtable]: https://en.wikipedia.org/wiki/Virtual_method_table\n ///\n /// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable] that\n /// customizes the behavior of the `RawWaker`.\n-#[derive(PartialEq)]\n+#[derive(PartialEq, Debug)]\n pub struct RawWaker {\n     /// A data pointer, which can be used to store arbitrary data as required\n     /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n@@ -24,55 +24,41 @@ pub struct RawWaker {\n     pub vtable: &'static RawWakerVTable,\n }\n \n-impl fmt::Debug for RawWaker {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"RawWaker\")\n-            .finish()\n-    }\n-}\n-\n /// A virtual function pointer table (vtable) that specifies the behavior\n /// of a [`RawWaker`].\n ///\n /// The pointer passed to all functions inside the vtable is the `data` pointer\n-/// from the enclosing `RawWaker` object.\n-#[derive(PartialEq, Copy, Clone)]\n+/// from the enclosing [`RawWaker`] object.\n+#[derive(PartialEq, Copy, Clone, Debug)]\n pub struct RawWakerVTable {\n-    /// This function will be called when the `RawWaker` gets cloned, e.g. when\n-    /// the `Waker` in which the `RawWaker` is stored gets cloned.\n+    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n+    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.\n     ///\n     /// The implementation of this function must retain all resources that are\n-    /// required for this additional instance of a `RawWaker` and associated\n-    /// task. Calling `wake` on the resulting `RawWaker` should result in a wakeup\n-    /// of the same task that would have been awoken by the original `RawWaker`.\n+    /// required for this additional instance of a [`RawWaker`] and associated\n+    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n+    /// of the same task that would have been awoken by the original [`RawWaker`].\n     pub clone: unsafe fn(*const ()) -> RawWaker,\n \n-    /// This function will be called when `wake` is called on the `Waker`.\n-    /// It must wake up the task associated with this `RawWaker`.\n+    /// This function will be called when `wake` is called on the [`Waker`].\n+    /// It must wake up the task associated with this [`RawWaker`].\n     pub wake: unsafe fn(*const ()),\n \n-    /// This function gets called when a `RawWaker` gets dropped.\n+    /// This function gets called when a [`RawWaker`] gets dropped.\n     ///\n     /// The implementation of this function must make sure to release any\n-    /// resources that are associated with this instance of a `RawWaker` and\n+    /// resources that are associated with this instance of a [`RawWaker`] and\n     /// associated task.\n-    pub drop_fn: unsafe fn(*const ()),\n-}\n-\n-impl fmt::Debug for RawWakerVTable {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"RawWakerVTable\")\n-            .finish()\n-    }\n+    pub drop: unsafe fn(*const ()),\n }\n \n /// A `Waker` is a handle for waking up a task by notifying its executor that it\n /// is ready to be run.\n ///\n-/// This handle encapsulates a `RawWaker` instance, which defines the\n+/// This handle encapsulates a [`RawWaker`] instance, which defines the\n /// executor-specific wakeup behavior.\n ///\n-/// Implements `Clone`, `Send`, and `Sync`.\n+/// Implements [`Clone`], [`Send`], and [`Sync`].\n #[repr(transparent)]\n pub struct Waker {\n     waker: RawWaker,\n@@ -87,6 +73,10 @@ impl Waker {\n     pub fn wake(&self) {\n         // The actual wakeup call is delegated through a virtual function call\n         // to the implementation which is defined by the executor.\n+\n+        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // to initialize `wake` and `data` requiring the user to acknowledge\n+        // that the contract of `RawWaker` is upheld.\n         unsafe { (self.waker.vtable.wake)(self.waker.data) }\n     }\n \n@@ -101,10 +91,11 @@ impl Waker {\n         self.waker == other.waker\n     }\n \n-    /// Creates a new `Waker` from `RawWaker`.\n+    /// Creates a new `Waker` from [`RawWaker`].\n     ///\n-    /// The method cannot check whether `RawWaker` fulfills the required API\n-    /// contract to make it usable for `Waker` and is therefore unsafe.\n+    /// The behavior of the returned `Waker` is undefined if the contract defined\n+    /// in [RawWaker]'s documentation is not upheld. Therefore this method is\n+    /// unsafe.\n     pub unsafe fn new_unchecked(waker: RawWaker) -> Waker {\n         Waker {\n             waker,\n@@ -115,14 +106,20 @@ impl Waker {\n impl Clone for Waker {\n     fn clone(&self) -> Self {\n         Waker {\n+            // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+            // to initialize `clone` and `data` requiring the user to acknowledge\n+            // that the contract of [`RawWaker`] is upheld.\n             waker: unsafe { (self.waker.vtable.clone)(self.waker.data) },\n         }\n     }\n }\n \n impl Drop for Waker {\n     fn drop(&mut self) {\n-        unsafe { (self.waker.vtable.drop_fn)(self.waker.data) }\n+        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // to initialize `drop` and `data` requiring the user to acknowledge\n+        // that the contract of `RawWaker` is upheld.\n+        unsafe { (self.waker.vtable.drop)(self.waker.data) }\n     }\n }\n "}, {"sha": "b4f07ab33214cca85abd97673399deeaea057a9d", "filename": "src/test/compile-fail/must_use-in-stdlib-traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs?ref=9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e", "patch": "@@ -4,7 +4,7 @@\n use std::iter::Iterator;\n use std::future::Future;\n \n-use std::task::{Poll, LocalWaker};\n+use std::task::{Poll, Waker};\n use std::pin::Pin;\n use std::unimplemented;\n \n@@ -13,7 +13,7 @@ struct MyFuture;\n impl Future for MyFuture {\n    type Output = u32;\n \n-   fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<u32> {\n+   fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<u32> {\n       Poll::Pending\n    }\n }"}, {"sha": "2def62a6ba60c774d0eb4287008b62d327ab7625", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e", "patch": "@@ -9,17 +9,70 @@ use std::sync::{\n     atomic::{self, AtomicUsize},\n };\n use std::task::{\n-    LocalWaker, Poll, Wake,\n-    local_waker_from_nonlocal,\n+    Poll, Waker, RawWaker, RawWakerVTable,\n };\n \n+macro_rules! waker_vtable {\n+    ($ty:ident) => {\n+        &RawWakerVTable {\n+            clone: clone_arc_raw::<$ty>,\n+            drop: drop_arc_raw::<$ty>,\n+            wake: wake_arc_raw::<$ty>,\n+        }\n+    };\n+}\n+\n+pub trait ArcWake {\n+    fn wake(arc_self: &Arc<Self>);\n+\n+    fn into_waker(wake: Arc<Self>) -> Waker where Self: Sized\n+    {\n+        let ptr = Arc::into_raw(wake) as *const();\n+\n+        unsafe {\n+            Waker::new_unchecked(RawWaker{\n+                data: ptr,\n+                vtable: waker_vtable!(Self),\n+            })\n+        }\n+    }\n+}\n+\n+unsafe fn increase_refcount<T: ArcWake>(data: *const()) {\n+    // Retain Arc by creating a copy\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    let arc_clone = arc.clone();\n+    // Forget the Arcs again, so that the refcount isn't decrased\n+    let _ = Arc::into_raw(arc);\n+    let _ = Arc::into_raw(arc_clone);\n+}\n+\n+unsafe fn clone_arc_raw<T: ArcWake>(data: *const()) -> RawWaker {\n+    increase_refcount::<T>(data);\n+    RawWaker {\n+        data: data,\n+        vtable: waker_vtable!(T),\n+    }\n+}\n+\n+unsafe fn drop_arc_raw<T: ArcWake>(data: *const()) {\n+    // Drop Arc\n+    let _: Arc<T> = Arc::from_raw(data as *const T);\n+}\n+\n+unsafe fn wake_arc_raw<T: ArcWake>(data: *const()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake(&arc);\n+    let _ = Arc::into_raw(arc);\n+}\n+\n struct Counter {\n     wakes: AtomicUsize,\n }\n \n-impl Wake for Counter {\n-    fn wake(this: &Arc<Self>) {\n-        this.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+impl ArcWake for Counter {\n+    fn wake(arc_self: &Arc<Self>) {\n+        arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n \n@@ -29,11 +82,11 @@ fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n \n impl Future for WakeOnceThenComplete {\n     type Output = ();\n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<()> {\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<()> {\n         if self.0 {\n             Poll::Ready(())\n         } else {\n-            lw.wake();\n+            waker.wake();\n             self.0 = true;\n             Poll::Pending\n         }\n@@ -130,7 +183,7 @@ where\n {\n     let mut fut = Box::pin(f(9));\n     let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n-    let waker = local_waker_from_nonlocal(counter.clone());\n+    let waker = ArcWake::into_waker(counter.clone());\n     assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n     assert_eq!(Poll::Pending, fut.as_mut().poll(&waker));\n     assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));"}, {"sha": "058d09e2420ae34f714c11f4492eeaa822ef424c", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 69, "deletions": 34, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=9e6bc3c4386bf5f7f1885fdaab4ef01fdc93007e", "patch": "@@ -3,69 +3,104 @@\n \n use std::future::Future;\n use std::pin::Pin;\n-use std::rc::Rc;\n use std::sync::{\n     Arc,\n     atomic::{self, AtomicUsize},\n };\n use std::task::{\n-    Poll, Wake, Waker, LocalWaker,\n-    local_waker, local_waker_from_nonlocal,\n+    Poll, Waker, RawWaker, RawWakerVTable,\n };\n \n-struct Counter {\n-    local_wakes: AtomicUsize,\n-    nonlocal_wakes: AtomicUsize,\n+macro_rules! waker_vtable {\n+    ($ty:ident) => {\n+        &RawWakerVTable {\n+            clone: clone_arc_raw::<$ty>,\n+            drop: drop_arc_raw::<$ty>,\n+            wake: wake_arc_raw::<$ty>,\n+        }\n+    };\n }\n \n-impl Wake for Counter {\n-    fn wake(this: &Arc<Self>) {\n-        this.nonlocal_wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+pub trait ArcWake {\n+    fn wake(arc_self: &Arc<Self>);\n+\n+    fn into_waker(wake: Arc<Self>) -> Waker where Self: Sized\n+    {\n+        let ptr = Arc::into_raw(wake) as *const();\n+\n+        unsafe {\n+            Waker::new_unchecked(RawWaker{\n+                data: ptr,\n+                vtable: waker_vtable!(Self),\n+            })\n+        }\n     }\n+}\n+\n+unsafe fn increase_refcount<T: ArcWake>(data: *const()) {\n+    // Retain Arc by creating a copy\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    let arc_clone = arc.clone();\n+    // Forget the Arcs again, so that the refcount isn't decrased\n+    let _ = Arc::into_raw(arc);\n+    let _ = Arc::into_raw(arc_clone);\n+}\n \n-    unsafe fn wake_local(this: &Arc<Self>) {\n-        this.local_wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+unsafe fn clone_arc_raw<T: ArcWake>(data: *const()) -> RawWaker {\n+    increase_refcount::<T>(data);\n+    RawWaker {\n+        data: data,\n+        vtable: waker_vtable!(T),\n+    }\n+}\n+\n+unsafe fn drop_arc_raw<T: ArcWake>(data: *const()) {\n+    // Drop Arc\n+    let _: Arc<T> = Arc::from_raw(data as *const T);\n+}\n+\n+unsafe fn wake_arc_raw<T: ArcWake>(data: *const()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake(&arc);\n+    let _ = Arc::into_raw(arc);\n+}\n+\n+struct Counter {\n+    wakes: AtomicUsize,\n+}\n+\n+impl Wake for Counter {\n+    fn wake(arc_self: &Arc<Self>) {\n+        arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n \n struct MyFuture;\n \n impl Future for MyFuture {\n     type Output = ();\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        // Wake once locally\n-        lw.wake();\n-        // Wake twice non-locally\n-        let waker = lw.clone().into_waker();\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        // Wake twice\n         waker.wake();\n         waker.wake();\n         Poll::Ready(())\n     }\n }\n \n-fn test_local_waker() {\n+fn test_waker() {\n     let counter = Arc::new(Counter {\n-        local_wakes: AtomicUsize::new(0),\n-        nonlocal_wakes: AtomicUsize::new(0),\n+        wakes: AtomicUsize::new(0),\n     });\n-    let waker = unsafe { local_waker(counter.clone()) };\n-    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&waker));\n-    assert_eq!(1, counter.local_wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(2, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n-}\n+    let waker = ArcWake::into_waker(counter.clone());\n+    assert_eq!(2, Arc::strong_count(&counter));\n \n-fn test_local_as_nonlocal_waker() {\n-    let counter = Arc::new(Counter {\n-        local_wakes: AtomicUsize::new(0),\n-        nonlocal_wakes: AtomicUsize::new(0),\n-    });\n-    let waker: LocalWaker = local_waker_from_nonlocal(counter.clone());\n     assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&waker));\n-    assert_eq!(0, counter.local_wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(3, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(2, counter.wakes.load(atomic::Ordering::SeqCst));\n+\n+    drop(waker);\n+    assert_eq!(1, Arc::strong_count(&counter));\n }\n \n fn main() {\n-    test_local_waker();\n-    test_local_as_nonlocal_waker();\n+    test_waker();\n }"}]}