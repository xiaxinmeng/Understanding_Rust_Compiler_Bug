{"sha": "44c76d6550081552c3c5106b0535a7e5bf265aec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0Yzc2ZDY1NTAwODE1NTJjM2M1MTA2YjA1MzVhN2U1YmYyNjVhZWM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-12-05T14:41:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-12-05T14:41:36Z"}, "message": "Add replace_match_with_if_let assist", "tree": {"sha": "362d0555ac4b8a4b41a06b2ffada92a17b758ae7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/362d0555ac4b8a4b41a06b2ffada92a17b758ae7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44c76d6550081552c3c5106b0535a7e5bf265aec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44c76d6550081552c3c5106b0535a7e5bf265aec", "html_url": "https://github.com/rust-lang/rust/commit/44c76d6550081552c3c5106b0535a7e5bf265aec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44c76d6550081552c3c5106b0535a7e5bf265aec/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3043cf53feffef3f69f25c2617801d2fc66ce75", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3043cf53feffef3f69f25c2617801d2fc66ce75", "html_url": "https://github.com/rust-lang/rust/commit/a3043cf53feffef3f69f25c2617801d2fc66ce75"}], "stats": {"total": 324, "additions": 319, "deletions": 5}, "files": [{"sha": "7bcc318a99d563c621720393791d6d5e33c10c08", "filename": "crates/assists/src/handlers/early_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=44c76d6550081552c3c5106b0535a7e5bf265aec", "patch": "@@ -112,7 +112,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n                         let then_branch =\n                             make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n                         let cond = invert_boolean_expression(cond_expr);\n-                        make::expr_if(make::condition(cond, None), then_branch)\n+                        make::expr_if(make::condition(cond, None), then_branch, None)\n                             .indent(if_indent_level)\n                     };\n                     replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)"}, {"sha": "eaffd80ce3b1b6af87e07d4ce01e0972ac986a82", "filename": "crates/assists/src/handlers/move_guard.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=44c76d6550081552c3c5106b0535a7e5bf265aec", "patch": "@@ -42,6 +42,7 @@ pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) ->\n     let if_expr = make::expr_if(\n         make::condition(guard_condition, None),\n         make::block_expr(None, Some(arm_expr.clone())),\n+        None,\n     )\n     .indent(arm_expr.indent_level());\n "}, {"sha": "4a355c66f03de90384bc7cd06783381f21e90949", "filename": "crates/assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 276, "deletions": 1, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=44c76d6550081552c3c5106b0535a7e5bf265aec", "patch": "@@ -1,3 +1,6 @@\n+use std::iter;\n+\n+use ide_db::{ty_filter::TryEnum, RootDatabase};\n use syntax::{\n     ast::{\n         self,\n@@ -8,7 +11,6 @@ use syntax::{\n };\n \n use crate::{utils::unwrap_trivial_block, AssistContext, AssistId, AssistKind, Assists};\n-use ide_db::ty_filter::TryEnum;\n \n // Assist: replace_if_let_with_match\n //\n@@ -79,6 +81,91 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n     )\n }\n \n+// Assist: replace_match_with_if_let\n+//\n+// Replaces a binary `match` with a wildcard pattern and no guards with an `if let` expression.\n+//\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     <|>match action {\n+//         Action::Move { distance } => foo(distance),\n+//         _ => bar(),\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     if let Action::Move { distance } = action {\n+//         foo(distance)\n+//     } else {\n+//         bar()\n+//     }\n+// }\n+// ```\n+pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let match_expr: ast::MatchExpr = ctx.find_node_at_offset()?;\n+    let mut arms = match_expr.match_arm_list()?.arms();\n+    let first_arm = arms.next()?;\n+    let second_arm = arms.next()?;\n+    if arms.next().is_some() || first_arm.guard().is_some() || second_arm.guard().is_some() {\n+        return None;\n+    }\n+    let condition_expr = match_expr.expr()?;\n+    let (if_let_pat, then_expr, else_expr) = if is_pat_wildcard_or_sad(&ctx.sema, &first_arm.pat()?)\n+    {\n+        (second_arm.pat()?, second_arm.expr()?, first_arm.expr()?)\n+    } else if is_pat_wildcard_or_sad(&ctx.sema, &second_arm.pat()?) {\n+        (first_arm.pat()?, first_arm.expr()?, second_arm.expr()?)\n+    } else {\n+        return None;\n+    };\n+\n+    let target = match_expr.syntax().text_range();\n+    acc.add(\n+        AssistId(\"replace_match_with_if_let\", AssistKind::RefactorRewrite),\n+        \"Replace with if let\",\n+        target,\n+        move |edit| {\n+            let condition = make::condition(condition_expr, Some(if_let_pat));\n+            let then_block = match then_expr.reset_indent() {\n+                ast::Expr::BlockExpr(block) => block,\n+                expr => make::block_expr(iter::empty(), Some(expr)),\n+            };\n+            let else_expr = match else_expr {\n+                ast::Expr::BlockExpr(block)\n+                    if block.statements().count() == 0 && block.expr().is_none() =>\n+                {\n+                    None\n+                }\n+                ast::Expr::TupleExpr(tuple) if tuple.fields().count() == 0 => None,\n+                expr => Some(expr),\n+            };\n+            let if_let_expr = make::expr_if(\n+                condition,\n+                then_block,\n+                else_expr.map(|else_expr| {\n+                    ast::ElseBranch::Block(make::block_expr(iter::empty(), Some(else_expr)))\n+                }),\n+            )\n+            .indent(IndentLevel::from_node(match_expr.syntax()));\n+\n+            edit.replace_ast::<ast::Expr>(match_expr.into(), if_let_expr);\n+        },\n+    )\n+}\n+\n+fn is_pat_wildcard_or_sad(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n+    sema.type_of_pat(&pat)\n+        .and_then(|ty| TryEnum::from_ty(sema, &ty))\n+        .map(|it| it.sad_pattern().syntax().text() == pat.syntax().text())\n+        .unwrap_or_else(|| matches!(pat, ast::Pat::WildcardPat(_)))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -249,6 +336,194 @@ fn main() {\n         }\n     }\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_replace_match_with_if_let_unwraps_simple_expressions() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        <|>match *self {\n+            VariantData::Struct(..) => true,\n+            _ => false,\n+        }\n+    }\n+}           \"#,\n+            r#\"\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        if let VariantData::Struct(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}           \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_replace_match_with_if_let_doesnt_unwrap_multiline_expressions() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn foo() {\n+    <|>match a {\n+        VariantData::Struct(..) => {\n+            bar(\n+                123\n+            )\n+        }\n+        _ => false,\n+    }\n+}           \"#,\n+            r#\"\n+fn foo() {\n+    if let VariantData::Struct(..) = a {\n+        bar(\n+            123\n+        )\n+    } else {\n+        false\n+    }\n+}           \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_match_with_if_let_target() {\n+        check_assist_target(\n+            replace_match_with_if_let,\n+            r#\"\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        <|>match *self {\n+            VariantData::Struct(..) => true,\n+            _ => false,\n+        }\n+    }\n+}           \"#,\n+            r#\"match *self {\n+            VariantData::Struct(..) => true,\n+            _ => false,\n+        }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn special_case_option_match_to_if_let() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn foo(x: Option<i32>) {\n+    <|>match x {\n+        Some(x) => println!(\"{}\", x),\n+        None => println!(\"none\"),\n+    }\n+}\n+           \"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn foo(x: Option<i32>) {\n+    if let Some(x) = x {\n+        println!(\"{}\", x)\n+    } else {\n+        println!(\"none\")\n+    }\n+}\n+           \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn special_case_result_match_to_if_let() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n+\n+fn foo(x: Result<i32, ()>) {\n+    <|>match x {\n+        Ok(x) => println!(\"{}\", x),\n+        Err(_) => println!(\"none\"),\n+    }\n+}\n+           \"#,\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n+\n+fn foo(x: Result<i32, ()>) {\n+    if let Ok(x) = x {\n+        println!(\"{}\", x)\n+    } else {\n+        println!(\"none\")\n+    }\n+}\n+           \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_indent_match_to_if_let() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn main() {\n+    if true {\n+        <|>match path.strip_prefix(root_path) {\n+            Ok(rel_path) => {\n+                let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+                Some((*id, rel_path))\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    if true {\n+        if let Ok(rel_path) = path.strip_prefix(root_path) {\n+            let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+            Some((*id, rel_path))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_match_with_if_let_empty_wildcard_expr() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn main() {\n+    <|>match path.strip_prefix(root_path) {\n+        Ok(rel_path) => println!(\"{}\", rel_path),\n+        _ => (),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    if let Ok(rel_path) = path.strip_prefix(root_path) {\n+        println!(\"{}\", rel_path)\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "5970e283cfb300d30c6331d64906b74ef35b17da", "filename": "crates/assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=44c76d6550081552c3c5106b0535a7e5bf265aec", "patch": "@@ -60,7 +60,7 @@ pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) ->\n             };\n             let block =\n                 make::block_expr(None, None).indent(IndentLevel::from_node(let_stmt.syntax()));\n-            let if_ = make::expr_if(make::condition(init, Some(with_placeholder)), block);\n+            let if_ = make::expr_if(make::condition(init, Some(with_placeholder)), block, None);\n             let stmt = make::expr_stmt(if_);\n \n             let placeholder = stmt.syntax().descendants().find_map(ast::WildcardPat::cast).unwrap();"}, {"sha": "b8ce7418d6f7e686310ed0c5efc6ca3329fa2313", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=44c76d6550081552c3c5106b0535a7e5bf265aec", "patch": "@@ -209,6 +209,7 @@ mod handlers {\n             reorder_fields::reorder_fields,\n             replace_derive_with_manual_impl::replace_derive_with_manual_impl,\n             replace_if_let_with_match::replace_if_let_with_match,\n+            replace_if_let_with_match::replace_match_with_if_let,\n             replace_impl_trait_with_generic::replace_impl_trait_with_generic,\n             replace_let_with_if_let::replace_let_with_if_let,\n             replace_qualified_name_with_use::replace_qualified_name_with_use,"}, {"sha": "853bde09ca25299939cb8de1ce0374092c09e0fb", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=44c76d6550081552c3c5106b0535a7e5bf265aec", "patch": "@@ -889,6 +889,34 @@ fn compute() -> Option<i32> { None }\n     )\n }\n \n+#[test]\n+fn doctest_replace_match_with_if_let() {\n+    check_doc_test(\n+        \"replace_match_with_if_let\",\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    <|>match action {\n+        Action::Move { distance } => foo(distance),\n+        _ => bar(),\n+    }\n+}\n+\"#####,\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    if let Action::Move { distance } = action {\n+        foo(distance)\n+    } else {\n+        bar()\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_replace_qualified_name_with_use() {\n     check_doc_test("}, {"sha": "cc09b77a590348f1add8d7bab956ed813ba20a0a", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c76d6550081552c3c5106b0535a7e5bf265aec/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=44c76d6550081552c3c5106b0535a7e5bf265aec", "patch": "@@ -171,8 +171,17 @@ pub fn expr_return() -> ast::Expr {\n pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n     expr_from_text(&format!(\"match {} {}\", expr, match_arm_list))\n }\n-pub fn expr_if(condition: ast::Condition, then_branch: ast::BlockExpr) -> ast::Expr {\n-    expr_from_text(&format!(\"if {} {}\", condition, then_branch))\n+pub fn expr_if(\n+    condition: ast::Condition,\n+    then_branch: ast::BlockExpr,\n+    else_branch: Option<ast::ElseBranch>,\n+) -> ast::Expr {\n+    let else_branch = match else_branch {\n+        Some(ast::ElseBranch::Block(block)) => format!(\"else {}\", block),\n+        Some(ast::ElseBranch::IfExpr(if_expr)) => format!(\"else {}\", if_expr),\n+        None => String::new(),\n+    };\n+    expr_from_text(&format!(\"if {} {} {}\", condition, then_branch, else_branch))\n }\n pub fn expr_prefix(op: SyntaxKind, expr: ast::Expr) -> ast::Expr {\n     let token = token(op);"}]}