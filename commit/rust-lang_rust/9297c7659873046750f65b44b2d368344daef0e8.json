{"sha": "9297c7659873046750f65b44b2d368344daef0e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOTdjNzY1OTg3MzA0Njc1MGY2NWI0NGIyZDM2ODM0NGRhZWYwZTg=", "commit": {"author": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-09-01T17:13:37Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-04T20:23:22Z"}, "message": "add additional Bitv constructors (as proposed in issue #2964)", "tree": {"sha": "b4a88ecc99bfb318b11b2ab5aa854c53a73057cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4a88ecc99bfb318b11b2ab5aa854c53a73057cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9297c7659873046750f65b44b2d368344daef0e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9297c7659873046750f65b44b2d368344daef0e8", "html_url": "https://github.com/rust-lang/rust/commit/9297c7659873046750f65b44b2d368344daef0e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9297c7659873046750f65b44b2d368344daef0e8/comments", "author": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f445497d6bd57c7fa775d5b5bcba4f1c3cacece8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f445497d6bd57c7fa775d5b5bcba4f1c3cacece8", "html_url": "https://github.com/rust-lang/rust/commit/f445497d6bd57c7fa775d5b5bcba4f1c3cacece8"}], "stats": {"total": 99, "additions": 99, "deletions": 0}, "files": [{"sha": "70cc3d3816fe5b626a9f7584db44c7dbc1b16caf", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/9297c7659873046750f65b44b2d368344daef0e8/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9297c7659873046750f65b44b2d368344daef0e8/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=9297c7659873046750f65b44b2d368344daef0e8", "patch": "@@ -420,6 +420,44 @@ struct Bitv {\n         vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n+    /**\n+     * Organise the bits into bytes, such that the first bit in the\n+     * bitv becomes the high-order bit of the first byte. If the\n+     * size of the bitv is not a multiple of 8 then trailing bits\n+     * will be filled-in with false/0\n+     */\n+    fn to_bytes() -> ~[u8] {\n+\n+        fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n+            let offset = byte * 8 + bit;\n+            if offset >= bitv.nbits {\n+                0\n+            } else {\n+                bitv[offset] as u8 << (7 - bit)\n+            }\n+        }\n+\n+        let len = self.nbits/8 +\n+                  if self.nbits % 8 == 0 { 0 } else { 1 };\n+        vec::from_fn(len, |i|\n+            bit(&self, i, 0) |\n+            bit(&self, i, 1) |\n+            bit(&self, i, 2) |\n+            bit(&self, i, 3) |\n+            bit(&self, i, 4) |\n+            bit(&self, i, 5) |\n+            bit(&self, i, 6) |\n+            bit(&self, i, 7)\n+        )\n+    }\n+\n+    /**\n+     * Transform self into a [bool] by turning each bit into a bool\n+     */\n+    fn to_bools() -> ~[bool] {\n+        vec::from_fn(self.nbits, |i| self[i])\n+    }\n+\n /**\n  * Converts `self` to a string.\n  *\n@@ -461,6 +499,38 @@ struct Bitv {\n \n } // end of bitv class\n \n+/**\n+ * Transform a byte-vector into a bitv. Each byte becomes 8 bits,\n+ * with the most significant bits of each byte coming first. Each\n+ * bit becomes true if equal to 1 or false if equal to 0.\n+ */\n+fn from_bytes(bytes: &[u8]) -> Bitv {\n+    from_fn(bytes.len() * 8, |i| {\n+        let b = bytes[i / 8] as uint;\n+        let offset = i % 8;\n+        b >> (7 - offset) & 1 == 1\n+    })\n+}\n+\n+/**\n+ * Transform a [bool] into a bitv by converting each bool into a bit.\n+ */\n+fn from_bools(bools: &[bool]) -> Bitv {\n+    from_fn(bools.len(), |i| bools[i])\n+}\n+\n+/**\n+ * Create a bitv of the specified length where the value at each\n+ * index is f(index).\n+ */\n+fn from_fn(len: uint, f: fn(index: uint) -> bool) -> Bitv {\n+    let bitv = Bitv(len, false);\n+    for uint::range(0, len) |i| {\n+        bitv.set(i, f(i));\n+    }\n+    return bitv;\n+}\n+\n const uint_bits: uint = 32u + (1u << 32u >> 27u);\n \n pure fn lor(w0: uint, w1: uint) -> uint { return w0 | w1; }\n@@ -815,6 +885,35 @@ mod tests {\n         assert a.equal(b);\n     }\n \n+    #[test]\n+    fn test_from_bytes() {\n+        let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n+        let str = ~\"10110110\" + ~\"00000000\" + ~\"11111111\";\n+        assert bitv.to_str() == str;\n+    }\n+\n+    #[test]\n+    fn test_to_bytes() {\n+        let bv = Bitv(3, true);\n+        bv.set(1, false);\n+        assert bv.to_bytes() == ~[0b10100000];\n+\n+        let bv = Bitv(9, false);\n+        bv.set(2, true);\n+        bv.set(8, true);\n+        assert bv.to_bytes() == ~[0b00100000, 0b10000000];\n+    }\n+\n+    #[test]\n+    fn test_from_bools() {\n+        assert from_bools([true, false, true, true]).to_str() == ~\"1011\";\n+    }\n+\n+    #[test]\n+    fn test_to_bools() {\n+        let bools = ~[false, false, true, false, false, true, true, false];\n+        assert from_bytes([0b00100110]).to_bools() == bools;\n+    }\n }\n \n //"}]}