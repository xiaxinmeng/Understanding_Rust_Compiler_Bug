{"sha": "c8ce32e7f45a020eebcd7329fbe33e8b53f832a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4Y2UzMmU3ZjQ1YTAyMGVlYmNkNzMyOWZiZTMzZThiNTNmODMyYTM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-23T00:58:05Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-23T03:32:09Z"}, "message": "Represent \"item families\" in the decoder as an enum\n\nThis eliminates some match checks. Also get rid of other match checks\nin metadata code.", "tree": {"sha": "63b905a71ab35dd5a1690213ea54e966842baaaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63b905a71ab35dd5a1690213ea54e966842baaaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3", "html_url": "https://github.com/rust-lang/rust/commit/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3b1c3bf4d72b59280cea647030c9813007f7b10", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b1c3bf4d72b59280cea647030c9813007f7b10", "html_url": "https://github.com/rust-lang/rust/commit/b3b1c3bf4d72b59280cea647030c9813007f7b10"}], "stats": {"total": 249, "additions": 157, "deletions": 92}, "files": [{"sha": "a1a2b7245eb983c176ad491a84e234452f224c70", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 120, "deletions": 70, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=c8ce32e7f45a020eebcd7329fbe33e8b53f832a3", "patch": "@@ -105,9 +105,56 @@ fn lookup_item(item_id: int, data: @~[u8]) -> ebml::doc {\n     }\n }\n \n-fn item_family(item: ebml::doc) -> char {\n+enum Family {\n+    Const,                 // c\n+    Fn,                    // f\n+    UnsafeFn,              // u\n+    PureFn,                // p\n+    StaticMethod,          // F\n+    UnsafeStaticMethod,    // U\n+    PureStaticMethod,      // P\n+    ForeignFn,             // e\n+    Type,                  // y\n+    ForeignType,           // T\n+    Mod,                   // m\n+    ForeignMod,            // n\n+    Enum,                  // t\n+    Variant,               // v\n+    Impl,                  // i\n+    Trait,                 // I\n+    Class,                 // C\n+    Struct,                // S\n+    PublicField,           // g\n+    PrivateField,          // j\n+    InheritedField         // N\n+}\n+\n+fn item_family(item: ebml::doc) -> Family {\n     let fam = ebml::get_doc(item, tag_items_data_item_family);\n-    ebml::doc_as_u8(fam) as char\n+    match ebml::doc_as_u8(fam) as char {\n+      'c' => Const,\n+      'f' => Fn,\n+      'u' => UnsafeFn,\n+      'p' => PureFn,\n+      'F' => StaticMethod,\n+      'U' => UnsafeStaticMethod,\n+      'P' => PureStaticMethod,\n+      'e' => ForeignFn,\n+      'y' => Type,\n+      'T' => ForeignType,\n+      'm' => Mod,\n+      'n' => ForeignMod,\n+      't' => Enum,\n+      'v' => Variant,\n+      'i' => Impl,\n+      'I' => Trait,\n+      'C' => Class,\n+      'S' => Struct,\n+      'g' => PublicField,\n+      'j' => PrivateField,\n+      'N' => InheritedField,\n+       c => fail (#fmt(\"unexpected family char: %c\", c))\n+    }\n }\n \n fn item_symbol(item: ebml::doc) -> ~str {\n@@ -245,31 +292,34 @@ fn item_name(intr: ident_interner, item: ebml::doc) -> ast::ident {\n \n fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n         -> def_like {\n-    let fam_ch = item_family(item);\n-    match fam_ch {\n-      'c' => dl_def(ast::def_const(did)),\n-      'C' => dl_def(ast::def_class(did, true)),\n-      'S' => dl_def(ast::def_class(did, false)),\n-      'u' => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n-      'f' => dl_def(ast::def_fn(did, ast::impure_fn)),\n-      'p' => dl_def(ast::def_fn(did, ast::pure_fn)),\n-      'e' => dl_def(ast::def_fn(did, ast::extern_fn)),\n-      'U' => dl_def(ast::def_static_method(did, ast::unsafe_fn)),\n-      'F' => dl_def(ast::def_static_method(did, ast::impure_fn)),\n-      'P' => dl_def(ast::def_static_method(did, ast::pure_fn)),\n-      'y' => dl_def(ast::def_ty(did)),\n-      't' => dl_def(ast::def_ty(did)),\n-      'm' => dl_def(ast::def_mod(did)),\n-      'n' => dl_def(ast::def_foreign_mod(did)),\n-      'v' => {\n-        let mut tid = option::get(item_parent_item(item));\n-        tid = {crate: cnum, node: tid.node};\n-        dl_def(ast::def_variant(tid, did))\n+    let fam = item_family(item);\n+    match fam {\n+      Const     => dl_def(ast::def_const(did)),\n+      Class     => dl_def(ast::def_class(did, true)),\n+      Struct    => dl_def(ast::def_class(did, false)),\n+      UnsafeFn  => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n+      Fn        => dl_def(ast::def_fn(did, ast::impure_fn)),\n+      PureFn    => dl_def(ast::def_fn(did, ast::pure_fn)),\n+      ForeignFn => dl_def(ast::def_fn(did, ast::extern_fn)),\n+      UnsafeStaticMethod => dl_def(ast::def_static_method(did,\n+                                                          ast::unsafe_fn)),\n+      StaticMethod => dl_def(ast::def_static_method(did, ast::impure_fn)),\n+      PureStaticMethod => dl_def(ast::def_static_method(did, ast::pure_fn)),\n+      Type | ForeignType => dl_def(ast::def_ty(did)),\n+      Mod => dl_def(ast::def_mod(did)),\n+      ForeignMod => dl_def(ast::def_foreign_mod(did)),\n+      Variant => {\n+          match item_parent_item(item) {\n+              some(t) => {\n+                let tid = {crate: cnum, node: t.node};\n+                dl_def(ast::def_variant(tid, did))\n+              }\n+              none => fail ~\"item_to_def_like: enum item has no parent\"\n+          }\n       }\n-      'I' => dl_def(ast::def_ty(did)),\n-      'i' => dl_impl(did),\n-      'g' | 'j' | 'N' => dl_field,\n-      ch => fail fmt!{\"unexpected family code: '%c'\", ch}\n+      Trait | Enum => dl_def(ast::def_ty(did)),\n+      Impl => dl_impl(did),\n+      PublicField | PrivateField | InheritedField => dl_field,\n     }\n }\n \n@@ -642,12 +692,14 @@ fn get_trait_methods(intr: ident_interner, cdata: cmd, id: ast::node_id,\n         let self_ty = get_self_ty(mth);\n         vec::push(result, {ident: name, tps: bounds, fty: fty,\n                     self_ty: self_ty,\n-                    purity: match check item_family(mth) {\n-                      'u' => ast::unsafe_fn,\n-                      'f' => ast::impure_fn,\n-                      'p' => ast::pure_fn\n+                    purity: match item_family(mth) {\n+                      UnsafeFn => ast::unsafe_fn,\n+                      Fn => ast::impure_fn,\n+                      PureFn => ast::pure_fn,\n+                      _ => fail ~\"bad purity\"\n                     }, vis: ast::public});\n     }\n+    #debug(\"get_trait_methods: }\");\n     @result\n }\n \n@@ -659,7 +711,7 @@ fn get_method_names_if_trait(intr: ident_interner, cdata: cmd,\n                           -> option<@DVec<(ast::ident, ast::self_ty_)>> {\n \n     let item = lookup_item(node_id, cdata.data);\n-    if item_family(item) != 'I' {\n+    if item_family(item) != Trait {\n         return none;\n     }\n \n@@ -685,7 +737,7 @@ fn get_item_attrs(cdata: cmd,\n \n // Helper function that gets either fields or methods\n fn get_class_members(intr: ident_interner, cdata: cmd, id: ast::node_id,\n-                     p: fn(char) -> bool) -> ~[ty::field_ty] {\n+                     p: fn(Family) -> bool) -> ~[ty::field_ty] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n@@ -702,33 +754,31 @@ fn get_class_members(intr: ident_interner, cdata: cmd, id: ast::node_id,\n     result\n }\n \n-pure fn family_to_visibility(family: char) -> ast::visibility {\n+pure fn family_to_visibility(family: Family) -> ast::visibility {\n     match family {\n-      'g' => ast::public,\n-      'j' => ast::private,\n-      'N' => ast::inherited,\n+      PublicField => ast::public,\n+      PrivateField => ast::private,\n+      InheritedField => ast::inherited,\n       _ => fail\n     }\n }\n \n-/* 'g' for public field, 'j' for private field, 'N' for inherited field */\n fn get_class_fields(intr: ident_interner, cdata: cmd, id: ast::node_id)\n     -> ~[ty::field_ty] {\n-    get_class_members(intr, cdata, id, |f| f == 'g' || f == 'j' || f == 'N')\n+    get_class_members(intr, cdata, id, |f| f == PublicField\n+                      || f == PrivateField || f == InheritedField)\n }\n \n-fn family_has_type_params(fam_ch: char) -> bool {\n-    match fam_ch {\n-      'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' | 'e' | 'N' => false,\n-      'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' | 'C'\n-          | 'a' | 'S'\n-          => true,\n-      _ => fail fmt!(\"'%c' is not a family\", fam_ch)\n+fn family_has_type_params(fam: Family) -> bool {\n+    match fam {\n+      Const | ForeignType | Mod | ForeignMod | PublicField | PrivateField\n+      | ForeignFn => false,\n+      _           => true\n     }\n }\n \n-fn family_names_type(fam_ch: char) -> bool {\n-    match fam_ch { 'y' | 't' | 'I' => true, _ => false }\n+fn family_names_type(fam: Family) -> bool {\n+    match fam { Type | Mod | Trait => true, _ => false }\n }\n \n fn read_path(d: ebml::doc) -> {path: ~str, pos: uint} {\n@@ -748,29 +798,29 @@ fn describe_def(items: ebml::doc, id: ast::def_id) -> ~str {\n     return item_family_to_str(item_family(it));\n }\n \n-fn item_family_to_str(fam: char) -> ~str {\n-    match check fam {\n-      'c' => return ~\"const\",\n-      'f' => return ~\"fn\",\n-      'u' => return ~\"unsafe fn\",\n-      'p' => return ~\"pure fn\",\n-      'F' => return ~\"static method\",\n-      'U' => return ~\"unsafe static method\",\n-      'P' => return ~\"pure static method\",\n-      'e' => return ~\"foreign fn\",\n-      'y' => return ~\"type\",\n-      'T' => return ~\"foreign type\",\n-      't' => return ~\"type\",\n-      'm' => return ~\"mod\",\n-      'n' => return ~\"foreign mod\",\n-      'v' => return ~\"enum\",\n-      'i' => return ~\"impl\",\n-      'I' => return ~\"trait\",\n-      'C' => return ~\"class\",\n-      'S' => return ~\"struct\",\n-      'g' => return ~\"public field\",\n-      'j' => return ~\"private field\",\n-      'N' => return ~\"inherited field\"\n+fn item_family_to_str(fam: Family) -> ~str {\n+    match fam {\n+      Const => ~\"const\",\n+      Fn => ~\"fn\",\n+      UnsafeFn => ~\"unsafe fn\",\n+      PureFn => ~\"pure fn\",\n+      StaticMethod => ~\"static method\",\n+      UnsafeStaticMethod => ~\"unsafe static method\",\n+      PureStaticMethod => ~\"pure static method\",\n+      ForeignFn => ~\"foreign fn\",\n+      Type => ~\"type\",\n+      ForeignType => ~\"foreign type\",\n+      Mod => ~\"mod\",\n+      ForeignMod => ~\"foreign mod\",\n+      Enum => ~\"enum\",\n+      Variant => ~\"variant\",\n+      Impl => ~\"impl\",\n+      Trait => ~\"trait\",\n+      Class => ~\"class\",\n+      Struct => ~\"struct\",\n+      PublicField => ~\"public field\",\n+      PrivateField => ~\"private field\",\n+      InheritedField => ~\"inherited field\",\n     }\n }\n "}, {"sha": "7b2e2b8a2174998bc5fef09dd45be3daa7ecdc15", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=c8ce32e7f45a020eebcd7329fbe33e8b53f832a3", "patch": "@@ -88,7 +88,7 @@ fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::writer,\n fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n     do ebml_w.wr_tag(tag_class_mut) {\n         let val = match mt {\n-          class_immutable => 'i',\n+          class_immutable => 'a',\n           class_mutable => 'm'\n         };\n         ebml_w.writer.write(&[val as u8]);\n@@ -472,7 +472,7 @@ fn purity_static_method_family(p: purity) -> char {\n       unsafe_fn => 'U',\n       pure_fn => 'P',\n       impure_fn => 'F',\n-      extern_fn => 'E'\n+      _ => fail ~\"extern fn can't be static\"\n     }\n }\n \n@@ -813,19 +813,22 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         visit_expr: |_e, _cx, _v| { },\n         visit_item: |i, cx, v, copy ebml_w| {\n             visit::visit_item(i, cx, v);\n-            match check ecx.tcx.items.get(i.id) {\n+            match ecx.tcx.items.get(i.id) {\n               ast_map::node_item(_, pt) => {\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n               }\n+              _ => fail ~\"bad item\"\n             }\n         },\n         visit_foreign_item: |ni, cx, v, copy ebml_w| {\n             visit::visit_foreign_item(ni, cx, v);\n-            match check ecx.tcx.items.get(ni.id) {\n+            match ecx.tcx.items.get(ni.id) {\n               ast_map::node_foreign_item(_, abi, pt) => {\n                 encode_info_for_foreign_item(ecx, ebml_w, ni,\n                                              index, *pt, abi);\n               }\n+              // case for separate item and foreign-item tables\n+              _ => fail ~\"bad foreign item\"\n             }\n         }\n         with *visit::default_visitor()"}, {"sha": "3677dce74d8f56407ebe8574b0235d7fa43a50c2", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=c8ce32e7f45a020eebcd7329fbe33e8b53f832a3", "patch": "@@ -1,5 +1,8 @@\n // Type decoding\n \n+// tjc note: Would be great to have a `match check` macro equivalent\n+// for some of these\n+\n import syntax::ast;\n import syntax::ast::*;\n import syntax::ast_util;\n@@ -103,10 +106,11 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n         return ty::vstore_fixed(n);\n     }\n \n-    match check next(st) {\n+    match next(st) {\n       '~' => ty::vstore_uniq,\n       '@' => ty::vstore_box,\n-      '&' => ty::vstore_slice(parse_region(st))\n+      '&' => ty::vstore_slice(parse_region(st)),\n+      _ => fail ~\"parse_vstore: bad input\"\n     }\n }\n \n@@ -126,7 +130,7 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n }\n \n fn parse_bound_region(st: @pstate) -> ty::bound_region {\n-    match check next(st) {\n+    match next(st) {\n       's' => ty::br_self,\n       'a' => {\n         let id = parse_int(st) as uint;\n@@ -138,12 +142,13 @@ fn parse_bound_region(st: @pstate) -> ty::bound_region {\n         let id = parse_int(st);\n         assert next(st) == '|';\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n-      }\n+      },\n+      _ => fail ~\"parse_bound_region: bad input\"\n     }\n }\n \n fn parse_region(st: @pstate) -> ty::region {\n-    match check next(st) {\n+    match next(st) {\n       'b' => {\n         ty::re_bound(parse_bound_region(st))\n       }\n@@ -163,13 +168,15 @@ fn parse_region(st: @pstate) -> ty::region {\n       't' => {\n         ty::re_static\n       }\n+      _ => fail ~\"parse_region: bad input\"\n     }\n }\n \n fn parse_opt<T>(st: @pstate, f: fn() -> T) -> option<T> {\n-    match check next(st) {\n+    match next(st) {\n       'n' => none,\n-      's' => some(f())\n+      's' => some(f()),\n+      _ => fail ~\"parse_opt: bad input\"\n     }\n }\n \n@@ -183,15 +190,15 @@ fn parse_str(st: @pstate, term: char) -> ~str {\n }\n \n fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n-    match check next(st) {\n+    match next(st) {\n       'n' => return ty::mk_nil(st.tcx),\n       'z' => return ty::mk_bot(st.tcx),\n       'b' => return ty::mk_bool(st.tcx),\n       'i' => return ty::mk_int(st.tcx),\n       'u' => return ty::mk_uint(st.tcx),\n       'l' => return ty::mk_float(st.tcx),\n       'M' => {\n-        match check next(st) {\n+        match next(st) {\n           'b' => return ty::mk_mach_uint(st.tcx, ast::ty_u8),\n           'w' => return ty::mk_mach_uint(st.tcx, ast::ty_u16),\n           'l' => return ty::mk_mach_uint(st.tcx, ast::ty_u32),\n@@ -201,7 +208,8 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n           'L' => return ty::mk_mach_int(st.tcx, ast::ty_i32),\n           'D' => return ty::mk_mach_int(st.tcx, ast::ty_i64),\n           'f' => return ty::mk_mach_float(st.tcx, ast::ty_f32),\n-          'F' => return ty::mk_mach_float(st.tcx, ast::ty_f64)\n+          'F' => return ty::mk_mach_float(st.tcx, ast::ty_f64),\n+          _ => fail ~\"parse_ty: bad numeric type\"\n         }\n       }\n       'c' => return ty::mk_char(st.tcx),\n@@ -270,10 +278,11 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       'Y' => return ty::mk_type(st.tcx),\n       'C' => {\n-        let ck = match check next(st) {\n+        let ck = match next(st) {\n           '&' => ty::ck_block,\n           '@' => ty::ck_box,\n-          '~' => ty::ck_uniq\n+          '~' => ty::ck_uniq,\n+          _ => fail ~\"parse_ty: bad closure kind\"\n         };\n         return ty::mk_opaque_closure_ptr(st.tcx, ck);\n       }\n@@ -354,11 +363,12 @@ fn parse_hex(st: @pstate) -> uint {\n }\n \n fn parse_purity(c: char) -> purity {\n-    match check c {\n+    match c {\n       'u' => unsafe_fn,\n       'p' => pure_fn,\n       'i' => impure_fn,\n-      'c' => extern_fn\n+      'c' => extern_fn,\n+      _ => fail ~\"parse_purity: bad purity\"\n     }\n }\n \n@@ -369,12 +379,13 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     assert (next(st) == '[');\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n-        let mode = match check peek(st) {\n+        let mode = match peek(st) {\n           '&' => ast::by_mutbl_ref,\n           '-' => ast::by_move,\n           '+' => ast::by_copy,\n           '=' => ast::by_ref,\n-          '#' => ast::by_val\n+          '#' => ast::by_val,\n+          _ => fail ~\"bad mode\"\n         };\n         st.pos += 1u;\n         vec::push(inputs, {mode: ast::expl(mode), ty: parse_ty(st, conv)});\n@@ -422,13 +433,14 @@ fn parse_bounds_data(data: @~[u8], start: uint,\n fn parse_bounds(st: @pstate, conv: conv_did) -> @~[ty::param_bound] {\n     let mut bounds = ~[];\n     loop {\n-        vec::push(bounds, match check next(st) {\n+        vec::push(bounds, match next(st) {\n           'S' => ty::bound_send,\n           'C' => ty::bound_copy,\n           'K' => ty::bound_const,\n           'O' => ty::bound_owned,\n           'I' => ty::bound_trait(parse_ty(st, conv)),\n-          '.' => break\n+          '.' => break,\n+          _ => fail ~\"parse_bounds: bad bounds\"\n         });\n     }\n     @bounds"}]}