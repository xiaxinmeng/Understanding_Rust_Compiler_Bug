{"sha": "3fb88e95aa5e122a521beec766d5b1264ca4de3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYjg4ZTk1YWE1ZTEyMmE1MjFiZWVjNzY2ZDViMTI2NGNhNGRlM2I=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-23T15:35:14Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-25T07:52:50Z"}, "message": "switch modules to new diagnostics", "tree": {"sha": "17e5815f78f81f04fd462605288e09e82c8caee8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17e5815f78f81f04fd462605288e09e82c8caee8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fb88e95aa5e122a521beec766d5b1264ca4de3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fb88e95aa5e122a521beec766d5b1264ca4de3b", "html_url": "https://github.com/rust-lang/rust/commit/3fb88e95aa5e122a521beec766d5b1264ca4de3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fb88e95aa5e122a521beec766d5b1264ca4de3b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcca35969dd7c63a83ee34c4ce7d54cefdb72bbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcca35969dd7c63a83ee34c4ce7d54cefdb72bbe", "html_url": "https://github.com/rust-lang/rust/commit/fcca35969dd7c63a83ee34c4ce7d54cefdb72bbe"}], "stats": {"total": 291, "additions": 156, "deletions": 135}, "files": [{"sha": "03b1acef3bf8e7941b7479b2ba0784d840e809f0", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=3fb88e95aa5e122a521beec766d5b1264ca4de3b", "patch": "@@ -1,8 +1,7 @@\n use std::sync::Arc;\n \n-use relative_path::RelativePathBuf;\n use ra_db::{CrateId, SourceRootId, Edition};\n-use ra_syntax::{ast::self, TreeArc, SyntaxNode};\n+use ra_syntax::{ast::self, TreeArc};\n \n use crate::{\n     Name, ScopesWithSourceMap, Ty, HirFileId,\n@@ -96,11 +95,6 @@ pub enum ModuleSource {\n     Module(TreeArc<ast::Module>),\n }\n \n-#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Problem {\n-    UnresolvedModule { candidate: RelativePathBuf },\n-}\n-\n impl Module {\n     /// Name of this module.\n     pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n@@ -172,8 +166,8 @@ impl Module {\n         db.crate_def_map(self.krate)[self.module_id].scope.clone()\n     }\n \n-    pub fn problems(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        self.problems_impl(db)\n+    pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut Diagnostics) {\n+        db.crate_def_map(self.krate).add_diagnostics(db, self.module_id, sink);\n     }\n \n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n@@ -521,10 +515,8 @@ impl Function {\n         r\n     }\n \n-    pub fn diagnostics(&self, db: &impl HirDatabase) -> Diagnostics {\n-        let mut res = Diagnostics::default();\n-        self.infer(db).add_diagnostics(db, *self, &mut res);\n-        res\n+    pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut Diagnostics) {\n+        self.infer(db).add_diagnostics(db, *self, sink);\n     }\n }\n "}, {"sha": "14237060cfb755ea21868118072b2bbceca0d293", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=3fb88e95aa5e122a521beec766d5b1264ca4de3b", "patch": "@@ -1,8 +1,8 @@\n use ra_db::FileId;\n-use ra_syntax::{ast, SyntaxNode, TreeArc, AstNode};\n+use ra_syntax::{ast, TreeArc, AstNode};\n \n use crate::{\n-    Module, ModuleSource, Problem, Name,\n+    Module, ModuleSource, Name,\n     nameres::{CrateModuleId, ImportId},\n     HirDatabase, DefDatabase,\n     HirFileId, SourceItemId,\n@@ -108,19 +108,4 @@ impl Module {\n         let parent_id = def_map[self.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n-\n-    pub(crate) fn problems_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-    ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let (my_file_id, _) = self.definition_source(db);\n-        // FIXME: not entirely corret filterint by module\n-        def_map\n-            .problems()\n-            .iter()\n-            .filter(|(source_item_id, _problem)| my_file_id == source_item_id.file_id)\n-            .map(|(source_item_id, problem)| (db.file_item(*source_item_id), problem.clone()))\n-            .collect()\n-    }\n }"}, {"sha": "e8bb1ed92ede8064e4384a7279fc84764c5f183a", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=3fb88e95aa5e122a521beec766d5b1264ca4de3b", "patch": "@@ -3,7 +3,20 @@ use std::{fmt, any::Any};\n use ra_syntax::{SyntaxNodePtr, AstPtr, ast};\n \n use crate::HirFileId;\n+use relative_path::RelativePathBuf;\n \n+/// Diagnostic defines hir API for errors and warnings.\n+///\n+/// It is used as a `dyn` object, which you can downcast to a concrete\n+/// diagnostic. Diagnostics are structured, meaning that they include rich\n+/// information which can be used by IDE to create fixes. Diagnostics are\n+/// expressed in terms of macro-expanded syntax tree nodes (so, it's a bad idea\n+/// to diagnostic in a salsa value).\n+///\n+/// Internally, various subsystems of hir produce diagnostics specific to a\n+/// subsytem (typically, an `enum`), which are safe to store in salsa but do not\n+/// include source locations. Such internal diagnostic are transformed into an\n+/// instance of `Diagnostic` on demand.\n pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n     fn file(&self) -> HirFileId;\n     fn syntax_node(&self) -> SyntaxNodePtr;\n@@ -34,14 +47,8 @@ impl Diagnostics {\n \n #[derive(Debug)]\n pub struct NoSuchField {\n-    pub(crate) file: HirFileId,\n-    pub(crate) field: AstPtr<ast::NamedField>,\n-}\n-\n-impl NoSuchField {\n-    pub fn field(&self) -> AstPtr<ast::NamedField> {\n-        self.field\n-    }\n+    pub file: HirFileId,\n+    pub field: AstPtr<ast::NamedField>,\n }\n \n impl Diagnostic for NoSuchField {\n@@ -58,3 +65,25 @@ impl Diagnostic for NoSuchField {\n         self\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct UnresolvedModule {\n+    pub file: HirFileId,\n+    pub decl: AstPtr<ast::Module>,\n+    pub candidate: RelativePathBuf,\n+}\n+\n+impl Diagnostic for UnresolvedModule {\n+    fn file(&self) -> HirFileId {\n+        self.file\n+    }\n+    fn syntax_node(&self) -> SyntaxNodePtr {\n+        self.decl.into()\n+    }\n+    fn message(&self) -> String {\n+        \"unresolved module\".to_string()\n+    }\n+    fn as_any(&self) -> &(Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "ce54d76084a3e7391c4c1e0ac69092a8184ac7cc", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=3fb88e95aa5e122a521beec766d5b1264ca4de3b", "patch": "@@ -64,7 +64,7 @@ pub use self::{\n \n pub use self::code_model_api::{\n     Crate, CrateDependency,\n-    Module, ModuleDef, ModuleSource, Problem,\n+    Module, ModuleDef, ModuleSource,\n     Struct, Enum, EnumVariant,\n     Function, FnSignature,\n     StructField, FieldSource,"}, {"sha": "416f114b40737bb4f6ced408765176f1d93ee08a", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=3fb88e95aa5e122a521beec766d5b1264ca4de3b", "patch": "@@ -56,14 +56,17 @@ mod tests;\n use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n+use relative_path::RelativePathBuf;\n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{FileId, Edition};\n+use ra_syntax::{AstNode, AstPtr, ast};\n use test_utils::tested_by;\n \n use crate::{\n-    ModuleDef, Name, Crate, Module, Problem,\n+    ModuleDef, Name, Crate, Module,\n     DefDatabase, Path, PathKind, HirFileId,\n     ids::{SourceItemId, SourceFileItemId, MacroCallId},\n+    diagnostics::{Diagnostics, UnresolvedModule},\n };\n \n pub(crate) use self::raw::{RawItems, ImportId, ImportSourceMap};\n@@ -85,7 +88,7 @@ pub struct CrateDefMap {\n     macros: Arena<CrateMacroId, mbe::MacroRules>,\n     public_macros: FxHashMap<Name, CrateMacroId>,\n     macro_resolutions: FxHashMap<MacroCallId, (Crate, CrateMacroId)>,\n-    problems: CrateDefMapProblems,\n+    diagnostics: Vec<DefDiagnostic>,\n }\n \n impl std::ops::Index<CrateModuleId> for CrateDefMap {\n@@ -125,21 +128,6 @@ pub(crate) struct ModuleData {\n     pub(crate) definition: Option<FileId>,\n }\n \n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct CrateDefMapProblems {\n-    problems: Vec<(SourceItemId, Problem)>,\n-}\n-\n-impl CrateDefMapProblems {\n-    fn add(&mut self, source_item_id: SourceItemId, problem: Problem) {\n-        self.problems.push((source_item_id, problem))\n-    }\n-\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (&'a SourceItemId, &'a Problem)> + 'a {\n-        self.problems.iter().map(|(s, p)| (s, p))\n-    }\n-}\n-\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n     items: FxHashMap<Name, Resolution>,\n@@ -212,7 +200,7 @@ impl CrateDefMap {\n                 macros: Arena::default(),\n                 public_macros: FxHashMap::default(),\n                 macro_resolutions: FxHashMap::default(),\n-                problems: CrateDefMapProblems::default(),\n+                diagnostics: Vec::new(),\n             }\n         };\n         let def_map = collector::collect_defs(db, def_map);\n@@ -224,10 +212,6 @@ impl CrateDefMap {\n         self.root\n     }\n \n-    pub(crate) fn problems(&self) -> &CrateDefMapProblems {\n-        &self.problems\n-    }\n-\n     pub(crate) fn mk_module(&self, module_id: CrateModuleId) -> Module {\n         Module { krate: self.krate, module_id }\n     }\n@@ -240,6 +224,15 @@ impl CrateDefMap {\n         &self.extern_prelude\n     }\n \n+    pub(crate) fn add_diagnostics(\n+        &self,\n+        db: &impl DefDatabase,\n+        module: CrateModuleId,\n+        sink: &mut Diagnostics,\n+    ) {\n+        self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n+    }\n+\n     pub(crate) fn resolve_macro(\n         &self,\n         macro_call_id: MacroCallId,\n@@ -452,3 +445,31 @@ impl CrateDefMap {\n         }\n     }\n }\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum DefDiagnostic {\n+    UnresolvedModule {\n+        module: CrateModuleId,\n+        declaration: SourceItemId,\n+        candidate: RelativePathBuf,\n+    },\n+}\n+\n+impl DefDiagnostic {\n+    fn add_to(&self, db: &impl DefDatabase, target_module: CrateModuleId, sink: &mut Diagnostics) {\n+        match self {\n+            DefDiagnostic::UnresolvedModule { module, declaration, candidate } => {\n+                if *module != target_module {\n+                    return;\n+                }\n+                let syntax = db.file_item(*declaration);\n+                let decl = ast::Module::cast(&syntax).unwrap();\n+                sink.push(UnresolvedModule {\n+                    file: declaration.file_id,\n+                    decl: AstPtr::new(&decl),\n+                    candidate: candidate.clone(),\n+                })\n+            }\n+        }\n+    }\n+}"}, {"sha": "bc6bc5e7fd4bd8132dc5c875a4c7fa43d519600d", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=3fb88e95aa5e122a521beec766d5b1264ca4de3b", "patch": "@@ -6,9 +6,9 @@ use ra_db::FileId;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path, Problem, Crate,\n+    DefDatabase, HirFileId, Name, Path, Crate,\n     KnownName,\n-    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode, raw},\n+    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode, raw, DefDiagnostic},\n     ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n };\n \n@@ -405,25 +405,27 @@ where\n             raw::ModuleData::Declaration { name, source_item_id } => {\n                 let source_item_id = source_item_id.with_file_id(self.file_id);\n                 let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n-                let (file_ids, problem) =\n-                    resolve_submodule(self.def_collector.db, self.file_id, name, is_root);\n-\n-                if let Some(problem) = problem {\n-                    self.def_collector.def_map.problems.add(source_item_id, problem)\n-                }\n-\n-                if let Some(&file_id) = file_ids.first() {\n-                    let module_id =\n-                        self.push_child_module(name.clone(), source_item_id, Some(file_id));\n-                    let raw_items = self.def_collector.db.raw_items(file_id);\n-                    ModCollector {\n-                        def_collector: &mut *self.def_collector,\n-                        module_id,\n-                        file_id: file_id.into(),\n-                        raw_items: &raw_items,\n+                match resolve_submodule(self.def_collector.db, self.file_id, name, is_root) {\n+                    Ok(file_id) => {\n+                        let module_id =\n+                            self.push_child_module(name.clone(), source_item_id, Some(file_id));\n+                        let raw_items = self.def_collector.db.raw_items(file_id);\n+                        ModCollector {\n+                            def_collector: &mut *self.def_collector,\n+                            module_id,\n+                            file_id: file_id.into(),\n+                            raw_items: &raw_items,\n+                        }\n+                        .collect(raw_items.items())\n                     }\n-                    .collect(raw_items.items())\n-                }\n+                    Err(candidate) => self.def_collector.def_map.diagnostics.push(\n+                        DefDiagnostic::UnresolvedModule {\n+                            module: self.module_id,\n+                            declaration: source_item_id,\n+                            candidate,\n+                        },\n+                    ),\n+                };\n             }\n         }\n     }\n@@ -524,7 +526,7 @@ fn resolve_submodule(\n     file_id: HirFileId,\n     name: &Name,\n     is_root: bool,\n-) -> (Vec<FileId>, Option<Problem>) {\n+) -> Result<FileId, RelativePathBuf> {\n     // FIXME: handle submodules of inline modules properly\n     let file_id = file_id.original_file(db);\n     let source_root_id = db.file_source_root(file_id);\n@@ -545,17 +547,10 @@ fn resolve_submodule(\n         candidates.push(file_dir_mod.clone());\n     };\n     let sr = db.source_root(source_root_id);\n-    let points_to = candidates\n-        .into_iter()\n-        .filter_map(|path| sr.files.get(&path))\n-        .map(|&it| it)\n-        .collect::<Vec<_>>();\n-    let problem = if points_to.is_empty() {\n-        Some(Problem::UnresolvedModule {\n-            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n-        })\n-    } else {\n-        None\n-    };\n-    (points_to, problem)\n+    let mut points_to = candidates.into_iter().filter_map(|path| sr.files.get(&path)).map(|&it| it);\n+    // FIXME: handle ambiguity\n+    match points_to.next() {\n+        Some(file_id) => Ok(file_id),\n+        None => Err(if is_dir_owner { file_mod } else { file_dir_mod }),\n+    }\n }"}, {"sha": "6dc3edc7a1aa63a722b99936d99c49f1d483f9b8", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=3fb88e95aa5e122a521beec766d5b1264ca4de3b", "patch": "@@ -120,9 +120,9 @@ impl InferenceResult {\n         &self,\n         db: &impl HirDatabase,\n         owner: Function,\n-        diagnostics: &mut Diagnostics,\n+        sink: &mut Diagnostics,\n     ) {\n-        self.diagnostics.iter().for_each(|it| it.add_to(db, owner, diagnostics))\n+        self.diagnostics.iter().for_each(|it| it.add_to(db, owner, sink))\n     }\n }\n \n@@ -1277,12 +1277,17 @@ mod diagnostics {\n     }\n \n     impl InferenceDiagnostic {\n-        pub(super) fn add_to(&self, db: &impl HirDatabase, owner: Function, acc: &mut Diagnostics) {\n+        pub(super) fn add_to(\n+            &self,\n+            db: &impl HirDatabase,\n+            owner: Function,\n+            sink: &mut Diagnostics,\n+        ) {\n             match self {\n                 InferenceDiagnostic::NoSuchField { expr, field } => {\n                     let (file, _) = owner.source(db);\n                     let field = owner.body_source_map(db).field_syntax(*expr, *field);\n-                    acc.push(NoSuchField { file, field })\n+                    sink.push(NoSuchField { file, field })\n                 }\n             }\n         }"}, {"sha": "254342c0a6b43f9840147c5230678e0b1ccb3a51", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb88e95aa5e122a521beec766d5b1264ca4de3b/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=3fb88e95aa5e122a521beec766d5b1264ca4de3b", "patch": "@@ -1,5 +1,5 @@\n use itertools::Itertools;\n-use hir::{Problem, source_binder};\n+use hir::{source_binder, diagnostics::Diagnostic as _};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n@@ -28,7 +28,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n     }\n \n     if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n-        check_module(&mut res, db, file_id, m);\n+        check_module(&mut res, db, m);\n     };\n     res\n }\n@@ -128,46 +128,40 @@ fn check_struct_shorthand_initialization(\n     Some(())\n }\n \n-fn check_module(\n-    acc: &mut Vec<Diagnostic>,\n-    db: &RootDatabase,\n-    file_id: FileId,\n-    module: hir::Module,\n-) {\n+fn check_module(acc: &mut Vec<Diagnostic>, db: &RootDatabase, module: hir::Module) {\n+    let mut diagnostics = hir::diagnostics::Diagnostics::default();\n+    module.diagnostics(db, &mut diagnostics);\n     for decl in module.declarations(db) {\n         match decl {\n-            hir::ModuleDef::Function(f) => check_function(acc, db, f),\n+            hir::ModuleDef::Function(f) => f.diagnostics(db, &mut diagnostics),\n             _ => (),\n         }\n     }\n \n-    let source_root = db.file_source_root(file_id);\n-    for (name_node, problem) in module.problems(db) {\n-        let diag = match problem {\n-            Problem::UnresolvedModule { candidate } => {\n-                let create_file =\n-                    FileSystemEdit::CreateFile { source_root, path: candidate.clone() };\n-                let fix = SourceChange::file_system_edit(\"create module\", create_file);\n-                Diagnostic {\n-                    range: name_node.range(),\n-                    message: \"unresolved module\".to_string(),\n-                    severity: Severity::Error,\n-                    fix: Some(fix),\n-                }\n-            }\n-        };\n-        acc.push(diag)\n-    }\n-}\n-\n-fn check_function(acc: &mut Vec<Diagnostic>, db: &RootDatabase, function: hir::Function) {\n-    for d in function.diagnostics(db).iter() {\n-        acc.push(Diagnostic {\n-            message: d.message(),\n-            range: d.syntax_node().range(),\n-            severity: Severity::Error,\n-            fix: None,\n-        })\n+    for d in diagnostics.iter() {\n+        if let Some(d) = d.downcast_ref::<hir::diagnostics::UnresolvedModule>() {\n+            let source_root = db.file_source_root(d.file().original_file(db));\n+            let create_file = FileSystemEdit::CreateFile { source_root, path: d.candidate.clone() };\n+            let fix = SourceChange {\n+                label: \"create module\".to_string(),\n+                source_file_edits: Vec::new(),\n+                file_system_edits: vec![create_file],\n+                cursor_position: None,\n+            };\n+            acc.push(Diagnostic {\n+                range: d.syntax_node().range(),\n+                message: d.message(),\n+                severity: Severity::Error,\n+                fix: Some(fix),\n+            })\n+        } else {\n+            acc.push(Diagnostic {\n+                message: d.message(),\n+                range: d.syntax_node().range(),\n+                severity: Severity::Error,\n+                fix: None,\n+            })\n+        }\n     }\n }\n "}]}