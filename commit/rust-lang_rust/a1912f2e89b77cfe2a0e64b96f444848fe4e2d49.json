{"sha": "a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExOTEyZjJlODliNzdjZmUyYTBlNjRiOTZmNDQ0ODQ4ZmU0ZTJkNDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T19:31:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T19:31:49Z"}, "message": "Auto merge of #68679 - matthewjasper:needs-type-op, r=varkor\n\nImprove `ty.needs_drop`\n\n* Handle cycles in `needs_drop` correctly\n* Normalize types when computing `needs_drop`\n* Move queries from rustc to rustc_ty\n* Avoid query in simple cases\n\nreopens #65918", "tree": {"sha": "3d83c761220edeb1195c6a876f8baef0b1d90c56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d83c761220edeb1195c6a876f8baef0b1d90c56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "html_url": "https://github.com/rust-lang/rust/commit/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d2be570970d784db5539a1d309cd22b85be910a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2be570970d784db5539a1d309cd22b85be910a", "html_url": "https://github.com/rust-lang/rust/commit/2d2be570970d784db5539a1d309cd22b85be910a"}, {"sha": "30a8353f372f7cc719d1de6811996ce5215183a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a8353f372f7cc719d1de6811996ce5215183a6", "html_url": "https://github.com/rust-lang/rust/commit/30a8353f372f7cc719d1de6811996ce5215183a6"}], "stats": {"total": 500, "additions": 337, "deletions": 163}, "files": [{"sha": "11b079806af2d443f017fa3e2bbb9abcc92d5e3a", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -669,26 +669,29 @@ rustc_queries! {\n             no_force\n             desc { \"computing whether `{}` is `Copy`\", env.value }\n         }\n+        /// Query backing `TyS::is_sized`.\n         query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n             no_force\n             desc { \"computing whether `{}` is `Sized`\", env.value }\n         }\n+        /// Query backing `TyS::is_freeze`.\n         query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n             no_force\n             desc { \"computing whether `{}` is freeze\", env.value }\n         }\n-\n-        // The cycle error here should be reported as an error by `check_representable`.\n-        // We consider the type as not needing drop in the meanwhile to avoid\n-        // further errors (done in impl Value for NeedsDrop).\n-        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n-        // in case we accidentally otherwise don't emit an error.\n-        query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n-            cycle_delay_bug\n+        /// Query backing `TyS::needs_drop`.\n+        query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n             no_force\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n+        /// A list of types where the ADT requires drop if and only if any of\n+        /// those types require drop. If the ADT is known to always need drop\n+        /// then `Err(AlwaysRequiresDrop)` is returned.\n+        query adt_drop_tys(_: DefId) -> Result<&'tcx ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {\n+            cache_on_disk_if { true }\n+        }\n+\n         query layout_raw(\n             env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Result<&'tcx ty::layout::LayoutDetails, ty::layout::LayoutError<'tcx>> {"}, {"sha": "3fd0d12c626aa9de6132e1ed26d8473f815395c9", "filename": "src/librustc/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmisc.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -1,12 +1,9 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n-use crate::middle::lang_items;\n use crate::traits::{self, ObligationCause};\n-use crate::ty::util::NeedsDrop;\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc_hir as hir;\n-use rustc_span::DUMMY_SP;\n \n #[derive(Clone)]\n pub enum CopyImplementationError<'tcx> {\n@@ -71,132 +68,3 @@ pub fn can_type_implement_copy(\n         Ok(())\n     })\n }\n-\n-fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n-}\n-\n-fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n-}\n-\n-fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n-}\n-\n-fn is_item_raw<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    item: lang_items::LangItem,\n-) -> bool {\n-    let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(item, None);\n-    tcx.infer_ctxt().enter(|infcx| {\n-        traits::type_known_to_meet_bound_modulo_regions(\n-            &infcx,\n-            param_env,\n-            ty,\n-            trait_def_id,\n-            DUMMY_SP,\n-        )\n-    })\n-}\n-\n-fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n-    let (param_env, ty) = query.into_parts();\n-\n-    let needs_drop = |ty: Ty<'tcx>| -> bool { tcx.needs_drop_raw(param_env.and(ty)).0 };\n-\n-    assert!(!ty.needs_infer());\n-\n-    NeedsDrop(match ty.kind {\n-        // Fast-path for primitive types\n-        ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Bool\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Never\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Char\n-        | ty::GeneratorWitness(..)\n-        | ty::RawPtr(_)\n-        | ty::Ref(..)\n-        | ty::Str => false,\n-\n-        // Foreign types can never have destructors\n-        ty::Foreign(..) => false,\n-\n-        // `ManuallyDrop` doesn't have a destructor regardless of field types.\n-        ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n-\n-        // Issue #22536: We first query `is_copy_modulo_regions`.  It sees a\n-        // normalized version of the type, and therefore will definitely\n-        // know whether the type implements Copy (and thus needs no\n-        // cleanup/drop/zeroing) ...\n-        _ if ty.is_copy_modulo_regions(tcx, param_env, DUMMY_SP) => false,\n-\n-        // ... (issue #22536 continued) but as an optimization, still use\n-        // prior logic of asking for the structural \"may drop\".\n-\n-        // FIXME(#22815): Note that this is a conservative heuristic;\n-        // it may report that the type \"may drop\" when actual type does\n-        // not actually have a destructor associated with it. But since\n-        // the type absolutely did not have the `Copy` bound attached\n-        // (see above), it is sound to treat it as having a destructor.\n-\n-        // User destructors are the only way to have concrete drop types.\n-        ty::Adt(def, _) if def.has_dtor(tcx) => true,\n-\n-        // Can refer to a type which may drop.\n-        // FIXME(eddyb) check this against a ParamEnv.\n-        ty::Dynamic(..)\n-        | ty::Projection(..)\n-        | ty::Param(_)\n-        | ty::Bound(..)\n-        | ty::Placeholder(..)\n-        | ty::Opaque(..)\n-        | ty::Infer(_)\n-        | ty::Error => true,\n-\n-        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n-        // Zero-length arrays never contain anything to drop.\n-        ty::Array(_, len) if len.try_eval_usize(tcx, param_env) == Some(0) => false,\n-\n-        // Structural recursion.\n-        ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n-\n-        ty::Closure(def_id, ref substs) => {\n-            substs.as_closure().upvar_tys(def_id, tcx).any(needs_drop)\n-        }\n-\n-        // Pessimistically assume that all generators will require destructors\n-        // as we don't know if a destructor is a noop or not until after the MIR\n-        // state transformation pass\n-        ty::Generator(..) => true,\n-\n-        ty::Tuple(..) => ty.tuple_fields().any(needs_drop),\n-\n-        // unions don't have destructors because of the child types,\n-        // only if they manually implement `Drop` (handled above).\n-        ty::Adt(def, _) if def.is_union() => false,\n-\n-        ty::Adt(def, substs) => def\n-            .variants\n-            .iter()\n-            .any(|variant| variant.fields.iter().any(|field| needs_drop(field.ty(tcx, substs)))),\n-    })\n-}\n-\n-pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    *providers = ty::query::Providers {\n-        is_copy_raw,\n-        is_sized_raw,\n-        is_freeze_raw,\n-        needs_drop_raw,\n-        ..*providers\n-    };\n-}"}, {"sha": "556e69b04f8243442e95be9c59946bc1ee148d96", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -633,7 +633,6 @@ impl<'tcx> TraitObligation<'tcx> {\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    misc::provide(providers);\n     *providers = ty::query::Providers {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,"}, {"sha": "335953fc41eddffece47b579899c75a9b1e40942", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -285,7 +285,7 @@ impl<'tcx> Instance<'tcx> {\n                 _ => {\n                     if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n                         let ty = substs.type_at(0);\n-                        if ty.needs_drop(tcx, ty::ParamEnv::reveal_all()) {\n+                        if ty.needs_drop(tcx, param_env.with_reveal_all()) {\n                             debug!(\" => nontrivial drop glue\");\n                             ty::InstanceDef::DropGlue(def_id, Some(ty))\n                         } else {"}, {"sha": "393d49a4e4b057be1c11938aeb97747dd43c5ad4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -1796,19 +1796,22 @@ bitflags! {\n         const IS_STRUCT           = 1 << 2;\n         /// Indicates whether the ADT is a struct and has a constructor.\n         const HAS_CTOR            = 1 << 3;\n-        /// Indicates whether the type is a `PhantomData`.\n+        /// Indicates whether the type is `PhantomData`.\n         const IS_PHANTOM_DATA     = 1 << 4;\n         /// Indicates whether the type has a `#[fundamental]` attribute.\n         const IS_FUNDAMENTAL      = 1 << 5;\n-        /// Indicates whether the type is a `Box`.\n+        /// Indicates whether the type is `Box`.\n         const IS_BOX              = 1 << 6;\n+        /// Indicates whether the type is `ManuallyDrop`.\n+        const IS_MANUALLY_DROP    = 1 << 7;\n+        // FIXME(matthewjasper) replace these with diagnostic items\n         /// Indicates whether the type is an `Arc`.\n-        const IS_ARC              = 1 << 7;\n+        const IS_ARC              = 1 << 8;\n         /// Indicates whether the type is an `Rc`.\n-        const IS_RC               = 1 << 8;\n+        const IS_RC               = 1 << 9;\n         /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n         /// (i.e., this flag is never set unless this ADT is an enum).\n-        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 9;\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 10;\n     }\n }\n \n@@ -2190,6 +2193,9 @@ impl<'tcx> AdtDef {\n         if Some(did) == tcx.lang_items().owned_box() {\n             flags |= AdtFlags::IS_BOX;\n         }\n+        if Some(did) == tcx.lang_items().manually_drop() {\n+            flags |= AdtFlags::IS_MANUALLY_DROP;\n+        }\n         if Some(did) == tcx.lang_items().arc() {\n             flags |= AdtFlags::IS_ARC;\n         }\n@@ -2290,6 +2296,12 @@ impl<'tcx> AdtDef {\n         self.flags.contains(AdtFlags::IS_BOX)\n     }\n \n+    /// Returns `true` if this is `ManuallyDrop<T>`.\n+    #[inline]\n+    pub fn is_manually_drop(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_MANUALLY_DROP)\n+    }\n+\n     /// Returns `true` if this type has a destructor.\n     pub fn has_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n         self.destructor(tcx).is_some()"}, {"sha": "2c51a0934278daafd03027f9b7e6a1a1417b661f", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -33,7 +33,7 @@ use crate::traits::Clauses;\n use crate::traits::{self, Vtable};\n use crate::ty::steal::Steal;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::util::NeedsDrop;\n+use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use crate::util::common::ErrorReported;\n use rustc_data_structures::fingerprint::Fingerprint;"}, {"sha": "b01d15c29b2db7612ec265c9529941a222a5f932", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -1,4 +1,3 @@\n-use crate::ty::util::NeedsDrop;\n use crate::ty::{self, AdtSizedConstraint, Ty, TyCtxt};\n \n use rustc_span::symbol::Symbol;\n@@ -26,12 +25,6 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for NeedsDrop {\n-    fn from_cycle_error(_: TyCtxt<'tcx>) -> Self {\n-        NeedsDrop(false)\n-    }\n-}\n-\n impl<'tcx> Value<'tcx> for AdtSizedConstraint<'tcx> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n         AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err]))"}, {"sha": "db7b8d8cfd9ed999a663cd909f58f9c4b5262b95", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -18,6 +18,8 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_span::Span;\n+use rustc_target::abi::TargetDataLayout;\n+use smallvec::SmallVec;\n use std::{cmp, fmt};\n use syntax::ast;\n \n@@ -724,7 +726,23 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// Note that this method is used to check eligible types in unions.\n     #[inline]\n     pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        tcx.needs_drop_raw(param_env.and(self)).0\n+        // Avoid querying in simple cases.\n+        match needs_drop_components(self, &tcx.data_layout) {\n+            Err(AlwaysRequiresDrop) => true,\n+            Ok(components) => {\n+                let query_ty = match *components {\n+                    [] => return false,\n+                    // If we've got a single component, call the query with that\n+                    // to increase the chance that we hit the query cache.\n+                    [component_ty] => component_ty,\n+                    _ => self,\n+                };\n+                // This doesn't depend on regions, so try to minimize distinct\n+                // query keys used.\n+                let erased = tcx.normalize_erasing_regions(param_env, query_ty);\n+                tcx.needs_drop_raw(param_env.and(erased))\n+            }\n+        }\n     }\n \n     pub fn same_type(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n@@ -923,9 +941,6 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-#[derive(Clone, HashStable)]\n-pub struct NeedsDrop(pub bool);\n-\n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n     ByReference(ty::Region<'tcx>, hir::Mutability),\n@@ -974,3 +989,72 @@ impl<'tcx> ExplicitSelf<'tcx> {\n         }\n     }\n }\n+\n+/// Returns a list of types such that the given type needs drop if and only if\n+/// *any* of the returned types need drop. Returns `Err(AlwaysRequiresDrop)` if\n+/// this type always needs drop.\n+pub fn needs_drop_components(\n+    ty: Ty<'tcx>,\n+    target_layout: &TargetDataLayout,\n+) -> Result<SmallVec<[Ty<'tcx>; 2]>, AlwaysRequiresDrop> {\n+    match ty.kind {\n+        ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Bool\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Never\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Char\n+        | ty::GeneratorWitness(..)\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n+        | ty::Str => Ok(SmallVec::new()),\n+\n+        // Foreign types can never have destructors.\n+        ty::Foreign(..) => Ok(SmallVec::new()),\n+\n+        // Pessimistically assume that all generators will require destructors\n+        // as we don't know if a destructor is a noop or not until after the MIR\n+        // state transformation pass.\n+        ty::Generator(..) | ty::Dynamic(..) | ty::Error => Err(AlwaysRequiresDrop),\n+\n+        ty::Slice(ty) => needs_drop_components(ty, target_layout),\n+        ty::Array(elem_ty, size) => {\n+            match needs_drop_components(elem_ty, target_layout) {\n+                Ok(v) if v.is_empty() => Ok(v),\n+                res => match size.val.try_to_bits(target_layout.pointer_size) {\n+                    // Arrays of size zero don't need drop, even if their element\n+                    // type does.\n+                    Some(0) => Ok(SmallVec::new()),\n+                    Some(_) => res,\n+                    // We don't know which of the cases above we are in, so\n+                    // return the whole type and let the caller decide what to\n+                    // do.\n+                    None => Ok(smallvec![ty]),\n+                },\n+            }\n+        }\n+        // If any field needs drop, then the whole tuple does.\n+        ty::Tuple(..) => ty.tuple_fields().try_fold(SmallVec::new(), move |mut acc, elem| {\n+            acc.extend(needs_drop_components(elem, target_layout)?);\n+            Ok(acc)\n+        }),\n+\n+        // These require checking for `Copy` bounds or `Adt` destructors.\n+        ty::Adt(..)\n+        | ty::Projection(..)\n+        | ty::UnnormalizedProjection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        | ty::Closure(..) => Ok(smallvec![ty]),\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, HashStable, RustcEncodable, RustcDecodable)]\n+pub struct AlwaysRequiresDrop;"}, {"sha": "9fe8a19311fb67e58a0ce2718048d4aae16608be", "filename": "src/librustc_ty/common_traits.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_ty%2Fcommon_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_ty%2Fcommon_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fcommon_traits.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -0,0 +1,40 @@\n+//! Queries for checking whether a type implements one of a few common traits.\n+\n+use rustc::middle::lang_items;\n+use rustc::traits;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+\n+fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n+}\n+\n+fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n+}\n+\n+fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n+}\n+\n+fn is_item_raw<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    item: lang_items::LangItem,\n+) -> bool {\n+    let (param_env, ty) = query.into_parts();\n+    let trait_def_id = tcx.require_lang_item(item, None);\n+    tcx.infer_ctxt().enter(|infcx| {\n+        traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        )\n+    })\n+}\n+\n+pub(crate) fn provide(providers: &mut ty::query::Providers<'_>) {\n+    *providers = ty::query::Providers { is_copy_raw, is_sized_raw, is_freeze_raw, ..*providers };\n+}"}, {"sha": "7eef19b94e40129fa2549ae4f4dacdd7c390a273", "filename": "src/librustc_ty/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_ty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_ty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Flib.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -6,7 +6,6 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(bool_to_option)]\n-#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]\n \n@@ -17,8 +16,12 @@ extern crate log;\n \n use rustc::ty::query::Providers;\n \n+mod common_traits;\n+mod needs_drop;\n mod ty;\n \n pub fn provide(providers: &mut Providers<'_>) {\n+    common_traits::provide(providers);\n+    needs_drop::provide(providers);\n     ty::provide(providers);\n }"}, {"sha": "0f71246c73759353a7d8a45bd1f1b6f20355b066", "filename": "src/librustc_ty/needs_drop.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_ty%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_ty%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fneeds_drop.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -0,0 +1,165 @@\n+//! Check whether a type has (potentially) non-trivial drop glue.\n+\n+use rustc::ty::subst::Subst;\n+use rustc::ty::util::{needs_drop_components, AlwaysRequiresDrop};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::DUMMY_SP;\n+\n+type NeedsDropResult<T> = Result<T, AlwaysRequiresDrop>;\n+\n+fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    let adt_fields =\n+        move |adt_def: &ty::AdtDef| tcx.adt_drop_tys(adt_def.did).map(|tys| tys.iter().copied());\n+    // If we don't know a type doesn't need drop, for example if it's a type\n+    // parameter without a `Copy` bound, then we conservatively return that it\n+    // needs drop.\n+    let res = NeedsDropTypes::new(tcx, query.param_env, query.value, adt_fields).next().is_some();\n+    debug!(\"needs_drop_raw({:?}) = {:?}\", query, res);\n+    res\n+}\n+\n+struct NeedsDropTypes<'tcx, F> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    query_ty: Ty<'tcx>,\n+    seen_tys: FxHashSet<Ty<'tcx>>,\n+    /// A stack of types left to process, and the recursion depth when we\n+    /// pushed that type. Each round, we pop something from the stack and check\n+    /// if it needs drop. If the result depends on whether some other types\n+    /// need drop we push them onto the stack.\n+    unchecked_tys: Vec<(Ty<'tcx>, usize)>,\n+    recursion_limit: usize,\n+    adt_components: F,\n+}\n+\n+impl<'tcx, F> NeedsDropTypes<'tcx, F> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        adt_components: F,\n+    ) -> Self {\n+        let mut seen_tys = FxHashSet::default();\n+        seen_tys.insert(ty);\n+        let recursion_limit = *tcx.sess.recursion_limit.get();\n+        Self {\n+            tcx,\n+            param_env,\n+            seen_tys,\n+            query_ty: ty,\n+            unchecked_tys: vec![(ty, 0)],\n+            recursion_limit,\n+            adt_components,\n+        }\n+    }\n+}\n+\n+impl<'tcx, F, I> Iterator for NeedsDropTypes<'tcx, F>\n+where\n+    F: Fn(&ty::AdtDef) -> NeedsDropResult<I>,\n+    I: Iterator<Item = Ty<'tcx>>,\n+{\n+    type Item = NeedsDropResult<Ty<'tcx>>;\n+\n+    fn next(&mut self) -> Option<NeedsDropResult<Ty<'tcx>>> {\n+        let tcx = self.tcx;\n+\n+        while let Some((ty, level)) = self.unchecked_tys.pop() {\n+            if level > self.recursion_limit {\n+                // Not having a `Span` isn't great. But there's hopefully some other\n+                // recursion limit error as well.\n+                tcx.sess.span_err(\n+                    DUMMY_SP,\n+                    &format!(\"overflow while checking whether `{}` requires drop\", self.query_ty),\n+                );\n+                return Some(Err(AlwaysRequiresDrop));\n+            }\n+\n+            let components = match needs_drop_components(ty, &tcx.data_layout) {\n+                Err(e) => return Some(Err(e)),\n+                Ok(components) => components,\n+            };\n+            debug!(\"needs_drop_components({:?}) = {:?}\", ty, components);\n+\n+            let queue_type = move |this: &mut Self, component: Ty<'tcx>| {\n+                if this.seen_tys.insert(component) {\n+                    this.unchecked_tys.push((component, level + 1));\n+                }\n+            };\n+\n+            for component in components {\n+                match component.kind {\n+                    _ if component.is_copy_modulo_regions(tcx, self.param_env, DUMMY_SP) => (),\n+\n+                    ty::Closure(def_id, substs) => {\n+                        for upvar_ty in substs.as_closure().upvar_tys(def_id, tcx) {\n+                            queue_type(self, upvar_ty);\n+                        }\n+                    }\n+\n+                    // Check for a `Drop` impl and whether this is a union or\n+                    // `ManuallyDrop`. If it's a struct or enum without a `Drop`\n+                    // impl then check whether the field types need `Drop`.\n+                    ty::Adt(adt_def, substs) => {\n+                        let tys = match (self.adt_components)(adt_def) {\n+                            Err(e) => return Some(Err(e)),\n+                            Ok(tys) => tys,\n+                        };\n+                        for required_ty in tys {\n+                            let subst_ty = tcx.normalize_erasing_regions(\n+                                self.param_env,\n+                                required_ty.subst(tcx, substs),\n+                            );\n+                            queue_type(self, subst_ty);\n+                        }\n+                    }\n+                    ty::Array(..) | ty::Opaque(..) | ty::Projection(..) | ty::Param(_) => {\n+                        if ty == component {\n+                            // Return the type to the caller: they may be able\n+                            // to normalize further than we can.\n+                            return Some(Ok(component));\n+                        } else {\n+                            // Store the type for later. We can't return here\n+                            // because we would then lose any other components\n+                            // of the type.\n+                            queue_type(self, component);\n+                        }\n+                    }\n+                    _ => return Some(Err(AlwaysRequiresDrop)),\n+                }\n+            }\n+        }\n+\n+        return None;\n+    }\n+}\n+\n+fn adt_drop_tys(tcx: TyCtxt<'_>, def_id: DefId) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n+    let adt_components = move |adt_def: &ty::AdtDef| {\n+        if adt_def.is_manually_drop() {\n+            debug!(\"adt_drop_tys: `{:?}` is manually drop\", adt_def);\n+            return Ok(Vec::new().into_iter());\n+        } else if adt_def.destructor(tcx).is_some() {\n+            debug!(\"adt_drop_tys: `{:?}` implements `Drop`\", adt_def);\n+            return Err(AlwaysRequiresDrop);\n+        } else if adt_def.is_union() {\n+            debug!(\"adt_drop_tys: `{:?}` is a union\", adt_def);\n+            return Ok(Vec::new().into_iter());\n+        }\n+        Ok(adt_def.all_fields().map(|field| tcx.type_of(field.did)).collect::<Vec<_>>().into_iter())\n+    };\n+\n+    let adt_ty = tcx.type_of(def_id);\n+    let param_env = tcx.param_env(def_id);\n+    let res: Result<Vec<_>, _> =\n+        NeedsDropTypes::new(tcx, param_env, adt_ty, adt_components).collect();\n+\n+    debug!(\"adt_drop_tys(`{}`) = `{:?}`\", tcx.def_path_str(def_id), res);\n+    res.map(|components| tcx.intern_type_list(&components))\n+}\n+\n+pub(crate) fn provide(providers: &mut ty::query::Providers<'_>) {\n+    *providers = ty::query::Providers { needs_drop_raw, adt_drop_tys, ..*providers };\n+}"}, {"sha": "ddb7c8bc79143b77af38b87d4628fba80f9d0de5", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -9,7 +9,11 @@ use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n-fn sized_constraint_for_ty(tcx: TyCtxt<'tcx>, adtdef: &ty::AdtDef, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n+fn sized_constraint_for_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    adtdef: &ty::AdtDef,\n+    ty: Ty<'tcx>,\n+) -> Vec<Ty<'tcx>> {\n     use ty::TyKind::*;\n \n     let result = match ty.kind {"}, {"sha": "0bdf7ba1a569e5745146b42218edeb5a3272ce95", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -1558,11 +1558,11 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: DefId) -> bool {\n     if let ty::Adt(def, substs) = item_type.kind {\n         assert!(def.is_union());\n         let fields = &def.non_enum_variant().fields;\n+        let param_env = tcx.param_env(item_def_id);\n         for field in fields {\n             let field_ty = field.ty(tcx, substs);\n             // We are currently checking the type this field came from, so it must be local.\n             let field_span = tcx.hir().span_if_local(field.did).unwrap();\n-            let param_env = tcx.param_env(field.did);\n             if field_ty.needs_drop(tcx, param_env) {\n                 struct_span_err!(\n                     tcx.sess,"}, {"sha": "bf1eaef367d69d05b0ae4519fb5eda80fd6700f7", "filename": "src/test/ui/recursion/recursion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Ftest%2Fui%2Frecursion%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Ftest%2Fui%2Frecursion%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursion.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -1,4 +1,5 @@\n // build-fail\n+// compile-flags:-C overflow-checks=off\n \n enum Nil {NilValue}\n struct Cons<T> {head:isize, tail:T}"}, {"sha": "1a65b0e84f6a3e399855166184b8e43b5f135bb6", "filename": "src/test/ui/recursion/recursion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -1,5 +1,5 @@\n error: reached the recursion limit while instantiating `test::<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Nil>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n-  --> $DIR/recursion.rs:14:1\n+  --> $DIR/recursion.rs:15:1\n    |\n LL | / fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n LL | |   match n {    0 => {first.dot(second)}"}, {"sha": "4ba778d53ac08a2fb4bca339155cd1d38c58a950", "filename": "src/test/ui/type-alias-impl-trait/issue-65918.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65918.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65918.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65918.rs?ref=a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test: This now ICEs again.\n+\n // build-pass\n \n #![feature(type_alias_impl_trait)]"}]}