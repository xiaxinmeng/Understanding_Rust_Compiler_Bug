{"sha": "467c86f4cbdd610f5f67a6dc4e97a4d1a5567e59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2N2M4NmY0Y2JkZDYxMGY1ZjY3YTZkYzRlOTdhNGQxYTU1NjdlNTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-03T06:33:25Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T21:41:28Z"}, "message": "parse_stmt_without_recovery: readability!", "tree": {"sha": "a1fe742f9306c66a54c3d6b977f136766aa59412", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1fe742f9306c66a54c3d6b977f136766aa59412"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/467c86f4cbdd610f5f67a6dc4e97a4d1a5567e59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/467c86f4cbdd610f5f67a6dc4e97a4d1a5567e59", "html_url": "https://github.com/rust-lang/rust/commit/467c86f4cbdd610f5f67a6dc4e97a4d1a5567e59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/467c86f4cbdd610f5f67a6dc4e97a4d1a5567e59/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74d9c4b312ee1a3149df2cf0bb8662ddcd5752ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/74d9c4b312ee1a3149df2cf0bb8662ddcd5752ba", "html_url": "https://github.com/rust-lang/rust/commit/74d9c4b312ee1a3149df2cf0bb8662ddcd5752ba"}], "stats": {"total": 108, "additions": 54, "deletions": 54}, "files": [{"sha": "a51d663b1a7b1e823906cff07c9d126e158f898a", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/467c86f4cbdd610f5f67a6dc4e97a4d1a5567e59/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467c86f4cbdd610f5f67a6dc4e97a4d1a5567e59/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=467c86f4cbdd610f5f67a6dc4e97a4d1a5567e59", "patch": "@@ -39,20 +39,21 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n \n-        Ok(Some(if self.eat_keyword(kw::Let) {\n+        if self.eat_keyword(kw::Let) {\n             let local = self.parse_local(attrs.into())?;\n-            self.mk_stmt(lo.to(self.prev_span), StmtKind::Local(local))\n-        } else if let Some(macro_def) = self.eat_macro_def(\n-            &attrs,\n-            &respan(lo, VisibilityKind::Inherited),\n-            lo,\n-        )? {\n-            self.mk_stmt(lo.to(self.prev_span), StmtKind::Item(macro_def))\n+            return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Local(local))));\n+        }\n+\n+        let mac_vis = respan(lo, VisibilityKind::Inherited);\n+        if let Some(macro_def) = self.eat_macro_def(&attrs, &mac_vis, lo)? {\n+            return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Item(macro_def))));\n+        }\n+\n         // Starts like a simple path, being careful to avoid contextual keywords\n         // such as a union items, item with `crate` visibility or auto trait items.\n         // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n         // like a path (1 token), but it fact not a path.\n-        } else if self.token.is_path_start()\n+        if self.token.is_path_start()\n             && !self.token.is_qpath_start()\n             && !self.is_union_item() // `union::b::c` - path, `union U { ... }` - not a path.\n             && !self.is_crate_vis() // `crate::b::c` - path, `crate struct S;` - not a path.\n@@ -77,58 +78,57 @@ impl<'a> Parser<'a> {\n                 this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n             })?;\n             return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Expr(expr))));\n-        } else {\n-            // FIXME: Bad copy of attrs\n-            let old_directory_ownership =\n-                mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n-            let item = self.parse_item_(attrs.clone(), false, true)?;\n-            self.directory.ownership = old_directory_ownership;\n-\n-            if let Some(item) = item {\n-                return Ok(Some(self.mk_stmt(lo.to(item.span), StmtKind::Item(item))));\n-            }\n+        }\n \n-            let unused_attrs = |attrs: &[Attribute], s: &mut Self| {\n-                if !attrs.is_empty() {\n-                    if s.prev_token_kind == PrevTokenKind::DocComment {\n-                        s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n-                    } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                        s.span_err(\n-                            s.token.span, \"expected statement after outer attribute\"\n-                        );\n-                    }\n-                }\n-            };\n+        // FIXME: Bad copy of attrs\n+        let old_directory_ownership =\n+            mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n+        let item = self.parse_item_(attrs.clone(), false, true)?;\n+        self.directory.ownership = old_directory_ownership;\n \n-            // Do not attempt to parse an expression if we're done here.\n-            if self.token == token::Semi {\n-                unused_attrs(&attrs, self);\n-                self.bump();\n-                let mut last_semi = lo;\n-                while self.token == token::Semi {\n-                    last_semi = self.token.span;\n-                    self.bump();\n+        if let Some(item) = item {\n+            return Ok(Some(self.mk_stmt(lo.to(item.span), StmtKind::Item(item))));\n+        }\n+\n+        let unused_attrs = |attrs: &[Attribute], s: &mut Self| {\n+            if !attrs.is_empty() {\n+                if s.prev_token_kind == PrevTokenKind::DocComment {\n+                    s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n+                } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n+                    s.span_err(\n+                        s.token.span, \"expected statement after outer attribute\"\n+                    );\n                 }\n-                // We are encoding a string of semicolons as an\n-                // an empty tuple that spans the excess semicolons\n-                // to preserve this info until the lint stage\n-                let kind = StmtKind::Semi(self.mk_expr(\n-                    lo.to(last_semi),\n-                    ExprKind::Tup(Vec::new()),\n-                    ThinVec::new()\n-                ));\n-                return Ok(Some(self.mk_stmt(lo.to(last_semi), kind)));\n             }\n+        };\n \n-            if self.token == token::CloseDelim(token::Brace) {\n-                unused_attrs(&attrs, self);\n-                return Ok(None);\n+        // Do not attempt to parse an expression if we're done here.\n+        if self.token == token::Semi {\n+            unused_attrs(&attrs, self);\n+            self.bump();\n+            let mut last_semi = lo;\n+            while self.token == token::Semi {\n+                last_semi = self.token.span;\n+                self.bump();\n             }\n+            // We are encoding a string of semicolons as an an empty tuple that spans\n+            // the excess semicolons to preserve this info until the lint stage.\n+            let kind = StmtKind::Semi(self.mk_expr(\n+                lo.to(last_semi),\n+                ExprKind::Tup(Vec::new()),\n+                ThinVec::new()\n+            ));\n+            return Ok(Some(self.mk_stmt(lo.to(last_semi), kind)));\n+        }\n \n-            // Remainder are line-expr stmts.\n-            let e = self.parse_expr_res( Restrictions::STMT_EXPR, Some(attrs.into()))?;\n-            self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n-        }))\n+        if self.token == token::CloseDelim(token::Brace) {\n+            unused_attrs(&attrs, self);\n+            return Ok(None);\n+        }\n+\n+        // Remainder are line-expr stmts.\n+        let e = self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs.into()))?;\n+        Ok(Some(self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))))\n     }\n \n     /// Parses a statement macro `mac!(args)` provided a `path` representing `mac`."}]}