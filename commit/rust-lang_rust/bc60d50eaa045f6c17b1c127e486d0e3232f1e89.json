{"sha": "bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "node_id": "C_kwDOAAsO6NoAKGJjNjBkNTBlYWEwNDVmNmMxN2IxYzEyN2U0ODZkMGUzMjMyZjFlODk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-06T17:34:24Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-11T17:46:01Z"}, "message": "Provide associated type information in method chains\n\nWhen encountering an unmet obligation that affects a method chain, like\nin iterator chains where one of the links has the wrong associated\ntype, we point at every method call and mention their evaluated\nassociated type at that point to give context to the user of where\nexpectations diverged from the code as written.\n\n```\nnote: the expression is of type `Map<std::slice::Iter<'_, {integer}>, [closure@$DIR/invalid-iterator-chain.rs:12:18: 12:21]>`\n  --> $DIR/invalid-iterator-chain.rs:12:14\n   |\nLL |         vec![0, 1]\n   |         ---------- this expression has type `Vec<{integer}>`\nLL |             .iter()\n   |              ------ associated type `std::iter::Iterator::Item` is `&{integer}` here\nLL |             .map(|x| { x; })\n   |              ^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `()` here\n```", "tree": {"sha": "e209fac2a960cf6de182ad01803dd9640a53d623", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e209fac2a960cf6de182ad01803dd9640a53d623"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "html_url": "https://github.com/rust-lang/rust/commit/bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d137783642b0b98eda2796dc66bffc2b089a8327", "url": "https://api.github.com/repos/rust-lang/rust/commits/d137783642b0b98eda2796dc66bffc2b089a8327", "html_url": "https://github.com/rust-lang/rust/commit/d137783642b0b98eda2796dc66bffc2b089a8327"}], "stats": {"total": 447, "additions": 413, "deletions": 34}, "files": [{"sha": "78364253adbca3788d8145abcbcf9edc56a48020", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "patch": "@@ -536,7 +536,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             |err| {\n                 self.note_obligation_cause_code(\n                     err,\n-                    &predicate,\n+                    predicate,\n                     obligation.param_env,\n                     obligation.cause.code(),\n                     &mut vec![],\n@@ -1586,7 +1586,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 {\n                     self.note_obligation_cause_code(\n                         &mut diag,\n-                        &error.obligation.predicate,\n+                        error.obligation.predicate,\n                         error.obligation.param_env,\n                         code,\n                         &mut vec![],\n@@ -2601,7 +2601,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n             self.note_obligation_cause_code(\n                 err,\n-                &obligation.predicate,\n+                obligation.predicate,\n                 obligation.param_env,\n                 obligation.cause.code(),\n                 &mut vec![],"}, {"sha": "8bfa405cbeae184d81dc8eb6f851bd4fb062cc61", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 260, "deletions": 31, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "patch": "@@ -1,8 +1,9 @@\n+// ignore-tidy-filelength\n use super::{DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation};\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n-use crate::traits::NormalizeExt;\n+use crate::traits::{NormalizeExt, ObligationCtxt};\n \n use hir::def::CtorOf;\n use hir::HirId;\n@@ -22,16 +23,18 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{InferOk, LateBoundRegionConversionTime};\n use rustc_middle::hir::map;\n+use rustc_middle::ty::error::TypeError::{self, Sorts};\n+use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n-    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n-    ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, InternalSubsts,\n+    IsSuggestable, ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder,\n+    TypeSuperFoldable, TypeVisitable, TypeckResults,\n };\n-use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n-use std::fmt;\n+use std::ops::Deref;\n \n use super::InferCtxtPrivExt;\n use crate::infer::InferCtxtExt as _;\n@@ -292,13 +295,13 @@ pub trait TypeErrCtxtExt<'tcx> {\n     fn note_obligation_cause_code<T>(\n         &self,\n         err: &mut Diagnostic,\n-        predicate: &T,\n+        predicate: T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display + ToPredicate<'tcx>;\n+        T: ToPredicate<'tcx>;\n \n     /// Suggest to await before try: future? => future.await?\n     fn suggest_await_before_try(\n@@ -2336,7 +2339,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         debug!(?next_code);\n         self.note_obligation_cause_code(\n             err,\n-            &obligation.predicate,\n+            obligation.predicate,\n             obligation.param_env,\n             next_code.unwrap(),\n             &mut Vec::new(),\n@@ -2347,15 +2350,16 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn note_obligation_cause_code<T>(\n         &self,\n         err: &mut Diagnostic,\n-        predicate: &T,\n+        predicate: T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display + ToPredicate<'tcx>,\n+        T: ToPredicate<'tcx>,\n     {\n         let tcx = self.tcx;\n+        let predicate = predicate.to_predicate(tcx);\n         match *cause_code {\n             ObligationCauseCode::ExprAssignable\n             | ObligationCauseCode::MatchExpressionArm { .. }\n@@ -2689,7 +2693,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n                             err,\n-                            &parent_predicate,\n+                            parent_predicate,\n                             param_env,\n                             &data.parent_code,\n                             obligated_types,\n@@ -2700,7 +2704,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n                             err,\n-                            &parent_predicate,\n+                            parent_predicate,\n                             param_env,\n                             cause_code.peel_derives(),\n                             obligated_types,\n@@ -2809,7 +2813,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n-                        &parent_predicate,\n+                        parent_predicate,\n                         param_env,\n                         &data.parent_code,\n                         obligated_types,\n@@ -2824,7 +2828,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n-                        &parent_predicate,\n+                        parent_predicate,\n                         param_env,\n                         &data.parent_code,\n                         obligated_types,\n@@ -2838,26 +2842,183 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ref parent_code,\n             } => {\n                 let hir = self.tcx.hir();\n-                if let Some(Node::Expr(expr @ hir::Expr { kind: hir::ExprKind::Block(..), .. })) =\n-                    hir.find(arg_hir_id)\n-                {\n+                if let Some(Node::Expr(expr)) = hir.find(arg_hir_id) {\n                     let parent_id = hir.get_parent_item(arg_hir_id);\n                     let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n                         Some(t) if t.hir_owner == parent_id => t,\n                         _ => self.tcx.typeck(parent_id.def_id),\n                     };\n-                    let expr = expr.peel_blocks();\n-                    let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n+                    if let hir::Expr { kind: hir::ExprKind::Block(..), .. } = expr {\n+                        let expr = expr.peel_blocks();\n+                        let ty =\n+                            typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n+                        let span = expr.span;\n+                        if Some(span) != err.span.primary_span() {\n+                            err.span_label(\n+                                span,\n+                                if ty.references_error() {\n+                                    String::new()\n+                                } else {\n+                                    format!(\"this tail expression is of type `{:?}`\", ty)\n+                                },\n+                            );\n+                        }\n+                    }\n+\n                     let span = expr.span;\n-                    if Some(span) != err.span.primary_span() {\n-                        err.span_label(\n-                            span,\n-                            if ty.references_error() {\n-                                String::new()\n-                            } else {\n-                                format!(\"this tail expression is of type `{:?}`\", ty)\n-                            },\n+                    let mut multi_span: MultiSpan = match expr.kind {\n+                        hir::ExprKind::MethodCall(_, _, _, span) => span.into(),\n+                        _ => span.into(),\n+                    };\n+\n+                    // FIXME: visit the ty to see if there's any closure involved, and if there is,\n+                    // check whether its evaluated return type is the same as the one corresponding\n+                    // to an associated type (as seen from `trait_pred`) in the predicate. Like in\n+                    // trait_pred `S: Sum<<Self as Iterator>::Item>` and predicate `i32: Sum<&()>`\n+                    let mut type_diffs = vec![];\n+\n+                    if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n+                        && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n+                        && let Some(pred) = predicates.predicates.get(*idx)\n+                        && let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder()\n+                    {\n+                        let mut c = CollectAllMismatches {\n+                            infcx: self.infcx,\n+                            param_env: param_env,\n+                            errors: vec![],\n+                        };\n+                        if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                                predicate\n+                            )) = predicate.kind().skip_binder()\n+                        {\n+                            if let Ok(_) = c.relate(trait_pred, predicate) {\n+                                type_diffs = c.errors;\n+                            }\n+                        }\n+                    }\n+                    let point_at_chain = |expr: &hir::Expr<'_>| {\n+                        let mut expr = expr;\n+                        let mut prev_ty = self.resolve_vars_if_possible(\n+                            typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n                         );\n+                        let outer_ty = prev_ty;\n+                        let mut assoc_seen = 0;\n+                        while let hir::ExprKind::MethodCall(_path_segment, rcvr_expr, _args, span) =\n+                            expr.kind\n+                        {\n+                            // Point at every method call in the chain with the resulting type.\n+                            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n+                            //               ^^^^^^ ^^^^^^^^^^^\n+                            expr = rcvr_expr;\n+\n+                            let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n+                            for diff in &type_diffs {\n+                                let Sorts(expected_found) = diff else { continue; };\n+                                let ty::Projection(proj) = expected_found.expected.kind() else { continue; };\n+                                assoc_seen += 1;\n+\n+                                let origin = TypeVariableOrigin {\n+                                    kind: TypeVariableOriginKind::TypeInference,\n+                                    span,\n+                                };\n+                                let trait_def_id = proj.trait_def_id(self.tcx);\n+                                // Make `Self` be equivalent to the type of the call chain\n+                                // expression we're looking at now, so that we can tell what\n+                                // for example `Iterator::Item` is at this point in the chain.\n+                                let substs =\n+                                    InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n+                                        match param.kind {\n+                                            ty::GenericParamDefKind::Type { .. } => {\n+                                                if param.index == 0 {\n+                                                    return prev_ty.into();\n+                                                }\n+                                            }\n+                                            ty::GenericParamDefKind::Lifetime\n+                                            | ty::GenericParamDefKind::Const { .. } => {}\n+                                        }\n+                                        self.var_for_def(span, param)\n+                                    });\n+                                // This will hold the resolved type of the associated type, if the\n+                                // current expression implements the trait that associated type is\n+                                // in. For example, this would be what `Iterator::Item` is here.\n+                                let ty_var = self.infcx.next_ty_var(origin);\n+                                // This corresponds to `<ExprTy as Iterator>::Item = _`.\n+                                let trait_ref = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                                    ty::Clause::Projection(ty::ProjectionPredicate {\n+                                        projection_ty: ty::ProjectionTy {\n+                                            substs,\n+                                            item_def_id: proj.item_def_id,\n+                                        },\n+                                        term: ty_var.into(),\n+                                    }),\n+                                ));\n+                                // Add `<ExprTy as Iterator>::Item = _` obligation.\n+                                ocx.register_obligation(Obligation::misc(\n+                                    self.tcx,\n+                                    span,\n+                                    expr.hir_id,\n+                                    param_env,\n+                                    trait_ref,\n+                                ));\n+                                if ocx.select_where_possible().is_empty() {\n+                                    // `ty_var` now holds the type that `Item` is for `ExprTy`.\n+                                    let assoc = self.tcx.def_path_str(proj.item_def_id);\n+                                    multi_span.push_span_label(\n+                                        span,\n+                                        &format!(\n+                                            \"associated type `{assoc}` is `{}` here\",\n+                                            self.resolve_vars_if_possible(ty_var),\n+                                        ),\n+                                    );\n+                                } else {\n+                                    // `<ExprTy as Iterator>` didn't select, so likely we've\n+                                    // reached the end of the iterator chain, like the originating\n+                                    // `Vec<_>`.\n+                                    multi_span.push_span_label(\n+                                        span,\n+                                        format!(\"this call has type `{prev_ty}`\"),\n+                                    );\n+                                }\n+                            }\n+                            prev_ty = self.resolve_vars_if_possible(\n+                                typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n+                            );\n+                        }\n+\n+                        // We want the type before deref coercions, otherwise we talk about `&[_]`\n+                        // instead of `Vec<_>`.\n+                        if let Some(ty) = typeck_results.expr_ty_opt(expr) {\n+                            let ty = self.resolve_vars_if_possible(ty);\n+                            // Point at the root expression\n+                            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n+                            // ^^^^^^^^^^^^^\n+                            multi_span.push_span_label(\n+                                expr.span,\n+                                format!(\"this expression has type `{ty}`\"),\n+                            );\n+                        };\n+                        if assoc_seen > 0 {\n+                            // Only show this if it is not a \"trivial\" expression (not a method\n+                            // chain) and there are associated types to talk about.\n+                            err.span_note(\n+                                multi_span,\n+                                format!(\"the expression is of type `{outer_ty}`\"),\n+                            );\n+                        }\n+                    };\n+                    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n+                        && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n+                        && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n+                        && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n+                        && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n+                        && let Some(binding_expr) = local.init\n+                    {\n+                        // If the expression we're calling on is a binding, we want to point at the\n+                        // `let` when talking about the type. Otherwise we'll point at every part\n+                        // of the method chain with the type.\n+                        point_at_chain(binding_expr);\n+                    } else {\n+                        point_at_chain(expr);\n                     }\n                 }\n                 if let Some(Node::Expr(hir::Expr {\n@@ -2888,9 +3049,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ObligationCauseCode::CompareImplItemObligation { trait_item_def_id, kind, .. } => {\n                 let item_name = self.tcx.item_name(trait_item_def_id);\n                 let msg = format!(\n-                    \"the requirement `{}` appears on the `impl`'s {kind} `{}` but not on the \\\n-                     corresponding trait's {kind}\",\n-                    predicate, item_name,\n+                    \"the requirement `{predicate}` appears on the `impl`'s {kind} \\\n+                     `{item_name}` but not on the corresponding trait's {kind}\",\n                 );\n                 let sp = self\n                     .tcx\n@@ -2900,7 +3060,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 let mut assoc_span: MultiSpan = sp.into();\n                 assoc_span.push_span_label(\n                     sp,\n-                    format!(\"this trait's {kind} doesn't have the requirement `{}`\", predicate),\n+                    format!(\"this trait's {kind} doesn't have the requirement `{predicate}`\"),\n                 );\n                 if let Some(ident) = self\n                     .tcx\n@@ -3286,3 +3446,72 @@ impl<'tcx> TypeFolder<'tcx> for ReplaceImplTraitFolder<'tcx> {\n         self.tcx\n     }\n }\n+\n+pub struct CollectAllMismatches<'a, 'tcx> {\n+    pub infcx: &'a InferCtxt<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub errors: Vec<TypeError<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n+    fn tag(&self) -> &'static str {\n+        \"CollectAllMismatches\"\n+    }\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    } // irrelevant\n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _: ty::Variance,\n+        _: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> RelateResult<'tcx, T> {\n+        self.relate(a, b)\n+    }\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        _b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        Ok(a)\n+    }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        if a == b || matches!(a.kind(), ty::Infer(_)) || matches!(b.kind(), ty::Infer(_)) {\n+            return Ok(a);\n+        }\n+        relate::super_relate_tys(self, a, b).or_else(|e| {\n+            self.errors.push(e);\n+            Ok(a)\n+        })\n+    }\n+    fn consts(\n+        &mut self,\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n+        if a == b {\n+            return Ok(a);\n+        }\n+        relate::super_relate_consts(self, a, b) // could do something similar here for constants!\n+    }\n+    fn binders<T: Relate<'tcx>>(\n+        &mut self,\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>> {\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n+    }\n+}"}, {"sha": "5e84dcdef305981dead16cab9ffca2b6b72e7d32", "filename": "src/test/ui/issues/issue-34334.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr?ref=bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "patch": "@@ -22,6 +22,14 @@ LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_rece\n    |\n    = help: the trait `FromIterator<()>` is not implemented for `Vec<(u32, _, _)>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the expression is of type `Map<std::slice::Iter<'_, (_, _, _)>, [closure@$DIR/issue-34334.rs:5:47: 5:82]>`\n+  --> $DIR/issue-34334.rs:5:43\n+   |\n+LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n+   |                                 -- ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `()` here\n+   |                                 |  |\n+   |                                 |  associated type `std::iter::Iterator::Item` is `&(_, _, _)` here\n+   |                                 this expression has type `Vec<(_, _, _)>`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "5ee287b1b15a41b1c6c43fd929576d8f46a8bd17", "filename": "src/test/ui/issues/issue-66923-show-error-for-correct-call.stderr", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr?ref=bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "patch": "@@ -8,6 +8,13 @@ LL |     let x2: Vec<f64> = x1.into_iter().collect();\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the expression is of type `std::slice::Iter<'_, f64>`\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:8:27\n+   |\n+LL |     let x2: Vec<f64> = x1.into_iter().collect();\n+   |                        -- ^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `&f64` here\n+   |                        |\n+   |                        this expression has type `&[f64]`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n@@ -24,6 +31,13 @@ LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the expression is of type `std::slice::Iter<'_, f64>`\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:12:17\n+   |\n+LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();\n+   |              -- ^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `&f64` here\n+   |              |\n+   |              this expression has type `&[f64]`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "de174807ab631d1134c03ecb997e82a48663d8fd", "filename": "src/test/ui/iterators/invalid-iterator-chain.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs?ref=bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "patch": "@@ -0,0 +1,17 @@\n+fn main() {\n+    let scores = vec![(0, 0)]\n+        .iter()\n+        .map(|(a, b)| {\n+            a + b;\n+        });\n+    println!(\"{}\", scores.sum::<i32>()); //~ ERROR E0277\n+    println!(\n+        \"{}\",\n+        vec![0, 1] //~ ERROR E0277\n+            .iter()\n+            .map(|x| { x; })\n+            .sum::<i32>(),\n+    );\n+    println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>()); //~ ERROR E0277\n+    println!(\"{}\", vec![(), ()].iter().sum::<i32>()); //~ ERROR E0277\n+}"}, {"sha": "03298089d88bd226903bafd8ac8edc8a7aad6a42", "filename": "src/test/ui/iterators/invalid-iterator-chain.stderr", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc60d50eaa045f6c17b1c127e486d0e3232f1e89/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr?ref=bc60d50eaa045f6c17b1c127e486d0e3232f1e89", "patch": "@@ -0,0 +1,111 @@\n+error[E0277]: the trait bound `i32: Sum<()>` is not satisfied\n+  --> $DIR/invalid-iterator-chain.rs:7:20\n+   |\n+LL |     println!(\"{}\", scores.sum::<i32>());\n+   |                    ^^^^^^ --- required by a bound introduced by this call\n+   |                    |\n+   |                    the trait `Sum<()>` is not implemented for `i32`\n+   |\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the expression is of type `Map<std::slice::Iter<'_, ({integer}, {integer})>, [closure@$DIR/invalid-iterator-chain.rs:4:14: 4:22]>`\n+  --> $DIR/invalid-iterator-chain.rs:7:20\n+   |\n+LL |       let scores = vec![(0, 0)]\n+   |                    ------------ this expression has type `Vec<({integer}, {integer})>`\n+LL |           .iter()\n+   |            ------ associated type `std::iter::Iterator::Item` is `&({integer}, {integer})` here\n+LL |           .map(|(a, b)| {\n+   |  __________-\n+LL | |             a + b;\n+LL | |         });\n+   | |__________- associated type `std::iter::Iterator::Item` is `()` here\n+LL |       println!(\"{}\", scores.sum::<i32>());\n+   |                      ^^^^^^\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `std::iter::Iterator::sum`\n+\n+error[E0277]: the trait bound `i32: Sum<()>` is not satisfied\n+  --> $DIR/invalid-iterator-chain.rs:10:9\n+   |\n+LL | /         vec![0, 1]\n+LL | |             .iter()\n+LL | |             .map(|x| { x; })\n+   | |____________________________^ the trait `Sum<()>` is not implemented for `i32`\n+LL |               .sum::<i32>(),\n+   |                --- required by a bound introduced by this call\n+   |\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the expression is of type `Map<std::slice::Iter<'_, {integer}>, [closure@$DIR/invalid-iterator-chain.rs:12:18: 12:21]>`\n+  --> $DIR/invalid-iterator-chain.rs:12:14\n+   |\n+LL |         vec![0, 1]\n+   |         ---------- this expression has type `Vec<{integer}>`\n+LL |             .iter()\n+   |              ------ associated type `std::iter::Iterator::Item` is `&{integer}` here\n+LL |             .map(|x| { x; })\n+   |              ^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `()` here\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `std::iter::Iterator::sum`\n+\n+error[E0277]: the trait bound `i32: Sum<()>` is not satisfied\n+  --> $DIR/invalid-iterator-chain.rs:15:20\n+   |\n+LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ --- required by a bound introduced by this call\n+   |                    |\n+   |                    the trait `Sum<()>` is not implemented for `i32`\n+   |\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the expression is of type `Map<std::slice::Iter<'_, {integer}>, [closure@$DIR/invalid-iterator-chain.rs:15:42: 15:45]>`\n+  --> $DIR/invalid-iterator-chain.rs:15:38\n+   |\n+LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n+   |                    ---------- ------ ^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `()` here\n+   |                    |          |\n+   |                    |          associated type `std::iter::Iterator::Item` is `&{integer}` here\n+   |                    this expression has type `Vec<{integer}>`\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `std::iter::Iterator::sum`\n+\n+error[E0277]: the trait bound `i32: Sum<&()>` is not satisfied\n+  --> $DIR/invalid-iterator-chain.rs:16:20\n+   |\n+LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n+   |                    ^^^^^^^^^^^^^^^^^^^ --- required by a bound introduced by this call\n+   |                    |\n+   |                    the trait `Sum<&()>` is not implemented for `i32`\n+   |\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the expression is of type `std::slice::Iter<'_, ()>`\n+  --> $DIR/invalid-iterator-chain.rs:16:33\n+   |\n+LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n+   |                    ------------ ^^^^^^ associated type `std::iter::Iterator::Item` is `&()` here\n+   |                    |\n+   |                    this expression has type `Vec<()>`\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `std::iter::Iterator::sum`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}