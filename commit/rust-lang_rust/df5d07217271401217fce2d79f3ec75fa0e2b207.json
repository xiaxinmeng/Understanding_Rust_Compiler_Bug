{"sha": "df5d07217271401217fce2d79f3ec75fa0e2b207", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNWQwNzIxNzI3MTQwMTIxN2ZjZTJkNzlmM2VjNzVmYTBlMmIyMDc=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-04T07:40:07Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-21T19:38:17Z"}, "message": "Move conflict error reporting to its own module", "tree": {"sha": "fdbdbdb63b3e1712a2e68c8dd3b4369300357662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdbdbdb63b3e1712a2e68c8dd3b4369300357662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df5d07217271401217fce2d79f3ec75fa0e2b207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df5d07217271401217fce2d79f3ec75fa0e2b207", "html_url": "https://github.com/rust-lang/rust/commit/df5d07217271401217fce2d79f3ec75fa0e2b207", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df5d07217271401217fce2d79f3ec75fa0e2b207/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebd6c7164ee7d8f85a640858f1cad1f56cc11a35", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd6c7164ee7d8f85a640858f1cad1f56cc11a35", "html_url": "https://github.com/rust-lang/rust/commit/ebd6c7164ee7d8f85a640858f1cad1f56cc11a35"}], "stats": {"total": 3990, "additions": 2002, "deletions": 1988}, "files": [{"sha": "19f29f346f96f4b149b17d2543afdbe593b0f1a9", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "added", "additions": 1991, "deletions": 0, "changes": 1991, "blob_url": "https://github.com/rust-lang/rust/blob/df5d07217271401217fce2d79f3ec75fa0e2b207/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df5d07217271401217fce2d79f3ec75fa0e2b207/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=df5d07217271401217fce2d79f3ec75fa0e2b207", "patch": "@@ -0,0 +1,1991 @@\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::region::ScopeTree;\n+use rustc::mir::{\n+    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n+    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceProjection,\n+    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+};\n+use rustc::ty::{self, Ty};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use syntax_pos::Span;\n+use syntax::source_map::CompilerDesugaringKind;\n+\n+use super::nll::explain_borrow::BorrowExplanation;\n+use super::nll::region_infer::{RegionName, RegionNameSource};\n+use super::prefixes::IsPrefixOf;\n+use super::WriteKind;\n+use super::borrow_set::BorrowData;\n+use super::MirBorrowckCtxt;\n+use super::{InitializationRequiringAction, PrefixSet};\n+use super::error_reporting::{IncludingDowncast, UseSpans};\n+use crate::dataflow::drop_flag_effects;\n+use crate::dataflow::indexes::{MovePathIndex, MoveOutIndex};\n+use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n+\n+#[derive(Debug)]\n+struct MoveSite {\n+    /// Index of the \"move out\" that we found. The `MoveData` can\n+    /// then tell us where the move occurred.\n+    moi: MoveOutIndex,\n+\n+    /// `true` if we traversed a back edge while walking from the point\n+    /// of error to the move site.\n+    traversed_back_edge: bool\n+}\n+\n+/// Which case a StorageDeadOrDrop is for.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum StorageDeadOrDrop<'tcx> {\n+    LocalStorageDead,\n+    BoxedStorageDead,\n+    Destructor(Ty<'tcx>),\n+}\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    pub(super) fn report_use_of_moved_or_uninitialized(\n+        &mut self,\n+        location: Location,\n+        desired_action: InitializationRequiringAction,\n+        (moved_place, used_place, span): (&Place<'tcx>, &Place<'tcx>, Span),\n+        mpi: MovePathIndex,\n+    ) {\n+        debug!(\n+            \"report_use_of_moved_or_uninitialized: location={:?} desired_action={:?} \\\n+             moved_place={:?} used_place={:?} span={:?} mpi={:?}\",\n+            location, desired_action, moved_place, used_place, span, mpi\n+        );\n+\n+        let use_spans = self.move_spans(moved_place, location)\n+            .or_else(|| self.borrow_spans(span, location));\n+        let span = use_spans.args_or_use();\n+\n+        let move_site_vec = self.get_moved_indexes(location, mpi);\n+        debug!(\n+            \"report_use_of_moved_or_uninitialized: move_site_vec={:?}\",\n+            move_site_vec\n+        );\n+        let move_out_indices: Vec<_> = move_site_vec\n+            .iter()\n+            .map(|move_site| move_site.moi)\n+            .collect();\n+\n+        if move_out_indices.is_empty() {\n+            let root_place = self.prefixes(&used_place, PrefixSet::All).last().unwrap();\n+\n+            if self.uninitialized_error_reported.contains(root_place) {\n+                debug!(\n+                    \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n+                    root_place\n+                );\n+                return;\n+            }\n+\n+            self.uninitialized_error_reported.insert(root_place.clone());\n+\n+            let item_msg = match self.describe_place_with_options(used_place,\n+                                                                  IncludingDowncast(true)) {\n+                Some(name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned(),\n+            };\n+            let mut err = self.infcx.tcx.cannot_act_on_uninitialized_variable(\n+                span,\n+                desired_action.as_noun(),\n+                &self.describe_place_with_options(moved_place, IncludingDowncast(true))\n+                    .unwrap_or_else(|| \"_\".to_owned()),\n+                Origin::Mir,\n+            );\n+            err.span_label(span, format!(\"use of possibly uninitialized {}\", item_msg));\n+\n+            use_spans.var_span_label(\n+                &mut err,\n+                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n+            );\n+\n+            err.buffer(&mut self.errors_buffer);\n+        } else {\n+            if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {\n+                if self.prefixes(&reported_place, PrefixSet::All)\n+                    .any(|p| p == used_place)\n+                {\n+                    debug!(\n+                        \"report_use_of_moved_or_uninitialized place: error suppressed \\\n+                         mois={:?}\",\n+                        move_out_indices\n+                    );\n+                    return;\n+                }\n+            }\n+\n+            let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n+\n+            let mut err = self.infcx.tcx.cannot_act_on_moved_value(\n+                span,\n+                desired_action.as_noun(),\n+                msg,\n+                self.describe_place_with_options(&moved_place, IncludingDowncast(true)),\n+                Origin::Mir,\n+            );\n+\n+            self.add_moved_or_invoked_closure_note(\n+                location,\n+                used_place,\n+                &mut err,\n+            );\n+\n+            let mut is_loop_move = false;\n+            let is_partial_move = move_site_vec.iter().any(|move_site| {\n+                let move_out = self.move_data.moves[(*move_site).moi];\n+                let moved_place = &self.move_data.move_paths[move_out.path].place;\n+                used_place != moved_place && used_place.is_prefix_of(moved_place)\n+            });\n+            for move_site in &move_site_vec {\n+                let move_out = self.move_data.moves[(*move_site).moi];\n+                let moved_place = &self.move_data.move_paths[move_out.path].place;\n+\n+                let move_spans = self.move_spans(moved_place, move_out.source);\n+                let move_span = move_spans.args_or_use();\n+\n+                let move_msg = if move_spans.for_closure() {\n+                    \" into closure\"\n+                } else {\n+                    \"\"\n+                };\n+\n+                if span == move_span {\n+                    err.span_label(\n+                        span,\n+                        format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n+                    );\n+                    if Some(CompilerDesugaringKind::ForLoop) == span.compiler_desugaring_kind() {\n+                        if let Ok(snippet) = self.infcx.tcx.sess.source_map()\n+                            .span_to_snippet(span)\n+                        {\n+                            err.span_suggestion(\n+                                move_span,\n+                                \"consider borrowing this to avoid moving it into the for loop\",\n+                                format!(\"&{}\", snippet),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                    is_loop_move = true;\n+                } else if move_site.traversed_back_edge {\n+                    err.span_label(\n+                        move_span,\n+                        format!(\n+                            \"value moved{} here, in previous iteration of loop\",\n+                            move_msg\n+                        ),\n+                    );\n+                } else {\n+                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                    move_spans.var_span_label(\n+                        &mut err,\n+                        format!(\"variable moved due to use{}\", move_spans.describe()),\n+                    );\n+                };\n+            }\n+\n+            use_spans.var_span_label(\n+                &mut err,\n+                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n+            );\n+\n+            if !is_loop_move {\n+                err.span_label(\n+                    span,\n+                    format!(\n+                        \"value {} here {}\",\n+                        desired_action.as_verb_in_past_tense(),\n+                        if is_partial_move { \"after partial move\" } else { \"after move\" },\n+                    ),\n+                );\n+            }\n+\n+            let ty = used_place.ty(self.mir, self.infcx.tcx).ty;\n+            let needs_note = match ty.sty {\n+                ty::Closure(id, _) => {\n+                    let tables = self.infcx.tcx.typeck_tables_of(id);\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id).unwrap();\n+\n+                    tables.closure_kind_origins().get(hir_id).is_none()\n+                }\n+                _ => true,\n+            };\n+\n+            if needs_note {\n+                let mpi = self.move_data.moves[move_out_indices[0]].path;\n+                let place = &self.move_data.move_paths[mpi].place;\n+\n+                let ty = place.ty(self.mir, self.infcx.tcx).ty;\n+                let opt_name = self.describe_place_with_options(place, IncludingDowncast(true));\n+                let note_msg = match opt_name {\n+                    Some(ref name) => format!(\"`{}`\", name),\n+                    None => \"value\".to_owned(),\n+                };\n+                if let ty::Param(param_ty) = ty.sty {\n+                    let tcx = self.infcx.tcx;\n+                    let generics = tcx.generics_of(self.mir_def_id);\n+                    let def_id = generics.type_param(&param_ty, tcx).def_id;\n+                    if let Some(sp) = tcx.hir().span_if_local(def_id) {\n+                        err.span_label(\n+                            sp,\n+                            \"consider adding a `Copy` constraint to this type argument\",\n+                        );\n+                    }\n+                }\n+                if let Place::Base(PlaceBase::Local(local)) = place {\n+                    let decl = &self.mir.local_decls[*local];\n+                    err.span_label(\n+                        decl.source_info.span,\n+                        format!(\n+                            \"move occurs because {} has type `{}`, \\\n+                                which does not implement the `Copy` trait\",\n+                            note_msg, ty,\n+                    ));\n+                } else {\n+                    err.note(&format!(\n+                        \"move occurs because {} has type `{}`, \\\n+                         which does not implement the `Copy` trait\",\n+                        note_msg, ty\n+                    ));\n+                }\n+            }\n+\n+            if let Some((_, mut old_err)) = self.move_error_reported\n+                .insert(move_out_indices, (used_place.clone(), err))\n+            {\n+                // Cancel the old error so it doesn't ICE.\n+                old_err.cancel();\n+            }\n+        }\n+    }\n+\n+    pub(super) fn report_move_out_while_borrowed(\n+        &mut self,\n+        location: Location,\n+        (place, span): (&Place<'tcx>, Span),\n+        borrow: &BorrowData<'tcx>,\n+    ) {\n+        debug!(\n+            \"report_move_out_while_borrowed: location={:?} place={:?} span={:?} borrow={:?}\",\n+            location, place, span, borrow\n+        );\n+        let tcx = self.infcx.tcx;\n+        let value_msg = match self.describe_place(place) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned(),\n+        };\n+        let borrow_msg = match self.describe_place(&borrow.borrowed_place) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned(),\n+        };\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.args_or_use();\n+\n+        let move_spans = self.move_spans(place, location);\n+        let span = move_spans.args_or_use();\n+\n+        let mut err = tcx.cannot_move_when_borrowed(\n+            span,\n+            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n+        err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n+\n+        borrow_spans.var_span_label(\n+            &mut err,\n+            format!(\"borrow occurs due to use{}\", borrow_spans.describe())\n+        );\n+\n+        move_spans.var_span_label(\n+            &mut err,\n+            format!(\"move occurs due to use{}\", move_spans.describe())\n+        );\n+\n+        self.explain_why_borrow_contains_point(\n+            location,\n+            borrow,\n+            None,\n+        ).add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", Some(borrow_span));\n+        err.buffer(&mut self.errors_buffer);\n+    }\n+\n+    pub(super) fn report_use_while_mutably_borrowed(\n+        &mut self,\n+        location: Location,\n+        (place, _span): (&Place<'tcx>, Span),\n+        borrow: &BorrowData<'tcx>,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let tcx = self.infcx.tcx;\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.args_or_use();\n+\n+        // Conflicting borrows are reported separately, so only check for move\n+        // captures.\n+        let use_spans = self.move_spans(place, location);\n+        let span = use_spans.var_or_use();\n+\n+        let mut err = tcx.cannot_use_when_mutably_borrowed(\n+            span,\n+            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n+            borrow_span,\n+            &self.describe_place(&borrow.borrowed_place)\n+                .unwrap_or_else(|| \"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+\n+        borrow_spans.var_span_label(&mut err, {\n+            let place = &borrow.borrowed_place;\n+            let desc_place = self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n+\n+            format!(\"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe())\n+        });\n+\n+        self.explain_why_borrow_contains_point(location, borrow, None)\n+            .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+        err\n+    }\n+\n+    pub(super) fn report_conflicting_borrow(\n+        &mut self,\n+        location: Location,\n+        (place, span): (&Place<'tcx>, Span),\n+        gen_borrow_kind: BorrowKind,\n+        issued_borrow: &BorrowData<'tcx>,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let issued_spans = self.retrieve_borrow_spans(issued_borrow);\n+        let issued_span = issued_spans.args_or_use();\n+\n+        let borrow_spans = self.borrow_spans(span, location);\n+        let span = borrow_spans.args_or_use();\n+\n+        let container_name = if issued_spans.for_generator() || borrow_spans.for_generator() {\n+            \"generator\"\n+        } else {\n+            \"closure\"\n+        };\n+\n+        let (desc_place, msg_place, msg_borrow, union_type_name) =\n+            self.describe_place_for_conflicting_borrow(place, &issued_borrow.borrowed_place);\n+\n+        let explanation = self.explain_why_borrow_contains_point(location, issued_borrow, None);\n+        let second_borrow_desc = if explanation.is_explained() {\n+            \"second \"\n+        } else {\n+            \"\"\n+        };\n+\n+        // FIXME: supply non-\"\" `opt_via` when appropriate\n+        let tcx = self.infcx.tcx;\n+        let first_borrow_desc;\n+        let mut err = match (\n+            gen_borrow_kind,\n+            \"immutable\",\n+            \"mutable\",\n+            issued_borrow.kind,\n+            \"immutable\",\n+            \"mutable\",\n+        ) {\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt) => {\n+                first_borrow_desc = \"mutable \";\n+                tcx.cannot_reborrow_already_borrowed(\n+                    span,\n+                    &desc_place,\n+                    &msg_place,\n+                    lft,\n+                    issued_span,\n+                    \"it\",\n+                    rgt,\n+                    &msg_borrow,\n+                    None,\n+                    Origin::Mir,\n+                )\n+            }\n+            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n+                first_borrow_desc = \"immutable \";\n+                tcx.cannot_reborrow_already_borrowed(\n+                    span,\n+                    &desc_place,\n+                    &msg_place,\n+                    lft,\n+                    issued_span,\n+                    \"it\",\n+                    rgt,\n+                    &msg_borrow,\n+                    None,\n+                    Origin::Mir,\n+                )\n+            }\n+\n+            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n+                first_borrow_desc = \"first \";\n+                tcx.cannot_mutably_borrow_multiply(\n+                    span,\n+                    &desc_place,\n+                    &msg_place,\n+                    issued_span,\n+                    &msg_borrow,\n+                    None,\n+                    Origin::Mir,\n+                )\n+            }\n+\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n+                first_borrow_desc = \"first \";\n+                tcx.cannot_uniquely_borrow_by_two_closures(\n+                    span,\n+                    &desc_place,\n+                    issued_span,\n+                    None,\n+                    Origin::Mir,\n+                )\n+            }\n+\n+            (BorrowKind::Mut { .. }, _, _, BorrowKind::Shallow, _, _)\n+            | (BorrowKind::Unique, _, _, BorrowKind::Shallow, _, _) => {\n+                let mut err = tcx.cannot_mutate_in_match_guard(\n+                    span,\n+                    issued_span,\n+                    &desc_place,\n+                    \"mutably borrow\",\n+                    Origin::Mir,\n+                );\n+                borrow_spans.var_span_label(\n+                    &mut err,\n+                    format!(\n+                        \"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe()\n+                    ),\n+                );\n+\n+                return err;\n+            }\n+\n+            (BorrowKind::Unique, _, _, _, _, _) => {\n+                first_borrow_desc = \"first \";\n+                tcx.cannot_uniquely_borrow_by_one_closure(\n+                    span,\n+                    container_name,\n+                    &desc_place,\n+                    \"\",\n+                    issued_span,\n+                    \"it\",\n+                    \"\",\n+                    None,\n+                    Origin::Mir,\n+                )\n+            },\n+\n+            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n+                first_borrow_desc = \"first \";\n+                tcx.cannot_reborrow_already_uniquely_borrowed(\n+                    span,\n+                    container_name,\n+                    &desc_place,\n+                    \"\",\n+                    lft,\n+                    issued_span,\n+                    \"\",\n+                    None,\n+                    second_borrow_desc,\n+                    Origin::Mir,\n+                )\n+            }\n+\n+            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n+                first_borrow_desc = \"first \";\n+                tcx.cannot_reborrow_already_uniquely_borrowed(\n+                    span,\n+                    container_name,\n+                    &desc_place,\n+                    \"\",\n+                    lft,\n+                    issued_span,\n+                    \"\",\n+                    None,\n+                    second_borrow_desc,\n+                    Origin::Mir,\n+                )\n+            }\n+\n+            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _)\n+            | (BorrowKind::Shared, _, _, BorrowKind::Shallow, _, _)\n+            | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _)\n+            | (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n+            | (BorrowKind::Shallow, _, _, BorrowKind::Shared, _, _)\n+            | (BorrowKind::Shallow, _, _, BorrowKind::Shallow, _, _) => unreachable!(),\n+        };\n+\n+        if issued_spans == borrow_spans {\n+            borrow_spans.var_span_label(\n+                &mut err,\n+                format!(\"borrows occur due to use of `{}`{}\", desc_place, borrow_spans.describe()),\n+            );\n+        } else {\n+            let borrow_place = &issued_borrow.borrowed_place;\n+            let borrow_place_desc = self.describe_place(borrow_place)\n+                                        .unwrap_or_else(|| \"_\".to_owned());\n+            issued_spans.var_span_label(\n+                &mut err,\n+                format!(\n+                    \"first borrow occurs due to use of `{}`{}\",\n+                    borrow_place_desc,\n+                    issued_spans.describe(),\n+                ),\n+            );\n+\n+            borrow_spans.var_span_label(\n+                &mut err,\n+                format!(\n+                    \"second borrow occurs due to use of `{}`{}\",\n+                    desc_place,\n+                    borrow_spans.describe(),\n+                ),\n+            );\n+        }\n+\n+        if union_type_name != \"\" {\n+            err.note(&format!(\n+                \"`{}` is a field of the union `{}`, so it overlaps the field `{}`\",\n+                msg_place, union_type_name, msg_borrow,\n+            ));\n+        }\n+\n+        explanation.add_explanation_to_diagnostic(\n+            self.infcx.tcx,\n+            self.mir,\n+            &mut err,\n+            first_borrow_desc,\n+            None,\n+        );\n+\n+        err\n+    }\n+\n+    /// Returns the description of the root place for a conflicting borrow and the full\n+    /// descriptions of the places that caused the conflict.\n+    ///\n+    /// In the simplest case, where there are no unions involved, if a mutable borrow of `x` is\n+    /// attempted while a shared borrow is live, then this function will return:\n+    ///\n+    ///     (\"x\", \"\", \"\")\n+    ///\n+    /// In the simple union case, if a mutable borrow of a union field `x.z` is attempted while\n+    /// a shared borrow of another field `x.y`, then this function will return:\n+    ///\n+    ///     (\"x\", \"x.z\", \"x.y\")\n+    ///\n+    /// In the more complex union case, where the union is a field of a struct, then if a mutable\n+    /// borrow of a union field in a struct `x.u.z` is attempted while a shared borrow of\n+    /// another field `x.u.y`, then this function will return:\n+    ///\n+    ///     (\"x.u\", \"x.u.z\", \"x.u.y\")\n+    ///\n+    /// This is used when creating error messages like below:\n+    ///\n+    /// >  cannot borrow `a.u` (via `a.u.z.c`) as immutable because it is also borrowed as\n+    /// >  mutable (via `a.u.s.b`) [E0502]\n+    pub(super) fn describe_place_for_conflicting_borrow(\n+        &self,\n+        first_borrowed_place: &Place<'tcx>,\n+        second_borrowed_place: &Place<'tcx>,\n+    ) -> (String, String, String, String) {\n+        // Define a small closure that we can use to check if the type of a place\n+        // is a union.\n+        let is_union = |place: &Place<'tcx>| -> bool {\n+            place.ty(self.mir, self.infcx.tcx).ty\n+                .ty_adt_def()\n+                .map(|adt| adt.is_union())\n+                .unwrap_or(false)\n+        };\n+\n+        // Start with an empty tuple, so we can use the functions on `Option` to reduce some\n+        // code duplication (particularly around returning an empty description in the failure\n+        // case).\n+        Some(())\n+            .filter(|_| {\n+                // If we have a conflicting borrow of the same place, then we don't want to add\n+                // an extraneous \"via x.y\" to our diagnostics, so filter out this case.\n+                first_borrowed_place != second_borrowed_place\n+            })\n+            .and_then(|_| {\n+                // We're going to want to traverse the first borrowed place to see if we can find\n+                // field access to a union. If we find that, then we will keep the place of the\n+                // union being accessed and the field that was being accessed so we can check the\n+                // second borrowed place for the same union and a access to a different field.\n+                let mut current = first_borrowed_place;\n+                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n+                    match elem {\n+                        ProjectionElem::Field(field, _) if is_union(base) => {\n+                            return Some((base, field));\n+                        },\n+                        _ => current = base,\n+                    }\n+                }\n+                None\n+            })\n+            .and_then(|(target_base, target_field)| {\n+                // With the place of a union and a field access into it, we traverse the second\n+                // borrowed place and look for a access to a different field of the same union.\n+                let mut current = second_borrowed_place;\n+                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n+                    match elem {\n+                        ProjectionElem::Field(field, _) if {\n+                            is_union(base) && field != target_field && base == target_base\n+                        } => {\n+                            let desc_base = self.describe_place(base)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+                            let desc_first = self.describe_place(first_borrowed_place)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+                            let desc_second = self.describe_place(second_borrowed_place)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+\n+                            // Also compute the name of the union type, eg. `Foo` so we\n+                            // can add a helpful note with it.\n+                            let ty = base.ty(self.mir, self.infcx.tcx).ty;\n+\n+                            return Some((desc_base, desc_first, desc_second, ty.to_string()));\n+                        },\n+                        _ => current = base,\n+                    }\n+                }\n+                None\n+            })\n+            .unwrap_or_else(|| {\n+                // If we didn't find a field access into a union, or both places match, then\n+                // only return the description of the first place.\n+                let desc_place = self.describe_place(first_borrowed_place)\n+                    .unwrap_or_else(|| \"_\".to_owned());\n+                (desc_place, \"\".to_string(), \"\".to_string(), \"\".to_string())\n+            })\n+    }\n+\n+    /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n+    ///\n+    /// This means that some data referenced by `borrow` needs to live\n+    /// past the point where the StorageDeadOrDrop of `place` occurs.\n+    /// This is usually interpreted as meaning that `place` has too\n+    /// short a lifetime. (But sometimes it is more useful to report\n+    /// it as a more direct conflict between the execution of a\n+    /// `Drop::drop` with an aliasing borrow.)\n+    pub(super) fn report_borrowed_value_does_not_live_long_enough(\n+        &mut self,\n+        location: Location,\n+        borrow: &BorrowData<'tcx>,\n+        place_span: (&Place<'tcx>, Span),\n+        kind: Option<WriteKind>,\n+    ) {\n+        debug!(\n+            \"report_borrowed_value_does_not_live_long_enough(\\\n+             {:?}, {:?}, {:?}, {:?}\\\n+             )\",\n+            location, borrow, place_span, kind\n+        );\n+\n+        let drop_span = place_span.1;\n+        let scope_tree = self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n+            .last()\n+            .unwrap();\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.var_or_use();\n+\n+        let proper_span = match *root_place {\n+            Place::Base(PlaceBase::Local(local)) => self.mir.local_decls[local].source_info.span,\n+            _ => drop_span,\n+        };\n+\n+        if self.access_place_error_reported\n+            .contains(&(root_place.clone(), borrow_span))\n+        {\n+            debug!(\n+                \"suppressing access_place error when borrow doesn't live long enough for {:?}\",\n+                borrow_span\n+            );\n+            return;\n+        }\n+\n+        self.access_place_error_reported\n+            .insert((root_place.clone(), borrow_span));\n+\n+        if let StorageDeadOrDrop::Destructor(dropped_ty) =\n+            self.classify_drop_access_kind(&borrow.borrowed_place)\n+        {\n+            // If a borrow of path `B` conflicts with drop of `D` (and\n+            // we're not in the uninteresting case where `B` is a\n+            // prefix of `D`), then report this as a more interesting\n+            // destructor conflict.\n+            if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n+                self.report_borrow_conflicts_with_destructor(\n+                    location, borrow, place_span, kind, dropped_ty,\n+                );\n+                return;\n+            }\n+        }\n+\n+        let place_desc = self.describe_place(&borrow.borrowed_place);\n+\n+        let kind_place = kind.filter(|_| place_desc.is_some()).map(|k| (k, place_span.0));\n+        let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n+\n+        let err = match (place_desc, explanation) {\n+            (Some(_), _) if self.is_place_thread_local(root_place) => {\n+                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n+            }\n+            // If the outlives constraint comes from inside the closure,\n+            // for example:\n+            //\n+            // let x = 0;\n+            // let y = &x;\n+            // Box::new(|| y) as Box<Fn() -> &'static i32>\n+            //\n+            // then just use the normal error. The closure isn't escaping\n+            // and `move` will not help here.\n+            (\n+                Some(ref name),\n+                BorrowExplanation::MustBeValidFor {\n+                    category: category @ ConstraintCategory::Return,\n+                    from_closure: false,\n+                    ref region_name,\n+                    span,\n+                    ..\n+                },\n+            )\n+            | (\n+                Some(ref name),\n+                BorrowExplanation::MustBeValidFor {\n+                    category: category @ ConstraintCategory::CallArgument,\n+                    from_closure: false,\n+                    ref region_name,\n+                    span,\n+                    ..\n+                },\n+            ) if borrow_spans.for_closure() => self.report_escaping_closure_capture(\n+                borrow_spans.args_or_use(),\n+                borrow_span,\n+                region_name,\n+                category,\n+                span,\n+                &format!(\"`{}`\", name),\n+            ),\n+            (\n+                ref name,\n+                BorrowExplanation::MustBeValidFor {\n+                    category: ConstraintCategory::Assignment,\n+                    from_closure: false,\n+                    region_name: RegionName {\n+                        source: RegionNameSource::AnonRegionFromUpvar(upvar_span, ref upvar_name),\n+                        ..\n+                    },\n+                    span,\n+                    ..\n+                },\n+            ) => self.report_escaping_data(borrow_span, name, upvar_span, upvar_name, span),\n+            (Some(name), explanation) => self.report_local_value_does_not_live_long_enough(\n+                location,\n+                &name,\n+                &scope_tree,\n+                &borrow,\n+                drop_span,\n+                borrow_spans,\n+                explanation,\n+            ),\n+            (None, explanation) => self.report_temporary_value_does_not_live_long_enough(\n+                location,\n+                &scope_tree,\n+                &borrow,\n+                drop_span,\n+                borrow_spans,\n+                proper_span,\n+                explanation,\n+            ),\n+        };\n+\n+        err.buffer(&mut self.errors_buffer);\n+    }\n+\n+    fn report_local_value_does_not_live_long_enough(\n+        &mut self,\n+        location: Location,\n+        name: &str,\n+        scope_tree: &'tcx ScopeTree,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        borrow_spans: UseSpans,\n+        explanation: BorrowExplanation,\n+    ) -> DiagnosticBuilder<'cx> {\n+        debug!(\n+            \"report_local_value_does_not_live_long_enough(\\\n+             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             )\",\n+            location, name, scope_tree, borrow, drop_span, borrow_spans\n+        );\n+\n+        let borrow_span = borrow_spans.var_or_use();\n+        if let BorrowExplanation::MustBeValidFor {\n+            category,\n+            span,\n+            ref opt_place_desc,\n+            from_closure: false,\n+            ..\n+        } = explanation {\n+            if let Some(diag) = self.try_report_cannot_return_reference_to_local(\n+                borrow,\n+                borrow_span,\n+                span,\n+                category,\n+                opt_place_desc.as_ref(),\n+            ) {\n+                return diag;\n+            }\n+        }\n+\n+        let mut err = self.infcx.tcx.path_does_not_live_long_enough(\n+            borrow_span,\n+            &format!(\"`{}`\", name),\n+            Origin::Mir,\n+        );\n+\n+        if let Some(annotation) = self.annotate_argument_and_return_for_borrow(borrow) {\n+            let region_name = annotation.emit(self, &mut err);\n+\n+            err.span_label(\n+                borrow_span,\n+                format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n+            );\n+\n+            if let Some(fn_hir_id) = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id) {\n+                err.span_label(\n+                    drop_span,\n+                    format!(\n+                        \"...but `{}` will be dropped here, when the function `{}` returns\",\n+                        name,\n+                        self.infcx.tcx.hir().name_by_hir_id(fn_hir_id),\n+                    ),\n+                );\n+\n+                err.note(\n+                    \"functions cannot return a borrow to data owned within the function's scope, \\\n+                     functions can only return borrows to data passed as arguments\",\n+                );\n+                err.note(\n+                    \"to learn more, visit <https://doc.rust-lang.org/book/ch04-02-\\\n+                     references-and-borrowing.html#dangling-references>\",\n+                );\n+            } else {\n+                err.span_label(\n+                    drop_span,\n+                    format!(\"...but `{}` dropped here while still borrowed\", name),\n+                );\n+            }\n+\n+            if let BorrowExplanation::MustBeValidFor { .. } = explanation {\n+            } else {\n+                explanation.add_explanation_to_diagnostic(\n+                    self.infcx.tcx,\n+                    self.mir,\n+                    &mut err,\n+                    \"\",\n+                    None,\n+                );\n+            }\n+        } else {\n+            err.span_label(borrow_span, \"borrowed value does not live long enough\");\n+            err.span_label(\n+                drop_span,\n+                format!(\"`{}` dropped here while still borrowed\", name),\n+            );\n+\n+            let within = if borrow_spans.for_generator() {\n+                \" by generator\"\n+            } else {\n+                \"\"\n+            };\n+\n+            borrow_spans.args_span_label(\n+                &mut err,\n+                format!(\"value captured here{}\", within),\n+            );\n+\n+            explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+        }\n+\n+        err\n+    }\n+\n+    fn report_borrow_conflicts_with_destructor(\n+        &mut self,\n+        location: Location,\n+        borrow: &BorrowData<'tcx>,\n+        (place, drop_span): (&Place<'tcx>, Span),\n+        kind: Option<WriteKind>,\n+        dropped_ty: Ty<'tcx>,\n+    ) {\n+        debug!(\n+            \"report_borrow_conflicts_with_destructor(\\\n+             {:?}, {:?}, ({:?}, {:?}), {:?}\\\n+             )\",\n+            location, borrow, place, drop_span, kind,\n+        );\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.var_or_use();\n+\n+        let mut err = self.infcx\n+            .tcx\n+            .cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n+\n+        let what_was_dropped = match self.describe_place(place) {\n+            Some(name) => format!(\"`{}`\", name.as_str()),\n+            None => String::from(\"temporary value\"),\n+        };\n+\n+        let label = match self.describe_place(&borrow.borrowed_place) {\n+            Some(borrowed) => format!(\n+                \"here, drop of {D} needs exclusive access to `{B}`, \\\n+                 because the type `{T}` implements the `Drop` trait\",\n+                D = what_was_dropped,\n+                T = dropped_ty,\n+                B = borrowed\n+            ),\n+            None => format!(\n+                \"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n+                D = what_was_dropped,\n+                T = dropped_ty\n+            ),\n+        };\n+        err.span_label(drop_span, label);\n+\n+        // Only give this note and suggestion if they could be relevant.\n+        let explanation =\n+            self.explain_why_borrow_contains_point(location, borrow, kind.map(|k| (k, place)));\n+        match explanation {\n+            BorrowExplanation::UsedLater { .. }\n+            | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n+                err.note(\"consider using a `let` binding to create a longer lived value\");\n+            }\n+            _ => {}\n+        }\n+\n+        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+\n+        err.buffer(&mut self.errors_buffer);\n+    }\n+\n+    fn report_thread_local_value_does_not_live_long_enough(\n+        &mut self,\n+        drop_span: Span,\n+        borrow_span: Span,\n+    ) -> DiagnosticBuilder<'cx> {\n+        debug!(\n+            \"report_thread_local_value_does_not_live_long_enough(\\\n+             {:?}, {:?}\\\n+             )\",\n+            drop_span, borrow_span\n+        );\n+\n+        let mut err = self.infcx\n+            .tcx\n+            .thread_local_value_does_not_live_long_enough(borrow_span, Origin::Mir);\n+\n+        err.span_label(\n+            borrow_span,\n+            \"thread-local variables cannot be borrowed beyond the end of the function\",\n+        );\n+        err.span_label(drop_span, \"end of enclosing function is here\");\n+\n+        err\n+    }\n+\n+    fn report_temporary_value_does_not_live_long_enough(\n+        &mut self,\n+        location: Location,\n+        scope_tree: &'tcx ScopeTree,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        borrow_spans: UseSpans,\n+        proper_span: Span,\n+        explanation: BorrowExplanation,\n+    ) -> DiagnosticBuilder<'cx> {\n+        debug!(\n+            \"report_temporary_value_does_not_live_long_enough(\\\n+             {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             )\",\n+            location, scope_tree, borrow, drop_span, proper_span\n+        );\n+\n+        if let BorrowExplanation::MustBeValidFor {\n+            category,\n+            span,\n+            from_closure: false,\n+            ..\n+        } = explanation {\n+            if let Some(diag) = self.try_report_cannot_return_reference_to_local(\n+                borrow,\n+                proper_span,\n+                span,\n+                category,\n+                None,\n+            ) {\n+                return diag;\n+            }\n+        }\n+\n+        let tcx = self.infcx.tcx;\n+        let mut err = tcx.temporary_value_borrowed_for_too_long(proper_span, Origin::Mir);\n+        err.span_label(\n+            proper_span,\n+            \"creates a temporary which is freed while still in use\",\n+        );\n+        err.span_label(\n+            drop_span,\n+            \"temporary value is freed at the end of this statement\",\n+        );\n+\n+        match explanation {\n+            BorrowExplanation::UsedLater(..)\n+            | BorrowExplanation::UsedLaterInLoop(..)\n+            | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n+                // Only give this note and suggestion if it could be relevant.\n+                err.note(\"consider using a `let` binding to create a longer lived value\");\n+            }\n+            _ => {}\n+        }\n+        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+\n+        let within = if borrow_spans.for_generator() {\n+            \" by generator\"\n+        } else {\n+            \"\"\n+        };\n+\n+        borrow_spans.args_span_label(\n+            &mut err,\n+            format!(\"value captured here{}\", within),\n+        );\n+\n+        err\n+    }\n+\n+    fn try_report_cannot_return_reference_to_local(\n+        &self,\n+        borrow: &BorrowData<'tcx>,\n+        borrow_span: Span,\n+        return_span: Span,\n+        category: ConstraintCategory,\n+        opt_place_desc: Option<&String>,\n+    ) -> Option<DiagnosticBuilder<'cx>> {\n+        let tcx = self.infcx.tcx;\n+\n+        let return_kind = match category {\n+            ConstraintCategory::Return => \"return\",\n+            ConstraintCategory::Yield => \"yield\",\n+            _ => return None,\n+        };\n+\n+        // FIXME use a better heuristic than Spans\n+        let reference_desc = if return_span == self.mir.source_info(borrow.reserve_location).span {\n+            \"reference to\"\n+        } else {\n+            \"value referencing\"\n+        };\n+\n+        let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n+            let local_kind = match borrow.borrowed_place {\n+                Place::Base(PlaceBase::Local(local)) => {\n+                    match self.mir.local_kind(local) {\n+                        LocalKind::ReturnPointer\n+                        | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n+                        LocalKind::Var => \"local variable \",\n+                        LocalKind::Arg\n+                        if !self.upvars.is_empty()\n+                            && local == Local::new(1) => {\n+                            \"variable captured by `move` \"\n+                        }\n+                        LocalKind::Arg => {\n+                            \"function parameter \"\n+                        }\n+                    }\n+                }\n+                _ => \"local data \",\n+            };\n+            (\n+                format!(\"{}`{}`\", local_kind, place_desc),\n+                format!(\"`{}` is borrowed here\", place_desc),\n+            )\n+        } else {\n+            let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n+                .last()\n+                .unwrap();\n+            let local = if let Place::Base(PlaceBase::Local(local)) = *root_place {\n+                local\n+            } else {\n+                bug!(\"try_report_cannot_return_reference_to_local: not a local\")\n+            };\n+            match self.mir.local_kind(local) {\n+                LocalKind::ReturnPointer | LocalKind::Temp => {\n+                    (\n+                        \"temporary value\".to_string(),\n+                        \"temporary value created here\".to_string(),\n+                    )\n+                }\n+                LocalKind::Arg => {\n+                    (\n+                        \"function parameter\".to_string(),\n+                        \"function parameter borrowed here\".to_string(),\n+                    )\n+                },\n+                LocalKind::Var => bug!(\"local variable without a name\"),\n+            }\n+        };\n+\n+        let mut err = tcx.cannot_return_reference_to_local(\n+            return_span,\n+            return_kind,\n+            reference_desc,\n+            &place_desc,\n+            Origin::Mir,\n+        );\n+\n+        if return_span != borrow_span {\n+            err.span_label(borrow_span, note);\n+        }\n+\n+        Some(err)\n+    }\n+\n+    fn report_escaping_closure_capture(\n+        &mut self,\n+        args_span: Span,\n+        var_span: Span,\n+        fr_name: &RegionName,\n+        category: ConstraintCategory,\n+        constraint_span: Span,\n+        captured_var: &str,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let tcx = self.infcx.tcx;\n+\n+        let mut err = tcx.cannot_capture_in_long_lived_closure(\n+            args_span,\n+            captured_var,\n+            var_span,\n+          Origin::Mir,\n+        );\n+\n+        let suggestion = match tcx.sess.source_map().span_to_snippet(args_span) {\n+            Ok(string) => format!(\"move {}\", string),\n+            Err(_) => \"move |<args>| <body>\".to_string()\n+        };\n+\n+        err.span_suggestion(\n+            args_span,\n+            &format!(\"to force the closure to take ownership of {} (and any \\\n+                      other referenced variables), use the `move` keyword\",\n+                      captured_var),\n+            suggestion,\n+            Applicability::MachineApplicable,\n+        );\n+\n+        match category {\n+            ConstraintCategory::Return => {\n+                err.span_note(constraint_span, \"closure is returned here\");\n+            }\n+            ConstraintCategory::CallArgument => {\n+                fr_name.highlight_region_name(&mut err);\n+                err.span_note(\n+                    constraint_span,\n+                    &format!(\"function requires argument type to outlive `{}`\", fr_name),\n+                );\n+            }\n+            _ => bug!(\"report_escaping_closure_capture called with unexpected constraint \\\n+                       category: `{:?}`\", category),\n+        }\n+        err\n+    }\n+\n+    fn report_escaping_data(\n+        &mut self,\n+        borrow_span: Span,\n+        name: &Option<String>,\n+        upvar_span: Span,\n+        upvar_name: &str,\n+        escape_span: Span,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let tcx = self.infcx.tcx;\n+\n+        let escapes_from = if tcx.is_closure(self.mir_def_id) {\n+            let tables = tcx.typeck_tables_of(self.mir_def_id);\n+            let mir_hir_id = tcx.hir().def_index_to_hir_id(self.mir_def_id.index);\n+            match tables.node_type(mir_hir_id).sty {\n+                ty::Closure(..) => \"closure\",\n+                ty::Generator(..) => \"generator\",\n+                _ => bug!(\"Closure body doesn't have a closure or generator type\"),\n+            }\n+        } else {\n+            \"function\"\n+        };\n+\n+        let mut err = tcx.borrowed_data_escapes_closure(escape_span, escapes_from, Origin::Mir);\n+\n+        err.span_label(\n+            upvar_span,\n+            format!(\n+                \"`{}` is declared here, outside of the {} body\",\n+                upvar_name, escapes_from\n+            ),\n+        );\n+\n+        err.span_label(\n+            borrow_span,\n+            format!(\n+                \"borrow is only valid in the {} body\",\n+                escapes_from\n+            ),\n+        );\n+\n+        if let Some(name) = name {\n+            err.span_label(\n+                escape_span,\n+                format!(\"reference to `{}` escapes the {} body here\", name, escapes_from),\n+            );\n+        } else {\n+            err.span_label(\n+                escape_span,\n+                format!(\"reference escapes the {} body here\", escapes_from),\n+            );\n+        }\n+\n+        err\n+    }\n+\n+    fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n+        let mir = self.mir;\n+\n+        let mut stack = Vec::new();\n+        stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n+            let is_back_edge = location.dominates(predecessor, &self.dominators);\n+            (predecessor, is_back_edge)\n+        }));\n+\n+        let mut visited = FxHashSet::default();\n+        let mut result = vec![];\n+\n+        'dfs: while let Some((location, is_back_edge)) = stack.pop() {\n+            debug!(\n+                \"report_use_of_moved_or_uninitialized: (current_location={:?}, back_edge={})\",\n+                location, is_back_edge\n+            );\n+\n+            if !visited.insert(location) {\n+                continue;\n+            }\n+\n+            // check for moves\n+            let stmt_kind = mir[location.block]\n+                .statements\n+                .get(location.statement_index)\n+                .map(|s| &s.kind);\n+            if let Some(StatementKind::StorageDead(..)) = stmt_kind {\n+                // this analysis only tries to find moves explicitly\n+                // written by the user, so we ignore the move-outs\n+                // created by `StorageDead` and at the beginning\n+                // of a function.\n+            } else {\n+                // If we are found a use of a.b.c which was in error, then we want to look for\n+                // moves not only of a.b.c but also a.b and a.\n+                //\n+                // Note that the moves data already includes \"parent\" paths, so we don't have to\n+                // worry about the other case: that is, if there is a move of a.b.c, it is already\n+                // marked as a move of a.b and a as well, so we will generate the correct errors\n+                // there.\n+                let mut mpis = vec![mpi];\n+                let move_paths = &self.move_data.move_paths;\n+                mpis.extend(move_paths[mpi].parents(move_paths));\n+\n+                for moi in &self.move_data.loc_map[location] {\n+                    debug!(\"report_use_of_moved_or_uninitialized: moi={:?}\", moi);\n+                    if mpis.contains(&self.move_data.moves[*moi].path) {\n+                        debug!(\"report_use_of_moved_or_uninitialized: found\");\n+                        result.push(MoveSite {\n+                            moi: *moi,\n+                            traversed_back_edge: is_back_edge,\n+                        });\n+\n+                        // Strictly speaking, we could continue our DFS here. There may be\n+                        // other moves that can reach the point of error. But it is kind of\n+                        // confusing to highlight them.\n+                        //\n+                        // Example:\n+                        //\n+                        // ```\n+                        // let a = vec![];\n+                        // let b = a;\n+                        // let c = a;\n+                        // drop(a); // <-- current point of error\n+                        // ```\n+                        //\n+                        // Because we stop the DFS here, we only highlight `let c = a`,\n+                        // and not `let b = a`. We will of course also report an error at\n+                        // `let c = a` which highlights `let b = a` as the move.\n+                        continue 'dfs;\n+                    }\n+                }\n+            }\n+\n+            // check for inits\n+            let mut any_match = false;\n+            drop_flag_effects::for_location_inits(\n+                self.infcx.tcx,\n+                self.mir,\n+                self.move_data,\n+                location,\n+                |m| {\n+                    if m == mpi {\n+                        any_match = true;\n+                    }\n+                },\n+            );\n+            if any_match {\n+                continue 'dfs;\n+            }\n+\n+            stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n+                let back_edge = location.dominates(predecessor, &self.dominators);\n+                (predecessor, is_back_edge || back_edge)\n+            }));\n+        }\n+\n+        result\n+    }\n+\n+    pub(super) fn report_illegal_mutation_of_borrowed(\n+        &mut self,\n+        location: Location,\n+        (place, span): (&Place<'tcx>, Span),\n+        loan: &BorrowData<'tcx>,\n+    ) {\n+        let loan_spans = self.retrieve_borrow_spans(loan);\n+        let loan_span = loan_spans.args_or_use();\n+\n+        let tcx = self.infcx.tcx;\n+        if loan.kind == BorrowKind::Shallow {\n+            let mut err = tcx.cannot_mutate_in_match_guard(\n+                span,\n+                loan_span,\n+                &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n+                \"assign\",\n+                Origin::Mir,\n+            );\n+            loan_spans.var_span_label(\n+                &mut err,\n+                format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n+            );\n+\n+            err.buffer(&mut self.errors_buffer);\n+\n+            return;\n+        }\n+\n+        let mut err = tcx.cannot_assign_to_borrowed(\n+            span,\n+            loan_span,\n+            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+\n+        loan_spans.var_span_label(\n+            &mut err,\n+            format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n+        );\n+\n+        self.explain_why_borrow_contains_point(location, loan, None)\n+            .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+\n+        err.buffer(&mut self.errors_buffer);\n+    }\n+\n+    /// Reports an illegal reassignment; for example, an assignment to\n+    /// (part of) a non-`mut` local that occurs potentially after that\n+    /// local has already been initialized. `place` is the path being\n+    /// assigned; `err_place` is a place providing a reason why\n+    /// `place` is not mutable (e.g., the non-`mut` local `x` in an\n+    /// assignment to `x.f`).\n+    pub(super) fn report_illegal_reassignment(\n+        &mut self,\n+        _location: Location,\n+        (place, span): (&Place<'tcx>, Span),\n+        assigned_span: Span,\n+        err_place: &Place<'tcx>,\n+    ) {\n+        let (from_arg, local_decl) = if let Place::Base(PlaceBase::Local(local)) = *err_place {\n+            if let LocalKind::Arg = self.mir.local_kind(local) {\n+                (true, Some(&self.mir.local_decls[local]))\n+            } else {\n+                (false, Some(&self.mir.local_decls[local]))\n+            }\n+        } else {\n+            (false, None)\n+        };\n+\n+        // If root local is initialized immediately (everything apart from let\n+        // PATTERN;) then make the error refer to that local, rather than the\n+        // place being assigned later.\n+        let (place_description, assigned_span) = match local_decl {\n+            Some(LocalDecl {\n+                is_user_variable: Some(ClearCrossCrate::Clear),\n+                ..\n+            })\n+            | Some(LocalDecl {\n+                is_user_variable:\n+                    Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                        opt_match_place: None,\n+                        ..\n+                    }))),\n+                ..\n+            })\n+            | Some(LocalDecl {\n+                is_user_variable: None,\n+                ..\n+            })\n+            | None => (self.describe_place(place), assigned_span),\n+            Some(decl) => (self.describe_place(err_place), decl.source_info.span),\n+        };\n+\n+        let mut err = self.infcx.tcx.cannot_reassign_immutable(\n+            span,\n+            place_description.as_ref().map(AsRef::as_ref).unwrap_or(\"_\"),\n+            from_arg,\n+            Origin::Mir,\n+        );\n+        let msg = if from_arg {\n+            \"cannot assign to immutable argument\"\n+        } else {\n+            \"cannot assign twice to immutable variable\"\n+        };\n+        if span != assigned_span {\n+            if !from_arg {\n+                let value_msg = match place_description {\n+                    Some(name) => format!(\"`{}`\", name),\n+                    None => \"value\".to_owned(),\n+                };\n+                err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n+            }\n+        }\n+        if let Some(decl) = local_decl {\n+            if let Some(name) = decl.name {\n+                if decl.can_be_made_mutable() {\n+                    err.span_suggestion(\n+                        decl.source_info.span,\n+                        \"make this binding mutable\",\n+                        format!(\"mut {}\", name),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+        err.span_label(span, msg);\n+        err.buffer(&mut self.errors_buffer);\n+    }\n+\n+    fn classify_drop_access_kind(&self, place: &Place<'tcx>) -> StorageDeadOrDrop<'tcx> {\n+        let tcx = self.infcx.tcx;\n+        match place {\n+            Place::Base(PlaceBase::Local(_)) |\n+            Place::Base(PlaceBase::Static(_)) => {\n+                StorageDeadOrDrop::LocalStorageDead\n+            }\n+            Place::Projection(box PlaceProjection { base, elem }) => {\n+                let base_access = self.classify_drop_access_kind(base);\n+                match elem {\n+                    ProjectionElem::Deref => match base_access {\n+                        StorageDeadOrDrop::LocalStorageDead\n+                        | StorageDeadOrDrop::BoxedStorageDead => {\n+                            assert!(\n+                                base.ty(self.mir, tcx).ty.is_box(),\n+                                \"Drop of value behind a reference or raw pointer\"\n+                            );\n+                            StorageDeadOrDrop::BoxedStorageDead\n+                        }\n+                        StorageDeadOrDrop::Destructor(_) => base_access,\n+                    },\n+                    ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n+                        let base_ty = base.ty(self.mir, tcx).ty;\n+                        match base_ty.sty {\n+                            ty::Adt(def, _) if def.has_dtor(tcx) => {\n+                                // Report the outermost adt with a destructor\n+                                match base_access {\n+                                    StorageDeadOrDrop::Destructor(_) => base_access,\n+                                    StorageDeadOrDrop::LocalStorageDead\n+                                    | StorageDeadOrDrop::BoxedStorageDead => {\n+                                        StorageDeadOrDrop::Destructor(base_ty)\n+                                    }\n+                                }\n+                            }\n+                            _ => base_access,\n+                        }\n+                    }\n+\n+                    ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. }\n+                    | ProjectionElem::Index(_) => base_access,\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Annotate argument and return type of function and closure with (synthesized) lifetime for\n+    /// borrow of local value that does not live long enough.\n+    fn annotate_argument_and_return_for_borrow(\n+        &self,\n+        borrow: &BorrowData<'tcx>,\n+    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n+        // Define a fallback for when we can't match a closure.\n+        let fallback = || {\n+            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n+            if is_closure {\n+                None\n+            } else {\n+                let ty = self.infcx.tcx.type_of(self.mir_def_id);\n+                match ty.sty {\n+                    ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n+                        self.mir_def_id,\n+                        self.infcx.tcx.fn_sig(self.mir_def_id),\n+                    ),\n+                    _ => None,\n+                }\n+            }\n+        };\n+\n+        // In order to determine whether we need to annotate, we need to check whether the reserve\n+        // place was an assignment into a temporary.\n+        //\n+        // If it was, we check whether or not that temporary is eventually assigned into the return\n+        // place. If it was, we can add annotations about the function's return type and arguments\n+        // and it'll make sense.\n+        let location = borrow.reserve_location;\n+        debug!(\n+            \"annotate_argument_and_return_for_borrow: location={:?}\",\n+            location\n+        );\n+        if let Some(&Statement { kind: StatementKind::Assign(ref reservation, _), ..})\n+             = &self.mir[location.block].statements.get(location.statement_index)\n+        {\n+            debug!(\n+                \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n+                reservation\n+            );\n+            // Check that the initial assignment of the reserve location is into a temporary.\n+            let mut target = *match reservation {\n+                Place::Base(PlaceBase::Local(local))\n+                    if self.mir.local_kind(*local) == LocalKind::Temp => local,\n+                _ => return None,\n+            };\n+\n+            // Next, look through the rest of the block, checking if we are assigning the\n+            // `target` (that is, the place that contains our borrow) to anything.\n+            let mut annotated_closure = None;\n+            for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+                debug!(\n+                    \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n+                    target, stmt\n+                );\n+                if let StatementKind::Assign(\n+                    Place::Base(PlaceBase::Local(assigned_to)),\n+                    box rvalue\n+                ) = &stmt.kind {\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                         rvalue={:?}\",\n+                        assigned_to, rvalue\n+                    );\n+                    // Check if our `target` was captured by a closure.\n+                    if let Rvalue::Aggregate(\n+                        box AggregateKind::Closure(def_id, substs),\n+                        operands,\n+                    ) = rvalue\n+                    {\n+                        for operand in operands {\n+                            let assigned_from = match operand {\n+                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                    assigned_from\n+                                }\n+                                _ => continue,\n+                            };\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                                assigned_from\n+                            );\n+\n+                            // Find the local from the operand.\n+                            let assigned_from_local = match assigned_from.local() {\n+                                Some(local) => local,\n+                                None => continue,\n+                            };\n+\n+                            if assigned_from_local != target {\n+                                continue;\n+                            }\n+\n+                            // If a closure captured our `target` and then assigned\n+                            // into a place then we should annotate the closure in\n+                            // case it ends up being assigned into the return place.\n+                            annotated_closure = self.annotate_fn_sig(\n+                                *def_id,\n+                                self.infcx.closure_sig(*def_id, *substs),\n+                            );\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: \\\n+                                 annotated_closure={:?} assigned_from_local={:?} \\\n+                                 assigned_to={:?}\",\n+                                annotated_closure, assigned_from_local, assigned_to\n+                            );\n+\n+                            if *assigned_to == mir::RETURN_PLACE {\n+                                // If it was assigned directly into the return place, then\n+                                // return now.\n+                                return annotated_closure;\n+                            } else {\n+                                // Otherwise, update the target.\n+                                target = *assigned_to;\n+                            }\n+                        }\n+\n+                        // If none of our closure's operands matched, then skip to the next\n+                        // statement.\n+                        continue;\n+                    }\n+\n+                    // Otherwise, look at other types of assignment.\n+                    let assigned_from = match rvalue {\n+                        Rvalue::Ref(_, _, assigned_from) => assigned_from,\n+                        Rvalue::Use(operand) => match operand {\n+                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                assigned_from\n+                            }\n+                            _ => continue,\n+                        },\n+                        _ => continue,\n+                    };\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from={:?}\",\n+                        assigned_from,\n+                    );\n+\n+                    // Find the local from the rvalue.\n+                    let assigned_from_local = match assigned_from.local() {\n+                        Some(local) => local,\n+                        None => continue,\n+                    };\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from_local={:?}\",\n+                        assigned_from_local,\n+                    );\n+\n+                    // Check if our local matches the target - if so, we've assigned our\n+                    // borrow to a new place.\n+                    if assigned_from_local != target {\n+                        continue;\n+                    }\n+\n+                    // If we assigned our `target` into a new place, then we should\n+                    // check if it was the return place.\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from_local={:?} assigned_to={:?}\",\n+                        assigned_from_local, assigned_to\n+                    );\n+                    if *assigned_to == mir::RETURN_PLACE {\n+                        // If it was then return the annotated closure if there was one,\n+                        // else, annotate this function.\n+                        return annotated_closure.or_else(fallback);\n+                    }\n+\n+                    // If we didn't assign into the return place, then we just update\n+                    // the target.\n+                    target = *assigned_to;\n+                }\n+            }\n+\n+            // Check the terminator if we didn't find anything in the statements.\n+            let terminator = &self.mir[location.block].terminator();\n+            debug!(\n+                \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n+                target, terminator\n+            );\n+            if let TerminatorKind::Call {\n+                destination: Some((Place::Base(PlaceBase::Local(assigned_to)), _)),\n+                args,\n+                ..\n+            } = &terminator.kind\n+            {\n+                debug!(\n+                    \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n+                    assigned_to, args\n+                );\n+                for operand in args {\n+                    let assigned_from = match operand {\n+                        Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                            assigned_from\n+                        }\n+                        _ => continue,\n+                    };\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                        assigned_from,\n+                    );\n+\n+                    if let Some(assigned_from_local) = assigned_from.local() {\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n+                            assigned_from_local,\n+                        );\n+\n+                        if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n+                            return annotated_closure.or_else(fallback);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // If we haven't found an assignment into the return place, then we need not add\n+        // any annotations.\n+        debug!(\"annotate_argument_and_return_for_borrow: none found\");\n+        None\n+    }\n+\n+    /// Annotate the first argument and return type of a function signature if they are\n+    /// references.\n+    fn annotate_fn_sig(\n+        &self,\n+        did: DefId,\n+        sig: ty::PolyFnSig<'tcx>,\n+    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n+        debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n+        let is_closure = self.infcx.tcx.is_closure(did);\n+        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did)?;\n+        let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(fn_hir_id)?;\n+\n+        // We need to work out which arguments to highlight. We do this by looking\n+        // at the return type, where there are three cases:\n+        //\n+        // 1. If there are named arguments, then we should highlight the return type and\n+        //    highlight any of the arguments that are also references with that lifetime.\n+        //    If there are no arguments that have the same lifetime as the return type,\n+        //    then don't highlight anything.\n+        // 2. The return type is a reference with an anonymous lifetime. If this is\n+        //    the case, then we can take advantage of (and teach) the lifetime elision\n+        //    rules.\n+        //\n+        //    We know that an error is being reported. So the arguments and return type\n+        //    must satisfy the elision rules. Therefore, if there is a single argument\n+        //    then that means the return type and first (and only) argument have the same\n+        //    lifetime and the borrow isn't meeting that, we can highlight the argument\n+        //    and return type.\n+        //\n+        //    If there are multiple arguments then the first argument must be self (else\n+        //    it would not satisfy the elision rules), so we can highlight self and the\n+        //    return type.\n+        // 3. The return type is not a reference. In this case, we don't highlight\n+        //    anything.\n+        let return_ty = sig.output();\n+        match return_ty.skip_binder().sty {\n+            ty::Ref(return_region, _, _) if return_region.has_name() && !is_closure => {\n+                // This is case 1 from above, return type is a named reference so we need to\n+                // search for relevant arguments.\n+                let mut arguments = Vec::new();\n+                for (index, argument) in sig.inputs().skip_binder().iter().enumerate() {\n+                    if let ty::Ref(argument_region, _, _) = argument.sty {\n+                        if argument_region == return_region {\n+                            // Need to use the `rustc::ty` types to compare against the\n+                            // `return_region`. Then use the `rustc::hir` type to get only\n+                            // the lifetime span.\n+                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].node {\n+                                // With access to the lifetime, we can get\n+                                // the span of it.\n+                                arguments.push((*argument, lifetime.span));\n+                            } else {\n+                                bug!(\"ty type is a ref but hir type is not\");\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // We need to have arguments. This shouldn't happen, but it's worth checking.\n+                if arguments.is_empty() {\n+                    return None;\n+                }\n+\n+                // We use a mix of the HIR and the Ty types to get information\n+                // as the HIR doesn't have full types for closure arguments.\n+                let return_ty = *sig.output().skip_binder();\n+                let mut return_span = fn_decl.output.span();\n+                if let hir::FunctionRetTy::Return(ty) = fn_decl.output {\n+                    if let hir::TyKind::Rptr(lifetime, _) = ty.into_inner().node {\n+                        return_span = lifetime.span;\n+                    }\n+                }\n+\n+                Some(AnnotatedBorrowFnSignature::NamedFunction {\n+                    arguments,\n+                    return_ty,\n+                    return_span,\n+                })\n+            }\n+            ty::Ref(_, _, _) if is_closure => {\n+                // This is case 2 from above but only for closures, return type is anonymous\n+                // reference so we select\n+                // the first argument.\n+                let argument_span = fn_decl.inputs.first()?.span;\n+                let argument_ty = sig.inputs().skip_binder().first()?;\n+\n+                // Closure arguments are wrapped in a tuple, so we need to get the first\n+                // from that.\n+                if let ty::Tuple(elems) = argument_ty.sty {\n+                    let argument_ty = elems.first()?.expect_ty();\n+                    if let ty::Ref(_, _, _) = argument_ty.sty {\n+                        return Some(AnnotatedBorrowFnSignature::Closure {\n+                            argument_ty,\n+                            argument_span,\n+                        });\n+                    }\n+                }\n+\n+                None\n+            }\n+            ty::Ref(_, _, _) => {\n+                // This is also case 2 from above but for functions, return type is still an\n+                // anonymous reference so we select the first argument.\n+                let argument_span = fn_decl.inputs.first()?.span;\n+                let argument_ty = sig.inputs().skip_binder().first()?;\n+\n+                let return_span = fn_decl.output.span();\n+                let return_ty = *sig.output().skip_binder();\n+\n+                // We expect the first argument to be a reference.\n+                match argument_ty.sty {\n+                    ty::Ref(_, _, _) => {}\n+                    _ => return None,\n+                }\n+\n+                Some(AnnotatedBorrowFnSignature::AnonymousFunction {\n+                    argument_ty,\n+                    argument_span,\n+                    return_ty,\n+                    return_span,\n+                })\n+            }\n+            _ => {\n+                // This is case 3 from above, return type is not a reference so don't highlight\n+                // anything.\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum AnnotatedBorrowFnSignature<'tcx> {\n+    NamedFunction {\n+        arguments: Vec<(Ty<'tcx>, Span)>,\n+        return_ty: Ty<'tcx>,\n+        return_span: Span,\n+    },\n+    AnonymousFunction {\n+        argument_ty: Ty<'tcx>,\n+        argument_span: Span,\n+        return_ty: Ty<'tcx>,\n+        return_span: Span,\n+    },\n+    Closure {\n+        argument_ty: Ty<'tcx>,\n+        argument_span: Span,\n+    },\n+}\n+\n+impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n+    /// Annotate the provided diagnostic with information about borrow from the fn signature that\n+    /// helps explain.\n+    pub(super) fn emit(\n+        &self,\n+        cx: &mut MirBorrowckCtxt<'_, '_, 'tcx>,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> String {\n+        match self {\n+            AnnotatedBorrowFnSignature::Closure {\n+                argument_ty,\n+                argument_span,\n+            } => {\n+                diag.span_label(\n+                    *argument_span,\n+                    format!(\"has type `{}`\", cx.get_name_for_ty(argument_ty, 0)),\n+                );\n+\n+                cx.get_region_name_for_ty(argument_ty, 0)\n+            }\n+            AnnotatedBorrowFnSignature::AnonymousFunction {\n+                argument_ty,\n+                argument_span,\n+                return_ty,\n+                return_span,\n+            } => {\n+                let argument_ty_name = cx.get_name_for_ty(argument_ty, 0);\n+                diag.span_label(*argument_span, format!(\"has type `{}`\", argument_ty_name));\n+\n+                let return_ty_name = cx.get_name_for_ty(return_ty, 0);\n+                let types_equal = return_ty_name == argument_ty_name;\n+                diag.span_label(\n+                    *return_span,\n+                    format!(\n+                        \"{}has type `{}`\",\n+                        if types_equal { \"also \" } else { \"\" },\n+                        return_ty_name,\n+                    ),\n+                );\n+\n+                diag.note(\n+                    \"argument and return type have the same lifetime due to lifetime elision rules\",\n+                );\n+                diag.note(\n+                    \"to learn more, visit <https://doc.rust-lang.org/book/ch10-03-\\\n+                     lifetime-syntax.html#lifetime-elision>\",\n+                );\n+\n+                cx.get_region_name_for_ty(return_ty, 0)\n+            }\n+            AnnotatedBorrowFnSignature::NamedFunction {\n+                arguments,\n+                return_ty,\n+                return_span,\n+            } => {\n+                // Region of return type and arguments checked to be the same earlier.\n+                let region_name = cx.get_region_name_for_ty(return_ty, 0);\n+                for (_, argument_span) in arguments {\n+                    diag.span_label(*argument_span, format!(\"has lifetime `{}`\", region_name));\n+                }\n+\n+                diag.span_label(\n+                    *return_span,\n+                    format!(\"also has lifetime `{}`\", region_name,),\n+                );\n+\n+                diag.help(&format!(\n+                    \"use data from the highlighted arguments which match the `{}` lifetime of \\\n+                     the return type\",\n+                    region_name,\n+                ));\n+\n+                region_name\n+            }\n+        }\n+    }\n+}"}, {"sha": "e7eef813e337a80077f91f60af02d108af068497", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 1988, "changes": 1998, "blob_url": "https://github.com/rust-lang/rust/blob/df5d07217271401217fce2d79f3ec75fa0e2b207/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df5d07217271401217fce2d79f3ec75fa0e2b207/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=df5d07217271401217fce2d79f3ec75fa0e2b207", "patch": "@@ -1,1505 +1,22 @@\n-use crate::borrow_check::nll::explain_borrow::BorrowExplanation;\n-use crate::borrow_check::nll::region_infer::{RegionName, RegionNameSource};\n-use crate::borrow_check::prefixes::IsPrefixOf;\n-use crate::borrow_check::WriteKind;\n use rustc::hir;\n use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n-    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, Constant,\n-    ConstraintCategory, Field, Local, LocalDecl, LocalKind, Location, Operand,\n-    Place, PlaceBase, PlaceProjection, ProjectionElem, Rvalue, Statement, StatementKind,\n-    Static, StaticKind, TerminatorKind, VarBindingForm,\n+    AggregateKind, BindingForm, ClearCrossCrate, Constant, Field, Local,\n+    LocalKind, Location, Operand, Place, PlaceBase, ProjectionElem, Rvalue,\n+    Statement, StatementKind, Static, StaticKind, TerminatorKind,\n };\n use rustc::ty::{self, DefIdTree, Ty};\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n-use syntax::source_map::CompilerDesugaringKind;\n use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n use super::{MirBorrowckCtxt};\n-use super::{InitializationRequiringAction, PrefixSet};\n-use crate::dataflow::drop_flag_effects;\n-use crate::dataflow::indexes::{MovePathIndex, MoveOutIndex};\n-use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n \n-#[derive(Debug)]\n-struct MoveSite {\n-    /// Index of the \"move out\" that we found. The `MoveData` can\n-    /// then tell us where the move occurred.\n-    moi: MoveOutIndex,\n-\n-    /// `true` if we traversed a back edge while walking from the point\n-    /// of error to the move site.\n-    traversed_back_edge: bool\n-}\n-\n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    pub(super) fn report_use_of_moved_or_uninitialized(\n-        &mut self,\n-        location: Location,\n-        desired_action: InitializationRequiringAction,\n-        (moved_place, used_place, span): (&Place<'tcx>, &Place<'tcx>, Span),\n-        mpi: MovePathIndex,\n-    ) {\n-        debug!(\n-            \"report_use_of_moved_or_uninitialized: location={:?} desired_action={:?} \\\n-             moved_place={:?} used_place={:?} span={:?} mpi={:?}\",\n-            location, desired_action, moved_place, used_place, span, mpi\n-        );\n-\n-        let use_spans = self.move_spans(moved_place, location)\n-            .or_else(|| self.borrow_spans(span, location));\n-        let span = use_spans.args_or_use();\n-\n-        let move_site_vec = self.get_moved_indexes(location, mpi);\n-        debug!(\n-            \"report_use_of_moved_or_uninitialized: move_site_vec={:?}\",\n-            move_site_vec\n-        );\n-        let move_out_indices: Vec<_> = move_site_vec\n-            .iter()\n-            .map(|move_site| move_site.moi)\n-            .collect();\n-\n-        if move_out_indices.is_empty() {\n-            let root_place = self.prefixes(&used_place, PrefixSet::All).last().unwrap();\n-\n-            if self.uninitialized_error_reported.contains(root_place) {\n-                debug!(\n-                    \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n-                    root_place\n-                );\n-                return;\n-            }\n-\n-            self.uninitialized_error_reported.insert(root_place.clone());\n-\n-            let item_msg = match self.describe_place_with_options(used_place,\n-                                                                  IncludingDowncast(true)) {\n-                Some(name) => format!(\"`{}`\", name),\n-                None => \"value\".to_owned(),\n-            };\n-            let mut err = self.infcx.tcx.cannot_act_on_uninitialized_variable(\n-                span,\n-                desired_action.as_noun(),\n-                &self.describe_place_with_options(moved_place, IncludingDowncast(true))\n-                    .unwrap_or_else(|| \"_\".to_owned()),\n-                Origin::Mir,\n-            );\n-            err.span_label(span, format!(\"use of possibly uninitialized {}\", item_msg));\n-\n-            use_spans.var_span_label(\n-                &mut err,\n-                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n-            );\n-\n-            err.buffer(&mut self.errors_buffer);\n-        } else {\n-            if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {\n-                if self.prefixes(&reported_place, PrefixSet::All)\n-                    .any(|p| p == used_place)\n-                {\n-                    debug!(\n-                        \"report_use_of_moved_or_uninitialized place: error suppressed \\\n-                         mois={:?}\",\n-                        move_out_indices\n-                    );\n-                    return;\n-                }\n-            }\n-\n-            let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n-\n-            let mut err = self.infcx.tcx.cannot_act_on_moved_value(\n-                span,\n-                desired_action.as_noun(),\n-                msg,\n-                self.describe_place_with_options(&moved_place, IncludingDowncast(true)),\n-                Origin::Mir,\n-            );\n-\n-            self.add_moved_or_invoked_closure_note(\n-                location,\n-                used_place,\n-                &mut err,\n-            );\n-\n-            let mut is_loop_move = false;\n-            let is_partial_move = move_site_vec.iter().any(|move_site| {\n-                let move_out = self.move_data.moves[(*move_site).moi];\n-                let moved_place = &self.move_data.move_paths[move_out.path].place;\n-                used_place != moved_place && used_place.is_prefix_of(moved_place)\n-            });\n-            for move_site in &move_site_vec {\n-                let move_out = self.move_data.moves[(*move_site).moi];\n-                let moved_place = &self.move_data.move_paths[move_out.path].place;\n-\n-                let move_spans = self.move_spans(moved_place, move_out.source);\n-                let move_span = move_spans.args_or_use();\n-\n-                let move_msg = if move_spans.for_closure() {\n-                    \" into closure\"\n-                } else {\n-                    \"\"\n-                };\n-\n-                if span == move_span {\n-                    err.span_label(\n-                        span,\n-                        format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n-                    );\n-                    if Some(CompilerDesugaringKind::ForLoop) == span.compiler_desugaring_kind() {\n-                        if let Ok(snippet) = self.infcx.tcx.sess.source_map()\n-                            .span_to_snippet(span)\n-                        {\n-                            err.span_suggestion(\n-                                move_span,\n-                                \"consider borrowing this to avoid moving it into the for loop\",\n-                                format!(\"&{}\", snippet),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }\n-                    is_loop_move = true;\n-                } else if move_site.traversed_back_edge {\n-                    err.span_label(\n-                        move_span,\n-                        format!(\n-                            \"value moved{} here, in previous iteration of loop\",\n-                            move_msg\n-                        ),\n-                    );\n-                } else {\n-                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                    move_spans.var_span_label(\n-                        &mut err,\n-                        format!(\"variable moved due to use{}\", move_spans.describe()),\n-                    );\n-                };\n-            }\n-\n-            use_spans.var_span_label(\n-                &mut err,\n-                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n-            );\n-\n-            if !is_loop_move {\n-                err.span_label(\n-                    span,\n-                    format!(\n-                        \"value {} here {}\",\n-                        desired_action.as_verb_in_past_tense(),\n-                        if is_partial_move { \"after partial move\" } else { \"after move\" },\n-                    ),\n-                );\n-            }\n-\n-            let ty = used_place.ty(self.mir, self.infcx.tcx).ty;\n-            let needs_note = match ty.sty {\n-                ty::Closure(id, _) => {\n-                    let tables = self.infcx.tcx.typeck_tables_of(id);\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id).unwrap();\n-\n-                    tables.closure_kind_origins().get(hir_id).is_none()\n-                }\n-                _ => true,\n-            };\n-\n-            if needs_note {\n-                let mpi = self.move_data.moves[move_out_indices[0]].path;\n-                let place = &self.move_data.move_paths[mpi].place;\n-\n-                let ty = place.ty(self.mir, self.infcx.tcx).ty;\n-                let opt_name = self.describe_place_with_options(place, IncludingDowncast(true));\n-                let note_msg = match opt_name {\n-                    Some(ref name) => format!(\"`{}`\", name),\n-                    None => \"value\".to_owned(),\n-                };\n-                if let ty::Param(param_ty) = ty.sty {\n-                    let tcx = self.infcx.tcx;\n-                    let generics = tcx.generics_of(self.mir_def_id);\n-                    let def_id = generics.type_param(&param_ty, tcx).def_id;\n-                    if let Some(sp) = tcx.hir().span_if_local(def_id) {\n-                        err.span_label(\n-                            sp,\n-                            \"consider adding a `Copy` constraint to this type argument\",\n-                        );\n-                    }\n-                }\n-                if let Place::Base(PlaceBase::Local(local)) = place {\n-                    let decl = &self.mir.local_decls[*local];\n-                    err.span_label(\n-                        decl.source_info.span,\n-                        format!(\n-                            \"move occurs because {} has type `{}`, \\\n-                                which does not implement the `Copy` trait\",\n-                            note_msg, ty,\n-                    ));\n-                } else {\n-                    err.note(&format!(\n-                        \"move occurs because {} has type `{}`, \\\n-                         which does not implement the `Copy` trait\",\n-                        note_msg, ty\n-                    ));\n-                }\n-            }\n-\n-            if let Some((_, mut old_err)) = self.move_error_reported\n-                .insert(move_out_indices, (used_place.clone(), err))\n-            {\n-                // Cancel the old error so it doesn't ICE.\n-                old_err.cancel();\n-            }\n-        }\n-    }\n-\n-    pub(super) fn report_move_out_while_borrowed(\n-        &mut self,\n-        location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n-        borrow: &BorrowData<'tcx>,\n-    ) {\n-        debug!(\n-            \"report_move_out_while_borrowed: location={:?} place={:?} span={:?} borrow={:?}\",\n-            location, place, span, borrow\n-        );\n-        let tcx = self.infcx.tcx;\n-        let value_msg = match self.describe_place(place) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n-        let borrow_msg = match self.describe_place(&borrow.borrowed_place) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n-\n-        let borrow_spans = self.retrieve_borrow_spans(borrow);\n-        let borrow_span = borrow_spans.args_or_use();\n-\n-        let move_spans = self.move_spans(place, location);\n-        let span = move_spans.args_or_use();\n-\n-        let mut err = tcx.cannot_move_when_borrowed(\n-            span,\n-            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n-            Origin::Mir,\n-        );\n-        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n-        err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n-\n-        borrow_spans.var_span_label(\n-            &mut err,\n-            format!(\"borrow occurs due to use{}\", borrow_spans.describe())\n-        );\n-\n-        move_spans.var_span_label(\n-            &mut err,\n-            format!(\"move occurs due to use{}\", move_spans.describe())\n-        );\n-\n-        self.explain_why_borrow_contains_point(\n-            location,\n-            borrow,\n-            None,\n-        ).add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", Some(borrow_span));\n-        err.buffer(&mut self.errors_buffer);\n-    }\n-\n-    pub(super) fn report_use_while_mutably_borrowed(\n-        &mut self,\n-        location: Location,\n-        (place, _span): (&Place<'tcx>, Span),\n-        borrow: &BorrowData<'tcx>,\n-    ) -> DiagnosticBuilder<'cx> {\n-        let tcx = self.infcx.tcx;\n-\n-        let borrow_spans = self.retrieve_borrow_spans(borrow);\n-        let borrow_span = borrow_spans.args_or_use();\n-\n-        // Conflicting borrows are reported separately, so only check for move\n-        // captures.\n-        let use_spans = self.move_spans(place, location);\n-        let span = use_spans.var_or_use();\n-\n-        let mut err = tcx.cannot_use_when_mutably_borrowed(\n-            span,\n-            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n-            borrow_span,\n-            &self.describe_place(&borrow.borrowed_place)\n-                .unwrap_or_else(|| \"_\".to_owned()),\n-            Origin::Mir,\n-        );\n-\n-        borrow_spans.var_span_label(&mut err, {\n-            let place = &borrow.borrowed_place;\n-            let desc_place = self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n-\n-            format!(\"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe())\n-        });\n-\n-        self.explain_why_borrow_contains_point(location, borrow, None)\n-            .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n-        err\n-    }\n-\n-    pub(super) fn report_conflicting_borrow(\n-        &mut self,\n-        location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n-        gen_borrow_kind: BorrowKind,\n-        issued_borrow: &BorrowData<'tcx>,\n-    ) -> DiagnosticBuilder<'cx> {\n-        let issued_spans = self.retrieve_borrow_spans(issued_borrow);\n-        let issued_span = issued_spans.args_or_use();\n-\n-        let borrow_spans = self.borrow_spans(span, location);\n-        let span = borrow_spans.args_or_use();\n-\n-        let container_name = if issued_spans.for_generator() || borrow_spans.for_generator() {\n-            \"generator\"\n-        } else {\n-            \"closure\"\n-        };\n-\n-        let (desc_place, msg_place, msg_borrow, union_type_name) =\n-            self.describe_place_for_conflicting_borrow(place, &issued_borrow.borrowed_place);\n-\n-        let explanation = self.explain_why_borrow_contains_point(location, issued_borrow, None);\n-        let second_borrow_desc = if explanation.is_explained() {\n-            \"second \"\n-        } else {\n-            \"\"\n-        };\n-\n-        // FIXME: supply non-\"\" `opt_via` when appropriate\n-        let tcx = self.infcx.tcx;\n-        let first_borrow_desc;\n-        let mut err = match (\n-            gen_borrow_kind,\n-            \"immutable\",\n-            \"mutable\",\n-            issued_borrow.kind,\n-            \"immutable\",\n-            \"mutable\",\n-        ) {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt) => {\n-                first_borrow_desc = \"mutable \";\n-                tcx.cannot_reborrow_already_borrowed(\n-                    span,\n-                    &desc_place,\n-                    &msg_place,\n-                    lft,\n-                    issued_span,\n-                    \"it\",\n-                    rgt,\n-                    &msg_borrow,\n-                    None,\n-                    Origin::Mir,\n-                )\n-            }\n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n-                first_borrow_desc = \"immutable \";\n-                tcx.cannot_reborrow_already_borrowed(\n-                    span,\n-                    &desc_place,\n-                    &msg_place,\n-                    lft,\n-                    issued_span,\n-                    \"it\",\n-                    rgt,\n-                    &msg_borrow,\n-                    None,\n-                    Origin::Mir,\n-                )\n-            }\n-\n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n-                first_borrow_desc = \"first \";\n-                tcx.cannot_mutably_borrow_multiply(\n-                    span,\n-                    &desc_place,\n-                    &msg_place,\n-                    issued_span,\n-                    &msg_borrow,\n-                    None,\n-                    Origin::Mir,\n-                )\n-            }\n-\n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n-                first_borrow_desc = \"first \";\n-                tcx.cannot_uniquely_borrow_by_two_closures(\n-                    span,\n-                    &desc_place,\n-                    issued_span,\n-                    None,\n-                    Origin::Mir,\n-                )\n-            }\n-\n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Shallow, _, _)\n-            | (BorrowKind::Unique, _, _, BorrowKind::Shallow, _, _) => {\n-                let mut err = tcx.cannot_mutate_in_match_guard(\n-                    span,\n-                    issued_span,\n-                    &desc_place,\n-                    \"mutably borrow\",\n-                    Origin::Mir,\n-                );\n-                borrow_spans.var_span_label(\n-                    &mut err,\n-                    format!(\n-                        \"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe()\n-                    ),\n-                );\n-\n-                return err;\n-            }\n-\n-            (BorrowKind::Unique, _, _, _, _, _) => {\n-                first_borrow_desc = \"first \";\n-                tcx.cannot_uniquely_borrow_by_one_closure(\n-                    span,\n-                    container_name,\n-                    &desc_place,\n-                    \"\",\n-                    issued_span,\n-                    \"it\",\n-                    \"\",\n-                    None,\n-                    Origin::Mir,\n-                )\n-            },\n-\n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n-                first_borrow_desc = \"first \";\n-                tcx.cannot_reborrow_already_uniquely_borrowed(\n-                    span,\n-                    container_name,\n-                    &desc_place,\n-                    \"\",\n-                    lft,\n-                    issued_span,\n-                    \"\",\n-                    None,\n-                    second_borrow_desc,\n-                    Origin::Mir,\n-                )\n-            }\n-\n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n-                first_borrow_desc = \"first \";\n-                tcx.cannot_reborrow_already_uniquely_borrowed(\n-                    span,\n-                    container_name,\n-                    &desc_place,\n-                    \"\",\n-                    lft,\n-                    issued_span,\n-                    \"\",\n-                    None,\n-                    second_borrow_desc,\n-                    Origin::Mir,\n-                )\n-            }\n-\n-            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _)\n-            | (BorrowKind::Shared, _, _, BorrowKind::Shallow, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Shared, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Shallow, _, _) => unreachable!(),\n-        };\n-\n-        if issued_spans == borrow_spans {\n-            borrow_spans.var_span_label(\n-                &mut err,\n-                format!(\"borrows occur due to use of `{}`{}\", desc_place, borrow_spans.describe()),\n-            );\n-        } else {\n-            let borrow_place = &issued_borrow.borrowed_place;\n-            let borrow_place_desc = self.describe_place(borrow_place)\n-                                        .unwrap_or_else(|| \"_\".to_owned());\n-            issued_spans.var_span_label(\n-                &mut err,\n-                format!(\n-                    \"first borrow occurs due to use of `{}`{}\",\n-                    borrow_place_desc,\n-                    issued_spans.describe(),\n-                ),\n-            );\n-\n-            borrow_spans.var_span_label(\n-                &mut err,\n-                format!(\n-                    \"second borrow occurs due to use of `{}`{}\",\n-                    desc_place,\n-                    borrow_spans.describe(),\n-                ),\n-            );\n-        }\n-\n-        if union_type_name != \"\" {\n-            err.note(&format!(\n-                \"`{}` is a field of the union `{}`, so it overlaps the field `{}`\",\n-                msg_place, union_type_name, msg_borrow,\n-            ));\n-        }\n-\n-        explanation.add_explanation_to_diagnostic(\n-            self.infcx.tcx,\n-            self.mir,\n-            &mut err,\n-            first_borrow_desc,\n-            None,\n-        );\n-\n-        err\n-    }\n-\n-    /// Returns the description of the root place for a conflicting borrow and the full\n-    /// descriptions of the places that caused the conflict.\n-    ///\n-    /// In the simplest case, where there are no unions involved, if a mutable borrow of `x` is\n-    /// attempted while a shared borrow is live, then this function will return:\n-    ///\n-    ///     (\"x\", \"\", \"\")\n-    ///\n-    /// In the simple union case, if a mutable borrow of a union field `x.z` is attempted while\n-    /// a shared borrow of another field `x.y`, then this function will return:\n-    ///\n-    ///     (\"x\", \"x.z\", \"x.y\")\n-    ///\n-    /// In the more complex union case, where the union is a field of a struct, then if a mutable\n-    /// borrow of a union field in a struct `x.u.z` is attempted while a shared borrow of\n-    /// another field `x.u.y`, then this function will return:\n-    ///\n-    ///     (\"x.u\", \"x.u.z\", \"x.u.y\")\n-    ///\n-    /// This is used when creating error messages like below:\n-    ///\n-    /// >  cannot borrow `a.u` (via `a.u.z.c`) as immutable because it is also borrowed as\n-    /// >  mutable (via `a.u.s.b`) [E0502]\n-    pub(super) fn describe_place_for_conflicting_borrow(\n-        &self,\n-        first_borrowed_place: &Place<'tcx>,\n-        second_borrowed_place: &Place<'tcx>,\n-    ) -> (String, String, String, String) {\n-        // Define a small closure that we can use to check if the type of a place\n-        // is a union.\n-        let is_union = |place: &Place<'tcx>| -> bool {\n-            place.ty(self.mir, self.infcx.tcx).ty\n-                .ty_adt_def()\n-                .map(|adt| adt.is_union())\n-                .unwrap_or(false)\n-        };\n-\n-        // Start with an empty tuple, so we can use the functions on `Option` to reduce some\n-        // code duplication (particularly around returning an empty description in the failure\n-        // case).\n-        Some(())\n-            .filter(|_| {\n-                // If we have a conflicting borrow of the same place, then we don't want to add\n-                // an extraneous \"via x.y\" to our diagnostics, so filter out this case.\n-                first_borrowed_place != second_borrowed_place\n-            })\n-            .and_then(|_| {\n-                // We're going to want to traverse the first borrowed place to see if we can find\n-                // field access to a union. If we find that, then we will keep the place of the\n-                // union being accessed and the field that was being accessed so we can check the\n-                // second borrowed place for the same union and a access to a different field.\n-                let mut current = first_borrowed_place;\n-                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n-                    match elem {\n-                        ProjectionElem::Field(field, _) if is_union(base) => {\n-                            return Some((base, field));\n-                        },\n-                        _ => current = base,\n-                    }\n-                }\n-                None\n-            })\n-            .and_then(|(target_base, target_field)| {\n-                // With the place of a union and a field access into it, we traverse the second\n-                // borrowed place and look for a access to a different field of the same union.\n-                let mut current = second_borrowed_place;\n-                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n-                    match elem {\n-                        ProjectionElem::Field(field, _) if {\n-                            is_union(base) && field != target_field && base == target_base\n-                        } => {\n-                            let desc_base = self.describe_place(base)\n-                                .unwrap_or_else(|| \"_\".to_owned());\n-                            let desc_first = self.describe_place(first_borrowed_place)\n-                                .unwrap_or_else(|| \"_\".to_owned());\n-                            let desc_second = self.describe_place(second_borrowed_place)\n-                                .unwrap_or_else(|| \"_\".to_owned());\n-\n-                            // Also compute the name of the union type, eg. `Foo` so we\n-                            // can add a helpful note with it.\n-                            let ty = base.ty(self.mir, self.infcx.tcx).ty;\n-\n-                            return Some((desc_base, desc_first, desc_second, ty.to_string()));\n-                        },\n-                        _ => current = base,\n-                    }\n-                }\n-                None\n-            })\n-            .unwrap_or_else(|| {\n-                // If we didn't find a field access into a union, or both places match, then\n-                // only return the description of the first place.\n-                let desc_place = self.describe_place(first_borrowed_place)\n-                    .unwrap_or_else(|| \"_\".to_owned());\n-                (desc_place, \"\".to_string(), \"\".to_string(), \"\".to_string())\n-            })\n-    }\n-\n-    /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n-    ///\n-    /// This means that some data referenced by `borrow` needs to live\n-    /// past the point where the StorageDeadOrDrop of `place` occurs.\n-    /// This is usually interpreted as meaning that `place` has too\n-    /// short a lifetime. (But sometimes it is more useful to report\n-    /// it as a more direct conflict between the execution of a\n-    /// `Drop::drop` with an aliasing borrow.)\n-    pub(super) fn report_borrowed_value_does_not_live_long_enough(\n-        &mut self,\n-        location: Location,\n-        borrow: &BorrowData<'tcx>,\n-        place_span: (&Place<'tcx>, Span),\n-        kind: Option<WriteKind>,\n-    ) {\n-        debug!(\n-            \"report_borrowed_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}\\\n-             )\",\n-            location, borrow, place_span, kind\n-        );\n-\n-        let drop_span = place_span.1;\n-        let scope_tree = self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n-            .last()\n-            .unwrap();\n-\n-        let borrow_spans = self.retrieve_borrow_spans(borrow);\n-        let borrow_span = borrow_spans.var_or_use();\n-\n-        let proper_span = match *root_place {\n-            Place::Base(PlaceBase::Local(local)) => self.mir.local_decls[local].source_info.span,\n-            _ => drop_span,\n-        };\n-\n-        if self.access_place_error_reported\n-            .contains(&(root_place.clone(), borrow_span))\n-        {\n-            debug!(\n-                \"suppressing access_place error when borrow doesn't live long enough for {:?}\",\n-                borrow_span\n-            );\n-            return;\n-        }\n-\n-        self.access_place_error_reported\n-            .insert((root_place.clone(), borrow_span));\n-\n-        if let StorageDeadOrDrop::Destructor(dropped_ty) =\n-            self.classify_drop_access_kind(&borrow.borrowed_place)\n-        {\n-            // If a borrow of path `B` conflicts with drop of `D` (and\n-            // we're not in the uninteresting case where `B` is a\n-            // prefix of `D`), then report this as a more interesting\n-            // destructor conflict.\n-            if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n-                self.report_borrow_conflicts_with_destructor(\n-                    location, borrow, place_span, kind, dropped_ty,\n-                );\n-                return;\n-            }\n-        }\n-\n-        let place_desc = self.describe_place(&borrow.borrowed_place);\n-\n-        let kind_place = kind.filter(|_| place_desc.is_some()).map(|k| (k, place_span.0));\n-        let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n-\n-        let err = match (place_desc, explanation) {\n-            (Some(_), _) if self.is_place_thread_local(root_place) => {\n-                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n-            }\n-            // If the outlives constraint comes from inside the closure,\n-            // for example:\n-            //\n-            // let x = 0;\n-            // let y = &x;\n-            // Box::new(|| y) as Box<Fn() -> &'static i32>\n-            //\n-            // then just use the normal error. The closure isn't escaping\n-            // and `move` will not help here.\n-            (\n-                Some(ref name),\n-                BorrowExplanation::MustBeValidFor {\n-                    category: category @ ConstraintCategory::Return,\n-                    from_closure: false,\n-                    ref region_name,\n-                    span,\n-                    ..\n-                },\n-            )\n-            | (\n-                Some(ref name),\n-                BorrowExplanation::MustBeValidFor {\n-                    category: category @ ConstraintCategory::CallArgument,\n-                    from_closure: false,\n-                    ref region_name,\n-                    span,\n-                    ..\n-                },\n-            ) if borrow_spans.for_closure() => self.report_escaping_closure_capture(\n-                borrow_spans.args_or_use(),\n-                borrow_span,\n-                region_name,\n-                category,\n-                span,\n-                &format!(\"`{}`\", name),\n-            ),\n-            (\n-                ref name,\n-                BorrowExplanation::MustBeValidFor {\n-                    category: ConstraintCategory::Assignment,\n-                    from_closure: false,\n-                    region_name: RegionName {\n-                        source: RegionNameSource::AnonRegionFromUpvar(upvar_span, ref upvar_name),\n-                        ..\n-                    },\n-                    span,\n-                    ..\n-                },\n-            ) => self.report_escaping_data(borrow_span, name, upvar_span, upvar_name, span),\n-            (Some(name), explanation) => self.report_local_value_does_not_live_long_enough(\n-                location,\n-                &name,\n-                &scope_tree,\n-                &borrow,\n-                drop_span,\n-                borrow_spans,\n-                explanation,\n-            ),\n-            (None, explanation) => self.report_temporary_value_does_not_live_long_enough(\n-                location,\n-                &scope_tree,\n-                &borrow,\n-                drop_span,\n-                borrow_spans,\n-                proper_span,\n-                explanation,\n-            ),\n-        };\n-\n-        err.buffer(&mut self.errors_buffer);\n-    }\n-\n-    fn report_local_value_does_not_live_long_enough(\n-        &mut self,\n-        location: Location,\n-        name: &str,\n-        scope_tree: &'tcx ScopeTree,\n-        borrow: &BorrowData<'tcx>,\n-        drop_span: Span,\n-        borrow_spans: UseSpans,\n-        explanation: BorrowExplanation,\n-    ) -> DiagnosticBuilder<'cx> {\n-        debug!(\n-            \"report_local_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n-             )\",\n-            location, name, scope_tree, borrow, drop_span, borrow_spans\n-        );\n-\n-        let borrow_span = borrow_spans.var_or_use();\n-        if let BorrowExplanation::MustBeValidFor {\n-            category,\n-            span,\n-            ref opt_place_desc,\n-            from_closure: false,\n-            ..\n-        } = explanation {\n-            if let Some(diag) = self.try_report_cannot_return_reference_to_local(\n-                borrow,\n-                borrow_span,\n-                span,\n-                category,\n-                opt_place_desc.as_ref(),\n-            ) {\n-                return diag;\n-            }\n-        }\n-\n-        let mut err = self.infcx.tcx.path_does_not_live_long_enough(\n-            borrow_span,\n-            &format!(\"`{}`\", name),\n-            Origin::Mir,\n-        );\n-\n-        if let Some(annotation) = self.annotate_argument_and_return_for_borrow(borrow) {\n-            let region_name = annotation.emit(self, &mut err);\n-\n-            err.span_label(\n-                borrow_span,\n-                format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n-            );\n-\n-            if let Some(fn_hir_id) = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id) {\n-                err.span_label(\n-                    drop_span,\n-                    format!(\n-                        \"...but `{}` will be dropped here, when the function `{}` returns\",\n-                        name,\n-                        self.infcx.tcx.hir().name_by_hir_id(fn_hir_id),\n-                    ),\n-                );\n-\n-                err.note(\n-                    \"functions cannot return a borrow to data owned within the function's scope, \\\n-                     functions can only return borrows to data passed as arguments\",\n-                );\n-                err.note(\n-                    \"to learn more, visit <https://doc.rust-lang.org/book/ch04-02-\\\n-                     references-and-borrowing.html#dangling-references>\",\n-                );\n-            } else {\n-                err.span_label(\n-                    drop_span,\n-                    format!(\"...but `{}` dropped here while still borrowed\", name),\n-                );\n-            }\n-\n-            if let BorrowExplanation::MustBeValidFor { .. } = explanation {\n-            } else {\n-                explanation.add_explanation_to_diagnostic(\n-                    self.infcx.tcx,\n-                    self.mir,\n-                    &mut err,\n-                    \"\",\n-                    None,\n-                );\n-            }\n-        } else {\n-            err.span_label(borrow_span, \"borrowed value does not live long enough\");\n-            err.span_label(\n-                drop_span,\n-                format!(\"`{}` dropped here while still borrowed\", name),\n-            );\n-\n-            let within = if borrow_spans.for_generator() {\n-                \" by generator\"\n-            } else {\n-                \"\"\n-            };\n-\n-            borrow_spans.args_span_label(\n-                &mut err,\n-                format!(\"value captured here{}\", within),\n-            );\n-\n-            explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n-        }\n-\n-        err\n-    }\n-\n-    fn report_borrow_conflicts_with_destructor(\n-        &mut self,\n-        location: Location,\n-        borrow: &BorrowData<'tcx>,\n-        (place, drop_span): (&Place<'tcx>, Span),\n-        kind: Option<WriteKind>,\n-        dropped_ty: Ty<'tcx>,\n-    ) {\n-        debug!(\n-            \"report_borrow_conflicts_with_destructor(\\\n-             {:?}, {:?}, ({:?}, {:?}), {:?}\\\n-             )\",\n-            location, borrow, place, drop_span, kind,\n-        );\n-\n-        let borrow_spans = self.retrieve_borrow_spans(borrow);\n-        let borrow_span = borrow_spans.var_or_use();\n-\n-        let mut err = self.infcx\n-            .tcx\n-            .cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n-\n-        let what_was_dropped = match self.describe_place(place) {\n-            Some(name) => format!(\"`{}`\", name.as_str()),\n-            None => String::from(\"temporary value\"),\n-        };\n-\n-        let label = match self.describe_place(&borrow.borrowed_place) {\n-            Some(borrowed) => format!(\n-                \"here, drop of {D} needs exclusive access to `{B}`, \\\n-                 because the type `{T}` implements the `Drop` trait\",\n-                D = what_was_dropped,\n-                T = dropped_ty,\n-                B = borrowed\n-            ),\n-            None => format!(\n-                \"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n-                D = what_was_dropped,\n-                T = dropped_ty\n-            ),\n-        };\n-        err.span_label(drop_span, label);\n-\n-        // Only give this note and suggestion if they could be relevant.\n-        let explanation =\n-            self.explain_why_borrow_contains_point(location, borrow, kind.map(|k| (k, place)));\n-        match explanation {\n-            BorrowExplanation::UsedLater { .. }\n-            | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n-                err.note(\"consider using a `let` binding to create a longer lived value\");\n-            }\n-            _ => {}\n-        }\n-\n-        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n-\n-        err.buffer(&mut self.errors_buffer);\n-    }\n-\n-    fn report_thread_local_value_does_not_live_long_enough(\n-        &mut self,\n-        drop_span: Span,\n-        borrow_span: Span,\n-    ) -> DiagnosticBuilder<'cx> {\n-        debug!(\n-            \"report_thread_local_value_does_not_live_long_enough(\\\n-             {:?}, {:?}\\\n-             )\",\n-            drop_span, borrow_span\n-        );\n-\n-        let mut err = self.infcx\n-            .tcx\n-            .thread_local_value_does_not_live_long_enough(borrow_span, Origin::Mir);\n-\n-        err.span_label(\n-            borrow_span,\n-            \"thread-local variables cannot be borrowed beyond the end of the function\",\n-        );\n-        err.span_label(drop_span, \"end of enclosing function is here\");\n-\n-        err\n-    }\n-\n-    fn report_temporary_value_does_not_live_long_enough(\n-        &mut self,\n-        location: Location,\n-        scope_tree: &'tcx ScopeTree,\n-        borrow: &BorrowData<'tcx>,\n-        drop_span: Span,\n-        borrow_spans: UseSpans,\n-        proper_span: Span,\n-        explanation: BorrowExplanation,\n-    ) -> DiagnosticBuilder<'cx> {\n-        debug!(\n-            \"report_temporary_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}, {:?}\\\n-             )\",\n-            location, scope_tree, borrow, drop_span, proper_span\n-        );\n-\n-        if let BorrowExplanation::MustBeValidFor {\n-            category,\n-            span,\n-            from_closure: false,\n-            ..\n-        } = explanation {\n-            if let Some(diag) = self.try_report_cannot_return_reference_to_local(\n-                borrow,\n-                proper_span,\n-                span,\n-                category,\n-                None,\n-            ) {\n-                return diag;\n-            }\n-        }\n-\n-        let tcx = self.infcx.tcx;\n-        let mut err = tcx.temporary_value_borrowed_for_too_long(proper_span, Origin::Mir);\n-        err.span_label(\n-            proper_span,\n-            \"creates a temporary which is freed while still in use\",\n-        );\n-        err.span_label(\n-            drop_span,\n-            \"temporary value is freed at the end of this statement\",\n-        );\n-\n-        match explanation {\n-            BorrowExplanation::UsedLater(..)\n-            | BorrowExplanation::UsedLaterInLoop(..)\n-            | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n-                // Only give this note and suggestion if it could be relevant.\n-                err.note(\"consider using a `let` binding to create a longer lived value\");\n-            }\n-            _ => {}\n-        }\n-        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n-\n-        let within = if borrow_spans.for_generator() {\n-            \" by generator\"\n-        } else {\n-            \"\"\n-        };\n-\n-        borrow_spans.args_span_label(\n-            &mut err,\n-            format!(\"value captured here{}\", within),\n-        );\n-\n-        err\n-    }\n-\n-    fn try_report_cannot_return_reference_to_local(\n-        &self,\n-        borrow: &BorrowData<'tcx>,\n-        borrow_span: Span,\n-        return_span: Span,\n-        category: ConstraintCategory,\n-        opt_place_desc: Option<&String>,\n-    ) -> Option<DiagnosticBuilder<'cx>> {\n-        let tcx = self.infcx.tcx;\n-\n-        let return_kind = match category {\n-            ConstraintCategory::Return => \"return\",\n-            ConstraintCategory::Yield => \"yield\",\n-            _ => return None,\n-        };\n-\n-        // FIXME use a better heuristic than Spans\n-        let reference_desc = if return_span == self.mir.source_info(borrow.reserve_location).span {\n-            \"reference to\"\n-        } else {\n-            \"value referencing\"\n-        };\n-\n-        let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n-            let local_kind = match borrow.borrowed_place {\n-                Place::Base(PlaceBase::Local(local)) => {\n-                    match self.mir.local_kind(local) {\n-                        LocalKind::ReturnPointer\n-                        | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n-                        LocalKind::Var => \"local variable \",\n-                        LocalKind::Arg\n-                        if !self.upvars.is_empty()\n-                            && local == Local::new(1) => {\n-                            \"variable captured by `move` \"\n-                        }\n-                        LocalKind::Arg => {\n-                            \"function parameter \"\n-                        }\n-                    }\n-                }\n-                _ => \"local data \",\n-            };\n-            (\n-                format!(\"{}`{}`\", local_kind, place_desc),\n-                format!(\"`{}` is borrowed here\", place_desc),\n-            )\n-        } else {\n-            let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n-                .last()\n-                .unwrap();\n-            let local = if let Place::Base(PlaceBase::Local(local)) = *root_place {\n-                local\n-            } else {\n-                bug!(\"try_report_cannot_return_reference_to_local: not a local\")\n-            };\n-            match self.mir.local_kind(local) {\n-                LocalKind::ReturnPointer | LocalKind::Temp => {\n-                    (\n-                        \"temporary value\".to_string(),\n-                        \"temporary value created here\".to_string(),\n-                    )\n-                }\n-                LocalKind::Arg => {\n-                    (\n-                        \"function parameter\".to_string(),\n-                        \"function parameter borrowed here\".to_string(),\n-                    )\n-                },\n-                LocalKind::Var => bug!(\"local variable without a name\"),\n-            }\n-        };\n-\n-        let mut err = tcx.cannot_return_reference_to_local(\n-            return_span,\n-            return_kind,\n-            reference_desc,\n-            &place_desc,\n-            Origin::Mir,\n-        );\n-\n-        if return_span != borrow_span {\n-            err.span_label(borrow_span, note);\n-        }\n-\n-        Some(err)\n-    }\n-\n-    fn report_escaping_closure_capture(\n-        &mut self,\n-        args_span: Span,\n-        var_span: Span,\n-        fr_name: &RegionName,\n-        category: ConstraintCategory,\n-        constraint_span: Span,\n-        captured_var: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n-        let tcx = self.infcx.tcx;\n-\n-        let mut err = tcx.cannot_capture_in_long_lived_closure(\n-            args_span,\n-            captured_var,\n-            var_span,\n-          Origin::Mir,\n-        );\n-\n-        let suggestion = match tcx.sess.source_map().span_to_snippet(args_span) {\n-            Ok(string) => format!(\"move {}\", string),\n-            Err(_) => \"move |<args>| <body>\".to_string()\n-        };\n-\n-        err.span_suggestion(\n-            args_span,\n-            &format!(\"to force the closure to take ownership of {} (and any \\\n-                      other referenced variables), use the `move` keyword\",\n-                      captured_var),\n-            suggestion,\n-            Applicability::MachineApplicable,\n-        );\n-\n-        match category {\n-            ConstraintCategory::Return => {\n-                err.span_note(constraint_span, \"closure is returned here\");\n-            }\n-            ConstraintCategory::CallArgument => {\n-                fr_name.highlight_region_name(&mut err);\n-                err.span_note(\n-                    constraint_span,\n-                    &format!(\"function requires argument type to outlive `{}`\", fr_name),\n-                );\n-            }\n-            _ => bug!(\"report_escaping_closure_capture called with unexpected constraint \\\n-                       category: `{:?}`\", category),\n-        }\n-        err\n-    }\n-\n-    fn report_escaping_data(\n-        &mut self,\n-        borrow_span: Span,\n-        name: &Option<String>,\n-        upvar_span: Span,\n-        upvar_name: &str,\n-        escape_span: Span,\n-    ) -> DiagnosticBuilder<'cx> {\n-        let tcx = self.infcx.tcx;\n-\n-        let escapes_from = if tcx.is_closure(self.mir_def_id) {\n-            let tables = tcx.typeck_tables_of(self.mir_def_id);\n-            let mir_hir_id = tcx.hir().def_index_to_hir_id(self.mir_def_id.index);\n-            match tables.node_type(mir_hir_id).sty {\n-                ty::Closure(..) => \"closure\",\n-                ty::Generator(..) => \"generator\",\n-                _ => bug!(\"Closure body doesn't have a closure or generator type\"),\n-            }\n-        } else {\n-            \"function\"\n-        };\n-\n-        let mut err = tcx.borrowed_data_escapes_closure(escape_span, escapes_from, Origin::Mir);\n-\n-        err.span_label(\n-            upvar_span,\n-            format!(\n-                \"`{}` is declared here, outside of the {} body\",\n-                upvar_name, escapes_from\n-            ),\n-        );\n-\n-        err.span_label(\n-            borrow_span,\n-            format!(\n-                \"borrow is only valid in the {} body\",\n-                escapes_from\n-            ),\n-        );\n-\n-        if let Some(name) = name {\n-            err.span_label(\n-                escape_span,\n-                format!(\"reference to `{}` escapes the {} body here\", name, escapes_from),\n-            );\n-        } else {\n-            err.span_label(\n-                escape_span,\n-                format!(\"reference escapes the {} body here\", escapes_from),\n-            );\n-        }\n-\n-        err\n-    }\n-\n-    fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n-        let mir = self.mir;\n-\n-        let mut stack = Vec::new();\n-        stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n-            let is_back_edge = location.dominates(predecessor, &self.dominators);\n-            (predecessor, is_back_edge)\n-        }));\n-\n-        let mut visited = FxHashSet::default();\n-        let mut result = vec![];\n-\n-        'dfs: while let Some((location, is_back_edge)) = stack.pop() {\n-            debug!(\n-                \"report_use_of_moved_or_uninitialized: (current_location={:?}, back_edge={})\",\n-                location, is_back_edge\n-            );\n-\n-            if !visited.insert(location) {\n-                continue;\n-            }\n-\n-            // check for moves\n-            let stmt_kind = mir[location.block]\n-                .statements\n-                .get(location.statement_index)\n-                .map(|s| &s.kind);\n-            if let Some(StatementKind::StorageDead(..)) = stmt_kind {\n-                // this analysis only tries to find moves explicitly\n-                // written by the user, so we ignore the move-outs\n-                // created by `StorageDead` and at the beginning\n-                // of a function.\n-            } else {\n-                // If we are found a use of a.b.c which was in error, then we want to look for\n-                // moves not only of a.b.c but also a.b and a.\n-                //\n-                // Note that the moves data already includes \"parent\" paths, so we don't have to\n-                // worry about the other case: that is, if there is a move of a.b.c, it is already\n-                // marked as a move of a.b and a as well, so we will generate the correct errors\n-                // there.\n-                let mut mpis = vec![mpi];\n-                let move_paths = &self.move_data.move_paths;\n-                mpis.extend(move_paths[mpi].parents(move_paths));\n-\n-                for moi in &self.move_data.loc_map[location] {\n-                    debug!(\"report_use_of_moved_or_uninitialized: moi={:?}\", moi);\n-                    if mpis.contains(&self.move_data.moves[*moi].path) {\n-                        debug!(\"report_use_of_moved_or_uninitialized: found\");\n-                        result.push(MoveSite {\n-                            moi: *moi,\n-                            traversed_back_edge: is_back_edge,\n-                        });\n-\n-                        // Strictly speaking, we could continue our DFS here. There may be\n-                        // other moves that can reach the point of error. But it is kind of\n-                        // confusing to highlight them.\n-                        //\n-                        // Example:\n-                        //\n-                        // ```\n-                        // let a = vec![];\n-                        // let b = a;\n-                        // let c = a;\n-                        // drop(a); // <-- current point of error\n-                        // ```\n-                        //\n-                        // Because we stop the DFS here, we only highlight `let c = a`,\n-                        // and not `let b = a`. We will of course also report an error at\n-                        // `let c = a` which highlights `let b = a` as the move.\n-                        continue 'dfs;\n-                    }\n-                }\n-            }\n-\n-            // check for inits\n-            let mut any_match = false;\n-            drop_flag_effects::for_location_inits(\n-                self.infcx.tcx,\n-                self.mir,\n-                self.move_data,\n-                location,\n-                |m| {\n-                    if m == mpi {\n-                        any_match = true;\n-                    }\n-                },\n-            );\n-            if any_match {\n-                continue 'dfs;\n-            }\n-\n-            stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n-                let back_edge = location.dominates(predecessor, &self.dominators);\n-                (predecessor, is_back_edge || back_edge)\n-            }));\n-        }\n-\n-        result\n-    }\n-\n-    pub(super) fn report_illegal_mutation_of_borrowed(\n-        &mut self,\n-        location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n-        loan: &BorrowData<'tcx>,\n-    ) {\n-        let loan_spans = self.retrieve_borrow_spans(loan);\n-        let loan_span = loan_spans.args_or_use();\n-\n-        let tcx = self.infcx.tcx;\n-        if loan.kind == BorrowKind::Shallow {\n-            let mut err = tcx.cannot_mutate_in_match_guard(\n-                span,\n-                loan_span,\n-                &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n-                \"assign\",\n-                Origin::Mir,\n-            );\n-            loan_spans.var_span_label(\n-                &mut err,\n-                format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-            );\n-\n-            err.buffer(&mut self.errors_buffer);\n-\n-            return;\n-        }\n-\n-        let mut err = tcx.cannot_assign_to_borrowed(\n-            span,\n-            loan_span,\n-            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n-            Origin::Mir,\n-        );\n-\n-        loan_spans.var_span_label(\n-            &mut err,\n-            format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-        );\n-\n-        self.explain_why_borrow_contains_point(location, loan, None)\n-            .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n-\n-        err.buffer(&mut self.errors_buffer);\n-    }\n-\n-    /// Reports an illegal reassignment; for example, an assignment to\n-    /// (part of) a non-`mut` local that occurs potentially after that\n-    /// local has already been initialized. `place` is the path being\n-    /// assigned; `err_place` is a place providing a reason why\n-    /// `place` is not mutable (e.g., the non-`mut` local `x` in an\n-    /// assignment to `x.f`).\n-    pub(super) fn report_illegal_reassignment(\n-        &mut self,\n-        _location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n-        assigned_span: Span,\n-        err_place: &Place<'tcx>,\n-    ) {\n-        let (from_arg, local_decl) = if let Place::Base(PlaceBase::Local(local)) = *err_place {\n-            if let LocalKind::Arg = self.mir.local_kind(local) {\n-                (true, Some(&self.mir.local_decls[local]))\n-            } else {\n-                (false, Some(&self.mir.local_decls[local]))\n-            }\n-        } else {\n-            (false, None)\n-        };\n-\n-        // If root local is initialized immediately (everything apart from let\n-        // PATTERN;) then make the error refer to that local, rather than the\n-        // place being assigned later.\n-        let (place_description, assigned_span) = match local_decl {\n-            Some(LocalDecl {\n-                is_user_variable: Some(ClearCrossCrate::Clear),\n-                ..\n-            })\n-            | Some(LocalDecl {\n-                is_user_variable:\n-                    Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                        opt_match_place: None,\n-                        ..\n-                    }))),\n-                ..\n-            })\n-            | Some(LocalDecl {\n-                is_user_variable: None,\n-                ..\n-            })\n-            | None => (self.describe_place(place), assigned_span),\n-            Some(decl) => (self.describe_place(err_place), decl.source_info.span),\n-        };\n-\n-        let mut err = self.infcx.tcx.cannot_reassign_immutable(\n-            span,\n-            place_description.as_ref().map(AsRef::as_ref).unwrap_or(\"_\"),\n-            from_arg,\n-            Origin::Mir,\n-        );\n-        let msg = if from_arg {\n-            \"cannot assign to immutable argument\"\n-        } else {\n-            \"cannot assign twice to immutable variable\"\n-        };\n-        if span != assigned_span {\n-            if !from_arg {\n-                let value_msg = match place_description {\n-                    Some(name) => format!(\"`{}`\", name),\n-                    None => \"value\".to_owned(),\n-                };\n-                err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n-            }\n-        }\n-        if let Some(decl) = local_decl {\n-            if let Some(name) = decl.name {\n-                if decl.can_be_made_mutable() {\n-                    err.span_suggestion(\n-                        decl.source_info.span,\n-                        \"make this binding mutable\",\n-                        format!(\"mut {}\", name),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-        err.span_label(span, msg);\n-        err.buffer(&mut self.errors_buffer);\n-    }\n-}\n-\n-pub(super) struct IncludingDowncast(bool);\n-\n-/// Which case a StorageDeadOrDrop is for.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum StorageDeadOrDrop<'tcx> {\n-    LocalStorageDead,\n-    BoxedStorageDead,\n-    Destructor(Ty<'tcx>),\n-}\n+pub(super) struct IncludingDowncast(pub(super) bool);\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n@@ -1866,507 +383,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             false\n         }\n     }\n-\n-    fn classify_drop_access_kind(&self, place: &Place<'tcx>) -> StorageDeadOrDrop<'tcx> {\n-        let tcx = self.infcx.tcx;\n-        match place {\n-            Place::Base(PlaceBase::Local(_)) |\n-            Place::Base(PlaceBase::Static(_)) => {\n-                StorageDeadOrDrop::LocalStorageDead\n-            }\n-            Place::Projection(box PlaceProjection { base, elem }) => {\n-                let base_access = self.classify_drop_access_kind(base);\n-                match elem {\n-                    ProjectionElem::Deref => match base_access {\n-                        StorageDeadOrDrop::LocalStorageDead\n-                        | StorageDeadOrDrop::BoxedStorageDead => {\n-                            assert!(\n-                                base.ty(self.mir, tcx).ty.is_box(),\n-                                \"Drop of value behind a reference or raw pointer\"\n-                            );\n-                            StorageDeadOrDrop::BoxedStorageDead\n-                        }\n-                        StorageDeadOrDrop::Destructor(_) => base_access,\n-                    },\n-                    ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = base.ty(self.mir, tcx).ty;\n-                        match base_ty.sty {\n-                            ty::Adt(def, _) if def.has_dtor(tcx) => {\n-                                // Report the outermost adt with a destructor\n-                                match base_access {\n-                                    StorageDeadOrDrop::Destructor(_) => base_access,\n-                                    StorageDeadOrDrop::LocalStorageDead\n-                                    | StorageDeadOrDrop::BoxedStorageDead => {\n-                                        StorageDeadOrDrop::Destructor(base_ty)\n-                                    }\n-                                }\n-                            }\n-                            _ => base_access,\n-                        }\n-                    }\n-\n-                    ProjectionElem::ConstantIndex { .. }\n-                    | ProjectionElem::Subslice { .. }\n-                    | ProjectionElem::Index(_) => base_access,\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Annotate argument and return type of function and closure with (synthesized) lifetime for\n-    /// borrow of local value that does not live long enough.\n-    fn annotate_argument_and_return_for_borrow(\n-        &self,\n-        borrow: &BorrowData<'tcx>,\n-    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n-        // Define a fallback for when we can't match a closure.\n-        let fallback = || {\n-            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n-            if is_closure {\n-                None\n-            } else {\n-                let ty = self.infcx.tcx.type_of(self.mir_def_id);\n-                match ty.sty {\n-                    ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n-                        self.mir_def_id,\n-                        self.infcx.tcx.fn_sig(self.mir_def_id),\n-                    ),\n-                    _ => None,\n-                }\n-            }\n-        };\n-\n-        // In order to determine whether we need to annotate, we need to check whether the reserve\n-        // place was an assignment into a temporary.\n-        //\n-        // If it was, we check whether or not that temporary is eventually assigned into the return\n-        // place. If it was, we can add annotations about the function's return type and arguments\n-        // and it'll make sense.\n-        let location = borrow.reserve_location;\n-        debug!(\n-            \"annotate_argument_and_return_for_borrow: location={:?}\",\n-            location\n-        );\n-        if let Some(&Statement { kind: StatementKind::Assign(ref reservation, _), ..})\n-             = &self.mir[location.block].statements.get(location.statement_index)\n-        {\n-            debug!(\n-                \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n-                reservation\n-            );\n-            // Check that the initial assignment of the reserve location is into a temporary.\n-            let mut target = *match reservation {\n-                Place::Base(PlaceBase::Local(local))\n-                    if self.mir.local_kind(*local) == LocalKind::Temp => local,\n-                _ => return None,\n-            };\n-\n-            // Next, look through the rest of the block, checking if we are assigning the\n-            // `target` (that is, the place that contains our borrow) to anything.\n-            let mut annotated_closure = None;\n-            for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-                debug!(\n-                    \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n-                    target, stmt\n-                );\n-                if let StatementKind::Assign(\n-                    Place::Base(PlaceBase::Local(assigned_to)),\n-                    box rvalue\n-                ) = &stmt.kind {\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n-                         rvalue={:?}\",\n-                        assigned_to, rvalue\n-                    );\n-                    // Check if our `target` was captured by a closure.\n-                    if let Rvalue::Aggregate(\n-                        box AggregateKind::Closure(def_id, substs),\n-                        operands,\n-                    ) = rvalue\n-                    {\n-                        for operand in operands {\n-                            let assigned_from = match operand {\n-                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                    assigned_from\n-                                }\n-                                _ => continue,\n-                            };\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                                assigned_from\n-                            );\n-\n-                            // Find the local from the operand.\n-                            let assigned_from_local = match assigned_from.local() {\n-                                Some(local) => local,\n-                                None => continue,\n-                            };\n-\n-                            if assigned_from_local != target {\n-                                continue;\n-                            }\n-\n-                            // If a closure captured our `target` and then assigned\n-                            // into a place then we should annotate the closure in\n-                            // case it ends up being assigned into the return place.\n-                            annotated_closure = self.annotate_fn_sig(\n-                                *def_id,\n-                                self.infcx.closure_sig(*def_id, *substs),\n-                            );\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: \\\n-                                 annotated_closure={:?} assigned_from_local={:?} \\\n-                                 assigned_to={:?}\",\n-                                annotated_closure, assigned_from_local, assigned_to\n-                            );\n-\n-                            if *assigned_to == mir::RETURN_PLACE {\n-                                // If it was assigned directly into the return place, then\n-                                // return now.\n-                                return annotated_closure;\n-                            } else {\n-                                // Otherwise, update the target.\n-                                target = *assigned_to;\n-                            }\n-                        }\n-\n-                        // If none of our closure's operands matched, then skip to the next\n-                        // statement.\n-                        continue;\n-                    }\n-\n-                    // Otherwise, look at other types of assignment.\n-                    let assigned_from = match rvalue {\n-                        Rvalue::Ref(_, _, assigned_from) => assigned_from,\n-                        Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                assigned_from\n-                            }\n-                            _ => continue,\n-                        },\n-                        _ => continue,\n-                    };\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from={:?}\",\n-                        assigned_from,\n-                    );\n-\n-                    // Find the local from the rvalue.\n-                    let assigned_from_local = match assigned_from.local() {\n-                        Some(local) => local,\n-                        None => continue,\n-                    };\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from_local={:?}\",\n-                        assigned_from_local,\n-                    );\n-\n-                    // Check if our local matches the target - if so, we've assigned our\n-                    // borrow to a new place.\n-                    if assigned_from_local != target {\n-                        continue;\n-                    }\n-\n-                    // If we assigned our `target` into a new place, then we should\n-                    // check if it was the return place.\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from_local={:?} assigned_to={:?}\",\n-                        assigned_from_local, assigned_to\n-                    );\n-                    if *assigned_to == mir::RETURN_PLACE {\n-                        // If it was then return the annotated closure if there was one,\n-                        // else, annotate this function.\n-                        return annotated_closure.or_else(fallback);\n-                    }\n-\n-                    // If we didn't assign into the return place, then we just update\n-                    // the target.\n-                    target = *assigned_to;\n-                }\n-            }\n-\n-            // Check the terminator if we didn't find anything in the statements.\n-            let terminator = &self.mir[location.block].terminator();\n-            debug!(\n-                \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n-                target, terminator\n-            );\n-            if let TerminatorKind::Call {\n-                destination: Some((Place::Base(PlaceBase::Local(assigned_to)), _)),\n-                args,\n-                ..\n-            } = &terminator.kind\n-            {\n-                debug!(\n-                    \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n-                    assigned_to, args\n-                );\n-                for operand in args {\n-                    let assigned_from = match operand {\n-                        Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                            assigned_from\n-                        }\n-                        _ => continue,\n-                    };\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                        assigned_from,\n-                    );\n-\n-                    if let Some(assigned_from_local) = assigned_from.local() {\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n-                            assigned_from_local,\n-                        );\n-\n-                        if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n-                            return annotated_closure.or_else(fallback);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // If we haven't found an assignment into the return place, then we need not add\n-        // any annotations.\n-        debug!(\"annotate_argument_and_return_for_borrow: none found\");\n-        None\n-    }\n-\n-    /// Annotate the first argument and return type of a function signature if they are\n-    /// references.\n-    fn annotate_fn_sig(\n-        &self,\n-        did: DefId,\n-        sig: ty::PolyFnSig<'tcx>,\n-    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n-        debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n-        let is_closure = self.infcx.tcx.is_closure(did);\n-        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did)?;\n-        let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(fn_hir_id)?;\n-\n-        // We need to work out which arguments to highlight. We do this by looking\n-        // at the return type, where there are three cases:\n-        //\n-        // 1. If there are named arguments, then we should highlight the return type and\n-        //    highlight any of the arguments that are also references with that lifetime.\n-        //    If there are no arguments that have the same lifetime as the return type,\n-        //    then don't highlight anything.\n-        // 2. The return type is a reference with an anonymous lifetime. If this is\n-        //    the case, then we can take advantage of (and teach) the lifetime elision\n-        //    rules.\n-        //\n-        //    We know that an error is being reported. So the arguments and return type\n-        //    must satisfy the elision rules. Therefore, if there is a single argument\n-        //    then that means the return type and first (and only) argument have the same\n-        //    lifetime and the borrow isn't meeting that, we can highlight the argument\n-        //    and return type.\n-        //\n-        //    If there are multiple arguments then the first argument must be self (else\n-        //    it would not satisfy the elision rules), so we can highlight self and the\n-        //    return type.\n-        // 3. The return type is not a reference. In this case, we don't highlight\n-        //    anything.\n-        let return_ty = sig.output();\n-        match return_ty.skip_binder().sty {\n-            ty::Ref(return_region, _, _) if return_region.has_name() && !is_closure => {\n-                // This is case 1 from above, return type is a named reference so we need to\n-                // search for relevant arguments.\n-                let mut arguments = Vec::new();\n-                for (index, argument) in sig.inputs().skip_binder().iter().enumerate() {\n-                    if let ty::Ref(argument_region, _, _) = argument.sty {\n-                        if argument_region == return_region {\n-                            // Need to use the `rustc::ty` types to compare against the\n-                            // `return_region`. Then use the `rustc::hir` type to get only\n-                            // the lifetime span.\n-                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].node {\n-                                // With access to the lifetime, we can get\n-                                // the span of it.\n-                                arguments.push((*argument, lifetime.span));\n-                            } else {\n-                                bug!(\"ty type is a ref but hir type is not\");\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // We need to have arguments. This shouldn't happen, but it's worth checking.\n-                if arguments.is_empty() {\n-                    return None;\n-                }\n-\n-                // We use a mix of the HIR and the Ty types to get information\n-                // as the HIR doesn't have full types for closure arguments.\n-                let return_ty = *sig.output().skip_binder();\n-                let mut return_span = fn_decl.output.span();\n-                if let hir::FunctionRetTy::Return(ty) = fn_decl.output {\n-                    if let hir::TyKind::Rptr(lifetime, _) = ty.into_inner().node {\n-                        return_span = lifetime.span;\n-                    }\n-                }\n-\n-                Some(AnnotatedBorrowFnSignature::NamedFunction {\n-                    arguments,\n-                    return_ty,\n-                    return_span,\n-                })\n-            }\n-            ty::Ref(_, _, _) if is_closure => {\n-                // This is case 2 from above but only for closures, return type is anonymous\n-                // reference so we select\n-                // the first argument.\n-                let argument_span = fn_decl.inputs.first()?.span;\n-                let argument_ty = sig.inputs().skip_binder().first()?;\n-\n-                // Closure arguments are wrapped in a tuple, so we need to get the first\n-                // from that.\n-                if let ty::Tuple(elems) = argument_ty.sty {\n-                    let argument_ty = elems.first()?.expect_ty();\n-                    if let ty::Ref(_, _, _) = argument_ty.sty {\n-                        return Some(AnnotatedBorrowFnSignature::Closure {\n-                            argument_ty,\n-                            argument_span,\n-                        });\n-                    }\n-                }\n-\n-                None\n-            }\n-            ty::Ref(_, _, _) => {\n-                // This is also case 2 from above but for functions, return type is still an\n-                // anonymous reference so we select the first argument.\n-                let argument_span = fn_decl.inputs.first()?.span;\n-                let argument_ty = sig.inputs().skip_binder().first()?;\n-\n-                let return_span = fn_decl.output.span();\n-                let return_ty = *sig.output().skip_binder();\n-\n-                // We expect the first argument to be a reference.\n-                match argument_ty.sty {\n-                    ty::Ref(_, _, _) => {}\n-                    _ => return None,\n-                }\n-\n-                Some(AnnotatedBorrowFnSignature::AnonymousFunction {\n-                    argument_ty,\n-                    argument_span,\n-                    return_ty,\n-                    return_span,\n-                })\n-            }\n-            _ => {\n-                // This is case 3 from above, return type is not a reference so don't highlight\n-                // anything.\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-enum AnnotatedBorrowFnSignature<'tcx> {\n-    NamedFunction {\n-        arguments: Vec<(Ty<'tcx>, Span)>,\n-        return_ty: Ty<'tcx>,\n-        return_span: Span,\n-    },\n-    AnonymousFunction {\n-        argument_ty: Ty<'tcx>,\n-        argument_span: Span,\n-        return_ty: Ty<'tcx>,\n-        return_span: Span,\n-    },\n-    Closure {\n-        argument_ty: Ty<'tcx>,\n-        argument_span: Span,\n-    },\n-}\n-\n-impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n-    /// Annotate the provided diagnostic with information about borrow from the fn signature that\n-    /// helps explain.\n-    fn emit(\n-        &self,\n-        cx: &mut MirBorrowckCtxt<'_, '_, 'tcx>,\n-        diag: &mut DiagnosticBuilder<'_>,\n-    ) -> String {\n-        match self {\n-            AnnotatedBorrowFnSignature::Closure {\n-                argument_ty,\n-                argument_span,\n-            } => {\n-                diag.span_label(\n-                    *argument_span,\n-                    format!(\"has type `{}`\", cx.get_name_for_ty(argument_ty, 0)),\n-                );\n-\n-                cx.get_region_name_for_ty(argument_ty, 0)\n-            }\n-            AnnotatedBorrowFnSignature::AnonymousFunction {\n-                argument_ty,\n-                argument_span,\n-                return_ty,\n-                return_span,\n-            } => {\n-                let argument_ty_name = cx.get_name_for_ty(argument_ty, 0);\n-                diag.span_label(*argument_span, format!(\"has type `{}`\", argument_ty_name));\n-\n-                let return_ty_name = cx.get_name_for_ty(return_ty, 0);\n-                let types_equal = return_ty_name == argument_ty_name;\n-                diag.span_label(\n-                    *return_span,\n-                    format!(\n-                        \"{}has type `{}`\",\n-                        if types_equal { \"also \" } else { \"\" },\n-                        return_ty_name,\n-                    ),\n-                );\n-\n-                diag.note(\n-                    \"argument and return type have the same lifetime due to lifetime elision rules\",\n-                );\n-                diag.note(\n-                    \"to learn more, visit <https://doc.rust-lang.org/book/ch10-03-\\\n-                     lifetime-syntax.html#lifetime-elision>\",\n-                );\n-\n-                cx.get_region_name_for_ty(return_ty, 0)\n-            }\n-            AnnotatedBorrowFnSignature::NamedFunction {\n-                arguments,\n-                return_ty,\n-                return_span,\n-            } => {\n-                // Region of return type and arguments checked to be the same earlier.\n-                let region_name = cx.get_region_name_for_ty(return_ty, 0);\n-                for (_, argument_span) in arguments {\n-                    diag.span_label(*argument_span, format!(\"has lifetime `{}`\", region_name));\n-                }\n-\n-                diag.span_label(\n-                    *return_span,\n-                    format!(\"also has lifetime `{}`\", region_name,),\n-                );\n-\n-                diag.help(&format!(\n-                    \"use data from the highlighted arguments which match the `{}` lifetime of \\\n-                     the return type\",\n-                    region_name,\n-                ));\n-\n-                region_name\n-            }\n-        }\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Return the name of the provided `Ty` (that must be a reference) with a synthesized lifetime\n     /// name where required.\n-    fn get_name_for_ty(&self, ty: Ty<'tcx>, counter: usize) -> String {\n+    pub(super) fn get_name_for_ty(&self, ty: Ty<'tcx>, counter: usize) -> String {\n         let mut s = String::new();\n         let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n \n@@ -2389,7 +411,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Returns the name of the provided `Ty` (that must be a reference)'s region with a\n     /// synthesized lifetime name where required.\n-    fn get_region_name_for_ty(&self, ty: Ty<'tcx>, counter: usize) -> String {\n+    pub(super) fn get_region_name_for_ty(&self, ty: Ty<'tcx>, counter: usize) -> String {\n         let mut s = String::new();\n         let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n \n@@ -2469,23 +491,23 @@ impl UseSpans {\n     }\n \n     /// Returns `false` if this place is not used in a closure.\n-    fn for_closure(&self) -> bool {\n+    pub(super) fn for_closure(&self) -> bool {\n         match *self {\n             UseSpans::ClosureUse { is_generator, .. } => !is_generator,\n             _ => false,\n         }\n     }\n \n     /// Returns `false` if this place is not used in a generator.\n-    fn for_generator(&self) -> bool {\n+    pub(super) fn for_generator(&self) -> bool {\n         match *self {\n             UseSpans::ClosureUse { is_generator, .. } => is_generator,\n             _ => false,\n         }\n     }\n \n     /// Describe the span associated with a use of a place.\n-    fn describe(&self) -> String {\n+    pub(super) fn describe(&self) -> String {\n         match *self {\n             UseSpans::ClosureUse { is_generator, .. } => if is_generator {\n                 \" in generator\".to_string()"}, {"sha": "eb8e5fa5e25a02f15e054426b38c42bd53e65c66", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df5d07217271401217fce2d79f3ec75fa0e2b207/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df5d07217271401217fce2d79f3ec75fa0e2b207/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=df5d07217271401217fce2d79f3ec75fa0e2b207", "patch": "@@ -54,6 +54,7 @@ crate mod borrow_set;\n mod error_reporting;\n mod flows;\n mod location;\n+mod conflict_errors;\n mod move_errors;\n mod mutability_errors;\n mod path_utils;"}]}