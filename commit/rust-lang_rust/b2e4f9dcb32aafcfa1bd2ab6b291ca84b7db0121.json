{"sha": "b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121", "node_id": "C_kwDOAAsO6NoAKGIyZTRmOWRjYjMyYWFmY2ZhMWJkMmFiNmIyOTFjYTg0YjdkYjAxMjE", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-09-06T09:49:34Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-09-06T18:29:58Z"}, "message": "Open a BCrypt algorithm handle", "tree": {"sha": "02e78006e210645c656146691963934aa6bb059b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02e78006e210645c656146691963934aa6bb059b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmMXkacACgkQcTRy8vRW\nJ94afw/7BLmP7R15+2XQNx/crvZGEG7AEdGVWTmFHNg4gKYsUo7G5qWPP3xdaSRS\nGXbqmIHyI44iM8+AXS6s+YUF9jMn5s6IfEtNQPL6xds5KRLMwdjfOMJFq5NVx1pU\nRQ/b7qhG+CSyJz4GVO/HoZ3Jn3RySk1c4hx16vvGt1t7Hxr5mTU/ylOtdwIsN5PN\nW2cf+AMZdQjOR7dQCIuFAT3Jsf2Ttq5uL9REisjMHrSPTSvUESGAbFoDshyryeog\nXoS9YssV2QPKaSpc03YiIUH+Zt6zKnKPOTOc8oniPJLdQk3qZjnyAOZfGpJqqZAk\noXwomp3YoKkbDqrMb622Nhtce6yp6Im4tfUR5N3whKeUnd6Ngm8lY6lXmN6+uxfK\nbuHTt1097UdKqvERzLij/sB4M2c0pahGWgYimtIJzG+HFz2DHiw6x+KmuhmXYiiy\n6IU6C6bVUXgR0TI0d5OqEQRkAYhlDYh3ZDLXsgcdeDCTeLuSVqR+OmyMVIaUPfFn\n1raM7/ORTrBn5aVI/BS7l3xE5fL7wZWuSWjW6D3rxMhs9/mKLLnvDR5rdKL55EEG\nbemcS47GYReCVSjHXHFq05wMp3jpf6jSxh8hM3XIEM5Vz3EbnZy48cRxZDG0Aztq\nteFziOZnlF7jNsFw5+ZFoe96MMwP9rhz+QxP3OoQ9d1IxnPnWMY=\n=dHF9\n-----END PGP SIGNATURE-----", "payload": "tree 02e78006e210645c656146691963934aa6bb059b\nparent 098cf8802271eacdc463fa66c35da377926d4c4e\nauthor Chris Denton <christophersdenton@gmail.com> 1662457774 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1662488998 +0100\n\nOpen a BCrypt algorithm handle\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121", "html_url": "https://github.com/rust-lang/rust/commit/b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "098cf8802271eacdc463fa66c35da377926d4c4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/098cf8802271eacdc463fa66c35da377926d4c4e", "html_url": "https://github.com/rust-lang/rust/commit/098cf8802271eacdc463fa66c35da377926d4c4e"}], "stats": {"total": 96, "additions": 76, "deletions": 20}, "files": [{"sha": "89d0ab59be89f3edcc15eba93163fd3a1485bcc4", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121", "patch": "@@ -66,6 +66,7 @@ pub type LPSYSTEM_INFO = *mut SYSTEM_INFO;\n pub type LPWSABUF = *mut WSABUF;\n pub type LPWSAOVERLAPPED = *mut c_void;\n pub type LPWSAOVERLAPPED_COMPLETION_ROUTINE = *mut c_void;\n+pub type BCRYPT_ALG_HANDLE = LPVOID;\n \n pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n pub type PLARGE_INTEGER = *mut c_longlong;\n@@ -278,14 +279,16 @@ pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n pub const STATUS_PENDING: NTSTATUS = 0x103 as _;\n pub const STATUS_END_OF_FILE: NTSTATUS = 0xC0000011_u32 as _;\n pub const STATUS_NOT_IMPLEMENTED: NTSTATUS = 0xC0000002_u32 as _;\n+pub const STATUS_NOT_SUPPORTED: NTSTATUS = 0xC00000BB_u32 as _;\n \n // Equivalent to the `NT_SUCCESS` C preprocessor macro.\n // See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n pub fn nt_success(status: NTSTATUS) -> bool {\n     status >= 0\n }\n \n-pub const BCRYPT_RNG_ALG_HANDLE: usize = 0x81;\n+// \"RNG\\0\"\n+pub const BCRYPT_RNG_ALGORITHM: &[u16] = &[b'R' as u16, b'N' as u16, b'G' as u16, 0];\n \n #[repr(C)]\n pub struct UNICODE_STRING {\n@@ -1229,11 +1232,18 @@ extern \"system\" {\n     // >= Vista / Server 2008\n     // https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom\n     pub fn BCryptGenRandom(\n-        hAlgorithm: LPVOID,\n+        hAlgorithm: BCRYPT_ALG_HANDLE,\n         pBuffer: *mut u8,\n         cbBuffer: ULONG,\n         dwFlags: ULONG,\n     ) -> NTSTATUS;\n+    pub fn BCryptOpenAlgorithmProvider(\n+        phalgorithm: *mut BCRYPT_ALG_HANDLE,\n+        pszAlgId: LPCWSTR,\n+        pszimplementation: LPCWSTR,\n+        dwflags: ULONG,\n+    ) -> NTSTATUS;\n+    pub fn BCryptCloseAlgorithmProvider(hAlgorithm: BCRYPT_ALG_HANDLE, dwFlags: ULONG) -> NTSTATUS;\n }\n \n // Functions that aren't available on every version of Windows that we support,"}, {"sha": "3dfa8dba97744876966c7eaede436855533a02a4", "filename": "library/std/src/sys/windows/rand.rs", "status": "modified", "additions": 64, "deletions": 18, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs?ref=b2e4f9dcb32aafcfa1bd2ab6b291ca84b7db0121", "patch": "@@ -22,7 +22,6 @@\n //! [`RtlGenRandom`]: https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom\n //! [`BCryptGenRandom`]: https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom\n //! [Pseudo-handle]: https://docs.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-pseudo-handles\n-use crate::io;\n use crate::mem;\n use crate::ptr;\n use crate::sys::c;\n@@ -34,35 +33,82 @@ use crate::sys::c;\n /// [`HashMap`]: crate::collections::HashMap\n /// [`RandomState`]: crate::collections::hash_map::RandomState\n pub fn hashmap_random_keys() -> (u64, u64) {\n-    let mut v = (0, 0);\n-    let ret = unsafe {\n-        let size = mem::size_of_val(&v).try_into().unwrap();\n-        c::BCryptGenRandom(\n-            // BCRYPT_RNG_ALG_HANDLE is only supported in Windows 10+.\n-            // So for Windows 8.1 and Windows 7 we'll need a fallback when this fails.\n-            ptr::invalid_mut(c::BCRYPT_RNG_ALG_HANDLE),\n-            ptr::addr_of_mut!(v).cast(),\n-            size,\n-            0,\n-        )\n-    };\n-    if ret != 0 { fallback_rng() } else { v }\n+    Rng::open().and_then(|rng| rng.gen_random_keys()).unwrap_or_else(fallback_rng)\n+}\n+\n+struct Rng(c::BCRYPT_ALG_HANDLE);\n+impl Rng {\n+    // Open a handle to the RNG algorithm.\n+    fn open() -> Result<Self, c::NTSTATUS> {\n+        use crate::sync::atomic::AtomicPtr;\n+        use crate::sync::atomic::Ordering::{Acquire, Release};\n+        const ERROR_VALUE: c::LPVOID = ptr::invalid_mut(usize::MAX);\n+\n+        // An atomic is used so we don't need to reopen the handle every time.\n+        static HANDLE: AtomicPtr<crate::ffi::c_void> = AtomicPtr::new(ptr::null_mut());\n+\n+        let mut handle = HANDLE.load(Acquire);\n+        // We use a sentinel value to designate an error occurred last time.\n+        if handle == ERROR_VALUE {\n+            Err(c::STATUS_NOT_SUPPORTED)\n+        } else if handle.is_null() {\n+            let status = unsafe {\n+                c::BCryptOpenAlgorithmProvider(\n+                    &mut handle,\n+                    c::BCRYPT_RNG_ALGORITHM.as_ptr(),\n+                    ptr::null(),\n+                    0,\n+                )\n+            };\n+            if c::nt_success(status) {\n+                // If another thread opens a handle first then use that handle instead.\n+                let result = HANDLE.compare_exchange(ptr::null_mut(), handle, Release, Acquire);\n+                if let Err(previous_handle) = result {\n+                    // Close our handle and return the previous one.\n+                    unsafe { c::BCryptCloseAlgorithmProvider(handle, 0) };\n+                    handle = previous_handle;\n+                }\n+                Ok(Self(handle))\n+            } else {\n+                HANDLE.store(ERROR_VALUE, Release);\n+                Err(status)\n+            }\n+        } else {\n+            Ok(Self(handle))\n+        }\n+    }\n+\n+    fn gen_random_keys(self) -> Result<(u64, u64), c::NTSTATUS> {\n+        let mut v = (0, 0);\n+        let status = unsafe {\n+            let size = mem::size_of_val(&v).try_into().unwrap();\n+            c::BCryptGenRandom(self.0, ptr::addr_of_mut!(v).cast(), size, 0)\n+        };\n+        if c::nt_success(status) { Ok(v) } else { Err(status) }\n+    }\n }\n \n /// Generate random numbers using the fallback RNG function (RtlGenRandom)\n #[cfg(not(target_vendor = \"uwp\"))]\n #[inline(never)]\n-fn fallback_rng() -> (u64, u64) {\n+fn fallback_rng(rng_status: c::NTSTATUS) -> (u64, u64) {\n     let mut v = (0, 0);\n     let ret =\n         unsafe { c::RtlGenRandom(&mut v as *mut _ as *mut u8, mem::size_of_val(&v) as c::ULONG) };\n \n-    if ret != 0 { v } else { panic!(\"fallback RNG broken: {}\", io::Error::last_os_error()) }\n+    if ret != 0 {\n+        v\n+    } else {\n+        panic!(\n+            \"RNG broken: {rng_status:#x}, fallback RNG broken: {}\",\n+            crate::io::Error::last_os_error()\n+        )\n+    }\n }\n \n /// We can't use RtlGenRandom with UWP, so there is no fallback\n #[cfg(target_vendor = \"uwp\")]\n #[inline(never)]\n-fn fallback_rng() -> (u64, u64) {\n-    panic!(\"fallback RNG broken: RtlGenRandom() not supported on UWP\");\n+fn fallback_rng(rng_status: c::NTSTATUS) -> (u64, u64) {\n+    panic!(\"RNG broken: {rng_status:#x} fallback RNG broken: RtlGenRandom() not supported on UWP\");\n }"}]}