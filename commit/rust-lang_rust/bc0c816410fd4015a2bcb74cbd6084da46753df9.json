{"sha": "bc0c816410fd4015a2bcb74cbd6084da46753df9", "node_id": "C_kwDOAAsO6NoAKGJjMGM4MTY0MTBmZDQwMTVhMmJjYjc0Y2JkNjA4NGRhNDY3NTNkZjk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-14T17:45:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-14T17:45:28Z"}, "message": "Rollup merge of #106855 - klensy:rd-s, r=notriddle\n\nrustdoc: few small cleanups", "tree": {"sha": "37fc5ae010a378607ac6e7ab416bb054a438905a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37fc5ae010a378607ac6e7ab416bb054a438905a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc0c816410fd4015a2bcb74cbd6084da46753df9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwuo4CRBK7hj4Ov3rIwAAxNEIAFmoxU3v/c81Kc/GVnYkV9La\n3x3qHkKH+OXjUzIMRMiPJfuxT6SHx2j6u/pm6zF/Sgr2GFUEcWQsuwNycCWp5Vry\nnmOiEH7JJo+04zq6cqzlI+AAXx3ZapXjZpZpcP4iepVE/ysN5uvv+LSEqk0dV8hV\nGvzgxs4kTZM7dKefaiCEktoYts5cG7Zuu8TX1jgs4ty4Y20HvGaL/+UuQZam9WkM\nnoeni3N6g2sHvQmJ11Yy5BbN3P09t5v7a737UMs/qxuM3qpytiH3KrVe0ZP6AWxz\nkMx18GU8Dt94xjbQq9mReumJkevszTKVi0Mi+3irIVx3EE2upu+Vv2oEVtgH7rI=\n=zbcV\n-----END PGP SIGNATURE-----\n", "payload": "tree 37fc5ae010a378607ac6e7ab416bb054a438905a\nparent 9db8e6d5e9d6a4e87105ee556c54a4d30d1b261b\nparent 8998bd35ed2ebd5889f7726e971e95e642c3fdca\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673718328 +0100\ncommitter GitHub <noreply@github.com> 1673718328 +0100\n\nRollup merge of #106855 - klensy:rd-s, r=notriddle\n\nrustdoc: few small cleanups\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc0c816410fd4015a2bcb74cbd6084da46753df9", "html_url": "https://github.com/rust-lang/rust/commit/bc0c816410fd4015a2bcb74cbd6084da46753df9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc0c816410fd4015a2bcb74cbd6084da46753df9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9db8e6d5e9d6a4e87105ee556c54a4d30d1b261b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9db8e6d5e9d6a4e87105ee556c54a4d30d1b261b", "html_url": "https://github.com/rust-lang/rust/commit/9db8e6d5e9d6a4e87105ee556c54a4d30d1b261b"}, {"sha": "8998bd35ed2ebd5889f7726e971e95e642c3fdca", "url": "https://api.github.com/repos/rust-lang/rust/commits/8998bd35ed2ebd5889f7726e971e95e642c3fdca", "html_url": "https://github.com/rust-lang/rust/commit/8998bd35ed2ebd5889f7726e971e95e642c3fdca"}], "stats": {"total": 61, "additions": 33, "deletions": 28}, "files": [{"sha": "3149c22b8e55ff6fcdd1293ef3594ce85a74d4a5", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=bc0c816410fd4015a2bcb74cbd6084da46753df9", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         }\n \n         // Index this method for searching later on.\n-        if let Some(ref s) = item.name.or_else(|| {\n+        if let Some(s) = item.name.or_else(|| {\n             if item.is_stripped() {\n                 None\n             } else if let clean::ImportItem(ref i) = *item.kind &&\n@@ -317,14 +317,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             short_markdown_summary(x.as_str(), &item.link_names(self.cache))\n                         });\n                         let ty = item.type_();\n-                        let name = s.to_string();\n-                        if ty != ItemType::StructField || u16::from_str_radix(&name, 10).is_err() {\n+                        if ty != ItemType::StructField\n+                            || u16::from_str_radix(s.as_str(), 10).is_err()\n+                        {\n                             // In case this is a field from a tuple struct, we don't add it into\n                             // the search index because its name is something like \"0\", which is\n                             // not useful for rustdoc search.\n                             self.cache.search_index.push(IndexItem {\n                                 ty,\n-                                name,\n+                                name: s,\n                                 path: join_with_double_colon(path),\n                                 desc,\n                                 parent,"}, {"sha": "006076baf7257dab55ae538a5361fb17a06be287", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=bc0c816410fd4015a2bcb74cbd6084da46753df9", "patch": "@@ -569,7 +569,7 @@ fn generate_macro_def_id_path(\n     root_path: Option<&str>,\n ) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n     let tcx = cx.shared.tcx;\n-    let crate_name = tcx.crate_name(def_id.krate).to_string();\n+    let crate_name = tcx.crate_name(def_id.krate);\n     let cache = cx.cache();\n \n     let fqp: Vec<Symbol> = tcx\n@@ -584,7 +584,7 @@ fn generate_macro_def_id_path(\n             }\n         })\n         .collect();\n-    let mut relative = fqp.iter().map(|elem| elem.to_string());\n+    let mut relative = fqp.iter().copied();\n     let cstore = CStore::from_tcx(tcx);\n     // We need this to prevent a `panic` when this function is used from intra doc links...\n     if !cstore.has_crate_data(def_id.krate) {\n@@ -602,9 +602,9 @@ fn generate_macro_def_id_path(\n     };\n \n     let mut path = if is_macro_2 {\n-        once(crate_name.clone()).chain(relative).collect()\n+        once(crate_name).chain(relative).collect()\n     } else {\n-        vec![crate_name.clone(), relative.next_back().unwrap()]\n+        vec![crate_name, relative.next_back().unwrap()]\n     };\n     if path.len() < 2 {\n         // The minimum we can have is the crate name followed by the macro name. If shorter, then\n@@ -614,17 +614,22 @@ fn generate_macro_def_id_path(\n     }\n \n     if let Some(last) = path.last_mut() {\n-        *last = format!(\"macro.{}.html\", last);\n+        *last = Symbol::intern(&format!(\"macro.{}.html\", last.as_str()));\n     }\n \n     let url = match cache.extern_locations[&def_id.krate] {\n         ExternalLocation::Remote(ref s) => {\n             // `ExternalLocation::Remote` always end with a `/`.\n-            format!(\"{}{}\", s, path.join(\"/\"))\n+            format!(\"{}{}\", s, path.iter().map(|p| p.as_str()).join(\"/\"))\n         }\n         ExternalLocation::Local => {\n             // `root_path` always end with a `/`.\n-            format!(\"{}{}/{}\", root_path.unwrap_or(\"\"), crate_name, path.join(\"/\"))\n+            format!(\n+                \"{}{}/{}\",\n+                root_path.unwrap_or(\"\"),\n+                crate_name,\n+                path.iter().map(|p| p.as_str()).join(\"/\")\n+            )\n         }\n         ExternalLocation::Unknown => {\n             debug!(\"crate {} not in cache when linkifying macros\", crate_name);\n@@ -1050,7 +1055,7 @@ fn fmt_type<'cx>(\n                 _ => String::new(),\n             };\n             let m = mutability.print_with_space();\n-            let amp = if f.alternate() { \"&\".to_string() } else { \"&amp;\".to_string() };\n+            let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n             match **ty {\n                 clean::DynTrait(ref bounds, ref trait_lt)\n                     if bounds.len() > 1 || trait_lt.is_some() =>"}, {"sha": "4ff67fe1551dd019f638bc79ce4ee6460047e6bf", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=bc0c816410fd4015a2bcb74cbd6084da46753df9", "patch": "@@ -30,7 +30,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n \n use once_cell::sync::Lazy;\n use std::borrow::Cow;\n@@ -198,7 +198,7 @@ fn slugify(c: char) -> Option<char> {\n \n #[derive(Clone, Debug)]\n pub struct Playground {\n-    pub crate_name: Option<String>,\n+    pub crate_name: Option<Symbol>,\n     pub url: String,\n }\n \n@@ -290,7 +290,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                 .map(|l| map_line(l).for_code())\n                 .intersperse(\"\\n\".into())\n                 .collect::<String>();\n-            let krate = krate.as_ref().map(|s| &**s);\n+            let krate = krate.as_ref().map(|s| s.as_str());\n             let (test, _, _) =\n                 doctest::make_test(&test, krate, false, &Default::default(), edition, None);\n             let channel = if test.contains(\"#![feature(\") { \"&amp;version=nightly\" } else { \"\" };"}, {"sha": "5cefe9475e77576e63458dc5d3a9dfeb1d469285", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=bc0c816410fd4015a2bcb74cbd6084da46753df9", "patch": "@@ -464,8 +464,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         // If user passed in `--playground-url` arg, we fill in crate name here\n         let mut playground = None;\n         if let Some(url) = playground_url {\n-            playground =\n-                Some(markdown::Playground { crate_name: Some(krate.name(tcx).to_string()), url });\n+            playground = Some(markdown::Playground { crate_name: Some(krate.name(tcx)), url });\n         }\n         let mut layout = layout::Layout {\n             logo: String::new(),\n@@ -491,7 +490,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                 }\n                 (sym::html_playground_url, Some(s)) => {\n                     playground = Some(markdown::Playground {\n-                        crate_name: Some(krate.name(tcx).to_string()),\n+                        crate_name: Some(krate.name(tcx)),\n                         url: s.to_string(),\n                     });\n                 }"}, {"sha": "f95d8e4303594900aa892473baed229afcceaacb", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=bc0c816410fd4015a2bcb74cbd6084da46753df9", "patch": "@@ -100,7 +100,7 @@ pub(crate) fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n #[derive(Debug)]\n pub(crate) struct IndexItem {\n     pub(crate) ty: ItemType,\n-    pub(crate) name: String,\n+    pub(crate) name: Symbol,\n     pub(crate) path: String,\n     pub(crate) desc: String,\n     pub(crate) parent: Option<DefId>,\n@@ -2769,8 +2769,8 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n     let mut work = VecDeque::new();\n \n     let mut process_path = |did: DefId| {\n-        let get_extern = || cache.external_paths.get(&did).map(|s| s.0.clone());\n-        let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n+        let get_extern = || cache.external_paths.get(&did).map(|s| &s.0);\n+        let fqp = cache.exact_paths.get(&did).or_else(get_extern);\n \n         if let Some(path) = fqp {\n             out.push(join_with_double_colon(&path));"}, {"sha": "b93db7e28b2d701de6649819290c3d44b2c79457", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=bc0c816410fd4015a2bcb74cbd6084da46753df9", "patch": "@@ -1027,8 +1027,8 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         .chain(std::iter::once(\"implementors\"))\n         .collect();\n     if let Some(did) = it.item_id.as_def_id() &&\n-        let get_extern = { || cache.external_paths.get(&did).map(|s| s.0.clone()) } &&\n-        let Some(fqp) = cache.exact_paths.get(&did).cloned().or_else(get_extern) {\n+        let get_extern = { || cache.external_paths.get(&did).map(|s| &s.0) } &&\n+        let Some(fqp) = cache.exact_paths.get(&did).or_else(get_extern) {\n         js_src_path.extend(fqp[..fqp.len() - 1].iter().copied());\n         js_src_path.push_fmt(format_args!(\"{}.{}.js\", it.type_(), fqp.last().unwrap()));\n     } else {"}, {"sha": "c64349f413cee8e3b19361c05808a0c5130e709d", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c816410fd4015a2bcb74cbd6084da46753df9/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=bc0c816410fd4015a2bcb74cbd6084da46753df9", "patch": "@@ -35,7 +35,7 @@ pub(crate) fn build_index<'tcx>(\n                 .map_or_else(String::new, |s| short_markdown_summary(&s, &item.link_names(cache)));\n             cache.search_index.push(IndexItem {\n                 ty: item.type_(),\n-                name: item.name.unwrap().to_string(),\n+                name: item.name.unwrap(),\n                 path: join_with_double_colon(&fqp[..fqp.len() - 1]),\n                 desc,\n                 parent: Some(parent),\n@@ -58,8 +58,8 @@ pub(crate) fn build_index<'tcx>(\n     // Sort search index items. This improves the compressibility of the search index.\n     cache.search_index.sort_unstable_by(|k1, k2| {\n         // `sort_unstable_by_key` produces lifetime errors\n-        let k1 = (&k1.path, &k1.name, &k1.ty, &k1.parent);\n-        let k2 = (&k2.path, &k2.name, &k2.ty, &k2.parent);\n+        let k1 = (&k1.path, k1.name.as_str(), &k1.ty, &k1.parent);\n+        let k2 = (&k2.path, k2.name.as_str(), &k2.ty, &k2.parent);\n         std::cmp::Ord::cmp(&k1, &k2)\n     });\n \n@@ -240,7 +240,7 @@ pub(crate) fn build_index<'tcx>(\n             )?;\n             crate_data.serialize_field(\n                 \"n\",\n-                &self.items.iter().map(|item| &item.name).collect::<Vec<_>>(),\n+                &self.items.iter().map(|item| item.name.as_str()).collect::<Vec<_>>(),\n             )?;\n             crate_data.serialize_field(\n                 \"q\",\n@@ -299,7 +299,7 @@ pub(crate) fn build_index<'tcx>(\n             )?;\n             crate_data.serialize_field(\n                 \"p\",\n-                &self.paths.iter().map(|(it, s)| (it, s.to_string())).collect::<Vec<_>>(),\n+                &self.paths.iter().map(|(it, s)| (it, s.as_str())).collect::<Vec<_>>(),\n             )?;\n             if has_aliases {\n                 crate_data.serialize_field(\"a\", &self.aliases)?;"}]}