{"sha": "f70c9dba22df28b606ee413a82a3fe4305855620", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MGM5ZGJhMjJkZjI4YjYwNmVlNDEzYTgyYTNmZTQzMDU4NTU2MjA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-25T23:00:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-25T23:00:20Z"}, "message": "Rollup merge of #71554 - gizmondo:68922, r=jonas-schievink\n\nReplace thread_local with generator resume arguments in box_region.\n\nFixes #68922.\n\nContinuation of #70622. Added a short doc, hope it makes sense.\n\nr? @jonas-schievink", "tree": {"sha": "065f6ab256a55a6cbc1826ddc1aa75ecbca043b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/065f6ab256a55a6cbc1826ddc1aa75ecbca043b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f70c9dba22df28b606ee413a82a3fe4305855620", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJepMEFCRBK7hj4Ov3rIwAAdHIIAGaJJNlODB9rYLUeDJlETkU6\nHkR030NAEU3aH72dJWLBS1F//90XNnt5yNPfCfvxAShryOtLW26sFp4+hYhVfoBW\naVsLuDYzCtBppFMlUkYrsyOEbxHK8IBqoL/jB8xSs4yLShBmYi6cW/FXrrckvQ7A\nWjJGDzK8qOpmbYNrOGBM3UMrsE3lkFPUqdKhAVQgeb59oCYNqXcM0V8Kjvgnwz90\nuXbJjCJXZgyj3smGIRIPEhloLeCEq6MSl+uDFHKATVksd8iuABELvwSWVfW2auWf\nemrTnrzAmnjXRafxs6WcmMY4m8uMO+jZeM61CmxQMSRIl6NUst8GTSsoV/von7Q=\n=j0ad\n-----END PGP SIGNATURE-----\n", "payload": "tree 065f6ab256a55a6cbc1826ddc1aa75ecbca043b4\nparent fde472792f2c05455f37ab770545579705f437e5\nparent 357f4ce4318088b541b98148cfcdff18552bb2cf\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587855620 +0200\ncommitter GitHub <noreply@github.com> 1587855620 +0200\n\nRollup merge of #71554 - gizmondo:68922, r=jonas-schievink\n\nReplace thread_local with generator resume arguments in box_region.\n\nFixes #68922.\n\nContinuation of #70622. Added a short doc, hope it makes sense.\n\nr? @jonas-schievink\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f70c9dba22df28b606ee413a82a3fe4305855620", "html_url": "https://github.com/rust-lang/rust/commit/f70c9dba22df28b606ee413a82a3fe4305855620", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f70c9dba22df28b606ee413a82a3fe4305855620/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fde472792f2c05455f37ab770545579705f437e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fde472792f2c05455f37ab770545579705f437e5", "html_url": "https://github.com/rust-lang/rust/commit/fde472792f2c05455f37ab770545579705f437e5"}, {"sha": "357f4ce4318088b541b98148cfcdff18552bb2cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/357f4ce4318088b541b98148cfcdff18552bb2cf", "html_url": "https://github.com/rust-lang/rust/commit/357f4ce4318088b541b98148cfcdff18552bb2cf"}], "stats": {"total": 54, "additions": 31, "deletions": 23}, "files": [{"sha": "eb6f4e8213ec711dac0b945cc5c2f751c9511451", "filename": "src/librustc_data_structures/box_region.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f70c9dba22df28b606ee413a82a3fe4305855620/src%2Flibrustc_data_structures%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70c9dba22df28b606ee413a82a3fe4305855620/src%2Flibrustc_data_structures%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbox_region.rs?ref=f70c9dba22df28b606ee413a82a3fe4305855620", "patch": "@@ -1,4 +1,15 @@\n-use std::cell::Cell;\n+//! This module provides a way to deal with self-referential data.\n+//!\n+//! The main idea is to allocate such data in a generator frame and then\n+//! give access to it by executing user-provided closures inside that generator.\n+//! The module provides a safe abstraction for the latter task.\n+//!\n+//! The interface consists of two exported macros meant to be used together:\n+//! * `declare_box_region_type` wraps a generator inside a struct with `access`\n+//!   method which accepts closures.\n+//! * `box_region_allow_access` is a helper which should be called inside\n+//!   a generator to actually execute those closures.\n+\n use std::marker::PhantomData;\n use std::ops::{Generator, GeneratorState};\n use std::pin::Pin;\n@@ -14,24 +25,23 @@ impl AccessAction {\n \n #[derive(Copy, Clone)]\n pub enum Action {\n+    Initial,\n     Access(AccessAction),\n     Complete,\n }\n \n-thread_local!(pub static BOX_REGION_ARG: Cell<Action> = Cell::new(Action::Complete));\n-\n pub struct PinnedGenerator<I, A, R> {\n-    generator: Pin<Box<dyn Generator<Yield = YieldType<I, A>, Return = R>>>,\n+    generator: Pin<Box<dyn Generator<Action, Yield = YieldType<I, A>, Return = R>>>,\n }\n \n impl<I, A, R> PinnedGenerator<I, A, R> {\n-    pub fn new<T: Generator<Yield = YieldType<I, A>, Return = R> + 'static>(\n+    pub fn new<T: Generator<Action, Yield = YieldType<I, A>, Return = R> + 'static>(\n         generator: T,\n     ) -> (I, Self) {\n         let mut result = PinnedGenerator { generator: Box::pin(generator) };\n \n         // Run it to the first yield to set it up\n-        let init = match Pin::new(&mut result.generator).resume(()) {\n+        let init = match Pin::new(&mut result.generator).resume(Action::Initial) {\n             GeneratorState::Yielded(YieldType::Initial(y)) => y,\n             _ => panic!(),\n         };\n@@ -40,21 +50,17 @@ impl<I, A, R> PinnedGenerator<I, A, R> {\n     }\n \n     pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n-        BOX_REGION_ARG.with(|i| {\n-            i.set(Action::Access(AccessAction(closure)));\n-        });\n-\n-        // Call the generator, which in turn will call the closure in BOX_REGION_ARG\n-        if let GeneratorState::Complete(_) = Pin::new(&mut self.generator).resume(()) {\n+        // Call the generator, which in turn will call the closure\n+        if let GeneratorState::Complete(_) =\n+            Pin::new(&mut self.generator).resume(Action::Access(AccessAction(closure)))\n+        {\n             panic!()\n         }\n     }\n \n     pub fn complete(&mut self) -> R {\n         // Tell the generator we want it to complete, consuming it and yielding a result\n-        BOX_REGION_ARG.with(|i| i.set(Action::Complete));\n-\n-        let result = Pin::new(&mut self.generator).resume(());\n+        let result = Pin::new(&mut self.generator).resume(Action::Complete);\n         if let GeneratorState::Complete(r) = result { r } else { panic!() }\n     }\n }\n@@ -89,7 +95,7 @@ macro_rules! declare_box_region_type {\n         >);\n \n         impl $name {\n-            fn new<T: ::std::ops::Generator<Yield = $yield_type, Return = $retc> + 'static>(\n+            fn new<T: ::std::ops::Generator<$crate::box_region::Action, Yield = $yield_type, Return = $retc> + 'static>(\n                 generator: T\n             ) -> ($reti, Self) {\n                 let (initial, pinned) = $crate::box_region::PinnedGenerator::new(generator);\n@@ -98,7 +104,7 @@ macro_rules! declare_box_region_type {\n \n             $v fn access<F: for<$($lifetimes)*> FnOnce($($args,)*) -> R, R>(&mut self, f: F) -> R {\n                 // Turn the FnOnce closure into *mut dyn FnMut()\n-                // so we can pass it in to the generator using the BOX_REGION_ARG thread local\n+                // so we can pass it in to the generator\n                 let mut r = None;\n                 let mut f = Some(f);\n                 let mut_f: &mut dyn for<$($lifetimes)*> FnMut(($($args,)*)) =\n@@ -140,9 +146,9 @@ macro_rules! declare_box_region_type {\n #[macro_export]\n #[allow_internal_unstable(fn_traits)]\n macro_rules! box_region_allow_access {\n-    (for($($lifetimes:tt)*), ($($args:ty),*), ($($exprs:expr),*) ) => {\n+    (for($($lifetimes:tt)*), ($($args:ty),*), ($($exprs:expr),*), $action:ident) => {\n         loop {\n-            match $crate::box_region::BOX_REGION_ARG.with(|i| i.get()) {\n+            match $action {\n                 $crate::box_region::Action::Access(accessor) => {\n                     let accessor: &mut dyn for<$($lifetimes)*> FnMut($($args),*) = unsafe {\n                         ::std::mem::transmute(accessor.get())\n@@ -152,10 +158,11 @@ macro_rules! box_region_allow_access {\n                         let marker = $crate::box_region::Marker::<\n                             for<$($lifetimes)*> fn(($($args,)*))\n                         >::new();\n-                        yield $crate::box_region::YieldType::Accessor(marker)\n+                        $action = yield $crate::box_region::YieldType::Accessor(marker);\n                     };\n                 }\n                 $crate::box_region::Action::Complete => break,\n+                $crate::box_region::Action::Initial => panic!(\"unexpected box_region action: Initial\"),\n             }\n         }\n     }"}, {"sha": "4b09148eab61f8269c1c5a95e91650906fd8d969", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f70c9dba22df28b606ee413a82a3fe4305855620/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70c9dba22df28b606ee413a82a3fe4305855620/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=f70c9dba22df28b606ee413a82a3fe4305855620", "patch": "@@ -109,7 +109,8 @@ pub fn configure_and_expand(\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n     let crate_name = crate_name.to_string();\n-    let (result, resolver) = BoxedResolver::new(static move || {\n+    let (result, resolver) = BoxedResolver::new(static move |mut action| {\n+        let _ = action;\n         let sess = &*sess;\n         let resolver_arenas = Resolver::arenas();\n         let res = configure_and_expand_inner(\n@@ -126,11 +127,11 @@ pub fn configure_and_expand(\n                 panic!()\n             }\n             Ok((krate, resolver)) => {\n-                yield BoxedResolver::initial_yield(Ok(krate));\n+                action = yield BoxedResolver::initial_yield(Ok(krate));\n                 resolver\n             }\n         };\n-        box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver));\n+        box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver), action);\n         resolver.into_outputs()\n     });\n     result.map(|k| (k, resolver))"}]}