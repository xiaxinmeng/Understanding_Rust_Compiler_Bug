{"sha": "8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmM2EyOWQxYTc0YzFjOGI4NDk5NDI2ZDY0MGI3YTg2NmYwM2ZhYmY=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-11-20T20:05:10Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-11-20T20:05:10Z"}, "message": "Blockify multiline match arms", "tree": {"sha": "e35bfcde0d2cc05d501900a9c7ab2a7451f3a55c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e35bfcde0d2cc05d501900a9c7ab2a7451f3a55c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "html_url": "https://github.com/rust-lang/rust/commit/8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc76558910b0eb8917e7e20a79a0080aa75a1b73", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc76558910b0eb8917e7e20a79a0080aa75a1b73", "html_url": "https://github.com/rust-lang/rust/commit/bc76558910b0eb8917e7e20a79a0080aa75a1b73"}], "stats": {"total": 274, "additions": 165, "deletions": 109}, "files": [{"sha": "0f118ca5d294a72cc64201d7d9a3d49836538eaa", "filename": "src/comment.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "patch": "@@ -127,12 +127,14 @@ impl FindUncommented for str {\n                 None => {\n                     return Some(i - pat.len());\n                 }\n-                Some(c) => match kind {\n-                    CodeCharKind::Normal if b == c => {}\n-                    _ => {\n-                        needle_iter = pat.chars();\n+                Some(c) => {\n+                    match kind {\n+                        CodeCharKind::Normal if b == c => {}\n+                        _ => {\n+                            needle_iter = pat.chars();\n+                        }\n                     }\n-                },\n+                }\n             }\n         }\n \n@@ -233,33 +235,39 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n         let item = try_opt!(self.base.next());\n         let chr = item.get_char();\n         self.status = match self.status {\n-            CharClassesStatus::LitString => match chr {\n-                '\"' => CharClassesStatus::Normal,\n-                '\\\\' => CharClassesStatus::LitStringEscape,\n-                _ => CharClassesStatus::LitString,\n-            },\n+            CharClassesStatus::LitString => {\n+                match chr {\n+                    '\"' => CharClassesStatus::Normal,\n+                    '\\\\' => CharClassesStatus::LitStringEscape,\n+                    _ => CharClassesStatus::LitString,\n+                }\n+            }\n             CharClassesStatus::LitStringEscape => CharClassesStatus::LitString,\n-            CharClassesStatus::LitChar => match chr {\n-                '\\\\' => CharClassesStatus::LitCharEscape,\n-                '\\'' => CharClassesStatus::Normal,\n-                _ => CharClassesStatus::LitChar,\n-            },\n+            CharClassesStatus::LitChar => {\n+                match chr {\n+                    '\\\\' => CharClassesStatus::LitCharEscape,\n+                    '\\'' => CharClassesStatus::Normal,\n+                    _ => CharClassesStatus::LitChar,\n+                }\n+            }\n             CharClassesStatus::LitCharEscape => CharClassesStatus::LitChar,\n             CharClassesStatus::Normal => {\n                 match chr {\n                     '\"' => CharClassesStatus::LitString,\n                     '\\'' => CharClassesStatus::LitChar,\n-                    '/' => match self.base.peek() {\n-                        Some(next) if next.get_char() == '*' => {\n-                            self.status = CharClassesStatus::BlockCommentOpening(1);\n-                            return Some((CodeCharKind::Comment, item));\n-                        }\n-                        Some(next) if next.get_char() == '/' => {\n-                            self.status = CharClassesStatus::LineComment;\n-                            return Some((CodeCharKind::Comment, item));\n+                    '/' => {\n+                        match self.base.peek() {\n+                            Some(next) if next.get_char() == '*' => {\n+                                self.status = CharClassesStatus::BlockCommentOpening(1);\n+                                return Some((CodeCharKind::Comment, item));\n+                            }\n+                            Some(next) if next.get_char() == '/' => {\n+                                self.status = CharClassesStatus::LineComment;\n+                                return Some((CodeCharKind::Comment, item));\n+                            }\n+                            _ => CharClassesStatus::Normal,\n                         }\n-                        _ => CharClassesStatus::Normal,\n-                    },\n+                    }\n                     _ => CharClassesStatus::Normal,\n                 }\n             }\n@@ -271,10 +279,12 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n                     return Some((CodeCharKind::Comment, item));\n                 }\n                 self.status = match self.base.peek() {\n-                    Some(next) if next.get_char() == '/' && chr == '*' =>\n-                        CharClassesStatus::BlockCommentClosing(deepness - 1),\n-                    Some(next) if next.get_char() == '*' && chr == '/' =>\n-                        CharClassesStatus::BlockCommentOpening(deepness + 1),\n+                    Some(next) if next.get_char() == '/' && chr == '*' => {\n+                        CharClassesStatus::BlockCommentClosing(deepness - 1)\n+                    }\n+                    Some(next) if next.get_char() == '*' && chr == '/' => {\n+                        CharClassesStatus::BlockCommentOpening(deepness + 1)\n+                    }\n                     _ => CharClassesStatus::BlockComment(deepness),\n                 };\n                 return Some((CodeCharKind::Comment, item));"}, {"sha": "3247e98c13a162edb2f8f9c5ec6ea52eb0b5af9a", "filename": "src/expr.rs", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "patch": "@@ -571,13 +571,15 @@ impl<'a> Rewrite for Loop<'a> {\n         let inner_offset = offset + self.keyword.len() + label_string.len();\n \n         let pat_expr_string = match self.cond {\n-            Some(cond) => try_opt!(rewrite_pat_expr(context,\n-                                                    self.pat,\n-                                                    cond,\n-                                                    self.matcher,\n-                                                    self.connector,\n-                                                    inner_width,\n-                                                    inner_offset)),\n+            Some(cond) => {\n+                try_opt!(rewrite_pat_expr(context,\n+                                          self.pat,\n+                                          cond,\n+                                          self.matcher,\n+                                          self.connector,\n+                                          inner_width,\n+                                          inner_offset))\n+            }\n             None => String::new(),\n         };\n \n@@ -711,6 +713,8 @@ fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n }\n \n // Checks that a block contains no statements, an expression and no comments.\n+// FIXME: incorrectly returns false when comment is contained completely within\n+// the expression.\n pub fn is_simple_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n     block.stmts.is_empty() && block.expr.is_some() && !block_contains_comment(block, codemap)\n }\n@@ -936,6 +940,11 @@ impl Rewrite for ast::Arm {\n \n         let comma = arm_comma(body);\n \n+        // let body = match *body {\n+        //     ast::ExprBlock(ref b) if is_simple_block(b, context.codemap) => b.expr,\n+        //     ref x => x,\n+        // };\n+\n         // Let's try and get the arm body on the same line as the condition.\n         // 4 = ` => `.len()\n         let same_line_body = if context.config.max_width > line_start + comma.len() + 4 {\n@@ -944,12 +953,13 @@ impl Rewrite for ast::Arm {\n             let rewrite = nop_block_collapse(body.rewrite(context, budget, offset), budget);\n \n             match rewrite {\n-                Some(ref body_str) if body_str.len() <= budget || comma.is_empty() =>\n+                Some(ref body_str) if body_str.len() <= budget || comma.is_empty() => {\n                     return Some(format!(\"{}{} => {}{}\",\n                                         attr_str.trim_left(),\n                                         pats_str,\n                                         body_str,\n-                                        comma)),\n+                                        comma));\n+                }\n                 _ => rewrite,\n             }\n         } else {\n@@ -961,26 +971,34 @@ impl Rewrite for ast::Arm {\n             return None;\n         }\n \n-        let body_budget = try_opt!(width.checked_sub(context.config.tab_spaces));\n-        let indent = context.block_indent.block_indent(context.config);\n-        let inner_context = &RewriteContext { block_indent: indent, ..*context };\n-        let next_line_body = nop_block_collapse(body.rewrite(inner_context, body_budget, indent),\n-                                                body_budget);\n+        let mut result = format!(\"{}{} =>\", attr_str.trim_left(), pats_str);\n \n-        let body_str = try_opt!(match_arm_heuristic(same_line_body.as_ref().map(|x| &x[..]),\n-                                                    next_line_body.as_ref().map(|x| &x[..])));\n-\n-        let spacer = match same_line_body {\n-            Some(ref body) if body == body_str => \" \".to_owned(),\n-            _ => format!(\"\\n{}\",\n-                         offset.block_indent(context.config).to_string(context.config)),\n+        match same_line_body {\n+            // FIXME: also take this branch is expr is block\n+            Some(ref body) if !body.contains('\\n') => {\n+                result.push(' ');\n+                result.push_str(&body);\n+            }\n+            _ => {\n+                let body_budget = try_opt!(width.checked_sub(context.config.tab_spaces));\n+                let indent = context.block_indent.block_indent(context.config);\n+                let inner_context = &RewriteContext { block_indent: indent, ..*context };\n+                let next_line_body = try_opt!(nop_block_collapse(body.rewrite(inner_context,\n+                                                                              body_budget,\n+                                                                              indent),\n+                                                                 body_budget));\n+\n+                result.push_str(\" {\\n\");\n+                let indent_str = offset.block_indent(context.config).to_string(context.config);\n+                result.push_str(&indent_str);\n+                result.push_str(&next_line_body);\n+                result.push('\\n');\n+                result.push_str(&offset.to_string(context.config));\n+                result.push('}');\n+            }\n         };\n \n-        Some(format!(\"{}{} =>{}{},\",\n-                     attr_str.trim_left(),\n-                     pats_str,\n-                     spacer,\n-                     body_str))\n+        Some(result)\n     }\n }\n \n@@ -1396,8 +1414,9 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     match (context.config.struct_lit_style,\n            context.config.struct_lit_multiline_style) {\n-        (StructLitStyle::Block, _) if fields_str.contains('\\n') || fields_str.len() > h_budget =>\n-            format_on_newline(),\n+        (StructLitStyle::Block, _) if fields_str.contains('\\n') || fields_str.len() > h_budget => {\n+            format_on_newline()\n+        }\n         (StructLitStyle::Block, MultilineStyle::ForceMulti) => format_on_newline(),\n         _ => Some(format!(\"{} {{ {} }}\", path_str, fields_str)),\n     }"}, {"sha": "60d08743a95210cace9f9ad35789d8c0e82b229e", "filename": "src/items.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "patch": "@@ -564,23 +564,26 @@ impl<'a> FmtVisitor<'a> {\n                                           \")\",\n                                           |arg| {\n                                               match *arg {\n-                                                  ArgumentKind::Regular(arg) =>\n-                                                      span_lo_for_arg(arg),\n+                                                  ArgumentKind::Regular(arg) => {\n+                                                      span_lo_for_arg(arg)\n+                                                  }\n                                                   ArgumentKind::Variadic(start) => start,\n                                               }\n                                           },\n                                           |arg| {\n                                               match *arg {\n                                                   ArgumentKind::Regular(arg) => arg.ty.span.hi,\n-                                                  ArgumentKind::Variadic(start) =>\n-                                                      start + BytePos(3),\n+                                                  ArgumentKind::Variadic(start) => {\n+                                                      start + BytePos(3)\n+                                                  }\n                                               }\n                                           },\n                                           |arg| {\n                                               match *arg {\n                                                   ArgumentKind::Regular(..) => None,\n-                                                  ArgumentKind::Variadic(..) =>\n-                                                      Some(\"...\".to_owned()),\n+                                                  ArgumentKind::Variadic(..) => {\n+                                                      Some(\"...\".to_owned())\n+                                                  }\n                                               }\n                                           },\n                                           comment_span_start,\n@@ -1118,8 +1121,9 @@ impl<'a> FmtVisitor<'a> {\n \n         let extra_indent = match self.config.where_indent {\n             BlockIndentStyle::Inherit => Indent::empty(),\n-            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual =>\n-                Indent::new(config.tab_spaces, 0),\n+            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => {\n+                Indent::new(config.tab_spaces, 0)\n+            }\n         };\n \n         let context = self.get_context();"}, {"sha": "727bc49a7422c2afc39721be04e87f7421eacf70", "filename": "src/missed_spans.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "patch": "@@ -103,10 +103,12 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let replaced = match self.write_mode {\n-            Some(mode) => match mode {\n-                WriteMode::Coverage => replace_chars(old_snippet),\n-                _ => old_snippet.to_owned(),\n-            },\n+            Some(mode) => {\n+                match mode {\n+                    WriteMode::Coverage => replace_chars(old_snippet),\n+                    _ => old_snippet.to_owned(),\n+                }\n+            }\n             None => old_snippet.to_owned(),\n         };\n         let snippet = &*replaced;"}, {"sha": "6d3c817256cae7443c0260d4c1ffa212ff0165eb", "filename": "tests/system.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "patch": "@@ -249,8 +249,10 @@ fn handle_result(result: HashMap<String, String>,\n fn get_target(file_name: &str, target: Option<&str>, write_mode: WriteMode) -> String {\n     let file_path = Path::new(file_name);\n     let (source_path_prefix, target_path_prefix) = match write_mode {\n-        WriteMode::Coverage => (Path::new(\"tests/coverage-source/\"),\n-                                \"tests/coverage-target/\"),\n+        WriteMode::Coverage => {\n+            (Path::new(\"tests/coverage-source/\"),\n+             \"tests/coverage-target/\")\n+        }\n         _ => (Path::new(\"tests/source/\"), \"tests/target/\"),\n     };\n "}, {"sha": "28a5ce2d98cc001f062fb69b579445d27df8ee29", "filename": "tests/target/match.rs", "status": "modified", "additions": 57, "deletions": 38, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3a29d1a74c1c8b8499426d640b7a866f03fabf/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=8f3a29d1a74c1c8b8499426d640b7a866f03fabf", "patch": "@@ -13,8 +13,9 @@ fn foo() {\n             foo()\n         }\n         // Perhaps this should introduce braces?\n-        Foo(ref bar) =>\n-            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        Foo(ref bar) => {\n+            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        }\n         Pattern1 | Pattern2 | Pattern3 => false,\n         Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn |\n         Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => {\n@@ -29,8 +30,9 @@ fn foo() {\n         Patternnnnnnnnnnnnnnnnnnn if looooooooooooooooooong_guard => meh,\n \n         Patternnnnnnnnnnnnnnnnnnnnnnnnn |\n-        Patternnnnnnnnnnnnnnnnnnnnnnnnn if looooooooooooooooooooooooooooooooooooooooong_guard =>\n-            meh,\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn if looooooooooooooooooooooooooooooooooooooooong_guard => {\n+            meh\n+        }\n \n         // Test that earlier patterns can take the guard space\n         (aaaa,\n@@ -75,19 +77,24 @@ fn main() {\n // Test that one-line bodies align.\n fn main() {\n     match r {\n-        Variableeeeeeeeeeeeeeeeee => (\"variable\",\n-                                      vec![\"id\", \"name\", \"qualname\", \"value\", \"type\", \"scopeid\"],\n-                                      true,\n-                                      true),\n-        Enummmmmmmmmmmmmmmmmmmmm => (\"enum\",\n-                                     vec![\"id\", \"qualname\", \"scopeid\", \"value\"],\n-                                     true,\n-                                     true),\n-        Variantttttttttttttttttttttttt =>\n+        Variableeeeeeeeeeeeeeeeee => {\n+            (\"variable\",\n+             vec![\"id\", \"name\", \"qualname\", \"value\", \"type\", \"scopeid\"],\n+             true,\n+             true)\n+        }\n+        Enummmmmmmmmmmmmmmmmmmmm => {\n+            (\"enum\",\n+             vec![\"id\", \"qualname\", \"scopeid\", \"value\"],\n+             true,\n+             true)\n+        }\n+        Variantttttttttttttttttttttttt => {\n             (\"variant\",\n              vec![\"id\", \"name\", \"qualname\", \"type\", \"value\", \"scopeid\"],\n              true,\n-             true),\n+             true)\n+        }\n     }\n }\n \n@@ -176,22 +183,28 @@ fn issue355() {\n         // m comment\n         m => vec!(3; 4),\n         // Rewrite splits macro\n-        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn =>\n-            println!(\"a\", b),\n+        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => {\n+            println!(\"a\", b)\n+        }\n         // Rewrite splits macro\n-        oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo =>\n-            vec![1, 2],\n+        oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo => {\n+            vec![1, 2]\n+        }\n         // Macro support fails to recognise this macro as splitable\n         // We push the whole expr to a new line, TODO split this macro as well\n-        pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp =>\n-            vec!(3; 4),\n+        pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp => {\n+            vec!(3; 4)\n+        }\n         // q, r and s: Rewrite splits match arm\n-        qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq =>\n-            println!(\"a\", b),\n-        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr =>\n-            vec![1, 2],\n-        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss =>\n-            vec!(3; 4),\n+        qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq => {\n+            println!(\"a\", b)\n+        }\n+        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr => {\n+            vec![1, 2]\n+        }\n+        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss => {\n+            vec!(3; 4)\n+        }\n         // Funky bracketing styles\n         t => println!{\"a\", b},\n         u => vec![1, 2],\n@@ -206,20 +219,24 @@ fn issue355() {\n         wc => println![\"a\", b], // comment\n         xc => vec![1, 2], // comment\n         yc => vec![3; 4], // comment\n-        yd => looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(aaaaaaaaaa,\n-                                                                                bbbbbbbbbb,\n-                                                                                cccccccccc,\n-                                                                                dddddddddd),\n+        yd => {\n+            looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(aaaaaaaaaa,\n+                                                                              bbbbbbbbbb,\n+                                                                              cccccccccc,\n+                                                                              dddddddddd)\n+        }\n     }\n }\n \n fn issue280() {\n     {\n         match x {\n-            CompressionMode::DiscardNewline | CompressionMode::CompressWhitespaceNewline =>\n-                ch == '\\n',\n-            ast::ItemConst(ref typ, ref expr) =>\n-                self.process_static_or_const_item(item, &typ, &expr),\n+            CompressionMode::DiscardNewline | CompressionMode::CompressWhitespaceNewline => {\n+                ch == '\\n'\n+            }\n+            ast::ItemConst(ref typ, ref expr) => {\n+                self.process_static_or_const_item(item, &typ, &expr)\n+            }\n         }\n     }\n }\n@@ -253,12 +270,13 @@ fn issue496() {\n         {\n             {\n                 match def {\n-                    def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n+                    def::DefConst(def_id) | def::DefAssociatedConst(def_id) => {\n                         match const_eval::lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n                             Some(const_expr) => {\n                                 x\n                             }\n-                        },\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -268,14 +286,15 @@ fn issue496() {\n fn issue494() {\n     {\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) =>\n+            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n                         scope: cx.tcx.region_maps.node_extent(id),\n                         expr: expr.to_ref(),\n                     },\n-                }))),\n+                })))\n+            }\n         }\n     }\n }"}]}