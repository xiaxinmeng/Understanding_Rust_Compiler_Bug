{"sha": "70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNjIyZGI0M2Q1ZTBhNThmOGZlNjZmZjE1MTE1ZTRmY2JiNWMyNzQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-19T12:29:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-19T12:29:16Z"}, "message": "Rollup merge of #72280 - nbdd0121:typeck, r=nikomatsakis\n\nFix up autoderef when reborrowing\n\nCurrently `(f)()` and `f.call_mut()` behaves differently if expression `f` contains autoderef in it. This causes a weird error in #72225.\n\nWhen `f` is type checked, `Deref` is used (this is expected as we can't yet determine if we should use `Fn` or `FnMut`). When subsequently we determine the actual trait to be used, when using the `f.call_mut()` syntax the `Deref` is patched to `DerefMut`, while for the `(f)()` syntax case it is not.\n\nThis PR replicates the fixup for the first case.\n\nFixes #72225\nFixes #68590", "tree": {"sha": "296530d1184b80e0d2993762a1f71489848c5f39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/296530d1184b80e0d2993762a1f71489848c5f39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7K+cCRBK7hj4Ov3rIwAAdHIIAH7se82VGIf66TTR2dHWj82S\nM5I8PYxBTN2L8DUCpy0MOwgUtMku6Wsn+7371zXtzH1jd1pO3hNQpy9qIjRHwZqw\nzkBtYpzTu6H04fFRnYPPgofbWQW6nW5unp1Nu2ByN434b69jVAnBfhe9xkz68tdj\n3OZ/1xQ2tBgaFP0GW9Mg837bjbiOh6168OEKa/FmhTJ55v8+cPpK2aZt9DPGz5OC\ngQAJCwZKNMoNHbubGz62VVEPzghW2xs5yIxnqLMKk/Up7EXsmQjThmeD3X7skVGy\nRaBeB7ENjM3N88QiXuXO25BUsogx0z9iIFdki6LQucml1MI4pj5BEC6qhPDYZ3U=\n=rpbL\n-----END PGP SIGNATURE-----\n", "payload": "tree 296530d1184b80e0d2993762a1f71489848c5f39\nparent 63b441aafbf52d6ba789ecc478455800c1a48df9\nparent 2b7d8588668bc79a1855a2c335572a1ac8ceaf34\nauthor Ralf Jung <post@ralfj.de> 1592569756 +0200\ncommitter GitHub <noreply@github.com> 1592569756 +0200\n\nRollup merge of #72280 - nbdd0121:typeck, r=nikomatsakis\n\nFix up autoderef when reborrowing\n\nCurrently `(f)()` and `f.call_mut()` behaves differently if expression `f` contains autoderef in it. This causes a weird error in #72225.\n\nWhen `f` is type checked, `Deref` is used (this is expected as we can't yet determine if we should use `Fn` or `FnMut`). When subsequently we determine the actual trait to be used, when using the `f.call_mut()` syntax the `Deref` is patched to `DerefMut`, while for the `(f)()` syntax case it is not.\n\nThis PR replicates the fixup for the first case.\n\nFixes #72225\nFixes #68590\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "html_url": "https://github.com/rust-lang/rust/commit/70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63b441aafbf52d6ba789ecc478455800c1a48df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/63b441aafbf52d6ba789ecc478455800c1a48df9", "html_url": "https://github.com/rust-lang/rust/commit/63b441aafbf52d6ba789ecc478455800c1a48df9"}, {"sha": "2b7d8588668bc79a1855a2c335572a1ac8ceaf34", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b7d8588668bc79a1855a2c335572a1ac8ceaf34", "html_url": "https://github.com/rust-lang/rust/commit/2b7d8588668bc79a1855a2c335572a1ac8ceaf34"}], "stats": {"total": 859, "additions": 467, "deletions": 392}, "files": [{"sha": "2570025959cb4f7320010f63837a7444209bd402", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -1,5 +1,5 @@\n use super::method::MethodCallee;\n-use super::{FnCtxt, Needs, PlaceOp};\n+use super::{FnCtxt, PlaceOp};\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -170,14 +170,13 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>, needs: Needs) -> Vec<Adjustment<'tcx>> {\n-        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx, needs))\n+    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n+        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx))\n     }\n \n     pub fn adjust_steps_as_infer_ok(\n         &self,\n         fcx: &FnCtxt<'a, 'tcx>,\n-        needs: Needs,\n     ) -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(self.cur_ty));\n@@ -186,7 +185,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n             .iter()\n             .map(|&(source, kind)| {\n                 if let AutoderefKind::Overloaded = kind {\n-                    fcx.try_overloaded_deref(self.span, source, needs).and_then(\n+                    fcx.try_overloaded_deref(self.span, source).and_then(\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n@@ -266,8 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         base_ty: Ty<'tcx>,\n-        needs: Needs,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        self.try_overloaded_place_op(span, base_ty, &[], needs, PlaceOp::Deref)\n+        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n     }\n }"}, {"sha": "fe200a0ad2a1c09423999f77a1daa5a7a7aabe24", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -1,6 +1,6 @@\n use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n-use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(self, Needs::None);\n+                let adjustments = autoderef.adjust_steps(self);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             &closure_sig,\n                         )\n                         .0;\n-                    let adjustments = autoderef.adjust_steps(self, Needs::None);\n+                    let adjustments = autoderef.adjust_steps(self);\n                     self.record_deferred_call_resolution(\n                         def_id,\n                         DeferredCallResolution {\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.try_overloaded_call_traits(call_expr, adjusted_ty, Some(arg_exprs))\n             .or_else(|| self.try_overloaded_call_traits(call_expr, adjusted_ty, None))\n             .map(|(autoref, method)| {\n-                let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+                let mut adjustments = autoderef.adjust_steps(self);\n                 adjustments.extend(autoref);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 CallStep::Overloaded(method)\n@@ -220,21 +220,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n                 let mut autoref = None;\n                 if borrow {\n-                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n-                        let mutbl = match mutbl {\n-                            hir::Mutability::Not => AutoBorrowMutability::Not,\n-                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                // For initial two-phase borrow\n-                                // deployment, conservatively omit\n-                                // overloaded function call ops.\n-                                allow_two_phase_borrow: AllowTwoPhase::No,\n-                            },\n-                        };\n-                        autoref = Some(Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                            target: method.sig.inputs()[0],\n-                        });\n-                    }\n+                    // Check for &self vs &mut self in the method signature. Since this is either\n+                    // the Fn or FnMut trait, it should be one of those.\n+                    let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind\n+                    {\n+                        (r, mutbl)\n+                    } else {\n+                        span_bug!(call_expr.span, \"input to call/call_mut is not a ref?\");\n+                    };\n+\n+                    let mutbl = match mutbl {\n+                        hir::Mutability::Not => AutoBorrowMutability::Not,\n+                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n+                            // For initial two-phase borrow\n+                            // deployment, conservatively omit\n+                            // overloaded function call ops.\n+                            allow_two_phase_borrow: AllowTwoPhase::No,\n+                        },\n+                    };\n+                    autoref = Some(Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                        target: method.sig.inputs()[0],\n+                    });\n                 }\n                 return Some((autoref, method));\n             }"}, {"sha": "1c34d71ee31847dcdb7cff52e53c319aac472ce4", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -51,7 +51,7 @@\n //! we may want to adjust precisely when coercions occur.\n \n use crate::astconv::AstConv;\n-use crate::check::{FnCtxt, Needs};\n+use crate::check::FnCtxt;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -421,9 +421,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             return success(vec![], ty, obligations);\n         }\n \n-        let needs = Needs::maybe_mut_place(mutbl_b);\n         let InferOk { value: mut adjustments, obligations: o } =\n-            autoderef.adjust_steps_as_infer_ok(self, needs);\n+            autoderef.adjust_steps_as_infer_ok(self);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "188f4a9401422fe65dff2048295808f09219a2f4", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 30, "deletions": 57, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -29,9 +29,7 @@ use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty;\n-use rustc_middle::ty::adjustment::{\n-    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n-};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n@@ -113,12 +111,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n \n-    pub(super) fn check_expr_with_expectation(\n+    fn check_expr_with_expectation_and_needs(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n+        needs: Needs,\n     ) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n+        let ty = self.check_expr_with_expectation(expr, expected);\n+\n+        // If the expression is used in a place whether mutable place is required\n+        // e.g. LHS of assignment, perform the conversion.\n+        if let Needs::MutPlace = needs {\n+            self.convert_place_derefs_to_mutable(expr);\n+        }\n+\n+        ty\n     }\n \n     pub(super) fn check_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n@@ -143,11 +150,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n-    fn check_expr_with_expectation_and_needs(\n+    pub(super) fn check_expr_with_expectation(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n         debug!(\">> type-checking: expr={:?} expected={:?}\", expr, expected);\n \n@@ -171,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let old_diverges = self.diverges.replace(Diverges::Maybe);\n         let old_has_errors = self.has_errors.replace(false);\n \n-        let ty = self.check_expr_kind(expr, expected, needs);\n+        let ty = self.check_expr_kind(expr, expected);\n \n         // Warn for non-block expressions with diverging children.\n         match expr.kind {\n@@ -213,9 +219,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n-        debug!(\"check_expr_kind(expr={:?}, expected={:?}, needs={:?})\", expr, expected, needs,);\n+        debug!(\"check_expr_kind(expr={:?}, expected={:?})\", expr, expected);\n \n         let tcx = self.tcx;\n         match expr.kind {\n@@ -226,9 +231,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_assign(expr, expected, lhs, rhs, span)\n             }\n             ExprKind::AssignOp(op, ref lhs, ref rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n-            ExprKind::Unary(unop, ref oprnd) => {\n-                self.check_expr_unary(unop, oprnd, expected, needs, expr)\n-            }\n+            ExprKind::Unary(unop, ref oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n             ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n@@ -264,7 +267,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Block(ref body, _) => self.check_block_with_expected(&body, expected),\n             ExprKind::Call(ref callee, ref args) => self.check_call(expr, &callee, args, expected),\n             ExprKind::MethodCall(ref segment, span, ref args, _) => {\n-                self.check_method_call(expr, segment, span, args, expected, needs)\n+                self.check_method_call(expr, segment, span, args, expected)\n             }\n             ExprKind::Cast(ref e, ref t) => self.check_expr_cast(e, t, expr),\n             ExprKind::Type(ref e, ref t) => {\n@@ -281,8 +284,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Struct(ref qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(ref base, field) => self.check_field(expr, needs, &base, field),\n-            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, needs, expr),\n+            ExprKind::Field(ref base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(ref value, ref src) => self.check_expr_yield(value, expr, src),\n             hir::ExprKind::Err => tcx.ty_error(),\n         }\n@@ -302,48 +305,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         unop: hir::UnOp,\n         oprnd: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected_inner = match unop {\n             hir::UnOp::UnNot | hir::UnOp::UnNeg => expected,\n             hir::UnOp::UnDeref => NoExpectation,\n         };\n-        let needs = match unop {\n-            hir::UnOp::UnDeref => needs,\n-            _ => Needs::None,\n-        };\n-        let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd, expected_inner, needs);\n+        let mut oprnd_t = self.check_expr_with_expectation(&oprnd, expected_inner);\n \n         if !oprnd_t.references_error() {\n             oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n             match unop {\n                 hir::UnOp::UnDeref => {\n-                    if let Some(mt) = oprnd_t.builtin_deref(true) {\n-                        oprnd_t = mt.ty;\n-                    } else if let Some(ok) = self.try_overloaded_deref(expr.span, oprnd_t, needs) {\n-                        let method = self.register_infer_ok_obligations(ok);\n-                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n-                            let mutbl = match mutbl {\n-                                hir::Mutability::Not => AutoBorrowMutability::Not,\n-                                hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                    // (It shouldn't actually matter for unary ops whether\n-                                    // we enable two-phase borrows or not, since a unary\n-                                    // op has no additional operands.)\n-                                    allow_two_phase_borrow: AllowTwoPhase::No,\n-                                },\n-                            };\n-                            self.apply_adjustments(\n-                                oprnd,\n-                                vec![Adjustment {\n-                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                    target: method.sig.inputs()[0],\n-                                }],\n-                            );\n-                        }\n-                        oprnd_t = self.make_overloaded_place_return_type(method).ty;\n-                        self.write_method_call(expr.hir_id, method);\n+                    if let Some(ty) = self.lookup_derefing(expr, oprnd, oprnd_t) {\n+                        oprnd_t = ty;\n                     } else {\n                         let mut err = type_error_struct!(\n                             tcx.sess,\n@@ -405,8 +381,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => NoExpectation,\n             }\n         });\n-        let needs = Needs::maybe_mut_place(mutbl);\n-        let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n+        let ty =\n+            self.check_expr_with_expectation_and_needs(&oprnd, hint, Needs::maybe_mut_place(mutbl));\n \n         let tm = ty::TypeAndMut { ty, mutbl };\n         match kind {\n@@ -861,10 +837,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n         let rcvr = &args[0];\n-        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n+        let rcvr_t = self.check_expr(&rcvr);\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n \n@@ -1443,11 +1418,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_field(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        needs: Needs,\n         base: &'tcx hir::Expr<'tcx>,\n         field: Ident,\n     ) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_needs(base, needs);\n+        let expr_t = self.check_expr(base);\n         let expr_t = self.structurally_resolved_type(base.span, expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n@@ -1467,7 +1441,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // of error recovery.\n                         self.write_field_index(expr.hir_id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(self, needs);\n+                            let adjustments = autoderef.adjust_steps(self);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize(self);\n \n@@ -1482,7 +1456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(self, needs);\n+                                let adjustments = autoderef.adjust_steps(self);\n                                 self.apply_adjustments(base, adjustments);\n                                 autoderef.finalize(self);\n \n@@ -1721,10 +1695,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         base: &'tcx hir::Expr<'tcx>,\n         idx: &'tcx hir::Expr<'tcx>,\n-        needs: Needs,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n-        let base_t = self.check_expr_with_needs(&base, needs);\n+        let base_t = self.check_expr(&base);\n         let idx_t = self.check_expr(&idx);\n \n         if base_t.references_error() {\n@@ -1733,7 +1706,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             idx_t\n         } else {\n             let base_t = self.structurally_resolved_type(base.span, base_t);\n-            match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n+            match self.lookup_indexing(expr, base, base_t, idx_t) {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n                     self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);"}, {"sha": "6844c9416af8a7a1a6a9c5b37a14afe11cb1ef4a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 153, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -1,12 +1,12 @@\n use super::{probe, MethodCallee};\n \n use crate::astconv::AstConv;\n-use crate::check::{callee, FnCtxt, Needs, PlaceOp};\n+use crate::check::{callee, FnCtxt};\n use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n use rustc_hir as hir;\n use rustc_infer::infer::{self, InferOk};\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -119,11 +119,6 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         // Create the final `MethodCallee`.\n         let callee = MethodCallee { def_id: pick.item.def_id, substs: all_substs, sig: method_sig };\n-\n-        if let Some(hir::Mutability::Mut) = pick.autoref {\n-            self.convert_place_derefs_to_mutable();\n-        }\n-\n         ConfirmResult { callee, illegal_sized_bound }\n     }\n \n@@ -149,7 +144,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+        let mut adjustments = autoderef.adjust_steps(self);\n \n         let mut target = autoderef.unambiguous_final_ty(self);\n \n@@ -415,151 +410,6 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         self.register_wf_obligation(fty.into(), self.span, traits::MiscObligation);\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // RECONCILIATION\n-\n-    /// When we select a method with a mutable autoref, we have to go convert any\n-    /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n-    /// respectively.\n-    fn convert_place_derefs_to_mutable(&self) {\n-        // Gather up expressions we want to munge.\n-        let mut exprs = vec![self.self_expr];\n-\n-        loop {\n-            match exprs.last().unwrap().kind {\n-                hir::ExprKind::Field(ref expr, _)\n-                | hir::ExprKind::Index(ref expr, _)\n-                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n-                _ => break,\n-            }\n-        }\n-\n-        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n-\n-        // Fix up autoderefs and derefs.\n-        for (i, &expr) in exprs.iter().rev().enumerate() {\n-            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n-\n-            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n-            // overloaded place ops, and will be fixed by them in order to get\n-            // the correct region.\n-            let mut source = self.node_ty(expr.hir_id);\n-            // Do not mutate adjustments in place, but rather take them,\n-            // and replace them after mutating them, to avoid having the\n-            // tables borrowed during (`deref_mut`) method resolution.\n-            let previous_adjustments =\n-                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n-            if let Some(mut adjustments) = previous_adjustments {\n-                let needs = Needs::MutPlace;\n-                for adjustment in &mut adjustments {\n-                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n-                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n-                            let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n-                                *deref = OverloadedDeref { region, mutbl };\n-                            }\n-                        }\n-                    }\n-                    source = adjustment.target;\n-                }\n-                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n-            }\n-\n-            match expr.kind {\n-                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n-                    // We need to get the final type in case dereferences were needed for the trait\n-                    // to apply (#72002).\n-                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n-                    self.convert_place_op_to_mutable(\n-                        PlaceOp::Index,\n-                        expr,\n-                        base_expr,\n-                        &[index_expr_ty],\n-                    );\n-                }\n-                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n-                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    fn convert_place_op_to_mutable(\n-        &self,\n-        op: PlaceOp,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &hir::Expr<'_>,\n-        arg_tys: &[Ty<'tcx>],\n-    ) {\n-        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n-        if !self.tables.borrow().is_method_call(expr) {\n-            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n-            return;\n-        }\n-\n-        let base_ty = self\n-            .tables\n-            .borrow()\n-            .expr_adjustments(base_expr)\n-            .last()\n-            .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n-        let base_ty = self.resolve_vars_if_possible(&base_ty);\n-\n-        // Need to deref because overloaded place ops take self by-reference.\n-        let base_ty =\n-            base_ty.builtin_deref(false).expect(\"place op takes something that is not a ref\").ty;\n-\n-        let method = self.try_overloaded_place_op(expr.span, base_ty, arg_tys, Needs::MutPlace, op);\n-        let method = match method {\n-            Some(ok) => self.register_infer_ok_obligations(ok),\n-            None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\"),\n-        };\n-        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n-        self.write_method_call(expr.hir_id, method);\n-\n-        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind {\n-            (r, mutbl)\n-        } else {\n-            span_bug!(expr.span, \"input to place op is not a ref?\");\n-        };\n-\n-        // Convert the autoref in the base expr to mutable with the correct\n-        // region and mutability.\n-        let base_expr_ty = self.node_ty(base_expr.hir_id);\n-        if let Some(adjustments) =\n-            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n-        {\n-            let mut source = base_expr_ty;\n-            for adjustment in &mut adjustments[..] {\n-                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n-                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n-                    let mutbl = match mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // For initial two-phase borrow\n-                            // deployment, conservatively omit\n-                            // overloaded operators.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n-                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n-                    adjustment.target =\n-                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n-                }\n-                source = adjustment.target;\n-            }\n-\n-            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n-\n-            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n-                adjustments[..]\n-            {\n-                *target = method.sig.inputs()[0];\n-            }\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n "}, {"sha": "2ece8e8c2842369a8c7fe0ea88413700eab89560", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 150, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -79,6 +79,7 @@ pub mod intrinsic;\n pub mod method;\n mod op;\n mod pat;\n+mod place_op;\n mod regionck;\n mod upvar;\n mod wfcheck;\n@@ -114,7 +115,7 @@ use rustc_infer::infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin,\n use rustc_middle::hir::map::blocks::FnLikeNode;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::adjustment::{\n-    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n+    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n@@ -156,7 +157,6 @@ use std::slice;\n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n-use self::autoderef::Autoderef;\n use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n use self::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n@@ -3333,6 +3333,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n+        let autoborrow_mut = adj.iter().any(|adj| {\n+            matches!(adj, &Adjustment {\n+                kind: Adjust::Borrow(AutoBorrow::Ref(_, AutoBorrowMutability::Mut { .. })),\n+                ..\n+            })\n+        });\n+\n         match self.tables.borrow_mut().adjustments_mut().entry(expr.hir_id) {\n             Entry::Vacant(entry) => {\n                 entry.insert(adj);\n@@ -3362,6 +3369,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 *entry.get_mut() = adj;\n             }\n         }\n+\n+        // If there is an mutable auto-borrow, it is equivalent to `&mut <expr>`.\n+        // In this case implicit use of `Deref` and `Index` within `<expr>` should\n+        // instead be `DerefMut` and `IndexMut`, so fix those up.\n+        if autoborrow_mut {\n+            self.convert_place_derefs_to_mutable(expr);\n+        }\n     }\n \n     /// Basically whenever we are converting from a type scheme into\n@@ -3753,154 +3767,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ret_ty.builtin_deref(true).unwrap()\n     }\n \n-    fn lookup_indexing(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &'tcx hir::Expr<'tcx>,\n-        base_ty: Ty<'tcx>,\n-        idx_ty: Ty<'tcx>,\n-        needs: Needs,\n-    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        // FIXME(#18741) -- this is almost but not quite the same as the\n-        // autoderef that normal method probing does. They could likely be\n-        // consolidated.\n-\n-        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n-        let mut result = None;\n-        while result.is_none() && autoderef.next().is_some() {\n-            result = self.try_index_step(expr, base_expr, &autoderef, needs, idx_ty);\n-        }\n-        autoderef.finalize(self);\n-        result\n-    }\n-\n-    /// To type-check `base_expr[index_expr]`, we progressively autoderef\n-    /// (and otherwise adjust) `base_expr`, looking for a type which either\n-    /// supports builtin indexing or overloaded indexing.\n-    /// This loop implements one step in that search; the autoderef loop\n-    /// is implemented by `lookup_indexing`.\n-    fn try_index_step(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &hir::Expr<'_>,\n-        autoderef: &Autoderef<'a, 'tcx>,\n-        needs: Needs,\n-        index_ty: Ty<'tcx>,\n-    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n-        debug!(\n-            \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n-             index_ty={:?})\",\n-            expr, base_expr, adjusted_ty, index_ty\n-        );\n-\n-        for &unsize in &[false, true] {\n-            let mut self_ty = adjusted_ty;\n-            if unsize {\n-                // We only unsize arrays here.\n-                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n-                    self_ty = self.tcx.mk_slice(element_ty);\n-                } else {\n-                    continue;\n-                }\n-            }\n-\n-            // If some lookup succeeds, write callee into table and extract index/element\n-            // type from the method signature.\n-            // If some lookup succeeded, install method in table\n-            let input_ty = self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::AutoDeref,\n-                span: base_expr.span,\n-            });\n-            let method = self.try_overloaded_place_op(\n-                expr.span,\n-                self_ty,\n-                &[input_ty],\n-                needs,\n-                PlaceOp::Index,\n-            );\n-\n-            let result = method.map(|ok| {\n-                debug!(\"try_index_step: success, using overloaded indexing\");\n-                let method = self.register_infer_ok_obligations(ok);\n-\n-                let mut adjustments = autoderef.adjust_steps(self, needs);\n-                if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].kind {\n-                    let mutbl = match r_mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // Indexing can be desugared to a method call,\n-                            // so maybe we could use two-phase here.\n-                            // See the documentation of AllowTwoPhase for why that's\n-                            // not the case today.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n-                    adjustments.push(Adjustment {\n-                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                        target: self\n-                            .tcx\n-                            .mk_ref(region, ty::TypeAndMut { mutbl: r_mutbl, ty: adjusted_ty }),\n-                    });\n-                }\n-                if unsize {\n-                    adjustments.push(Adjustment {\n-                        kind: Adjust::Pointer(PointerCast::Unsize),\n-                        target: method.sig.inputs()[0],\n-                    });\n-                }\n-                self.apply_adjustments(base_expr, adjustments);\n-\n-                self.write_method_call(expr.hir_id, method);\n-                (input_ty, self.make_overloaded_place_return_type(method).ty)\n-            });\n-            if result.is_some() {\n-                return result;\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, Ident) {\n-        let (tr, name) = match (op, is_mut) {\n-            (PlaceOp::Deref, false) => (self.tcx.lang_items().deref_trait(), sym::deref),\n-            (PlaceOp::Deref, true) => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n-            (PlaceOp::Index, false) => (self.tcx.lang_items().index_trait(), sym::index),\n-            (PlaceOp::Index, true) => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n-        };\n-        (tr, Ident::with_dummy_span(name))\n-    }\n-\n-    fn try_overloaded_place_op(\n-        &self,\n-        span: Span,\n-        base_ty: Ty<'tcx>,\n-        arg_tys: &[Ty<'tcx>],\n-        needs: Needs,\n-        op: PlaceOp,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        debug!(\"try_overloaded_place_op({:?},{:?},{:?},{:?})\", span, base_ty, needs, op);\n-\n-        // Try Mut first, if needed.\n-        let (mut_tr, mut_op) = self.resolve_place_op(op, true);\n-        let method = match (needs, mut_tr) {\n-            (Needs::MutPlace, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, mut_op, trait_did, base_ty, Some(arg_tys))\n-            }\n-            _ => None,\n-        };\n-\n-        // Otherwise, fall back to the immutable version.\n-        let (imm_tr, imm_op) = self.resolve_place_op(op, false);\n-        match (method, imm_tr) {\n-            (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, imm_op, trait_did, base_ty, Some(arg_tys))\n-            }\n-            (method, _) => method,\n-        }\n-    }\n-\n     fn check_method_argument_types(\n         &self,\n         sp: Span,"}, {"sha": "56804792b19442a04481e078866ac341fb5f2a69", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -1,7 +1,7 @@\n //! Code related to processing overloaded binary and unary operators.\n \n use super::method::MethodCallee;\n-use super::{FnCtxt, Needs};\n+use super::FnCtxt;\n use rustc_errors::{self, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // trait matching creating lifetime constraints that are too strict.\n                 // e.g., adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n                 // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-                let lhs_ty = self.check_expr_with_needs(lhs_expr, Needs::None);\n+                let lhs_ty = self.check_expr(lhs_expr);\n                 let fresh_var = self.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: lhs_expr.span,\n@@ -177,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // equivalence on the LHS of an assign-op like `+=`;\n                 // overwritten or mutably-borrowed places cannot be\n                 // coerced to a supertype.\n-                self.check_expr_with_needs(lhs_expr, Needs::MutPlace)\n+                self.check_expr(lhs_expr)\n             }\n         };\n         let lhs_ty = self.resolve_vars_with_obligations(lhs_ty);"}, {"sha": "d1c22cd1ac03ebe0d18747d73f5a0b6e38198517", "filename": "src/librustc_typeck/check/place_op.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -0,0 +1,336 @@\n+use crate::check::autoderef::Autoderef;\n+use crate::check::method::MethodCallee;\n+use crate::check::{FnCtxt, PlaceOp};\n+use rustc_hir as hir;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::InferOk;\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n+use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::Span;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// Type-check `*oprnd_expr` with `oprnd_expr` type-checked already.\n+    pub(super) fn lookup_derefing(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        oprnd_expr: &'tcx hir::Expr<'tcx>,\n+        oprnd_ty: Ty<'tcx>,\n+    ) -> Option<Ty<'tcx>> {\n+        if let Some(mt) = oprnd_ty.builtin_deref(true) {\n+            return Some(mt.ty);\n+        }\n+\n+        let ok = self.try_overloaded_deref(expr.span, oprnd_ty)?;\n+        let method = self.register_infer_ok_obligations(ok);\n+        if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+            self.apply_adjustments(\n+                oprnd_expr,\n+                vec![Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                    target: method.sig.inputs()[0],\n+                }],\n+            );\n+        } else {\n+            span_bug!(expr.span, \"input to deref is not a ref?\");\n+        }\n+        let ty = self.make_overloaded_place_return_type(method).ty;\n+        self.write_method_call(expr.hir_id, method);\n+        Some(ty)\n+    }\n+\n+    /// Type-check `*base_expr[index_expr]` with `base_expr` and `index_expr` type-checked already.\n+    pub(super) fn lookup_indexing(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &'tcx hir::Expr<'tcx>,\n+        base_ty: Ty<'tcx>,\n+        idx_ty: Ty<'tcx>,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n+        // FIXME(#18741) -- this is almost but not quite the same as the\n+        // autoderef that normal method probing does. They could likely be\n+        // consolidated.\n+\n+        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n+        let mut result = None;\n+        while result.is_none() && autoderef.next().is_some() {\n+            result = self.try_index_step(expr, base_expr, &autoderef, idx_ty);\n+        }\n+        autoderef.finalize(self);\n+        result\n+    }\n+\n+    /// To type-check `base_expr[index_expr]`, we progressively autoderef\n+    /// (and otherwise adjust) `base_expr`, looking for a type which either\n+    /// supports builtin indexing or overloaded indexing.\n+    /// This loop implements one step in that search; the autoderef loop\n+    /// is implemented by `lookup_indexing`.\n+    fn try_index_step(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n+        autoderef: &Autoderef<'a, 'tcx>,\n+        index_ty: Ty<'tcx>,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n+        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        debug!(\n+            \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n+             index_ty={:?})\",\n+            expr, base_expr, adjusted_ty, index_ty\n+        );\n+\n+        for &unsize in &[false, true] {\n+            let mut self_ty = adjusted_ty;\n+            if unsize {\n+                // We only unsize arrays here.\n+                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n+                    self_ty = self.tcx.mk_slice(element_ty);\n+                } else {\n+                    continue;\n+                }\n+            }\n+\n+            // If some lookup succeeds, write callee into table and extract index/element\n+            // type from the method signature.\n+            // If some lookup succeeded, install method in table\n+            let input_ty = self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::AutoDeref,\n+                span: base_expr.span,\n+            });\n+            let method =\n+                self.try_overloaded_place_op(expr.span, self_ty, &[input_ty], PlaceOp::Index);\n+\n+            let result = method.map(|ok| {\n+                debug!(\"try_index_step: success, using overloaded indexing\");\n+                let method = self.register_infer_ok_obligations(ok);\n+\n+                let mut adjustments = autoderef.adjust_steps(self);\n+                if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                        target: self.tcx.mk_ref(\n+                            region,\n+                            ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: adjusted_ty },\n+                        ),\n+                    });\n+                } else {\n+                    span_bug!(expr.span, \"input to index is not a ref?\");\n+                }\n+                if unsize {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Pointer(PointerCast::Unsize),\n+                        target: method.sig.inputs()[0],\n+                    });\n+                }\n+                self.apply_adjustments(base_expr, adjustments);\n+\n+                self.write_method_call(expr.hir_id, method);\n+                (input_ty, self.make_overloaded_place_return_type(method).ty)\n+            });\n+            if result.is_some() {\n+                return result;\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Try to resolve an overloaded place op. We only deal with the immutable\n+    /// variant here (Deref/Index). In some contexts we would need the mutable\n+    /// variant (DerefMut/IndexMut); those would be later converted by\n+    /// `convert_place_derefs_to_mutable`.\n+    pub(super) fn try_overloaded_place_op(\n+        &self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        arg_tys: &[Ty<'tcx>],\n+        op: PlaceOp,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\"try_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n+\n+        let (imm_tr, imm_op) = match op {\n+            PlaceOp::Deref => (self.tcx.lang_items().deref_trait(), sym::deref),\n+            PlaceOp::Index => (self.tcx.lang_items().index_trait(), sym::index),\n+        };\n+        imm_tr.and_then(|trait_did| {\n+            self.lookup_method_in_trait(\n+                span,\n+                Ident::with_dummy_span(imm_op),\n+                trait_did,\n+                base_ty,\n+                Some(arg_tys),\n+            )\n+        })\n+    }\n+\n+    fn try_mutable_overloaded_place_op(\n+        &self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        arg_tys: &[Ty<'tcx>],\n+        op: PlaceOp,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\"try_mutable_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n+\n+        let (mut_tr, mut_op) = match op {\n+            PlaceOp::Deref => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n+            PlaceOp::Index => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n+        };\n+        mut_tr.and_then(|trait_did| {\n+            self.lookup_method_in_trait(\n+                span,\n+                Ident::with_dummy_span(mut_op),\n+                trait_did,\n+                base_ty,\n+                Some(arg_tys),\n+            )\n+        })\n+    }\n+\n+    /// Convert auto-derefs, indices, etc of an expression from `Deref` and `Index`\n+    /// into `DerefMut` and `IndexMut` respectively.\n+    ///\n+    /// This is a second pass of typechecking derefs/indices. We need this we do not\n+    /// always know whether a place needs to be mutable or not in the first pass.\n+    /// This happens whether there is an implicit mutable reborrow, e.g. when the type\n+    /// is used as the receiver of a method call.\n+    pub fn convert_place_derefs_to_mutable(&self, expr: &hir::Expr<'_>) {\n+        // Gather up expressions we want to munge.\n+        let mut exprs = vec![expr];\n+\n+        loop {\n+            match exprs.last().unwrap().kind {\n+                hir::ExprKind::Field(ref expr, _)\n+                | hir::ExprKind::Index(ref expr, _)\n+                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n+                _ => break,\n+            }\n+        }\n+\n+        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n+\n+        // Fix up autoderefs and derefs.\n+        for (i, &expr) in exprs.iter().rev().enumerate() {\n+            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+\n+            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n+            // overloaded place ops, and will be fixed by them in order to get\n+            // the correct region.\n+            let mut source = self.node_ty(expr.hir_id);\n+            // Do not mutate adjustments in place, but rather take them,\n+            // and replace them after mutating them, to avoid having the\n+            // tables borrowed during (`deref_mut`) method resolution.\n+            let previous_adjustments =\n+                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n+            if let Some(mut adjustments) = previous_adjustments {\n+                for adjustment in &mut adjustments {\n+                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n+                        if let Some(ok) = self.try_mutable_overloaded_place_op(\n+                            expr.span,\n+                            source,\n+                            &[],\n+                            PlaceOp::Deref,\n+                        ) {\n+                            let method = self.register_infer_ok_obligations(ok);\n+                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n+                                *deref = OverloadedDeref { region, mutbl };\n+                            }\n+                        }\n+                    }\n+                    source = adjustment.target;\n+                }\n+                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n+            }\n+\n+            match expr.kind {\n+                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n+                    // We need to get the final type in case dereferences were needed for the trait\n+                    // to apply (#72002).\n+                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n+                    self.convert_place_op_to_mutable(\n+                        PlaceOp::Index,\n+                        expr,\n+                        base_expr,\n+                        &[index_expr_ty],\n+                    );\n+                }\n+                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n+                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn convert_place_op_to_mutable(\n+        &self,\n+        op: PlaceOp,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n+        arg_tys: &[Ty<'tcx>],\n+    ) {\n+        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n+        if !self.tables.borrow().is_method_call(expr) {\n+            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n+            return;\n+        }\n+\n+        // Need to deref because overloaded place ops take self by-reference.\n+        let base_ty = self\n+            .tables\n+            .borrow()\n+            .expr_ty_adjusted(base_expr)\n+            .builtin_deref(false)\n+            .expect(\"place op takes something that is not a ref\")\n+            .ty;\n+\n+        let method = self.try_mutable_overloaded_place_op(expr.span, base_ty, arg_tys, op);\n+        let method = match method {\n+            Some(ok) => self.register_infer_ok_obligations(ok),\n+            // Couldn't find the mutable variant of the place op, keep the\n+            // current, immutable version.\n+            None => return,\n+        };\n+        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n+        self.write_method_call(expr.hir_id, method);\n+\n+        let region = if let ty::Ref(r, _, hir::Mutability::Mut) = method.sig.inputs()[0].kind {\n+            r\n+        } else {\n+            span_bug!(expr.span, \"input to mutable place op is not a mut ref?\");\n+        };\n+\n+        // Convert the autoref in the base expr to mutable with the correct\n+        // region and mutability.\n+        let base_expr_ty = self.node_ty(base_expr.hir_id);\n+        if let Some(adjustments) =\n+            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n+        {\n+            let mut source = base_expr_ty;\n+            for adjustment in &mut adjustments[..] {\n+                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n+                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    let mutbl = AutoBorrowMutability::Mut {\n+                        // Deref/indexing can be desugared to a method call,\n+                        // so maybe we could use two-phase here.\n+                        // See the documentation of AllowTwoPhase for why that's\n+                        // not the case today.\n+                        allow_two_phase_borrow: AllowTwoPhase::No,\n+                    };\n+                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n+                    adjustment.target =\n+                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n+                }\n+                source = adjustment.target;\n+            }\n+\n+            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n+            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n+                adjustments[..]\n+            {\n+                *target = method.sig.inputs()[0];\n+            }\n+        }\n+    }\n+}"}, {"sha": "e4436260e70a07ac26d90c715b3995087ec58379", "filename": "src/test/ui/typeck/issue-68590-reborrow-through-derefmut.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Ftest%2Fui%2Ftypeck%2Fissue-68590-reborrow-through-derefmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Ftest%2Fui%2Ftypeck%2Fissue-68590-reborrow-through-derefmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-68590-reborrow-through-derefmut.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+\n+// rust-lang/rust#68590: confusing diagnostics when reborrowing through DerefMut.\n+\n+use std::cell::RefCell;\n+\n+struct A;\n+\n+struct S<'a> {\n+    a: &'a mut A,\n+}\n+\n+fn take_a(_: &mut A) {}\n+\n+fn test<'a>(s: &RefCell<S<'a>>) {\n+    let mut guard = s.borrow_mut();\n+    take_a(guard.a);\n+    let _s2 = S { a: guard.a };\n+}\n+\n+fn main() {\n+    let a = &mut A;\n+    let s = RefCell::new(S { a });\n+    test(&s);\n+}"}, {"sha": "3ea05389f04a0b7ae8c2fdd3c8f31f34e37b1178", "filename": "src/test/ui/typeck/issue-72225-call-fnmut-through-derefmut.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Ftest%2Fui%2Ftypeck%2Fissue-72225-call-fnmut-through-derefmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70622db43d5e0a58f8fe66ff15115e4fcbb5c274/src%2Ftest%2Fui%2Ftypeck%2Fissue-72225-call-fnmut-through-derefmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-72225-call-fnmut-through-derefmut.rs?ref=70622db43d5e0a58f8fe66ff15115e4fcbb5c274", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+// rust-lang/rust#72225: confusing diagnostics when calling FnMut through DerefMut.\n+\n+use std::cell::RefCell;\n+\n+struct S {\n+    f: Box<dyn FnMut()>\n+}\n+\n+fn test(s: &RefCell<S>) {\n+    let mut guard = s.borrow_mut();\n+    (guard.f)();\n+}\n+\n+fn main() {\n+    let s = RefCell::new(S {\n+        f: Box::new(|| ())\n+    });\n+    test(&s);\n+}"}]}