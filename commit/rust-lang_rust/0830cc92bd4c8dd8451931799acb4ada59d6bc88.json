{"sha": "0830cc92bd4c8dd8451931799acb4ada59d6bc88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MzBjYzkyYmQ0YzhkZDg0NTE5MzE3OTlhY2I0YWRhNTlkNmJjODg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-07-16T06:58:29Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-07-16T06:58:29Z"}, "message": "Revert \"Clean up LLVM module naming (just use CodegenUnit names).\"\n\nThis reverts commit f6894ebe664d111259a91a2b5fcc1236ca413436.", "tree": {"sha": "3c274f6daca2070fe76c6238370ae2b60be08452", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c274f6daca2070fe76c6238370ae2b60be08452"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0830cc92bd4c8dd8451931799acb4ada59d6bc88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0830cc92bd4c8dd8451931799acb4ada59d6bc88", "html_url": "https://github.com/rust-lang/rust/commit/0830cc92bd4c8dd8451931799acb4ada59d6bc88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0830cc92bd4c8dd8451931799acb4ada59d6bc88/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89aa0bc108d57d4d8205d95551eb2586689568e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/89aa0bc108d57d4d8205d95551eb2586689568e8", "html_url": "https://github.com/rust-lang/rust/commit/89aa0bc108d57d4d8205d95551eb2586689568e8"}], "stats": {"total": 108, "additions": 69, "deletions": 39}, "files": [{"sha": "a7f0910a6fcccff6e1fe9eb48b1ea26d213499b9", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=0830cc92bd4c8dd8451931799acb4ada59d6bc88", "patch": "@@ -45,6 +45,13 @@ use std::process::{Output, Stdio};\n use std::str;\n use syntax::attr;\n \n+/// The LLVM module name containing crate-metadata. This includes a `.` on\n+/// purpose, so it cannot clash with the name of a user-defined module.\n+pub const METADATA_MODULE_NAME: &'static str = \"crate.metadata\";\n+\n+// same as for metadata above, but for allocator shim\n+pub const ALLOCATOR_MODULE_NAME: &'static str = \"crate.allocator\";\n+\n pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n                                   invalid_output_for_target, build_link_meta, out_filename,\n                                   check_file_is_writeable};"}, {"sha": "ef03e76f946822de90eadb6b784ab153d66f0e7d", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=0830cc92bd4c8dd8451931799acb4ada59d6bc88", "patch": "@@ -238,7 +238,7 @@ fn fat_lto(cgcx: &CodegenContext,\n         .expect(\"must be codegen'ing at least one module\");\n     let module = modules.remove(costliest_module);\n     let llmod = module.llvm().expect(\"can't lto pre-codegened modules\").llmod;\n-    info!(\"using {:?} as a base module\", module.name);\n+    info!(\"using {:?} as a base module\", module.llmod_id);\n \n     // For all other modules we codegened we'll need to link them into our own\n     // bitcode. All modules were codegened in their own LLVM context, however,\n@@ -248,7 +248,7 @@ fn fat_lto(cgcx: &CodegenContext,\n     for module in modules {\n         let llvm = module.llvm().expect(\"can't lto pre-codegened modules\");\n         let buffer = ModuleBuffer::new(llvm.llmod);\n-        let llmod_id = CString::new(&module.name[..]).unwrap();\n+        let llmod_id = CString::new(&module.llmod_id[..]).unwrap();\n         serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n     }\n \n@@ -376,9 +376,9 @@ fn thin_lto(cgcx: &CodegenContext,\n         //        the most expensive portion of this small bit of global\n         //        analysis!\n         for (i, module) in modules.iter().enumerate() {\n-            info!(\"local module: {} - {}\", i, module.name);\n+            info!(\"local module: {} - {}\", i, module.llmod_id);\n             let llvm = module.llvm().expect(\"can't lto precodegened module\");\n-            let name = CString::new(module.name.clone()).unwrap();\n+            let name = CString::new(module.llmod_id.clone()).unwrap();\n             let buffer = ThinBuffer::new(llvm.llmod);\n             thin_modules.push(llvm::ThinLTOModule {\n                 identifier: name.as_ptr(),\n@@ -387,7 +387,7 @@ fn thin_lto(cgcx: &CodegenContext,\n             });\n             thin_buffers.push(buffer);\n             module_names.push(name);\n-            timeline.record(&module.name);\n+            timeline.record(&module.llmod_id);\n         }\n \n         // FIXME: All upstream crates are deserialized internally in the\n@@ -676,6 +676,7 @@ impl ThinModule {\n                 llcx,\n                 tm,\n             }),\n+            llmod_id: self.name().to_string(),\n             name: self.name().to_string(),\n             kind: ModuleKind::Regular,\n         };"}, {"sha": "d36142af56c6540ad15af51d052e1bace989f8c9", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=0830cc92bd4c8dd8451931799acb4ada59d6bc88", "patch": "@@ -694,7 +694,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n \n         if config.emit_bc_compressed {\n             let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n-            let data = bytecode::encode(&module.name, data);\n+            let data = bytecode::encode(&module.llmod_id, data);\n             if let Err(e) = fs::write(&dst, data) {\n                 diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n             }\n@@ -1306,6 +1306,7 @@ fn execute_work_item(cgcx: &CodegenContext,\n         assert_eq!(bytecode_compressed.is_some(), config.emit_bc_compressed);\n \n         Ok(WorkItemResult::Compiled(CompiledModule {\n+            llmod_id: module.llmod_id.clone(),\n             name: module_name,\n             kind: ModuleKind::Regular,\n             pre_existing: true,"}, {"sha": "9a625720f4d09e90c7dba73bd0e11906660cf3cc", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=0830cc92bd4c8dd8451931799acb4ada59d6bc88", "patch": "@@ -739,18 +739,15 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let link_meta = link::build_link_meta(crate_hash);\n \n     // Codegen the metadata.\n-    let metadata_cgu_name = CodegenUnit::build_cgu_name(tcx,\n-                                                        LOCAL_CRATE,\n-                                                        &[\"crate\"],\n-                                                        Some(\"metadata\")).as_str()\n-                                                                         .to_string();\n+    let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata) =\n         time(tcx.sess, \"write metadata\", || {\n-            write_metadata(tcx, &metadata_cgu_name, &link_meta)\n+            write_metadata(tcx, llmod_id, &link_meta)\n         });\n \n     let metadata_module = ModuleCodegen {\n-        name: metadata_cgu_name,\n+        name: link::METADATA_MODULE_NAME.to_string(),\n+        llmod_id: llmod_id.to_string(),\n         source: ModuleSource::Codegened(ModuleLlvm {\n             llcx: metadata_llcx,\n             llmod: metadata_llmod,\n@@ -813,30 +810,26 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Codegen an allocator shim, if any\n     let allocator_module = if let Some(kind) = *tcx.sess.allocator_kind.get() {\n-        let llmod_id = CodegenUnit::build_cgu_name(tcx,\n-                                                   LOCAL_CRATE,\n-                                                   &[\"crate\"],\n-                                                   Some(\"allocator\")).as_str()\n-                                                                     .to_string();\n-        let (llcx, llmod) = unsafe {\n-            context::create_context_and_module(tcx.sess, &llmod_id)\n-        };\n-        let modules = ModuleLlvm {\n-            llmod,\n-            llcx,\n-            tm: create_target_machine(tcx.sess, false),\n-        };\n-        time(tcx.sess, \"write allocator module\", || {\n-            unsafe {\n+        unsafe {\n+            let llmod_id = \"allocator\";\n+            let (llcx, llmod) =\n+                context::create_context_and_module(tcx.sess, llmod_id);\n+            let modules = ModuleLlvm {\n+                llmod,\n+                llcx,\n+                tm: create_target_machine(tcx.sess, false),\n+            };\n+            time(tcx.sess, \"write allocator module\", || {\n                 allocator::codegen(tcx, &modules, kind)\n-            }\n-        });\n+            });\n \n-        Some(ModuleCodegen {\n-            name: llmod_id,\n-            source: ModuleSource::Codegened(modules),\n-            kind: ModuleKind::Allocator,\n-        })\n+            Some(ModuleCodegen {\n+                name: link::ALLOCATOR_MODULE_NAME.to_string(),\n+                llmod_id: llmod_id.to_string(),\n+                source: ModuleSource::Codegened(modules),\n+                kind: ModuleKind::Allocator,\n+            })\n+        }\n     } else {\n         None\n     };\n@@ -879,10 +872,21 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // succeed it means that none of the dependencies has changed\n                 // and we can safely re-use.\n                 if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, dep_node) {\n+                    // Append \".rs\" to LLVM module identifier.\n+                    //\n+                    // LLVM code generator emits a \".file filename\" directive\n+                    // for ELF backends. Value of the \"filename\" is set as the\n+                    // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+                    // crashes if the module identifier is same as other symbols\n+                    // such as a function name in the module.\n+                    // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+                    let llmod_id = format!(\"{}.rs\", cgu.name());\n+\n                     let module = ModuleCodegen {\n                         name: cgu.name().to_string(),\n                         source: ModuleSource::Preexisting(buf),\n                         kind: ModuleKind::Regular,\n+                        llmod_id,\n                     };\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n                     write::submit_codegened_module_to_llvm(tcx, module, 0);\n@@ -1191,8 +1195,21 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     {\n         let cgu_name = cgu.name().to_string();\n \n+        // Append \".rs\" to LLVM module identifier.\n+        //\n+        // LLVM code generator emits a \".file filename\" directive\n+        // for ELF backends. Value of the \"filename\" is set as the\n+        // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+        // crashes if the module identifier is same as other symbols\n+        // such as a function name in the module.\n+        // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+        let llmod_id = format!(\"{}-{}.rs\",\n+                               cgu.name(),\n+                               tcx.crate_disambiguator(LOCAL_CRATE)\n+                                   .to_fingerprint().to_hex());\n+\n         // Instantiate monomorphizations without filling out definitions yet...\n-        let cx = CodegenCx::new(tcx, cgu);\n+        let cx = CodegenCx::new(tcx, cgu, &llmod_id);\n         let module = {\n             let mono_items = cx.codegen_unit\n                                  .items_in_deterministic_order(cx.tcx);\n@@ -1250,6 +1267,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 name: cgu_name,\n                 source: ModuleSource::Codegened(llvm_module),\n                 kind: ModuleKind::Regular,\n+                llmod_id,\n             }\n         };\n "}, {"sha": "b774d7c5def217a9a17f5bc501bc8ef60cdb7d07", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=0830cc92bd4c8dd8451931799acb4ada59d6bc88", "patch": "@@ -214,7 +214,8 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n \n impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               codegen_unit: Arc<CodegenUnit<'tcx>>)\n+               codegen_unit: Arc<CodegenUnit<'tcx>>,\n+               llmod_id: &str)\n                -> CodegenCx<'a, 'tcx> {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n@@ -267,7 +268,7 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n \n         unsafe {\n             let (llcx, llmod) = create_context_and_module(&tcx.sess,\n-                                                          &codegen_unit.name().as_str());\n+                                                          &llmod_id[..]);\n \n             let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 let dctx = debuginfo::CrateDebugContext::new(llmod);"}, {"sha": "e575c7ad68491ddd0364bfe46ee6cf591a19f0e6", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0830cc92bd4c8dd8451931799acb4ada59d6bc88/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=0830cc92bd4c8dd8451931799acb4ada59d6bc88", "patch": "@@ -258,8 +258,8 @@ struct ModuleCodegen {\n     /// unique amongst **all** crates.  Therefore, it should contain\n     /// something unique to this crate (e.g., a module path) as well\n     /// as the crate name and disambiguator.\n-    /// We currently generate these names via CodegenUnit::build_cgu_name().\n     name: String,\n+    llmod_id: String,\n     source: ModuleSource,\n     kind: ModuleKind,\n }\n@@ -306,6 +306,7 @@ impl ModuleCodegen {\n         };\n \n         CompiledModule {\n+            llmod_id: self.llmod_id,\n             name: self.name.clone(),\n             kind: self.kind,\n             pre_existing,\n@@ -319,6 +320,7 @@ impl ModuleCodegen {\n #[derive(Debug)]\n struct CompiledModule {\n     name: String,\n+    llmod_id: String,\n     kind: ModuleKind,\n     pre_existing: bool,\n     object: Option<PathBuf>,"}]}