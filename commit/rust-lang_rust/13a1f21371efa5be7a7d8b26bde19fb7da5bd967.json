{"sha": "13a1f21371efa5be7a7d8b26bde19fb7da5bd967", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzYTFmMjEzNzFlZmE1YmU3YTdkOGIyNmJkZTE5ZmI3ZGE1YmQ5Njc=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-09-20T07:40:25Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-10-17T13:54:09Z"}, "message": "hashmap: Store hashes as usize internally\n\nWe can't use more than usize's bits of a hash to select a bucket anyway,\nso we only need to store that part in the table. This should be an\nimprovement for the size of the data structure on 32-bit platforms.\nSmaller data means better cache utilization and hopefully better\nperformance.", "tree": {"sha": "a1d169fb94a0d21abc2041684666de714724815d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1d169fb94a0d21abc2041684666de714724815d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13a1f21371efa5be7a7d8b26bde19fb7da5bd967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13a1f21371efa5be7a7d8b26bde19fb7da5bd967", "html_url": "https://github.com/rust-lang/rust/commit/13a1f21371efa5be7a7d8b26bde19fb7da5bd967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13a1f21371efa5be7a7d8b26bde19fb7da5bd967/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da7f8c540b47c5bb063356bf5ad05a6a49ed0ff1", "url": "https://api.github.com/repos/rust-lang/rust/commits/da7f8c540b47c5bb063356bf5ad05a6a49ed0ff1", "html_url": "https://github.com/rust-lang/rust/commit/da7f8c540b47c5bb063356bf5ad05a6a49ed0ff1"}], "stats": {"total": 69, "additions": 44, "deletions": 25}, "files": [{"sha": "ec0e457dc6aa30f8e92fb6f65c02e1f7349897ba", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 44, "deletions": 25, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/13a1f21371efa5be7a7d8b26bde19fb7da5bd967/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a1f21371efa5be7a7d8b26bde19fb7da5bd967/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=13a1f21371efa5be7a7d8b26bde19fb7da5bd967", "patch": "@@ -21,7 +21,18 @@ use ptr::{self, Unique, Shared};\n \n use self::BucketState::*;\n \n-const EMPTY_BUCKET: u64 = 0;\n+/// Integer type used for stored hash values.\n+///\n+/// No more than bit_width(usize) bits are needed to select a bucket.\n+///\n+/// The most significant bit is ours to use for tagging `SafeHash`.\n+///\n+/// (Even if we could have usize::MAX bytes allocated for buckets,\n+/// each bucket stores at least a `HashUint`, so there can be no more than\n+/// usize::MAX / size_of(usize) buckets.)\n+type HashUint = usize;\n+\n+const EMPTY_BUCKET: HashUint = 0;\n \n /// The raw hashtable, providing safe-ish access to the unzipped and highly\n /// optimized arrays of hashes, and key-value pairs.\n@@ -64,7 +75,7 @@ const EMPTY_BUCKET: u64 = 0;\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size: usize,\n-    hashes: Unique<u64>,\n+    hashes: Unique<HashUint>,\n \n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n@@ -75,7 +86,7 @@ unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}\n unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n struct RawBucket<K, V> {\n-    hash: *mut u64,\n+    hash: *mut HashUint,\n     // We use *const to ensure covariance with respect to K and V\n     pair: *const (K, V),\n     _marker: marker::PhantomData<(K, V)>,\n@@ -136,15 +147,27 @@ pub struct GapThenFull<K, V, M> {\n /// buckets.\n #[derive(PartialEq, Copy, Clone)]\n pub struct SafeHash {\n-    hash: u64,\n+    hash: HashUint,\n }\n \n impl SafeHash {\n     /// Peek at the hash value, which is guaranteed to be non-zero.\n     #[inline(always)]\n-    pub fn inspect(&self) -> u64 {\n+    pub fn inspect(&self) -> HashUint {\n         self.hash\n     }\n+\n+    #[inline(always)]\n+    pub fn new(hash: u64) -> Self {\n+        // We need to avoid 0 in order to prevent collisions with\n+        // EMPTY_HASH. We can maintain our precious uniform distribution\n+        // of initial indexes by unconditionally setting the MSB,\n+        // effectively reducing the hashes by one bit.\n+        //\n+        // Truncate hash to fit in `HashUint`.\n+        let hash_bits = size_of::<HashUint>() * 8;\n+        SafeHash { hash: (1 << (hash_bits - 1)) | (hash as HashUint) }\n+    }\n }\n \n /// We need to remove hashes of 0. That's reserved for empty buckets.\n@@ -156,25 +179,21 @@ pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash\n {\n     let mut state = hash_state.build_hasher();\n     t.hash(&mut state);\n-    // We need to avoid 0 in order to prevent collisions with\n-    // EMPTY_HASH. We can maintain our precious uniform distribution\n-    // of initial indexes by unconditionally setting the MSB,\n-    // effectively reducing 64-bits hashes to 63 bits.\n-    SafeHash { hash: 0x8000_0000_0000_0000 | state.finish() }\n+    SafeHash::new(state.finish())\n }\n \n-// `replace` casts a `*u64` to a `*SafeHash`. Since we statically\n+// `replace` casts a `*HashUint` to a `*SafeHash`. Since we statically\n // ensure that a `FullBucket` points to an index with a non-zero hash,\n-// and a `SafeHash` is just a `u64` with a different name, this is\n+// and a `SafeHash` is just a `HashUint` with a different name, this is\n // safe.\n //\n // This test ensures that a `SafeHash` really IS the same size as a\n-// `u64`. If you need to change the size of `SafeHash` (and\n+// `HashUint`. If you need to change the size of `SafeHash` (and\n // consequently made this test fail), `replace` needs to be\n // modified to no longer assume this.\n #[test]\n-fn can_alias_safehash_as_u64() {\n-    assert_eq!(size_of::<SafeHash>(), size_of::<u64>())\n+fn can_alias_safehash_as_hash() {\n+    assert_eq!(size_of::<SafeHash>(), size_of::<HashUint>())\n }\n \n impl<K, V> RawBucket<K, V> {\n@@ -605,14 +624,14 @@ impl<K, V> RawTable<K, V> {\n             return RawTable {\n                 size: 0,\n                 capacity: 0,\n-                hashes: Unique::new(EMPTY as *mut u64),\n+                hashes: Unique::new(EMPTY as *mut HashUint),\n                 marker: marker::PhantomData,\n             };\n         }\n \n         // No need for `checked_mul` before a more restrictive check performed\n         // later in this method.\n-        let hashes_size = capacity.wrapping_mul(size_of::<u64>());\n+        let hashes_size = capacity.wrapping_mul(size_of::<HashUint>());\n         let pairs_size = capacity.wrapping_mul(size_of::<(K, V)>());\n \n         // Allocating hashmaps is a little tricky. We need to allocate two\n@@ -624,13 +643,13 @@ impl<K, V> RawTable<K, V> {\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n         let (alignment, hash_offset, size, oflo) = calculate_allocation(hashes_size,\n-                                                                        align_of::<u64>(),\n+                                                                        align_of::<HashUint>(),\n                                                                         pairs_size,\n                                                                         align_of::<(K, V)>());\n         assert!(!oflo, \"capacity overflow\");\n \n         // One check for overflow that covers calculation and rounding of size.\n-        let size_of_bucket = size_of::<u64>().checked_add(size_of::<(K, V)>()).unwrap();\n+        let size_of_bucket = size_of::<HashUint>().checked_add(size_of::<(K, V)>()).unwrap();\n         assert!(size >=\n                 capacity.checked_mul(size_of_bucket)\n                     .expect(\"capacity overflow\"),\n@@ -641,7 +660,7 @@ impl<K, V> RawTable<K, V> {\n             ::alloc::oom()\n         }\n \n-        let hashes = buffer.offset(hash_offset as isize) as *mut u64;\n+        let hashes = buffer.offset(hash_offset as isize) as *mut HashUint;\n \n         RawTable {\n             capacity: capacity,\n@@ -652,7 +671,7 @@ impl<K, V> RawTable<K, V> {\n     }\n \n     fn first_bucket_raw(&self) -> RawBucket<K, V> {\n-        let hashes_size = self.capacity * size_of::<u64>();\n+        let hashes_size = self.capacity * size_of::<HashUint>();\n         let pairs_size = self.capacity * size_of::<(K, V)>();\n \n         let buffer = *self.hashes as *mut u8;\n@@ -756,7 +775,7 @@ impl<K, V> RawTable<K, V> {\n /// this interface is safe, it's not used outside this module.\n struct RawBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n-    hashes_end: *mut u64,\n+    hashes_end: *mut HashUint,\n \n     // Strictly speaking, this should be &'a (K,V), but that would\n     // require that K:'a, and we often use RawBuckets<'static...> for\n@@ -802,7 +821,7 @@ impl<'a, K, V> Iterator for RawBuckets<'a, K, V> {\n /// the table's remaining entries. It's used in the implementation of Drop.\n struct RevMoveBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n-    hashes_end: *mut u64,\n+    hashes_end: *mut HashUint,\n     elems_left: usize,\n \n     // As above, `&'a (K,V)` would seem better, but we often use\n@@ -1036,10 +1055,10 @@ impl<K, V> Drop for RawTable<K, V> {\n             }\n         }\n \n-        let hashes_size = self.capacity * size_of::<u64>();\n+        let hashes_size = self.capacity * size_of::<HashUint>();\n         let pairs_size = self.capacity * size_of::<(K, V)>();\n         let (align, _, size, oflo) = calculate_allocation(hashes_size,\n-                                                          align_of::<u64>(),\n+                                                          align_of::<HashUint>(),\n                                                           pairs_size,\n                                                           align_of::<(K, V)>());\n "}]}