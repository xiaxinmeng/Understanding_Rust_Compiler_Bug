{"sha": "f85e383b94376d55bb5ee6be375ef3dc0006590f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NWUzODNiOTQzNzZkNTViYjVlZTZiZTM3NWVmM2RjMDAwNjU5MGY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T14:29:25Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T14:29:25Z"}, "message": "internal: refactor inactive code diagnostics", "tree": {"sha": "03e3c3685a893891c7b9f144597362a5e57c02ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03e3c3685a893891c7b9f144597362a5e57c02ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f85e383b94376d55bb5ee6be375ef3dc0006590f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f85e383b94376d55bb5ee6be375ef3dc0006590f", "html_url": "https://github.com/rust-lang/rust/commit/f85e383b94376d55bb5ee6be375ef3dc0006590f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f85e383b94376d55bb5ee6be375ef3dc0006590f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa9ed4e0ce633e51d1411951bf044719e6837457", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa9ed4e0ce633e51d1411951bf044719e6837457", "html_url": "https://github.com/rust-lang/rust/commit/fa9ed4e0ce633e51d1411951bf044719e6837457"}], "stats": {"total": 274, "additions": 141, "deletions": 133}, "files": [{"sha": "03e7f5e8432153c750223143a1a39abfb361d97d", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=f85e383b94376d55bb5ee6be375ef3dc0006590f", "patch": "@@ -5,11 +5,10 @@\n //! be expressed in terms of hir types themselves.\n use std::any::Any;\n \n-use cfg::{CfgExpr, CfgOptions, DnfExpr};\n+use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n-use stdx::format_to;\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n pub use crate::diagnostics_sink::{\n@@ -38,6 +37,7 @@ diagnostics![\n     UnresolvedImport,\n     UnresolvedMacroCall,\n     MissingFields,\n+    InactiveCode,\n ];\n \n #[derive(Debug)]\n@@ -62,39 +62,13 @@ pub struct UnresolvedMacroCall {\n     pub path: ModPath,\n }\n \n-// Diagnostic: inactive-code\n-//\n-// This diagnostic is shown for code with inactive `#[cfg]` attributes.\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct InactiveCode {\n-    pub file: HirFileId,\n-    pub node: SyntaxNodePtr,\n+    pub node: InFile<SyntaxNodePtr>,\n     pub cfg: CfgExpr,\n     pub opts: CfgOptions,\n }\n \n-impl Diagnostic for InactiveCode {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"inactive-code\")\n-    }\n-    fn message(&self) -> String {\n-        let inactive = DnfExpr::new(self.cfg.clone()).why_inactive(&self.opts);\n-        let mut buf = \"code is inactive due to #[cfg] directives\".to_string();\n-\n-        if let Some(inactive) = inactive {\n-            format_to!(buf, \": {}\", inactive);\n-        }\n-\n-        buf\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.node.clone())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n // Diagnostic: unresolved-proc-macro\n //\n // This diagnostic is shown when a procedural macro can not be found. This usually means that"}, {"sha": "d59b52b259561d1948be752c1401543e4c7b9152", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f85e383b94376d55bb5ee6be375ef3dc0006590f", "patch": "@@ -506,12 +506,14 @@ impl Module {\n \n                 DefDiagnosticKind::UnconfiguredCode { ast, cfg, opts } => {\n                     let item = ast.to_node(db.upcast());\n-                    sink.push(InactiveCode {\n-                        file: ast.file_id,\n-                        node: AstPtr::new(&item).into(),\n-                        cfg: cfg.clone(),\n-                        opts: opts.clone(),\n-                    });\n+                    acc.push(\n+                        InactiveCode {\n+                            node: ast.with_value(AstPtr::new(&item).into()),\n+                            cfg: cfg.clone(),\n+                            opts: opts.clone(),\n+                        }\n+                        .into(),\n+                    );\n                 }\n \n                 DefDiagnosticKind::UnresolvedProcMacro { ast } => {\n@@ -1045,12 +1047,10 @@ impl Function {\n         let source_map = db.body_with_source_map(self.id.into()).1;\n         for diag in source_map.diagnostics() {\n             match diag {\n-                BodyDiagnostic::InactiveCode { node, cfg, opts } => sink.push(InactiveCode {\n-                    file: node.file_id,\n-                    node: node.value.clone(),\n-                    cfg: cfg.clone(),\n-                    opts: opts.clone(),\n-                }),\n+                BodyDiagnostic::InactiveCode { node, cfg, opts } => acc.push(\n+                    InactiveCode { node: node.clone(), cfg: cfg.clone(), opts: opts.clone() }\n+                        .into(),\n+                ),\n                 BodyDiagnostic::MacroError { node, message } => sink.push(MacroError {\n                     file: node.file_id,\n                     node: node.value.clone().into(),"}, {"sha": "075dcc6d2d248dfadea2e1465dcda6711204d10a", "filename": "crates/hir_def/src/body/tests.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs?ref=f85e383b94376d55bb5ee6be375ef3dc0006590f", "patch": "@@ -88,39 +88,6 @@ mod m {\n     );\n }\n \n-#[test]\n-fn cfg_diagnostics() {\n-    check_diagnostics(\n-        r\"\n-fn f() {\n-    // The three g\u0336e\u0336n\u0336d\u0336e\u0336r\u0336s\u0336 statements:\n-\n-    #[cfg(a)] fn f() {}  // Item statement\n-  //^^^^^^^^^^^^^^^^^^^ InactiveCode\n-    #[cfg(a)] {}         // Expression statement\n-  //^^^^^^^^^^^^ InactiveCode\n-    #[cfg(a)] let x = 0; // let statement\n-  //^^^^^^^^^^^^^^^^^^^^ InactiveCode\n-\n-    abc(#[cfg(a)] 0);\n-      //^^^^^^^^^^^ InactiveCode\n-    let x = Struct {\n-        #[cfg(a)] f: 0,\n-      //^^^^^^^^^^^^^^ InactiveCode\n-    };\n-    match () {\n-        () => (),\n-        #[cfg(a)] () => (),\n-      //^^^^^^^^^^^^^^^^^^ InactiveCode\n-    }\n-\n-    #[cfg(a)] 0          // Trailing expression of block\n-  //^^^^^^^^^^^ InactiveCode\n-}\n-    \",\n-    );\n-}\n-\n #[test]\n fn macro_diag_builtin() {\n     check_diagnostics("}, {"sha": "f1ee03d4ddd1b93491df7ae44ccd7507a6ad720c", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=f85e383b94376d55bb5ee6be375ef3dc0006590f", "patch": "@@ -12,48 +12,6 @@ fn check_no_diagnostics(ra_fixture: &str) {\n     db.check_no_diagnostics();\n }\n \n-#[test]\n-fn inactive_item() {\n-    // Additional tests in `cfg` crate. This only tests disabled cfgs.\n-\n-    check_diagnostics(\n-        r#\"\n-        //- /lib.rs\n-          #[cfg(no)] pub fn f() {}\n-        //^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n-\n-          #[cfg(no)] #[cfg(no2)] mod m;\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n-\n-          #[cfg(all(not(a), b))] enum E {}\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n-\n-          #[cfg(feature = \"std\")] use std;\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n-        \"#,\n-    );\n-}\n-\n-/// Tests that `cfg` attributes behind `cfg_attr` is handled properly.\n-#[test]\n-fn inactive_via_cfg_attr() {\n-    cov_mark::check!(cfg_attr_active);\n-    check_diagnostics(\n-        r#\"\n-        //- /lib.rs\n-          #[cfg_attr(not(never), cfg(no))] fn f() {}\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n-\n-          #[cfg_attr(not(never), cfg(not(no)))] fn f() {}\n-\n-          #[cfg_attr(never, cfg(no))] fn g() {}\n-\n-          #[cfg_attr(not(never), inline, cfg(no))] fn h() {}\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n-        \"#,\n-    );\n-}\n-\n #[test]\n fn builtin_macro_fails_expansion() {\n     check_diagnostics("}, {"sha": "634e6a043e104347e36062931d69a9133429624c", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=f85e383b94376d55bb5ee6be375ef3dc0006590f", "patch": "@@ -8,6 +8,7 @@ mod unresolved_module;\n mod unresolved_extern_crate;\n mod unresolved_import;\n mod unresolved_macro_call;\n+mod inactive_code;\n mod missing_fields;\n \n mod fixes;\n@@ -164,22 +165,6 @@ pub(crate) fn diagnostics(\n         .on::<hir::diagnostics::ReplaceFilterMapNextWithFindMap, _>(|d| {\n             res.borrow_mut().push(warning_with_fix(d, &sema, resolve));\n         })\n-        .on::<hir::diagnostics::InactiveCode, _>(|d| {\n-            // If there's inactive code somewhere in a macro, don't propagate to the call-site.\n-            if d.display_source().file_id.expansion_info(db).is_some() {\n-                return;\n-            }\n-\n-            // Override severity and mark as unused.\n-            res.borrow_mut().push(\n-                Diagnostic::hint(\n-                    sema.diagnostics_display_range(d.display_source()).range,\n-                    d.message(),\n-                )\n-                .with_unused(true)\n-                .with_code(Some(d.code())),\n-            );\n-        })\n         .on::<UnlinkedFile, _>(|d| {\n             // Limit diagnostic to the first few characters in the file. This matches how VS Code\n             // renders it with the full span, but on other editors, and is less invasive.\n@@ -247,6 +232,11 @@ pub(crate) fn diagnostics(\n             AnyDiagnostic::UnresolvedImport(d) => unresolved_import::unresolved_import(&ctx, &d),\n             AnyDiagnostic::UnresolvedMacroCall(d) => unresolved_macro_call::unresolved_macro_call(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n+\n+            AnyDiagnostic::InactiveCode(d) => match inactive_code::inactive_code(&ctx, &d) {\n+                Some(it) => it,\n+                None => continue,\n+            }\n         };\n         if let Some(code) = d.code {\n             if ctx.config.disabled.contains(code.as_str()) {\n@@ -451,7 +441,13 @@ mod tests {\n         expect.assert_debug_eq(&diagnostics)\n     }\n \n+    #[track_caller]\n     pub(crate) fn check_diagnostics(ra_fixture: &str) {\n+        check_diagnostics_with_inactive_code(ra_fixture, false)\n+    }\n+\n+    #[track_caller]\n+    pub(crate) fn check_diagnostics_with_inactive_code(ra_fixture: &str, with_inactive_code: bool) {\n         let (analysis, file_id) = fixture::file(ra_fixture);\n         let diagnostics = analysis\n             .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::All, file_id)\n@@ -460,7 +456,7 @@ mod tests {\n         let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n         let mut actual = diagnostics\n             .into_iter()\n-            .filter(|d| d.code != Some(DiagnosticCode(\"inactive-code\")))\n+            .filter(|d| d.code != Some(DiagnosticCode(\"inactive-code\")) || with_inactive_code)\n             .map(|d| (d.range, d.message))\n             .collect::<Vec<_>>();\n         actual.sort_by_key(|(range, _)| range.start());"}, {"sha": "52f97cb4c158bf3b52c051e9808936e62ddfe370", "filename": "crates/ide/src/diagnostics/inactive_code.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fide%2Fsrc%2Fdiagnostics%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85e383b94376d55bb5ee6be375ef3dc0006590f/crates%2Fide%2Fsrc%2Fdiagnostics%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Finactive_code.rs?ref=f85e383b94376d55bb5ee6be375ef3dc0006590f", "patch": "@@ -0,0 +1,113 @@\n+use cfg::DnfExpr;\n+use stdx::format_to;\n+\n+use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: inactive-code\n+//\n+// This diagnostic is shown for code with inactive `#[cfg]` attributes.\n+pub(super) fn inactive_code(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::InactiveCode,\n+) -> Option<Diagnostic> {\n+    // If there's inactive code somewhere in a macro, don't propagate to the call-site.\n+    if d.node.file_id.expansion_info(ctx.sema.db).is_some() {\n+        return None;\n+    }\n+\n+    let inactive = DnfExpr::new(d.cfg.clone()).why_inactive(&d.opts);\n+    let mut message = \"code is inactive due to #[cfg] directives\".to_string();\n+\n+    if let Some(inactive) = inactive {\n+        format_to!(message, \": {}\", inactive);\n+    }\n+\n+    let res = Diagnostic::new(\n+        \"inactive-code\",\n+        message,\n+        ctx.sema.diagnostics_display_range(d.node.clone()).range,\n+    )\n+    .with_unused(true);\n+    Some(res)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics_with_inactive_code;\n+\n+    #[test]\n+    fn cfg_diagnostics() {\n+        check_diagnostics_with_inactive_code(\n+            r#\"\n+fn f() {\n+    // The three g\u0336e\u0336n\u0336d\u0336e\u0336r\u0336s\u0336 statements:\n+\n+    #[cfg(a)] fn f() {}  // Item statement\n+  //^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    #[cfg(a)] {}         // Expression statement\n+  //^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    #[cfg(a)] let x = 0; // let statement\n+  //^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+\n+    abc(#[cfg(a)] 0);\n+      //^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    let x = Struct {\n+        #[cfg(a)] f: 0,\n+      //^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    };\n+    match () {\n+        () => (),\n+        #[cfg(a)] () => (),\n+      //^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    }\n+\n+    #[cfg(a)] 0          // Trailing expression of block\n+  //^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+}\n+        \"#,\n+            true,\n+        );\n+    }\n+\n+    #[test]\n+    fn inactive_item() {\n+        // Additional tests in `cfg` crate. This only tests disabled cfgs.\n+\n+        check_diagnostics_with_inactive_code(\n+            r#\"\n+    #[cfg(no)] pub fn f() {}\n+  //^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no is disabled\n+\n+    #[cfg(no)] #[cfg(no2)] mod m;\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no and no2 are disabled\n+\n+    #[cfg(all(not(a), b))] enum E {}\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: b is disabled\n+\n+    #[cfg(feature = \"std\")] use std;\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: feature = \"std\" is disabled\n+\"#,\n+            true,\n+        );\n+    }\n+\n+    /// Tests that `cfg` attributes behind `cfg_attr` is handled properly.\n+    #[test]\n+    fn inactive_via_cfg_attr() {\n+        cov_mark::check!(cfg_attr_active);\n+        check_diagnostics_with_inactive_code(\n+            r#\"\n+    #[cfg_attr(not(never), cfg(no))] fn f() {}\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no is disabled\n+\n+    #[cfg_attr(not(never), cfg(not(no)))] fn f() {}\n+\n+    #[cfg_attr(never, cfg(no))] fn g() {}\n+\n+    #[cfg_attr(not(never), inline, cfg(no))] fn h() {}\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no is disabled\n+\"#,\n+            true,\n+        );\n+    }\n+}"}]}