{"sha": "cb04e495dc7a34cc708246dad7bb8b844216fd3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMDRlNDk1ZGM3YTM0Y2M3MDgyNDZkYWQ3YmI4Yjg0NDIxNmZkM2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-23T00:39:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-23T20:42:53Z"}, "message": "rewrite drop code\n\nThis was triggered by me wanting to address a use of DUMMY_SP, but\nactually I'm not sure what would be a better span -- I guess the span\nfor the function as a whole.", "tree": {"sha": "e38e7405f083ba4fe805aebf311d427bd5668a1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e38e7405f083ba4fe805aebf311d427bd5668a1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb04e495dc7a34cc708246dad7bb8b844216fd3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb04e495dc7a34cc708246dad7bb8b844216fd3e", "html_url": "https://github.com/rust-lang/rust/commit/cb04e495dc7a34cc708246dad7bb8b844216fd3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb04e495dc7a34cc708246dad7bb8b844216fd3e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f976e222e97fdcb8ab66634c8910ce524f6804c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f976e222e97fdcb8ab66634c8910ce524f6804c9", "html_url": "https://github.com/rust-lang/rust/commit/f976e222e97fdcb8ab66634c8910ce524f6804c9"}], "stats": {"total": 168, "additions": 85, "deletions": 83}, "files": [{"sha": "4c9e2c0c5fa6d51b358cea0f04fbda0a96da7186", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb04e495dc7a34cc708246dad7bb8b844216fd3e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb04e495dc7a34cc708246dad7bb8b844216fd3e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=cb04e495dc7a34cc708246dad7bb8b844216fd3e", "patch": "@@ -256,7 +256,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 block = match value {\n                     Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n                     None => {\n-                        this.cfg.push_assign_unit(block, scope_id, expr_span, &Lvalue::ReturnPointer);\n+                        this.cfg.push_assign_unit(block, scope_id,\n+                                                  expr_span, &Lvalue::ReturnPointer);\n                         block\n                     }\n                 };"}, {"sha": "3211e5849a06c8c213135e3db6c0e395d0288638", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb04e495dc7a34cc708246dad7bb8b844216fd3e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb04e495dc7a34cc708246dad7bb8b844216fd3e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=cb04e495dc7a34cc708246dad7bb8b844216fd3e", "patch": "@@ -272,7 +272,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let (actual, result) = (self.temp(usize_ty), self.temp(bool_ty));\n \n                 // actual = len(lvalue)\n-                self.cfg.push_assign(block, scope_id, test.span, &actual, Rvalue::Len(lvalue.clone()));\n+                self.cfg.push_assign(block, scope_id, test.span,\n+                                     &actual, Rvalue::Len(lvalue.clone()));\n \n                 // expected = <N>\n                 let expected = self.push_usize(block, scope_id, test.span, len);"}, {"sha": "5aeaef06b8910425f4a79e178229229d52a18c0c", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/cb04e495dc7a34cc708246dad7bb8b844216fd3e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb04e495dc7a34cc708246dad7bb8b844216fd3e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=cb04e495dc7a34cc708246dad7bb8b844216fd3e", "patch": "@@ -113,12 +113,20 @@ pub struct Scope<'tcx> {\n     // This is expected to go away once `box EXPR` becomes a sugar for placement protocol and gets\n     // desugared in some earlier stage.\n     free: Option<FreeData<'tcx>>,\n+\n+    /// The cached block for the cleanups-on-diverge path. This block\n+    /// contains a block that will just do a RESUME to an appropriate\n+    /// place. This block does not execute any of the drops or free:\n+    /// each of those has their own cached-blocks, which will branch\n+    /// to this point.\n+    cached_block: Option<BasicBlock>\n }\n \n struct DropData<'tcx> {\n     span: Span,\n     value: Lvalue<'tcx>,\n     // NB: per-drop \u201ccache\u201d is necessary for the build_scope_drops function below.\n+\n     /// The cached block for the cleanups-on-diverge path. This block contains code to run the\n     /// current drop and all the preceding drops (i.e. those having lower index in Drop\u2019s\n     /// Scope drop array)\n@@ -127,10 +135,13 @@ struct DropData<'tcx> {\n \n struct FreeData<'tcx> {\n     span: Span,\n+\n     /// Lvalue containing the allocated box.\n     value: Lvalue<'tcx>,\n+\n     /// type of item for which the box was allocated for (i.e. the T in Box<T>).\n     item_ty: Ty<'tcx>,\n+\n     /// The cached block containing code to run the free. The block will also execute all the drops\n     /// in the scope.\n     cached_block: Option<BasicBlock>\n@@ -155,6 +166,7 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     fn invalidate_cache(&mut self) {\n+        self.cached_block = None;\n         for dropdata in &mut self.drops {\n             dropdata.cached_block = None;\n         }\n@@ -234,7 +246,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             id: id,\n             extent: extent,\n             drops: vec![],\n-            free: None\n+            free: None,\n+            cached_block: None,\n         });\n         self.scope_auxiliary.push(ScopeAuxiliary {\n             extent: extent,\n@@ -288,7 +301,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                               block));\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n-                let free = build_free(self.hir.tcx(), tmp.clone(), free_data, next);\n+                let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n                 self.cfg.terminate(block, scope.id, span, free);\n                 block = next;\n             }\n@@ -419,20 +432,16 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n         let unit_temp = self.get_unit_temp();\n         let Builder { ref mut hir, ref mut cfg, ref mut scopes, .. } = *self;\n-        let mut next_block = None;\n \n         // Given an array of scopes, we generate these from the outermost scope to the innermost\n         // one. Thus for array [S0, S1, S2] with corresponding cleanup blocks [B0, B1, B2], we will\n         // generate B0 <- B1 <- B2 in left-to-right order. Control flow of the generated blocks\n         // always ends up at a block with the Resume terminator.\n-        for scope in scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some()) {\n-            next_block = Some(build_diverge_scope(hir.tcx(),\n-                                                  cfg,\n-                                                  unit_temp.clone(),\n-                                                  scope,\n-                                                  next_block));\n+        if scopes.iter().any(|scope| !scope.drops.is_empty() || scope.free.is_some()) {\n+            Some(build_diverge_scope(hir.tcx(), cfg, &unit_temp, scopes))\n+        } else {\n+            None\n         }\n-        scopes.iter().rev().flat_map(|x| x.cached_block()).next()\n     }\n \n     /// Utility function for *non*-scope code to build their own drops\n@@ -525,8 +534,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n         // icache with cold branch code), however to achieve that we either have to rely on rvalue\n         // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, scope_id, span, &tuple, // tuple = (message_arg, file_arg, line_arg);\n+        self.cfg.push_assign(block, scope_id, span, &tuple, // [1]\n                              Rvalue::Aggregate(AggregateKind::Tuple, elems));\n+        // [1] tuple = (message_arg, file_arg, line_arg);\n         // FIXME: is this region really correct here?\n         self.cfg.push_assign(block, scope_id, span, &tuple_ref, // tuple_ref = &tuple;\n                              Rvalue::Ref(region, BorrowKind::Shared, tuple));\n@@ -602,58 +612,42 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n \n fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n                              cfg: &mut CFG<'tcx>,\n-                             unit_temp: Lvalue<'tcx>,\n-                             scope: &mut Scope<'tcx>,\n-                             target: Option<BasicBlock>)\n-                             -> BasicBlock {\n-    debug_assert!(!scope.drops.is_empty() || scope.free.is_some());\n-\n-    // First, we build the drops, iterating the drops array in reverse. We do that so that as soon\n-    // as we find a `cached_block`, we know that we\u2019re finished and don\u2019t need to do anything else.\n-    let mut previous = None;\n-    let mut last_drop_block = None;\n-    for drop_data in scope.drops.iter_mut().rev() {\n-        if let Some(cached_block) = drop_data.cached_block {\n-            if let Some((previous_block, previous_span, previous_value)) = previous {\n-                cfg.terminate(previous_block,\n-                              scope.id,\n-                              previous_span,\n-                              TerminatorKind::Drop {\n-                                  value: previous_value,\n-                                  target: cached_block,\n-                                  unwind: None\n-                              });\n-                return last_drop_block.unwrap();\n-            } else {\n-                return cached_block;\n-            }\n-        } else {\n-            let block = cfg.start_new_cleanup_block();\n-            drop_data.cached_block = Some(block);\n-            if let Some((previous_block, previous_span, previous_value)) = previous {\n-                cfg.terminate(previous_block,\n-                              scope.id,\n-                              previous_span,\n-                              TerminatorKind::Drop {\n-                                  value: previous_value,\n-                                  target: block,\n-                                  unwind: None\n-                              });\n-            } else {\n-                last_drop_block = Some(block);\n-            }\n-            previous = Some((block, drop_data.span, drop_data.value.clone()));\n-        }\n-    }\n-\n-    // Prepare the end target for this chain.\n-    let mut target = target.unwrap_or_else(||{\n-        let b = cfg.start_new_cleanup_block();\n-        cfg.terminate(b, scope.id, DUMMY_SP, TerminatorKind::Resume); // TODO\n-        b\n-    });\n+                             unit_temp: &Lvalue<'tcx>,\n+                             scopes: &mut [Scope<'tcx>])\n+                             -> BasicBlock\n+{\n+    assert!(scopes.len() >= 1);\n+\n+    // Build up the drops in **reverse** order. The end result will\n+    // look like:\n+    //\n+    //    [drops[n]] -...-> [drops[0]] -> [Free] -> [scopes[..n-1]]\n+    //    |                                    |\n+    //    +------------------------------------+\n+    //     code for scopes[n]\n+    //\n+    // The code in this function reads from right to left. At each\n+    // point, we check for cached blocks representing the\n+    // remainder. If everything is cached, we'll just walk right to\n+    // left reading the cached results but never created anything.\n+\n+    // To start, translate scopes[1..].\n+    let (scope, earlier_scopes) = scopes.split_last_mut().unwrap();\n+    let mut target = if let Some(cached_block) = scope.cached_block {\n+        cached_block\n+    } else if earlier_scopes.is_empty() {\n+        // Diverging from the root scope creates a RESUME terminator.\n+        // FIXME what span to use here?\n+        let resumeblk = cfg.start_new_cleanup_block();\n+        cfg.terminate(resumeblk, scope.id, DUMMY_SP, TerminatorKind::Resume);\n+        resumeblk\n+    } else {\n+        // Diverging from any other scope chains up to the previous scope.\n+        build_diverge_scope(tcx, cfg, unit_temp, earlier_scopes)\n+    };\n+    scope.cached_block = Some(target);\n \n-    // Then, build the free branching into the prepared target.\n+    // Next, build up any free.\n     if let Some(ref mut free_data) = scope.free {\n         target = if let Some(cached_block) = free_data.cached_block {\n             cached_block\n@@ -665,29 +659,35 @@ fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n                           build_free(tcx, unit_temp, free_data, target));\n             free_data.cached_block = Some(into);\n             into\n-        }\n-    };\n+        };\n+    }\n \n-    if let Some((previous_block, previous_span, previous_value)) = previous {\n-        // Finally, branch into that just-built `target` from the `previous_block`.\n-        cfg.terminate(previous_block,\n-                      scope.id,\n-                      previous_span,\n-                      TerminatorKind::Drop {\n-                          value: previous_value,\n-                          target: target,\n-                          unwind: None\n-                      });\n-        last_drop_block.unwrap()\n-    } else {\n-        // If `previous.is_none()`, there were no drops in this scope \u2013 we return the\n-        // target.\n-        target\n+    // Next, build up the drops. Here we iterate the vector in\n+    // *forward* order, so that we generate drops[0] first (right to\n+    // left in diagram above).\n+    for drop_data in &mut scope.drops {\n+        target = if let Some(cached_block) = drop_data.cached_block {\n+            cached_block\n+        } else {\n+            let block = cfg.start_new_cleanup_block();\n+            cfg.terminate(block,\n+                          scope.id,\n+                          drop_data.span,\n+                          TerminatorKind::Drop {\n+                              value: drop_data.value.clone(),\n+                              target: target,\n+                              unwind: None\n+                          });\n+            drop_data.cached_block = Some(block);\n+            block\n+        };\n     }\n+\n+    target\n }\n \n fn build_free<'tcx>(tcx: &TyCtxt<'tcx>,\n-                    unit_temp: Lvalue<'tcx>,\n+                    unit_temp: &Lvalue<'tcx>,\n                     data: &FreeData<'tcx>,\n                     target: BasicBlock)\n                     -> TerminatorKind<'tcx> {\n@@ -707,7 +707,7 @@ fn build_free<'tcx>(tcx: &TyCtxt<'tcx>,\n             }\n         }),\n         args: vec![Operand::Consume(data.value.clone())],\n-        destination: Some((unit_temp, target)),\n+        destination: Some((unit_temp.clone(), target)),\n         cleanup: None\n     }\n }"}]}