{"sha": "56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZmU0YzI2ODFmN2VmNDY3ZDhiMzQwNTI3OWFjYmNmYzZiMGViY2Y=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-12T15:57:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-12T15:57:58Z"}, "message": "Implement passing cast-to-vtable values as bounded params\n\nCloses #1492", "tree": {"sha": "954d173194466acc35049717b95b5466af407d38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/954d173194466acc35049717b95b5466af407d38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf", "html_url": "https://github.com/rust-lang/rust/commit/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca72a8300b2781b8267e0afffcc5a7692c25d366", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca72a8300b2781b8267e0afffcc5a7692c25d366", "html_url": "https://github.com/rust-lang/rust/commit/ca72a8300b2781b8267e0afffcc5a7692c25d366"}], "stats": {"total": 237, "additions": 160, "deletions": 77}, "files": [{"sha": "1ad1b4f50eff7751423c807fb2add0e38fb73f67", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf", "patch": "@@ -5443,24 +5443,10 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n       }\n       ast::item_impl(tps, some(@{node: ast::ty_path(_, id), _}), _, ms) {\n         let i_did = ast_util::def_id_of_def(ccx.tcx.def_map.get(id));\n-        let ty = ty::lookup_item_type(ccx.tcx, i_did).ty;\n-        let new_pt = pt + [it.ident + int::str(it.id), \"wrap\"];\n-        let extra_tps = vec::map(tps, {|p| param_bounds(ccx, p)});\n-        let tbl = C_struct(vec::map(*ty::iface_methods(ccx.tcx, i_did), {|im|\n-            alt vec::find(ms, {|m| m.ident == im.ident}) {\n-              some(m) {\n-                trans_impl::trans_wrapper(ccx, new_pt, extra_tps, m)\n-              }\n-            }\n-        }));\n-        let s = mangle_exported_name(ccx, new_pt + [\"!vtable\"], ty);\n-        let vt_gvar = str::as_buf(s, {|buf|\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n-        });\n-        llvm::LLVMSetInitializer(vt_gvar, tbl);\n-        llvm::LLVMSetGlobalConstant(vt_gvar, True);\n-        ccx.item_ids.insert(it.id, vt_gvar);\n-        ccx.item_symbols.insert(it.id, s);\n+        trans_impl::trans_impl_vtable(ccx, pt, i_did, ms, tps, it);\n+      }\n+      ast::item_iface(_, _) {\n+        trans_impl::trans_iface_vtable(ccx, pt, it);\n       }\n       _ { }\n     }"}, {"sha": "6b28f1483e7dcf7a1456962fcd82e0e3f416ecf4", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf", "patch": "@@ -916,9 +916,9 @@ tag dict_param {\n     dict_param_dict(dict_id);\n     dict_param_ty(ty::t);\n }\n-type dict_id = @{impl_def: ast::def_id, params: [dict_param]};\n+type dict_id = @{def: ast::def_id, params: [dict_param]};\n fn hash_dict_id(&&dp: dict_id) -> uint {\n-    let h = syntax::ast_util::hash_def_id(dp.impl_def);\n+    let h = syntax::ast_util::hash_def_id(dp.def);\n     for param in dp.params {\n         h = h << 2u;\n         alt param {"}, {"sha": "0139148d728bd63795d54f4e01cffca24e28097b", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 135, "deletions": 42, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf", "patch": "@@ -68,18 +68,23 @@ fn trans_static_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n     {env: obj_env(val) with lval_static_fn(bcx, did, e.id)}\n }\n \n+fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, m: ty::method)\n+    -> {ty: ty::t, llty: TypeRef} {\n+    let fty = ty::mk_fn(ccx.tcx, m.fty);\n+    let bare_fn_ty = type_of_fn_from_ty(ccx, ast_util::dummy_sp(),\n+                                        fty, *m.tps);\n+    let {inputs, output} = llfn_arg_tys(bare_fn_ty);\n+    {ty: fty, llty: T_fn([dict_ty] + inputs, output)}\n+}\n+\n fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n                        fld_expr: @ast::expr, iface_id: ast::def_id,\n                        n_method: uint) -> lval_maybe_callee {\n     let bcx = bcx, ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n     let method = ty::iface_methods(tcx, iface_id)[n_method];\n-    let fty = ty::mk_fn(tcx, method.fty);\n-    let bare_fn_ty = type_of_fn_from_ty(ccx, ast_util::dummy_sp(),\n-                                        fty, *method.tps);\n-    let {inputs: bare_inputs, output} = llfn_arg_tys(bare_fn_ty);\n-    let fn_ty = T_fn([val_ty(dict)] + bare_inputs, output);\n+    let {ty: fty, llty: llfty} = wrapper_fn_ty(ccx, val_ty(dict), method);\n     let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n-                             T_ptr(T_array(T_ptr(fn_ty), n_method + 1u)));\n+                             T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n     let generic = none;\n     if vec::len(*method.tps) > 0u || ty::type_contains_params(tcx, fty) {\n@@ -138,9 +143,36 @@ fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n     {inputs: args, output: out_ty}\n }\n \n-fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n-                 extra_tps: [ty::param_bounds], m: @ast::method) -> ValueRef {\n-    let real_fn = ccx.item_ids.get(m.id);\n+fn trans_vtable(ccx: @crate_ctxt, id: ast::node_id, name: str,\n+                ptrs: [ValueRef]) {\n+    let tbl = C_struct(ptrs);\n+    let vt_gvar = str::as_buf(name, {|buf|\n+        llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n+    });\n+    llvm::LLVMSetInitializer(vt_gvar, tbl);\n+    llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n+    ccx.item_ids.insert(id, vt_gvar);\n+    ccx.item_symbols.insert(id, name);\n+}\n+\n+fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident], llfty: TypeRef,\n+                 fill: block(ValueRef, @block_ctxt) -> @block_ctxt)\n+    -> ValueRef {\n+    let lcx = @{path: pt, module_path: [],\n+                obj_typarams: [], obj_fields: [], ccx: ccx};\n+    let name = link::mangle_internal_name_by_path(ccx, pt);\n+    let llfn = decl_internal_cdecl_fn(ccx.llmod, name, llfty);\n+    let fcx = new_fn_ctxt(lcx, ast_util::dummy_sp(), llfn);\n+    let bcx = new_top_block_ctxt(fcx), lltop = bcx.llbb;\n+    let bcx = fill(llfn, bcx);\n+    build_return(bcx);\n+    finish_fn(fcx, lltop);\n+    ret llfn;\n+}\n+\n+fn trans_impl_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n+                      extra_tps: [ty::param_bounds], real_fn: ValueRef)\n+    -> ValueRef {\n     let {inputs: real_args, output: real_ret} =\n         llfn_arg_tys(llvm::LLVMGetElementType(val_ty(real_fn)));\n     let extra_ptrs = [];\n@@ -159,32 +191,80 @@ fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n     let wrap_args = [T_ptr(T_dict())] + vec::slice(real_args, 0u, 2u) +\n         vec::slice(real_args, 2u + vec::len(extra_ptrs), vec::len(real_args));\n     let llfn_ty = T_fn(wrap_args, real_ret);\n+    trans_wrapper(ccx, pt, llfn_ty, {|llfn, bcx|\n+        let dict = PointerCast(bcx, LLVMGetParam(llfn, 0u), env_ty);\n+        // retptr, self\n+        let args = [LLVMGetParam(llfn, 1u), LLVMGetParam(llfn, 2u)], i = 0u;\n+        // saved tydescs/dicts\n+        while i < n_extra_ptrs {\n+            i += 1u;\n+            args += [load_inbounds(bcx, dict, [0, i as int])];\n+        }\n+        // the rest of the parameters\n+        let i = 3u, params_total = llvm::LLVMCountParamTypes(llfn_ty);\n+        while i < params_total {\n+            args += [LLVMGetParam(llfn, i)];\n+            i += 1u;\n+        }\n+        Call(bcx, real_fn, args);\n+        bcx\n+    })\n+}\n \n-    let lcx = @{path: pt + [\"wrapper\", m.ident], module_path: [],\n-                obj_typarams: [], obj_fields: [], ccx: ccx};\n-    let name = link::mangle_internal_name_by_path_and_seq(ccx, pt, m.ident);\n-    let llfn = decl_internal_cdecl_fn(ccx.llmod, name, llfn_ty);\n-    let fcx = new_fn_ctxt(lcx, ast_util::dummy_sp(), llfn);\n-    let bcx = new_top_block_ctxt(fcx), lltop = bcx.llbb;\n+fn trans_impl_vtable(ccx: @crate_ctxt, pt: [ast::ident],\n+                     iface_id: ast::def_id, ms: [@ast::method],\n+                     tps: [ast::ty_param], it: @ast::item) {\n+    let new_pt = pt + [it.ident + int::str(it.id), \"wrap\"];\n+    let extra_tps = vec::map(tps, {|p| param_bounds(ccx, p)});\n+    let ptrs = vec::map(*ty::iface_methods(ccx.tcx, iface_id), {|im|\n+        alt vec::find(ms, {|m| m.ident == im.ident}) {\n+          some(m) {\n+            let target = ccx.item_ids.get(m.id);\n+            trans_impl_wrapper(ccx, new_pt + [m.ident], extra_tps, target)\n+          }\n+        }\n+    });\n+    let s = link::mangle_internal_name_by_path(ccx, new_pt + [\"!vtable\"]);\n+    trans_vtable(ccx, it.id, s, ptrs);\n+}\n \n-    let dict = PointerCast(bcx, LLVMGetParam(llfn, 0u), env_ty);\n-    // retptr, self\n-    let args = [LLVMGetParam(llfn, 1u), LLVMGetParam(llfn, 2u)], i = 0u;\n-    // saved tydescs/dicts\n-    while i < n_extra_ptrs {\n-        i += 1u;\n-        args += [load_inbounds(bcx, dict, [0, i as int])];\n-    }\n-    // the rest of the parameters\n-    let i = 3u, params_total = llvm::LLVMCountParamTypes(llfn_ty);\n-    while i < params_total {\n-        args += [LLVMGetParam(llfn, i)];\n+fn trans_iface_wrapper(ccx: @crate_ctxt, pt: [ast::ident], m: ty::method,\n+                       n: uint) -> ValueRef {\n+    let {llty: llfty, _} = wrapper_fn_ty(ccx, T_ptr(T_i8()), m);\n+    trans_wrapper(ccx, pt, llfty, {|llfn, bcx|\n+        let self = Load(bcx, PointerCast(bcx, LLVMGetParam(llfn, 2u),\n+                                         T_ptr(T_opaque_iface_ptr(ccx))));\n+        let boxed = GEPi(bcx, self, [0, abi::box_rc_field_body]);\n+        let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, boxed, [0, 1]),\n+                                         T_ptr(T_ptr(T_dict()))));\n+        let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n+                                 T_ptr(T_array(T_ptr(llfty), n + 1u)));\n+        let mptr = Load(bcx, GEPi(bcx, vtable, [0, n as int]));\n+        // FIXME[impl] This doesn't account for more-than-ptr-sized alignment\n+        let inner_self = GEPi(bcx, boxed, [0, 2]);\n+        let args = [PointerCast(bcx, dict, T_ptr(T_i8())),\n+                    LLVMGetParam(llfn, 1u),\n+                    PointerCast(bcx, inner_self, T_opaque_cbox_ptr(ccx))];\n+        let i = 3u, total = llvm::LLVMCountParamTypes(llfty);\n+        while i < total {\n+            args += [LLVMGetParam(llfn, i)];\n+            i += 1u;\n+        }\n+        Call(bcx, mptr, args);\n+        bcx\n+    })\n+}\n+\n+fn trans_iface_vtable(ccx: @crate_ctxt, pt: [ast::ident], it: @ast::item) {\n+    let new_pt = pt + [it.ident + int::str(it.id)];\n+    let i_did = ast_util::local_def(it.id), i = 0u;\n+    let ptrs = vec::map(*ty::iface_methods(ccx.tcx, i_did), {|m|\n+        let w = trans_iface_wrapper(ccx, new_pt + [m.ident], m, i);\n         i += 1u;\n-    }\n-    Call(bcx, ccx.item_ids.get(m.id), args);\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n-    ret llfn;\n+        w\n+    });\n+    let s = link::mangle_internal_name_by_path(ccx, new_pt + [\"!vtable\"]);\n+    trans_vtable(ccx, it.id, s, ptrs);\n }\n \n fn dict_is_static(tcx: ty::ctxt, origin: typeck::dict_origin) -> bool {\n@@ -193,7 +273,8 @@ fn dict_is_static(tcx: ty::ctxt, origin: typeck::dict_origin) -> bool {\n         vec::all(ts, {|t| !ty::type_contains_params(tcx, t)}) &&\n         vec::all(*origs, {|o| dict_is_static(tcx, o)})\n       }\n-      typeck::dict_param(_, _) { false }\n+      typeck::dict_iface(_) { true }\n+      _ { false }\n     }\n }\n \n@@ -219,14 +300,17 @@ fn get_dict(bcx: @block_ctxt, origin: typeck::dict_origin) -> result {\n       typeck::dict_param(n_param, n_bound) {\n         rslt(bcx, option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound])\n       }\n+      typeck::dict_iface(did) {\n+        ret rslt(bcx, get_static_dict(bcx, origin));\n+      }\n     }\n }\n \n fn dict_id(tcx: ty::ctxt, origin: typeck::dict_origin) -> dict_id {\n     alt origin {\n       typeck::dict_static(did, ts, origs) {\n         let d_params = [], orig = 0u;\n-        if vec::len(ts) == 0u { ret @{impl_def: did, params: d_params}; }\n+        if vec::len(ts) == 0u { ret @{def: did, params: d_params}; }\n         let impl_params = ty::lookup_item_type(tcx, did).bounds;\n         vec::iter2(ts, *impl_params) {|t, bounds|\n             d_params += [dict_param_ty(t)];\n@@ -239,7 +323,10 @@ fn dict_id(tcx: ty::ctxt, origin: typeck::dict_origin) -> dict_id {\n                 }\n             }\n         }\n-        @{impl_def: did, params: d_params}\n+        @{def: did, params: d_params}\n+      }\n+      typeck::dict_iface(did) {\n+        @{def: did, params: []}\n       }\n     }\n }\n@@ -269,16 +356,19 @@ fn get_static_dict(bcx: @block_ctxt, origin: typeck::dict_origin)\n fn get_dict_ptrs(bcx: @block_ctxt, origin: typeck::dict_origin)\n     -> {bcx: @block_ctxt, ptrs: [ValueRef]} {\n     let ccx = bcx_ccx(bcx);\n-    alt origin {\n-      typeck::dict_static(impl_did, tys, sub_origins) {\n-        let vtable = if impl_did.crate == ast::local_crate {\n-            ccx.item_ids.get(impl_did.node)\n+    fn get_vtable(ccx: @crate_ctxt, did: ast::def_id) -> ValueRef {\n+        if did.crate == ast::local_crate {\n+            ccx.item_ids.get(did.node)\n         } else {\n-            let name = csearch::get_symbol(ccx.sess.get_cstore(), impl_did);\n+            let name = csearch::get_symbol(ccx.sess.get_cstore(), did);\n             get_extern_const(ccx.externs, ccx.llmod, name, T_ptr(T_i8()))\n-        };\n+        }\n+    }\n+    alt origin {\n+      typeck::dict_static(impl_did, tys, sub_origins) {\n         let impl_params = ty::lookup_item_type(ccx.tcx, impl_did).bounds;\n-        let ptrs = [vtable], origin = 0u, ti = none, bcx = bcx;\n+        let ptrs = [get_vtable(ccx, impl_did)];\n+        let origin = 0u, ti = none, bcx = bcx;\n         vec::iter2(*impl_params, tys) {|param, ty|\n             let rslt = get_tydesc(bcx, ty, true, tps_normal, ti).result;\n             ptrs += [rslt.val];\n@@ -297,6 +387,9 @@ fn get_dict_ptrs(bcx: @block_ctxt, origin: typeck::dict_origin)\n         }\n         {bcx: bcx, ptrs: ptrs}\n       }\n+      typeck::dict_iface(did) {\n+        {bcx: bcx, ptrs: [get_vtable(ccx, did)]}\n+      }\n     }\n }\n "}, {"sha": "18b602e33aad24c5be7efa197be118298ce31979", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf", "patch": "@@ -20,7 +20,7 @@ import syntax::print::pprust::*;\n \n export check_crate;\n export method_map, method_origin, method_static, method_param, method_iface;\n-export dict_map, dict_res, dict_origin, dict_static, dict_param;\n+export dict_map, dict_res, dict_origin, dict_static, dict_param, dict_iface;\n \n tag method_origin {\n     method_static(ast::def_id);\n@@ -36,6 +36,7 @@ tag dict_origin {\n     dict_static(ast::def_id, [ty::t], dict_res);\n     // Param number, bound number\n     dict_param(uint, uint);\n+    dict_iface(ast::def_id);\n }\n type dict_map = hashmap<ast::node_id, dict_res>;\n \n@@ -2197,24 +2198,20 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n         let t_e = ty::expr_ty(tcx, e);\n \n-        if ty::type_is_nil(tcx, t_e) {\n-            tcx.sess.span_err(expr.span,\n-                              \"cast from nil: \" +\n+        alt ty::struct(tcx, t_1) {\n+          // This will be looked up later on\n+          ty::ty_iface(_, _) {}\n+          _ {\n+            if ty::type_is_nil(tcx, t_e) {\n+                tcx.sess.span_err(expr.span, \"cast from nil: \" +\n                                   ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n-        }\n-\n-        if ty::type_is_nil(tcx, t_1) {\n-            tcx.sess.span_err(expr.span,\n-                              \"cast to nil: \" +\n+            } else if ty::type_is_nil(tcx, t_1) {\n+                tcx.sess.span_err(expr.span, \"cast to nil: \" +\n                                   ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n-        }\n+            }\n \n-        alt ty::struct(tcx, t_1) {\n-          // This will be looked up later on\n-          ty::ty_iface(_, _) {}\n-          _ {\n             let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n             if type_is_c_like_enum(fcx,expr.span,t_e) && t_1_is_scalar {\n                 /* this case is allowed */\n@@ -2942,6 +2939,9 @@ mod dict {\n                 }\n             }\n           }\n+          ty::ty_iface(did, _) {\n+            ret dict_iface(did);\n+          }\n           _ {\n             let found = none;\n             std::list::iter(isc) {|impls|"}, {"sha": "f252eef07bc5ce62df9063bfa822f3d75b42575a", "filename": "src/test/run-pass/iface-cast.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-cast.rs?ref=56fe4c2681f7ef467d8b3405279acbcfc6b0ebcf", "patch": "@@ -33,13 +33,17 @@ impl of to_str for Tree {\n     }\n }\n \n+fn foo<T: to_str>(x: T) -> str { x.to_str() }\n+\n fn main() {\n     let t1 = Tree(@{mutable left: none,\n                     mutable right: none,\n                     val: 1 as to_str });\n     let t2 = Tree(@{mutable left: some(t1),\n                     mutable right: some(t1),\n                     val: 2 as to_str });\n-    assert t2.to_str() == \"[2, some([1, none, none]), some([1, none, none])]\";\n+    let expected = \"[2, some([1, none, none]), some([1, none, none])]\";\n+    assert t2.to_str() == expected;\n+    assert foo(t2 as to_str) == expected;\n     t1.left = some(t2); // create cycle\n }"}]}