{"sha": "3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwODdhMWYzOWVhZWFjOWQ3NmM4YjE1OWRjYzY0ZGU1MTViYjJiODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-09T08:26:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-09T08:26:17Z"}, "message": "Auto merge of #40368 - arielb1:rollup, r=arielb1\n\nRollup of 20 pull requests\n\n- Successful merges: #40154, #40222, #40226, #40237, #40254, #40258, #40265, #40268, #40279, #40283, #40292, #40293, #40296, #40316, #40321, #40325, #40326, #40327, #40333, #40335\n- Failed merges:", "tree": {"sha": "bace37e5277d56098ee4d1bb0727d930d68b650c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bace37e5277d56098ee4d1bb0727d930d68b650c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "html_url": "https://github.com/rust-lang/rust/commit/3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c9208faf1f180cd15cf93f74f1e57b24856d11e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9208faf1f180cd15cf93f74f1e57b24856d11e", "html_url": "https://github.com/rust-lang/rust/commit/5c9208faf1f180cd15cf93f74f1e57b24856d11e"}, {"sha": "f2886e8bda7d628ae0cc16e4fe579cbc2c6dc1b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2886e8bda7d628ae0cc16e4fe579cbc2c6dc1b0", "html_url": "https://github.com/rust-lang/rust/commit/f2886e8bda7d628ae0cc16e4fe579cbc2c6dc1b0"}], "stats": {"total": 6215, "additions": 435, "deletions": 5780}, "files": [{"sha": "bdc14d8c3be714d9b64838f619e0c62f842d45c0", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -18,6 +18,9 @@\n [submodule \"src/liblibc\"]\n \tpath = src/liblibc\n \turl = https://github.com/rust-lang/libc.git\n+[submodule \"src/doc/nomicon\"]\n+\tpath = src/doc/nomicon\n+\turl = https://github.com/rust-lang-nursery/nomicon\n [submodule \"src/tools/cargo\"]\n \tpath = src/tools/cargo\n \turl = https://github.com/rust-lang/cargo"}, {"sha": "f921fb2c94233efa196d6ef16ebc271dc2a813a5", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -406,5 +406,5 @@ are:\n [rr]: https://doc.rust-lang.org/book/README.html\n [tlgba]: http://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/\n [ro]: http://www.rustaceans.org/\n-[rctd]: ./COMPILER_TESTS.md\n+[rctd]: ./src/test/COMPILER_TESTS.md\n [cheatsheet]: https://buildbot.rust-lang.org/homu/"}, {"sha": "79f11144a073d25373cf96784caf07f97c410171", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -149,7 +149,7 @@ $ ./configure\n $ make && sudo make install\n ```\n \n-When using the configure script, the generated config.mk` file may override the\n+When using the configure script, the generated `config.mk` file may override the\n `config.toml` file. To go back to the `config.toml` file, delete the generated\n `config.mk` file.\n "}, {"sha": "1f262b360e3ed7562491c20c44cc308da7f0c4c1", "filename": "src/doc/index.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -28,6 +28,7 @@ Rust provides a number of book-length sets of documentation, collectively\n nicknamed 'The Rust Bookshelf.'\n \n * [The Rust Programming Language][book] teaches you how to program in Rust.\n+* [The Unstable Book][unstable-book] has documentation for unstable features.\n * [The Rustonomicon][nomicon] is your guidebook to the dark arts of unsafe Rust.\n * [The Reference][ref] is not a formal spec, but is more detailed and comprehensive than the book.\n \n@@ -44,4 +45,5 @@ landed before then. That work is being tracked [here][38643].\n [err]: error-index.html\n [book]: book/index.html\n [nomicon]: nomicon/index.html\n+[unstable-book]: unstable-book/index.html\n "}, {"sha": "d08fe97d12b41c1ed8cc7701e545864132783941", "filename": "src/doc/nomicon", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -0,0 +1 @@\n+Subproject commit d08fe97d12b41c1ed8cc7701e545864132783941"}, {"sha": "d577d7b5cc91b4d0099dbd778ad6135f5b66e9e4", "filename": "src/doc/nomicon/src/README.md", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2FREADME.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,38 +0,0 @@\n-# The Rustonomicon\n-\n-#### The Dark Arts of Advanced and Unsafe Rust Programming\n-\n-# NOTE: This is a draft document, and may contain serious errors\n-\n-> Instead of the programs I had hoped for, there came only a shuddering blackness\n-and ineffable loneliness; and I saw at last a fearful truth which no one had\n-ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n-that this language of stone and stridor is not a sentient perpetuation of Rust\n-as London is of Old London and Paris of Old Paris, but that it is in fact\n-quite unsafe, its sprawling body imperfectly embalmed and infested with queer\n-animate things which have nothing to do with it as it was in compilation.\n-\n-This book digs into all the awful details that are necessary to understand in\n-order to write correct Unsafe Rust programs. Due to the nature of this problem,\n-it may lead to unleashing untold horrors that shatter your psyche into a billion\n-infinitesimal fragments of despair.\n-\n-Should you wish a long and happy career of writing Rust programs, you should\n-turn back now and forget you ever saw this book. It is not necessary. However\n-if you intend to write unsafe code -- or just want to dig into the guts of the\n-language -- this book contains invaluable information.\n-\n-Unlike [The Book][trpl] we will be assuming considerable prior knowledge. In\n-particular, you should be comfortable with basic systems programming and Rust.\n-If you don't feel comfortable with these topics, you should consider [reading\n-The Book][trpl] first. Though we will not be assuming that you have, and will\n-take care to occasionally give a refresher on the basics where appropriate. You\n-can skip straight to this book if you want; just know that we won't be\n-explaining everything from the ground up.\n-\n-To be clear, this book goes into deep detail. We're going to dig into\n-exception-safety, pointer aliasing, memory models, and even some type-theory.\n-We will also be spending a lot of time talking about the different kinds\n-of safety and guarantees.\n-\n-[trpl]: ../book/index.html"}, {"sha": "e33dcbbb4188e834798a10d9e5e1111e1e129cf4", "filename": "src/doc/nomicon/src/SUMMARY.md", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2FSUMMARY.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,55 +0,0 @@\n-# Summary\n-\n-[Introduction](README.md)\n-\n-* [Meet Safe and Unsafe](meet-safe-and-unsafe.md)\n-\t* [How Safe and Unsafe Interact](safe-unsafe-meaning.md)\n-\t* [Working with Unsafe](working-with-unsafe.md)\n-* [Data Layout](data.md)\n-\t* [repr(Rust)](repr-rust.md)\n-\t* [Exotically Sized Types](exotic-sizes.md)\n-\t* [Other reprs](other-reprs.md)\n-* [Ownership](ownership.md)\n-\t* [References](references.md)\n-\t* [Lifetimes](lifetimes.md)\n-\t* [Limits of Lifetimes](lifetime-mismatch.md)\n-\t* [Lifetime Elision](lifetime-elision.md)\n-\t* [Unbounded Lifetimes](unbounded-lifetimes.md)\n-\t* [Higher-Rank Trait Bounds](hrtb.md)\n-\t* [Subtyping and Variance](subtyping.md)\n-\t* [Drop Check](dropck.md)\n-\t* [PhantomData](phantom-data.md)\n-\t* [Splitting Borrows](borrow-splitting.md)\n-* [Type Conversions](conversions.md)\n-\t* [Coercions](coercions.md)\n-\t* [The Dot Operator](dot-operator.md)\n-\t* [Casts](casts.md)\n-\t* [Transmutes](transmutes.md)\n-* [Uninitialized Memory](uninitialized.md)\n-\t* [Checked](checked-uninit.md)\n-\t* [Drop Flags](drop-flags.md)\n-\t* [Unchecked](unchecked-uninit.md)\n-* [Ownership Based Resource Management](obrm.md)\n-\t* [Constructors](constructors.md)\n-\t* [Destructors](destructors.md)\n-\t* [Leaking](leaking.md)\n-* [Unwinding](unwinding.md)\n-\t* [Exception Safety](exception-safety.md)\n-\t* [Poisoning](poisoning.md)\n-* [Concurrency](concurrency.md)\n-\t* [Races](races.md)\n-\t* [Send and Sync](send-and-sync.md)\n-\t* [Atomics](atomics.md)\n-* [Implementing Vec](vec.md)\n-\t* [Layout](vec-layout.md)\n-\t* [Allocating](vec-alloc.md)\n-\t* [Push and Pop](vec-push-pop.md)\n-\t* [Deallocating](vec-dealloc.md)\n-\t* [Deref](vec-deref.md)\n-\t* [Insert and Remove](vec-insert-remove.md)\n-\t* [IntoIter](vec-into-iter.md)\n-\t* [RawVec](vec-raw.md)\n-\t* [Drain](vec-drain.md)\n-\t* [Handling Zero-Sized Types](vec-zsts.md)\n-\t* [Final Code](vec-final.md)\n-* [Implementing Arc and Mutex](arc-and-mutex.md)"}, {"sha": "fedc7b8bd6a18dcf925ec63a1deffcc088011331", "filename": "src/doc/nomicon/src/arc-and-mutex.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Farc-and-mutex.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Farc-and-mutex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Farc-and-mutex.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,7 +0,0 @@\n-# Implementing Arc and Mutex\n-\n-Knowing the theory is all fine and good, but the *best* way to understand\n-something is to use it. To better understand atomics and interior mutability,\n-we'll be implementing versions of the standard library's Arc and Mutex types.\n-\n-TODO: ALL OF THIS OMG"}, {"sha": "e9ed21a93e00a317ce6e4460115a4ffaddaf4ad6", "filename": "src/doc/nomicon/src/atomics.md", "status": "removed", "additions": 0, "deletions": 255, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fatomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fatomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fatomics.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,255 +0,0 @@\n-# Atomics\n-\n-Rust pretty blatantly just inherits C11's memory model for atomics. This is not\n-due to this model being particularly excellent or easy to understand. Indeed,\n-this model is quite complex and known to have [several flaws][C11-busted].\n-Rather, it is a pragmatic concession to the fact that *everyone* is pretty bad\n-at modeling atomics. At very least, we can benefit from existing tooling and\n-research around C.\n-\n-Trying to fully explain the model in this book is fairly hopeless. It's defined\n-in terms of madness-inducing causality graphs that require a full book to\n-properly understand in a practical way. If you want all the nitty-gritty\n-details, you should check out [C's specification (Section 7.17)][C11-model].\n-Still, we'll try to cover the basics and some of the problems Rust developers\n-face.\n-\n-The C11 memory model is fundamentally about trying to bridge the gap between the\n-semantics we want, the optimizations compilers want, and the inconsistent chaos\n-our hardware wants. *We* would like to just write programs and have them do\n-exactly what we said but, you know, fast. Wouldn't that be great?\n-\n-\n-\n-\n-# Compiler Reordering\n-\n-Compilers fundamentally want to be able to do all sorts of complicated\n-transformations to reduce data dependencies and eliminate dead code. In\n-particular, they may radically change the actual order of events, or make events\n-never occur! If we write something like\n-\n-```rust,ignore\n-x = 1;\n-y = 3;\n-x = 2;\n-```\n-\n-The compiler may conclude that it would be best if your program did\n-\n-```rust,ignore\n-x = 2;\n-y = 3;\n-```\n-\n-This has inverted the order of events and completely eliminated one event.\n-From a single-threaded perspective this is completely unobservable: after all\n-the statements have executed we are in exactly the same state. But if our\n-program is multi-threaded, we may have been relying on `x` to actually be\n-assigned to 1 before `y` was assigned. We would like the compiler to be\n-able to make these kinds of optimizations, because they can seriously improve\n-performance. On the other hand, we'd also like to be able to depend on our\n-program *doing the thing we said*.\n-\n-\n-\n-\n-# Hardware Reordering\n-\n-On the other hand, even if the compiler totally understood what we wanted and\n-respected our wishes, our hardware might instead get us in trouble. Trouble\n-comes from CPUs in the form of memory hierarchies. There is indeed a global\n-shared memory space somewhere in your hardware, but from the perspective of each\n-CPU core it is *so very far away* and *so very slow*. Each CPU would rather work\n-with its local cache of the data and only go through all the anguish of\n-talking to shared memory only when it doesn't actually have that memory in\n-cache.\n-\n-After all, that's the whole point of the cache, right? If every read from the\n-cache had to run back to shared memory to double check that it hadn't changed,\n-what would the point be? The end result is that the hardware doesn't guarantee\n-that events that occur in the same order on *one* thread, occur in the same\n-order on *another* thread. To guarantee this, we must issue special instructions\n-to the CPU telling it to be a bit less smart.\n-\n-For instance, say we convince the compiler to emit this logic:\n-\n-```text\n-initial state: x = 0, y = 1\n-\n-THREAD 1        THREAD2\n-y = 3;          if x == 1 {\n-x = 1;              y *= 2;\n-                }\n-```\n-\n-Ideally this program has 2 possible final states:\n-\n-* `y = 3`: (thread 2 did the check before thread 1 completed)\n-* `y = 6`: (thread 2 did the check after thread 1 completed)\n-\n-However there's a third potential state that the hardware enables:\n-\n-* `y = 2`: (thread 2 saw `x = 1`, but not `y = 3`, and then overwrote `y = 3`)\n-\n-It's worth noting that different kinds of CPU provide different guarantees. It\n-is common to separate hardware into two categories: strongly-ordered and weakly-\n-ordered. Most notably x86/64 provides strong ordering guarantees, while ARM\n-provides weak ordering guarantees. This has two consequences for concurrent\n-programming:\n-\n-* Asking for stronger guarantees on strongly-ordered hardware may be cheap or\n-  even free because they already provide strong guarantees unconditionally.\n-  Weaker guarantees may only yield performance wins on weakly-ordered hardware.\n-\n-* Asking for guarantees that are too weak on strongly-ordered hardware is\n-  more likely to *happen* to work, even though your program is strictly\n-  incorrect. If possible, concurrent algorithms should be tested on\n-  weakly-ordered hardware.\n-\n-\n-\n-\n-\n-# Data Accesses\n-\n-The C11 memory model attempts to bridge the gap by allowing us to talk about the\n-*causality* of our program. Generally, this is by establishing a *happens\n-before* relationship between parts of the program and the threads that are\n-running them. This gives the hardware and compiler room to optimize the program\n-more aggressively where a strict happens-before relationship isn't established,\n-but forces them to be more careful where one is established. The way we\n-communicate these relationships are through *data accesses* and *atomic\n-accesses*.\n-\n-Data accesses are the bread-and-butter of the programming world. They are\n-fundamentally unsynchronized and compilers are free to aggressively optimize\n-them. In particular, data accesses are free to be reordered by the compiler on\n-the assumption that the program is single-threaded. The hardware is also free to\n-propagate the changes made in data accesses to other threads as lazily and\n-inconsistently as it wants. Most critically, data accesses are how data races\n-happen. Data accesses are very friendly to the hardware and compiler, but as\n-we've seen they offer *awful* semantics to try to write synchronized code with.\n-Actually, that's too weak.\n-\n-**It is literally impossible to write correct synchronized code using only data\n-accesses.**\n-\n-Atomic accesses are how we tell the hardware and compiler that our program is\n-multi-threaded. Each atomic access can be marked with an *ordering* that\n-specifies what kind of relationship it establishes with other accesses. In\n-practice, this boils down to telling the compiler and hardware certain things\n-they *can't* do. For the compiler, this largely revolves around re-ordering of\n-instructions. For the hardware, this largely revolves around how writes are\n-propagated to other threads. The set of orderings Rust exposes are:\n-\n-* Sequentially Consistent (SeqCst)\n-* Release\n-* Acquire\n-* Relaxed\n-\n-(Note: We explicitly do not expose the C11 *consume* ordering)\n-\n-TODO: negative reasoning vs positive reasoning? TODO: \"can't forget to\n-synchronize\"\n-\n-\n-\n-# Sequentially Consistent\n-\n-Sequentially Consistent is the most powerful of all, implying the restrictions\n-of all other orderings. Intuitively, a sequentially consistent operation\n-cannot be reordered: all accesses on one thread that happen before and after a\n-SeqCst access stay before and after it. A data-race-free program that uses\n-only sequentially consistent atomics and data accesses has the very nice\n-property that there is a single global execution of the program's instructions\n-that all threads agree on. This execution is also particularly nice to reason\n-about: it's just an interleaving of each thread's individual executions. This\n-does not hold if you start using the weaker atomic orderings.\n-\n-The relative developer-friendliness of sequential consistency doesn't come for\n-free. Even on strongly-ordered platforms sequential consistency involves\n-emitting memory fences.\n-\n-In practice, sequential consistency is rarely necessary for program correctness.\n-However sequential consistency is definitely the right choice if you're not\n-confident about the other memory orders. Having your program run a bit slower\n-than it needs to is certainly better than it running incorrectly! It's also\n-mechanically trivial to downgrade atomic operations to have a weaker\n-consistency later on. Just change `SeqCst` to `Relaxed` and you're done! Of\n-course, proving that this transformation is *correct* is a whole other matter.\n-\n-\n-\n-\n-# Acquire-Release\n-\n-Acquire and Release are largely intended to be paired. Their names hint at their\n-use case: they're perfectly suited for acquiring and releasing locks, and\n-ensuring that critical sections don't overlap.\n-\n-Intuitively, an acquire access ensures that every access after it stays after\n-it. However operations that occur before an acquire are free to be reordered to\n-occur after it. Similarly, a release access ensures that every access before it\n-stays before it. However operations that occur after a release are free to be\n-reordered to occur before it.\n-\n-When thread A releases a location in memory and then thread B subsequently\n-acquires *the same* location in memory, causality is established. Every write\n-that happened before A's release will be observed by B after its release.\n-However no causality is established with any other threads. Similarly, no\n-causality is established if A and B access *different* locations in memory.\n-\n-Basic use of release-acquire is therefore simple: you acquire a location of\n-memory to begin the critical section, and then release that location to end it.\n-For instance, a simple spinlock might look like:\n-\n-```rust\n-use std::sync::Arc;\n-use std::sync::atomic::{AtomicBool, Ordering};\n-use std::thread;\n-\n-fn main() {\n-    let lock = Arc::new(AtomicBool::new(false)); // value answers \"am I locked?\"\n-\n-    // ... distribute lock to threads somehow ...\n-\n-    // Try to acquire the lock by setting it to true\n-    while lock.compare_and_swap(false, true, Ordering::Acquire) { }\n-    // broke out of the loop, so we successfully acquired the lock!\n-\n-    // ... scary data accesses ...\n-\n-    // ok we're done, release the lock\n-    lock.store(false, Ordering::Release);\n-}\n-```\n-\n-On strongly-ordered platforms most accesses have release or acquire semantics,\n-making release and acquire often totally free. This is not the case on\n-weakly-ordered platforms.\n-\n-\n-\n-\n-# Relaxed\n-\n-Relaxed accesses are the absolute weakest. They can be freely re-ordered and\n-provide no happens-before relationship. Still, relaxed operations are still\n-atomic. That is, they don't count as data accesses and any read-modify-write\n-operations done to them occur atomically. Relaxed operations are appropriate for\n-things that you definitely want to happen, but don't particularly otherwise care\n-about. For instance, incrementing a counter can be safely done by multiple\n-threads using a relaxed `fetch_add` if you're not using the counter to\n-synchronize any other accesses.\n-\n-There's rarely a benefit in making an operation relaxed on strongly-ordered\n-platforms, since they usually provide release-acquire semantics anyway. However\n-relaxed operations can be cheaper on weakly-ordered platforms.\n-\n-\n-\n-\n-\n-[C11-busted]: http://plv.mpi-sws.org/c11comp/popl15.pdf\n-[C11-model]: http://www.open-std.org/jtc1/sc22/wg14/www/standards.html#9899"}, {"sha": "28ddb507ae27d7fe6da3d8e36f87a1fe90155a89", "filename": "src/doc/nomicon/src/borrow-splitting.md", "status": "removed", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fborrow-splitting.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fborrow-splitting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fborrow-splitting.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,291 +0,0 @@\n-# Splitting Borrows\n-\n-The mutual exclusion property of mutable references can be very limiting when\n-working with a composite structure. The borrow checker understands some basic\n-stuff, but will fall over pretty easily. It does understand structs\n-sufficiently to know that it's possible to borrow disjoint fields of a struct\n-simultaneously. So this works today:\n-\n-```rust\n-struct Foo {\n-    a: i32,\n-    b: i32,\n-    c: i32,\n-}\n-\n-let mut x = Foo {a: 0, b: 0, c: 0};\n-let a = &mut x.a;\n-let b = &mut x.b;\n-let c = &x.c;\n-*b += 1;\n-let c2 = &x.c;\n-*a += 10;\n-println!(\"{} {} {} {}\", a, b, c, c2);\n-```\n-\n-However borrowck doesn't understand arrays or slices in any way, so this doesn't\n-work:\n-\n-```rust,ignore\n-let mut x = [1, 2, 3];\n-let a = &mut x[0];\n-let b = &mut x[1];\n-println!(\"{} {}\", a, b);\n-```\n-\n-```text\n-<anon>:4:14: 4:18 error: cannot borrow `x[..]` as mutable more than once at a time\n-<anon>:4 let b = &mut x[1];\n-                      ^~~~\n-<anon>:3:14: 3:18 note: previous borrow of `x[..]` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x[..]` until the borrow ends\n-<anon>:3 let a = &mut x[0];\n-                      ^~~~\n-<anon>:6:2: 6:2 note: previous borrow ends here\n-<anon>:1 fn main() {\n-<anon>:2 let mut x = [1, 2, 3];\n-<anon>:3 let a = &mut x[0];\n-<anon>:4 let b = &mut x[1];\n-<anon>:5 println!(\"{} {}\", a, b);\n-<anon>:6 }\n-         ^\n-error: aborting due to 2 previous errors\n-```\n-\n-While it was plausible that borrowck could understand this simple case, it's\n-pretty clearly hopeless for borrowck to understand disjointness in general\n-container types like a tree, especially if distinct keys actually *do* map\n-to the same value.\n-\n-In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\n-to unsafe code. For instance, mutable slices expose a `split_at_mut` function\n-that consumes the slice and returns two mutable slices. One for everything to\n-the left of the index, and one for everything to the right. Intuitively we know\n-this is safe because the slices don't overlap, and therefore alias. However\n-the implementation requires some unsafety:\n-\n-```rust,ignore\n-fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-    let len = self.len();\n-    let ptr = self.as_mut_ptr();\n-    assert!(mid <= len);\n-    unsafe {\n-        (from_raw_parts_mut(ptr, mid),\n-         from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n-    }\n-}\n-```\n-\n-This is actually a bit subtle. So as to avoid ever making two `&mut`'s to the\n-same value, we explicitly construct brand-new slices through raw pointers.\n-\n-However more subtle is how iterators that yield mutable references work.\n-The iterator trait is defined as follows:\n-\n-```rust\n-trait Iterator {\n-    type Item;\n-\n-    fn next(&mut self) -> Option<Self::Item>;\n-}\n-```\n-\n-Given this definition, Self::Item has *no* connection to `self`. This means that\n-we can call `next` several times in a row, and hold onto all the results\n-*concurrently*. This is perfectly fine for by-value iterators, which have\n-exactly these semantics. It's also actually fine for shared references, as they\n-admit arbitrarily many references to the same thing (although the iterator needs\n-to be a separate object from the thing being shared).\n-\n-But mutable references make this a mess. At first glance, they might seem\n-completely incompatible with this API, as it would produce multiple mutable\n-references to the same object!\n-\n-However it actually *does* work, exactly because iterators are one-shot objects.\n-Everything an IterMut yields will be yielded at most once, so we don't\n-actually ever yield multiple mutable references to the same piece of data.\n-\n-Perhaps surprisingly, mutable iterators don't require unsafe code to be\n-implemented for many types!\n-\n-For instance here's a singly linked list:\n-\n-```rust\n-# fn main() {}\n-type Link<T> = Option<Box<Node<T>>>;\n-\n-struct Node<T> {\n-    elem: T,\n-    next: Link<T>,\n-}\n-\n-pub struct LinkedList<T> {\n-    head: Link<T>,\n-}\n-\n-pub struct IterMut<'a, T: 'a>(Option<&'a mut Node<T>>);\n-\n-impl<T> LinkedList<T> {\n-    fn iter_mut(&mut self) -> IterMut<T> {\n-        IterMut(self.head.as_mut().map(|node| &mut **node))\n-    }\n-}\n-\n-impl<'a, T> Iterator for IterMut<'a, T> {\n-    type Item = &'a mut T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.0.take().map(|node| {\n-            self.0 = node.next.as_mut().map(|node| &mut **node);\n-            &mut node.elem\n-        })\n-    }\n-}\n-```\n-\n-Here's a mutable slice:\n-\n-```rust\n-# fn main() {}\n-use std::mem;\n-\n-pub struct IterMut<'a, T: 'a>(&'a mut[T]);\n-\n-impl<'a, T> Iterator for IterMut<'a, T> {\n-    type Item = &'a mut T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let slice = mem::replace(&mut self.0, &mut []);\n-        if slice.is_empty() { return None; }\n-\n-        let (l, r) = slice.split_at_mut(1);\n-        self.0 = r;\n-        l.get_mut(0)\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        let slice = mem::replace(&mut self.0, &mut []);\n-        if slice.is_empty() { return None; }\n-\n-        let new_len = slice.len() - 1;\n-        let (l, r) = slice.split_at_mut(new_len);\n-        self.0 = l;\n-        r.get_mut(0)\n-    }\n-}\n-```\n-\n-And here's a binary tree:\n-\n-```rust\n-# fn main() {}\n-use std::collections::VecDeque;\n-\n-type Link<T> = Option<Box<Node<T>>>;\n-\n-struct Node<T> {\n-    elem: T,\n-    left: Link<T>,\n-    right: Link<T>,\n-}\n-\n-pub struct Tree<T> {\n-    root: Link<T>,\n-}\n-\n-struct NodeIterMut<'a, T: 'a> {\n-    elem: Option<&'a mut T>,\n-    left: Option<&'a mut Node<T>>,\n-    right: Option<&'a mut Node<T>>,\n-}\n-\n-enum State<'a, T: 'a> {\n-    Elem(&'a mut T),\n-    Node(&'a mut Node<T>),\n-}\n-\n-pub struct IterMut<'a, T: 'a>(VecDeque<NodeIterMut<'a, T>>);\n-\n-impl<T> Tree<T> {\n-    pub fn iter_mut(&mut self) -> IterMut<T> {\n-        let mut deque = VecDeque::new();\n-        self.root.as_mut().map(|root| deque.push_front(root.iter_mut()));\n-        IterMut(deque)\n-    }\n-}\n-\n-impl<T> Node<T> {\n-    pub fn iter_mut(&mut self) -> NodeIterMut<T> {\n-        NodeIterMut {\n-            elem: Some(&mut self.elem),\n-            left: self.left.as_mut().map(|node| &mut **node),\n-            right: self.right.as_mut().map(|node| &mut **node),\n-        }\n-    }\n-}\n-\n-\n-impl<'a, T> Iterator for NodeIterMut<'a, T> {\n-    type Item = State<'a, T>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.left.take() {\n-            Some(node) => Some(State::Node(node)),\n-            None => match self.elem.take() {\n-                Some(elem) => Some(State::Elem(elem)),\n-                None => match self.right.take() {\n-                    Some(node) => Some(State::Node(node)),\n-                    None => None,\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator for NodeIterMut<'a, T> {\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        match self.right.take() {\n-            Some(node) => Some(State::Node(node)),\n-            None => match self.elem.take() {\n-                Some(elem) => Some(State::Elem(elem)),\n-                None => match self.left.take() {\n-                    Some(node) => Some(State::Node(node)),\n-                    None => None,\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T> Iterator for IterMut<'a, T> {\n-    type Item = &'a mut T;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        loop {\n-            match self.0.front_mut().and_then(|node_it| node_it.next()) {\n-                Some(State::Elem(elem)) => return Some(elem),\n-                Some(State::Node(node)) => self.0.push_front(node.iter_mut()),\n-                None => if let None = self.0.pop_front() { return None },\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        loop {\n-            match self.0.back_mut().and_then(|node_it| node_it.next_back()) {\n-                Some(State::Elem(elem)) => return Some(elem),\n-                Some(State::Node(node)) => self.0.push_back(node.iter_mut()),\n-                None => if let None = self.0.pop_back() { return None },\n-            }\n-        }\n-    }\n-}\n-```\n-\n-All of these are completely safe and work on stable Rust! This ultimately\n-falls out of the simple struct case we saw before: Rust understands that you\n-can safely split a mutable reference into subfields. We can then encode\n-permanently consuming a reference via Options (or in the case of slices,\n-replacing with an empty slice)."}, {"sha": "31b78587245404ce78c87e3883f3a313ef967917", "filename": "src/doc/nomicon/src/casts.md", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fcasts.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fcasts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fcasts.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,71 +0,0 @@\n-# Casts\n-\n-Casts are a superset of coercions: every coercion can be explicitly\n-invoked via a cast. However some conversions require a cast.\n-While coercions are pervasive and largely harmless, these \"true casts\"\n-are rare and potentially dangerous. As such, casts must be explicitly invoked\n-using the `as` keyword: `expr as Type`.\n-\n-True casts generally revolve around raw pointers and the primitive numeric\n-types. Even though they're dangerous, these casts are infallible at runtime.\n-If a cast triggers some subtle corner case no indication will be given that\n-this occurred. The cast will simply succeed. That said, casts must be valid\n-at the type level, or else they will be prevented statically. For instance,\n-`7u8 as bool` will not compile.\n-\n-That said, casts aren't `unsafe` because they generally can't violate memory\n-safety *on their own*. For instance, converting an integer to a raw pointer can\n-very easily lead to terrible things. However the act of creating the pointer\n-itself is safe, because actually using a raw pointer is already marked as\n-`unsafe`.\n-\n-Here's an exhaustive list of all the true casts. For brevity, we will use `*`\n-to denote either a `*const` or `*mut`, and `integer` to denote any integral\n-primitive:\n-\n- * `*T as *U` where `T, U: Sized`\n- * `*T as *U` TODO: explain unsized situation\n- * `*T as integer`\n- * `integer as *T`\n- * `number as number`\n- * `C-like-enum as integer`\n- * `bool as integer`\n- * `char as integer`\n- * `u8 as char`\n- * `&[T; n] as *const T`\n- * `fn as *T` where `T: Sized`\n- * `fn as integer`\n-\n-Note that lengths are not adjusted when casting raw slices -\n-`*const [u16] as *const [u8]` creates a slice that only includes\n-half of the original memory.\n-\n-Casting is not transitive, that is, even if `e as U1 as U2` is a valid\n-expression, `e as U2` is not necessarily so.\n-\n-For numeric casts, there are quite a few cases to consider:\n-\n-* casting between two integers of the same size (e.g. i32 -> u32) is a no-op\n-* casting from a larger integer to a smaller integer (e.g. u32 -> u8) will\n-  truncate\n-* casting from a smaller integer to a larger integer (e.g. u8 -> u32) will\n-    * zero-extend if the source is unsigned\n-    * sign-extend if the source is signed\n-* casting from a float to an integer will round the float towards zero\n-    * **[NOTE: currently this will cause Undefined Behavior if the rounded\n-      value cannot be represented by the target integer type][float-int]**.\n-      This includes Inf and NaN. This is a bug and will be fixed.\n-* casting from an integer to float will produce the floating point\n-  representation of the integer, rounded if necessary (rounding strategy\n-  unspecified)\n-* casting from an f32 to an f64 is perfect and lossless\n-* casting from an f64 to an f32 will produce the closest possible value\n-  (rounding strategy unspecified)\n-    * **[NOTE: currently this will cause Undefined Behavior if the value\n-      is finite but larger or smaller than the largest or smallest finite\n-      value representable by f32][float-float]**. This is a bug and will\n-      be fixed.\n-\n-\n-[float-int]: https://github.com/rust-lang/rust/issues/10184\n-[float-float]: https://github.com/rust-lang/rust/issues/15536"}, {"sha": "b743fda354692a44400c2c21ae0fb71c2d5a30d5", "filename": "src/doc/nomicon/src/chapter_1.md", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fchapter_1.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fchapter_1.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fchapter_1.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1 +0,0 @@\n-# Chapter 1"}, {"sha": "4423404fe6e9c4256b0baa8e269e7b117983d866", "filename": "src/doc/nomicon/src/checked-uninit.md", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fchecked-uninit.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,117 +0,0 @@\n-# Checked Uninitialized Memory\n-\n-Like C, all stack variables in Rust are uninitialized until a value is\n-explicitly assigned to them. Unlike C, Rust statically prevents you from ever\n-reading them until you do:\n-\n-```rust,ignore\n-fn main() {\n-    let x: i32;\n-    println!(\"{}\", x);\n-}\n-```\n-\n-```text\n-src/main.rs:3:20: 3:21 error: use of possibly uninitialized variable: `x`\n-src/main.rs:3     println!(\"{}\", x);\n-                                 ^\n-```\n-\n-This is based off of a basic branch analysis: every branch must assign a value\n-to `x` before it is first used. Interestingly, Rust doesn't require the variable\n-to be mutable to perform a delayed initialization if every branch assigns\n-exactly once. However the analysis does not take advantage of constant analysis\n-or anything like that. So this compiles:\n-\n-```rust\n-fn main() {\n-    let x: i32;\n-\n-    if true {\n-        x = 1;\n-    } else {\n-        x = 2;\n-    }\n-\n-    println!(\"{}\", x);\n-}\n-```\n-\n-but this doesn't:\n-\n-```rust,ignore\n-fn main() {\n-    let x: i32;\n-    if true {\n-        x = 1;\n-    }\n-    println!(\"{}\", x);\n-}\n-```\n-\n-```text\n-src/main.rs:6:17: 6:18 error: use of possibly uninitialized variable: `x`\n-src/main.rs:6   println!(\"{}\", x);\n-```\n-\n-while this does:\n-\n-```rust\n-fn main() {\n-    let x: i32;\n-    if true {\n-        x = 1;\n-        println!(\"{}\", x);\n-    }\n-    // Don't care that there are branches where it's not initialized\n-    // since we don't use the value in those branches\n-}\n-```\n-\n-Of course, while the analysis doesn't consider actual values, it does\n-have a relatively sophisticated understanding of dependencies and control\n-flow. For instance, this works:\n-\n-```rust\n-let x: i32;\n-\n-loop {\n-    // Rust doesn't understand that this branch will be taken unconditionally,\n-    // because it relies on actual values.\n-    if true {\n-        // But it does understand that it will only be taken once because\n-        // we unconditionally break out of it. Therefore `x` doesn't\n-        // need to be marked as mutable.\n-        x = 0;\n-        break;\n-    }\n-}\n-// It also knows that it's impossible to get here without reaching the break.\n-// And therefore that `x` must be initialized here!\n-println!(\"{}\", x);\n-```\n-\n-If a value is moved out of a variable, that variable becomes logically\n-uninitialized if the type of the value isn't Copy. That is:\n-\n-```rust\n-fn main() {\n-    let x = 0;\n-    let y = Box::new(0);\n-    let z1 = x; // x is still valid because i32 is Copy\n-    let z2 = y; // y is now logically uninitialized because Box isn't Copy\n-}\n-```\n-\n-However reassigning `y` in this example *would* require `y` to be marked as\n-mutable, as a Safe Rust program could observe that the value of `y` changed:\n-\n-```rust\n-fn main() {\n-    let mut y = Box::new(0);\n-    let z = y; // y is now logically uninitialized because Box isn't Copy\n-    y = Box::new(1); // reinitialize y\n-}\n-```\n-\n-Otherwise it's like `y` is a brand new variable."}, {"sha": "1a51bb5a9c614db1e1ab3eea1a2553abc34f2f3f", "filename": "src/doc/nomicon/src/coercions.md", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fcoercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fcoercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fcoercions.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,72 +0,0 @@\n-# Coercions\n-\n-Types can implicitly be coerced to change in certain contexts. These changes are\n-generally just *weakening* of types, largely focused around pointers and\n-lifetimes. They mostly exist to make Rust \"just work\" in more cases, and are\n-largely harmless.\n-\n-Here's all the kinds of coercion:\n-\n-Coercion is allowed between the following types:\n-\n-* Transitivity: `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to\n-  `T_3`\n-* Pointer Weakening:\n-    * `&mut T` to `&T`\n-    * `*mut T` to `*const T`\n-    * `&T` to `*const T`\n-    * `&mut T` to `*mut T`\n-* Unsizing: `T` to `U` if `T` implements `CoerceUnsized<U>`\n-* Deref coercion: Expression `&x` of type `&T` to `&*x` of type `&U` if `T` derefs to `U` (i.e. `T: Deref<Target=U>`)\n-\n-`CoerceUnsized<Pointer<U>> for Pointer<T> where T: Unsize<U>` is implemented\n-for all pointer types (including smart pointers like Box and Rc). Unsize is\n-only implemented automatically, and enables the following transformations:\n-\n-* `[T; n]` => `[T]`\n-* `T` => `Trait` where `T: Trait`\n-* `Foo<..., T, ...>` => `Foo<..., U, ...>` where:\n-    * `T: Unsize<U>`\n-    * `Foo` is a struct\n-    * Only the last field of `Foo` has type involving `T`\n-    * `T` is not part of the type of any other fields\n-    * `Bar<T>: Unsize<Bar<U>>`, if the last field of `Foo` has type `Bar<T>`\n-\n-Coercions occur at a *coercion site*. Any location that is explicitly typed\n-will cause a coercion to its type. If inference is necessary, the coercion will\n-not be performed. Exhaustively, the coercion sites for an expression `e` to\n-type `U` are:\n-\n-* let statements, statics, and consts: `let x: U = e`\n-* Arguments to functions: `takes_a_U(e)`\n-* Any expression that will be returned: `fn foo() -> U { e }`\n-* Struct literals: `Foo { some_u: e }`\n-* Array literals: `let x: [U; 10] = [e, ..]`\n-* Tuple literals: `let x: (U, ..) = (e, ..)`\n-* The last expression in a block: `let x: U = { ..; e }`\n-\n-Note that we do not perform coercions when matching traits (except for\n-receivers, see below). If there is an impl for some type `U` and `T` coerces to\n-`U`, that does not constitute an implementation for `T`. For example, the\n-following will not type check, even though it is OK to coerce `t` to `&T` and\n-there is an impl for `&T`:\n-\n-```rust,ignore\n-trait Trait {}\n-\n-fn foo<X: Trait>(t: X) {}\n-\n-impl<'a> Trait for &'a i32 {}\n-\n-\n-fn main() {\n-    let t: &mut i32 = &mut 0;\n-    foo(t);\n-}\n-```\n-\n-```text\n-<anon>:10:5: 10:8 error: the trait bound `&mut i32 : Trait` is not satisfied [E0277]\n-<anon>:10     foo(t);\n-              ^~~\n-```"}, {"sha": "6205199bfcc44fd2ea692d01d59d48bd3b31ed1a", "filename": "src/doc/nomicon/src/concurrency.md", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fconcurrency.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,13 +0,0 @@\n-# Concurrency and Parallelism\n-\n-Rust as a language doesn't *really* have an opinion on how to do concurrency or\n-parallelism. The standard library exposes OS threads and blocking sys-calls\n-because everyone has those, and they're uniform enough that you can provide\n-an abstraction over them in a relatively uncontroversial way. Message passing,\n-green threads, and async APIs are all diverse enough that any abstraction over\n-them tends to involve trade-offs that we weren't willing to commit to for 1.0.\n-\n-However the way Rust models concurrency makes it relatively easy to design your own\n-concurrency paradigm as a library and have everyone else's code Just Work\n-with yours. Just require the right lifetimes and Send and Sync where appropriate\n-and you're off to the races. Or rather, off to the... not... having... races."}, {"sha": "b79e72dbae2bf550e32cc6f07775c92cb3c5c65f", "filename": "src/doc/nomicon/src/constructors.md", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fconstructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fconstructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fconstructors.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,59 +0,0 @@\n-# Constructors\n-\n-There is exactly one way to create an instance of a user-defined type: name it,\n-and initialize all its fields at once:\n-\n-```rust\n-struct Foo {\n-    a: u8,\n-    b: u32,\n-    c: bool,\n-}\n-\n-enum Bar {\n-    X(u32),\n-    Y(bool),\n-}\n-\n-struct Unit;\n-\n-let foo = Foo { a: 0, b: 1, c: false };\n-let bar = Bar::X(0);\n-let empty = Unit;\n-```\n-\n-That's it. Every other way you make an instance of a type is just calling a\n-totally vanilla function that does some stuff and eventually bottoms out to The\n-One True Constructor.\n-\n-Unlike C++, Rust does not come with a slew of built-in kinds of constructor.\n-There are no Copy, Default, Assignment, Move, or whatever constructors. The\n-reasons for this are varied, but it largely boils down to Rust's philosophy of\n-*being explicit*.\n-\n-Move constructors are meaningless in Rust because we don't enable types to\n-\"care\" about their location in memory. Every type must be ready for it to be\n-blindly memcopied to somewhere else in memory. This means pure on-the-stack-but-\n-still-movable intrusive linked lists are simply not happening in Rust (safely).\n-\n-Assignment and copy constructors similarly don't exist because move semantics\n-are the only semantics in Rust. At most `x = y` just moves the bits of y into\n-the x variable. Rust does provide two facilities for providing C++'s copy-\n-oriented semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy\n-constructor, but it's never implicitly invoked. You have to explicitly call\n-`clone` on an element you want to be cloned. Copy is a special case of Clone\n-where the implementation is just \"copy the bits\". Copy types *are* implicitly\n-cloned whenever they're moved, but because of the definition of Copy this just\n-means not treating the old copy as uninitialized -- a no-op.\n-\n-While Rust provides a `Default` trait for specifying the moral equivalent of a\n-default constructor, it's incredibly rare for this trait to be used. This is\n-because variables [aren't implicitly initialized][uninit]. Default is basically\n-only useful for generic programming. In concrete contexts, a type will provide a\n-static `new` method for any kind of \"default\" constructor. This has no relation\n-to `new` in other languages and has no special meaning. It's just a naming\n-convention.\n-\n-TODO: talk about \"placement new\"?\n-\n-[uninit]: uninitialized.html"}, {"sha": "388d003d9b6c21d10adb3d9ee1a127c133f1e874", "filename": "src/doc/nomicon/src/conversions.md", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fconversions.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,34 +0,0 @@\n-# Type Conversions\n-\n-At the end of the day, everything is just a pile of bits somewhere, and type\n-systems are just there to help us use those bits right. There are two common\n-problems with typing bits: needing to reinterpret those exact bits as a\n-different type, and needing to change the bits to have equivalent meaning for\n-a different type. Because Rust encourages encoding important properties in the\n-type system, these problems are incredibly pervasive. As such, Rust\n-consequently gives you several ways to solve them.\n-\n-First we'll look at the ways that Safe Rust gives you to reinterpret values.\n-The most trivial way to do this is to just destructure a value into its\n-constituent parts and then build a new type out of them. e.g.\n-\n-```rust\n-struct Foo {\n-    x: u32,\n-    y: u16,\n-}\n-\n-struct Bar {\n-    a: u32,\n-    b: u16,\n-}\n-\n-fn reinterpret(foo: Foo) -> Bar {\n-    let Foo { x, y } = foo;\n-    Bar { a: x, b: y }\n-}\n-```\n-\n-But this is, at best, annoying. For common conversions, Rust provides\n-more ergonomic alternatives.\n-"}, {"sha": "bf202ada08e95a8208837a4f22194945d24e29f6", "filename": "src/doc/nomicon/src/data.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fdata.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,5 +0,0 @@\n-# Data Representation in Rust\n-\n-Low-level programming cares a lot about data layout. It's a big deal. It also\n-pervasively influences the rest of the language, so we're going to start by\n-digging into how data is represented in Rust."}, {"sha": "8c395fe3dc947ebbf0ec40405a8f77a1732a0156", "filename": "src/doc/nomicon/src/destructors.md", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fdestructors.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,190 +0,0 @@\n-# Destructors\n-\n-What the language *does* provide is full-blown automatic destructors through the\n-`Drop` trait, which provides the following method:\n-\n-```rust,ignore\n-fn drop(&mut self);\n-```\n-\n-This method gives the type time to somehow finish what it was doing.\n-\n-**After `drop` is run, Rust will recursively try to drop all of the fields\n-of `self`.**\n-\n-This is a convenience feature so that you don't have to write \"destructor\n-boilerplate\" to drop children. If a struct has no special logic for being\n-dropped other than dropping its children, then it means `Drop` doesn't need to\n-be implemented at all!\n-\n-**There is no stable way to prevent this behavior in Rust 1.0.**\n-\n-Note that taking `&mut self` means that even if you could suppress recursive\n-Drop, Rust will prevent you from e.g. moving fields out of self. For most types,\n-this is totally fine.\n-\n-For instance, a custom implementation of `Box` might write `Drop` like this:\n-\n-```rust\n-#![feature(alloc, heap_api, unique)]\n-\n-extern crate alloc;\n-\n-use std::ptr::{drop_in_place, Unique};\n-use std::mem;\n-\n-use alloc::heap;\n-\n-struct Box<T>{ ptr: Unique<T> }\n-\n-impl<T> Drop for Box<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            drop_in_place(*self.ptr);\n-            heap::deallocate((*self.ptr) as *mut u8,\n-                             mem::size_of::<T>(),\n-                             mem::align_of::<T>());\n-        }\n-    }\n-}\n-# fn main() {}\n-```\n-\n-and this works fine because when Rust goes to drop the `ptr` field it just sees\n-a [Unique] that has no actual `Drop` implementation. Similarly nothing can\n-use-after-free the `ptr` because when drop exits, it becomes inaccessible.\n-\n-However this wouldn't work:\n-\n-```rust\n-#![feature(alloc, heap_api, unique)]\n-\n-extern crate alloc;\n-\n-use std::ptr::{drop_in_place, Unique};\n-use std::mem;\n-\n-use alloc::heap;\n-\n-struct Box<T>{ ptr: Unique<T> }\n-\n-impl<T> Drop for Box<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            drop_in_place(*self.ptr);\n-            heap::deallocate((*self.ptr) as *mut u8,\n-                             mem::size_of::<T>(),\n-                             mem::align_of::<T>());\n-        }\n-    }\n-}\n-\n-struct SuperBox<T> { my_box: Box<T> }\n-\n-impl<T> Drop for SuperBox<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            // Hyper-optimized: deallocate the box's contents for it\n-            // without `drop`ing the contents\n-            heap::deallocate((*self.my_box.ptr) as *mut u8,\n-                             mem::size_of::<T>(),\n-                             mem::align_of::<T>());\n-        }\n-    }\n-}\n-# fn main() {}\n-```\n-\n-After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\n-happily proceed to tell the box to Drop itself and everything will blow up with\n-use-after-frees and double-frees.\n-\n-Note that the recursive drop behavior applies to all structs and enums\n-regardless of whether they implement Drop. Therefore something like\n-\n-```rust\n-struct Boxy<T> {\n-    data1: Box<T>,\n-    data2: Box<T>,\n-    info: u32,\n-}\n-```\n-\n-will have its data1 and data2's fields destructors whenever it \"would\" be\n-dropped, even though it itself doesn't implement Drop. We say that such a type\n-*needs Drop*, even though it is not itself Drop.\n-\n-Similarly,\n-\n-```rust\n-enum Link {\n-    Next(Box<Link>),\n-    None,\n-}\n-```\n-\n-will have its inner Box field dropped if and only if an instance stores the\n-Next variant.\n-\n-In general this works really nicely because you don't need to worry about\n-adding/removing drops when you refactor your data layout. Still there's\n-certainly many valid usecases for needing to do trickier things with\n-destructors.\n-\n-The classic safe solution to overriding recursive drop and allowing moving out\n-of Self during `drop` is to use an Option:\n-\n-```rust\n-#![feature(alloc, heap_api, unique)]\n-\n-extern crate alloc;\n-\n-use std::ptr::{drop_in_place, Unique};\n-use std::mem;\n-\n-use alloc::heap;\n-\n-struct Box<T>{ ptr: Unique<T> }\n-\n-impl<T> Drop for Box<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            drop_in_place(*self.ptr);\n-            heap::deallocate((*self.ptr) as *mut u8,\n-                             mem::size_of::<T>(),\n-                             mem::align_of::<T>());\n-        }\n-    }\n-}\n-\n-struct SuperBox<T> { my_box: Option<Box<T>> }\n-\n-impl<T> Drop for SuperBox<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            // Hyper-optimized: deallocate the box's contents for it\n-            // without `drop`ing the contents. Need to set the `box`\n-            // field as `None` to prevent Rust from trying to Drop it.\n-            let my_box = self.my_box.take().unwrap();\n-            heap::deallocate((*my_box.ptr) as *mut u8,\n-                             mem::size_of::<T>(),\n-                             mem::align_of::<T>());\n-            mem::forget(my_box);\n-        }\n-    }\n-}\n-# fn main() {}\n-```\n-\n-However this has fairly odd semantics: you're saying that a field that *should*\n-always be Some *may* be None, just because that happens in the destructor. Of\n-course this conversely makes a lot of sense: you can call arbitrary methods on\n-self during the destructor, and this should prevent you from ever doing so after\n-deinitializing the field. Not that it will prevent you from producing any other\n-arbitrarily invalid state in there.\n-\n-On balance this is an ok choice. Certainly what you should reach for by default.\n-However, in the future we expect there to be a first-class way to announce that\n-a field shouldn't be automatically dropped.\n-\n-[Unique]: phantom-data.html"}, {"sha": "a1fc33bdc1e33cf73d2d5081db5488fb39e00685", "filename": "src/doc/nomicon/src/dot-operator.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdot-operator.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdot-operator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fdot-operator.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,6 +0,0 @@\n-# The Dot Operator\n-\n-The dot operator will perform a lot of magic to convert types. It will perform\n-auto-referencing, auto-dereferencing, and coercion until types match.\n-\n-TODO: steal information from http://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082#28552082"}, {"sha": "e69264f281c9928fe8f27b9e6ebade5b95feb2a1", "filename": "src/doc/nomicon/src/drop-flags.md", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fdrop-flags.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,83 +0,0 @@\n-# Drop Flags\n-\n-The examples in the previous section introduce an interesting problem for Rust.\n-We have seen that it's possible to conditionally initialize, deinitialize, and\n-reinitialize locations of memory totally safely. For Copy types, this isn't\n-particularly notable since they're just a random pile of bits. However types\n-with destructors are a different story: Rust needs to know whether to call a\n-destructor whenever a variable is assigned to, or a variable goes out of scope.\n-How can it do this with conditional initialization?\n-\n-Note that this is not a problem that all assignments need worry about. In\n-particular, assigning through a dereference unconditionally drops, and assigning\n-in a `let` unconditionally doesn't drop:\n-\n-```\n-let mut x = Box::new(0); // let makes a fresh variable, so never need to drop\n-let y = &mut x;\n-*y = Box::new(1); // Deref assumes the referent is initialized, so always drops\n-```\n-\n-This is only a problem when overwriting a previously initialized variable or\n-one of its subfields.\n-\n-It turns out that Rust actually tracks whether a type should be dropped or not\n-*at runtime*. As a variable becomes initialized and uninitialized, a *drop flag*\n-for that variable is toggled. When a variable might need to be dropped, this\n-flag is evaluated to determine if it should be dropped.\n-\n-Of course, it is often the case that a value's initialization state can be\n-statically known at every point in the program. If this is the case, then the\n-compiler can theoretically generate more efficient code! For instance, straight-\n-line code has such *static drop semantics*:\n-\n-```rust\n-let mut x = Box::new(0); // x was uninit; just overwrite.\n-let mut y = x;           // y was uninit; just overwrite and make x uninit.\n-x = Box::new(0);         // x was uninit; just overwrite.\n-y = x;                   // y was init; Drop y, overwrite it, and make x uninit!\n-                         // y goes out of scope; y was init; Drop y!\n-                         // x goes out of scope; x was uninit; do nothing.\n-```\n-\n-Similarly, branched code where all branches have the same behavior with respect\n-to initialization has static drop semantics:\n-\n-```rust\n-# let condition = true;\n-let mut x = Box::new(0);    // x was uninit; just overwrite.\n-if condition {\n-    drop(x)                 // x gets moved out; make x uninit.\n-} else {\n-    println!(\"{}\", x);\n-    drop(x)                 // x gets moved out; make x uninit.\n-}\n-x = Box::new(0);            // x was uninit; just overwrite.\n-                            // x goes out of scope; x was init; Drop x!\n-```\n-\n-However code like this *requires* runtime information to correctly Drop:\n-\n-```rust\n-# let condition = true;\n-let x;\n-if condition {\n-    x = Box::new(0);        // x was uninit; just overwrite.\n-    println!(\"{}\", x);\n-}\n-                            // x goes out of scope; x might be uninit;\n-                            // check the flag!\n-```\n-\n-Of course, in this case it's trivial to retrieve static drop semantics:\n-\n-```rust\n-# let condition = true;\n-if condition {\n-    let x = Box::new(0);\n-    println!(\"{}\", x);\n-}\n-```\n-\n-The drop flags are tracked on the stack and no longer stashed in types that\n-implement drop."}, {"sha": "39039694be674cf1d014269a05cf2f57596754c7", "filename": "src/doc/nomicon/src/dropck.md", "status": "removed", "additions": 0, "deletions": 295, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fdropck.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,295 +0,0 @@\n-# Drop Check\n-\n-We have seen how lifetimes provide us some fairly simple rules for ensuring\n-that we never read dangling references. However up to this point we have only ever\n-interacted with the *outlives* relationship in an inclusive manner. That is,\n-when we talked about `'a: 'b`, it was ok for `'a` to live *exactly* as long as\n-`'b`. At first glance, this seems to be a meaningless distinction. Nothing ever\n-gets dropped at the same time as another, right? This is why we used the\n-following desugaring of `let` statements:\n-\n-```rust,ignore\n-let x;\n-let y;\n-```\n-\n-```rust,ignore\n-{\n-    let x;\n-    {\n-        let y;\n-    }\n-}\n-```\n-\n-Each creates its own scope, clearly establishing that one drops before the\n-other. However, what if we do the following?\n-\n-```rust,ignore\n-let (x, y) = (vec![], vec![]);\n-```\n-\n-Does either value strictly outlive the other? The answer is in fact *no*,\n-neither value strictly outlives the other. Of course, one of x or y will be\n-dropped before the other, but the actual order is not specified. Tuples aren't\n-special in this regard; composite structures just don't guarantee their\n-destruction order as of Rust 1.0.\n-\n-We *could* specify this for the fields of built-in composites like tuples and\n-structs. However, what about something like Vec? Vec has to manually drop its\n-elements via pure-library code. In general, anything that implements Drop has\n-a chance to fiddle with its innards during its final death knell. Therefore\n-the compiler can't sufficiently reason about the actual destruction order\n-of the contents of any type that implements Drop.\n-\n-So why do we care? We care because if the type system isn't careful, it could\n-accidentally make dangling pointers. Consider the following simple program:\n-\n-```rust\n-struct Inspector<'a>(&'a u8);\n-\n-fn main() {\n-    let (inspector, days);\n-    days = Box::new(1);\n-    inspector = Inspector(&days);\n-}\n-```\n-\n-This program is totally sound and compiles today. The fact that `days` does\n-not *strictly* outlive `inspector` doesn't matter. As long as the `inspector`\n-is alive, so is days.\n-\n-However if we add a destructor, the program will no longer compile!\n-\n-```rust,ignore\n-struct Inspector<'a>(&'a u8);\n-\n-impl<'a> Drop for Inspector<'a> {\n-    fn drop(&mut self) {\n-        println!(\"I was only {} days from retirement!\", self.0);\n-    }\n-}\n-\n-fn main() {\n-    let (inspector, days);\n-    days = Box::new(1);\n-    inspector = Inspector(&days);\n-    // Let's say `days` happens to get dropped first.\n-    // Then when Inspector is dropped, it will try to read free'd memory!\n-}\n-```\n-\n-```text\n-<anon>:12:28: 12:32 error: `days` does not live long enough\n-<anon>:12     inspector = Inspector(&days);\n-                                     ^~~~\n-<anon>:9:11: 15:2 note: reference must be valid for the block at 9:10...\n-<anon>:9 fn main() {\n-<anon>:10     let (inspector, days);\n-<anon>:11     days = Box::new(1);\n-<anon>:12     inspector = Inspector(&days);\n-<anon>:13     // Let's say `days` happens to get dropped first.\n-<anon>:14     // Then when Inspector is dropped, it will try to read free'd memory!\n-          ...\n-<anon>:10:27: 15:2 note: ...but borrowed value is only valid for the block suffix following statement 0 at 10:26\n-<anon>:10     let (inspector, days);\n-<anon>:11     days = Box::new(1);\n-<anon>:12     inspector = Inspector(&days);\n-<anon>:13     // Let's say `days` happens to get dropped first.\n-<anon>:14     // Then when Inspector is dropped, it will try to read free'd memory!\n-<anon>:15 }\n-```\n-\n-Implementing Drop lets the Inspector execute some arbitrary code during its\n-death. This means it can potentially observe that types that are supposed to\n-live as long as it does actually were destroyed first.\n-\n-Interestingly, only generic types need to worry about this. If they aren't\n-generic, then the only lifetimes they can harbor are `'static`, which will truly\n-live *forever*. This is why this problem is referred to as *sound generic drop*.\n-Sound generic drop is enforced by the *drop checker*. As of this writing, some\n-of the finer details of how the drop checker validates types is totally up in\n-the air. However The Big Rule is the subtlety that we have focused on this whole\n-section:\n-\n-**For a generic type to soundly implement drop, its generics arguments must\n-strictly outlive it.**\n-\n-Obeying this rule is (usually) necessary to satisfy the borrow\n-checker; obeying it is sufficient but not necessary to be\n-sound. That is, if your type obeys this rule then it's definitely\n-sound to drop.\n-\n-The reason that it is not always necessary to satisfy the above rule\n-is that some Drop implementations will not access borrowed data even\n-though their type gives them the capability for such access.\n-\n-For example, this variant of the above `Inspector` example will never\n-access borrowed data:\n-\n-```rust,ignore\n-struct Inspector<'a>(&'a u8, &'static str);\n-\n-impl<'a> Drop for Inspector<'a> {\n-    fn drop(&mut self) {\n-        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n-    }\n-}\n-\n-fn main() {\n-    let (inspector, days);\n-    days = Box::new(1);\n-    inspector = Inspector(&days, \"gadget\");\n-    // Let's say `days` happens to get dropped first.\n-    // Even when Inspector is dropped, its destructor will not access the\n-    // borrowed `days`.\n-}\n-```\n-\n-Likewise, this variant will also never access borrowed data:\n-\n-```rust,ignore\n-use std::fmt;\n-\n-struct Inspector<T: fmt::Display>(T, &'static str);\n-\n-impl<T: fmt::Display> Drop for Inspector<T> {\n-    fn drop(&mut self) {\n-        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n-    }\n-}\n-\n-fn main() {\n-    let (inspector, days): (Inspector<&u8>, Box<u8>);\n-    days = Box::new(1);\n-    inspector = Inspector(&days, \"gadget\");\n-    // Let's say `days` happens to get dropped first.\n-    // Even when Inspector is dropped, its destructor will not access the\n-    // borrowed `days`.\n-}\n-```\n-\n-However, *both* of the above variants are rejected by the borrow\n-checker during the analysis of `fn main`, saying that `days` does not\n-live long enough.\n-\n-The reason is that the borrow checking analysis of `main` does not\n-know about the internals of each Inspector's Drop implementation.  As\n-far as the borrow checker knows while it is analyzing `main`, the body\n-of an inspector's destructor might access that borrowed data.\n-\n-Therefore, the drop checker forces all borrowed data in a value to\n-strictly outlive that value.\n-\n-# An Escape Hatch\n-\n-The precise rules that govern drop checking may be less restrictive in\n-the future.\n-\n-The current analysis is deliberately conservative and trivial; it forces all\n-borrowed data in a value to outlive that value, which is certainly sound.\n-\n-Future versions of the language may make the analysis more precise, to\n-reduce the number of cases where sound code is rejected as unsafe.\n-This would help address cases such as the two Inspectors above that\n-know not to inspect during destruction.\n-\n-In the meantime, there is an unstable attribute that one can use to\n-assert (unsafely) that a generic type's destructor is *guaranteed* to\n-not access any expired data, even if its type gives it the capability\n-to do so.\n-\n-That attribute is called `may_dangle` and was introduced in [RFC 1327]\n-(https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md).\n-To deploy it on the Inspector example from above, we would write:\n-\n-```rust,ignore\n-struct Inspector<'a>(&'a u8, &'static str);\n-\n-unsafe impl<#[may_dangle] 'a> Drop for Inspector<'a> {\n-    fn drop(&mut self) {\n-        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n-    }\n-}\n-```\n-\n-Use of this attribute requires the `Drop` impl to be marked `unsafe` because the\n-compiler is not checking the implicit assertion that no potentially expired data\n-(e.g. `self.0` above) is accessed.\n-\n-The attribute can be applied to any number of lifetime and type parameters. In\n-the following example, we assert that we access no data behind a reference of\n-lifetime `'b` and that the only uses of `T` will be moves or drops, but omit\n-the attribute from `'a` and `U`, because we do access data with that lifetime\n-and that type:\n-\n-```rust,ignore\n-use std::fmt::Display;\n-\n-struct Inspector<'a, 'b, T, U: Display>(&'a u8, &'b u8, T, U);\n-\n-unsafe impl<'a, #[may_dangle] 'b, #[may_dangle] T, U: Display> Drop for Inspector<'a, 'b, T, U> {\n-    fn drop(&mut self) {\n-        println!(\"Inspector({}, _, _, {})\", self.0, self.3);\n-    }\n-}\n-```\n-\n-It is sometimes obvious that no such access can occur, like the case above.\n-However, when dealing with a generic type parameter, such access can\n-occur indirectly. Examples of such indirect access are:\n-\n- * invoking a callback,\n- * via a trait method call.\n-\n-(Future changes to the language, such as impl specialization, may add\n-other avenues for such indirect access.)\n-\n-Here is an example of invoking a callback:\n-\n-```rust,ignore\n-struct Inspector<T>(T, &'static str, Box<for <'r> fn(&'r T) -> String>);\n-\n-impl<T> Drop for Inspector<T> {\n-    fn drop(&mut self) {\n-        // The `self.2` call could access a borrow e.g. if `T` is `&'a _`.\n-        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n-                 (self.2)(&self.0), self.1);\n-    }\n-}\n-```\n-\n-Here is an example of a trait method call:\n-\n-```rust,ignore\n-use std::fmt;\n-\n-struct Inspector<T: fmt::Display>(T, &'static str);\n-\n-impl<T: fmt::Display> Drop for Inspector<T> {\n-    fn drop(&mut self) {\n-        // There is a hidden call to `<T as Display>::fmt` below, which\n-        // could access a borrow e.g. if `T` is `&'a _`\n-        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n-                 self.0, self.1);\n-    }\n-}\n-```\n-\n-And of course, all of these accesses could be further hidden within\n-some other method invoked by the destructor, rather than being written\n-directly within it.\n-\n-In all of the above cases where the `&'a u8` is accessed in the\n-destructor, adding the `#[may_dangle]`\n-attribute makes the type vulnerable to misuse that the borrower\n-checker will not catch, inviting havoc. It is better to avoid adding\n-the attribute.\n-\n-# Is that all about drop checker?\n-\n-It turns out that when writing unsafe code, we generally don't need to\n-worry at all about doing the right thing for the drop checker. However there\n-is one special case that you need to worry about, which we will look at in\n-the next section.\n-"}, {"sha": "a3cbc6abd69cc98023f139e408d15aab03007dc8", "filename": "src/doc/nomicon/src/exception-safety.md", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fexception-safety.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fexception-safety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fexception-safety.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,217 +0,0 @@\n-# Exception Safety\n-\n-Although programs should use unwinding sparingly, there's a lot of code that\n-*can* panic. If you unwrap a None, index out of bounds, or divide by 0, your\n-program will panic. On debug builds, every arithmetic operation can panic\n-if it overflows. Unless you are very careful and tightly control what code runs,\n-pretty much everything can unwind, and you need to be ready for it.\n-\n-Being ready for unwinding is often referred to as *exception safety*\n-in the broader programming world. In Rust, there are two levels of exception\n-safety that one may concern themselves with:\n-\n-* In unsafe code, we *must* be exception safe to the point of not violating\n-  memory safety. We'll call this *minimal* exception safety.\n-\n-* In safe code, it is *good* to be exception safe to the point of your program\n-  doing the right thing. We'll call this *maximal* exception safety.\n-\n-As is the case in many places in Rust, Unsafe code must be ready to deal with\n-bad Safe code when it comes to unwinding. Code that transiently creates\n-unsound states must be careful that a panic does not cause that state to be\n-used. Generally this means ensuring that only non-panicking code is run while\n-these states exist, or making a guard that cleans up the state in the case of\n-a panic. This does not necessarily mean that the state a panic witnesses is a\n-fully coherent state. We need only guarantee that it's a *safe* state.\n-\n-Most Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\n-It controls all the code that runs, and most of that code can't panic. However\n-it is not uncommon for Unsafe code to work with arrays of temporarily\n-uninitialized data while repeatedly invoking caller-provided code. Such code\n-needs to be careful and consider exception safety.\n-\n-\n-\n-\n-\n-## Vec::push_all\n-\n-`Vec::push_all` is a temporary hack to get extending a Vec by a slice reliably\n-efficient without specialization. Here's a simple implementation:\n-\n-```rust,ignore\n-impl<T: Clone> Vec<T> {\n-    fn push_all(&mut self, to_push: &[T]) {\n-        self.reserve(to_push.len());\n-        unsafe {\n-            // can't overflow because we just reserved this\n-            self.set_len(self.len() + to_push.len());\n-\n-            for (i, x) in to_push.iter().enumerate() {\n-                self.ptr().offset(i as isize).write(x.clone());\n-            }\n-        }\n-    }\n-}\n-```\n-\n-We bypass `push` in order to avoid redundant capacity and `len` checks on the\n-Vec that we definitely know has capacity. The logic is totally correct, except\n-there's a subtle problem with our code: it's not exception-safe! `set_len`,\n-`offset`, and `write` are all fine; `clone` is the panic bomb we over-looked.\n-\n-Clone is completely out of our control, and is totally free to panic. If it\n-does, our function will exit early with the length of the Vec set too large. If\n-the Vec is looked at or dropped, uninitialized memory will be read!\n-\n-The fix in this case is fairly simple. If we want to guarantee that the values\n-we *did* clone are dropped, we can set the `len` every loop iteration. If we\n-just want to guarantee that uninitialized memory can't be observed, we can set\n-the `len` after the loop.\n-\n-\n-\n-\n-\n-## BinaryHeap::sift_up\n-\n-Bubbling an element up a heap is a bit more complicated than extending a Vec.\n-The pseudocode is as follows:\n-\n-```text\n-bubble_up(heap, index):\n-    while index != 0 && heap[index] < heap[parent(index)]:\n-        heap.swap(index, parent(index))\n-        index = parent(index)\n-\n-```\n-\n-A literal transcription of this code to Rust is totally fine, but has an annoying\n-performance characteristic: the `self` element is swapped over and over again\n-uselessly. We would rather have the following:\n-\n-```text\n-bubble_up(heap, index):\n-    let elem = heap[index]\n-    while index != 0 && elem < heap[parent(index)]:\n-        heap[index] = heap[parent(index)]\n-        index = parent(index)\n-    heap[index] = elem\n-```\n-\n-This code ensures that each element is copied as little as possible (it is in\n-fact necessary that elem be copied twice in general). However it now exposes\n-some exception safety trouble! At all times, there exists two copies of one\n-value. If we panic in this function something will be double-dropped.\n-Unfortunately, we also don't have full control of the code: that comparison is\n-user-defined!\n-\n-Unlike Vec, the fix isn't as easy here. One option is to break the user-defined\n-code and the unsafe code into two separate phases:\n-\n-```text\n-bubble_up(heap, index):\n-    let end_index = index;\n-    while end_index != 0 && heap[end_index] < heap[parent(end_index)]:\n-        end_index = parent(end_index)\n-\n-    let elem = heap[index]\n-    while index != end_index:\n-        heap[index] = heap[parent(index)]\n-        index = parent(index)\n-    heap[index] = elem\n-```\n-\n-If the user-defined code blows up, that's no problem anymore, because we haven't\n-actually touched the state of the heap yet. Once we do start messing with the\n-heap, we're working with only data and functions that we trust, so there's no\n-concern of panics.\n-\n-Perhaps you're not happy with this design. Surely it's cheating! And we have\n-to do the complex heap traversal *twice*! Alright, let's bite the bullet. Let's\n-intermix untrusted and unsafe code *for reals*.\n-\n-If Rust had `try` and `finally` like in Java, we could do the following:\n-\n-```text\n-bubble_up(heap, index):\n-    let elem = heap[index]\n-    try:\n- \u00a0 \u00a0 \u00a0 \u00a0while index != 0 && elem < heap[parent(index)]:\n-            heap[index] = heap[parent(index)]\n-            index = parent(index)\n-    finally:\n-        heap[index] = elem\n-```\n-\n-The basic idea is simple: if the comparison panics, we just toss the loose\n-element in the logically uninitialized index and bail out. Anyone who observes\n-the heap will see a potentially *inconsistent* heap, but at least it won't\n-cause any double-drops! If the algorithm terminates normally, then this\n-operation happens to coincide precisely with the how we finish up regardless.\n-\n-Sadly, Rust has no such construct, so we're going to need to roll our own! The\n-way to do this is to store the algorithm's state in a separate struct with a\n-destructor for the \"finally\" logic. Whether we panic or not, that destructor\n-will run and clean up after us.\n-\n-```rust,ignore\n-struct Hole<'a, T: 'a> {\n-    data: &'a mut [T],\n-    /// `elt` is always `Some` from new until drop.\n-    elt: Option<T>,\n-    pos: usize,\n-}\n-\n-impl<'a, T> Hole<'a, T> {\n-    fn new(data: &'a mut [T], pos: usize) -> Self {\n-        unsafe {\n-            let elt = ptr::read(&data[pos]);\n-            Hole {\n-                data: data,\n-                elt: Some(elt),\n-                pos: pos,\n-            }\n-        }\n-    }\n-\n-    fn pos(&self) -> usize { self.pos }\n-\n-    fn removed(&self) -> &T { self.elt.as_ref().unwrap() }\n-\n-    unsafe fn get(&self, index: usize) -> &T { &self.data[index] }\n-\n-    unsafe fn move_to(&mut self, index: usize) {\n-        let index_ptr: *const _ = &self.data[index];\n-        let hole_ptr = &mut self.data[self.pos];\n-        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n-        self.pos = index;\n-    }\n-}\n-\n-impl<'a, T> Drop for Hole<'a, T> {\n-    fn drop(&mut self) {\n-        // fill the hole again\n-        unsafe {\n-            let pos = self.pos;\n-            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n-        }\n-    }\n-}\n-\n-impl<T: Ord> BinaryHeap<T> {\n-    fn sift_up(&mut self, pos: usize) {\n-        unsafe {\n-            // Take out the value at `pos` and create a hole.\n-            let mut hole = Hole::new(&mut self.data, pos);\n-\n-            while hole.pos() != 0 {\n-                let parent = parent(hole.pos());\n-                if hole.removed() <= hole.get(parent) { break }\n-                hole.move_to(parent);\n-            }\n-            // Hole will be unconditionally filled here; panic or not!\n-        }\n-    }\n-}\n-```"}, {"sha": "9f858d11dbbb901c97a81c6898657a0ff5093eaf", "filename": "src/doc/nomicon/src/exotic-sizes.md", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fexotic-sizes.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fexotic-sizes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fexotic-sizes.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,137 +0,0 @@\n-# Exotically Sized Types\n-\n-Most of the time, we think in terms of types with a fixed, positive size. This\n-is not always the case, however.\n-\n-\n-\n-\n-\n-# Dynamically Sized Types (DSTs)\n-\n-Rust in fact supports Dynamically Sized Types (DSTs): types without a statically\n-known size or alignment. On the surface, this is a bit nonsensical: Rust *must*\n-know the size and alignment of something in order to correctly work with it! In\n-this regard, DSTs are not normal types. Due to their lack of a statically known\n-size, these types can only exist behind some kind of pointer. Any pointer to a\n-DST consequently becomes a *fat* pointer consisting of the pointer and the\n-information that \"completes\" them (more on this below).\n-\n-There are two major DSTs exposed by the language: trait objects, and slices.\n-\n-A trait object represents some type that implements the traits it specifies.\n-The exact original type is *erased* in favor of runtime reflection\n-with a vtable containing all the information necessary to use the type.\n-This is the information that completes a trait object: a pointer to its vtable.\n-\n-A slice is simply a view into some contiguous storage -- typically an array or\n-`Vec`. The information that completes a slice is just the number of elements\n-it points to.\n-\n-Structs can actually store a single DST directly as their last field, but this\n-makes them a DST as well:\n-\n-```rust\n-// Can't be stored on the stack directly\n-struct Foo {\n-    info: u32,\n-    data: [u8],\n-}\n-```\n-\n-**NOTE: [As of Rust 1.0 struct DSTs are broken if the last field has\n-a variable position based on its alignment][dst-issue].**\n-\n-\n-\n-\n-\n-# Zero Sized Types (ZSTs)\n-\n-Rust actually allows types to be specified that occupy no space:\n-\n-```rust\n-struct Foo; // No fields = no size\n-\n-// All fields have no size = no size\n-struct Baz {\n-    foo: Foo,\n-    qux: (),      // empty tuple has no size\n-    baz: [u8; 0], // empty array has no size\n-}\n-```\n-\n-On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless.\n-However as with many curious layout choices in Rust, their potential is realized\n-in a generic context: Rust largely understands that any operation that  produces\n-or stores a ZST can be reduced to a no-op. First off, storing it  doesn't even\n-make sense -- it doesn't occupy any space. Also there's only one  value of that\n-type, so anything that loads it can just produce it from the  aether -- which is\n-also a no-op since it doesn't occupy any space.\n-\n-One of the most extreme example's of this is Sets and Maps. Given a\n-`Map<Key, Value>`, it is common to implement a `Set<Key>` as just a thin wrapper\n-around `Map<Key, UselessJunk>`. In many languages, this would necessitate\n-allocating space for UselessJunk and doing work to store and load UselessJunk\n-only to discard it. Proving this unnecessary would be a difficult analysis for\n-the compiler.\n-\n-However in Rust, we can just say that  `Set<Key> = Map<Key, ()>`. Now Rust\n-statically knows that every load and store is useless, and no allocation has any\n-size. The result is that the monomorphized code is basically a custom\n-implementation of a HashSet with none of the overhead that HashMap would have to\n-support values.\n-\n-Safe code need not worry about ZSTs, but *unsafe* code must be careful about the\n-consequence of types with no size. In particular, pointer offsets are no-ops,\n-and standard allocators (including jemalloc, the one used by default in Rust)\n-may return `nullptr` when a zero-sized allocation is requested, which is\n-indistinguishable from out of memory.\n-\n-\n-\n-\n-\n-# Empty Types\n-\n-Rust also enables types to be declared that *cannot even be instantiated*. These\n-types can only be talked about at the type level, and never at the value level.\n-Empty types can be declared by specifying an enum with no variants:\n-\n-```rust\n-enum Void {} // No variants = EMPTY\n-```\n-\n-Empty types are even more marginal than ZSTs. The primary motivating example for\n-Void types is type-level unreachability. For instance, suppose an API needs to\n-return a Result in general, but a specific case actually is infallible. It's\n-actually possible to communicate this at the type level by returning a\n-`Result<T, Void>`. Consumers of the API can confidently unwrap such a Result\n-knowing that it's *statically impossible* for this value to be an `Err`, as\n-this would require providing a value of type `Void`.\n-\n-In principle, Rust can do some interesting analyses and optimizations based\n-on this fact. For instance, `Result<T, Void>` could be represented as just `T`,\n-because the `Err` case doesn't actually exist. The following *could* also\n-compile:\n-\n-```rust,ignore\n-enum Void {}\n-\n-let res: Result<u32, Void> = Ok(0);\n-\n-// Err doesn't exist anymore, so Ok is actually irrefutable.\n-let Ok(num) = res;\n-```\n-\n-But neither of these tricks work today, so all Void types get you is\n-the ability to be confident that certain situations are statically impossible.\n-\n-One final subtle detail about empty types is that raw pointers to them are\n-actually valid to construct, but dereferencing them is Undefined Behavior\n-because that doesn't actually make sense. That is, you could model C's `void *`\n-type with `*const Void`, but this doesn't necessarily gain anything over using\n-e.g. `*const ()`, which *is* safe to randomly dereference.\n-\n-\n-[dst-issue]: https://github.com/rust-lang/rust/issues/26403"}, {"sha": "645986af13ace5aae29aa8bf5f1c7a1607a8dfa0", "filename": "src/doc/nomicon/src/hrtb.md", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fhrtb.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fhrtb.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fhrtb.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,73 +0,0 @@\n-# Higher-Rank Trait Bounds (HRTBs)\n-\n-Rust's `Fn` traits are a little bit magic. For instance, we can write the\n-following code:\n-\n-```rust\n-struct Closure<F> {\n-    data: (u8, u16),\n-    func: F,\n-}\n-\n-impl<F> Closure<F>\n-    where F: Fn(&(u8, u16)) -> &u8,\n-{\n-    fn call(&self) -> &u8 {\n-        (self.func)(&self.data)\n-    }\n-}\n-\n-fn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n-\n-fn main() {\n-    let clo = Closure { data: (0, 1), func: do_it };\n-    println!(\"{}\", clo.call());\n-}\n-```\n-\n-If we try to naively desugar this code in the same way that we did in the\n-lifetimes section, we run into some trouble:\n-\n-```rust,ignore\n-struct Closure<F> {\n-    data: (u8, u16),\n-    func: F,\n-}\n-\n-impl<F> Closure<F>\n-    // where F: Fn(&'??? (u8, u16)) -> &'??? u8,\n-{\n-    fn call<'a>(&'a self) -> &'a u8 {\n-        (self.func)(&self.data)\n-    }\n-}\n-\n-fn do_it<'b>(data: &'b (u8, u16)) -> &'b u8 { &'b data.0 }\n-\n-fn main() {\n-    'x: {\n-        let clo = Closure { data: (0, 1), func: do_it };\n-        println!(\"{}\", clo.call());\n-    }\n-}\n-```\n-\n-How on earth are we supposed to express the lifetimes on `F`'s trait bound? We\n-need to provide some lifetime there, but the lifetime we care about can't be\n-named until we enter the body of `call`! Also, that isn't some fixed lifetime;\n-`call` works with *any* lifetime `&self` happens to have at that point.\n-\n-This job requires The Magic of Higher-Rank Trait Bounds (HRTBs). The way we\n-desugar this is as follows:\n-\n-```rust,ignore\n-where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n-```\n-\n-(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`\n-trait)\n-\n-`for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n-*infinite list* of trait bounds that F must satisfy. Intense. There aren't many\n-places outside of the `Fn` traits where we encounter HRTBs, and even for\n-those we have a nice magic sugar for the common cases."}, {"sha": "38b70b85b576afe94b442bdffbe30e4bd1ceddf8", "filename": "src/doc/nomicon/src/leaking.md", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fleaking.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,251 +0,0 @@\n-# Leaking\n-\n-Ownership-based resource management is intended to simplify composition. You\n-acquire resources when you create the object, and you release the resources when\n-it gets destroyed. Since destruction is handled for you, it means you can't\n-forget to release the resources, and it happens as soon as possible! Surely this\n-is perfect and all of our problems are solved.\n-\n-Everything is terrible and we have new and exotic problems to try to solve.\n-\n-Many people like to believe that Rust eliminates resource leaks. In practice,\n-this is basically true. You would be surprised to see a Safe Rust program\n-leak resources in an uncontrolled way.\n-\n-However from a theoretical perspective this is absolutely not the case, no\n-matter how you look at it. In the strictest sense, \"leaking\" is so abstract as\n-to be unpreventable. It's quite trivial to initialize a collection at the start\n-of a program, fill it with tons of objects with destructors, and then enter an\n-infinite event loop that never refers to it. The collection will sit around\n-uselessly, holding on to its precious resources until the program terminates (at\n-which point all those resources would have been reclaimed by the OS anyway).\n-\n-We may consider a more restricted form of leak: failing to drop a value that is\n-unreachable. Rust also doesn't prevent this. In fact Rust *has a function for\n-doing this*: `mem::forget`. This function consumes the value it is passed *and\n-then doesn't run its destructor*.\n-\n-In the past `mem::forget` was marked as unsafe as a sort of lint against using\n-it, since failing to call a destructor is generally not a well-behaved thing to\n-do (though useful for some special unsafe code). However this was generally\n-determined to be an untenable stance to take: there are many ways to fail to\n-call a destructor in safe code. The most famous example is creating a cycle of\n-reference-counted pointers using interior mutability.\n-\n-It is reasonable for safe code to assume that destructor leaks do not happen, as\n-any program that leaks destructors is probably wrong. However *unsafe* code\n-cannot rely on destructors to be run in order to be safe. For most types this\n-doesn't matter: if you leak the destructor then the type is by definition\n-inaccessible, so it doesn't matter, right? For instance, if you leak a `Box<u8>`\n-then you waste some memory but that's hardly going to violate memory-safety.\n-\n-However where we must be careful with destructor leaks are *proxy* types. These\n-are types which manage access to a distinct object, but don't actually own it.\n-Proxy objects are quite rare. Proxy objects you'll need to care about are even\n-rarer. However we'll focus on three interesting examples in the standard\n-library:\n-\n-* `vec::Drain`\n-* `Rc`\n-* `thread::scoped::JoinGuard`\n-\n-\n-\n-## Drain\n-\n-`drain` is a collections API that moves data out of the container without\n-consuming the container. This enables us to reuse the allocation of a `Vec`\n-after claiming ownership over all of its contents. It produces an iterator\n-(Drain) that returns the contents of the Vec by-value.\n-\n-Now, consider Drain in the middle of iteration: some values have been moved out,\n-and others haven't. This means that part of the Vec is now full of logically\n-uninitialized data! We could backshift all the elements in the Vec every time we\n-remove a value, but this would have pretty catastrophic performance\n-consequences.\n-\n-Instead, we would like Drain to fix the Vec's backing storage when it is\n-dropped. It should run itself to completion, backshift any elements that weren't\n-removed (drain supports subranges), and then fix Vec's `len`. It's even\n-unwinding-safe! Easy!\n-\n-Now consider the following:\n-\n-```rust,ignore\n-let mut vec = vec![Box::new(0); 4];\n-\n-{\n-    // start draining, vec can no longer be accessed\n-    let mut drainer = vec.drain(..);\n-\n-    // pull out two elements and immediately drop them\n-    drainer.next();\n-    drainer.next();\n-\n-    // get rid of drainer, but don't call its destructor\n-    mem::forget(drainer);\n-}\n-\n-// Oops, vec[0] was dropped, we're reading a pointer into free'd memory!\n-println!(\"{}\", vec[0]);\n-```\n-\n-This is pretty clearly Not Good. Unfortunately, we're kind of stuck between a\n-rock and a hard place: maintaining consistent state at every step has an\n-enormous cost (and would negate any benefits of the API). Failing to maintain\n-consistent state gives us Undefined Behavior in safe code (making the API\n-unsound).\n-\n-So what can we do? Well, we can pick a trivially consistent state: set the Vec's\n-len to be 0 when we start the iteration, and fix it up if necessary in the\n-destructor. That way, if everything executes like normal we get the desired\n-behavior with minimal overhead. But if someone has the *audacity* to\n-mem::forget us in the middle of the iteration, all that does is *leak even more*\n-(and possibly leave the Vec in an unexpected but otherwise consistent state).\n-Since we've accepted that mem::forget is safe, this is definitely safe. We call\n-leaks causing more leaks a *leak amplification*.\n-\n-\n-\n-\n-## Rc\n-\n-Rc is an interesting case because at first glance it doesn't appear to be a\n-proxy value at all. After all, it manages the data it points to, and dropping\n-all the Rcs for a value will drop that value. Leaking an Rc doesn't seem like it\n-would be particularly dangerous. It will leave the refcount permanently\n-incremented and prevent the data from being freed or dropped, but that seems\n-just like Box, right?\n-\n-Nope.\n-\n-Let's consider a simplified implementation of Rc:\n-\n-```rust,ignore\n-struct Rc<T> {\n-    ptr: *mut RcBox<T>,\n-}\n-\n-struct RcBox<T> {\n-    data: T,\n-    ref_count: usize,\n-}\n-\n-impl<T> Rc<T> {\n-    fn new(data: T) -> Self {\n-        unsafe {\n-            // Wouldn't it be nice if heap::allocate worked like this?\n-            let ptr = heap::allocate::<RcBox<T>>();\n-            ptr::write(ptr, RcBox {\n-                data: data,\n-                ref_count: 1,\n-            });\n-            Rc { ptr: ptr }\n-        }\n-    }\n-\n-    fn clone(&self) -> Self {\n-        unsafe {\n-            (*self.ptr).ref_count += 1;\n-        }\n-        Rc { ptr: self.ptr }\n-    }\n-}\n-\n-impl<T> Drop for Rc<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            (*self.ptr).ref_count -= 1;\n-            if (*self.ptr).ref_count == 0 {\n-                // drop the data and then free it\n-                ptr::read(self.ptr);\n-                heap::deallocate(self.ptr);\n-            }\n-        }\n-    }\n-}\n-```\n-\n-This code contains an implicit and subtle assumption: `ref_count` can fit in a\n-`usize`, because there can't be more than `usize::MAX` Rcs in memory. However\n-this itself assumes that the `ref_count` accurately reflects the number of Rcs\n-in memory, which we know is false with `mem::forget`. Using `mem::forget` we can\n-overflow the `ref_count`, and then get it down to 0 with outstanding Rcs. Then\n-we can happily use-after-free the inner data. Bad Bad Not Good.\n-\n-This can be solved by just checking the `ref_count` and doing *something*. The\n-standard library's stance is to just abort, because your program has become\n-horribly degenerate. Also *oh my gosh* it's such a ridiculous corner case.\n-\n-\n-\n-\n-## thread::scoped::JoinGuard\n-\n-The thread::scoped API intends to allow threads to be spawned that reference\n-data on their parent's stack without any synchronization over that data by\n-ensuring the parent joins the thread before any of the shared data goes out\n-of scope.\n-\n-```rust,ignore\n-pub fn scoped<'a, F>(f: F) -> JoinGuard<'a>\n-    where F: FnOnce() + Send + 'a\n-```\n-\n-Here `f` is some closure for the other thread to execute. Saying that\n-`F: Send +'a` is saying that it closes over data that lives for `'a`, and it\n-either owns that data or the data was Sync (implying `&data` is Send).\n-\n-Because JoinGuard has a lifetime, it keeps all the data it closes over\n-borrowed in the parent thread. This means the JoinGuard can't outlive\n-the data that the other thread is working on. When the JoinGuard *does* get\n-dropped it blocks the parent thread, ensuring the child terminates before any\n-of the closed-over data goes out of scope in the parent.\n-\n-Usage looked like:\n-\n-```rust,ignore\n-let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-{\n-    let guards = vec![];\n-    for x in &mut data {\n-        // Move the mutable reference into the closure, and execute\n-        // it on a different thread. The closure has a lifetime bound\n-        // by the lifetime of the mutable reference `x` we store in it.\n-        // The guard that is returned is in turn assigned the lifetime\n-        // of the closure, so it also mutably borrows `data` as `x` did.\n-        // This means we cannot access `data` until the guard goes away.\n-        let guard = thread::scoped(move || {\n-            *x *= 2;\n-        });\n-        // store the thread's guard for later\n-        guards.push(guard);\n-    }\n-    // All guards are dropped here, forcing the threads to join\n-    // (this thread blocks here until the others terminate).\n-    // Once the threads join, the borrow expires and the data becomes\n-    // accessible again in this thread.\n-}\n-// data is definitely mutated here.\n-```\n-\n-In principle, this totally works! Rust's ownership system perfectly ensures it!\n-...except it relies on a destructor being called to be safe.\n-\n-```rust,ignore\n-let mut data = Box::new(0);\n-{\n-    let guard = thread::scoped(|| {\n-        // This is at best a data race. At worst, it's also a use-after-free.\n-        *data += 1;\n-    });\n-    // Because the guard is forgotten, expiring the loan without blocking this\n-    // thread.\n-    mem::forget(guard);\n-}\n-// So the Box is dropped here while the scoped thread may or may not be trying\n-// to access it.\n-```\n-\n-Dang. Here the destructor running was pretty fundamental to the API, and it had\n-to be scrapped in favor of a completely different design."}, {"sha": "e92d735a01d6921aba25e49c08d23afd800ca7af", "filename": "src/doc/nomicon/src/lifetime-elision.md", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-elision.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-elision.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-elision.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,64 +0,0 @@\n-# Lifetime Elision\n-\n-In order to make common patterns more ergonomic, Rust allows lifetimes to be\n-*elided* in function signatures.\n-\n-A *lifetime position* is anywhere you can write a lifetime in a type:\n-\n-```rust,ignore\n-&'a T\n-&'a mut T\n-T<'a>\n-```\n-\n-Lifetime positions can appear as either \"input\" or \"output\":\n-\n-* For `fn` definitions, input refers to the types of the formal arguments\n-  in the `fn` definition, while output refers to\n-  result types. So `fn foo(s: &str) -> (&str, &str)` has elided one lifetime in\n-  input position and two lifetimes in output position.\n-  Note that the input positions of a `fn` method definition do not\n-  include the lifetimes that occur in the method's `impl` header\n-  (nor lifetimes that occur in the trait header, for a default method).\n-\n-* In the future, it should be possible to elide `impl` headers in the same manner.\n-\n-Elision rules are as follows:\n-\n-* Each elided lifetime in input position becomes a distinct lifetime\n-  parameter.\n-\n-* If there is exactly one input lifetime position (elided or not), that lifetime\n-  is assigned to *all* elided output lifetimes.\n-\n-* If there are multiple input lifetime positions, but one of them is `&self` or\n-  `&mut self`, the lifetime of `self` is assigned to *all* elided output lifetimes.\n-\n-* Otherwise, it is an error to elide an output lifetime.\n-\n-Examples:\n-\n-```rust,ignore\n-fn print(s: &str);                                      // elided\n-fn print<'a>(s: &'a str);                               // expanded\n-\n-fn debug(lvl: uint, s: &str);                           // elided\n-fn debug<'a>(lvl: uint, s: &'a str);                    // expanded\n-\n-fn substr(s: &str, until: uint) -> &str;                // elided\n-fn substr<'a>(s: &'a str, until: uint) -> &'a str;      // expanded\n-\n-fn get_str() -> &str;                                   // ILLEGAL\n-\n-fn frob(s: &str, t: &str) -> &str;                      // ILLEGAL\n-\n-fn get_mut(&mut self) -> &mut T;                        // elided\n-fn get_mut<'a>(&'a mut self) -> &'a mut T;              // expanded\n-\n-fn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command                  // elided\n-fn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n-\n-fn new(buf: &mut [u8]) -> BufWriter;                    // elided\n-fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>          // expanded\n-\n-```"}, {"sha": "30b4f09f9032de94c3c10e39e3ef112448524a1a", "filename": "src/doc/nomicon/src/lifetime-mismatch.md", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-mismatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-mismatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-mismatch.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,81 +0,0 @@\n-# Limits of Lifetimes\n-\n-Given the following code:\n-\n-```rust,ignore\n-struct Foo;\n-\n-impl Foo {\n-    fn mutate_and_share(&mut self) -> &Self { &*self }\n-    fn share(&self) {}\n-}\n-\n-fn main() {\n-    let mut foo = Foo;\n-    let loan = foo.mutate_and_share();\n-    foo.share();\n-}\n-```\n-\n-One might expect it to compile. We call `mutate_and_share`, which mutably borrows\n-`foo` temporarily, but then returns only a shared reference. Therefore we\n-would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.\n-\n-However when we try to compile it:\n-\n-```text\n-<anon>:11:5: 11:8 error: cannot borrow `foo` as immutable because it is also borrowed as mutable\n-<anon>:11     foo.share();\n-              ^~~\n-<anon>:10:16: 10:19 note: previous borrow of `foo` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `foo` until the borrow ends\n-<anon>:10     let loan = foo.mutate_and_share();\n-                         ^~~\n-<anon>:12:2: 12:2 note: previous borrow ends here\n-<anon>:8 fn main() {\n-<anon>:9     let mut foo = Foo;\n-<anon>:10     let loan = foo.mutate_and_share();\n-<anon>:11     foo.share();\n-<anon>:12 }\n-          ^\n-```\n-\n-What happened? Well, we got the exact same reasoning as we did for\n-[Example 2 in the previous section][ex2]. We desugar the program and we get\n-the following:\n-\n-```rust,ignore\n-struct Foo;\n-\n-impl Foo {\n-    fn mutate_and_share<'a>(&'a mut self) -> &'a Self { &'a *self }\n-    fn share<'a>(&'a self) {}\n-}\n-\n-fn main() {\n-\t'b: {\n-    \tlet mut foo: Foo = Foo;\n-    \t'c: {\n-    \t\tlet loan: &'c Foo = Foo::mutate_and_share::<'c>(&'c mut foo);\n-    \t\t'd: {\n-    \t\t\tFoo::share::<'d>(&'d foo);\n-    \t\t}\n-    \t}\n-    }\n-}\n-```\n-\n-The lifetime system is forced to extend the `&mut foo` to have lifetime `'c`,\n-due to the lifetime of `loan` and mutate_and_share's signature. Then when we\n-try to call `share`, and it sees we're trying to alias that `&'c mut foo` and\n-blows up in our face!\n-\n-This program is clearly correct according to the reference semantics we actually\n-care about, but the lifetime system is too coarse-grained to handle that.\n-\n-\n-TODO: other common problems? SEME regions stuff, mostly?\n-\n-\n-\n-\n-[ex2]: lifetimes.html#example-aliasing-a-mutable-reference"}, {"sha": "e2f0cc86772308315519d9b3e3a04461595083f1", "filename": "src/doc/nomicon/src/lifetimes.md", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetimes.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,215 +0,0 @@\n-# Lifetimes\n-\n-Rust enforces these rules through *lifetimes*. Lifetimes are effectively\n-just names for scopes somewhere in the program. Each reference,\n-and anything that contains a reference, is tagged with a lifetime specifying\n-the scope it's valid for.\n-\n-Within a function body, Rust generally doesn't let you explicitly name the\n-lifetimes involved. This is because it's generally not really necessary\n-to talk about lifetimes in a local context; Rust has all the information and\n-can work out everything as optimally as possible. Many anonymous scopes and\n-temporaries that you would otherwise have to write are often introduced to\n-make your code Just Work.\n-\n-However once you cross the function boundary, you need to start talking about\n-lifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip\n-our toes with lifetimes, we're going to pretend that we're actually allowed\n-to label scopes with lifetimes, and desugar the examples from the start of\n-this chapter.\n-\n-Originally, our examples made use of *aggressive* sugar -- high fructose corn\n-syrup even -- around scopes and lifetimes, because writing everything out\n-explicitly is *extremely noisy*. All Rust code relies on aggressive inference\n-and elision of \"obvious\" things.\n-\n-One particularly interesting piece of sugar is that each `let` statement implicitly\n-introduces a scope. For the most part, this doesn't really matter. However it\n-does matter for variables that refer to each other. As a simple example, let's\n-completely desugar this simple piece of Rust code:\n-\n-```rust\n-let x = 0;\n-let y = &x;\n-let z = &y;\n-```\n-\n-The borrow checker always tries to minimize the extent of a lifetime, so it will\n-likely desugar to the following:\n-\n-```rust,ignore\n-// NOTE: `'a: {` and `&'b x` is not valid syntax!\n-'a: {\n-    let x: i32 = 0;\n-    'b: {\n-        // lifetime used is 'b because that's good enough.\n-        let y: &'b i32 = &'b x;\n-        'c: {\n-            // ditto on 'c\n-            let z: &'c &'b i32 = &'c y;\n-        }\n-    }\n-}\n-```\n-\n-Wow. That's... awful. Let's all take a moment to thank Rust for making this easier.\n-\n-Actually passing references to outer scopes will cause Rust to infer\n-a larger lifetime:\n-\n-```rust\n-let x = 0;\n-let z;\n-let y = &x;\n-z = y;\n-```\n-\n-```rust,ignore\n-'a: {\n-    let x: i32 = 0;\n-    'b: {\n-        let z: &'b i32;\n-        'c: {\n-            // Must use 'b here because this reference is\n-            // being passed to that scope.\n-            let y: &'b i32 = &'b x;\n-            z = y;\n-        }\n-    }\n-}\n-```\n-\n-\n-\n-# Example: references that outlive referents\n-\n-Alright, let's look at some of those examples from before:\n-\n-```rust,ignore\n-fn as_str(data: &u32) -> &str {\n-    let s = format!(\"{}\", data);\n-    &s\n-}\n-```\n-\n-desugars to:\n-\n-```rust,ignore\n-fn as_str<'a>(data: &'a u32) -> &'a str {\n-    'b: {\n-        let s = format!(\"{}\", data);\n-        return &'a s;\n-    }\n-}\n-```\n-\n-This signature of `as_str` takes a reference to a u32 with *some* lifetime, and\n-promises that it can produce a reference to a str that can live *just as long*.\n-Already we can see why this signature might be trouble. That basically implies\n-that we're going to find a str somewhere in the scope the reference\n-to the u32 originated in, or somewhere *even earlier*. That's a bit of a tall\n-order.\n-\n-We then proceed to compute the string `s`, and return a reference to it. Since\n-the contract of our function says the reference must outlive `'a`, that's the\n-lifetime we infer for the reference. Unfortunately, `s` was defined in the\n-scope `'b`, so the only way this is sound is if `'b` contains `'a` -- which is\n-clearly false since `'a` must contain the function call itself. We have therefore\n-created a reference whose lifetime outlives its referent, which is *literally*\n-the first thing we said that references can't do. The compiler rightfully blows\n-up in our face.\n-\n-To make this more clear, we can expand the example:\n-\n-```rust,ignore\n-fn as_str<'a>(data: &'a u32) -> &'a str {\n-    'b: {\n-        let s = format!(\"{}\", data);\n-        return &'a s\n-    }\n-}\n-\n-fn main() {\n-    'c: {\n-        let x: u32 = 0;\n-        'd: {\n-            // An anonymous scope is introduced because the borrow does not\n-            // need to last for the whole scope x is valid for. The return\n-            // of as_str must find a str somewhere before this function\n-            // call. Obviously not happening.\n-            println!(\"{}\", as_str::<'d>(&'d x));\n-        }\n-    }\n-}\n-```\n-\n-Shoot!\n-\n-Of course, the right way to write this function is as follows:\n-\n-```rust\n-fn to_string(data: &u32) -> String {\n-    format!(\"{}\", data)\n-}\n-```\n-\n-We must produce an owned value inside the function to return it! The only way\n-we could have returned an `&'a str` would have been if it was in a field of the\n-`&'a u32`, which is obviously not the case.\n-\n-(Actually we could have also just returned a string literal, which as a global\n-can be considered to reside at the bottom of the stack; though this limits\n-our implementation *just a bit*.)\n-\n-\n-\n-\n-\n-# Example: aliasing a mutable reference\n-\n-How about the other example:\n-\n-```rust,ignore\n-let mut data = vec![1, 2, 3];\n-let x = &data[0];\n-data.push(4);\n-println!(\"{}\", x);\n-```\n-\n-```rust,ignore\n-'a: {\n-    let mut data: Vec<i32> = vec![1, 2, 3];\n-    'b: {\n-        // 'b is as big as we need this borrow to be\n-        // (just need to get to `println!`)\n-        let x: &'b i32 = Index::index::<'b>(&'b data, 0);\n-        'c: {\n-            // Temporary scope because we don't need the\n-            // &mut to last any longer.\n-            Vec::push(&'c mut data, 4);\n-        }\n-        println!(\"{}\", x);\n-    }\n-}\n-```\n-\n-The problem here is a bit more subtle and interesting. We want Rust to\n-reject this program for the following reason: We have a live shared reference `x`\n-to a descendant of `data` when we try to take a mutable reference to `data`\n-to `push`. This would create an aliased mutable reference, which would\n-violate the *second* rule of references.\n-\n-However this is *not at all* how Rust reasons that this program is bad. Rust\n-doesn't understand that `x` is a reference to a subpath of `data`. It doesn't\n-understand Vec at all. What it *does* see is that `x` has to live for `'b` to\n-be printed. The signature of `Index::index` subsequently demands that the\n-reference we take to `data` has to survive for `'b`. When we try to call `push`,\n-it then sees us try to make an `&'c mut data`. Rust knows that `'c` is contained\n-within `'b`, and rejects our program because the `&'b data` must still be live!\n-\n-Here we see that the lifetime system is much more coarse than the reference\n-semantics we're actually interested in preserving. For the most part, *that's\n-totally ok*, because it keeps us from spending all day explaining our program\n-to the compiler. However it does mean that several programs that are totally\n-correct with respect to Rust's *true* semantics are rejected because lifetimes\n-are too dumb."}, {"sha": "d42d0b6d7255c3e1bbff94c6ef8b09855aa9c9ab", "filename": "src/doc/nomicon/src/meet-safe-and-unsafe.md", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fmeet-safe-and-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fmeet-safe-and-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fmeet-safe-and-unsafe.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,98 +0,0 @@\n-# Meet Safe and Unsafe\n-\n-Programmers in safe \"high-level\" languages face a fundamental dilemma. On one\n-hand, it would be *really* great to just say what you want and not worry about\n-how it's done. On the other hand, that can lead to unacceptably poor\n-performance. It may be necessary to drop down to less clear or idiomatic\n-practices to get the performance characteristics you want. Or maybe you just\n-throw up your hands in disgust and decide to shell out to an implementation in\n-a less sugary-wonderful *unsafe* language.\n-\n-Worse, when you want to talk directly to the operating system, you *have* to\n-talk to an unsafe language: *C*. C is ever-present and unavoidable. It's the\n-lingua-franca of the programming world.\n-Even other safe languages generally expose C interfaces for the world at large!\n-Regardless of why you're doing it, as soon as your program starts talking to\n-C it stops being safe.\n-\n-With that said, Rust is *totally* a safe programming language.\n-\n-Well, Rust *has* a safe programming language. Let's step back a bit.\n-\n-Rust can be thought of as being composed of two programming languages: *Safe\n-Rust* and *Unsafe Rust*. Safe Rust is For Reals  Totally Safe. Unsafe Rust,\n-unsurprisingly, is *not* For Reals Totally Safe.  In fact, Unsafe Rust lets you\n-do some really, *really* unsafe things.\n-\n-Safe Rust is the *true* Rust programming language. If all you do is write Safe\n-Rust, you will never have to worry about type-safety or memory-safety. You will\n-never endure a null or dangling pointer, or any of that Undefined Behavior\n-nonsense.\n-\n-*That's totally awesome.*\n-\n-The standard library also gives you enough utilities out-of-the-box that you'll\n-be able to write awesome high-performance applications and libraries in pure\n-idiomatic Safe Rust.\n-\n-But maybe you want to talk to another language. Maybe you're writing a\n-low-level abstraction not exposed by the standard library. Maybe you're\n-*writing* the standard library (which is written entirely in Rust). Maybe you\n-need to do something the type-system doesn't understand and just *frob some dang\n-bits*. Maybe you need Unsafe Rust.\n-\n-Unsafe Rust is exactly like Safe Rust with all the same rules and semantics.\n-However Unsafe Rust lets you do some *extra* things that are Definitely Not Safe.\n-\n-The only things that are different in Unsafe Rust are that you can:\n-\n-* Dereference raw pointers\n-* Call `unsafe` functions (including C functions, intrinsics, and the raw allocator)\n-* Implement `unsafe` traits\n-* Mutate statics\n-\n-That's it. The reason these operations are relegated to Unsafe is that misusing\n-any of these things will cause the ever dreaded Undefined Behavior. Invoking\n-Undefined Behavior gives the compiler full rights to do arbitrarily bad things\n-to your program. You definitely *should not* invoke Undefined Behavior.\n-\n-Unlike C, Undefined Behavior is pretty limited in scope in Rust. All the core\n-language cares about is preventing the following things:\n-\n-* Dereferencing null or dangling pointers\n-* Reading [uninitialized memory]\n-* Breaking the [pointer aliasing rules]\n-* Producing invalid primitive values:\n-    * dangling/null references\n-    * a `bool` that isn't 0 or 1\n-    * an undefined `enum` discriminant\n-    * a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n-    * A non-utf8 `str`\n-* Unwinding into another language\n-* Causing a [data race][race]\n-\n-That's it. That's all the causes of Undefined Behavior baked into Rust. Of\n-course, unsafe functions and traits are free to declare arbitrary other\n-constraints that a program must maintain to avoid Undefined Behavior. However,\n-generally violations of these constraints will just transitively lead to one of\n-the above problems. Some additional constraints may also derive from compiler\n-intrinsics that make special assumptions about how code can be optimized.\n-\n-Rust is otherwise quite permissive with respect to other dubious operations.\n-Rust considers it \"safe\" to:\n-\n-* Deadlock\n-* Have a [race condition][race]\n-* Leak memory\n-* Fail to call destructors\n-* Overflow integers\n-* Abort the program\n-* Delete the production database\n-\n-However any program that actually manages to do such a thing is *probably*\n-incorrect. Rust provides lots of tools to make these things rare, but\n-these problems are considered impractical to categorically prevent.\n-\n-[pointer aliasing rules]: references.html\n-[uninitialized memory]: uninitialized.html\n-[race]: races.html"}, {"sha": "19e5ec382595c212c09e5a3485ae8bac6c0505e1", "filename": "src/doc/nomicon/src/obrm.md", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fobrm.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fobrm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fobrm.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,14 +0,0 @@\n-# The Perils Of Ownership Based Resource Management (OBRM)\n-\n-OBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\n-interact with a lot in Rust. Especially if you use the standard library.\n-\n-Roughly speaking the pattern is as follows: to acquire a resource, you create an\n-object that manages it. To release the resource, you simply destroy the object,\n-and it cleans up the resource for you. The most common \"resource\" this pattern\n-manages is simply *memory*. `Box`, `Rc`, and basically everything in\n-`std::collections` is a convenience to enable correctly managing memory. This is\n-particularly important in Rust because we have no pervasive GC to rely on for\n-memory management. Which is the point, really: Rust is about control. However we\n-are not limited to just memory. Pretty much every other system resource like a\n-thread, file, or socket is exposed through this kind of API."}, {"sha": "02f39e3c4dd2794726e1ee2e1cd6aa9b17d738b1", "filename": "src/doc/nomicon/src/other-reprs.md", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fother-reprs.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fother-reprs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fother-reprs.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,79 +0,0 @@\n-# Alternative representations\n-\n-Rust allows you to specify alternative data layout strategies from the default.\n-\n-\n-\n-\n-# repr(C)\n-\n-This is the most important `repr`. It has fairly simple intent: do what C does.\n-The order, size, and alignment of fields is exactly what you would expect from C\n-or C++. Any type you expect to pass through an FFI boundary should have\n-`repr(C)`, as C is the lingua-franca of the programming world. This is also\n-necessary to soundly do more elaborate tricks with data layout such as\n-reinterpreting values as a different type.\n-\n-However, the interaction with Rust's more exotic data layout features must be\n-kept in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\",\n-`repr(C)` can be applied to types that will be nonsensical or problematic if\n-passed through the FFI boundary.\n-\n-* ZSTs are still zero-sized, even though this is not a standard behavior in\n-C, and is explicitly contrary to the behavior of an empty type in C++, which\n-still consumes a byte of space.\n-\n-* DSTs, tuples, and tagged unions are not a concept in C and as such are never\n-FFI safe.\n-\n-* Tuple structs are like structs with regards to `repr(C)`, as the only\n-  difference from a struct is that the fields aren\u2019t named.\n-\n-* **If the type would have any [drop flags], they will still be added**\n-\n-* This is equivalent to one of `repr(u*)` (see the next section) for enums. The\n-chosen size is the default enum size for the target platform's C ABI. Note that\n-enum representation in C is implementation defined, so this is really a \"best\n-guess\". In particular, this may be incorrect when the C code of interest is\n-compiled with certain flags.\n-\n-\n-\n-# repr(u8), repr(u16), repr(u32), repr(u64)\n-\n-These specify the size to make a C-like enum. If the discriminant overflows the\n-integer it has to fit in, it will produce a compile-time error. You can manually\n-ask Rust to allow this by setting the overflowing element to explicitly be 0.\n-However Rust will not allow you to create an enum where two variants have the\n-same discriminant.\n-\n-On non-C-like enums, this will inhibit certain optimizations like the null-\n-pointer optimization.\n-\n-These reprs have no effect on a struct.\n-\n-\n-\n-\n-# repr(packed)\n-\n-`repr(packed)` forces Rust to strip any padding, and only align the type to a\n-byte. This may improve the memory footprint, but will likely have other negative\n-side-effects.\n-\n-In particular, most architectures *strongly* prefer values to be aligned. This\n-may mean the unaligned loads are penalized (x86), or even fault (some ARM\n-chips). For simple cases like directly loading or storing a packed field, the\n-compiler might be able to paper over alignment issues with shifts and masks.\n-However if you take a reference to a packed field, it's unlikely that the\n-compiler will be able to emit code to avoid an unaligned load.\n-\n-**[As of Rust 1.0 this can cause undefined behavior.][ub loads]**\n-\n-`repr(packed)` is not to be used lightly. Unless you have extreme requirements,\n-this should not be used.\n-\n-This repr is a modifier on `repr(C)` and `repr(rust)`.\n-\n-[drop flags]: drop-flags.html\n-[ub loads]: https://github.com/rust-lang/rust/issues/27060"}, {"sha": "dd9e9db244a8161a2c8b59555cad56c1efe944b0", "filename": "src/doc/nomicon/src/ownership.md", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fownership.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,66 +0,0 @@\n-# Ownership and Lifetimes\n-\n-Ownership is the breakout feature of Rust. It allows Rust to be completely\n-memory-safe and efficient, while avoiding garbage collection. Before getting\n-into the ownership system in detail, we will consider the motivation of this\n-design.\n-\n-We will assume that you accept that garbage collection (GC) is not always an\n-optimal solution, and that it is desirable to manually manage memory in some\n-contexts. If you do not accept this, might I interest you in a different\n-language?\n-\n-Regardless of your feelings on GC, it is pretty clearly a *massive* boon to\n-making code safe. You never have to worry about things going away *too soon*\n-(although whether you still wanted to be pointing at that thing is a different\n-issue...). This is a pervasive problem that C and C++ programs need to deal\n-with. Consider this simple mistake that all of us who have used a non-GC'd\n-language have made at one point:\n-\n-```rust,ignore\n-fn as_str(data: &u32) -> &str {\n-    // compute the string\n-    let s = format!(\"{}\", data);\n-\n-    // OH NO! We returned a reference to something that\n-    // exists only in this function!\n-    // Dangling pointer! Use after free! Alas!\n-    // (this does not compile in Rust)\n-    &s\n-}\n-```\n-\n-This is exactly what Rust's ownership system was built to solve.\n-Rust knows the scope in which the `&s` lives, and as such can prevent it from\n-escaping. However this is a simple case that even a C compiler could plausibly\n-catch. Things get more complicated as code gets bigger and pointers get fed through\n-various functions. Eventually, a C compiler will fall down and won't be able to\n-perform sufficient escape analysis to prove your code unsound. It will consequently\n-be forced to accept your program on the assumption that it is correct.\n-\n-This will never happen to Rust. It's up to the programmer to prove to the\n-compiler that everything is sound.\n-\n-Of course, Rust's story around ownership is much more complicated than just\n-verifying that references don't escape the scope of their referent. That's\n-because ensuring pointers are always valid is much more complicated than this.\n-For instance in this code,\n-\n-```rust,ignore\n-let mut data = vec![1, 2, 3];\n-// get an internal reference\n-let x = &data[0];\n-\n-// OH NO! `push` causes the backing storage of `data` to be reallocated.\n-// Dangling pointer! Use after free! Alas!\n-// (this does not compile in Rust)\n-data.push(4);\n-\n-println!(\"{}\", x);\n-```\n-\n-naive scope analysis would be insufficient to prevent this bug, because `data`\n-does in fact live as long as we needed. However it was *changed* while we had\n-a reference into it. This is why Rust requires any references to freeze the\n-referent and its owners.\n-"}, {"sha": "32539c2d01f6dcd9e9488cfae80f02f0be929db6", "filename": "src/doc/nomicon/src/phantom-data.md", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fphantom-data.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,104 +0,0 @@\n-# PhantomData\n-\n-When working with unsafe code, we can often end up in a situation where\n-types or lifetimes are logically associated with a struct, but not actually\n-part of a field. This most commonly occurs with lifetimes. For instance, the\n-`Iter` for `&'a [T]` is (approximately) defined as follows:\n-\n-```rust,ignore\n-struct Iter<'a, T: 'a> {\n-    ptr: *const T,\n-    end: *const T,\n-}\n-```\n-\n-However because `'a` is unused within the struct's body, it's *unbounded*.\n-Because of the troubles this has historically caused, unbounded lifetimes and\n-types are *forbidden* in struct definitions. Therefore we must somehow refer\n-to these types in the body. Correctly doing this is necessary to have\n-correct variance and drop checking.\n-\n-We do this using `PhantomData`, which is a special marker type. `PhantomData`\n-consumes no space, but simulates a field of the given type for the purpose of\n-static analysis. This was deemed to be less error-prone than explicitly telling\n-the type-system the kind of variance that you want, while also providing other\n-useful such as the information needed by drop check.\n-\n-Iter logically contains a bunch of `&'a T`s, so this is exactly what we tell\n-the PhantomData to simulate:\n-\n-```\n-use std::marker;\n-\n-struct Iter<'a, T: 'a> {\n-    ptr: *const T,\n-    end: *const T,\n-    _marker: marker::PhantomData<&'a T>,\n-}\n-```\n-\n-and that's it. The lifetime will be bounded, and your iterator will be variant\n-over `'a` and `T`. Everything Just Works.\n-\n-Another important example is Vec, which is (approximately) defined as follows:\n-\n-```\n-struct Vec<T> {\n-    data: *const T, // *const for variance!\n-    len: usize,\n-    cap: usize,\n-}\n-```\n-\n-Unlike the previous example, it *appears* that everything is exactly as we\n-want. Every generic argument to Vec shows up in at least one field.\n-Good to go!\n-\n-Nope.\n-\n-The drop checker will generously determine that `Vec<T>` does not own any values\n-of type T. This will in turn make it conclude that it doesn't need to worry\n-about Vec dropping any T's in its destructor for determining drop check\n-soundness. This will in turn allow people to create unsoundness using\n-Vec's destructor.\n-\n-In order to tell dropck that we *do* own values of type T, and therefore may\n-drop some T's when *we* drop, we must add an extra PhantomData saying exactly\n-that:\n-\n-```\n-use std::marker;\n-\n-struct Vec<T> {\n-    data: *const T, // *const for covariance!\n-    len: usize,\n-    cap: usize,\n-    _marker: marker::PhantomData<T>,\n-}\n-```\n-\n-Raw pointers that own an allocation is such a pervasive pattern that the\n-standard library made a utility for itself called `Unique<T>` which:\n-\n-* wraps a `*const T` for variance\n-* includes a `PhantomData<T>`\n-* auto-derives `Send`/`Sync` as if T was contained\n-* marks the pointer as `NonZero` for the null-pointer optimization\n-\n-## Table of `PhantomData` patterns\n-\n-Here\u2019s a table of all the wonderful ways `PhantomData` could be used:\n-\n-| Phantom type                | `'a`      | `T`                       |\n-|-----------------------------|-----------|---------------------------|\n-| `PhantomData<T>`            | -         | variant (with drop check) |\n-| `PhantomData<&'a T>`        | variant   | variant                   |\n-| `PhantomData<&'a mut T>`    | variant   | invariant                 |\n-| `PhantomData<*const T>`     | -         | variant                   |\n-| `PhantomData<*mut T>`       | -         | invariant                 |\n-| `PhantomData<fn(T)>`        | -         | contravariant (*)         |\n-| `PhantomData<fn() -> T>`    | -         | variant                   |\n-| `PhantomData<fn(T) -> T>`   | -         | invariant                 |\n-| `PhantomData<Cell<&'a ()>>` | invariant | -                         |\n-\n-(*) If contravariance gets scrapped, this would be invariant."}, {"sha": "9b5dec3eec3843315458f8d0365d9face8c92ca6", "filename": "src/doc/nomicon/src/poisoning.md", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fpoisoning.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fpoisoning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fpoisoning.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,35 +0,0 @@\n-# Poisoning\n-\n-Although all unsafe code *must* ensure it has minimal exception safety, not all\n-types ensure *maximal* exception safety. Even if the type does, your code may\n-ascribe additional meaning to it. For instance, an integer is certainly\n-exception-safe, but has no semantics on its own. It's possible that code that\n-panics could fail to correctly update the integer, producing an inconsistent\n-program state.\n-\n-This is *usually* fine, because anything that witnesses an exception is about\n-to get destroyed. For instance, if you send a Vec to another thread and that\n-thread panics, it doesn't matter if the Vec is in a weird state. It will be\n-dropped and go away forever. However some types are especially good at smuggling\n-values across the panic boundary.\n-\n-These types may choose to explicitly *poison* themselves if they witness a panic.\n-Poisoning doesn't entail anything in particular. Generally it just means\n-preventing normal usage from proceeding. The most notable example of this is the\n-standard library's Mutex type. A Mutex will poison itself if one of its\n-MutexGuards (the thing it returns when a lock is obtained) is dropped during a\n-panic. Any future attempts to lock the Mutex will return an `Err` or panic.\n-\n-Mutex poisons not for true safety in the sense that Rust normally cares about. It\n-poisons as a safety-guard against blindly using the data that comes out of a Mutex\n-that has witnessed a panic while locked. The data in such a Mutex was likely in the\n-middle of being modified, and as such may be in an inconsistent or incomplete state.\n-It is important to note that one cannot violate memory safety with such a type\n-if it is correctly written. After all, it must be minimally exception-safe!\n-\n-However if the Mutex contained, say, a BinaryHeap that does not actually have the\n-heap property, it's unlikely that any code that uses it will do\n-what the author intended. As such, the program should not proceed normally.\n-Still, if you're double-plus-sure that you can do *something* with the value,\n-the Mutex exposes a method to get the lock anyway. It *is* safe, after all.\n-Just maybe nonsense."}, {"sha": "c9b8c3d01b2f856a8ec678a6c8603694bbd0ee4d", "filename": "src/doc/nomicon/src/races.md", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fraces.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fraces.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fraces.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,86 +0,0 @@\n-# Data Races and Race Conditions\n-\n-Safe Rust guarantees an absence of data races, which are defined as:\n-\n-* two or more threads concurrently accessing a location of memory\n-* one of them is a write\n-* one of them is unsynchronized\n-\n-A data race has Undefined Behavior, and is therefore impossible to perform\n-in Safe Rust. Data races are *mostly* prevented through rust's ownership system:\n-it's impossible to alias a mutable reference, so it's impossible to perform a\n-data race. Interior mutability makes this more complicated, which is largely why\n-we have the Send and Sync traits (see below).\n-\n-**However Rust does not prevent general race conditions.**\n-\n-This is pretty fundamentally impossible, and probably honestly undesirable. Your\n-hardware is racy, your OS is racy, the other programs on your computer are racy,\n-and the world this all runs in is racy. Any system that could genuinely claim to\n-prevent *all* race conditions would be pretty awful to use, if not just\n-incorrect.\n-\n-So it's perfectly \"fine\" for a Safe Rust program to get deadlocked or do\n-something nonsensical with incorrect synchronization. Obviously such a program\n-isn't very good, but Rust can only hold your hand so far. Still, a race\n-condition can't violate memory safety in a Rust program on its own. Only in\n-conjunction with some other unsafe code can a race condition actually violate\n-memory safety. For instance:\n-\n-```rust,no_run\n-use std::thread;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-use std::sync::Arc;\n-\n-let data = vec![1, 2, 3, 4];\n-// Arc so that the memory the AtomicUsize is stored in still exists for\n-// the other thread to increment, even if we completely finish executing\n-// before it. Rust won't compile the program without it, because of the\n-// lifetime requirements of thread::spawn!\n-let idx = Arc::new(AtomicUsize::new(0));\n-let other_idx = idx.clone();\n-\n-// `move` captures other_idx by-value, moving it into this thread\n-thread::spawn(move || {\n-    // It's ok to mutate idx because this value\n-    // is an atomic, so it can't cause a Data Race.\n-    other_idx.fetch_add(10, Ordering::SeqCst);\n-});\n-\n-// Index with the value loaded from the atomic. This is safe because we\n-// read the atomic memory only once, and then pass a copy of that value\n-// to the Vec's indexing implementation. This indexing will be correctly\n-// bounds checked, and there's no chance of the value getting changed\n-// in the middle. However our program may panic if the thread we spawned\n-// managed to increment before this ran. A race condition because correct\n-// program execution (panicking is rarely correct) depends on order of\n-// thread execution.\n-println!(\"{}\", data[idx.load(Ordering::SeqCst)]);\n-```\n-\n-```rust,no_run\n-use std::thread;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-use std::sync::Arc;\n-\n-let data = vec![1, 2, 3, 4];\n-\n-let idx = Arc::new(AtomicUsize::new(0));\n-let other_idx = idx.clone();\n-\n-// `move` captures other_idx by-value, moving it into this thread\n-thread::spawn(move || {\n-    // It's ok to mutate idx because this value\n-    // is an atomic, so it can't cause a Data Race.\n-    other_idx.fetch_add(10, Ordering::SeqCst);\n-});\n-\n-if idx.load(Ordering::SeqCst) < data.len() {\n-    unsafe {\n-        // Incorrectly loading the idx after we did the bounds check.\n-        // It could have changed. This is a race condition, *and dangerous*\n-        // because we decided to do `get_unchecked`, which is `unsafe`.\n-        println!(\"{}\", data.get_unchecked(idx.load(Ordering::SeqCst)));\n-    }\n-}\n-```"}, {"sha": "5d80f1edd964a7ee4249cad38be8ef67c6d1a4bd", "filename": "src/doc/nomicon/src/references.md", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Freferences.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Freferences.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Freferences.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,177 +0,0 @@\n-# References\n-\n-This section gives a high-level view of the memory model that *all* Rust\n-programs must satisfy to be correct. Safe code is statically verified\n-to obey this model by the borrow checker. Unsafe code may go above\n-and beyond the borrow checker while still satisfying this model. The borrow\n-checker may also be extended to allow more programs to compile, as long as\n-this more fundamental model is satisfied.\n-\n-There are two kinds of reference:\n-\n-* Shared reference: `&`\n-* Mutable reference: `&mut`\n-\n-Which obey the following rules:\n-\n-* A reference cannot outlive its referent\n-* A mutable reference cannot be aliased\n-\n-That's it. That's the whole model. Of course, we should probably define\n-what *aliased* means. To define aliasing, we must define the notion of\n-*paths* and *liveness*.\n-\n-\n-**NOTE: The model that follows is generally agreed to be dubious and have\n-issues. It's ok-ish as an intuitive model, but fails to capture the desired\n-semantics. We leave this here to be able to use notions introduced here in later\n-sections. This will be significantly changed in the future. TODO: do that.**\n-\n-\n-# Paths\n-\n-If all Rust had were values (no pointers), then every value would be uniquely\n-owned by a variable or composite structure. From this we naturally derive a\n-*tree* of ownership. The stack itself is the root of the tree, with every\n-variable as its direct children. Each variable's direct children would be their\n-fields (if any), and so on.\n-\n-From this view, every value in Rust has a unique *path* in the tree of\n-ownership. Of particular interest are *ancestors* and *descendants*: if `x` owns\n-`y`, then `x` is an ancestor of `y`, and `y` is a descendant of `x`. Note\n-that this is an inclusive relationship: `x` is a descendant and ancestor of\n-itself.\n-\n-We can then define references as simply *names* for paths. When you create a\n-reference, you're declaring that an ownership path exists to this address\n-of memory.\n-\n-Tragically, plenty of data doesn't reside on the stack, and we must also\n-accommodate this. Globals and thread-locals are simple enough to model as\n-residing at the bottom of the stack (though we must be careful with mutable\n-globals). Data on the heap poses a different problem.\n-\n-If all Rust had on the heap was data uniquely owned by a pointer on the stack,\n-then we could just treat such a pointer as a struct that owns the value on the\n-heap. Box, Vec, String, and HashMap, are examples of types which uniquely\n-own data on the heap.\n-\n-Unfortunately, data on the heap is not *always* uniquely owned. Rc for instance\n-introduces a notion of *shared* ownership. Shared ownership of a value means\n-there is no unique path to it. A value with no unique path limits what we can do\n-with it.\n-\n-In general, only shared references can be created to non-unique paths. However\n-mechanisms which ensure mutual exclusion may establish One True Owner\n-temporarily, establishing a unique path to that value (and therefore all\n-its children). If this is done, the value may be mutated. In particular, a\n-mutable reference can be taken.\n-\n-The most common way to establish such a path is through *interior mutability*,\n-in contrast to the *inherited mutability* that everything in Rust normally uses.\n-Cell, RefCell, Mutex, and RWLock are all examples of interior mutability types.\n-These types provide exclusive access through runtime restrictions.\n-\n-An interesting case of this effect is Rc itself: if an Rc has refcount 1,\n-then it is safe to mutate or even move its internals. Note however that the\n-refcount itself uses interior mutability.\n-\n-In order to correctly communicate to the type system that a variable or field of\n-a struct can have interior mutability, it must be wrapped in an UnsafeCell. This\n-does not in itself make it safe to perform interior mutability operations on\n-that value. You still must yourself ensure that mutual exclusion is upheld.\n-\n-\n-\n-\n-# Liveness\n-\n-Note: Liveness is not the same thing as a *lifetime*, which will be explained\n-in detail in the next section of this chapter.\n-\n-Roughly, a reference is *live* at some point in a program if it can be\n-dereferenced. Shared references are always live unless they are literally\n-unreachable (for instance, they reside in freed or leaked memory). Mutable\n-references can be reachable but *not* live through the process of *reborrowing*.\n-\n-A mutable reference can be reborrowed to either a shared or mutable reference to\n-one of its descendants. A reborrowed reference will only be live again once all\n-reborrows derived from it expire. For instance, a mutable reference can be\n-reborrowed to point to a field of its referent:\n-\n-```rust\n-let x = &mut (1, 2);\n-{\n-    // reborrow x to a subfield\n-    let y = &mut x.0;\n-    // y is now live, but x isn't\n-    *y = 3;\n-}\n-// y goes out of scope, so x is live again\n-*x = (5, 7);\n-```\n-\n-It is also possible to reborrow into *multiple* mutable references, as long as\n-they are *disjoint*: no reference is an ancestor of another. Rust\n-explicitly enables this to be done with disjoint struct fields, because\n-disjointness can be statically proven:\n-\n-```rust\n-let x = &mut (1, 2);\n-{\n-    // reborrow x to two disjoint subfields\n-    let y = &mut x.0;\n-    let z = &mut x.1;\n-\n-    // y and z are now live, but x isn't\n-    *y = 3;\n-    *z = 4;\n-}\n-// y and z go out of scope, so x is live again\n-*x = (5, 7);\n-```\n-\n-However it's often the case that Rust isn't sufficiently smart to prove that\n-multiple borrows are disjoint. *This does not mean it is fundamentally illegal\n-to make such a borrow*, just that Rust isn't as smart as you want.\n-\n-To simplify things, we can model variables as a fake type of reference: *owned*\n-references. Owned references have much the same semantics as mutable references:\n-they can be re-borrowed in a mutable or shared manner, which makes them no\n-longer live. Live owned references have the unique property that they can be\n-moved out of (though mutable references *can* be swapped out of). This power is\n-only given to *live* owned references because moving its referent would of\n-course invalidate all outstanding references prematurely.\n-\n-As a local lint against inappropriate mutation, only variables that are marked\n-as `mut` can be borrowed mutably.\n-\n-It is interesting to note that Box behaves exactly like an owned reference. It\n-can be moved out of, and Rust understands it sufficiently to reason about its\n-paths like a normal variable.\n-\n-\n-\n-\n-# Aliasing\n-\n-With liveness and paths defined, we can now properly define *aliasing*:\n-\n-**A mutable reference is aliased if there exists another live reference to one\n-of its ancestors or descendants.**\n-\n-(If you prefer, you may also say the two live references alias *each other*.\n-This has no semantic consequences, but is probably a more useful notion when\n-verifying the soundness of a construct.)\n-\n-That's it. Super simple right? Except for the fact that it took us two pages to\n-define all of the terms in that definition. You know: Super. Simple.\n-\n-Actually it's a bit more complicated than that. In addition to references, Rust\n-has *raw pointers*: `*const T` and `*mut T`. Raw pointers have no inherent\n-ownership or aliasing semantics. As a result, Rust makes absolutely no effort to\n-track that they are used correctly, and they are wildly unsafe.\n-\n-**It is an open question to what degree raw pointers have alias semantics.\n-However it is important for these definitions to be sound that the existence of\n-a raw pointer does not imply some kind of live path.**"}, {"sha": "c02cf44189f1a704354712dbed60f2b31f73fa47", "filename": "src/doc/nomicon/src/repr-rust.md", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Frepr-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Frepr-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Frepr-rust.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,154 +0,0 @@\n-# repr(Rust)\n-\n-First and foremost, all types have an alignment specified in bytes. The\n-alignment of a type specifies what addresses are valid to store the value at. A\n-value of alignment `n` must only be stored at an address that is a multiple of\n-`n`. So alignment 2 means you must be stored at an even address, and 1 means\n-that you can be stored anywhere. Alignment is at least 1, and always a power of\n-2. Most primitives are generally aligned to their size, although this is\n-platform-specific behavior. In particular, on x86 `u64` and `f64` may be only\n-aligned to 32 bits.\n-\n-A type's size must always be a multiple of its alignment. This ensures that an\n-array of that type may always be indexed by offsetting by a multiple of its\n-size. Note that the size and alignment of a type may not be known\n-statically in the case of [dynamically sized types][dst].\n-\n-Rust gives you the following ways to lay out composite data:\n-\n-* structs (named product types)\n-* tuples (anonymous product types)\n-* arrays (homogeneous product types)\n-* enums (named sum types -- tagged unions)\n-\n-An enum is said to be *C-like* if none of its variants have associated data.\n-\n-Composite structures will have an alignment equal to the maximum\n-of their fields' alignment. Rust will consequently insert padding where\n-necessary to ensure that all fields are properly aligned and that the overall\n-type's size is a multiple of its alignment. For instance:\n-\n-```rust\n-struct A {\n-    a: u8,\n-    b: u32,\n-    c: u16,\n-}\n-```\n-\n-will be 32-bit aligned on an architecture that aligns these primitives to their\n-respective sizes. The whole struct will therefore have a size that is a multiple\n-of 32-bits. It will potentially become:\n-\n-```rust\n-struct A {\n-    a: u8,\n-    _pad1: [u8; 3], // to align `b`\n-    b: u32,\n-    c: u16,\n-    _pad2: [u8; 2], // to make overall size multiple of 4\n-}\n-```\n-\n-There is *no indirection* for these types; all data is stored within the struct,\n-as you would expect in C. However with the exception of arrays (which are\n-densely packed and in-order), the layout of data is not by default specified in\n-Rust. Given the two following struct definitions:\n-\n-```rust\n-struct A {\n-    a: i32,\n-    b: u64,\n-}\n-\n-struct B {\n-    a: i32,\n-    b: u64,\n-}\n-```\n-\n-Rust *does* guarantee that two instances of A have their data laid out in\n-exactly the same way. However Rust *does not* currently guarantee that an\n-instance of A has the same field ordering or padding as an instance of B, though\n-in practice there's no reason why they wouldn't.\n-\n-With A and B as written, this point would seem to be pedantic, but several other\n-features of Rust make it desirable for the language to play with data layout in\n-complex ways.\n-\n-For instance, consider this struct:\n-\n-```rust\n-struct Foo<T, U> {\n-    count: u16,\n-    data1: T,\n-    data2: U,\n-}\n-```\n-\n-Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\n-Rust lays out the fields in the order specified, we expect it to pad the\n-values in the struct to satisfy their alignment requirements. So if Rust\n-didn't reorder fields, we would expect it to produce the following:\n-\n-```rust,ignore\n-struct Foo<u16, u32> {\n-    count: u16,\n-    data1: u16,\n-    data2: u32,\n-}\n-\n-struct Foo<u32, u16> {\n-    count: u16,\n-    _pad1: u16,\n-    data1: u32,\n-    data2: u16,\n-    _pad2: u16,\n-}\n-```\n-\n-The latter case quite simply wastes space. An optimal use of space therefore\n-requires different monomorphizations to have *different field orderings*.\n-\n-**Note: this is a hypothetical optimization that is not yet implemented in Rust\n-1.0**\n-\n-Enums make this consideration even more complicated. Naively, an enum such as:\n-\n-```rust\n-enum Foo {\n-    A(u32),\n-    B(u64),\n-    C(u8),\n-}\n-```\n-\n-would be laid out as:\n-\n-```rust\n-struct FooRepr {\n-    data: u64, // this is either a u64, u32, or u8 based on `tag`\n-    tag: u8,   // 0 = A, 1 = B, 2 = C\n-}\n-```\n-\n-And indeed this is approximately how it would be laid out in general (modulo the\n-size and position of `tag`).\n-\n-However there are several cases where such a representation is inefficient. The\n-classic case of this is Rust's \"null pointer optimization\": an enum consisting\n-of a single outer unit variant (e.g. `None`) and a (potentially nested) non-\n-nullable pointer variant (e.g. `&T`) makes the tag unnecessary, because a null\n-pointer value can safely be interpreted to mean that the unit variant is chosen\n-instead. The net result is that, for example, `size_of::<Option<&T>>() ==\n-size_of::<&T>()`.\n-\n-There are many types in Rust that are, or contain, non-nullable pointers such as\n-`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\n-nested enums pooling their tags into a single discriminant, as they are by\n-definition known to have a limited range of valid values. In principle enums could\n-use fairly elaborate algorithms to cache bits throughout nested types with\n-special constrained representations. As such it is *especially* desirable that\n-we leave enum layout unspecified today.\n-\n-[dst]: exotic-sizes.html#dynamically-sized-types-dsts"}, {"sha": "0a655a3f53a21dfe0f80e9e7312bc88d8bbbf791", "filename": "src/doc/nomicon/src/safe-unsafe-meaning.md", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fsafe-unsafe-meaning.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,123 +0,0 @@\n-# How Safe and Unsafe Interact\n-\n-What's the relationship between Safe Rust and Unsafe Rust? How do they\n-interact?\n-\n-The separation between Safe Rust and Unsafe Rust is controlled with the\n-`unsafe` keyword, which acts as an interface from one to the other. This is\n-why we can say Safe Rust is a safe language: all the unsafe parts are kept\n-exclusively behind the boundary.\n-\n-The `unsafe` keyword has two uses: to declare the existence of contracts the\n-compiler can't check, and to declare that the adherence of some code to\n-those contracts has been checked by the programmer.\n-\n-You can use `unsafe` to indicate the existence of unchecked contracts on\n-_functions_ and on _trait declarations_. On functions, `unsafe` means that\n-users of the function must check that function's documentation to ensure\n-they are using it in a way that maintains the contracts the function\n-requires. On trait declarations, `unsafe` means that implementors of the\n-trait must check the trait documentation to ensure their implementation\n-maintains the contracts the trait requires.\n-\n-You can use `unsafe` on a block to declare that all constraints required\n-by an unsafe function within the block have been adhered to, and the code\n-can therefore be trusted. You can use `unsafe` on a trait implementation\n-to declare that the implementation of that trait has adhered to whatever\n-contracts the trait's documentation requires.\n-\n-The standard library has a number of unsafe functions, including:\n-\n-* `slice::get_unchecked`, which performs unchecked indexing, allowing\n-  memory safety to be freely violated.\n-* `mem::transmute` reinterprets some value as having a given type, bypassing\n-  type safety in arbitrary ways (see [conversions] for details).\n-* Every raw pointer to a sized type has an intrinstic `offset` method that\n-  invokes Undefined Behavior if the passed offset is not \"in bounds\" as\n-  defined by LLVM.\n-* All FFI functions are `unsafe` because the other language can do arbitrary\n-  operations that the Rust compiler can't check.\n-\n-As of Rust 1.0 there are exactly two unsafe traits:\n-\n-* `Send` is a marker trait (a trait with no API) that promises implementors are\n-  safe to send (move) to another thread.\n-* `Sync` is a marker trait that promises threads can safely share implementors\n-  through a shared reference.\n-\n-Much of the Rust standard library also uses Unsafe Rust internally, although\n-these implementations are rigorously manually checked, and the Safe Rust\n-interfaces provided on top of these implementations can be assumed to be safe.\n-\n-The need for all of this separation boils down a single fundamental property\n-of Safe Rust:\n-\n-**No matter what, Safe Rust can't cause Undefined Behavior.**\n-\n-The design of the safe/unsafe split means that Safe Rust inherently has to\n-trust that any Unsafe Rust it touches has been written correctly (meaning\n-the Unsafe Rust actually maintains whatever contracts it is supposed to\n-maintain). On the other hand, Unsafe Rust has to be very careful about\n-trusting Safe Rust.\n-\n-As an example, Rust has the `PartialOrd` and `Ord` traits to differentiate\n-between types which can \"just\" be compared, and those that provide a total\n-ordering (where every value of the type is either equal to, greater than,\n-or less than any other value of the same type). The sorted map type\n-`BTreeMap` doesn't make sense for partially-ordered types, and so it\n-requires that any key type for it implements the `Ord` trait. However,\n-`BTreeMap` has Unsafe Rust code inside of its implementation, and this\n-Unsafe Rust code cannot assume that any `Ord` implementation it gets makes\n-sense. The unsafe portions of `BTreeMap`'s internals have to be careful to\n-maintain all necessary contracts, even if a key type's `Ord` implementation\n-does not implement a total ordering.\n-\n-Unsafe Rust cannot automatically trust Safe Rust. When writing Unsafe Rust,\n-you must be careful to only rely on specific Safe Rust code, and not make\n-assumptions about potential future Safe Rust code providing the same\n-guarantees.\n-\n-This is the problem that `unsafe` traits exist to resolve. The `BTreeMap`\n-type could theoretically require that keys implement a new trait called\n-`UnsafeOrd`, rather than `Ord`, that might look like this:\n-\n-```rust\n-use std::cmp::Ordering;\n-\n-unsafe trait UnsafeOrd {\n-    fn cmp(&self, other: &Self) -> Ordering;\n-}\n-```\n-\n-Then, a type would use `unsafe` to implement `UnsafeOrd`, indicating that\n-they've ensured their implementation maintains whatever contracts the\n-trait expects. In this situation, the Unsafe Rust in the internals of\n-`BTreeMap` could trust that the key type's `UnsafeOrd` implementation is\n-correct. If it isn't, it's the fault of the unsafe trait implementation\n-code, which is consistent with Rust's safety guarantees.\n-\n-The decision of whether to mark a trait `unsafe` is an API design choice.\n-Rust has traditionally avoided marking traits unsafe because it makes Unsafe\n-Rust pervasive, which is not desirable. `Send` and `Sync` are marked unsafe\n-because thread safety is a *fundamental property* that unsafe code can't\n-possibly hope to defend against in the way it could defend against a bad\n-`Ord` implementation. The decision of whether to mark your own traits `unsafe`\n-depends on the same sort of consideration. If `unsafe` code cannot reasonably\n-expect to defend against a bad implementation of the trait, then marking the\n-trait `unsafe` is a reasonable choice.\n-\n-As an aside, while `Send` and `Sync` are `unsafe` traits, they are\n-automatically implemented for types when such derivations are provably safe\n-to do. `Send` is automatically derived for all types composed only of values\n-whose types also implement `Send`. `Sync` is automatically derived for all\n-types composed only of values whose types also implement `Sync`.\n-\n-This is the dance of Safe Rust and Unsafe Rust. It is designed to make using\n-Safe Rust as ergonomic as possible, but requires extra effort and care when\n-writing Unsafe Rust. The rest of the book is largely a discussion of the sort\n-of care that must be taken, and what contracts it is expected of Unsafe Rust\n-to uphold.\n-\n-[drop flags]: drop-flags.html\n-[conversions]: conversions.html\n-"}, {"sha": "959f870d4e6459144d42c2b8efb532ced7dd14e2", "filename": "src/doc/nomicon/src/send-and-sync.md", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fsend-and-sync.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,80 +0,0 @@\n-# Send and Sync\n-\n-Not everything obeys inherited mutability, though. Some types allow you to\n-multiply alias a location in memory while mutating it. Unless these types use\n-synchronization to manage this access, they are absolutely not thread safe. Rust\n-captures this through the `Send` and `Sync` traits.\n-\n-* A type is Send if it is safe to send it to another thread.\n-* A type is Sync if it is safe to share between threads (`&T` is Send).\n-\n-Send and Sync are fundamental to Rust's concurrency story. As such, a\n-substantial amount of special tooling exists to make them work right. First and\n-foremost, they're [unsafe traits]. This means that they are unsafe to\n-implement, and other unsafe code can assume that they are correctly\n-implemented. Since they're *marker traits* (they have no associated items like\n-methods), correctly implemented simply means that they have the intrinsic\n-properties an implementor should have. Incorrectly implementing Send or Sync can\n-cause Undefined Behavior.\n-\n-Send and Sync are also automatically derived traits. This means that, unlike\n-every other trait, if a type is composed entirely of Send or Sync types, then it\n-is Send or Sync. Almost all primitives are Send and Sync, and as a consequence\n-pretty much all types you'll ever interact with are Send and Sync.\n-\n-Major exceptions include:\n-\n-* raw pointers are neither Send nor Sync (because they have no safety guards).\n-* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't).\n-* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized).\n-\n-`Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\n-unsynchronized shared mutable state. However raw pointers are, strictly\n-speaking, marked as thread-unsafe as more of a *lint*. Doing anything useful\n-with a raw pointer requires dereferencing it, which is already unsafe. In that\n-sense, one could argue that it would be \"fine\" for them to be marked as thread\n-safe.\n-\n-However it's important that they aren't thread safe to prevent types that\n-contain them from being automatically marked as thread safe. These types have\n-non-trivial untracked ownership, and it's unlikely that their author was\n-necessarily thinking hard about thread safety. In the case of Rc, we have a nice\n-example of a type that contains a `*mut` that is definitely not thread safe.\n-\n-Types that aren't automatically derived can simply implement them if desired:\n-\n-```rust\n-struct MyBox(*mut u8);\n-\n-unsafe impl Send for MyBox {}\n-unsafe impl Sync for MyBox {}\n-```\n-\n-In the *incredibly rare* case that a type is inappropriately automatically\n-derived to be Send or Sync, then one can also unimplement Send and Sync:\n-\n-```rust\n-#![feature(optin_builtin_traits)]\n-\n-// I have some magic semantics for some synchronization primitive!\n-struct SpecialThreadToken(u8);\n-\n-impl !Send for SpecialThreadToken {}\n-impl !Sync for SpecialThreadToken {}\n-```\n-\n-Note that *in and of itself* it is impossible to incorrectly derive Send and\n-Sync. Only types that are ascribed special meaning by other unsafe code can\n-possible cause trouble by being incorrectly Send or Sync.\n-\n-Most uses of raw pointers should be encapsulated behind a sufficient abstraction\n-that Send and Sync can be derived. For instance all of Rust's standard\n-collections are Send and Sync (when they contain Send and Sync types) in spite\n-of their pervasive use of raw pointers to manage allocations and complex ownership.\n-Similarly, most iterators into these collections are Send and Sync because they\n-largely behave like an `&` or `&mut` into the collection.\n-\n-TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\n-only to data races?\n-\n-[unsafe traits]: safe-unsafe-meaning.html"}, {"sha": "d771712d050134712794fbe04f8fed7577212a8e", "filename": "src/doc/nomicon/src/subtyping.md", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fsubtyping.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,213 +0,0 @@\n-# Subtyping and Variance\n-\n-Although Rust doesn't have any notion of structural inheritance, it *does*\n-include subtyping. In Rust, subtyping derives entirely from lifetimes. Since\n-lifetimes are scopes, we can partially order them based on the *contains*\n-(outlives) relationship. We can even express this as a generic bound.\n-\n-Subtyping on lifetimes is in terms of that relationship: if `'a: 'b` (\"a contains\n-b\" or \"a outlives b\"), then `'a` is a subtype of `'b`. This is a large source of\n-confusion, because it seems intuitively backwards to many: the bigger scope is a\n-*subtype* of the smaller scope.\n-\n-This does in fact make sense, though. The intuitive reason for this is that if\n-you expect an `&'a u8`, then it's totally fine for me to hand you an `&'static\n-u8`, in the same way that if you expect an Animal in Java, it's totally fine for\n-me to hand you a Cat. Cats are just Animals *and more*, just as `'static` is\n-just `'a` *and more*.\n-\n-(Note, the subtyping relationship and typed-ness of lifetimes is a fairly\n-arbitrary construct that some disagree with. However it simplifies our analysis\n-to treat lifetimes and types uniformly.)\n-\n-Higher-ranked lifetimes are also subtypes of every concrete lifetime. This is\n-because taking an arbitrary lifetime is strictly more general than taking a\n-specific one.\n-\n-\n-\n-# Variance\n-\n-Variance is where things get a bit complicated.\n-\n-Variance is a property that *type constructors* have with respect to their\n-arguments. A type constructor in Rust is a generic type with unbound arguments.\n-For instance `Vec` is a type constructor that takes a `T` and returns a\n-`Vec<T>`. `&` and `&mut` are type constructors that take two inputs: a\n-lifetime, and a type to point to.\n-\n-A type constructor's *variance* is how the subtyping of its inputs affects the\n-subtyping of its outputs. There are two kinds of variance in Rust:\n-\n-* F is *variant* over `T` if `T` being a subtype of `U` implies\n-  `F<T>` is a subtype of `F<U>` (subtyping \"passes through\")\n-* F is *invariant* over `T` otherwise (no subtyping relation can be derived)\n-\n-(For those of you who are familiar with variance from other languages, what we\n-refer to as \"just\" variance is in fact *covariance*. Rust has *contravariance*\n-for functions. The future of contravariance is uncertain and it may be\n-scrapped. For now, `fn(T)` is contravariant in `T`, which is used in matching\n-methods in trait implementations to the trait definition. Traits don't have\n-inferred variance, so `Fn(T)` is invariant in `T`).\n-\n-Some important variances:\n-\n-* `&'a T` is variant over `'a` and `T` (as is `*const T` by metaphor)\n-* `&'a mut T` is variant over `'a` but invariant over `T`\n-* `Fn(T) -> U` is invariant over `T`, but variant over `U`\n-* `Box`, `Vec`, and all other collections are variant over the types of\n-  their contents\n-* `UnsafeCell<T>`, `Cell<T>`, `RefCell<T>`, `Mutex<T>` and all other\n-  interior mutability types are invariant over T (as is `*mut T` by metaphor)\n-\n-To understand why these variances are correct and desirable, we will consider\n-several examples.\n-\n-\n-We have already covered why `&'a T` should be variant over `'a` when\n-introducing subtyping: it's desirable to be able to pass longer-lived things\n-where shorter-lived things are needed.\n-\n-Similar reasoning applies to why it should be variant over T. It is reasonable\n-to be able to pass `&&'static str` where an `&&'a str` is expected. The\n-additional level of indirection does not change the desire to be able to pass\n-longer lived things where shorted lived things are expected.\n-\n-However this logic doesn't apply to `&mut`. To see why `&mut` should\n-be invariant over T, consider the following code:\n-\n-```rust,ignore\n-fn overwrite<T: Copy>(input: &mut T, new: &mut T) {\n-    *input = *new;\n-}\n-\n-fn main() {\n-    let mut forever_str: &'static str = \"hello\";\n-    {\n-        let string = String::from(\"world\");\n-        overwrite(&mut forever_str, &mut &*string);\n-    }\n-    // Oops, printing free'd memory\n-    println!(\"{}\", forever_str);\n-}\n-```\n-\n-The signature of `overwrite` is clearly valid: it takes mutable references to\n-two values of the same type, and overwrites one with the other. If `&mut T` was\n-variant over T, then `&mut &'static str` would be a subtype of `&mut &'a str`,\n-since `&'static str` is a subtype of `&'a str`. Therefore the lifetime of\n-`forever_str` would successfully be \"shrunk\" down to the shorter lifetime of\n-`string`, and `overwrite` would be called successfully. `string` would\n-subsequently be dropped, and `forever_str` would point to freed memory when we\n-print it! Therefore `&mut` should be invariant.\n-\n-This is the general theme of variance vs invariance: if variance would allow you\n-to store a short-lived value into a longer-lived slot, then you must be\n-invariant.\n-\n-However it *is* sound for `&'a mut T` to be variant over `'a`. The key difference\n-between `'a` and T is that `'a` is a property of the reference itself,\n-while T is something the reference is borrowing. If you change T's type, then\n-the source still remembers the original type. However if you change the\n-lifetime's type, no one but the reference knows this information, so it's fine.\n-Put another way: `&'a mut T` owns `'a`, but only *borrows* T.\n-\n-`Box` and `Vec` are interesting cases because they're variant, but you can\n-definitely store values in them! This is where Rust gets really clever: it's\n-fine for them to be variant because you can only store values\n-in them *via a mutable reference*! The mutable reference makes the whole type\n-invariant, and therefore prevents you from smuggling a short-lived type into\n-them.\n-\n-Being variant allows `Box` and `Vec` to be weakened when shared\n-immutably. So you can pass a `&Box<&'static str>` where a `&Box<&'a str>` is\n-expected.\n-\n-However what should happen when passing *by-value* is less obvious. It turns out\n-that, yes, you can use subtyping when passing by-value. That is, this works:\n-\n-```rust\n-fn get_box<'a>(str: &'a str) -> Box<&'a str> {\n-    // string literals are `&'static str`s\n-    Box::new(\"hello\")\n-}\n-```\n-\n-Weakening when you pass by-value is fine because there's no one else who\n-\"remembers\" the old lifetime in the Box. The reason a variant `&mut` was\n-trouble was because there's always someone else who remembers the original\n-subtype: the actual owner.\n-\n-The invariance of the cell types can be seen as follows: `&` is like an `&mut`\n-for a cell, because you can still store values in them through an `&`. Therefore\n-cells must be invariant to avoid lifetime smuggling.\n-\n-`Fn` is the most subtle case because it has mixed variance. To see why\n-`Fn(T) -> U` should be invariant over T, consider the following function\n-signature:\n-\n-```rust,ignore\n-// 'a is derived from some parent scope\n-fn foo(&'a str) -> usize;\n-```\n-\n-This signature claims that it can handle any `&str` that lives at least as\n-long as `'a`. Now if this signature was variant over `&'a str`, that\n-would mean\n-\n-```rust,ignore\n-fn foo(&'static str) -> usize;\n-```\n-\n-could be provided in its place, as it would be a subtype. However this function\n-has a stronger requirement: it says that it can only handle `&'static str`s,\n-and nothing else. Giving `&'a str`s to it would be unsound, as it's free to\n-assume that what it's given lives forever. Therefore functions are not variant\n-over their arguments.\n-\n-To see why `Fn(T) -> U` should be variant over U, consider the following\n-function signature:\n-\n-```rust,ignore\n-// 'a is derived from some parent scope\n-fn foo(usize) -> &'a str;\n-```\n-\n-This signature claims that it will return something that outlives `'a`. It is\n-therefore completely reasonable to provide\n-\n-```rust,ignore\n-fn foo(usize) -> &'static str;\n-```\n-\n-in its place. Therefore functions are variant over their return type.\n-\n-`*const` has the exact same semantics as `&`, so variance follows. `*mut` on the\n-other hand can dereference to an `&mut` whether shared or not, so it is marked\n-as invariant just like cells.\n-\n-This is all well and good for the types the standard library provides, but\n-how is variance determined for type that *you* define? A struct, informally\n-speaking, inherits the variance of its fields. If a struct `Foo`\n-has a generic argument `A` that is used in a field `a`, then Foo's variance\n-over `A` is exactly `a`'s variance. However this is complicated if `A` is used\n-in multiple fields.\n-\n-* If all uses of A are variant, then Foo is variant over A\n-* Otherwise, Foo is invariant over A\n-\n-```rust\n-use std::cell::Cell;\n-\n-struct Foo<'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H> {\n-    a: &'a A,     // variant over 'a and A\n-    b: &'b mut B, // variant over 'b and invariant over B\n-    c: *const C,  // variant over C\n-    d: *mut D,    // invariant over D\n-    e: Vec<E>,    // variant over E\n-    f: Cell<F>,   // invariant over F\n-    g: G,         // variant over G\n-    h1: H,        // would also be variant over H except...\n-    h2: Cell<H>,  // invariant over H, because invariance wins\n-}\n-```"}, {"sha": "043c8fe462595cb732697edd27965b354c317635", "filename": "src/doc/nomicon/src/transmutes.md", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Ftransmutes.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Ftransmutes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Ftransmutes.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,35 +0,0 @@\n-# Transmutes\n-\n-Get out of our way type system! We're going to reinterpret these bits or die\n-trying! Even though this book is all about doing things that are unsafe, I\n-really can't emphasize that you should deeply think about finding Another Way\n-than the operations covered in this section. This is really, truly, the most\n-horribly unsafe thing you can do in Rust. The railguards here are dental floss.\n-\n-`mem::transmute<T, U>` takes a value of type `T` and reinterprets it to have\n-type `U`. The only restriction is that the `T` and `U` are verified to have the\n-same size. The ways to cause Undefined Behavior with this are mind boggling.\n-\n-* First and foremost, creating an instance of *any* type with an invalid state\n-  is going to cause arbitrary chaos that can't really be predicted.\n-* Transmute has an overloaded return type. If you do not specify the return type\n-  it may produce a surprising type to satisfy inference.\n-* Making a primitive with an invalid value is UB\n-* Transmuting between non-repr(C) types is UB\n-* Transmuting an & to &mut is UB\n-    * Transmuting an & to &mut is *always* UB\n-    * No you can't do it\n-    * No you're not special\n-* Transmuting to a reference without an explicitly provided lifetime\n-  produces an [unbounded lifetime]\n-\n-`mem::transmute_copy<T, U>` somehow manages to be *even more* wildly unsafe than\n-this. It copies `size_of<U>` bytes out of an `&T` and interprets them as a `U`.\n-The size check that `mem::transmute` has is gone (as it may be valid to copy\n-out a prefix), though it is Undefined Behavior for `U` to be larger than `T`.\n-\n-Also of course you can get most of the functionality of these functions using\n-pointer casts.\n-\n-\n-[unbounded lifetime]: unbounded-lifetimes.html"}, {"sha": "b41cf8b4ed91490f6726dfee1e786d328037cd74", "filename": "src/doc/nomicon/src/unbounded-lifetimes.md", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Funbounded-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Funbounded-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Funbounded-lifetimes.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,36 +0,0 @@\n-# Unbounded Lifetimes\n-\n-Unsafe code can often end up producing references or lifetimes out of thin air.\n-Such lifetimes come into the world as *unbounded*. The most common source of this\n-is dereferencing a raw pointer, which produces a reference with an unbounded lifetime.\n-Such a lifetime becomes as big as context demands. This is in fact more powerful\n-than simply becoming `'static`, because for instance `&'static &'a T`\n-will fail to typecheck, but the unbound lifetime will perfectly mold into\n-`&'a &'a T` as needed. However for most intents and purposes, such an unbounded\n-lifetime can be regarded as `'static`.\n-\n-Almost no reference is `'static`, so this is probably wrong. `transmute` and\n-`transmute_copy` are the two other primary offenders. One should endeavor to\n-bound an unbounded lifetime as quickly as possible, especially across function\n-boundaries.\n-\n-Given a function, any output lifetimes that don't derive from inputs are\n-unbounded. For instance:\n-\n-```rust,ignore\n-fn get_str<'a>() -> &'a str;\n-```\n-\n-will produce an `&str` with an unbounded lifetime. The easiest way to avoid\n-unbounded lifetimes is to use lifetime elision at the function boundary.\n-If an output lifetime is elided, then it *must* be bounded by an input lifetime.\n-Of course it might be bounded by the *wrong* lifetime, but this will usually\n-just cause a compiler error, rather than allow memory safety to be trivially\n-violated.\n-\n-Within a function, bounding lifetimes is more error-prone. The safest and easiest\n-way to bound a lifetime is to return it from a function with a bound lifetime.\n-However if this is unacceptable, the reference can be placed in a location with\n-a specific lifetime. Unfortunately it's impossible to name all lifetimes involved\n-in a function.\n-"}, {"sha": "ef31a3535d6a07cc23f7a5d5d4456050ba68ddbd", "filename": "src/doc/nomicon/src/unchecked-uninit.md", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Funchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Funchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Funchecked-uninit.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,85 +0,0 @@\n-# Unchecked Uninitialized Memory\n-\n-One interesting exception to this rule is working with arrays. Safe Rust doesn't\n-permit you to partially initialize an array. When you initialize an array, you\n-can either set every value to the same thing with `let x = [val; N]`, or you can\n-specify each member individually with `let x = [val1, val2, val3]`.\n-Unfortunately this is pretty rigid, especially if you need to initialize your\n-array in a more incremental or dynamic way.\n-\n-Unsafe Rust gives us a powerful tool to handle this problem:\n-`mem::uninitialized`. This function pretends to return a value when really\n-it does nothing at all. Using it, we can convince Rust that we have initialized\n-a variable, allowing us to do trickier things with conditional and incremental\n-initialization.\n-\n-Unfortunately, this opens us up to all kinds of problems. Assignment has a\n-different meaning to Rust based on whether it believes that a variable is\n-initialized or not. If it's believed uninitialized, then Rust will semantically\n-just memcopy the bits over the uninitialized ones, and do nothing else. However\n-if Rust believes a value to be initialized, it will try to `Drop` the old value!\n-Since we've tricked Rust into believing that the value is initialized, we can no\n-longer safely use normal assignment.\n-\n-This is also a problem if you're working with a raw system allocator, which\n-returns a pointer to uninitialized memory.\n-\n-To handle this, we must use the `ptr` module. In particular, it provides\n-three functions that allow us to assign bytes to a location in memory without\n-dropping the old value: `write`, `copy`, and `copy_nonoverlapping`.\n-\n-* `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed\n-  to by `ptr`.\n-* `ptr::copy(src, dest, count)` copies the bits that `count` T's would occupy\n-  from src to dest. (this is equivalent to memmove -- note that the argument\n-  order is reversed!)\n-* `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a\n-  little faster on the assumption that the two ranges of memory don't overlap.\n-  (this is equivalent to memcpy -- note that the argument order is reversed!)\n-\n-It should go without saying that these functions, if misused, will cause serious\n-havoc or just straight up Undefined Behavior. The only things that these\n-functions *themselves* require is that the locations you want to read and write\n-are allocated. However the ways writing arbitrary bits to arbitrary\n-locations of memory can break things are basically uncountable!\n-\n-Putting this all together, we get the following:\n-\n-```rust\n-use std::mem;\n-use std::ptr;\n-\n-// size of the array is hard-coded but easy to change. This means we can't\n-// use [a, b, c] syntax to initialize the array, though!\n-const SIZE: usize = 10;\n-\n-let mut x: [Box<u32>; SIZE];\n-\n-unsafe {\n-\t// convince Rust that x is Totally Initialized\n-\tx = mem::uninitialized();\n-\tfor i in 0..SIZE {\n-\t\t// very carefully overwrite each index without reading it\n-\t\t// NOTE: exception safety is not a concern; Box can't panic\n-\t\tptr::write(&mut x[i], Box::new(i as u32));\n-\t}\n-}\n-\n-println!(\"{:?}\", x);\n-```\n-\n-It's worth noting that you don't need to worry about `ptr::write`-style\n-shenanigans with types which don't implement `Drop` or contain `Drop` types,\n-because Rust knows not to try to drop them. Similarly you should be able to\n-assign to fields of partially initialized structs directly if those fields don't\n-contain any `Drop` types.\n-\n-However when working with uninitialized memory you need to be ever-vigilant for\n-Rust trying to drop values you make like this before they're fully initialized.\n-Every control path through that variable's scope must initialize the value\n-before it ends, if it has a destructor.\n-*[This includes code panicking](unwinding.html)*.\n-\n-And that's about it for working with uninitialized memory! Basically nothing\n-anywhere expects to be handed uninitialized memory, so if you're going to pass\n-it around at all, be sure to be *really* careful."}, {"sha": "eafc67907f2af43c57b60f0b91c9664bec42f102", "filename": "src/doc/nomicon/src/uninitialized.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Funinitialized.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Funinitialized.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Funinitialized.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,10 +0,0 @@\n-# Working With Uninitialized Memory\n-\n-All runtime-allocated memory in a Rust program begins its life as\n-*uninitialized*. In this state the value of the memory is an indeterminate pile\n-of bits that may or may not even reflect a valid state for the type that is\n-supposed to inhabit that location of memory. Attempting to interpret this memory\n-as a value of *any* type will cause Undefined Behavior. Do Not Do This.\n-\n-Rust provides mechanisms to work with uninitialized memory in checked (safe) and\n-unchecked (unsafe) ways."}, {"sha": "6dc396d5153482c392470997f7c7b400a973c091", "filename": "src/doc/nomicon/src/unwinding.md", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Funwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Funwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Funwinding.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,49 +0,0 @@\n-# Unwinding\n-\n-Rust has a *tiered* error-handling scheme:\n-\n-* If something might reasonably be absent, Option is used.\n-* If something goes wrong and can reasonably be handled, Result is used.\n-* If something goes wrong and cannot reasonably be handled, the thread panics.\n-* If something catastrophic happens, the program aborts.\n-\n-Option and Result are overwhelmingly preferred in most situations, especially\n-since they can be promoted into a panic or abort at the API user's discretion.\n-Panics cause the thread to halt normal execution and unwind its stack, calling\n-destructors as if every function instantly returned.\n-\n-As of 1.0, Rust is of two minds when it comes to panics. In the long-long-ago,\n-Rust was much more like Erlang. Like Erlang, Rust had lightweight tasks,\n-and tasks were intended to kill themselves with a panic when they reached an\n-untenable state. Unlike an exception in Java or C++, a panic could not be\n-caught at any time. Panics could only be caught by the owner of the task, at which\n-point they had to be handled or *that* task would itself panic.\n-\n-Unwinding was important to this story because if a task's\n-destructors weren't called, it would cause memory and other system resources to\n-leak. Since tasks were expected to die during normal execution, this would make\n-Rust very poor for long-running systems!\n-\n-As the Rust we know today came to be, this style of programming grew out of\n-fashion in the push for less-and-less abstraction. Light-weight tasks were\n-killed in the name of heavy-weight OS threads. Still, on stable Rust as of 1.0\n-panics can only be caught by the parent thread. This means catching a panic\n-requires spinning up an entire OS thread! This unfortunately stands in conflict\n-to Rust's philosophy of zero-cost abstractions.\n-\n-There is an unstable API called `catch_panic` that enables catching a panic\n-without spawning a thread. Still, we would encourage you to only do this\n-sparingly. In particular, Rust's current unwinding implementation is heavily\n-optimized for the \"doesn't unwind\" case. If a program doesn't unwind, there\n-should be no runtime cost for the program being *ready* to unwind. As a\n-consequence, actually unwinding will be more expensive than in e.g. Java.\n-Don't build your programs to unwind under normal circumstances. Ideally, you\n-should only panic for programming errors or *extreme* problems.\n-\n-Rust's unwinding strategy is not specified to be fundamentally compatible\n-with any other language's unwinding. As such, unwinding into Rust from another\n-language, or unwinding into another language from Rust is Undefined Behavior.\n-You must *absolutely* catch any panics at the FFI boundary! What you do at that\n-point is up to you, but *something* must be done. If you fail to do this,\n-at best, your application will crash and burn. At worst, your application *won't*\n-crash and burn, and will proceed with completely clobbered state."}, {"sha": "ef4c52793433f9ef23ee7a96ce7017f7f9d678fe", "filename": "src/doc/nomicon/src/vec-alloc.md", "status": "removed", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-alloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-alloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-alloc.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,223 +0,0 @@\n-# Allocating Memory\n-\n-Using Unique throws a wrench in an important feature of Vec (and indeed all of\n-the std collections): an empty Vec doesn't actually allocate at all. So if we\n-can't allocate, but also can't put a null pointer in `ptr`, what do we do in\n-`Vec::new`? Well, we just put some other garbage in there!\n-\n-This is perfectly fine because we already have `cap == 0` as our sentinel for no\n-allocation. We don't even need to handle it specially in almost any code because\n-we usually need to check if `cap > len` or `len > 0` anyway. The traditional\n-Rust value to put here is `0x01`. The standard library actually exposes this\n-as `alloc::heap::EMPTY`. There are quite a few places where we'll\n-want to use `heap::EMPTY` because there's no real allocation to talk about but\n-`null` would make the compiler do bad things.\n-\n-All of the `heap` API is totally unstable under the `heap_api` feature, though.\n-We could trivially define `heap::EMPTY` ourselves, but we'll want the rest of\n-the `heap` API anyway, so let's just get that dependency over with.\n-\n-So:\n-\n-```rust,ignore\n-#![feature(alloc, heap_api)]\n-\n-use std::mem;\n-\n-use alloc::heap::EMPTY;\n-\n-impl<T> Vec<T> {\n-    fn new() -> Self {\n-        assert!(mem::size_of::<T>() != 0, \"We're not ready to handle ZSTs\");\n-        unsafe {\n-            // need to cast EMPTY to the actual ptr type we want, let\n-            // inference handle it.\n-            Vec { ptr: Unique::new(heap::EMPTY as *mut _), len: 0, cap: 0 }\n-        }\n-    }\n-}\n-```\n-\n-I slipped in that assert there because zero-sized types will require some\n-special handling throughout our code, and I want to defer the issue for now.\n-Without this assert, some of our early drafts will do some Very Bad Things.\n-\n-Next we need to figure out what to actually do when we *do* want space. For\n-that, we'll need to use the rest of the heap APIs. These basically allow us to\n-talk directly to Rust's allocator (jemalloc by default).\n-\n-We'll also need a way to handle out-of-memory (OOM) conditions. The standard\n-library calls the `abort` intrinsic, which just calls an illegal instruction to\n-crash the whole program. The reason we abort and don't panic is because\n-unwinding can cause allocations to happen, and that seems like a bad thing to do\n-when your allocator just came back with \"hey I don't have any more memory\".\n-\n-Of course, this is a bit silly since most platforms don't actually run out of\n-memory in a conventional way. Your operating system will probably kill the\n-application by another means if you legitimately start using up all the memory.\n-The most likely way we'll trigger OOM is by just asking for ludicrous quantities\n-of memory at once (e.g. half the theoretical address space). As such it's\n-*probably* fine to panic and nothing bad will happen. Still, we're trying to be\n-like the standard library as much as possible, so we'll just kill the whole\n-program.\n-\n-We said we don't want to use intrinsics, so doing exactly what `std` does is\n-out. Instead, we'll call `std::process::exit` with some random number.\n-\n-```rust\n-fn oom() {\n-    ::std::process::exit(-9999);\n-}\n-```\n-\n-Okay, now we can write growing. Roughly, we want to have this logic:\n-\n-```text\n-if cap == 0:\n-    allocate()\n-    cap = 1\n-else:\n-    reallocate()\n-    cap *= 2\n-```\n-\n-But Rust's only supported allocator API is so low level that we'll need to do a\n-fair bit of extra work. We also need to guard against some special\n-conditions that can occur with really large allocations or empty allocations.\n-\n-In particular, `ptr::offset` will cause us a lot of trouble, because it has\n-the semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to\n-not have dealt with this instruction, here's the basic story with GEP: alias\n-analysis, alias analysis, alias analysis. It's super important to an optimizing\n-compiler to be able to reason about data dependencies and aliasing.\n-\n-As a simple example, consider the following fragment of code:\n-\n-```rust\n-# let x = &mut 0;\n-# let y = &mut 0;\n-*x *= 7;\n-*y *= 3;\n-```\n-\n-If the compiler can prove that `x` and `y` point to different locations in\n-memory, the two operations can in theory be executed in parallel (by e.g.\n-loading them into different registers and working on them independently).\n-However the compiler can't do this in general because if x and y point to\n-the same location in memory, the operations need to be done to the same value,\n-and they can't just be merged afterwards.\n-\n-When you use GEP inbounds, you are specifically telling LLVM that the offsets\n-you're about to do are within the bounds of a single \"allocated\" entity. The\n-ultimate payoff being that LLVM can assume that if two pointers are known to\n-point to two disjoint objects, all the offsets of those pointers are *also*\n-known to not alias (because you won't just end up in some random place in\n-memory). LLVM is heavily optimized to work with GEP offsets, and inbounds\n-offsets are the best of all, so it's important that we use them as much as\n-possible.\n-\n-So that's what GEP's about, how can it cause us trouble?\n-\n-The first problem is that we index into arrays with unsigned integers, but\n-GEP (and as a consequence `ptr::offset`) takes a signed integer. This means\n-that half of the seemingly valid indices into an array will overflow GEP and\n-actually go in the wrong direction! As such we must limit all allocations to\n-`isize::MAX` elements. This actually means we only need to worry about\n-byte-sized objects, because e.g. `> isize::MAX` `u16`s will truly exhaust all of\n-the system's memory. However in order to avoid subtle corner cases where someone\n-reinterprets some array of `< isize::MAX` objects as bytes, std limits all\n-allocations to `isize::MAX` bytes.\n-\n-On all 64-bit targets that Rust currently supports we're artificially limited\n-to significantly less than all 64 bits of the address space (modern x64\n-platforms only expose 48-bit addressing), so we can rely on just running out of\n-memory first. However on 32-bit targets, particularly those with extensions to\n-use more of the address space (PAE x86 or x32), it's theoretically possible to\n-successfully allocate more than `isize::MAX` bytes of memory.\n-\n-However since this is a tutorial, we're not going to be particularly optimal\n-here, and just unconditionally check, rather than use clever platform-specific\n-`cfg`s.\n-\n-The other corner-case we need to worry about is empty allocations. There will\n-be two kinds of empty allocations we need to worry about: `cap = 0` for all T,\n-and `cap > 0` for zero-sized types.\n-\n-These cases are tricky because they come\n-down to what LLVM means by \"allocated\". LLVM's notion of an\n-allocation is significantly more abstract than how we usually use it. Because\n-LLVM needs to work with different languages' semantics and custom allocators,\n-it can't really intimately understand allocation. Instead, the main idea behind\n-allocation is \"doesn't overlap with other stuff\". That is, heap allocations,\n-stack allocations, and globals don't randomly overlap. Yep, it's about alias\n-analysis. As such, Rust can technically play a bit fast and loose with the notion of\n-an allocation as long as it's *consistent*.\n-\n-Getting back to the empty allocation case, there are a couple of places where\n-we want to offset by 0 as a consequence of generic code. The question is then:\n-is it consistent to do so? For zero-sized types, we have concluded that it is\n-indeed consistent to do a GEP inbounds offset by an arbitrary number of\n-elements. This is a runtime no-op because every element takes up no space,\n-and it's fine to pretend that there's infinite zero-sized types allocated\n-at `0x01`. No allocator will ever allocate that address, because they won't\n-allocate `0x00` and they generally allocate to some minimal alignment higher\n-than a byte. Also generally the whole first page of memory is\n-protected from being allocated anyway (a whole 4k, on many platforms).\n-\n-However what about for positive-sized types? That one's a bit trickier. In\n-principle, you can argue that offsetting by 0 gives LLVM no information: either\n-there's an element before the address or after it, but it can't know which.\n-However we've chosen to conservatively assume that it may do bad things. As\n-such we will guard against this case explicitly.\n-\n-*Phew*\n-\n-Ok with all the nonsense out of the way, let's actually allocate some memory:\n-\n-```rust,ignore\n-fn grow(&mut self) {\n-    // this is all pretty delicate, so let's say it's all unsafe\n-    unsafe {\n-        // current API requires us to specify size and alignment manually.\n-        let align = mem::align_of::<T>();\n-        let elem_size = mem::size_of::<T>();\n-\n-        let (new_cap, ptr) = if self.cap == 0 {\n-            let ptr = heap::allocate(elem_size, align);\n-            (1, ptr)\n-        } else {\n-            // as an invariant, we can assume that `self.cap < isize::MAX`,\n-            // so this doesn't need to be checked.\n-            let new_cap = self.cap * 2;\n-            // Similarly this can't overflow due to previously allocating this\n-            let old_num_bytes = self.cap * elem_size;\n-\n-            // check that the new allocation doesn't exceed `isize::MAX` at all\n-            // regardless of the actual size of the capacity. This combines the\n-            // `new_cap <= isize::MAX` and `new_num_bytes <= usize::MAX` checks\n-            // we need to make. We lose the ability to allocate e.g. 2/3rds of\n-            // the address space with a single Vec of i16's on 32-bit though.\n-            // Alas, poor Yorick -- I knew him, Horatio.\n-            assert!(old_num_bytes <= (::std::isize::MAX as usize) / 2,\n-                    \"capacity overflow\");\n-\n-            let new_num_bytes = old_num_bytes * 2;\n-            let ptr = heap::reallocate(*self.ptr as *mut _,\n-                                        old_num_bytes,\n-                                        new_num_bytes,\n-                                        align);\n-            (new_cap, ptr)\n-        };\n-\n-        // If allocate or reallocate fail, we'll get `null` back\n-        if ptr.is_null() { oom(); }\n-\n-        self.ptr = Unique::new(ptr as *mut _);\n-        self.cap = new_cap;\n-    }\n-}\n-```\n-\n-Nothing particularly tricky here. Just computing sizes and alignments and doing\n-some careful multiplication checks.\n-"}, {"sha": "83ab5b24b02453b29395ffdebe1edfbc23a488f0", "filename": "src/doc/nomicon/src/vec-dealloc.md", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-dealloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-dealloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-dealloc.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,29 +0,0 @@\n-# Deallocating\n-\n-Next we should implement Drop so that we don't massively leak tons of resources.\n-The easiest way is to just call `pop` until it yields None, and then deallocate\n-our buffer. Note that calling `pop` is unneeded if `T: !Drop`. In theory we can\n-ask Rust if `T` `needs_drop` and omit the calls to `pop`. However in practice\n-LLVM is *really* good at removing simple side-effect free code like this, so I\n-wouldn't bother unless you notice it's not being stripped (in this case it is).\n-\n-We must not call `heap::deallocate` when `self.cap == 0`, as in this case we\n-haven't actually allocated any memory.\n-\n-\n-```rust,ignore\n-impl<T> Drop for Vec<T> {\n-    fn drop(&mut self) {\n-        if self.cap != 0 {\n-            while let Some(_) = self.pop() { }\n-\n-            let align = mem::align_of::<T>();\n-            let elem_size = mem::size_of::<T>();\n-            let num_bytes = elem_size * self.cap;\n-            unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n-            }\n-        }\n-    }\n-}\n-```"}, {"sha": "e21542c955aeba457bc0484489786bc11883e13d", "filename": "src/doc/nomicon/src/vec-deref.md", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-deref.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-deref.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-deref.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,42 +0,0 @@\n-# Deref\n-\n-Alright! We've got a decent minimal stack implemented. We can push, we can\n-pop, and we can clean up after ourselves. However there's a whole mess of\n-functionality we'd reasonably want. In particular, we have a proper array, but\n-none of the slice functionality. That's actually pretty easy to solve: we can\n-implement `Deref<Target=[T]>`. This will magically make our Vec coerce to, and\n-behave like, a slice in all sorts of conditions.\n-\n-All we need is `slice::from_raw_parts`. It will correctly handle empty slices\n-for us. Later once we set up zero-sized type support it will also Just Work\n-for those too.\n-\n-```rust,ignore\n-use std::ops::Deref;\n-\n-impl<T> Deref for Vec<T> {\n-    type Target = [T];\n-    fn deref(&self) -> &[T] {\n-        unsafe {\n-            ::std::slice::from_raw_parts(*self.ptr, self.len)\n-        }\n-    }\n-}\n-```\n-\n-And let's do DerefMut too:\n-\n-```rust,ignore\n-use std::ops::DerefMut;\n-\n-impl<T> DerefMut for Vec<T> {\n-    fn deref_mut(&mut self) -> &mut [T] {\n-        unsafe {\n-            ::std::slice::from_raw_parts_mut(*self.ptr, self.len)\n-        }\n-    }\n-}\n-```\n-\n-Now we have `len`, `first`, `last`, indexing, slicing, sorting, `iter`,\n-`iter_mut`, and all other sorts of bells and whistles provided by slice. Sweet!"}, {"sha": "5bd2bf05d8c081496d227a9465f7a65c527cf979", "filename": "src/doc/nomicon/src/vec-drain.md", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-drain.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-drain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-drain.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,152 +0,0 @@\n-# Drain\n-\n-Let's move on to Drain. Drain is largely the same as IntoIter, except that\n-instead of consuming the Vec, it borrows the Vec and leaves its allocation\n-untouched. For now we'll only implement the \"basic\" full-range version.\n-\n-```rust,ignore\n-use std::marker::PhantomData;\n-\n-struct Drain<'a, T: 'a> {\n-    // Need to bound the lifetime here, so we do it with `&'a mut Vec<T>`\n-    // because that's semantically what we contain. We're \"just\" calling\n-    // `pop()` and `remove(0)`.\n-    vec: PhantomData<&'a mut Vec<T>>\n-    start: *const T,\n-    end: *const T,\n-}\n-\n-impl<'a, T> Iterator for Drain<'a, T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> {\n-        if self.start == self.end {\n-            None\n-```\n-\n--- wait, this is seeming familiar. Let's do some more compression. Both\n-IntoIter and Drain have the exact same structure, let's just factor it out.\n-\n-```rust\n-struct RawValIter<T> {\n-    start: *const T,\n-    end: *const T,\n-}\n-\n-impl<T> RawValIter<T> {\n-    // unsafe to construct because it has no associated lifetimes.\n-    // This is necessary to store a RawValIter in the same struct as\n-    // its actual allocation. OK since it's a private implementation\n-    // detail.\n-    unsafe fn new(slice: &[T]) -> Self {\n-        RawValIter {\n-            start: slice.as_ptr(),\n-            end: if slice.len() == 0 {\n-                // if `len = 0`, then this is not actually allocated memory.\n-                // Need to avoid offsetting because that will give wrong\n-                // information to LLVM via GEP.\n-                slice.as_ptr()\n-            } else {\n-                slice.as_ptr().offset(slice.len() as isize)\n-            }\n-        }\n-    }\n-}\n-\n-// Iterator and DoubleEndedIterator impls identical to IntoIter.\n-```\n-\n-And IntoIter becomes the following:\n-\n-```rust,ignore\n-pub struct IntoIter<T> {\n-    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n-    iter: RawValIter<T>,\n-}\n-\n-impl<T> Iterator for IntoIter<T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n-}\n-\n-impl<T> Drop for IntoIter<T> {\n-    fn drop(&mut self) {\n-        for _ in &mut self.iter {}\n-    }\n-}\n-\n-impl<T> Vec<T> {\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        unsafe {\n-            let iter = RawValIter::new(&self);\n-\n-            let buf = ptr::read(&self.buf);\n-            mem::forget(self);\n-\n-            IntoIter {\n-                iter: iter,\n-                _buf: buf,\n-            }\n-        }\n-    }\n-}\n-```\n-\n-Note that I've left a few quirks in this design to make upgrading Drain to work\n-with arbitrary subranges a bit easier. In particular we *could* have RawValIter\n-drain itself on drop, but that won't work right for a more complex Drain.\n-We also take a slice to simplify Drain initialization.\n-\n-Alright, now Drain is really easy:\n-\n-```rust,ignore\n-use std::marker::PhantomData;\n-\n-pub struct Drain<'a, T: 'a> {\n-    vec: PhantomData<&'a mut Vec<T>>,\n-    iter: RawValIter<T>,\n-}\n-\n-impl<'a, T> Iterator for Drain<'a, T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n-}\n-\n-impl<'a, T> Drop for Drain<'a, T> {\n-    fn drop(&mut self) {\n-        for _ in &mut self.iter {}\n-    }\n-}\n-\n-impl<T> Vec<T> {\n-    pub fn drain(&mut self) -> Drain<T> {\n-        unsafe {\n-            let iter = RawValIter::new(&self);\n-\n-            // this is a mem::forget safety thing. If Drain is forgotten, we just\n-            // leak the whole Vec's contents. Also we need to do this *eventually*\n-            // anyway, so why not do it now?\n-            self.len = 0;\n-\n-            Drain {\n-                iter: iter,\n-                vec: PhantomData,\n-            }\n-        }\n-    }\n-}\n-```\n-\n-For more details on the `mem::forget` problem, see the\n-[section on leaks][leaks].\n-\n-[leaks]: leaking.html"}, {"sha": "39746cad781f8d98cded467e771d378ece5da9c2", "filename": "src/doc/nomicon/src/vec-final.md", "status": "removed", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-final.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-final.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-final.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,321 +0,0 @@\n-# The Final Code\n-\n-```rust\n-#![feature(unique)]\n-#![feature(alloc, heap_api)]\n-\n-extern crate alloc;\n-\n-use std::ptr::{Unique, self};\n-use std::mem;\n-use std::ops::{Deref, DerefMut};\n-use std::marker::PhantomData;\n-\n-use alloc::heap;\n-\n-struct RawVec<T> {\n-    ptr: Unique<T>,\n-    cap: usize,\n-}\n-\n-impl<T> RawVec<T> {\n-    fn new() -> Self {\n-        unsafe {\n-            // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n-\n-            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n-            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: cap }\n-        }\n-    }\n-\n-    fn grow(&mut self) {\n-        unsafe {\n-            let elem_size = mem::size_of::<T>();\n-\n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the Vec is overfull.\n-            assert!(elem_size != 0, \"capacity overflow\");\n-\n-            let align = mem::align_of::<T>();\n-\n-            let (new_cap, ptr) = if self.cap == 0 {\n-                let ptr = heap::allocate(elem_size, align);\n-                (1, ptr)\n-            } else {\n-                let new_cap = 2 * self.cap;\n-                let ptr = heap::reallocate(*self.ptr as *mut _,\n-                                            self.cap * elem_size,\n-                                            new_cap * elem_size,\n-                                            align);\n-                (new_cap, ptr)\n-            };\n-\n-            // If allocate or reallocate fail, we'll get `null` back\n-            if ptr.is_null() { oom() }\n-\n-            self.ptr = Unique::new(ptr as *mut _);\n-            self.cap = new_cap;\n-        }\n-    }\n-}\n-\n-impl<T> Drop for RawVec<T> {\n-    fn drop(&mut self) {\n-        let elem_size = mem::size_of::<T>();\n-        if self.cap != 0 && elem_size != 0 {\n-            let align = mem::align_of::<T>();\n-\n-            let num_bytes = elem_size * self.cap;\n-            unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n-            }\n-        }\n-    }\n-}\n-\n-\n-\n-\n-\n-pub struct Vec<T> {\n-    buf: RawVec<T>,\n-    len: usize,\n-}\n-\n-impl<T> Vec<T> {\n-    fn ptr(&self) -> *mut T { *self.buf.ptr }\n-\n-    fn cap(&self) -> usize { self.buf.cap }\n-\n-    pub fn new() -> Self {\n-        Vec { buf: RawVec::new(), len: 0 }\n-    }\n-    pub fn push(&mut self, elem: T) {\n-        if self.len == self.cap() { self.buf.grow(); }\n-\n-        unsafe {\n-            ptr::write(self.ptr().offset(self.len as isize), elem);\n-        }\n-\n-        // Can't fail, we'll OOM first.\n-        self.len += 1;\n-    }\n-\n-    pub fn pop(&mut self) -> Option<T> {\n-        if self.len == 0 {\n-            None\n-        } else {\n-            self.len -= 1;\n-            unsafe {\n-                Some(ptr::read(self.ptr().offset(self.len as isize)))\n-            }\n-        }\n-    }\n-\n-    pub fn insert(&mut self, index: usize, elem: T) {\n-        assert!(index <= self.len, \"index out of bounds\");\n-        if self.cap() == self.len { self.buf.grow(); }\n-\n-        unsafe {\n-            if index < self.len {\n-                ptr::copy(self.ptr().offset(index as isize),\n-                          self.ptr().offset(index as isize + 1),\n-                          self.len - index);\n-            }\n-            ptr::write(self.ptr().offset(index as isize), elem);\n-            self.len += 1;\n-        }\n-    }\n-\n-    pub fn remove(&mut self, index: usize) -> T {\n-        assert!(index < self.len, \"index out of bounds\");\n-        unsafe {\n-            self.len -= 1;\n-            let result = ptr::read(self.ptr().offset(index as isize));\n-            ptr::copy(self.ptr().offset(index as isize + 1),\n-                      self.ptr().offset(index as isize),\n-                      self.len - index);\n-            result\n-        }\n-    }\n-\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        unsafe {\n-            let iter = RawValIter::new(&self);\n-            let buf = ptr::read(&self.buf);\n-            mem::forget(self);\n-\n-            IntoIter {\n-                iter: iter,\n-                _buf: buf,\n-            }\n-        }\n-    }\n-\n-    pub fn drain(&mut self) -> Drain<T> {\n-        unsafe {\n-            let iter = RawValIter::new(&self);\n-\n-            // this is a mem::forget safety thing. If Drain is forgotten, we just\n-            // leak the whole Vec's contents. Also we need to do this *eventually*\n-            // anyway, so why not do it now?\n-            self.len = 0;\n-\n-            Drain {\n-                iter: iter,\n-                vec: PhantomData,\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Vec<T> {\n-    fn drop(&mut self) {\n-        while let Some(_) = self.pop() {}\n-        // allocation is handled by RawVec\n-    }\n-}\n-\n-impl<T> Deref for Vec<T> {\n-    type Target = [T];\n-    fn deref(&self) -> &[T] {\n-        unsafe {\n-            ::std::slice::from_raw_parts(self.ptr(), self.len)\n-        }\n-    }\n-}\n-\n-impl<T> DerefMut for Vec<T> {\n-    fn deref_mut(&mut self) -> &mut [T] {\n-        unsafe {\n-            ::std::slice::from_raw_parts_mut(self.ptr(), self.len)\n-        }\n-    }\n-}\n-\n-\n-\n-\n-\n-struct RawValIter<T> {\n-    start: *const T,\n-    end: *const T,\n-}\n-\n-impl<T> RawValIter<T> {\n-    unsafe fn new(slice: &[T]) -> Self {\n-        RawValIter {\n-            start: slice.as_ptr(),\n-            end: if mem::size_of::<T>() == 0 {\n-                ((slice.as_ptr() as usize) + slice.len()) as *const _\n-            } else if slice.len() == 0 {\n-                slice.as_ptr()\n-            } else {\n-                slice.as_ptr().offset(slice.len() as isize)\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Iterator for RawValIter<T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> {\n-        if self.start == self.end {\n-            None\n-        } else {\n-            unsafe {\n-                let result = ptr::read(self.start);\n-                self.start = if mem::size_of::<T>() == 0 {\n-                    (self.start as usize + 1) as *const _\n-                } else {\n-                    self.start.offset(1)\n-                };\n-                Some(result)\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let elem_size = mem::size_of::<T>();\n-        let len = (self.end as usize - self.start as usize)\n-                  / if elem_size == 0 { 1 } else { elem_size };\n-        (len, Some(len))\n-    }\n-}\n-\n-impl<T> DoubleEndedIterator for RawValIter<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.start == self.end {\n-            None\n-        } else {\n-            unsafe {\n-                self.end = if mem::size_of::<T>() == 0 {\n-                    (self.end as usize - 1) as *const _\n-                } else {\n-                    self.end.offset(-1)\n-                };\n-                Some(ptr::read(self.end))\n-            }\n-        }\n-    }\n-}\n-\n-\n-\n-\n-pub struct IntoIter<T> {\n-    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n-    iter: RawValIter<T>,\n-}\n-\n-impl<T> Iterator for IntoIter<T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n-}\n-\n-impl<T> Drop for IntoIter<T> {\n-    fn drop(&mut self) {\n-        for _ in &mut *self {}\n-    }\n-}\n-\n-\n-\n-\n-pub struct Drain<'a, T: 'a> {\n-    vec: PhantomData<&'a mut Vec<T>>,\n-    iter: RawValIter<T>,\n-}\n-\n-impl<'a, T> Iterator for Drain<'a, T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> { self.iter.next_back() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n-}\n-\n-impl<'a, T> Drop for Drain<'a, T> {\n-    fn drop(&mut self) {\n-        // pre-drain the iter\n-        for _ in &mut self.iter {}\n-    }\n-}\n-\n-/// Abort the process, we're out of memory!\n-///\n-/// In practice this is probably dead code on most OSes\n-fn oom() {\n-    ::std::process::exit(-9999);\n-}\n-\n-# fn main() {}\n-```"}, {"sha": "2c14bc4522722e25bf80312f75df2b9c90c28d98", "filename": "src/doc/nomicon/src/vec-insert-remove.md", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-insert-remove.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-insert-remove.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-insert-remove.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,51 +0,0 @@\n-# Insert and Remove\n-\n-Something *not* provided by slice is `insert` and `remove`, so let's do those\n-next.\n-\n-Insert needs to shift all the elements at the target index to the right by one.\n-To do this we need to use `ptr::copy`, which is our version of C's `memmove`.\n-This copies some chunk of memory from one location to another, correctly\n-handling the case where the source and destination overlap (which will\n-definitely happen here).\n-\n-If we insert at index `i`, we want to shift the `[i .. len]` to `[i+1 .. len+1]`\n-using the old len.\n-\n-```rust,ignore\n-pub fn insert(&mut self, index: usize, elem: T) {\n-    // Note: `<=` because it's valid to insert after everything\n-    // which would be equivalent to push.\n-    assert!(index <= self.len, \"index out of bounds\");\n-    if self.cap == self.len { self.grow(); }\n-\n-    unsafe {\n-        if index < self.len {\n-            // ptr::copy(src, dest, len): \"copy from source to dest len elems\"\n-            ptr::copy(self.ptr.offset(index as isize),\n-                      self.ptr.offset(index as isize + 1),\n-                      self.len - index);\n-        }\n-        ptr::write(self.ptr.offset(index as isize), elem);\n-        self.len += 1;\n-    }\n-}\n-```\n-\n-Remove behaves in the opposite manner. We need to shift all the elements from\n-`[i+1 .. len + 1]` to `[i .. len]` using the *new* len.\n-\n-```rust,ignore\n-pub fn remove(&mut self, index: usize) -> T {\n-    // Note: `<` because it's *not* valid to remove after everything\n-    assert!(index < self.len, \"index out of bounds\");\n-    unsafe {\n-        self.len -= 1;\n-        let result = ptr::read(self.ptr.offset(index as isize));\n-        ptr::copy(self.ptr.offset(index as isize + 1),\n-                  self.ptr.offset(index as isize),\n-                  self.len - index);\n-        result\n-    }\n-}\n-```"}, {"sha": "f2f5995ec1cbfaba6f62aebb004a228dee0a3ecb", "filename": "src/doc/nomicon/src/vec-into-iter.md", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-into-iter.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-into-iter.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-into-iter.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,147 +0,0 @@\n-# IntoIter\n-\n-Let's move on to writing iterators. `iter` and `iter_mut` have already been\n-written for us thanks to The Magic of Deref. However there's two interesting\n-iterators that Vec provides that slices can't: `into_iter` and `drain`.\n-\n-IntoIter consumes the Vec by-value, and can consequently yield its elements\n-by-value. In order to enable this, IntoIter needs to take control of Vec's\n-allocation.\n-\n-IntoIter needs to be DoubleEnded as well, to enable reading from both ends.\n-Reading from the back could just be implemented as calling `pop`, but reading\n-from the front is harder. We could call `remove(0)` but that would be insanely\n-expensive. Instead we're going to just use ptr::read to copy values out of\n-either end of the Vec without mutating the buffer at all.\n-\n-To do this we're going to use a very common C idiom for array iteration. We'll\n-make two pointers; one that points to the start of the array, and one that\n-points to one-element past the end. When we want an element from one end, we'll\n-read out the value pointed to at that end and move the pointer over by one. When\n-the two pointers are equal, we know we're done.\n-\n-Note that the order of read and offset are reversed for `next` and `next_back`\n-For `next_back` the pointer is always after the element it wants to read next,\n-while for `next` the pointer is always at the element it wants to read next.\n-To see why this is, consider the case where every element but one has been\n-yielded.\n-\n-The array looks like this:\n-\n-```text\n-          S  E\n-[X, X, X, O, X, X, X]\n-```\n-\n-If E pointed directly at the element it wanted to yield next, it would be\n-indistinguishable from the case where there are no more elements to yield.\n-\n-Although we don't actually care about it during iteration, we also need to hold\n-onto the Vec's allocation information in order to free it once IntoIter is\n-dropped.\n-\n-So we're going to use the following struct:\n-\n-```rust,ignore\n-struct IntoIter<T> {\n-    buf: Unique<T>,\n-    cap: usize,\n-    start: *const T,\n-    end: *const T,\n-}\n-```\n-\n-And this is what we end up with for initialization:\n-\n-```rust,ignore\n-impl<T> Vec<T> {\n-    fn into_iter(self) -> IntoIter<T> {\n-        // Can't destructure Vec since it's Drop\n-        let ptr = self.ptr;\n-        let cap = self.cap;\n-        let len = self.len;\n-\n-        // Make sure not to drop Vec since that will free the buffer\n-        mem::forget(self);\n-\n-        unsafe {\n-            IntoIter {\n-                buf: ptr,\n-                cap: cap,\n-                start: *ptr,\n-                end: if cap == 0 {\n-                    // can't offset off this pointer, it's not allocated!\n-                    *ptr\n-                } else {\n-                    ptr.offset(len as isize)\n-                }\n-            }\n-        }\n-    }\n-}\n-```\n-\n-Here's iterating forward:\n-\n-```rust,ignore\n-impl<T> Iterator for IntoIter<T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> {\n-        if self.start == self.end {\n-            None\n-        } else {\n-            unsafe {\n-                let result = ptr::read(self.start);\n-                self.start = self.start.offset(1);\n-                Some(result)\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = (self.end as usize - self.start as usize)\n-                  / mem::size_of::<T>();\n-        (len, Some(len))\n-    }\n-}\n-```\n-\n-And here's iterating backwards.\n-\n-```rust,ignore\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.start == self.end {\n-            None\n-        } else {\n-            unsafe {\n-                self.end = self.end.offset(-1);\n-                Some(ptr::read(self.end))\n-            }\n-        }\n-    }\n-}\n-```\n-\n-Because IntoIter takes ownership of its allocation, it needs to implement Drop\n-to free it. However it also wants to implement Drop to drop any elements it\n-contains that weren't yielded.\n-\n-\n-```rust,ignore\n-impl<T> Drop for IntoIter<T> {\n-    fn drop(&mut self) {\n-        if self.cap != 0 {\n-            // drop any remaining elements\n-            for _ in &mut *self {}\n-\n-            let align = mem::align_of::<T>();\n-            let elem_size = mem::size_of::<T>();\n-            let num_bytes = elem_size * self.cap;\n-            unsafe {\n-                heap::deallocate(*self.buf as *mut _, num_bytes, align);\n-            }\n-        }\n-    }\n-}\n-```"}, {"sha": "1dc09aef6ad282d4c0e29516f8c20cfa2300b724", "filename": "src/doc/nomicon/src/vec-layout.md", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-layout.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-layout.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-layout.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,100 +0,0 @@\n-# Layout\n-\n-First off, we need to come up with the struct layout. A Vec has three parts:\n-a pointer to the allocation, the size of the allocation, and the number of\n-elements that have been initialized.\n-\n-Naively, this means we just want this design:\n-\n-```rust\n-pub struct Vec<T> {\n-    ptr: *mut T,\n-    cap: usize,\n-    len: usize,\n-}\n-# fn main() {}\n-```\n-\n-And indeed this would compile. Unfortunately, it would be incorrect. First, the\n-compiler will give us too strict variance. So a `&Vec<&'static str>`\n-couldn't be used where an `&Vec<&'a str>` was expected. More importantly, it\n-will give incorrect ownership information to the drop checker, as it will\n-conservatively assume we don't own any values of type `T`. See [the chapter\n-on ownership and lifetimes][ownership] for all the details on variance and\n-drop check.\n-\n-As we saw in the ownership chapter, we should use `Unique<T>` in place of\n-`*mut T` when we have a raw pointer to an allocation we own. Unique is unstable,\n-so we'd like to not use it if possible, though.\n-\n-As a recap, Unique is a wrapper around a raw pointer that declares that:\n-\n-* We are variant over `T`\n-* We may own a value of type `T` (for drop check)\n-* We are Send/Sync if `T` is Send/Sync\n-* We deref to `*mut T` (so it largely acts like a `*mut` in our code)\n-* Our pointer is never null (so `Option<Vec<T>>` is null-pointer-optimized)\n-\n-We can implement all of the above requirements except for the last\n-one in stable Rust:\n-\n-```rust\n-use std::marker::PhantomData;\n-use std::ops::Deref;\n-use std::mem;\n-\n-struct Unique<T> {\n-    ptr: *const T,              // *const for variance\n-    _marker: PhantomData<T>,    // For the drop checker\n-}\n-\n-// Deriving Send and Sync is safe because we are the Unique owners\n-// of this data. It's like Unique<T> is \"just\" T.\n-unsafe impl<T: Send> Send for Unique<T> {}\n-unsafe impl<T: Sync> Sync for Unique<T> {}\n-\n-impl<T> Unique<T> {\n-    pub fn new(ptr: *mut T) -> Self {\n-        Unique { ptr: ptr, _marker: PhantomData }\n-    }\n-}\n-\n-impl<T> Deref for Unique<T> {\n-    type Target = *mut T;\n-    fn deref(&self) -> &*mut T {\n-        // There's no way to cast the *const to a *mut\n-        // while also taking a reference. So we just\n-        // transmute it since it's all \"just pointers\".\n-        unsafe { mem::transmute(&self.ptr) }\n-    }\n-}\n-# fn main() {}\n-```\n-\n-Unfortunately the mechanism for stating that your value is non-zero is\n-unstable and unlikely to be stabilized soon. As such we're just going to\n-take the hit and use std's Unique:\n-\n-\n-```rust\n-#![feature(unique)]\n-\n-use std::ptr::{Unique, self};\n-\n-pub struct Vec<T> {\n-    ptr: Unique<T>,\n-    cap: usize,\n-    len: usize,\n-}\n-\n-# fn main() {}\n-```\n-\n-If you don't care about the null-pointer optimization, then you can use the\n-stable code. However we will be designing the rest of the code around enabling\n-the optimization. In particular, `Unique::new` is unsafe to call, because\n-putting `null` inside of it is Undefined Behavior. Our stable Unique doesn't\n-need `new` to be unsafe because it doesn't make any interesting guarantees about\n-its contents.\n-\n-[ownership]: ownership.html"}, {"sha": "d31a74cc308d95d6b49fef3f22b7d186a94f4ed6", "filename": "src/doc/nomicon/src/vec-push-pop.md", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-push-pop.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-push-pop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-push-pop.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,55 +0,0 @@\n-# Push and Pop\n-\n-Alright. We can initialize. We can allocate. Let's actually implement some\n-functionality! Let's start with `push`. All it needs to do is check if we're\n-full to grow, unconditionally write to the next index, and then increment our\n-length.\n-\n-To do the write we have to be careful not to evaluate the memory we want to write\n-to. At worst, it's truly uninitialized memory from the allocator. At best it's the\n-bits of some old value we popped off. Either way, we can't just index to the memory\n-and dereference it, because that will evaluate the memory as a valid instance of\n-T. Worse, `foo[idx] = x` will try to call `drop` on the old value of `foo[idx]`!\n-\n-The correct way to do this is with `ptr::write`, which just blindly overwrites the\n-target address with the bits of the value we provide. No evaluation involved.\n-\n-For `push`, if the old len (before push was called) is 0, then we want to write\n-to the 0th index. So we should offset by the old len.\n-\n-```rust,ignore\n-pub fn push(&mut self, elem: T) {\n-    if self.len == self.cap { self.grow(); }\n-\n-    unsafe {\n-        ptr::write(self.ptr.offset(self.len as isize), elem);\n-    }\n-\n-    // Can't fail, we'll OOM first.\n-    self.len += 1;\n-}\n-```\n-\n-Easy! How about `pop`? Although this time the index we want to access is\n-initialized, Rust won't just let us dereference the location of memory to move\n-the value out, because that would leave the memory uninitialized! For this we\n-need `ptr::read`, which just copies out the bits from the target address and\n-interprets it as a value of type T. This will leave the memory at this address\n-logically uninitialized, even though there is in fact a perfectly good instance\n-of T there.\n-\n-For `pop`, if the old len is 1, we want to read out of the 0th index. So we\n-should offset by the new len.\n-\n-```rust,ignore\n-pub fn pop(&mut self) -> Option<T> {\n-    if self.len == 0 {\n-        None\n-    } else {\n-        self.len -= 1;\n-        unsafe {\n-            Some(ptr::read(self.ptr.offset(self.len as isize)))\n-        }\n-    }\n-}\n-```"}, {"sha": "20fa8ab92c24c7c2c32abada6bc5a6f4a048e730", "filename": "src/doc/nomicon/src/vec-raw.md", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-raw.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-raw.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-raw.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,136 +0,0 @@\n-# RawVec\n-\n-We've actually reached an interesting situation here: we've duplicated the logic\n-for specifying a buffer and freeing its memory in Vec and IntoIter. Now that\n-we've implemented it and identified *actual* logic duplication, this is a good\n-time to perform some logic compression.\n-\n-We're going to abstract out the `(ptr, cap)` pair and give them the logic for\n-allocating, growing, and freeing:\n-\n-```rust,ignore\n-struct RawVec<T> {\n-    ptr: Unique<T>,\n-    cap: usize,\n-}\n-\n-impl<T> RawVec<T> {\n-    fn new() -> Self {\n-        assert!(mem::size_of::<T>() != 0, \"TODO: implement ZST support\");\n-        unsafe {\n-            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: 0 }\n-        }\n-    }\n-\n-    // unchanged from Vec\n-    fn grow(&mut self) {\n-        unsafe {\n-            let align = mem::align_of::<T>();\n-            let elem_size = mem::size_of::<T>();\n-\n-            let (new_cap, ptr) = if self.cap == 0 {\n-                let ptr = heap::allocate(elem_size, align);\n-                (1, ptr)\n-            } else {\n-                let new_cap = 2 * self.cap;\n-                let ptr = heap::reallocate(*self.ptr as *mut _,\n-                                            self.cap * elem_size,\n-                                            new_cap * elem_size,\n-                                            align);\n-                (new_cap, ptr)\n-            };\n-\n-            // If allocate or reallocate fail, we'll get `null` back\n-            if ptr.is_null() { oom() }\n-\n-            self.ptr = Unique::new(ptr as *mut _);\n-            self.cap = new_cap;\n-        }\n-    }\n-}\n-\n-\n-impl<T> Drop for RawVec<T> {\n-    fn drop(&mut self) {\n-        if self.cap != 0 {\n-            let align = mem::align_of::<T>();\n-            let elem_size = mem::size_of::<T>();\n-            let num_bytes = elem_size * self.cap;\n-            unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n-            }\n-        }\n-    }\n-}\n-```\n-\n-And change Vec as follows:\n-\n-```rust,ignore\n-pub struct Vec<T> {\n-    buf: RawVec<T>,\n-    len: usize,\n-}\n-\n-impl<T> Vec<T> {\n-    fn ptr(&self) -> *mut T { *self.buf.ptr }\n-\n-    fn cap(&self) -> usize { self.buf.cap }\n-\n-    pub fn new() -> Self {\n-        Vec { buf: RawVec::new(), len: 0 }\n-    }\n-\n-    // push/pop/insert/remove largely unchanged:\n-    // * `self.ptr -> self.ptr()`\n-    // * `self.cap -> self.cap()`\n-    // * `self.grow -> self.buf.grow()`\n-}\n-\n-impl<T> Drop for Vec<T> {\n-    fn drop(&mut self) {\n-        while let Some(_) = self.pop() {}\n-        // deallocation is handled by RawVec\n-    }\n-}\n-```\n-\n-And finally we can really simplify IntoIter:\n-\n-```rust,ignore\n-struct IntoIter<T> {\n-    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n-    start: *const T,\n-    end: *const T,\n-}\n-\n-// next and next_back literally unchanged since they never referred to the buf\n-\n-impl<T> Drop for IntoIter<T> {\n-    fn drop(&mut self) {\n-        // only need to ensure all our elements are read;\n-        // buffer will clean itself up afterwards.\n-        for _ in &mut *self {}\n-    }\n-}\n-\n-impl<T> Vec<T> {\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        unsafe {\n-            // need to use ptr::read to unsafely move the buf out since it's\n-            // not Copy, and Vec implements Drop (so we can't destructure it).\n-            let buf = ptr::read(&self.buf);\n-            let len = self.len;\n-            mem::forget(self);\n-\n-            IntoIter {\n-                start: *buf.ptr,\n-                end: buf.ptr.offset(len as isize),\n-                _buf: buf,\n-            }\n-        }\n-    }\n-}\n-```\n-\n-Much better."}, {"sha": "5ae9bdd3274733102d2aff965fc38403c9beab22", "filename": "src/doc/nomicon/src/vec-zsts.md", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-zsts.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-zsts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec-zsts.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,176 +0,0 @@\n-# Handling Zero-Sized Types\n-\n-It's time. We're going to fight the specter that is zero-sized types. Safe Rust\n-*never* needs to care about this, but Vec is very intensive on raw pointers and\n-raw allocations, which are exactly the two things that care about\n-zero-sized types. We need to be careful of two things:\n-\n-* The raw allocator API has undefined behavior if you pass in 0 for an\n-  allocation size.\n-* raw pointer offsets are no-ops for zero-sized types, which will break our\n-  C-style pointer iterator.\n-\n-Thankfully we abstracted out pointer-iterators and allocating handling into\n-RawValIter and RawVec respectively. How mysteriously convenient.\n-\n-\n-\n-\n-## Allocating Zero-Sized Types\n-\n-So if the allocator API doesn't support zero-sized allocations, what on earth\n-do we store as our allocation? Why, `heap::EMPTY` of course! Almost every operation\n-with a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs\n-to be considered to store or load them. This actually extends to `ptr::read` and\n-`ptr::write`: they won't actually look at the pointer at all. As such we never need\n-to change the pointer.\n-\n-Note however that our previous reliance on running out of memory before overflow is\n-no longer valid with zero-sized types. We must explicitly guard against capacity\n-overflow for zero-sized types.\n-\n-Due to our current architecture, all this means is writing 3 guards, one in each\n-method of RawVec.\n-\n-```rust,ignore\n-impl<T> RawVec<T> {\n-    fn new() -> Self {\n-        unsafe {\n-            // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n-\n-            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n-            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: cap }\n-        }\n-    }\n-\n-    fn grow(&mut self) {\n-        unsafe {\n-            let elem_size = mem::size_of::<T>();\n-\n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the Vec is overfull.\n-            assert!(elem_size != 0, \"capacity overflow\");\n-\n-            let align = mem::align_of::<T>();\n-\n-            let (new_cap, ptr) = if self.cap == 0 {\n-                let ptr = heap::allocate(elem_size, align);\n-                (1, ptr)\n-            } else {\n-                let new_cap = 2 * self.cap;\n-                let ptr = heap::reallocate(*self.ptr as *mut _,\n-                                            self.cap * elem_size,\n-                                            new_cap * elem_size,\n-                                            align);\n-                (new_cap, ptr)\n-            };\n-\n-            // If allocate or reallocate fail, we'll get `null` back\n-            if ptr.is_null() { oom() }\n-\n-            self.ptr = Unique::new(ptr as *mut _);\n-            self.cap = new_cap;\n-        }\n-    }\n-}\n-\n-impl<T> Drop for RawVec<T> {\n-    fn drop(&mut self) {\n-        let elem_size = mem::size_of::<T>();\n-\n-        // don't free zero-sized allocations, as they were never allocated.\n-        if self.cap != 0 && elem_size != 0 {\n-            let align = mem::align_of::<T>();\n-\n-            let num_bytes = elem_size * self.cap;\n-            unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n-            }\n-        }\n-    }\n-}\n-```\n-\n-That's it. We support pushing and popping zero-sized types now. Our iterators\n-(that aren't provided by slice Deref) are still busted, though.\n-\n-\n-\n-\n-## Iterating Zero-Sized Types\n-\n-Zero-sized offsets are no-ops. This means that our current design will always\n-initialize `start` and `end` as the same value, and our iterators will yield\n-nothing. The current solution to this is to cast the pointers to integers,\n-increment, and then cast them back:\n-\n-```rust,ignore\n-impl<T> RawValIter<T> {\n-    unsafe fn new(slice: &[T]) -> Self {\n-        RawValIter {\n-            start: slice.as_ptr(),\n-            end: if mem::size_of::<T>() == 0 {\n-                ((slice.as_ptr() as usize) + slice.len()) as *const _\n-            } else if slice.len() == 0 {\n-                slice.as_ptr()\n-            } else {\n-                slice.as_ptr().offset(slice.len() as isize)\n-            }\n-        }\n-    }\n-}\n-```\n-\n-Now we have a different bug. Instead of our iterators not running at all, our\n-iterators now run *forever*. We need to do the same trick in our iterator impls.\n-Also, our size_hint computation code will divide by 0 for ZSTs. Since we'll\n-basically be treating the two pointers as if they point to bytes, we'll just\n-map size 0 to divide by 1.\n-\n-```rust,ignore\n-impl<T> Iterator for RawValIter<T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> {\n-        if self.start == self.end {\n-            None\n-        } else {\n-            unsafe {\n-                let result = ptr::read(self.start);\n-                self.start = if mem::size_of::<T>() == 0 {\n-                    (self.start as usize + 1) as *const _\n-                } else {\n-                    self.start.offset(1)\n-                };\n-                Some(result)\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let elem_size = mem::size_of::<T>();\n-        let len = (self.end as usize - self.start as usize)\n-                  / if elem_size == 0 { 1 } else { elem_size };\n-        (len, Some(len))\n-    }\n-}\n-\n-impl<T> DoubleEndedIterator for RawValIter<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.start == self.end {\n-            None\n-        } else {\n-            unsafe {\n-                self.end = if mem::size_of::<T>() == 0 {\n-                    (self.end as usize - 1) as *const _\n-                } else {\n-                    self.end.offset(-1)\n-                };\n-                Some(ptr::read(self.end))\n-            }\n-        }\n-    }\n-}\n-```\n-\n-And that's it. Iteration works!"}, {"sha": "ad98e45f197b351b461462e20a5a0bdbc920f087", "filename": "src/doc/nomicon/src/vec.md", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fvec.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,20 +0,0 @@\n-# Example: Implementing Vec\n-\n-To bring everything together, we're going to write `std::Vec` from scratch.\n-Because all the best tools for writing unsafe code are unstable, this\n-project will only work on nightly (as of Rust 1.9.0). With the exception of the\n-allocator API, much of the unstable code we'll use is expected to be stabilized\n-in a similar form as it is today.\n-\n-However we will generally try to avoid unstable code where possible. In\n-particular we won't use any intrinsics that could make a code a little\n-bit nicer or efficient because intrinsics are permanently unstable. Although\n-many intrinsics *do* become stabilized elsewhere (`std::ptr` and `str::mem`\n-consist of many intrinsics).\n-\n-Ultimately this means our implementation may not take advantage of all\n-possible optimizations, though it will be by no means *naive*. We will\n-definitely get into the weeds over nitty-gritty details, even\n-when the problem doesn't *really* merit it.\n-\n-You wanted advanced. We're gonna go advanced."}, {"sha": "5724f3d09a3024277c68e211ebf8e338c400c625", "filename": "src/doc/nomicon/src/working-with-unsafe.md", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fworking-with-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c9208faf1f180cd15cf93f74f1e57b24856d11e/src%2Fdoc%2Fnomicon%2Fsrc%2Fworking-with-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fworking-with-unsafe.md?ref=5c9208faf1f180cd15cf93f74f1e57b24856d11e", "patch": "@@ -1,119 +0,0 @@\n-# Working with Unsafe\n-\n-Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and\n-binary manner. Unfortunately, reality is significantly more complicated than\n-that. For instance, consider the following toy function:\n-\n-```rust\n-fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n-    if idx < arr.len() {\n-        unsafe {\n-            Some(*arr.get_unchecked(idx))\n-        }\n-    } else {\n-        None\n-    }\n-}\n-```\n-\n-Clearly, this function is safe. We check that the index is in bounds, and if it\n-is, index into the array in an unchecked manner. But even in such a trivial\n-function, the scope of the unsafe block is questionable. Consider changing the\n-`<` to a `<=`:\n-\n-```rust\n-fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n-    if idx <= arr.len() {\n-        unsafe {\n-            Some(*arr.get_unchecked(idx))\n-        }\n-    } else {\n-        None\n-    }\n-}\n-```\n-\n-This program is now unsound, and yet *we only modified safe code*. This is the\n-fundamental problem of safety: it's non-local. The soundness of our unsafe\n-operations necessarily depends on the state established by otherwise\n-\"safe\" operations.\n-\n-Safety is modular in the sense that opting into unsafety doesn't require you\n-to consider arbitrary other kinds of badness. For instance, doing an unchecked\n-index into a slice doesn't mean you suddenly need to worry about the slice being\n-null or containing uninitialized memory. Nothing fundamentally changes. However\n-safety *isn't* modular in the sense that programs are inherently stateful and\n-your unsafe operations may depend on arbitrary other state.\n-\n-Trickier than that is when we get into actual statefulness. Consider a simple\n-implementation of `Vec`:\n-\n-```rust\n-use std::ptr;\n-\n-// Note this definition is insufficient. See the section on implementing Vec.\n-pub struct Vec<T> {\n-    ptr: *mut T,\n-    len: usize,\n-    cap: usize,\n-}\n-\n-// Note this implementation does not correctly handle zero-sized types.\n-// We currently live in a nice imaginary world of only positive fixed-size\n-// types.\n-impl<T> Vec<T> {\n-    pub fn push(&mut self, elem: T) {\n-        if self.len == self.cap {\n-            // not important for this example\n-            self.reallocate();\n-        }\n-        unsafe {\n-            ptr::write(self.ptr.offset(self.len as isize), elem);\n-            self.len += 1;\n-        }\n-    }\n-\n-    # fn reallocate(&mut self) { }\n-}\n-\n-# fn main() {}\n-```\n-\n-This code is simple enough to reasonably audit and verify. Now consider\n-adding the following method:\n-\n-```rust,ignore\n-fn make_room(&mut self) {\n-    // grow the capacity\n-    self.cap += 1;\n-}\n-```\n-\n-This code is 100% Safe Rust but it is also completely unsound. Changing the\n-capacity violates the invariants of Vec (that `cap` reflects the allocated space\n-in the Vec). This is not something the rest of Vec can guard against. It *has*\n-to trust the capacity field because there's no way to verify it.\n-\n-`unsafe` does more than pollute a whole function: it pollutes a whole *module*.\n-Generally, the only bullet-proof way to limit the scope of unsafe code is at the\n-module boundary with privacy.\n-\n-However this works *perfectly*. The existence of `make_room` is *not* a\n-problem for the soundness of Vec because we didn't mark it as public. Only the\n-module that defines this function can call it. Also, `make_room` directly\n-accesses the private fields of Vec, so it can only be written in the same module\n-as Vec.\n-\n-It is therefore possible for us to write a completely safe abstraction that\n-relies on complex invariants. This is *critical* to the relationship between\n-Safe Rust and Unsafe Rust. We have already seen that Unsafe code must trust\n-*some* Safe code, but can't trust *generic* Safe code. It can't trust an\n-arbitrary implementor of a trait or any function that was passed to it to be\n-well-behaved in a way that safe code doesn't care about.\n-\n-However if unsafe code couldn't prevent client safe code from messing with its\n-state in arbitrary ways, safety would be a lost cause. Thankfully, it *can*\n-prevent arbitrary code from messing with critical state due to privacy.\n-\n-Safety lives!\n-"}, {"sha": "e27c45773441a7a7e114eba1460fdf50fefafd0f", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -1646,6 +1646,10 @@ impl str {\n     /// 'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n     /// `Lowercase`.\n     ///\n+    /// Since some characters can expand into multiple characters when changing\n+    /// the case, this function returns a [`String`] instead of modifying the\n+    /// parameter in-place.\n+    ///\n     /// [`String`]: string/struct.String.html\n     ///\n     /// # Examples\n@@ -1718,6 +1722,10 @@ impl str {\n     /// 'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n     /// `Uppercase`.\n     ///\n+    /// Since some characters can expand into multiple characters when changing\n+    /// the case, this function returns a [`String`] instead of modifying the\n+    /// parameter in-place.\n+    ///\n     /// [`String`]: string/struct.String.html\n     ///\n     /// # Examples"}, {"sha": "43323676ab459b4f39a1233218f6dcc3c63f58dd", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -433,6 +433,10 @@ impl String {\n     ///\n     /// [`str::from_utf8()`]: ../../std/str/fn.from_utf8.html\n     ///\n+    /// The inverse of this method is [`as_bytes`].\n+    ///\n+    /// [`as_bytes`]: #method.as_bytes\n+    ///\n     /// # Errors\n     ///\n     /// Returns `Err` if the slice is not UTF-8 with a description as to why the\n@@ -979,6 +983,10 @@ impl String {\n \n     /// Returns a byte slice of this `String`'s contents.\n     ///\n+    /// The inverse of this method is [`from_utf8`].\n+    ///\n+    /// [`from_utf8`]: #method.from_utf8\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}, {"sha": "d38c9f6e1cf805f3a82b250e6afeb23e5e4f1f27", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -1335,6 +1335,27 @@ impl<T: PartialEq> Vec<T> {\n     pub fn dedup(&mut self) {\n         self.dedup_by(|a, b| a == b)\n     }\n+\n+    /// Removes the first instance of `item` from the vector if the item exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    ///# #![feature(vec_remove_item)]\n+    /// let mut vec = vec![1, 2, 3, 1];\n+    ///\n+    /// vec.remove_item(&1);\n+    ///\n+    /// assert_eq!(vec, vec![2, 3, 1]);\n+    /// ```\n+    #[unstable(feature = \"vec_remove_item\", reason = \"recently added\", issue = \"40062\")]\n+    pub fn remove_item(&mut self, item: &T) -> Option<T> {\n+        let pos = match self.iter().position(|x| *x == *item) {\n+            Some(x) => x,\n+            None => return None,\n+        };\n+        Some(self.remove(pos))\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "fb42b915c7694a542957d62ea0575f4d38e3c372", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -402,15 +402,16 @@ pub mod reimpls {\n     }\n \n     trait AbsExt: Sized {\n-        fn uabs(self) -> u128 {\n-            self.iabs() as u128\n-        }\n+        fn uabs(self) -> u128;\n         fn iabs(self) -> i128;\n     }\n \n     impl AbsExt for i128 {\n+        fn uabs(self) -> u128 {\n+            self.iabs() as u128\n+        }\n         fn iabs(self) -> i128 {\n-            let s = self >> 127;\n+            let s = self.wrapping_shr(127);\n             ((self ^ s).wrapping_sub(s))\n         }\n     }"}, {"sha": "b22f7fa17077b7890940b0ac82ba331d685d3e7f", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -32,11 +32,11 @@ macro_rules! panic {\n \n /// Ensure that a boolean expression is `true` at runtime.\n ///\n-/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// This will invoke the [`panic!`] macro if the provided expression cannot be\n /// evaluated to `true` at runtime.\n ///\n /// Assertions are always checked in both debug and release builds, and cannot\n-/// be disabled. See `debug_assert!` for assertions that are not enabled in\n+/// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n /// release builds by default.\n ///\n /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n@@ -48,6 +48,8 @@ macro_rules! panic {\n /// This macro has a second version, where a custom panic message can\n /// be provided with or without arguments for formatting.\n ///\n+/// [`panic!`]: macro.panic.html\n+/// [`debug_assert!`]: macro.debug_assert.html\n /// [testing]: ../book/testing.html\n ///\n /// # Examples\n@@ -88,9 +90,11 @@ macro_rules! assert {\n /// On panic, this macro will print the values of the expressions with their\n /// debug representations.\n ///\n-/// Like `assert!()`, this macro has a second version, where a custom\n+/// Like [`assert!()`], this macro has a second version, where a custom\n /// panic message can be provided.\n ///\n+/// [`assert!()`]: macro.assert.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -134,6 +138,8 @@ macro_rules! assert_eq {\n /// Like `assert!()`, this macro has a second version, where a custom\n /// panic message can be provided.\n ///\n+/// [`assert!`]: macro.assert.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -171,13 +177,13 @@ macro_rules! assert_ne {\n \n /// Ensure that a boolean expression is `true` at runtime.\n ///\n-/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// This will invoke the [`panic!`] macro if the provided expression cannot be\n /// evaluated to `true` at runtime.\n ///\n-/// Like `assert!`, this macro also has a second version, where a custom panic\n+/// Like [`assert!`], this macro also has a second version, where a custom panic\n /// message can be provided.\n ///\n-/// Unlike `assert!`, `debug_assert!` statements are only enabled in non\n+/// Unlike [`assert!`], `debug_assert!` statements are only enabled in non\n /// optimized builds by default. An optimized build will omit all\n /// `debug_assert!` statements unless `-C debug-assertions` is passed to the\n /// compiler. This makes `debug_assert!` useful for checks that are too\n@@ -187,10 +193,13 @@ macro_rules! assert_ne {\n /// An unchecked assertion allows a program in an inconsistent state to keep\n /// running, which might have unexpected consequences but does not introduce\n /// unsafety as long as this only happens in safe code. The performance cost\n-/// of assertions, is however, not measurable in general. Replacing `assert!`\n+/// of assertions, is however, not measurable in general. Replacing [`assert!`]\n /// with `debug_assert!` is thus only encouraged after thorough profiling, and\n /// more importantly, only in safe code!\n ///\n+/// [`panic!`]: macro.panic.html\n+/// [`assert!`]: macro.assert.html\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "260fdab9d58fb5205faa1d1f6aa226c7f5c629cf", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -191,6 +191,10 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// allocations or resources, so care must be taken not to overwrite an object\n /// that should be dropped.\n ///\n+/// It does not immediately drop the contents of `src` either; it is rather\n+/// *moved* into the memory location `dst` and will be dropped whenever that\n+/// location goes out of scope.\n+///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n ///"}, {"sha": "be04b0e6577f054033e650bf15cf209008f25a77", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -1286,7 +1286,7 @@ pub struct Destructor {\n     /// invoked even when there are lifetimes in the type-structure of\n     /// `adt` that do not strictly outlive the adt value itself.\n     /// (This allows programs to make cyclic structures without\n-    /// resorting to unasfe means; see RFCs 769 and 1238).\n+    /// resorting to unsafe means; see RFCs 769 and 1238).\n     pub is_dtorck: bool,\n }\n "}, {"sha": "2b9ccf6d3e246c666e0eabf9c9d812638324313f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 54, "deletions": 85, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -1935,10 +1935,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // We must collect the defaults *before* we do any unification. Because we have\n             // directly attached defaults to the type variables any unification that occurs\n             // will erase defaults causing conflicting defaults to be completely ignored.\n-            let default_map: FxHashMap<_, _> =\n+            let default_map: FxHashMap<Ty<'tcx>, _> =\n                 unsolved_variables\n                     .iter()\n-                    .filter_map(|t| self.default(t).map(|d| (t, d)))\n+                    .filter_map(|t| self.default(t).map(|d| (*t, d)))\n                     .collect();\n \n             let mut unbound_tyvars = FxHashSet();\n@@ -2007,37 +2007,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // we will rollback the inference context to its prior state so we can probe\n             // for conflicts and correctly report them.\n \n-\n             let _ = self.commit_if_ok(|_: &infer::CombinedSnapshot| {\n-                for ty in &unbound_tyvars {\n-                    if self.type_var_diverges(ty) {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n-                                           self.tcx.mk_diverging_default());\n-                    } else {\n-                        match self.type_is_unconstrained_numeric(ty) {\n-                            UnconstrainedInt => {\n-                                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n-                            },\n-                            UnconstrainedFloat => {\n-                                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n-                            }\n-                            Neither => {\n-                                if let Some(default) = default_map.get(ty) {\n-                                    let default = default.clone();\n-                                    let default_ty = self.normalize_associated_types_in(\n-                                        default.origin_span, &default.ty);\n-                                    match self.eq_types(false,\n-                                                        &self.misc(default.origin_span),\n-                                                        ty,\n-                                                        default_ty) {\n-                                        Ok(ok) => self.register_infer_ok_obligations(ok),\n-                                        Err(_) => conflicts.push((*ty, default)),\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+                conflicts.extend(\n+                    self.apply_defaults_and_return_conflicts(&unbound_tyvars, &default_map, None)\n+                );\n \n                 // If there are conflicts we rollback, otherwise commit\n                 if conflicts.len() > 0 {\n@@ -2047,37 +2020,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             });\n \n-            if conflicts.len() > 0 {\n-                // Loop through each conflicting default, figuring out the default that caused\n-                // a unification failure and then report an error for each.\n-                for (conflict, default) in conflicts {\n-                    let conflicting_default =\n-                        self.find_conflicting_default(&unbound_tyvars, &default_map, conflict)\n-                            .unwrap_or(type_variable::Default {\n-                                ty: self.next_ty_var(\n-                                    TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n-                                origin_span: syntax_pos::DUMMY_SP,\n-                                // what do I put here?\n-                                def_id: self.tcx.hir.local_def_id(ast::CRATE_NODE_ID)\n-                            });\n-\n-                    // This is to ensure that we elimnate any non-determinism from the error\n-                    // reporting by fixing an order, it doesn't matter what order we choose\n-                    // just that it is consistent.\n-                    let (first_default, second_default) =\n-                        if default.def_id < conflicting_default.def_id {\n-                            (default, conflicting_default)\n-                        } else {\n-                            (conflicting_default, default)\n-                        };\n+            // Loop through each conflicting default, figuring out the default that caused\n+            // a unification failure and then report an error for each.\n+            for (conflict, default) in conflicts {\n+                let conflicting_default =\n+                    self.apply_defaults_and_return_conflicts(\n+                            &unbound_tyvars,\n+                            &default_map,\n+                            Some(conflict)\n+                        )\n+                        .last()\n+                        .map(|(_, tv)| tv)\n+                        .unwrap_or(type_variable::Default {\n+                            ty: self.next_ty_var(\n+                                TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n+                            origin_span: syntax_pos::DUMMY_SP,\n+                            // what do I put here?\n+                            def_id: self.tcx.hir.local_def_id(ast::CRATE_NODE_ID)\n+                        });\n+\n+                // This is to ensure that we elimnate any non-determinism from the error\n+                // reporting by fixing an order, it doesn't matter what order we choose\n+                // just that it is consistent.\n+                let (first_default, second_default) =\n+                    if default.def_id < conflicting_default.def_id {\n+                        (default, conflicting_default)\n+                    } else {\n+                        (conflicting_default, default)\n+                    };\n \n \n-                    self.report_conflicting_default_types(\n-                        first_default.origin_span,\n-                        self.body_id,\n-                        first_default,\n-                        second_default)\n-                }\n+                self.report_conflicting_default_types(\n+                    first_default.origin_span,\n+                    self.body_id,\n+                    first_default,\n+                    second_default)\n             }\n         }\n \n@@ -2088,56 +2065,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // apply the default that caused conflict first to a local version of the type variable\n     // table then apply defaults until we find a conflict. That default must be the one\n     // that caused conflict earlier.\n-    fn find_conflicting_default(&self,\n-                                unbound_vars: &FxHashSet<Ty<'tcx>>,\n-                                default_map: &FxHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n-                                conflict: Ty<'tcx>)\n-                                -> Option<type_variable::Default<'tcx>> {\n+    fn apply_defaults_and_return_conflicts<'b>(\n+        &'b self,\n+        unbound_vars: &'b FxHashSet<Ty<'tcx>>,\n+        default_map: &'b FxHashMap<Ty<'tcx>, type_variable::Default<'tcx>>,\n+        conflict: Option<Ty<'tcx>>,\n+    ) -> impl Iterator<Item=(Ty<'tcx>, type_variable::Default<'tcx>)> + 'b {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n-        // Ensure that we apply the conflicting default first\n-        let mut unbound_tyvars = Vec::with_capacity(unbound_vars.len() + 1);\n-        unbound_tyvars.push(conflict);\n-        unbound_tyvars.extend(unbound_vars.iter());\n-\n-        let mut result = None;\n-        // We run the same code as above applying defaults in order, this time when\n-        // we find the conflict we just return it for error reporting above.\n-\n-        // We also run this inside snapshot that never commits so we can do error\n-        // reporting for more then one conflict.\n-        for ty in &unbound_tyvars {\n+        conflict.into_iter().chain(unbound_vars.iter().cloned()).flat_map(move |ty| {\n             if self.type_var_diverges(ty) {\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, ty,\n                                    self.tcx.mk_diverging_default());\n             } else {\n                 match self.type_is_unconstrained_numeric(ty) {\n                     UnconstrainedInt => {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, self.tcx.types.i32)\n                     },\n                     UnconstrainedFloat => {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, self.tcx.types.f64)\n                     },\n                     Neither => {\n                         if let Some(default) = default_map.get(ty) {\n                             let default = default.clone();\n+                            let default_ty = self.normalize_associated_types_in(\n+                                default.origin_span, &default.ty);\n                             match self.eq_types(false,\n                                                 &self.misc(default.origin_span),\n                                                 ty,\n-                                                default.ty) {\n+                                                default_ty) {\n                                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                                 Err(_) => {\n-                                    result = Some(default);\n+                                    return Some((ty, default));\n                                 }\n                             }\n                         }\n                     }\n                 }\n             }\n-        }\n \n-        return result;\n+            None\n+        })\n     }\n \n     fn select_all_obligations_or_error(&self) {"}, {"sha": "6bd9cf6620b0e4f40fe5214e303c620eba115a75", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -167,7 +167,11 @@ nav.sub {\n \tposition: absolute;\n \tleft: 0;\n \ttop: 0;\n-\tmin-height: 100%;\n+\tmin-height: 100vh;\n+}\n+\n+.sidebar .current {\n+\tmargin-right: -20px;\n }\n \n .content, nav { max-width: 960px; }\n@@ -185,11 +189,16 @@ nav.sub {\n }\n \n .sidebar .location {\n+\tborder: 1px solid;\n \tfont-size: 17px;\n \tmargin: 30px 0 20px 0;\n \ttext-align: center;\n }\n \n+.location:empty {\n+\tborder: none;\n+}\n+\n .location a:first-child { font-weight: 500; }\n \n .block {"}, {"sha": "f1e81900d1eecc356db4c2efca25fd89a6fe220a", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -37,8 +37,17 @@ pre {\n     background-color: #F5F5F5;\n }\n \n+.sidebar {\n+    background-color: #F1F1F1;\n+}\n+\n+.sidebar .current {\n+    background-color: #fff;\n+}\n+\n .sidebar .location {\n-    background: #e1e1e1;\n+    border-color: #000;\n+    background-color: #fff;\n     color: #333;\n }\n "}, {"sha": "c1ecc241b7b63d4d52aa9f9ca06cb8b9e40cd8ff", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -422,8 +422,11 @@ impl Collector {\n                     as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n                     line: usize, filename: String) {\n         let name = if self.use_headers {\n-            let s = self.current_header.as_ref().map(|s| &**s).unwrap_or(\"\");\n-            format!(\"{} - {} (line {})\", filename, s, line)\n+            if let Some(ref header) = self.current_header {\n+                format!(\"{} - {} (line {})\", filename, header, line)\n+            } else {\n+                format!(\"{} - (line {})\", filename, line)\n+            }\n         } else {\n             format!(\"{} - {} (line {})\", filename, self.names.join(\"::\"), line)\n         };"}, {"sha": "f9b0ec479d70115768328111f24537acbb979453", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -396,8 +396,6 @@ pub struct HashMap<K, V, S = RandomState> {\n     table: RawTable<K, V>,\n \n     resize_policy: DefaultResizePolicy,\n-\n-    long_probes: bool,\n }\n \n /// Search for a pre-hashed key.\n@@ -655,7 +653,6 @@ impl<K, V, S> HashMap<K, V, S>\n             hash_builder: hash_builder,\n             resize_policy: DefaultResizePolicy::new(),\n             table: RawTable::new(0),\n-            long_probes: false,\n         }\n     }\n \n@@ -688,7 +685,6 @@ impl<K, V, S> HashMap<K, V, S>\n             hash_builder: hash_builder,\n             resize_policy: resize_policy,\n             table: RawTable::new(raw_cap),\n-            long_probes: false,\n         }\n     }\n \n@@ -746,7 +742,7 @@ impl<K, V, S> HashMap<K, V, S>\n             let min_cap = self.len().checked_add(additional).expect(\"reserve overflow\");\n             let raw_cap = self.resize_policy.raw_capacity(min_cap);\n             self.resize(raw_cap);\n-        } else if self.long_probes && remaining <= self.len() {\n+        } else if self.table.tag() && remaining <= self.len() {\n             // Probe sequence is too long and table is half full,\n             // resize early to reduce probing length.\n             let new_capacity = self.table.capacity() * 2;\n@@ -763,7 +759,6 @@ impl<K, V, S> HashMap<K, V, S>\n         assert!(self.table.size() <= new_raw_cap);\n         assert!(new_raw_cap.is_power_of_two() || new_raw_cap == 0);\n \n-        self.long_probes = false;\n         let mut old_table = replace(&mut self.table, RawTable::new(new_raw_cap));\n         let old_size = old_table.size();\n \n@@ -844,8 +839,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// If the key already exists, the hashtable will be returned untouched\n     /// and a reference to the existing element will be returned.\n     fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> Option<V> {\n-        let entry = search_hashed(&mut self.table, hash, |key| *key == k)\n-            .into_entry(k, &mut self.long_probes);\n+        let entry = search_hashed(&mut self.table, hash, |key| *key == k).into_entry(k);\n         match entry {\n             Some(Occupied(mut elem)) => Some(elem.insert(v)),\n             Some(Vacant(elem)) => {\n@@ -1002,7 +996,7 @@ impl<K, V, S> HashMap<K, V, S>\n         self.reserve(1);\n         let hash = self.make_hash(&key);\n         search_hashed(&mut self.table, hash, |q| q.eq(&key))\n-            .into_entry(key, &mut self.long_probes).expect(\"unreachable\")\n+            .into_entry(key).expect(\"unreachable\")\n     }\n \n     /// Returns the number of elements in the map.\n@@ -1456,7 +1450,7 @@ impl<K, V, M> InternalEntry<K, V, M> {\n \n impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n     #[inline]\n-    fn into_entry(self, key: K, long_probes: &'a mut bool) -> Option<Entry<'a, K, V>> {\n+    fn into_entry(self, key: K) -> Option<Entry<'a, K, V>> {\n         match self {\n             InternalEntry::Occupied { elem } => {\n                 Some(Occupied(OccupiedEntry {\n@@ -1469,7 +1463,6 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n                     hash: hash,\n                     key: key,\n                     elem: elem,\n-                    long_probes: long_probes,\n                 }))\n             }\n             InternalEntry::TableIsEmpty => None,\n@@ -1542,7 +1535,6 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n-    long_probes: &'a mut bool,\n }\n \n #[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n@@ -2117,15 +2109,15 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n-            NeqElem(bucket, disp) => {\n+            NeqElem(mut bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n-                    *self.long_probes = true;\n+                    bucket.table_mut().set_tag(true);\n                 }\n                 robin_hood(bucket, disp, self.hash, self.key, value)\n             },\n-            NoElem(bucket, disp) => {\n+            NoElem(mut bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n-                    *self.long_probes = true;\n+                    bucket.table_mut().set_tag(true);\n                 }\n                 bucket.put(self.hash, self.key, value).into_mut_refs().1\n             },"}, {"sha": "0e225b2964f63752246b7a30d6fc26096b425e98", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -34,6 +34,42 @@ type HashUint = usize;\n \n const EMPTY_BUCKET: HashUint = 0;\n \n+/// Special `Unique<HashUint>` that uses the lower bit of the pointer\n+/// to expose a boolean tag.\n+/// Note: when the pointer is initialized to EMPTY `.ptr()` will return\n+/// null and the tag functions shouldn't be used.\n+struct TaggedHashUintPtr(Unique<HashUint>);\n+\n+impl TaggedHashUintPtr {\n+    #[inline]\n+    unsafe fn new(ptr: *mut HashUint) -> Self {\n+        debug_assert!(ptr as usize & 1 == 0 || ptr as usize == EMPTY as usize);\n+        TaggedHashUintPtr(Unique::new(ptr))\n+    }\n+\n+    #[inline]\n+    fn set_tag(&mut self, value: bool) {\n+        let usize_ptr = &*self.0 as *const *mut HashUint as *mut usize;\n+        unsafe {\n+            if value {\n+                *usize_ptr |= 1;\n+            } else {\n+                *usize_ptr &= !1;\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn tag(&self) -> bool {\n+        (*self.0 as usize) & 1 == 1\n+    }\n+\n+    #[inline]\n+    fn ptr(&self) -> *mut HashUint {\n+        (*self.0 as usize & !1) as *mut HashUint\n+    }\n+}\n+\n /// The raw hashtable, providing safe-ish access to the unzipped and highly\n /// optimized arrays of hashes, and key-value pairs.\n ///\n@@ -72,10 +108,14 @@ const EMPTY_BUCKET: HashUint = 0;\n /// around just the \"table\" part of the hashtable. It enforces some\n /// invariants at the type level and employs some performance trickery,\n /// but in general is just a tricked out `Vec<Option<(u64, K, V)>>`.\n+///\n+/// The hashtable also exposes a special boolean tag. The tag defaults to false\n+/// when the RawTable is created and is accessible with the `tag` and `set_tag`\n+/// functions.\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size: usize,\n-    hashes: Unique<HashUint>,\n+    hashes: TaggedHashUintPtr,\n \n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n@@ -208,6 +248,10 @@ impl<K, V, M> FullBucket<K, V, M> {\n     pub fn table(&self) -> &M {\n         &self.table\n     }\n+    /// Borrow a mutable reference to the table.\n+    pub fn table_mut(&mut self) -> &mut M {\n+        &mut self.table\n+    }\n     /// Move out the reference to the table.\n     pub fn into_table(self) -> M {\n         self.table\n@@ -227,6 +271,10 @@ impl<K, V, M> EmptyBucket<K, V, M> {\n     pub fn table(&self) -> &M {\n         &self.table\n     }\n+    /// Borrow a mutable reference to the table.\n+    pub fn table_mut(&mut self) -> &mut M {\n+        &mut self.table\n+    }\n }\n \n impl<K, V, M> Bucket<K, V, M> {\n@@ -687,7 +735,7 @@ impl<K, V> RawTable<K, V> {\n             return RawTable {\n                 size: 0,\n                 capacity: 0,\n-                hashes: Unique::new(EMPTY as *mut HashUint),\n+                hashes: TaggedHashUintPtr::new(EMPTY as *mut HashUint),\n                 marker: marker::PhantomData,\n             };\n         }\n@@ -728,7 +776,7 @@ impl<K, V> RawTable<K, V> {\n         RawTable {\n             capacity: capacity,\n             size: 0,\n-            hashes: Unique::new(hashes),\n+            hashes: TaggedHashUintPtr::new(hashes),\n             marker: marker::PhantomData,\n         }\n     }\n@@ -737,13 +785,13 @@ impl<K, V> RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<HashUint>();\n         let pairs_size = self.capacity * size_of::<(K, V)>();\n \n-        let buffer = *self.hashes as *mut u8;\n+        let buffer = self.hashes.ptr() as *mut u8;\n         let (pairs_offset, _, oflo) =\n             calculate_offsets(hashes_size, pairs_size, align_of::<(K, V)>());\n         debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n-                hash: *self.hashes,\n+                hash: self.hashes.ptr(),\n                 pair: buffer.offset(pairs_offset as isize) as *const _,\n                 _marker: marker::PhantomData,\n             }\n@@ -755,7 +803,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n-            ptr::write_bytes(*ret.hashes, 0, capacity);\n+            ptr::write_bytes(ret.hashes.ptr(), 0, capacity);\n             ret\n         }\n     }\n@@ -774,7 +822,7 @@ impl<K, V> RawTable<K, V> {\n     fn raw_buckets(&self) -> RawBuckets<K, V> {\n         RawBuckets {\n             raw: self.first_bucket_raw(),\n-            hashes_end: unsafe { self.hashes.offset(self.capacity as isize) },\n+            hashes_end: unsafe { self.hashes.ptr().offset(self.capacity as isize) },\n             marker: marker::PhantomData,\n         }\n     }\n@@ -832,6 +880,16 @@ impl<K, V> RawTable<K, V> {\n             marker: marker::PhantomData,\n         }\n     }\n+\n+    /// Set the table tag\n+    pub fn set_tag(&mut self, value: bool) {\n+        self.hashes.set_tag(value)\n+    }\n+\n+    /// Get the table tag\n+    pub fn tag(&self) -> bool {\n+        self.hashes.tag()\n+    }\n }\n \n /// A raw iterator. The basis for some other iterators in this module. Although\n@@ -1156,7 +1214,7 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n         debug_assert!(!oflo, \"should be impossible\");\n \n         unsafe {\n-            deallocate(*self.hashes as *mut u8, size, align);\n+            deallocate(self.hashes.ptr() as *mut u8, size, align);\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}, {"sha": "64eb52e28bc42d2ce075c5938c9b1f1614c4c795", "filename": "src/libstd/env.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -590,6 +590,10 @@ pub fn current_exe() -> io::Result<PathBuf> {\n ///\n /// This structure is created through the [`std::env::args`] function.\n ///\n+/// The first element is traditionally the path of the executable, but it can be\n+/// set to arbitrary text, and may not even exist. This means this property should\n+/// not be relied upon for security purposes.\n+///\n /// [`String`]: ../string/struct.String.html\n /// [`std::env::args`]: ./fn.args.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n@@ -600,6 +604,10 @@ pub struct Args { inner: ArgsOs }\n ///\n /// This structure is created through the [`std::env::args_os`] function.\n ///\n+/// The first element is traditionally the path of the executable, but it can be\n+/// set to arbitrary text, and may not even exist. This means this property should\n+/// not be relied upon for security purposes.\n+///\n /// [`OsString`]: ../ffi/struct.OsString.html\n /// [`std::env::args_os`]: ./fn.args_os.html\n #[stable(feature = \"env\", since = \"1.0.0\")]"}, {"sha": "e7bf16eae9ee660bd6bbf06f70bccb096a683116", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -330,8 +330,7 @@ declare_features! (\n     // `extern \"msp430-interrupt\" fn()`\n     (active, abi_msp430_interrupt, \"1.16.0\", Some(38487)),\n \n-    // Used to identify crates that contain sanitizer runtimes\n-    // rustc internal\n+    // Coerces non capturing closures to function pointers\n     (active, closure_to_fn_coercion, \"1.17.0\", Some(39817)),\n \n     // Used to identify crates that contain sanitizer runtimes"}, {"sha": "320ea6b5cc4e381b571b9607692cfe847f239f2f", "filename": "src/test/codegen/issue-15953.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcodegen%2Fissue-15953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcodegen%2Fissue-15953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-15953.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that llvm generates `memcpy` for moving a value\n+// inside a function and moving an argument.\n+\n+struct Foo {\n+    x: Vec<i32>,\n+}\n+\n+#[inline(never)]\n+#[no_mangle]\n+// CHECK: memcpy\n+fn interior(x: Vec<i32>) -> Vec<i32> {\n+    let Foo { x } = Foo { x: x };\n+    x\n+}\n+\n+#[inline(never)]\n+#[no_mangle]\n+// CHECK: memcpy\n+fn exterior(x: Vec<i32>) -> Vec<i32> {\n+    x\n+}\n+\n+fn main() {\n+    let x = interior(Vec::new());\n+    println!(\"{:?}\", x);\n+\n+    let x = exterior(Vec::new());\n+    println!(\"{:?}\", x);\n+}"}, {"sha": "d1971a5e1aea40403f0a486d23d25285de263685", "filename": "src/test/compile-fail/auxiliary/cfg-target-thread-local.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fcfg-target-thread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fcfg-target-thread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fcfg-target-thread-local.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(thread_local)]\n+#![feature(cfg_target_thread_local)]\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+#[cfg_attr(target_thread_local, thread_local)]\n+pub static FOO: u32 = 3;"}, {"sha": "985bd8320e05938d9449dc6b75b970d909ab16e4", "filename": "src/test/compile-fail/feature-gate-cfg-target-thread-local.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Ffeature-gate-cfg-target-thread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Ffeature-gate-cfg-target-thread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-cfg-target-thread-local.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows\n+// aux-build:cfg-target-thread-local.rs\n+\n+#![feature(thread_local)]\n+\n+extern crate cfg_target_thread_local;\n+\n+extern {\n+    #[cfg_attr(target_thread_local, thread_local)]\n+    //~^ `cfg(target_thread_local)` is experimental and subject to change (see issue #29594)\n+\n+    static FOO: u32;\n+}\n+\n+fn main() {\n+    assert_eq!(FOO, 3);\n+}"}, {"sha": "c8f9cd943cdaaf9ab61d41e2b71cc1faefbef3e0", "filename": "src/test/compile-fail/feature-gate-unwind-attributes.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unwind-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unwind-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unwind-attributes.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+extern {\n+// CHECK: Function Attrs: nounwind\n+// CHECK-NEXT: declare void @extern_fn\n+    fn extern_fn();\n+// CHECK-NOT: Function Attrs: nounwind\n+// CHECK: declare void @unwinding_extern_fn\n+    #[unwind] //~ ERROR #[unwind] is experimental\n+    fn unwinding_extern_fn();\n+}\n+\n+pub unsafe fn force_declare() {\n+    extern_fn();\n+    unwinding_extern_fn();\n+}"}, {"sha": "60afea5a621bd7219fe0168508d62979975fc444", "filename": "src/test/compile-fail/issue-18446.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Fissue-18446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Fissue-18446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18446.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that name clashes between the method in an impl for the type\n+// and the method in the trait when both are in the same scope.\n+\n+trait T {\n+    fn foo(&self);\n+}\n+\n+impl<'a> T + 'a {\n+    fn foo(&self) {}\n+}\n+\n+impl T for i32 {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let x: &T = &0i32;\n+    x.foo(); //~ ERROR multiple applicable items in scope [E0034]\n+}"}, {"sha": "0df84a436c0a936f0409dd159ac6f8934e09d428", "filename": "src/test/compile-fail/issue-22874.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Fissue-22874.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Fcompile-fail%2Fissue-22874.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22874.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Table {\n+    rows: [[String]],\n+    //~^ ERROR the trait bound `[std::string::String]: std::marker::Sized` is not satisfied [E0277]\n+}\n+\n+fn f(table: &Table) -> &[String] {\n+    &table.rows[0]\n+}\n+\n+fn main() {}"}, {"sha": "eb321e046dcbf55a9c46522f5a347f88cdf5fbd1", "filename": "src/test/run-pass/issue-18446.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Frun-pass%2Fissue-18446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Frun-pass%2Fissue-18446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18446.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that methods in trait impls should override default methods.\n+\n+trait T {\n+    fn foo(&self) -> i32 { 0 }\n+}\n+\n+impl<'a> T + 'a {\n+    fn foo(&self) -> i32 { 1 }\n+}\n+\n+fn main() {}"}, {"sha": "fc286184dcb351a44266098ca90ce52863355fc6", "filename": "src/test/run-pass/issue-23311.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Frun-pass%2Fissue-23311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftest%2Frun-pass%2Fissue-23311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23311.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not ICE when pattern matching an array against a slice.\n+\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    match \"foo\".as_bytes() {\n+        b\"food\" => (),\n+        &[b'f', ..] => (),\n+        _ => ()\n+    }\n+}"}, {"sha": "9b323c95fc3c8eace38e78d7a5605bd23c9b1541", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3087a1f39eaeac9d76c8b159dcc64de515bb2b83/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=3087a1f39eaeac9d76c8b159dcc64de515bb2b83", "patch": "@@ -165,17 +165,11 @@ pub fn check(path: &Path, bad: &mut bool) {\n         }\n     });\n \n-    // FIXME get this whitelist empty.\n-    let whitelist = vec![\n-        \"cfg_target_thread_local\", \"unwind_attributes\",\n-    ];\n-\n     // Only check the number of lang features.\n     // Obligatory testing for library features is dumb.\n     let gate_untested = features.iter()\n                                 .filter(|&(_, f)| f.level == Status::Unstable)\n                                 .filter(|&(_, f)| !f.has_gate_test)\n-                                .filter(|&(n, _)| !whitelist.contains(&n.as_str()))\n                                 .collect::<Vec<_>>();\n \n     for &(name, _) in gate_untested.iter() {"}]}