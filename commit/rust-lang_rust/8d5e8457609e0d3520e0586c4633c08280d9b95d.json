{"sha": "8d5e8457609e0d3520e0586c4633c08280d9b95d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNWU4NDU3NjA5ZTBkMzUyMGUwNTg2YzQ2MzNjMDgyODBkOWI5NWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-04T18:41:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-04T18:41:01Z"}, "message": "Auto merge of #32582 - nikomatsakis:issue-32326, r=aturon\n\nprocess cycles as soon as they are detected\n\nWe used to wait for the recursion limit, but that might well be too\nlong!\n\nFixes #32326\nr? @aturon", "tree": {"sha": "e37954f491cb6d5984348efb29bffc56600aacf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e37954f491cb6d5984348efb29bffc56600aacf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d5e8457609e0d3520e0586c4633c08280d9b95d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d5e8457609e0d3520e0586c4633c08280d9b95d", "html_url": "https://github.com/rust-lang/rust/commit/8d5e8457609e0d3520e0586c4633c08280d9b95d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d5e8457609e0d3520e0586c4633c08280d9b95d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a3b5585061e34bc87374adec993a6b1f0ec2a55", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3b5585061e34bc87374adec993a6b1f0ec2a55", "html_url": "https://github.com/rust-lang/rust/commit/6a3b5585061e34bc87374adec993a6b1f0ec2a55"}, {"sha": "e733b86ae3c2d8b86fe44f6d5c6c94ac36388ec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e733b86ae3c2d8b86fe44f6d5c6c94ac36388ec2", "html_url": "https://github.com/rust-lang/rust/commit/e733b86ae3c2d8b86fe44f6d5c6c94ac36388ec2"}], "stats": {"total": 389, "additions": 236, "deletions": 153}, "files": [{"sha": "810dfb960c6dc001a6d471745e64892340426b99", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 179, "deletions": 148, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/8d5e8457609e0d3520e0586c4633c08280d9b95d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d5e8457609e0d3520e0586c4633c08280d9b95d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=8d5e8457609e0d3520e0586c4633c08280d9b95d", "patch": "@@ -320,103 +320,172 @@ impl<'tcx> FulfillmentContext<'tcx> {\n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                               tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                              mut backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+                              backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                               -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n                                         FulfillmentErrorCode<'tcx>>\n {\n-    match process_predicate1(selcx, pending_obligation, backtrace.clone(), region_obligations) {\n-        Ok(Some(v)) => {\n-            // FIXME(#30977) The code below is designed to detect (and\n-            // permit) DAGs, while still ensuring that the reasoning\n-            // is acyclic. However, it does a few things\n-            // suboptimally. For example, it refreshes type variables\n-            // a lot, probably more than needed, but also less than\n-            // you might want.\n-            //\n-            //   - more than needed: I want to be very sure we don't\n-            //     accidentally treat a cycle as a DAG, so I am\n-            //     refreshing type variables as we walk the ancestors;\n-            //     but we are going to repeat this a lot, which is\n-            //     sort of silly, and it would be nicer to refresh\n-            //     them *in place* so that later predicate processing\n-            //     can benefit from the same work;\n-            //   - less than you might want: we only add items in the cache here,\n-            //     but maybe we learn more about type variables and could add them into\n-            //     the cache later on.\n-\n-            let tcx = selcx.tcx();\n-\n-            // Compute a little FnvHashSet for the ancestors. We only\n-            // do this the first time that we care.\n-            let mut cache = None;\n-            let mut is_ancestor = |predicate: &ty::Predicate<'tcx>| {\n-                if cache.is_none() {\n-                    let mut c = FnvHashSet();\n-                    for ancestor in backtrace.by_ref() {\n-                        // Ugh. This just feels ridiculously\n-                        // inefficient.  But we need to compare\n-                        // predicates without being concerned about\n-                        // the vagaries of type inference, so for now\n-                        // just ensure that they are always\n-                        // up-to-date. (I suppose we could just use a\n-                        // snapshot and check if they are unifiable?)\n-                        let resolved_predicate =\n-                            selcx.infcx().resolve_type_vars_if_possible(\n-                                &ancestor.obligation.predicate);\n-                        c.insert(resolved_predicate);\n-                    }\n-                    cache = Some(c);\n+    match process_predicate1(selcx, pending_obligation, region_obligations) {\n+        Ok(Some(v)) => process_child_obligations(selcx,\n+                                                 tree_cache,\n+                                                 &pending_obligation.obligation,\n+                                                 backtrace,\n+                                                 v),\n+        Ok(None) => Ok(None),\n+        Err(e) => Err(e)\n+    }\n+}\n+\n+fn process_child_obligations<'a,'tcx>(\n+    selcx: &mut SelectionContext<'a,'tcx>,\n+    tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n+    pending_obligation: &PredicateObligation<'tcx>,\n+    backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+    child_obligations: Vec<PredicateObligation<'tcx>>)\n+    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n+              FulfillmentErrorCode<'tcx>>\n+{\n+    // FIXME(#30977) The code below is designed to detect (and\n+    // permit) DAGs, while still ensuring that the reasoning\n+    // is acyclic. However, it does a few things\n+    // suboptimally. For example, it refreshes type variables\n+    // a lot, probably more than needed, but also less than\n+    // you might want.\n+    //\n+    //   - more than needed: I want to be very sure we don't\n+    //     accidentally treat a cycle as a DAG, so I am\n+    //     refreshing type variables as we walk the ancestors;\n+    //     but we are going to repeat this a lot, which is\n+    //     sort of silly, and it would be nicer to refresh\n+    //     them *in place* so that later predicate processing\n+    //     can benefit from the same work;\n+    //   - less than you might want: we only add items in the cache here,\n+    //     but maybe we learn more about type variables and could add them into\n+    //     the cache later on.\n+\n+    let tcx = selcx.tcx();\n+\n+    let mut ancestor_set = AncestorSet::new(&backtrace);\n+\n+    let pending_predicate_obligations: Vec<_> =\n+        child_obligations\n+        .into_iter()\n+        .filter_map(|obligation| {\n+            // Probably silly, but remove any inference\n+            // variables. This is actually crucial to the ancestor\n+            // check marked (*) below, but it's not clear that it\n+            // makes sense to ALWAYS do it.\n+            let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n+\n+            // Screen out obligations that we know globally\n+            // are true.\n+            if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n+                return None;\n+            }\n+\n+            // Check whether this obligation appears\n+            // somewhere else in the tree. If not, we have to\n+            // process it for sure.\n+            if !tree_cache.is_duplicate_or_add(&obligation.predicate) {\n+                return Some(PendingPredicateObligation {\n+                    obligation: obligation,\n+                    stalled_on: vec![]\n+                });\n+            }\n+\n+            debug!(\"process_child_obligations: duplicate={:?}\",\n+                   obligation.predicate);\n+\n+            // OK, the obligation appears elsewhere in the tree.\n+            // This is either a fatal error or else something we can\n+            // ignore. If the obligation appears in our *ancestors*\n+            // (rather than some more distant relative), that\n+            // indicates a cycle. Cycles are either considered\n+            // resolved (if this is a coinductive case) or a fatal\n+            // error.\n+            if let Some(index) = ancestor_set.has(selcx.infcx(), &obligation.predicate) {\n+                //                            ~~~ (*) see above\n+                debug!(\"process_child_obligations: cycle index = {}\", index);\n+\n+                let backtrace = backtrace.clone();\n+                let cycle: Vec<_> =\n+                    iter::once(&obligation)\n+                    .chain(Some(pending_obligation))\n+                    .chain(backtrace.take(index + 1).map(|p| &p.obligation))\n+                    .cloned()\n+                    .collect();\n+                if coinductive_match(selcx, &cycle) {\n+                    debug!(\"process_child_obligations: coinductive match\");\n+                    None\n+                } else {\n+                    report_overflow_error_cycle(selcx.infcx(), &cycle);\n                 }\n+            } else {\n+                // Not a cycle. Just ignore this obligation then,\n+                // we're already in the process of proving it.\n+                debug!(\"process_child_obligations: not a cycle\");\n+                None\n+            }\n+        })\n+        .collect();\n \n-                cache.as_ref().unwrap().contains(predicate)\n-            };\n+    Ok(Some(pending_predicate_obligations))\n+}\n+\n+struct AncestorSet<'b, 'tcx: 'b> {\n+    populated: bool,\n+    cache: FnvHashMap<ty::Predicate<'tcx>, usize>,\n+    backtrace: Backtrace<'b, PendingPredicateObligation<'tcx>>,\n+}\n \n-            let pending_predicate_obligations: Vec<_> =\n-                v.into_iter()\n-                 .filter_map(|obligation| {\n-                     // Probably silly, but remove any inference\n-                     // variables. This is actually crucial to the\n-                     // ancestor check below, but it's not clear that\n-                     // it makes sense to ALWAYS do it.\n-                     let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n-\n-                     // Screen out obligations that we know globally\n-                     // are true. This should really be the DAG check\n-                     // mentioned above.\n-                     if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n-                         return None;\n-                     }\n-\n-                     // Check whether this obligation appears somewhere else in the tree.\n-                     if tree_cache.is_duplicate_or_add(&obligation.predicate) {\n-                         // If the obligation appears as a parent,\n-                         // allow it, because that is a cycle.\n-                         // Otherwise though we can just ignore\n-                         // it. Note that we have to be careful around\n-                         // inference variables here -- for the\n-                         // purposes of the ancestor check, we retain\n-                         // the invariant that all type variables are\n-                         // fully refreshed.\n-                         if !is_ancestor(&obligation.predicate) {\n-                             return None;\n-                         }\n-                     }\n-\n-                     Some(PendingPredicateObligation {\n-                         obligation: obligation,\n-                         stalled_on: vec![]\n-                     })\n-                 })\n-                 .collect();\n-\n-            Ok(Some(pending_predicate_obligations))\n+impl<'b, 'tcx> AncestorSet<'b, 'tcx> {\n+    fn new(backtrace: &Backtrace<'b, PendingPredicateObligation<'tcx>>) -> Self {\n+        AncestorSet {\n+            populated: false,\n+            cache: FnvHashMap(),\n+            backtrace: backtrace.clone(),\n         }\n-        Ok(None) => Ok(None),\n-        Err(e) => Err(e)\n     }\n-}\n \n+    /// Checks whether any of the ancestors in the backtrace are equal\n+    /// to `predicate` (`predicate` is assumed to be fully\n+    /// type-resolved).  Returns `None` if not; otherwise, returns\n+    /// `Some` with the index within the backtrace.\n+    fn has<'a>(&mut self,\n+               infcx: &InferCtxt<'a, 'tcx>,\n+               predicate: &ty::Predicate<'tcx>)\n+               -> Option<usize> {\n+        // the first time, we have to populate the cache\n+        if !self.populated {\n+            let backtrace = self.backtrace.clone();\n+            for (index, ancestor) in backtrace.enumerate() {\n+                // Ugh. This just feels ridiculously\n+                // inefficient.  But we need to compare\n+                // predicates without being concerned about\n+                // the vagaries of type inference, so for now\n+                // just ensure that they are always\n+                // up-to-date. (I suppose we could just use a\n+                // snapshot and check if they are unifiable?)\n+                let resolved_predicate =\n+                    infcx.resolve_type_vars_if_possible(\n+                        &ancestor.obligation.predicate);\n+\n+                // Though we try to avoid it, it can happen that a\n+                // cycle already exists in the predecessors. This\n+                // happens if the type variables were not fully known\n+                // at the time that the ancestors were pushed. We'll\n+                // just ignore such cycles for now, on the premise\n+                // that they will repeat themselves and we'll deal\n+                // with them properly then.\n+                self.cache.entry(resolved_predicate)\n+                          .or_insert(index);\n+            }\n+            self.populated = true;\n+        }\n+\n+        self.cache.get(predicate).cloned()\n+    }\n+}\n \n /// Return the set of type variables contained in a trait ref\n fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n@@ -438,7 +507,6 @@ fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n /// - `Err` if the predicate does not hold\n fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                               backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                                region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                                -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n                                          FulfillmentErrorCode<'tcx>>\n@@ -461,16 +529,6 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n     let obligation = &mut pending_obligation.obligation;\n \n-    // If we exceed the recursion limit, take a moment to look for a\n-    // cycle so we can give a better error report from here, where we\n-    // have more context.\n-    let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n-    if obligation.recursion_depth >= recursion_limit {\n-        if let Some(cycle) = scan_for_cycle(obligation, &backtrace) {\n-            report_overflow_error_cycle(selcx.infcx(), &cycle);\n-        }\n-    }\n-\n     if obligation.predicate.has_infer_types() {\n         obligation.predicate = selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n     }\n@@ -481,10 +539,6 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                 return Ok(Some(vec![]));\n             }\n \n-            if coinductive_match(selcx, obligation, data, &backtrace) {\n-                return Ok(Some(vec![]));\n-            }\n-\n             let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(Some(vtable)) => {\n@@ -609,63 +663,40 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n /// For defaulted traits, we use a co-inductive strategy to solve, so\n /// that recursion is ok. This routine returns true if the top of the\n-/// stack (`top_obligation` and `top_data`):\n+/// stack (`cycle[0]`):\n /// - is a defaulted trait, and\n /// - it also appears in the backtrace at some position `X`; and,\n /// - all the predicates at positions `X..` between `X` an the top are\n ///   also defaulted traits.\n fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                              top_obligation: &PredicateObligation<'tcx>,\n-                              top_data: &ty::PolyTraitPredicate<'tcx>,\n-                              backtrace: &Backtrace<PendingPredicateObligation<'tcx>>)\n+                              cycle: &[PredicateObligation<'tcx>])\n                               -> bool\n {\n-    if selcx.tcx().trait_has_default_impl(top_data.def_id()) {\n-        debug!(\"coinductive_match: top_data={:?}\", top_data);\n-        for bt_obligation in backtrace.clone() {\n-            debug!(\"coinductive_match: bt_obligation={:?}\", bt_obligation);\n-\n-            // *Everything* in the backtrace must be a defaulted trait.\n-            match bt_obligation.obligation.predicate {\n-                ty::Predicate::Trait(ref data) => {\n-                    if !selcx.tcx().trait_has_default_impl(data.def_id()) {\n-                        debug!(\"coinductive_match: trait does not have default impl\");\n-                        break;\n-                    }\n-                }\n-                _ => { break; }\n-            }\n-\n-            // And we must find a recursive match.\n-            if bt_obligation.obligation.predicate == top_obligation.predicate {\n-                debug!(\"coinductive_match: found a match in the backtrace\");\n-                return true;\n-            }\n-        }\n-    }\n-\n-    false\n+    let len = cycle.len();\n+\n+    assert_eq!(cycle[0].predicate, cycle[len - 1].predicate);\n+\n+    cycle[0..len-1]\n+        .iter()\n+        .all(|bt_obligation| {\n+            let result = coinductive_obligation(selcx, bt_obligation);\n+            debug!(\"coinductive_match: bt_obligation={:?} coinductive={}\",\n+                   bt_obligation, result);\n+            result\n+        })\n }\n \n-fn scan_for_cycle<'a,'tcx>(top_obligation: &PredicateObligation<'tcx>,\n-                           backtrace: &Backtrace<PendingPredicateObligation<'tcx>>)\n-                           -> Option<Vec<PredicateObligation<'tcx>>>\n-{\n-    let mut map = FnvHashMap();\n-    let all_obligations =\n-        || iter::once(top_obligation)\n-               .chain(backtrace.clone()\n-                               .map(|p| &p.obligation));\n-    for (index, bt_obligation) in all_obligations().enumerate() {\n-        if let Some(&start) = map.get(&bt_obligation.predicate) {\n-            // Found a cycle starting at position `start` and running\n-            // until the current position (`index`).\n-            return Some(all_obligations().skip(start).take(index - start + 1).cloned().collect());\n-        } else {\n-            map.insert(bt_obligation.predicate.clone(), index);\n+fn coinductive_obligation<'a, 'tcx>(selcx: &SelectionContext<'a, 'tcx>,\n+                                    obligation: &PredicateObligation<'tcx>)\n+                                    -> bool {\n+    match obligation.predicate {\n+        ty::Predicate::Trait(ref data) => {\n+            selcx.tcx().trait_has_default_impl(data.def_id())\n+        }\n+        _ => {\n+            false\n         }\n     }\n-    None\n }\n \n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,"}, {"sha": "8af243afc22996b064c55ecc24e68aec2c7d82c4", "filename": "src/test/compile-fail/issue-32326.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d5e8457609e0d3520e0586c4633c08280d9b95d/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d5e8457609e0d3520e0586c4633c08280d9b95d/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs?ref=8d5e8457609e0d3520e0586c4633c08280d9b95d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #32326. We ran out of memory because we\n+// attempted to expand this case up to the recursion limit, and 2^N is\n+// too big.\n+\n+enum Expr { //~ ERROR E0072\n+    Plus(Expr, Expr),\n+    Literal(i64),\n+}\n+\n+fn main() { }"}, {"sha": "3d7c4868e96fe3bff3e62da72e0752ecc45c519a", "filename": "src/test/compile-fail/sized-cycle-note.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d5e8457609e0d3520e0586c4633c08280d9b95d/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d5e8457609e0d3520e0586c4633c08280d9b95d/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs?ref=8d5e8457609e0d3520e0586c4633c08280d9b95d", "patch": "@@ -20,11 +20,11 @@ struct Baz { q: Option<Foo> }\n \n struct Foo { q: Option<Baz> }\n //~^ ERROR recursive type `Foo` has infinite size\n-//~| type `Foo` is embedded within `std::option::Option<Foo>`...\n-//~| ...which in turn is embedded within `std::option::Option<Foo>`...\n-//~| ...which in turn is embedded within `Baz`...\n-//~| ...which in turn is embedded within `std::option::Option<Baz>`...\n-//~| ...which in turn is embedded within `Foo`, completing the cycle.\n+//~| NOTE type `Foo` is embedded within `std::option::Option<Foo>`...\n+//~| NOTE ...which in turn is embedded within `std::option::Option<Foo>`...\n+//~| NOTE ...which in turn is embedded within `Baz`...\n+//~| NOTE ...which in turn is embedded within `std::option::Option<Baz>`...\n+//~| NOTE ...which in turn is embedded within `Foo`, completing the cycle.\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "cdf4b405fd83e7bd398c6a55eb6082eed820f1e3", "filename": "src/test/compile-fail/traits-inductive-overflow-auto-normal-auto.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8d5e8457609e0d3520e0586c4633c08280d9b95d/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-auto-normal-auto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d5e8457609e0d3520e0586c4633c08280d9b95d/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-auto-normal-auto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-auto-normal-auto.rs?ref=8d5e8457609e0d3520e0586c4633c08280d9b95d", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for a potential corner case in current impl where you have an\n+// auto trait (Magic1) that depends on a normal trait (Magic2) which\n+// in turn depends on the auto trait (Magic1). This was incorrectly\n+// being considered coinductive, but because of the normal trait\n+// interfering, it should not be.\n+\n+#![feature(optin_builtin_traits)]\n+\n+trait Magic1: Magic2 { }\n+impl Magic1 for .. {}\n+\n+trait Magic2 { }\n+impl<T: Magic1> Magic2 for T { }\n+\n+fn is_magic1<T: Magic1>() { }\n+\n+#[derive(Debug)]\n+struct NoClone;\n+\n+fn main() {\n+    is_magic1::<NoClone>(); //~ ERROR E0275\n+}"}]}