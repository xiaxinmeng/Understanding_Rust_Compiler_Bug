{"sha": "4bea7b3ed0856310fc64614e5bb01e348777c99f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZWE3YjNlZDA4NTYzMTBmYzY0NjE0ZTViYjAxZTM0ODc3N2M5OWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-06T06:06:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-06T06:06:35Z"}, "message": "auto merge of #16367 : epdtry/rust/parallel-codegen, r=alexcrichton\n\nThis branch adds support for running LLVM optimization and codegen on different parts of a crate in parallel.  Instead of translating the crate into a single LLVM compilation unit, `rustc` now distributes items in the crate among several compilation units, and spawns worker threads to optimize and codegen each compilation unit independently.  This improves compile times on multicore machines, at the cost of worse performance in the compiled code.  The intent is to speed up build times during development without sacrificing too much optimization.\r\n\r\nOn the machine I tested this on, `librustc` build time with `-O` went from 265 seconds (master branch, single-threaded) to 115s (this branch, with 4 threads), a speedup of 2.3x.  For comparison, the build time without `-O` was 90s (single-threaded).  Bootstrapping `rustc` using 4 threads gets a 1.6x speedup over the default settings (870s vs. 1380s), and building `librustc` with the resulting stage2 compiler takes 1.3x as long as the master branch (44s vs.  55s, single threaded, ignoring time spent in LLVM codegen).\r\n\r\nThe user-visible changes from this branch are two new codegen flags:\r\n\r\n * `-C codegen-units=N`: Distribute items across `N` compilation units.\r\n * `-C codegen-threads=N`: Spawn `N` worker threads for running optimization and codegen.  (It is possible to set `codegen-threads` larger than `codegen-units`, but this is not very useful.)\r\n\r\nInternal changes to the compiler are described in detail on the individual commit messages.\r\n\r\nNote: The first commit on this branch is copied from #16359, which this branch depends on.\r\n\r\nr? @nick29581", "tree": {"sha": "ddbe6030b91a2eb06e74bd720fab756e9187ac8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddbe6030b91a2eb06e74bd720fab756e9187ac8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bea7b3ed0856310fc64614e5bb01e348777c99f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bea7b3ed0856310fc64614e5bb01e348777c99f", "html_url": "https://github.com/rust-lang/rust/commit/4bea7b3ed0856310fc64614e5bb01e348777c99f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bea7b3ed0856310fc64614e5bb01e348777c99f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da1395b6cbd613054ed1f0400b0599226a7ddcee", "url": "https://api.github.com/repos/rust-lang/rust/commits/da1395b6cbd613054ed1f0400b0599226a7ddcee", "html_url": "https://github.com/rust-lang/rust/commit/da1395b6cbd613054ed1f0400b0599226a7ddcee"}, {"sha": "6d2d47b2fc73b7beacced1f2a62037193ea1ed30", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d2d47b2fc73b7beacced1f2a62037193ea1ed30", "html_url": "https://github.com/rust-lang/rust/commit/6d2d47b2fc73b7beacced1f2a62037193ea1ed30"}], "stats": {"total": 4118, "additions": 2954, "deletions": 1164}, "files": [{"sha": "32671722ba72872bbeaabe397ec5c193cd45ecfe", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -1577,10 +1577,6 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n \n // codegen tests (vs. clang)\n \n-fn make_o_name(config: &Config, testfile: &Path) -> Path {\n-    output_base_name(config, testfile).with_extension(\"o\")\n-}\n-\n fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n     if suffix.len() == 0 {\n         (*p).clone()\n@@ -1596,14 +1592,13 @@ fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let link_args = vec!(\"-L\".to_string(),\n                          aux_dir.as_str().unwrap().to_string());\n-    let llvm_args = vec!(\"--emit=obj\".to_string(),\n-                         \"--crate-type=lib\".to_string(),\n-                         \"-C\".to_string(),\n-                         \"save-temps\".to_string());\n+    let llvm_args = vec!(\"--emit=bc,obj\".to_string(),\n+                         \"--crate-type=lib\".to_string());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(llvm_args.as_slice()),\n-                                 |a, b| ThisFile(make_o_name(a, b)), testfile);\n+                                 |a, b| ThisDirectory(output_base_name(a, b).dir_path()),\n+                                 testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n "}, {"sha": "5adf8b653813d4b83e8706149b9748cd34a9df32", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 52, "deletions": 520, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -13,12 +13,11 @@ use super::archive;\n use super::rpath;\n use super::rpath::RPathConfig;\n use super::svh::Svh;\n+use super::write::{OutputTypeBitcode, OutputTypeExe, OutputTypeObject};\n use driver::driver::{CrateTranslation, OutputFilenames, Input, FileInput};\n use driver::config::NoDebugInfo;\n use driver::session::Session;\n use driver::config;\n-use llvm;\n-use llvm::ModuleRef;\n use metadata::common::LinkMeta;\n use metadata::{encoder, cstore, filesearch, csearch, loader, creader};\n use middle::trans::context::CrateContext;\n@@ -28,13 +27,11 @@ use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n \n-use std::c_str::{ToCStr, CString};\n use std::char;\n use std::collections::HashSet;\n use std::io::{fs, TempDir, Command};\n use std::io;\n use std::mem;\n-use std::ptr;\n use std::str;\n use std::string::String;\n use flate;\n@@ -77,476 +74,6 @@ pub static RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n \n-#[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n-pub enum OutputType {\n-    OutputTypeBitcode,\n-    OutputTypeAssembly,\n-    OutputTypeLlvmAssembly,\n-    OutputTypeObject,\n-    OutputTypeExe,\n-}\n-\n-pub fn llvm_err(sess: &Session, msg: String) -> ! {\n-    unsafe {\n-        let cstr = llvm::LLVMRustGetLastError();\n-        if cstr == ptr::null() {\n-            sess.fatal(msg.as_slice());\n-        } else {\n-            let err = CString::new(cstr, true);\n-            let err = String::from_utf8_lossy(err.as_bytes());\n-            sess.fatal(format!(\"{}: {}\",\n-                               msg.as_slice(),\n-                               err.as_slice()).as_slice());\n-        }\n-    }\n-}\n-\n-pub fn write_output_file(\n-        sess: &Session,\n-        target: llvm::TargetMachineRef,\n-        pm: llvm::PassManagerRef,\n-        m: ModuleRef,\n-        output: &Path,\n-        file_type: llvm::FileType) {\n-    unsafe {\n-        output.with_c_str(|output| {\n-            let result = llvm::LLVMRustWriteOutputFile(\n-                    target, pm, m, output, file_type);\n-            if !result {\n-                llvm_err(sess, \"could not write output\".to_string());\n-            }\n-        })\n-    }\n-}\n-\n-pub mod write {\n-\n-    use super::super::lto;\n-    use super::{write_output_file, OutputType};\n-    use super::{OutputTypeAssembly, OutputTypeBitcode};\n-    use super::{OutputTypeExe, OutputTypeLlvmAssembly};\n-    use super::{OutputTypeObject};\n-    use driver::driver::{CrateTranslation, OutputFilenames};\n-    use driver::config::NoDebugInfo;\n-    use driver::session::Session;\n-    use driver::config;\n-    use llvm;\n-    use llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n-    use util::common::time;\n-    use syntax::abi;\n-\n-    use std::c_str::ToCStr;\n-    use std::io::{Command};\n-    use libc::{c_uint, c_int};\n-    use std::str;\n-\n-    // On android, we by default compile for armv7 processors. This enables\n-    // things like double word CAS instructions (rather than emulating them)\n-    // which are *far* more efficient. This is obviously undesirable in some\n-    // cases, so if any sort of target feature is specified we don't append v7\n-    // to the feature list.\n-    //\n-    // On iOS only armv7 and newer are supported. So it is useful to\n-    // get all hardware potential via VFP3 (hardware floating point)\n-    // and NEON (SIMD) instructions supported by LLVM.\n-    // Note that without those flags various linking errors might\n-    // arise as some of intrinsics are converted into function calls\n-    // and nobody provides implementations those functions\n-    fn target_feature<'a>(sess: &'a Session) -> &'a str {\n-        match sess.targ_cfg.os {\n-            abi::OsAndroid => {\n-                if \"\" == sess.opts.cg.target_feature.as_slice() {\n-                    \"+v7\"\n-                } else {\n-                    sess.opts.cg.target_feature.as_slice()\n-                }\n-            },\n-            abi::OsiOS if sess.targ_cfg.arch == abi::Arm => {\n-                \"+v7,+thumb2,+vfp3,+neon\"\n-            },\n-            _ => sess.opts.cg.target_feature.as_slice()\n-        }\n-    }\n-\n-    pub fn run_passes(sess: &Session,\n-                      trans: &CrateTranslation,\n-                      output_types: &[OutputType],\n-                      output: &OutputFilenames) {\n-        let llmod = trans.module;\n-        let llcx = trans.context;\n-        unsafe {\n-            configure_llvm(sess);\n-\n-            if sess.opts.cg.save_temps {\n-                output.with_extension(\"no-opt.bc\").with_c_str(|buf| {\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                })\n-            }\n-\n-            let opt_level = match sess.opts.optimize {\n-              config::No => llvm::CodeGenLevelNone,\n-              config::Less => llvm::CodeGenLevelLess,\n-              config::Default => llvm::CodeGenLevelDefault,\n-              config::Aggressive => llvm::CodeGenLevelAggressive,\n-            };\n-            let use_softfp = sess.opts.cg.soft_float;\n-\n-            // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a parameter.\n-            // FIXME: #11954: mac64 unwinding may not work with fp elim\n-            let no_fp_elim = (sess.opts.debuginfo != NoDebugInfo) ||\n-                             (sess.targ_cfg.os == abi::OsMacos &&\n-                              sess.targ_cfg.arch == abi::X86_64);\n-\n-            // OSX has -dead_strip, which doesn't rely on ffunction_sections\n-            // FIXME(#13846) this should be enabled for windows\n-            let ffunction_sections = sess.targ_cfg.os != abi::OsMacos &&\n-                                     sess.targ_cfg.os != abi::OsWindows;\n-            let fdata_sections = ffunction_sections;\n-\n-            let reloc_model = match sess.opts.cg.relocation_model.as_slice() {\n-                \"pic\" => llvm::RelocPIC,\n-                \"static\" => llvm::RelocStatic,\n-                \"default\" => llvm::RelocDefault,\n-                \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n-                _ => {\n-                    sess.err(format!(\"{} is not a valid relocation mode\",\n-                                     sess.opts\n-                                         .cg\n-                                         .relocation_model).as_slice());\n-                    sess.abort_if_errors();\n-                    return;\n-                }\n-            };\n-\n-            let code_model = match sess.opts.cg.code_model.as_slice() {\n-                \"default\" => llvm::CodeModelDefault,\n-                \"small\" => llvm::CodeModelSmall,\n-                \"kernel\" => llvm::CodeModelKernel,\n-                \"medium\" => llvm::CodeModelMedium,\n-                \"large\" => llvm::CodeModelLarge,\n-                _ => {\n-                    sess.err(format!(\"{} is not a valid code model\",\n-                                     sess.opts\n-                                         .cg\n-                                         .code_model).as_slice());\n-                    sess.abort_if_errors();\n-                    return;\n-                }\n-            };\n-\n-            let tm = sess.targ_cfg\n-                         .target_strs\n-                         .target_triple\n-                         .as_slice()\n-                         .with_c_str(|t| {\n-                sess.opts.cg.target_cpu.as_slice().with_c_str(|cpu| {\n-                    target_feature(sess).with_c_str(|features| {\n-                        llvm::LLVMRustCreateTargetMachine(\n-                            t, cpu, features,\n-                            code_model,\n-                            reloc_model,\n-                            opt_level,\n-                            true /* EnableSegstk */,\n-                            use_softfp,\n-                            no_fp_elim,\n-                            ffunction_sections,\n-                            fdata_sections,\n-                        )\n-                    })\n-                })\n-            });\n-\n-            // Create the two optimizing pass managers. These mirror what clang\n-            // does, and are by populated by LLVM's default PassManagerBuilder.\n-            // Each manager has a different set of passes, but they also share\n-            // some common passes.\n-            let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n-            let mpm = llvm::LLVMCreatePassManager();\n-\n-            // If we're verifying or linting, add them to the function pass\n-            // manager.\n-            let addpass = |pass: &str| {\n-                pass.as_slice().with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n-            };\n-            if !sess.no_verify() { assert!(addpass(\"verify\")); }\n-\n-            if !sess.opts.cg.no_prepopulate_passes {\n-                llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n-                llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-                populate_llvm_passes(fpm, mpm, llmod, opt_level,\n-                                     trans.no_builtins);\n-            }\n-\n-            for pass in sess.opts.cg.passes.iter() {\n-                pass.as_slice().with_c_str(|s| {\n-                    if !llvm::LLVMRustAddPass(mpm, s) {\n-                        sess.warn(format!(\"unknown pass {}, ignoring\",\n-                                          *pass).as_slice());\n-                    }\n-                })\n-            }\n-\n-            // Finally, run the actual optimization passes\n-            time(sess.time_passes(), \"llvm function passes\", (), |()|\n-                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n-            time(sess.time_passes(), \"llvm module passes\", (), |()|\n-                 llvm::LLVMRunPassManager(mpm, llmod));\n-\n-            // Deallocate managers that we're now done with\n-            llvm::LLVMDisposePassManager(fpm);\n-            llvm::LLVMDisposePassManager(mpm);\n-\n-            // Emit the bytecode if we're either saving our temporaries or\n-            // emitting an rlib. Whenever an rlib is created, the bytecode is\n-            // inserted into the archive in order to allow LTO against it.\n-            if sess.opts.cg.save_temps ||\n-               (sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n-                sess.opts.output_types.contains(&OutputTypeExe)) {\n-                output.temp_path(OutputTypeBitcode).with_c_str(|buf| {\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                })\n-            }\n-\n-            if sess.lto() {\n-                time(sess.time_passes(), \"all lto passes\", (), |()|\n-                     lto::run(sess, llmod, tm, trans.reachable.as_slice()));\n-\n-                if sess.opts.cg.save_temps {\n-                    output.with_extension(\"lto.bc\").with_c_str(|buf| {\n-                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                    })\n-                }\n-            }\n-\n-            // A codegen-specific pass manager is used to generate object\n-            // files for an LLVM module.\n-            //\n-            // Apparently each of these pass managers is a one-shot kind of\n-            // thing, so we create a new one for each type of output. The\n-            // pass manager passed to the closure should be ensured to not\n-            // escape the closure itself, and the manager should only be\n-            // used once.\n-            fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n-                            no_builtins: bool, f: |PassManagerRef|) {\n-                unsafe {\n-                    let cpm = llvm::LLVMCreatePassManager();\n-                    llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-                    llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n-                    f(cpm);\n-                    llvm::LLVMDisposePassManager(cpm);\n-                }\n-            }\n-\n-            let mut object_file = None;\n-            let mut needs_metadata = false;\n-            for output_type in output_types.iter() {\n-                let path = output.path(*output_type);\n-                match *output_type {\n-                    OutputTypeBitcode => {\n-                        path.with_c_str(|buf| {\n-                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                        })\n-                    }\n-                    OutputTypeLlvmAssembly => {\n-                        path.with_c_str(|output| {\n-                            with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                                llvm::LLVMRustPrintModule(cpm, llmod, output);\n-                            })\n-                        })\n-                    }\n-                    OutputTypeAssembly => {\n-                        // If we're not using the LLVM assembler, this function\n-                        // could be invoked specially with output_type_assembly,\n-                        // so in this case we still want the metadata object\n-                        // file.\n-                        let ty = OutputTypeAssembly;\n-                        let path = if sess.opts.output_types.contains(&ty) {\n-                           path\n-                        } else {\n-                            needs_metadata = true;\n-                            output.temp_path(OutputTypeAssembly)\n-                        };\n-                        with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                            write_output_file(sess, tm, cpm, llmod, &path,\n-                                            llvm::AssemblyFile);\n-                        });\n-                    }\n-                    OutputTypeObject => {\n-                        object_file = Some(path);\n-                    }\n-                    OutputTypeExe => {\n-                        object_file = Some(output.temp_path(OutputTypeObject));\n-                        needs_metadata = true;\n-                    }\n-                }\n-            }\n-\n-            time(sess.time_passes(), \"codegen passes\", (), |()| {\n-                match object_file {\n-                    Some(ref path) => {\n-                        with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                            write_output_file(sess, tm, cpm, llmod, path,\n-                                            llvm::ObjectFile);\n-                        });\n-                    }\n-                    None => {}\n-                }\n-                if needs_metadata {\n-                    with_codegen(tm, trans.metadata_module,\n-                                 trans.no_builtins, |cpm| {\n-                        let out = output.temp_path(OutputTypeObject)\n-                                        .with_extension(\"metadata.o\");\n-                        write_output_file(sess, tm, cpm,\n-                                        trans.metadata_module, &out,\n-                                        llvm::ObjectFile);\n-                    })\n-                }\n-            });\n-\n-            llvm::LLVMRustDisposeTargetMachine(tm);\n-            llvm::LLVMDisposeModule(trans.metadata_module);\n-            llvm::LLVMDisposeModule(llmod);\n-            llvm::LLVMContextDispose(llcx);\n-            if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n-        }\n-    }\n-\n-    pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n-        let pname = super::get_cc_prog(sess);\n-        let mut cmd = Command::new(pname.as_slice());\n-\n-        cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(OutputTypeObject))\n-                               .arg(outputs.temp_path(OutputTypeAssembly));\n-        debug!(\"{}\", &cmd);\n-\n-        match cmd.output() {\n-            Ok(prog) => {\n-                if !prog.status.success() {\n-                    sess.err(format!(\"linking with `{}` failed: {}\",\n-                                     pname,\n-                                     prog.status).as_slice());\n-                    sess.note(format!(\"{}\", &cmd).as_slice());\n-                    let mut note = prog.error.clone();\n-                    note.push_all(prog.output.as_slice());\n-                    sess.note(str::from_utf8(note.as_slice()).unwrap());\n-                    sess.abort_if_errors();\n-                }\n-            },\n-            Err(e) => {\n-                sess.err(format!(\"could not exec the linker `{}`: {}\",\n-                                 pname,\n-                                 e).as_slice());\n-                sess.abort_if_errors();\n-            }\n-        }\n-    }\n-\n-    unsafe fn configure_llvm(sess: &Session) {\n-        use std::sync::{Once, ONCE_INIT};\n-        static mut INIT: Once = ONCE_INIT;\n-\n-        // Copy what clang does by turning on loop vectorization at O2 and\n-        // slp vectorization at O3\n-        let vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n-                             (sess.opts.optimize == config::Default ||\n-                              sess.opts.optimize == config::Aggressive);\n-        let vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n-                            sess.opts.optimize == config::Aggressive;\n-\n-        let mut llvm_c_strs = Vec::new();\n-        let mut llvm_args = Vec::new();\n-        {\n-            let add = |arg: &str| {\n-                let s = arg.to_c_str();\n-                llvm_args.push(s.as_ptr());\n-                llvm_c_strs.push(s);\n-            };\n-            add(\"rustc\"); // fake program name\n-            if vectorize_loop { add(\"-vectorize-loops\"); }\n-            if vectorize_slp  { add(\"-vectorize-slp\");   }\n-            if sess.time_llvm_passes() { add(\"-time-passes\"); }\n-            if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n-\n-            for arg in sess.opts.cg.llvm_args.iter() {\n-                add((*arg).as_slice());\n-            }\n-        }\n-\n-        INIT.doit(|| {\n-            llvm::LLVMInitializePasses();\n-\n-            // Only initialize the platforms supported by Rust here, because\n-            // using --llvm-root will have multiple platforms that rustllvm\n-            // doesn't actually link to and it's pointless to put target info\n-            // into the registry that Rust cannot generate machine code for.\n-            llvm::LLVMInitializeX86TargetInfo();\n-            llvm::LLVMInitializeX86Target();\n-            llvm::LLVMInitializeX86TargetMC();\n-            llvm::LLVMInitializeX86AsmPrinter();\n-            llvm::LLVMInitializeX86AsmParser();\n-\n-            llvm::LLVMInitializeARMTargetInfo();\n-            llvm::LLVMInitializeARMTarget();\n-            llvm::LLVMInitializeARMTargetMC();\n-            llvm::LLVMInitializeARMAsmPrinter();\n-            llvm::LLVMInitializeARMAsmParser();\n-\n-            llvm::LLVMInitializeMipsTargetInfo();\n-            llvm::LLVMInitializeMipsTarget();\n-            llvm::LLVMInitializeMipsTargetMC();\n-            llvm::LLVMInitializeMipsAsmPrinter();\n-            llvm::LLVMInitializeMipsAsmParser();\n-\n-            llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n-                                         llvm_args.as_ptr());\n-        });\n-    }\n-\n-    unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n-                                   mpm: llvm::PassManagerRef,\n-                                   llmod: ModuleRef,\n-                                   opt: llvm::CodeGenOptLevel,\n-                                   no_builtins: bool) {\n-        // Create the PassManagerBuilder for LLVM. We configure it with\n-        // reasonable defaults and prepare it to actually populate the pass\n-        // manager.\n-        let builder = llvm::LLVMPassManagerBuilderCreate();\n-        match opt {\n-            llvm::CodeGenLevelNone => {\n-                // Don't add lifetime intrinsics at O0\n-                llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n-            }\n-            llvm::CodeGenLevelLess => {\n-                llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n-            }\n-            // numeric values copied from clang\n-            llvm::CodeGenLevelDefault => {\n-                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n-                                                                    225);\n-            }\n-            llvm::CodeGenLevelAggressive => {\n-                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n-                                                                    275);\n-            }\n-        }\n-        llvm::LLVMPassManagerBuilderSetOptLevel(builder, opt as c_uint);\n-        llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, no_builtins);\n-\n-        // Use the builder to populate the function/module pass managers.\n-        llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);\n-        llvm::LLVMPassManagerBuilderPopulateModulePassManager(builder, mpm);\n-        llvm::LLVMPassManagerBuilderDispose(builder);\n-\n-        match opt {\n-            llvm::CodeGenLevelDefault | llvm::CodeGenLevelAggressive => {\n-                \"mergefunc\".with_c_str(|s| llvm::LLVMRustAddPass(mpm, s));\n-            }\n-            _ => {}\n-        };\n-    }\n-}\n-\n-\n /*\n  * Name mangling and its relationship to metadata. This is complex. Read\n  * carefully.\n@@ -715,14 +242,14 @@ fn symbol_hash(tcx: &ty::ctxt,\n }\n \n fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> String {\n-    match ccx.type_hashcodes.borrow().find(&t) {\n+    match ccx.type_hashcodes().borrow().find(&t) {\n         Some(h) => return h.to_string(),\n         None => {}\n     }\n \n-    let mut symbol_hasher = ccx.symbol_hasher.borrow_mut();\n-    let hash = symbol_hash(ccx.tcx(), &mut *symbol_hasher, t, &ccx.link_meta);\n-    ccx.type_hashcodes.borrow_mut().insert(t, hash.clone());\n+    let mut symbol_hasher = ccx.symbol_hasher().borrow_mut();\n+    let hash = symbol_hash(ccx.tcx(), &mut *symbol_hasher, t, ccx.link_meta());\n+    ccx.type_hashcodes().borrow_mut().insert(t, hash.clone());\n     hash\n }\n \n@@ -877,7 +404,7 @@ pub fn get_ar_prog(sess: &Session) -> String {\n     }\n }\n \n-fn remove(sess: &Session, path: &Path) {\n+pub fn remove(sess: &Session, path: &Path) {\n     match fs::unlink(path) {\n         Ok(..) => {}\n         Err(e) => {\n@@ -1135,51 +662,56 @@ fn link_rlib<'a>(sess: &'a Session,\n             ab.add_file(&metadata).unwrap();\n             remove(sess, &metadata);\n \n-            // For LTO purposes, the bytecode of this library is also inserted\n-            // into the archive.\n-            //\n-            // Note that we make sure that the bytecode filename in the archive\n-            // is never exactly 16 bytes long by adding a 16 byte extension to\n-            // it. This is to work around a bug in LLDB that would cause it to\n-            // crash if the name of a file in an archive was exactly 16 bytes.\n-            let bc_filename = obj_filename.with_extension(\"bc\");\n-            let bc_deflated_filename = obj_filename.with_extension(\"bytecode.deflate\");\n-\n-            let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n-                Ok(buffer) => buffer,\n-                Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n-                                             e).as_slice())\n-            };\n+            if sess.opts.cg.codegen_units == 1 {\n+                // For LTO purposes, the bytecode of this library is also\n+                // inserted into the archive.  We currently do this only when\n+                // codegen_units == 1, so we don't have to deal with multiple\n+                // bitcode files per crate.\n+                //\n+                // Note that we make sure that the bytecode filename in the\n+                // archive is never exactly 16 bytes long by adding a 16 byte\n+                // extension to it. This is to work around a bug in LLDB that\n+                // would cause it to crash if the name of a file in an archive\n+                // was exactly 16 bytes.\n+                let bc_filename = obj_filename.with_extension(\"bc\");\n+                let bc_deflated_filename = obj_filename.with_extension(\"bytecode.deflate\");\n+\n+                let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n+                    Ok(buffer) => buffer,\n+                    Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n+                                                 e).as_slice())\n+                };\n \n-            let bc_data_deflated = match flate::deflate_bytes(bc_data.as_slice()) {\n-                Some(compressed) => compressed,\n-                None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n-                                           bc_filename.display()).as_slice())\n-            };\n+                let bc_data_deflated = match flate::deflate_bytes(bc_data.as_slice()) {\n+                    Some(compressed) => compressed,\n+                    None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n+                                               bc_filename.display()).as_slice())\n+                };\n \n-            let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n-                Ok(file) => file,\n-                Err(e) => {\n-                    sess.fatal(format!(\"failed to create compressed bytecode \\\n-                                        file: {}\", e).as_slice())\n-                }\n-            };\n+                let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n+                    Ok(file) => file,\n+                    Err(e) => {\n+                        sess.fatal(format!(\"failed to create compressed bytecode \\\n+                                            file: {}\", e).as_slice())\n+                    }\n+                };\n \n-            match write_rlib_bytecode_object_v1(&mut bc_file_deflated,\n-                                                bc_data_deflated.as_slice()) {\n-                Ok(()) => {}\n-                Err(e) => {\n-                    sess.err(format!(\"failed to write compressed bytecode: \\\n-                                      {}\", e).as_slice());\n-                    sess.abort_if_errors()\n-                }\n-            };\n+                match write_rlib_bytecode_object_v1(&mut bc_file_deflated,\n+                                                    bc_data_deflated.as_slice()) {\n+                    Ok(()) => {}\n+                    Err(e) => {\n+                        sess.err(format!(\"failed to write compressed bytecode: \\\n+                                          {}\", e).as_slice());\n+                        sess.abort_if_errors()\n+                    }\n+                };\n \n-            ab.add_file(&bc_deflated_filename).unwrap();\n-            remove(sess, &bc_deflated_filename);\n-            if !sess.opts.cg.save_temps &&\n-               !sess.opts.output_types.contains(&OutputTypeBitcode) {\n-                remove(sess, &bc_filename);\n+                ab.add_file(&bc_deflated_filename).unwrap();\n+                remove(sess, &bc_deflated_filename);\n+                if !sess.opts.cg.save_temps &&\n+                   !sess.opts.output_types.contains(&OutputTypeBitcode) {\n+                    remove(sess, &bc_filename);\n+                }\n             }\n         }\n "}, {"sha": "d7f183faa0192c553afe7036c5013e43df429db2", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use super::link;\n+use super::write;\n use driver::session;\n use driver::config;\n use llvm;\n@@ -66,7 +67,14 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                                   archive.read(format!(\"{}.bytecode.deflate\",\n                                                        file).as_slice())\n                               });\n-        let bc_encoded = bc_encoded.expect(\"missing compressed bytecode in archive!\");\n+        let bc_encoded = match bc_encoded {\n+            Some(data) => data,\n+            None => {\n+                sess.fatal(format!(\"missing compressed bytecode in {} \\\n+                                    (perhaps it was compiled with -C codegen-units > 1)\",\n+                                   path.display()).as_slice());\n+            },\n+        };\n         let bc_extractor = if is_versioned_bytecode_format(bc_encoded) {\n             |_| {\n                 // Read the version\n@@ -119,9 +127,9 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                     ptr as *const libc::c_char,\n                                                     bc_decoded.len() as libc::size_t) {\n-                link::llvm_err(sess,\n-                               format!(\"failed to load bc of `{}`\",\n-                                       name.as_slice()));\n+                write::llvm_err(sess.diagnostic().handler(),\n+                                format!(\"failed to load bc of `{}`\",\n+                                        name.as_slice()));\n             }\n         });\n     }"}, {"sha": "627d455f06e11f90297619675e0658783417a00d", "filename": "src/librustc/back/write.rs", "status": "added", "additions": 962, "deletions": 0, "changes": 962, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,962 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use back::lto;\n+use back::link::{get_cc_prog, remove};\n+use driver::driver::{CrateTranslation, ModuleTranslation, OutputFilenames};\n+use driver::config::NoDebugInfo;\n+use driver::session::Session;\n+use driver::config;\n+use llvm;\n+use llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n+use util::common::time;\n+use syntax::abi;\n+use syntax::codemap;\n+use syntax::diagnostic;\n+use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n+\n+use std::c_str::{ToCStr, CString};\n+use std::io::Command;\n+use std::io::fs;\n+use std::iter::Unfold;\n+use std::ptr;\n+use std::str;\n+use std::sync::{Arc, Mutex};\n+use std::task::TaskBuilder;\n+use libc::{c_uint, c_int};\n+\n+\n+#[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n+pub enum OutputType {\n+    OutputTypeBitcode,\n+    OutputTypeAssembly,\n+    OutputTypeLlvmAssembly,\n+    OutputTypeObject,\n+    OutputTypeExe,\n+}\n+\n+\n+pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n+    unsafe {\n+        let cstr = llvm::LLVMRustGetLastError();\n+        if cstr == ptr::null() {\n+            handler.fatal(msg.as_slice());\n+        } else {\n+            let err = CString::new(cstr, true);\n+            let err = String::from_utf8_lossy(err.as_bytes());\n+            handler.fatal(format!(\"{}: {}\",\n+                                  msg.as_slice(),\n+                                  err.as_slice()).as_slice());\n+        }\n+    }\n+}\n+\n+pub fn write_output_file(\n+        handler: &diagnostic::Handler,\n+        target: llvm::TargetMachineRef,\n+        pm: llvm::PassManagerRef,\n+        m: ModuleRef,\n+        output: &Path,\n+        file_type: llvm::FileType) {\n+    unsafe {\n+        output.with_c_str(|output| {\n+            let result = llvm::LLVMRustWriteOutputFile(\n+                    target, pm, m, output, file_type);\n+            if !result {\n+                llvm_err(handler, \"could not write output\".to_string());\n+            }\n+        })\n+    }\n+}\n+\n+\n+struct Diagnostic {\n+    msg: String,\n+    code: Option<String>,\n+    lvl: Level,\n+}\n+\n+// We use an Arc instead of just returning a list of diagnostics from the\n+// child task because we need to make sure that the messages are seen even\n+// if the child task fails (for example, when `fatal` is called).\n+#[deriving(Clone)]\n+struct SharedEmitter {\n+    buffer: Arc<Mutex<Vec<Diagnostic>>>,\n+}\n+\n+impl SharedEmitter {\n+    fn new() -> SharedEmitter {\n+        SharedEmitter {\n+            buffer: Arc::new(Mutex::new(Vec::new())),\n+        }\n+    }\n+\n+    fn dump(&mut self, handler: &Handler) {\n+        let mut buffer = self.buffer.lock();\n+        for diag in buffer.iter() {\n+            match diag.code {\n+                Some(ref code) => {\n+                    handler.emit_with_code(None,\n+                                           diag.msg.as_slice(),\n+                                           code.as_slice(),\n+                                           diag.lvl);\n+                },\n+                None => {\n+                    handler.emit(None,\n+                                 diag.msg.as_slice(),\n+                                 diag.lvl);\n+                },\n+            }\n+        }\n+        buffer.clear();\n+    }\n+}\n+\n+impl Emitter for SharedEmitter {\n+    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, codemap::Span)>,\n+            msg: &str, code: Option<&str>, lvl: Level) {\n+        assert!(cmsp.is_none(), \"SharedEmitter doesn't support spans\");\n+\n+        self.buffer.lock().push(Diagnostic {\n+            msg: msg.to_string(),\n+            code: code.map(|s| s.to_string()),\n+            lvl: lvl,\n+        });\n+    }\n+\n+    fn custom_emit(&mut self, _cm: &codemap::CodeMap,\n+                   _sp: diagnostic::RenderSpan, _msg: &str, _lvl: Level) {\n+        fail!(\"SharedEmitter doesn't support custom_emit\");\n+    }\n+}\n+\n+\n+// On android, we by default compile for armv7 processors. This enables\n+// things like double word CAS instructions (rather than emulating them)\n+// which are *far* more efficient. This is obviously undesirable in some\n+// cases, so if any sort of target feature is specified we don't append v7\n+// to the feature list.\n+//\n+// On iOS only armv7 and newer are supported. So it is useful to\n+// get all hardware potential via VFP3 (hardware floating point)\n+// and NEON (SIMD) instructions supported by LLVM.\n+// Note that without those flags various linking errors might\n+// arise as some of intrinsics are converted into function calls\n+// and nobody provides implementations those functions\n+fn target_feature<'a>(sess: &'a Session) -> &'a str {\n+    match sess.targ_cfg.os {\n+        abi::OsAndroid => {\n+            if \"\" == sess.opts.cg.target_feature.as_slice() {\n+                \"+v7\"\n+            } else {\n+                sess.opts.cg.target_feature.as_slice()\n+            }\n+        },\n+        abi::OsiOS if sess.targ_cfg.arch == abi::Arm => {\n+            \"+v7,+thumb2,+vfp3,+neon\"\n+        },\n+        _ => sess.opts.cg.target_feature.as_slice()\n+    }\n+}\n+\n+fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n+    match optimize {\n+      config::No => llvm::CodeGenLevelNone,\n+      config::Less => llvm::CodeGenLevelLess,\n+      config::Default => llvm::CodeGenLevelDefault,\n+      config::Aggressive => llvm::CodeGenLevelAggressive,\n+    }\n+}\n+\n+fn create_target_machine(sess: &Session) -> TargetMachineRef {\n+    let reloc_model = match sess.opts.cg.relocation_model.as_slice() {\n+        \"pic\" => llvm::RelocPIC,\n+        \"static\" => llvm::RelocStatic,\n+        \"default\" => llvm::RelocDefault,\n+        \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n+        _ => {\n+            sess.err(format!(\"{} is not a valid relocation mode\",\n+                             sess.opts\n+                                 .cg\n+                                 .relocation_model).as_slice());\n+            sess.abort_if_errors();\n+            unreachable!();\n+        }\n+    };\n+\n+    let opt_level = get_llvm_opt_level(sess.opts.optimize);\n+    let use_softfp = sess.opts.cg.soft_float;\n+\n+    // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a parameter.\n+    // FIXME: #11954: mac64 unwinding may not work with fp elim\n+    let no_fp_elim = (sess.opts.debuginfo != NoDebugInfo) ||\n+                     (sess.targ_cfg.os == abi::OsMacos &&\n+                      sess.targ_cfg.arch == abi::X86_64);\n+\n+    // OSX has -dead_strip, which doesn't rely on ffunction_sections\n+    // FIXME(#13846) this should be enabled for windows\n+    let ffunction_sections = sess.targ_cfg.os != abi::OsMacos &&\n+                             sess.targ_cfg.os != abi::OsWindows;\n+    let fdata_sections = ffunction_sections;\n+\n+    let code_model = match sess.opts.cg.code_model.as_slice() {\n+        \"default\" => llvm::CodeModelDefault,\n+        \"small\" => llvm::CodeModelSmall,\n+        \"kernel\" => llvm::CodeModelKernel,\n+        \"medium\" => llvm::CodeModelMedium,\n+        \"large\" => llvm::CodeModelLarge,\n+        _ => {\n+            sess.err(format!(\"{} is not a valid code model\",\n+                             sess.opts\n+                                 .cg\n+                                 .code_model).as_slice());\n+            sess.abort_if_errors();\n+            unreachable!();\n+        }\n+    };\n+\n+    unsafe {\n+        sess.targ_cfg\n+             .target_strs\n+             .target_triple\n+             .as_slice()\n+             .with_c_str(|t| {\n+            sess.opts.cg.target_cpu.as_slice().with_c_str(|cpu| {\n+                target_feature(sess).with_c_str(|features| {\n+                    llvm::LLVMRustCreateTargetMachine(\n+                        t, cpu, features,\n+                        code_model,\n+                        reloc_model,\n+                        opt_level,\n+                        true /* EnableSegstk */,\n+                        use_softfp,\n+                        no_fp_elim,\n+                        ffunction_sections,\n+                        fdata_sections,\n+                    )\n+                })\n+            })\n+        })\n+    }\n+}\n+\n+\n+/// Module-specific configuration for `optimize_and_codegen`.\n+#[deriving(Clone)]\n+struct ModuleConfig {\n+    /// LLVM TargetMachine to use for codegen.\n+    tm: TargetMachineRef,\n+    /// Names of additional optimization passes to run.\n+    passes: Vec<String>,\n+    /// Some(level) to optimize at a certain level, or None to run\n+    /// absolutely no optimizations (used for the metadata module).\n+    opt_level: Option<llvm::CodeGenOptLevel>,\n+\n+    // Flags indicating which outputs to produce.\n+    emit_no_opt_bc: bool,\n+    emit_bc: bool,\n+    emit_lto_bc: bool,\n+    emit_ir: bool,\n+    emit_asm: bool,\n+    emit_obj: bool,\n+\n+    // Miscellaneous flags.  These are mostly copied from command-line\n+    // options.\n+    no_verify: bool,\n+    no_prepopulate_passes: bool,\n+    no_builtins: bool,\n+    time_passes: bool,\n+}\n+\n+impl ModuleConfig {\n+    fn new(tm: TargetMachineRef, passes: Vec<String>) -> ModuleConfig {\n+        ModuleConfig {\n+            tm: tm,\n+            passes: passes,\n+            opt_level: None,\n+\n+            emit_no_opt_bc: false,\n+            emit_bc: false,\n+            emit_lto_bc: false,\n+            emit_ir: false,\n+            emit_asm: false,\n+            emit_obj: false,\n+\n+            no_verify: false,\n+            no_prepopulate_passes: false,\n+            no_builtins: false,\n+            time_passes: false,\n+        }\n+    }\n+\n+    fn set_flags(&mut self, sess: &Session, trans: &CrateTranslation) {\n+        self.no_verify = sess.no_verify();\n+        self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n+        self.no_builtins = trans.no_builtins;\n+        self.time_passes = sess.time_passes();\n+    }\n+}\n+\n+/// Additional resources used by optimize_and_codegen (not module specific)\n+struct CodegenContext<'a> {\n+    // Extra resources used for LTO: (sess, reachable).  This will be `None`\n+    // when running in a worker thread.\n+    lto_ctxt: Option<(&'a Session, &'a [String])>,\n+    // Handler to use for diagnostics produced during codegen.\n+    handler: &'a Handler,\n+}\n+\n+impl<'a> CodegenContext<'a> {\n+    fn new(handler: &'a Handler) -> CodegenContext<'a> {\n+        CodegenContext {\n+            lto_ctxt: None,\n+            handler: handler,\n+        }\n+    }\n+\n+    fn new_with_session(sess: &'a Session, reachable: &'a [String]) -> CodegenContext<'a> {\n+        CodegenContext {\n+            lto_ctxt: Some((sess, reachable)),\n+            handler: sess.diagnostic().handler(),\n+        }\n+    }\n+}\n+\n+// Unsafe due to LLVM calls.\n+unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n+                               mtrans: ModuleTranslation,\n+                               config: ModuleConfig,\n+                               name_extra: String,\n+                               output_names: OutputFilenames) {\n+    let ModuleTranslation { llmod, llcx } = mtrans;\n+    let tm = config.tm;\n+\n+    if config.emit_no_opt_bc {\n+        let ext = format!(\"{}.no-opt.bc\", name_extra);\n+        output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n+            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+        })\n+    }\n+\n+    match config.opt_level {\n+        Some(opt_level) => {\n+            // Create the two optimizing pass managers. These mirror what clang\n+            // does, and are by populated by LLVM's default PassManagerBuilder.\n+            // Each manager has a different set of passes, but they also share\n+            // some common passes.\n+            let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n+            let mpm = llvm::LLVMCreatePassManager();\n+\n+            // If we're verifying or linting, add them to the function pass\n+            // manager.\n+            let addpass = |pass: &str| {\n+                pass.as_slice().with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n+            };\n+            if !config.no_verify { assert!(addpass(\"verify\")); }\n+\n+            if !config.no_prepopulate_passes {\n+                llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n+                llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n+                populate_llvm_passes(fpm, mpm, llmod, opt_level,\n+                                     config.no_builtins);\n+            }\n+\n+            for pass in config.passes.iter() {\n+                pass.as_slice().with_c_str(|s| {\n+                    if !llvm::LLVMRustAddPass(mpm, s) {\n+                        cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n+                                                  *pass).as_slice());\n+                    }\n+                })\n+            }\n+\n+            // Finally, run the actual optimization passes\n+            time(config.time_passes, \"llvm function passes\", (), |()|\n+                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n+            time(config.time_passes, \"llvm module passes\", (), |()|\n+                 llvm::LLVMRunPassManager(mpm, llmod));\n+\n+            // Deallocate managers that we're now done with\n+            llvm::LLVMDisposePassManager(fpm);\n+            llvm::LLVMDisposePassManager(mpm);\n+\n+            match cgcx.lto_ctxt {\n+                Some((sess, reachable)) if sess.lto() =>  {\n+                    time(sess.time_passes(), \"all lto passes\", (), |()|\n+                         lto::run(sess, llmod, tm, reachable));\n+\n+                    if config.emit_lto_bc {\n+                        let name = format!(\"{}.lto.bc\", name_extra);\n+                        output_names.with_extension(name.as_slice()).with_c_str(|buf| {\n+                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                        })\n+                    }\n+                },\n+                _ => {},\n+            }\n+        },\n+        None => {},\n+    }\n+\n+    // A codegen-specific pass manager is used to generate object\n+    // files for an LLVM module.\n+    //\n+    // Apparently each of these pass managers is a one-shot kind of\n+    // thing, so we create a new one for each type of output. The\n+    // pass manager passed to the closure should be ensured to not\n+    // escape the closure itself, and the manager should only be\n+    // used once.\n+    unsafe fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n+                    no_builtins: bool, f: |PassManagerRef|) {\n+        let cpm = llvm::LLVMCreatePassManager();\n+        llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+        llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n+        f(cpm);\n+        llvm::LLVMDisposePassManager(cpm);\n+    }\n+\n+    if config.emit_bc {\n+        let ext = format!(\"{}.bc\", name_extra);\n+        output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n+            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+        })\n+    }\n+\n+    time(config.time_passes, \"codegen passes\", (), |()| {\n+        if config.emit_ir {\n+            let ext = format!(\"{}.ll\", name_extra);\n+            output_names.with_extension(ext.as_slice()).with_c_str(|output| {\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    llvm::LLVMRustPrintModule(cpm, llmod, output);\n+                })\n+            })\n+        }\n+\n+        if config.emit_asm {\n+            let path = output_names.with_extension(format!(\"{}.s\", name_extra).as_slice());\n+            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFile);\n+            });\n+        }\n+\n+        if config.emit_obj {\n+            let path = output_names.with_extension(format!(\"{}.o\", name_extra).as_slice());\n+            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFile);\n+            });\n+        }\n+    });\n+\n+    llvm::LLVMDisposeModule(llmod);\n+    llvm::LLVMContextDispose(llcx);\n+    llvm::LLVMRustDisposeTargetMachine(tm);\n+}\n+\n+pub fn run_passes(sess: &Session,\n+                  trans: &CrateTranslation,\n+                  output_types: &[OutputType],\n+                  crate_output: &OutputFilenames) {\n+    // It's possible that we have `codegen_units > 1` but only one item in\n+    // `trans.modules`.  We could theoretically proceed and do LTO in that\n+    // case, but it would be confusing to have the validity of\n+    // `-Z lto -C codegen-units=2` depend on details of the crate being\n+    // compiled, so we complain regardless.\n+    if sess.lto() && sess.opts.cg.codegen_units > 1 {\n+        // This case is impossible to handle because LTO expects to be able\n+        // to combine the entire crate and all its dependencies into a\n+        // single compilation unit, but each codegen unit is in a separate\n+        // LLVM context, so they can't easily be combined.\n+        sess.fatal(\"can't perform LTO when using multiple codegen units\");\n+    }\n+\n+    // Sanity check\n+    assert!(trans.modules.len() == sess.opts.cg.codegen_units);\n+\n+    unsafe {\n+        configure_llvm(sess);\n+    }\n+\n+    let tm = create_target_machine(sess);\n+\n+    // Figure out what we actually need to build.\n+\n+    let mut modules_config = ModuleConfig::new(tm, sess.opts.cg.passes.clone());\n+    let mut metadata_config = ModuleConfig::new(tm, vec!());\n+\n+    modules_config.opt_level = Some(get_llvm_opt_level(sess.opts.optimize));\n+\n+    // Save all versions of the bytecode if we're saving our temporaries.\n+    if sess.opts.cg.save_temps {\n+        modules_config.emit_no_opt_bc = true;\n+        modules_config.emit_bc = true;\n+        modules_config.emit_lto_bc = true;\n+        metadata_config.emit_bc = true;\n+    }\n+\n+    // Emit a bitcode file for the crate if we're emitting an rlib.\n+    // Whenever an rlib is created, the bitcode is inserted into the\n+    // archive in order to allow LTO against it.\n+    let needs_crate_bitcode =\n+            sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n+            sess.opts.output_types.contains(&OutputTypeExe) &&\n+            sess.opts.cg.codegen_units == 1;\n+    if needs_crate_bitcode {\n+        modules_config.emit_bc = true;\n+    }\n+\n+    for output_type in output_types.iter() {\n+        match *output_type {\n+            OutputTypeBitcode => { modules_config.emit_bc = true; },\n+            OutputTypeLlvmAssembly => { modules_config.emit_ir = true; },\n+            OutputTypeAssembly => {\n+                modules_config.emit_asm = true;\n+                // If we're not using the LLVM assembler, this function\n+                // could be invoked specially with output_type_assembly, so\n+                // in this case we still want the metadata object file.\n+                if !sess.opts.output_types.contains(&OutputTypeAssembly) {\n+                    metadata_config.emit_obj = true;\n+                }\n+            },\n+            OutputTypeObject => { modules_config.emit_obj = true; },\n+            OutputTypeExe => {\n+                modules_config.emit_obj = true;\n+                metadata_config.emit_obj = true;\n+            },\n+        }\n+    }\n+\n+    modules_config.set_flags(sess, trans);\n+    metadata_config.set_flags(sess, trans);\n+\n+\n+    // Populate a buffer with a list of codegen tasks.  Items are processed in\n+    // LIFO order, just because it's a tiny bit simpler that way.  (The order\n+    // doesn't actually matter.)\n+    let mut work_items = Vec::with_capacity(1 + trans.modules.len());\n+\n+    {\n+        let work = build_work_item(sess,\n+                                   trans.metadata_module,\n+                                   metadata_config.clone(),\n+                                   crate_output.clone(),\n+                                   \"metadata\".to_string());\n+        work_items.push(work);\n+    }\n+\n+    for (index, mtrans) in trans.modules.iter().enumerate() {\n+        let work = build_work_item(sess,\n+                                   *mtrans,\n+                                   modules_config.clone(),\n+                                   crate_output.clone(),\n+                                   format!(\"{}\", index));\n+        work_items.push(work);\n+    }\n+\n+    // Process the work items, optionally using worker threads.\n+    if sess.opts.cg.codegen_units == 1 {\n+        run_work_singlethreaded(sess, trans.reachable.as_slice(), work_items);\n+\n+        if needs_crate_bitcode {\n+            // The only bitcode file produced (aside from metadata) was\n+            // \"crate.0.bc\".  Rename to \"crate.bc\" since that's what\n+            // `link_rlib` expects to find.\n+            fs::copy(&crate_output.with_extension(\"0.bc\"),\n+                     &crate_output.temp_path(OutputTypeBitcode)).unwrap();\n+        }\n+    } else {\n+        run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n+\n+        assert!(!needs_crate_bitcode,\n+               \"can't produce a crate bitcode file from multiple compilation units\");\n+    }\n+\n+    // All codegen is finished.\n+    unsafe {\n+        llvm::LLVMRustDisposeTargetMachine(tm);\n+    }\n+\n+    // Produce final compile outputs.\n+\n+    let copy_if_one_unit = |ext: &str, output_type: OutputType| {\n+        // Three cases:\n+        if sess.opts.cg.codegen_units == 1 {\n+            // 1) Only one codegen unit.  In this case it's no difficulty\n+            //    to copy `foo.0.x` to `foo.x`.\n+            fs::copy(&crate_output.with_extension(ext),\n+                     &crate_output.path(output_type)).unwrap();\n+            if !sess.opts.cg.save_temps {\n+                // The user just wants `foo.x`, not `foo.0.x`.\n+                remove(sess, &crate_output.with_extension(ext));\n+            }\n+        } else {\n+            if crate_output.single_output_file.is_some() {\n+                // 2) Multiple codegen units, with `-o some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(format!(\"ignoring -o because multiple .{} files were produced\",\n+                                  ext).as_slice());\n+            } else {\n+                // 3) Multiple codegen units, but no `-o some_name`.  We\n+                //    just leave the `foo.0.x` files in place.\n+                // (We don't have to do any work in this case.)\n+            }\n+        }\n+    };\n+\n+    let link_obj = |output_path: &Path| {\n+        // Running `ld -r` on a single input is kind of pointless.\n+        if sess.opts.cg.codegen_units == 1 {\n+            fs::copy(&crate_output.with_extension(\"0.o\"),\n+                     output_path).unwrap();\n+            // Leave the .0.o file around, to mimic the behavior of the normal\n+            // code path.\n+            return;\n+        }\n+\n+        // Some builds of MinGW GCC will pass --force-exe-suffix to ld, which\n+        // will automatically add a .exe extension if the extension is not\n+        // already .exe or .dll.  To ensure consistent behavior on Windows, we\n+        // add the .exe suffix explicitly and then rename the output file to\n+        // the desired path.  This will give the correct behavior whether or\n+        // not GCC adds --force-exe-suffix.\n+        let windows_output_path =\n+            if sess.targ_cfg.os == abi::OsWindows {\n+                Some(output_path.with_extension(\"o.exe\"))\n+            } else {\n+                None\n+            };\n+\n+        let pname = get_cc_prog(sess);\n+        let mut cmd = Command::new(pname.as_slice());\n+\n+        cmd.args(sess.targ_cfg.target_strs.cc_args.as_slice());\n+        cmd.arg(\"-nostdlib\");\n+\n+        for index in range(0, trans.modules.len()) {\n+            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index).as_slice()));\n+        }\n+\n+        cmd.arg(\"-r\")\n+           .arg(\"-o\")\n+           .arg(windows_output_path.as_ref().unwrap_or(output_path));\n+\n+        if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n+            println!(\"{}\", &cmd);\n+        }\n+\n+        cmd.stdin(::std::io::process::Ignored)\n+           .stdout(::std::io::process::InheritFd(1))\n+           .stderr(::std::io::process::InheritFd(2));\n+        match cmd.status() {\n+            Ok(_) => {},\n+            Err(e) => {\n+                sess.err(format!(\"could not exec the linker `{}`: {}\",\n+                                 pname,\n+                                 e).as_slice());\n+                sess.abort_if_errors();\n+            },\n+        }\n+\n+        match windows_output_path {\n+            Some(ref windows_path) => {\n+                fs::rename(windows_path, output_path).unwrap();\n+            },\n+            None => {\n+                // The file is already named according to `output_path`.\n+            }\n+        }\n+    };\n+\n+    // Flag to indicate whether the user explicitly requested bitcode.\n+    // Otherwise, we produced it only as a temporary output, and will need\n+    // to get rid of it.\n+    // FIXME: Since we don't support LTO anyway, maybe we can avoid\n+    // producing the temporary .0.bc's in the first place?\n+    let mut save_bitcode = false;\n+    for output_type in output_types.iter() {\n+        match *output_type {\n+            OutputTypeBitcode => {\n+                save_bitcode = true;\n+                copy_if_one_unit(\"0.bc\", OutputTypeBitcode);\n+            },\n+            OutputTypeLlvmAssembly => { copy_if_one_unit(\"0.ll\", OutputTypeLlvmAssembly); },\n+            OutputTypeAssembly => { copy_if_one_unit(\"0.s\", OutputTypeAssembly); },\n+            OutputTypeObject => { link_obj(&crate_output.path(OutputTypeObject)); },\n+            OutputTypeExe => {\n+                // If OutputTypeObject is already in the list, then\n+                // `crate.o` will be handled by the OutputTypeObject case.\n+                // Otherwise, we need to create the temporary object so we\n+                // can run the linker.\n+                if !sess.opts.output_types.contains(&OutputTypeObject) {\n+                    link_obj(&crate_output.temp_path(OutputTypeObject));\n+                }\n+            },\n+        }\n+    }\n+    let save_bitcode = save_bitcode;\n+\n+    // Clean up unwanted temporary files.\n+\n+    // We create the following files by default:\n+    //  - crate.0.bc\n+    //  - crate.0.o\n+    //  - crate.metadata.bc\n+    //  - crate.metadata.o\n+    //  - crate.o (linked from crate.##.o)\n+    //  - crate.bc (copied from crate.0.bc)\n+    // We may create additional files if requested by the user (through\n+    // `-C save-temps` or `--emit=` flags).\n+\n+    if !sess.opts.cg.save_temps {\n+        // Remove the temporary .0.o objects.  If the user didn't\n+        // explicitly request bitcode (with --emit=bc), we must remove\n+        // .0.bc as well.  (We don't touch the crate.bc that may have been\n+        // produced earlier.)\n+        for i in range(0, trans.modules.len()) {\n+            if modules_config.emit_obj {\n+                let ext = format!(\"{}.o\", i);\n+                remove(sess, &crate_output.with_extension(ext.as_slice()));\n+            }\n+\n+            if modules_config.emit_bc && !save_bitcode {\n+                let ext = format!(\"{}.bc\", i);\n+                remove(sess, &crate_output.with_extension(ext.as_slice()));\n+            }\n+        }\n+\n+        if metadata_config.emit_bc && !save_bitcode {\n+            remove(sess, &crate_output.with_extension(\"metadata.bc\"));\n+        }\n+    }\n+\n+    // We leave the following files around by default:\n+    //  - crate.o\n+    //  - crate.metadata.o\n+    //  - crate.bc\n+    // These are used in linking steps and will be cleaned up afterward.\n+\n+    // FIXME: time_llvm_passes support - does this use a global context or\n+    // something?\n+    //if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n+}\n+\n+type WorkItem = proc(&CodegenContext):Send;\n+\n+fn build_work_item(sess: &Session,\n+                   mtrans: ModuleTranslation,\n+                   config: ModuleConfig,\n+                   output_names: OutputFilenames,\n+                   name_extra: String) -> WorkItem {\n+    let mut config = config;\n+    config.tm = create_target_machine(sess);\n+\n+    proc(cgcx) unsafe {\n+        optimize_and_codegen(cgcx, mtrans, config, name_extra, output_names);\n+    }\n+}\n+\n+fn run_work_singlethreaded(sess: &Session,\n+                           reachable: &[String],\n+                           work_items: Vec<WorkItem>) {\n+    let cgcx = CodegenContext::new_with_session(sess, reachable);\n+    let mut work_items = work_items;\n+\n+    // Since we're running single-threaded, we can pass the session to\n+    // the proc, allowing `optimize_and_codegen` to perform LTO.\n+    for work in Unfold::new((), |_| work_items.pop()) {\n+        work(&cgcx);\n+    }\n+}\n+\n+fn run_work_multithreaded(sess: &Session,\n+                          work_items: Vec<WorkItem>,\n+                          num_workers: uint) {\n+    // Run some workers to process the work items.\n+    let work_items_arc = Arc::new(Mutex::new(work_items));\n+    let mut diag_emitter = SharedEmitter::new();\n+    let mut futures = Vec::with_capacity(num_workers);\n+\n+    for i in range(0, num_workers) {\n+        let work_items_arc = work_items_arc.clone();\n+        let diag_emitter = diag_emitter.clone();\n+\n+        let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(proc() {\n+            let diag_handler = mk_handler(box diag_emitter);\n+\n+            // Must construct cgcx inside the proc because it has non-Send\n+            // fields.\n+            let cgcx = CodegenContext::new(&diag_handler);\n+\n+            loop {\n+                // Avoid holding the lock for the entire duration of the match.\n+                let maybe_work = work_items_arc.lock().pop();\n+                match maybe_work {\n+                    Some(work) => {\n+                        work(&cgcx);\n+\n+                        // Make sure to fail the worker so the main thread can\n+                        // tell that there were errors.\n+                        cgcx.handler.abort_if_errors();\n+                    }\n+                    None => break,\n+                }\n+            }\n+        });\n+        futures.push(future);\n+    }\n+\n+    let mut failed = false;\n+    for future in futures.move_iter() {\n+        match future.unwrap() {\n+            Ok(()) => {},\n+            Err(_) => {\n+                failed = true;\n+            },\n+        }\n+        // Display any new diagnostics.\n+        diag_emitter.dump(sess.diagnostic().handler());\n+    }\n+    if failed {\n+        sess.fatal(\"aborting due to worker thread failure\");\n+    }\n+}\n+\n+pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n+    let pname = get_cc_prog(sess);\n+    let mut cmd = Command::new(pname.as_slice());\n+\n+    cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(OutputTypeObject))\n+                           .arg(outputs.temp_path(OutputTypeAssembly));\n+    debug!(\"{}\", &cmd);\n+\n+    match cmd.output() {\n+        Ok(prog) => {\n+            if !prog.status.success() {\n+                sess.err(format!(\"linking with `{}` failed: {}\",\n+                                 pname,\n+                                 prog.status).as_slice());\n+                sess.note(format!(\"{}\", &cmd).as_slice());\n+                let mut note = prog.error.clone();\n+                note.push_all(prog.output.as_slice());\n+                sess.note(str::from_utf8(note.as_slice()).unwrap());\n+                sess.abort_if_errors();\n+            }\n+        },\n+        Err(e) => {\n+            sess.err(format!(\"could not exec the linker `{}`: {}\",\n+                             pname,\n+                             e).as_slice());\n+            sess.abort_if_errors();\n+        }\n+    }\n+}\n+\n+unsafe fn configure_llvm(sess: &Session) {\n+    use std::sync::{Once, ONCE_INIT};\n+    static mut INIT: Once = ONCE_INIT;\n+\n+    // Copy what clang does by turning on loop vectorization at O2 and\n+    // slp vectorization at O3\n+    let vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n+                         (sess.opts.optimize == config::Default ||\n+                          sess.opts.optimize == config::Aggressive);\n+    let vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n+                        sess.opts.optimize == config::Aggressive;\n+\n+    let mut llvm_c_strs = Vec::new();\n+    let mut llvm_args = Vec::new();\n+    {\n+        let add = |arg: &str| {\n+            let s = arg.to_c_str();\n+            llvm_args.push(s.as_ptr());\n+            llvm_c_strs.push(s);\n+        };\n+        add(\"rustc\"); // fake program name\n+        if vectorize_loop { add(\"-vectorize-loops\"); }\n+        if vectorize_slp  { add(\"-vectorize-slp\");   }\n+        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n+        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n+\n+        for arg in sess.opts.cg.llvm_args.iter() {\n+            add((*arg).as_slice());\n+        }\n+    }\n+\n+    INIT.doit(|| {\n+        llvm::LLVMInitializePasses();\n+\n+        // Only initialize the platforms supported by Rust here, because\n+        // using --llvm-root will have multiple platforms that rustllvm\n+        // doesn't actually link to and it's pointless to put target info\n+        // into the registry that Rust cannot generate machine code for.\n+        llvm::LLVMInitializeX86TargetInfo();\n+        llvm::LLVMInitializeX86Target();\n+        llvm::LLVMInitializeX86TargetMC();\n+        llvm::LLVMInitializeX86AsmPrinter();\n+        llvm::LLVMInitializeX86AsmParser();\n+\n+        llvm::LLVMInitializeARMTargetInfo();\n+        llvm::LLVMInitializeARMTarget();\n+        llvm::LLVMInitializeARMTargetMC();\n+        llvm::LLVMInitializeARMAsmPrinter();\n+        llvm::LLVMInitializeARMAsmParser();\n+\n+        llvm::LLVMInitializeMipsTargetInfo();\n+        llvm::LLVMInitializeMipsTarget();\n+        llvm::LLVMInitializeMipsTargetMC();\n+        llvm::LLVMInitializeMipsAsmPrinter();\n+        llvm::LLVMInitializeMipsAsmParser();\n+\n+        llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n+                                     llvm_args.as_ptr());\n+    });\n+}\n+\n+unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n+                               mpm: llvm::PassManagerRef,\n+                               llmod: ModuleRef,\n+                               opt: llvm::CodeGenOptLevel,\n+                               no_builtins: bool) {\n+    // Create the PassManagerBuilder for LLVM. We configure it with\n+    // reasonable defaults and prepare it to actually populate the pass\n+    // manager.\n+    let builder = llvm::LLVMPassManagerBuilderCreate();\n+    match opt {\n+        llvm::CodeGenLevelNone => {\n+            // Don't add lifetime intrinsics at O0\n+            llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n+        }\n+        llvm::CodeGenLevelLess => {\n+            llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n+        }\n+        // numeric values copied from clang\n+        llvm::CodeGenLevelDefault => {\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n+                                                                225);\n+        }\n+        llvm::CodeGenLevelAggressive => {\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n+                                                                275);\n+        }\n+    }\n+    llvm::LLVMPassManagerBuilderSetOptLevel(builder, opt as c_uint);\n+    llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, no_builtins);\n+\n+    // Use the builder to populate the function/module pass managers.\n+    llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);\n+    llvm::LLVMPassManagerBuilderPopulateModulePassManager(builder, mpm);\n+    llvm::LLVMPassManagerBuilderDispose(builder);\n+\n+    match opt {\n+        llvm::CodeGenLevelDefault | llvm::CodeGenLevelAggressive => {\n+            \"mergefunc\".with_c_str(|s| llvm::LLVMRustAddPass(mpm, s));\n+        }\n+        _ => {}\n+    };\n+}"}, {"sha": "3e3a88ceffd67f1810d4458fe55424f856febc1a", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -16,7 +16,7 @@ use driver::driver;\n use driver::session::Session;\n \n use back;\n-use back::link;\n+use back::write;\n use back::target_strs;\n use back::{arm, x86, x86_64, mips, mipsel};\n use lint;\n@@ -72,7 +72,7 @@ pub struct Options {\n     pub debuginfo: DebugInfoLevel,\n     pub lint_opts: Vec<(String, lint::Level)>,\n     pub describe_lints: bool,\n-    pub output_types: Vec<back::link::OutputType> ,\n+    pub output_types: Vec<back::write::OutputType> ,\n     // This was mutable for rustpkg, which updates search paths based on the\n     // parsed code. It remains mutable in case its replacements wants to use\n     // this.\n@@ -303,6 +303,13 @@ macro_rules! cgoptions(\n             }\n         }\n \n+        fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n+            use std::from_str::FromStr;\n+            match v.and_then(FromStr::from_str) {\n+                Some(i) => { *slot = i; true },\n+                None => false\n+            }\n+        }\n     }\n ) )\n \n@@ -347,6 +354,8 @@ cgoptions!(\n          \"metadata to mangle symbol names with\"),\n     extra_filename: String = (\"\".to_string(), parse_string,\n          \"extra data to put in each output filename\"),\n+    codegen_units: uint = (1, parse_uint,\n+        \"divide crate into N units to optimize in parallel\"),\n )\n \n pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n@@ -646,11 +655,11 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         for unparsed_output_type in unparsed_output_types.iter() {\n             for part in unparsed_output_type.as_slice().split(',') {\n                 let output_type = match part.as_slice() {\n-                    \"asm\"  => link::OutputTypeAssembly,\n-                    \"ir\"   => link::OutputTypeLlvmAssembly,\n-                    \"bc\"   => link::OutputTypeBitcode,\n-                    \"obj\"  => link::OutputTypeObject,\n-                    \"link\" => link::OutputTypeExe,\n+                    \"asm\"  => write::OutputTypeAssembly,\n+                    \"ir\"   => write::OutputTypeLlvmAssembly,\n+                    \"bc\"   => write::OutputTypeBitcode,\n+                    \"obj\"  => write::OutputTypeObject,\n+                    \"link\" => write::OutputTypeExe,\n                     _ => {\n                         early_error(format!(\"unknown emission type: `{}`\",\n                                             part).as_slice())\n@@ -663,7 +672,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     output_types.as_mut_slice().sort();\n     output_types.dedup();\n     if output_types.len() == 0 {\n-        output_types.push(link::OutputTypeExe);\n+        output_types.push(write::OutputTypeExe);\n     }\n \n     let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| Path::new(m));"}, {"sha": "09bf69bff4cdd5ee5ef8d5b69e1057faec1ef8dd", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -10,6 +10,7 @@\n \n \n use back::link;\n+use back::write;\n use driver::session::Session;\n use driver::config;\n use front;\n@@ -441,10 +442,14 @@ pub fn phase_save_analysis(sess: &Session,\n          middle::save::process_crate(sess, krate, analysis, odir));\n }\n \n+pub struct ModuleTranslation {\n+    pub llcx: ContextRef,\n+    pub llmod: ModuleRef,\n+}\n+\n pub struct CrateTranslation {\n-    pub context: ContextRef,\n-    pub module: ModuleRef,\n-    pub metadata_module: ModuleRef,\n+    pub modules: Vec<ModuleTranslation>,\n+    pub metadata_module: ModuleTranslation,\n     pub link: LinkMeta,\n     pub metadata: Vec<u8>,\n     pub reachable: Vec<String>,\n@@ -472,23 +477,23 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: &CrateTranslation,\n                                outputs: &OutputFilenames) {\n     if sess.opts.cg.no_integrated_as {\n-        let output_type = link::OutputTypeAssembly;\n+        let output_type = write::OutputTypeAssembly;\n \n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n-            link::write::run_passes(sess, trans, [output_type], outputs));\n+            write::run_passes(sess, trans, [output_type], outputs));\n \n-        link::write::run_assembler(sess, outputs);\n+        write::run_assembler(sess, outputs);\n \n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.cg.save_temps {\n-            fs::unlink(&outputs.temp_path(link::OutputTypeAssembly)).unwrap();\n+            fs::unlink(&outputs.temp_path(write::OutputTypeAssembly)).unwrap();\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n-            link::write::run_passes(sess,\n-                                    trans,\n-                                    sess.opts.output_types.as_slice(),\n-                                    outputs));\n+            write::run_passes(sess,\n+                              trans,\n+                              sess.opts.output_types.as_slice(),\n+                              outputs));\n     }\n }\n \n@@ -532,7 +537,7 @@ pub fn stop_after_phase_2(sess: &Session) -> bool {\n }\n \n pub fn stop_after_phase_5(sess: &Session) -> bool {\n-    if !sess.opts.output_types.iter().any(|&i| i == link::OutputTypeExe) {\n+    if !sess.opts.output_types.iter().any(|&i| i == write::OutputTypeExe) {\n         debug!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n@@ -548,7 +553,7 @@ fn write_out_deps(sess: &Session,\n     for output_type in sess.opts.output_types.iter() {\n         let file = outputs.path(*output_type);\n         match *output_type {\n-            link::OutputTypeExe => {\n+            write::OutputTypeExe => {\n                 for output in sess.crate_types.borrow().iter() {\n                     let p = link::filename_for_input(sess, *output,\n                                                      id, &file);\n@@ -679,6 +684,7 @@ pub fn collect_crate_metadata(session: &Session,\n     session.opts.cg.metadata.clone()\n }\n \n+#[deriving(Clone)]\n pub struct OutputFilenames {\n     pub out_directory: Path,\n     pub out_filestem: String,\n@@ -687,22 +693,22 @@ pub struct OutputFilenames {\n }\n \n impl OutputFilenames {\n-    pub fn path(&self, flavor: link::OutputType) -> Path {\n+    pub fn path(&self, flavor: write::OutputType) -> Path {\n         match self.single_output_file {\n             Some(ref path) => return path.clone(),\n             None => {}\n         }\n         self.temp_path(flavor)\n     }\n \n-    pub fn temp_path(&self, flavor: link::OutputType) -> Path {\n+    pub fn temp_path(&self, flavor: write::OutputType) -> Path {\n         let base = self.out_directory.join(self.filestem());\n         match flavor {\n-            link::OutputTypeBitcode => base.with_extension(\"bc\"),\n-            link::OutputTypeAssembly => base.with_extension(\"s\"),\n-            link::OutputTypeLlvmAssembly => base.with_extension(\"ll\"),\n-            link::OutputTypeObject => base.with_extension(\"o\"),\n-            link::OutputTypeExe => base,\n+            write::OutputTypeBitcode => base.with_extension(\"bc\"),\n+            write::OutputTypeAssembly => base.with_extension(\"s\"),\n+            write::OutputTypeLlvmAssembly => base.with_extension(\"ll\"),\n+            write::OutputTypeObject => base.with_extension(\"o\"),\n+            write::OutputTypeExe => base,\n         }\n     }\n "}, {"sha": "e4eac80c4afd92ab06d3a62acdbc640b79caf136", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -69,6 +69,7 @@ pub mod back {\n \n     pub mod link;\n     pub mod lto;\n+    pub mod write;\n \n }\n "}, {"sha": "da73f25b6d164be2b91305a679f52a4cc4f14996", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -892,7 +892,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                                 IITraitItemRef(local_def(parent_id),\n                                                RequiredInlinedTraitItemRef(\n                                                    &*ast_method)));\n-        } else {\n+        }\n+        if !any_types {\n             encode_symbol(ecx, rbml_w, m.def_id.node);\n         }\n         encode_method_argument_names(rbml_w, &*ast_method.pe_fn_decl());\n@@ -1047,7 +1048,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, item.attrs.as_slice());\n         if tps_len > 0u || should_inline(item.attrs.as_slice()) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n-        } else {\n+        }\n+        if tps_len == 0 {\n             encode_symbol(ecx, rbml_w, item.id);\n         }\n         encode_visibility(rbml_w, vis);\n@@ -1411,9 +1413,8 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_name(rbml_w, nitem.ident.name);\n         if abi == abi::RustIntrinsic {\n             encode_inlined_item(ecx, rbml_w, IIForeignRef(nitem));\n-        } else {\n-            encode_symbol(ecx, rbml_w, nitem.id);\n         }\n+        encode_symbol(ecx, rbml_w, nitem.id);\n       }\n       ForeignItemStatic(_, mutbl) => {\n         if mutbl {"}, {"sha": "1b93e1974419cf75998be04a729075e5fce77a71", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -563,7 +563,7 @@ fn get_branches<'a>(bcx: &'a Block, m: &[Match], col: uint) -> Vec<Opt<'a>> {\n             }\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n-                let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n+                let opt_def = ccx.tcx().def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = ty::enum_variant_with_id(ccx.tcx(), enum_id, var_id);"}, {"sha": "21673a67ea8ac487343927de74e59912717f22e6", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -150,14 +150,14 @@ pub fn represent_node(bcx: &Block, node: ast::NodeId) -> Rc<Repr> {\n /// Decides how to represent a given type.\n pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n-    match cx.adt_reprs.borrow().find(&t) {\n+    match cx.adt_reprs().borrow().find(&t) {\n         Some(repr) => return repr.clone(),\n         None => {}\n     }\n \n     let repr = Rc::new(represent_type_uncached(cx, t));\n     debug!(\"Represented as: {:?}\", repr)\n-    cx.adt_reprs.borrow_mut().insert(t, repr.clone());\n+    cx.adt_reprs().borrow_mut().insert(t, repr.clone());\n     repr\n }\n \n@@ -423,7 +423,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             attempts = choose_shortest;\n         },\n         attr::ReprPacked => {\n-            cx.tcx.sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n+            cx.tcx().sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n         }\n     }\n     for &ity in attempts.iter() {"}, {"sha": "49e058333e523212c068aede51b0559f1209dd20", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 331, "deletions": 171, "changes": 502, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -29,7 +29,7 @@ use back::link::{mangle_exported_name};\n use back::{link, abi};\n use driver::config;\n use driver::config::{NoDebugInfo, FullDebugInfo};\n-use driver::driver::{CrateAnalysis, CrateTranslation};\n+use driver::driver::{CrateAnalysis, CrateTranslation, ModuleTranslation};\n use driver::session::Session;\n use lint;\n use llvm::{BasicBlockRef, ModuleRef, ValueRef, Vector, get_param};\n@@ -47,15 +47,16 @@ use middle::trans::builder::{Builder, noname};\n use middle::trans::callee;\n use middle::trans::cleanup::{CleanupMethods, ScopeId};\n use middle::trans::cleanup;\n-use middle::trans::common::{Block, C_bool, C_bytes, C_i32, C_integral, C_nil};\n-use middle::trans::common::{C_null, C_struct, C_u64, C_u8, C_uint, C_undef};\n+use middle::trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral, C_nil};\n+use middle::trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_uint, C_undef};\n use middle::trans::common::{CrateContext, ExternMap, FunctionContext};\n use middle::trans::common::{NodeInfo, Result, SubstP, monomorphize_type};\n use middle::trans::common::{node_id_type, param_substs, return_type_is_void};\n use middle::trans::common::{tydesc_info, type_is_immediate};\n use middle::trans::common::{type_is_zero_size, val_ty};\n use middle::trans::common;\n use middle::trans::consts;\n+use middle::trans::context::SharedCrateContext;\n use middle::trans::controlflow;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n@@ -84,6 +85,7 @@ use arena::TypedArena;\n use libc::{c_uint, uint64_t};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n+use std::collections::HashSet;\n use std::rc::Rc;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel, Rust, RustCall};\n@@ -136,7 +138,7 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n }\n \n pub struct StatRecorder<'a> {\n-    ccx: &'a CrateContext,\n+    ccx: &'a CrateContext<'a>,\n     name: Option<String>,\n     start: u64,\n     istart: uint,\n@@ -149,7 +151,7 @@ impl<'a> StatRecorder<'a> {\n         } else {\n             0\n         };\n-        let istart = ccx.stats.n_llvm_insns.get();\n+        let istart = ccx.stats().n_llvm_insns.get();\n         StatRecorder {\n             ccx: ccx,\n             name: Some(name),\n@@ -165,13 +167,13 @@ impl<'a> Drop for StatRecorder<'a> {\n         if self.ccx.sess().trans_stats() {\n             let end = time::precise_time_ns();\n             let elapsed = ((end - self.start) / 1_000_000) as uint;\n-            let iend = self.ccx.stats.n_llvm_insns.get();\n-            self.ccx.stats.fn_stats.borrow_mut().push((self.name.take().unwrap(),\n+            let iend = self.ccx.stats().n_llvm_insns.get();\n+            self.ccx.stats().fn_stats.borrow_mut().push((self.name.take().unwrap(),\n                                                        elapsed,\n                                                        iend - self.istart));\n-            self.ccx.stats.n_fns.set(self.ccx.stats.n_fns.get() + 1);\n+            self.ccx.stats().n_fns.set(self.ccx.stats().n_fns.get() + 1);\n             // Reset LLVM insn count to avoid compound costs.\n-            self.ccx.stats.n_llvm_insns.set(self.istart);\n+            self.ccx.stats().n_llvm_insns.set(self.istart);\n         }\n     }\n }\n@@ -182,7 +184,7 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n \n     let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMGetOrInsertFunction(ccx.llmod, buf, ty.to_ref())\n+            llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf, ty.to_ref())\n         }\n     });\n \n@@ -198,7 +200,7 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n         _ => {}\n     }\n \n-    if ccx.tcx.sess.opts.cg.no_redzone {\n+    if ccx.tcx().sess.opts.cg.no_redzone {\n         unsafe {\n             llvm::LLVMAddFunctionAttribute(llfn,\n                                            llvm::FunctionIndex as c_uint,\n@@ -243,7 +245,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n }\n \n fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::DefId) -> ValueRef {\n-    match ccx.externs.borrow().find_equiv(&name) {\n+    match ccx.externs().borrow().find_equiv(&name) {\n         Some(n) => return *n,\n         None => ()\n     }\n@@ -254,7 +256,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n         set_llvm_fn_attrs(attrs.as_slice(), f)\n     });\n \n-    ccx.externs.borrow_mut().insert(name.to_string(), f);\n+    ccx.externs().borrow_mut().insert(name.to_string(), f);\n     f\n }\n \n@@ -264,22 +266,22 @@ pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n     let unboxed_closure_type = ty::mk_unboxed_closure(ccx.tcx(),\n                                                       closure_id,\n                                                       ty::ReStatic);\n-    let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+    let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n     let unboxed_closure = unboxed_closures.get(&closure_id);\n     match unboxed_closure.kind {\n         ty::FnUnboxedClosureKind => {\n-            ty::mk_imm_rptr(&ccx.tcx, ty::ReStatic, unboxed_closure_type)\n+            ty::mk_imm_rptr(ccx.tcx(), ty::ReStatic, unboxed_closure_type)\n         }\n         ty::FnMutUnboxedClosureKind => {\n-            ty::mk_mut_rptr(&ccx.tcx, ty::ReStatic, unboxed_closure_type)\n+            ty::mk_mut_rptr(ccx.tcx(), ty::ReStatic, unboxed_closure_type)\n         }\n         ty::FnOnceUnboxedClosureKind => unboxed_closure_type,\n     }\n }\n \n pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n                                 -> ty::UnboxedClosureKind {\n-    let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+    let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n     unboxed_closures.get(&closure_id).kind\n }\n \n@@ -292,7 +294,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n             (f.sig.inputs.clone(), f.sig.output, f.abi, Some(Type::i8p(ccx)))\n         }\n         ty::ty_unboxed_closure(closure_did, _) => {\n-            let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+            let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let unboxed_closure = unboxed_closures.get(&closure_did);\n             let function_type = unboxed_closure.closure_type.clone();\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did);\n@@ -308,7 +310,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n     let llfty = type_of_rust_fn(ccx, env, inputs.as_slice(), output, abi);\n     debug!(\"decl_rust_fn(input count={},type={})\",\n            inputs.len(),\n-           ccx.tn.type_to_string(llfty));\n+           ccx.tn().type_to_string(llfty));\n \n     let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, output);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n@@ -413,15 +415,15 @@ pub fn malloc_raw_dyn_managed<'a>(\n // Type descriptor and type glue stuff\n \n pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> Rc<tydesc_info> {\n-    match ccx.tydescs.borrow().find(&t) {\n+    match ccx.tydescs().borrow().find(&t) {\n         Some(inf) => return inf.clone(),\n         _ => { }\n     }\n \n-    ccx.stats.n_static_tydescs.set(ccx.stats.n_static_tydescs.get() + 1u);\n+    ccx.stats().n_static_tydescs.set(ccx.stats().n_static_tydescs.get() + 1u);\n     let inf = Rc::new(glue::declare_tydesc(ccx, t));\n \n-    ccx.tydescs.borrow_mut().insert(t, inf.clone());\n+    ccx.tydescs().borrow_mut().insert(t, inf.clone());\n     inf\n }\n \n@@ -492,10 +494,10 @@ pub fn unset_split_stack(f: ValueRef) {\n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n-    if ccx.all_llvm_symbols.borrow().contains(&sym) {\n+    if ccx.all_llvm_symbols().borrow().contains(&sym) {\n         ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).as_slice());\n     }\n-    ccx.all_llvm_symbols.borrow_mut().insert(sym);\n+    ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n \n \n@@ -532,7 +534,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         let dtor_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n                                      [glue::get_drop_glue_type(ccx, t)], ty::mk_nil());\n         get_extern_fn(ccx,\n-                      &mut *ccx.externs.borrow_mut(),\n+                      &mut *ccx.externs().borrow_mut(),\n                       name.as_slice(),\n                       llvm::CCallConv,\n                       llty,\n@@ -961,8 +963,8 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n-            get_extern_const(&mut *ccx.externs.borrow_mut(),\n-                             ccx.llmod,\n+            get_extern_const(&mut *ccx.externs().borrow_mut(),\n+                             ccx.llmod(),\n                              name.as_slice(),\n                              llty)\n         }\n@@ -1165,7 +1167,7 @@ pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef,\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = PointerCast(cx, src, Type::i8p(ccx));\n     let dst_ptr = PointerCast(cx, dst, Type::i8p(ccx));\n-    let size = IntCast(cx, n_bytes, ccx.int_type);\n+    let size = IntCast(cx, n_bytes, ccx.int_type());\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], None);\n@@ -1426,7 +1428,7 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n            if id == -1 {\n                \"\".to_string()\n            } else {\n-               ccx.tcx.map.path_to_string(id).to_string()\n+               ccx.tcx().map.path_to_string(id).to_string()\n            },\n            id, param_substs.repr(ccx.tcx()));\n \n@@ -1786,7 +1788,7 @@ pub fn trans_closure(ccx: &CrateContext,\n                      is_unboxed_closure: IsUnboxedClosureFlag,\n                      maybe_load_env: <'a>|&'a Block<'a>, ScopeId|\n                                          -> &'a Block<'a>) {\n-    ccx.stats.n_closures.set(ccx.stats.n_closures.get() + 1);\n+    ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n@@ -1820,7 +1822,7 @@ pub fn trans_closure(ccx: &CrateContext,\n                ty_to_string(ccx.tcx(), *monomorphized_arg_type));\n     }\n     debug!(\"trans_closure: function lltype: {}\",\n-           bcx.fcx.ccx.tn.val_to_string(bcx.fcx.llfn));\n+           bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n@@ -1912,7 +1914,7 @@ pub fn trans_fn(ccx: &CrateContext,\n                 param_substs: &param_substs,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_string(id).to_string());\n+    let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n@@ -1958,7 +1960,7 @@ pub fn trans_named_tuple_constructor<'a>(mut bcx: &'a Block<'a>,\n                                          dest: expr::Dest) -> Result<'a> {\n \n     let ccx = bcx.fcx.ccx;\n-    let tcx = &ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n@@ -2064,7 +2066,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n-    let levels = ccx.tcx.node_lint_levels.borrow();\n+    let levels = ccx.tcx().node_lint_levels.borrow();\n     let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCE);\n     let lvlsrc = match levels.find(&(id, lint_id)) {\n         None | Some(&(lint::Allow, _)) => return,\n@@ -2114,7 +2116,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n }\n \n pub struct TransItemVisitor<'a> {\n-    pub ccx: &'a CrateContext,\n+    pub ccx: &'a CrateContext<'a>,\n }\n \n impl<'a> Visitor<()> for TransItemVisitor<'a> {\n@@ -2123,29 +2125,95 @@ impl<'a> Visitor<()> for TransItemVisitor<'a> {\n     }\n }\n \n+/// Enum describing the origin of an LLVM `Value`, for linkage purposes.\n+pub enum ValueOrigin {\n+    /// The LLVM `Value` is in this context because the corresponding item was\n+    /// assigned to the current compilation unit.\n+    OriginalTranslation,\n+    /// The `Value`'s corresponding item was assigned to some other compilation\n+    /// unit, but the `Value` was translated in this context anyway because the\n+    /// item is marked `#[inline]`.\n+    InlinedCopy,\n+}\n+\n+/// Set the appropriate linkage for an LLVM `ValueRef` (function or global).\n+/// If the `llval` is the direct translation of a specific Rust item, `id`\n+/// should be set to the `NodeId` of that item.  (This mapping should be\n+/// 1-to-1, so monomorphizations and drop/visit glue should have `id` set to\n+/// `None`.)  `llval_origin` indicates whether `llval` is the translation of an\n+/// item assigned to `ccx`'s compilation unit or an inlined copy of an item\n+/// assigned to a different compilation unit.\n+pub fn update_linkage(ccx: &CrateContext,\n+                      llval: ValueRef,\n+                      id: Option<ast::NodeId>,\n+                      llval_origin: ValueOrigin) {\n+    match llval_origin {\n+        InlinedCopy => {\n+            // `llval` is a translation of an item defined in a separate\n+            // compilation unit.  This only makes sense if there are at least\n+            // two compilation units.\n+            assert!(ccx.sess().opts.cg.codegen_units > 1);\n+            // `llval` is a copy of something defined elsewhere, so use\n+            // `AvailableExternallyLinkage` to avoid duplicating code in the\n+            // output.\n+            llvm::SetLinkage(llval, llvm::AvailableExternallyLinkage);\n+            return;\n+        },\n+        OriginalTranslation => {},\n+    }\n+\n+    match id {\n+        Some(id) if ccx.reachable().contains(&id) => {\n+            llvm::SetLinkage(llval, llvm::ExternalLinkage);\n+        },\n+        _ => {\n+            // `id` does not refer to an item in `ccx.reachable`.\n+            if ccx.sess().opts.cg.codegen_units > 1 {\n+                llvm::SetLinkage(llval, llvm::ExternalLinkage);\n+            } else {\n+                llvm::SetLinkage(llval, llvm::InternalLinkage);\n+            }\n+        },\n+    }\n+}\n+\n pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n+\n+    let from_external = ccx.external_srcs().borrow().contains_key(&item.id);\n+\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let llfn = get_item_val(ccx, item.id);\n-            if abi != Rust {\n-                foreign::trans_rust_fn_with_foreign_abi(ccx,\n-                                                        &**decl,\n-                                                        &**body,\n-                                                        item.attrs.as_slice(),\n-                                                        llfn,\n-                                                        &param_substs::empty(),\n-                                                        item.id,\n-                                                        None);\n-            } else {\n-                trans_fn(ccx,\n-                         &**decl,\n-                         &**body,\n-                         llfn,\n-                         &param_substs::empty(),\n-                         item.id,\n-                         item.attrs.as_slice());\n+            let trans_everywhere = attr::requests_inline(item.attrs.as_slice());\n+            // Ignore `trans_everywhere` for cross-crate inlined items\n+            // (`from_external`).  `trans_item` will be called once for each\n+            // compilation unit that references the item, so it will still get\n+            // translated everywhere it's needed.\n+            for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n+                let llfn = get_item_val(ccx, item.id);\n+                if abi != Rust {\n+                    foreign::trans_rust_fn_with_foreign_abi(ccx,\n+                                                            &**decl,\n+                                                            &**body,\n+                                                            item.attrs.as_slice(),\n+                                                            llfn,\n+                                                            &param_substs::empty(),\n+                                                            item.id,\n+                                                            None);\n+                } else {\n+                    trans_fn(ccx,\n+                             &**decl,\n+                             &**body,\n+                             llfn,\n+                             &param_substs::empty(),\n+                             item.id,\n+                             item.attrs.as_slice());\n+                }\n+                update_linkage(ccx,\n+                               llfn,\n+                               Some(item.id),\n+                               if is_origin { OriginalTranslation } else { InlinedCopy });\n             }\n         }\n \n@@ -2162,7 +2230,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                          item.id);\n       }\n       ast::ItemMod(ref m) => {\n-        trans_mod(ccx, m);\n+        trans_mod(&ccx.rotate(), m);\n       }\n       ast::ItemEnum(ref enum_definition, _) => {\n         enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n@@ -2171,7 +2239,18 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n           // Recurse on the expression to catch items in blocks\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr, ());\n-          consts::trans_const(ccx, m, item.id);\n+\n+          let trans_everywhere = attr::requests_inline(item.attrs.as_slice());\n+          for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n+              consts::trans_const(ccx, m, item.id);\n+\n+              let g = get_item_val(ccx, item.id);\n+              update_linkage(ccx,\n+                             g,\n+                             Some(item.id),\n+                             if is_origin { OriginalTranslation } else { InlinedCopy });\n+          }\n+\n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n           if attr::contains_name(item.attrs.as_slice(), \"static_assert\") {\n@@ -2181,7 +2260,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let v = ccx.const_values.borrow().get_copy(&item.id);\n+              let v = ccx.const_values().borrow().get_copy(&item.id);\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");\n@@ -2218,21 +2297,17 @@ pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n \n fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n-    ccx.item_symbols.borrow_mut().insert(node_id, sym);\n-\n-    if !ccx.reachable.contains(&node_id) {\n-        llvm::SetLinkage(llfn, llvm::InternalLinkage);\n-    }\n+    ccx.item_symbols().borrow_mut().insert(node_id, sym);\n \n     // The stack exhaustion lang item shouldn't have a split stack because\n     // otherwise it would continue to be exhausted (bad), and both it and the\n     // eh_personality functions need to be externally linkable.\n     let def = ast_util::local_def(node_id);\n-    if ccx.tcx.lang_items.stack_exhausted() == Some(def) {\n+    if ccx.tcx().lang_items.stack_exhausted() == Some(def) {\n         unset_split_stack(llfn);\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n-    if ccx.tcx.lang_items.eh_personality() == Some(def) {\n+    if ccx.tcx().lang_items.eh_personality() == Some(def) {\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n \n@@ -2268,7 +2343,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n         ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _) => {\n-            let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+            let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let ref function_type = unboxed_closures.get(&closure_did)\n                                                     .closure_type;\n \n@@ -2485,8 +2560,8 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n     fn create_entry_fn(ccx: &CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func([ccx.int_type, Type::i8p(ccx).ptr_to()],\n-                               &ccx.int_type);\n+        let llfty = Type::func([ccx.int_type(), Type::i8p(ccx).ptr_to()],\n+                               &ccx.int_type());\n \n         let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil());\n \n@@ -2498,15 +2573,15 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n \n         let llbb = \"top\".with_c_str(|buf| {\n             unsafe {\n-                llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n+                llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, buf)\n             }\n         });\n-        let bld = ccx.builder.b;\n+        let bld = ccx.raw_builder();\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n \n             let (start_fn, args) = if use_start_lang_item {\n-                let start_def_id = match ccx.tcx.lang_items.require(StartFnLangItem) {\n+                let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => { ccx.sess().fatal(s.as_slice()); }\n                 };\n@@ -2553,11 +2628,20 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n \n fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n                  ty: ty::t, attrs: &[ast::Attribute]) -> String {\n+    match ccx.external_srcs().borrow().find(&id) {\n+        Some(&did) => {\n+            let sym = csearch::get_symbol(&ccx.sess().cstore, did);\n+            debug!(\"found item {} in other crate...\", sym);\n+            return sym;\n+        }\n+        None => {}\n+    }\n+\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n         Some(name) => name.get().to_string(),\n \n-        _ => ccx.tcx.map.with_path(id, |mut path| {\n+        _ => ccx.tcx().map.with_path(id, |mut path| {\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n                 path.last().unwrap().to_string()\n@@ -2577,13 +2661,12 @@ fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`{:?}`)\", id);\n \n-    match ccx.item_vals.borrow().find_copy(&id) {\n+    match ccx.item_vals().borrow().find_copy(&id) {\n         Some(v) => return v,\n         None => {}\n     }\n \n-    let mut foreign = false;\n-    let item = ccx.tcx.map.get(id);\n+    let item = ccx.tcx().map.get(id);\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n@@ -2596,33 +2679,20 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     // using the current crate's name/version\n                     // information in the hash of the symbol\n                     debug!(\"making {}\", sym);\n-                    let (sym, is_local) = {\n-                        match ccx.external_srcs.borrow().find(&i.id) {\n-                            Some(&did) => {\n-                                debug!(\"but found in other crate...\");\n-                                (csearch::get_symbol(&ccx.sess().cstore,\n-                                                     did), false)\n-                            }\n-                            None => (sym, true)\n-                        }\n-                    };\n+                    let is_local = !ccx.external_srcs().borrow().contains_key(&id);\n \n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n                     let (v, inlineable, _) = consts::const_expr(ccx, &**expr, is_local);\n-                    ccx.const_values.borrow_mut().insert(id, v);\n+                    ccx.const_values().borrow_mut().insert(id, v);\n                     let mut inlineable = inlineable;\n \n                     unsafe {\n                         let llty = llvm::LLVMTypeOf(v);\n                         let g = sym.as_slice().with_c_str(|buf| {\n-                            llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n+                            llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n                         });\n \n-                        if !ccx.reachable.contains(&id) {\n-                            llvm::SetLinkage(g, llvm::InternalLinkage);\n-                        }\n-\n                         // Apply the `unnamed_addr` attribute if\n                         // requested\n                         if !ast_util::static_has_significant_address(\n@@ -2655,11 +2725,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                         if !inlineable {\n                             debug!(\"{} not inlined\", sym);\n-                            ccx.non_inlineable_statics.borrow_mut()\n+                            ccx.non_inlineable_statics().borrow_mut()\n                                                       .insert(id);\n                         }\n \n-                        ccx.item_symbols.borrow_mut().insert(i.id, sym);\n+                        ccx.item_symbols().borrow_mut().insert(i.id, sym);\n                         g\n                     }\n                 }\n@@ -2713,11 +2783,9 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         }\n \n         ast_map::NodeForeignItem(ni) => {\n-            foreign = true;\n-\n             match ni.node {\n                 ast::ForeignItemFn(..) => {\n-                    let abi = ccx.tcx.map.get_foreign_abi(id);\n+                    let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n                     foreign::register_foreign_item_fn(ccx, abi, ty,\n@@ -2740,8 +2808,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             };\n             assert!(args.len() != 0u);\n             let ty = ty::node_id_to_type(ccx.tcx(), id);\n-            let parent = ccx.tcx.map.get_parent(id);\n-            let enm = ccx.tcx.map.expect_item(parent);\n+            let parent = ccx.tcx().map.get_parent(id);\n+            let enm = ccx.tcx().map.expect_item(parent);\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n@@ -2766,8 +2834,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n                 Some(ctor_id) => ctor_id,\n             };\n-            let parent = ccx.tcx.map.get_parent(id);\n-            let struct_item = ccx.tcx.map.expect_item(parent);\n+            let parent = ccx.tcx().map.get_parent(id);\n+            let struct_item = ccx.tcx().map.expect_item(parent);\n             let ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n             let sym = exported_name(ccx,\n                                     id,\n@@ -2786,14 +2854,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         }\n     };\n \n-    // foreign items (extern fns and extern statics) don't have internal\n-    // linkage b/c that doesn't quite make sense. Otherwise items can\n-    // have internal linkage if they're not reachable.\n-    if !foreign && !ccx.reachable.contains(&id) {\n-        llvm::SetLinkage(val, llvm::InternalLinkage);\n-    }\n+    // All LLVM globals and functions are initially created as external-linkage\n+    // declarations.  If `trans_item`/`trans_fn` later turns the declaration\n+    // into a definition, it adjusts the linkage then (using `update_linkage`).\n+    //\n+    // The exception is foreign items, which have their linkage set inside the\n+    // call to `foreign::register_*` above.  We don't touch the linkage after\n+    // that (`foreign::trans_foreign_mod` doesn't adjust the linkage like the\n+    // other item translation functions do).\n \n-    ccx.item_vals.borrow_mut().insert(id, val);\n+    ccx.item_vals().borrow_mut().insert(id, val);\n     val\n }\n \n@@ -2810,26 +2880,27 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n \n pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstPtrToInt(v, ccx.int_type.to_ref());\n+        return llvm::LLVMConstPtrToInt(v, ccx.int_type().to_ref());\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n+pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r SharedCrateContext,\n+                                      ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n         encoder::EncodeParams {\n             diag: cx.sess().diagnostic(),\n             tcx: cx.tcx(),\n-            reexports2: &cx.exp_map2,\n-            item_symbols: &cx.item_symbols,\n-            non_inlineable_statics: &cx.non_inlineable_statics,\n-            link_meta: &cx.link_meta,\n+            reexports2: cx.exp_map2(),\n+            item_symbols: cx.item_symbols(),\n+            non_inlineable_statics: cx.non_inlineable_statics(),\n+            link_meta: cx.link_meta(),\n             cstore: &cx.sess().cstore,\n             encode_inlined_item: ie,\n-            reachable: &cx.reachable,\n+            reachable: cx.reachable(),\n         }\n }\n \n-pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n+pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     use flate;\n \n     let any_library = cx.sess().crate_types.borrow().iter().any(|ty| {\n@@ -2851,14 +2922,14 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n                              cx.sess().fatal(\"failed to compress metadata\")\n                          }\n                      }.as_slice());\n-    let llmeta = C_bytes(cx, compressed.as_slice());\n-    let llconst = C_struct(cx, [llmeta], false);\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.as_slice());\n+    let llconst = C_struct_in_context(cx.metadata_llcx(), [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n-                       cx.link_meta.crate_name,\n-                       cx.link_meta.crate_hash);\n+                       cx.link_meta().crate_name,\n+                       cx.link_meta().crate_hash);\n     let llglobal = name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(cx.metadata_llmod, val_ty(llconst).to_ref(), buf)\n+            llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(), buf)\n         }\n     });\n     unsafe {\n@@ -2871,6 +2942,84 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     return metadata;\n }\n \n+/// Find any symbols that are defined in one compilation unit, but not declared\n+/// in any other compilation unit.  Give these symbols internal linkage.\n+fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n+    use std::c_str::CString;\n+\n+    unsafe {\n+        let mut declared = HashSet::new();\n+\n+        let iter_globals = |llmod| {\n+            ValueIter {\n+                cur: llvm::LLVMGetFirstGlobal(llmod),\n+                step: llvm::LLVMGetNextGlobal,\n+            }\n+        };\n+\n+        let iter_functions = |llmod| {\n+            ValueIter {\n+                cur: llvm::LLVMGetFirstFunction(llmod),\n+                step: llvm::LLVMGetNextFunction,\n+            }\n+        };\n+\n+        // Collect all external declarations in all compilation units.\n+        for ccx in cx.iter() {\n+            for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+                let linkage = llvm::LLVMGetLinkage(val);\n+                // We only care about external declarations (not definitions)\n+                // and available_externally definitions.\n+                if !(linkage == llvm::ExternalLinkage as c_uint &&\n+                     llvm::LLVMIsDeclaration(val) != 0) &&\n+                   !(linkage == llvm::AvailableExternallyLinkage as c_uint) {\n+                    continue\n+                }\n+\n+                let name = CString::new(llvm::LLVMGetValueName(val), false);\n+                declared.insert(name);\n+            }\n+        }\n+\n+        // Examine each external definition.  If the definition is not used in\n+        // any other compilation unit, and is not reachable from other crates,\n+        // then give it internal linkage.\n+        for ccx in cx.iter() {\n+            for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+                // We only care about external definitions.\n+                if !(llvm::LLVMGetLinkage(val) == llvm::ExternalLinkage as c_uint &&\n+                     llvm::LLVMIsDeclaration(val) == 0) {\n+                    continue\n+                }\n+\n+                let name = CString::new(llvm::LLVMGetValueName(val), false);\n+                if !declared.contains(&name) &&\n+                   !reachable.contains_equiv(&name.as_str().unwrap()) {\n+                    llvm::SetLinkage(val, llvm::InternalLinkage);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    struct ValueIter {\n+        cur: ValueRef,\n+        step: unsafe extern \"C\" fn(ValueRef) -> ValueRef,\n+    }\n+\n+    impl Iterator<ValueRef> for ValueIter {\n+        fn next(&mut self) -> Option<ValueRef> {\n+            let old = self.cur;\n+            if !old.is_null() {\n+                self.cur = unsafe { (self.step)(old) };\n+                Some(old)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n pub fn trans_crate(krate: ast::Crate,\n                    analysis: CrateAnalysis) -> (ty::ctxt, CrateTranslation) {\n     let CrateAnalysis { ty_cx: tcx, exp_map2, reachable, name, .. } = analysis;\n@@ -2895,80 +3044,83 @@ pub fn trans_crate(krate: ast::Crate,\n \n     let link_meta = link::build_link_meta(&tcx.sess, &krate, name);\n \n-    // Append \".rs\" to crate name as LLVM module identifier.\n-    //\n-    // LLVM code generator emits a \".file filename\" directive\n-    // for ELF backends. Value of the \"filename\" is set as the\n-    // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n-    // crashes if the module identifier is same as other symbols\n-    // such as a function name in the module.\n-    // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let mut llmod_id = link_meta.crate_name.clone();\n-    llmod_id.push_str(\".rs\");\n-\n-    let ccx = CrateContext::new(llmod_id.as_slice(), tcx, exp_map2,\n-                                Sha256::new(), link_meta, reachable);\n-\n-    // First, verify intrinsics.\n-    intrinsic::check_intrinsics(&ccx);\n-\n-    // Next, translate the module.\n+    let codegen_units = tcx.sess.opts.cg.codegen_units;\n+    let shared_ccx = SharedCrateContext::new(link_meta.crate_name.as_slice(),\n+                                             codegen_units,\n+                                             tcx,\n+                                             exp_map2,\n+                                             Sha256::new(),\n+                                             link_meta.clone(),\n+                                             reachable);\n+\n     {\n-        let _icx = push_ctxt(\"text\");\n-        trans_mod(&ccx, &krate.module);\n+        let ccx = shared_ccx.get_ccx(0);\n+\n+        // First, verify intrinsics.\n+        intrinsic::check_intrinsics(&ccx);\n+\n+        // Next, translate the module.\n+        {\n+            let _icx = push_ctxt(\"text\");\n+            trans_mod(&ccx, &krate.module);\n+        }\n     }\n \n-    glue::emit_tydescs(&ccx);\n-    if ccx.sess().opts.debuginfo != NoDebugInfo {\n-        debuginfo::finalize(&ccx);\n+    for ccx in shared_ccx.iter() {\n+        glue::emit_tydescs(&ccx);\n+        if ccx.sess().opts.debuginfo != NoDebugInfo {\n+            debuginfo::finalize(&ccx);\n+        }\n     }\n \n     // Translate the metadata.\n-    let metadata = write_metadata(&ccx, &krate);\n-    if ccx.sess().trans_stats() {\n+    let metadata = write_metadata(&shared_ccx, &krate);\n+\n+    if shared_ccx.sess().trans_stats() {\n+        let stats = shared_ccx.stats();\n         println!(\"--- trans stats ---\");\n-        println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs.get());\n-        println!(\"n_glues_created: {}\", ccx.stats.n_glues_created.get());\n-        println!(\"n_null_glues: {}\", ccx.stats.n_null_glues.get());\n-        println!(\"n_real_glues: {}\", ccx.stats.n_real_glues.get());\n-\n-        println!(\"n_fns: {}\", ccx.stats.n_fns.get());\n-        println!(\"n_monos: {}\", ccx.stats.n_monos.get());\n-        println!(\"n_inlines: {}\", ccx.stats.n_inlines.get());\n-        println!(\"n_closures: {}\", ccx.stats.n_closures.get());\n+        println!(\"n_static_tydescs: {}\", stats.n_static_tydescs.get());\n+        println!(\"n_glues_created: {}\", stats.n_glues_created.get());\n+        println!(\"n_null_glues: {}\", stats.n_null_glues.get());\n+        println!(\"n_real_glues: {}\", stats.n_real_glues.get());\n+\n+        println!(\"n_fns: {}\", stats.n_fns.get());\n+        println!(\"n_monos: {}\", stats.n_monos.get());\n+        println!(\"n_inlines: {}\", stats.n_inlines.get());\n+        println!(\"n_closures: {}\", stats.n_closures.get());\n         println!(\"fn stats:\");\n-        ccx.stats.fn_stats.borrow_mut().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n+        stats.fn_stats.borrow_mut().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_b.cmp(&insns_a)\n         });\n-        for tuple in ccx.stats.fn_stats.borrow().iter() {\n+        for tuple in stats.fn_stats.borrow().iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {\n                     println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n                 }\n             }\n         }\n     }\n-    if ccx.sess().count_llvm_insns() {\n-        for (k, v) in ccx.stats.llvm_insns.borrow().iter() {\n+    if shared_ccx.sess().count_llvm_insns() {\n+        for (k, v) in shared_ccx.stats().llvm_insns.borrow().iter() {\n             println!(\"{:7u} {}\", *v, *k);\n         }\n     }\n \n-    let llcx = ccx.llcx;\n-    let link_meta = ccx.link_meta.clone();\n-    let llmod = ccx.llmod;\n+    let modules = shared_ccx.iter()\n+        .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n+        .collect();\n \n-    let mut reachable: Vec<String> = ccx.reachable.iter().filter_map(|id| {\n-        ccx.item_symbols.borrow().find(id).map(|s| s.to_string())\n+    let mut reachable: Vec<String> = shared_ccx.reachable().iter().filter_map(|id| {\n+        shared_ccx.item_symbols().borrow().find(id).map(|s| s.to_string())\n     }).collect();\n \n     // For the purposes of LTO, we add to the reachable set all of the upstream\n     // reachable extern fns. These functions are all part of the public ABI of\n     // the final product, so LTO needs to preserve them.\n-    ccx.sess().cstore.iter_crate_data(|cnum, _| {\n-        let syms = csearch::get_reachable_extern_fns(&ccx.sess().cstore, cnum);\n+    shared_ccx.sess().cstore.iter_crate_data(|cnum, _| {\n+        let syms = csearch::get_reachable_extern_fns(&shared_ccx.sess().cstore, cnum);\n         reachable.extend(syms.move_iter().map(|did| {\n-            csearch::get_symbol(&ccx.sess().cstore, did)\n+            csearch::get_symbol(&shared_ccx.sess().cstore, did)\n         }));\n     });\n \n@@ -2986,18 +3138,26 @@ pub fn trans_crate(krate: ast::Crate,\n     // referenced from rt/rust_try.ll\n     reachable.push(\"rust_eh_personality_catch\".to_string());\n \n-    let metadata_module = ccx.metadata_llmod;\n-    let formats = ccx.tcx.dependency_formats.borrow().clone();\n+    if codegen_units > 1 {\n+        internalize_symbols(&shared_ccx, &reachable.iter().map(|x| x.clone()).collect());\n+    }\n+\n+    let metadata_module = ModuleTranslation {\n+        llcx: shared_ccx.metadata_llcx(),\n+        llmod: shared_ccx.metadata_llmod(),\n+    };\n+    let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n     let no_builtins = attr::contains_name(krate.attrs.as_slice(), \"no_builtins\");\n \n-    (ccx.tcx, CrateTranslation {\n-        context: llcx,\n-        module: llmod,\n-        link: link_meta,\n+    let translation = CrateTranslation {\n+        modules: modules,\n         metadata_module: metadata_module,\n+        link: link_meta,\n         metadata: metadata,\n         reachable: reachable,\n         crate_formats: formats,\n         no_builtins: no_builtins,\n-    })\n+    };\n+\n+    (shared_ccx.take_tcx(), translation)\n }"}, {"sha": "fd988eb7fc1370f4fbdf892e812cb60cfe7988e2", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -352,7 +352,7 @@ pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n             let eltty = if ty.kind() == llvm::Array {\n                 ty.element_type()\n             } else {\n-                ccx.int_type\n+                ccx.int_type()\n             };\n             return llvm::LLVMGetUndef(eltty.to_ref());\n         }\n@@ -373,7 +373,7 @@ pub fn AtomicLoad(cx: &Block, pointer_val: ValueRef, order: AtomicOrdering) -> V\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(ccx.int_type.to_ref());\n+            return llvm::LLVMGetUndef(ccx.int_type().to_ref());\n         }\n         B(cx).atomic_load(pointer_val, order)\n     }\n@@ -388,7 +388,7 @@ pub fn LoadRangeAssert(cx: &Block, pointer_val: ValueRef, lo: c_ulonglong,\n         let eltty = if ty.kind() == llvm::Array {\n             ty.element_type()\n         } else {\n-            ccx.int_type\n+            ccx.int_type()\n         };\n         unsafe {\n             llvm::LLVMGetUndef(eltty.to_ref())\n@@ -658,7 +658,7 @@ pub fn _UndefReturn(cx: &Block, fn_: ValueRef) -> ValueRef {\n         let retty = if ty.kind() == llvm::Integer {\n             ty.return_type()\n         } else {\n-            ccx.int_type\n+            ccx.int_type()\n         };\n         B(cx).count_insn(\"ret_undef\");\n         llvm::LLVMGetUndef(retty.to_ref())\n@@ -786,7 +786,7 @@ pub fn IsNotNull(cx: &Block, val: ValueRef) -> ValueRef {\n pub fn PtrDiff(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type().to_ref()); }\n         B(cx).ptrdiff(lhs, rhs)\n     }\n }"}, {"sha": "322a6a3cc909eb1272a1d29e4618926b046c5388", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -25,7 +25,7 @@ use syntax::codemap::Span;\n \n pub struct Builder<'a> {\n     pub llbuilder: BuilderRef,\n-    pub ccx: &'a CrateContext,\n+    pub ccx: &'a CrateContext<'a>,\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -38,21 +38,22 @@ pub fn noname() -> *const c_char {\n impl<'a> Builder<'a> {\n     pub fn new(ccx: &'a CrateContext) -> Builder<'a> {\n         Builder {\n-            llbuilder: ccx.builder.b,\n+            llbuilder: ccx.raw_builder(),\n             ccx: ccx,\n         }\n     }\n \n     pub fn count_insn(&self, category: &str) {\n         if self.ccx.sess().trans_stats() {\n-            self.ccx.stats.n_llvm_insns.set(self.ccx\n-                                                .stats\n+            self.ccx.stats().n_llvm_insns.set(self.ccx\n+                                                .stats()\n                                                 .n_llvm_insns\n                                                 .get() + 1);\n         }\n+        self.ccx.count_llvm_insn();\n         if self.ccx.sess().count_llvm_insns() {\n             base::with_insn_ctxt(|v| {\n-                let mut h = self.ccx.stats.llvm_insns.borrow_mut();\n+                let mut h = self.ccx.stats().llvm_insns.borrow_mut();\n \n                 // Build version of path with cycles removed.\n \n@@ -160,9 +161,9 @@ impl<'a> Builder<'a> {\n         self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {} with args ({})\",\n-               self.ccx.tn.val_to_string(llfn),\n+               self.ccx.tn().val_to_string(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn.val_to_string(v))\n+                   .map(|&v| self.ccx.tn().val_to_string(v))\n                    .collect::<Vec<String>>()\n                    .connect(\", \"));\n \n@@ -488,7 +489,7 @@ impl<'a> Builder<'a> {\n             let v = [min, max];\n \n             llvm::LLVMSetMetadata(value, llvm::MD_range as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx,\n+                                  llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n                                                             v.as_ptr(), v.len() as c_uint));\n         }\n \n@@ -497,8 +498,8 @@ impl<'a> Builder<'a> {\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n         debug!(\"Store {} -> {}\",\n-               self.ccx.tn.val_to_string(val),\n-               self.ccx.tn.val_to_string(ptr));\n+               self.ccx.tn().val_to_string(val),\n+               self.ccx.tn().val_to_string(ptr));\n         assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store\");\n         unsafe {\n@@ -508,8 +509,8 @@ impl<'a> Builder<'a> {\n \n     pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) {\n         debug!(\"Store {} -> {}\",\n-               self.ccx.tn.val_to_string(val),\n-               self.ccx.tn.val_to_string(ptr));\n+               self.ccx.tn().val_to_string(val),\n+               self.ccx.tn().val_to_string(ptr));\n         assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store.volatile\");\n         unsafe {\n@@ -520,8 +521,8 @@ impl<'a> Builder<'a> {\n \n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n         debug!(\"Store {} -> {}\",\n-               self.ccx.tn.val_to_string(val),\n-               self.ccx.tn.val_to_string(ptr));\n+               self.ccx.tn().val_to_string(val),\n+               self.ccx.tn().val_to_string(ptr));\n         self.count_insn(\"store.atomic\");\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n@@ -794,11 +795,11 @@ impl<'a> Builder<'a> {\n                          else          { llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_string(*v));\n+            debug!(\"Asm Input Type: {:?}\", self.ccx.tn().val_to_string(*v));\n             val_ty(*v)\n         }).collect::<Vec<_>>();\n \n-        debug!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_string(output));\n+        debug!(\"Asm Output Type: {:?}\", self.ccx.tn().type_to_string(output));\n         let fty = Type::func(argtys.as_slice(), &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n@@ -812,9 +813,9 @@ impl<'a> Builder<'a> {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {} with args ({})\",\n-               self.ccx.tn.val_to_string(llfn),\n+               self.ccx.tn().val_to_string(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn.val_to_string(v))\n+                   .map(|&v| self.ccx.tn().val_to_string(v))\n                    .collect::<Vec<String>>()\n                    .connect(\", \"));\n "}, {"sha": "90bd1521705f029bc0e5e7ad967a395e3fbb367d", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -146,7 +146,7 @@ fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n     let r = size % 32;\n     if r > 0 {\n         unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx, r as c_uint)));\n+            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n         }\n     }\n "}, {"sha": "15d296ac723716188ea898cefe6788406ba792cd", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -87,7 +87,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"push_ast_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_string(id));\n+               self.ccx.tcx().map.node_to_string(id));\n \n         // FIXME(#2202) -- currently closure bodies have a parent\n         // region, which messes up the assertion below, since there\n@@ -101,7 +101,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         // this new AST scope had better be its immediate child.\n         let top_scope = self.top_ast_scope();\n         if top_scope.is_some() {\n-            assert_eq!(self.ccx.tcx.region_maps.opt_encl_scope(id), top_scope);\n+            assert_eq!(self.ccx.tcx().region_maps.opt_encl_scope(id), top_scope);\n         }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(id)));\n@@ -111,7 +111,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                                id: ast::NodeId,\n                                exits: [&'a Block<'a>, ..EXIT_MAX]) {\n         debug!(\"push_loop_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_string(id));\n+               self.ccx.tcx().map.node_to_string(id));\n         assert_eq!(Some(id), self.top_ast_scope());\n \n         self.push_scope(CleanupScope::new(LoopScopeKind(id, exits)));\n@@ -135,7 +135,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"pop_and_trans_ast_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_string(cleanup_scope));\n+               self.ccx.tcx().map.node_to_string(cleanup_scope));\n \n         assert!(self.top_scope(|s| s.kind.is_ast_with_id(cleanup_scope)));\n \n@@ -154,7 +154,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"pop_loop_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_string(cleanup_scope));\n+               self.ccx.tcx().map.node_to_string(cleanup_scope));\n \n         assert!(self.top_scope(|s| s.kind.is_loop_with_id(cleanup_scope)));\n \n@@ -237,7 +237,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_lifetime_end({:?}, val={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val));\n+               self.ccx.tn().val_to_string(val));\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -262,7 +262,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n@@ -288,7 +288,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n                true);\n \n@@ -314,7 +314,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n@@ -334,7 +334,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn().val_to_string(val),\n                heap);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n@@ -374,7 +374,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx.map.node_to_string(cleanup_scope)).as_slice());\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope)).as_slice());\n     }\n \n     fn schedule_clean_in_custom_scope(&self,\n@@ -720,7 +720,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         let llpersonality = match pad_bcx.tcx().lang_items.eh_personality() {\n             Some(def_id) => callee::trans_fn_ref(pad_bcx, def_id, ExprId(0)),\n             None => {\n-                let mut personality = self.ccx.eh_personality.borrow_mut();\n+                let mut personality = self.ccx.eh_personality().borrow_mut();\n                 match *personality {\n                     Some(llpersonality) => llpersonality,\n                     None => {"}, {"sha": "4e9431f262911bb686dd47168399240e0f925cab", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -427,12 +427,12 @@ pub fn trans_expr_fn<'a>(\n pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n                                                     closure_id: ast::DefId)\n                                                     -> Option<ValueRef> {\n-    if !ccx.tcx.unboxed_closures.borrow().contains_key(&closure_id) {\n+    if !ccx.tcx().unboxed_closures.borrow().contains_key(&closure_id) {\n         // Not an unboxed closure.\n         return None\n     }\n \n-    match ccx.unboxed_closure_vals.borrow().find(&closure_id) {\n+    match ccx.unboxed_closure_vals().borrow().find(&closure_id) {\n         Some(llfn) => {\n             debug!(\"get_or_create_declaration_if_unboxed_closure(): found \\\n                     closure\");\n@@ -441,10 +441,10 @@ pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n         None => {}\n     }\n \n-    let function_type = ty::mk_unboxed_closure(&ccx.tcx,\n+    let function_type = ty::mk_unboxed_closure(ccx.tcx(),\n                                                closure_id,\n                                                ty::ReStatic);\n-    let symbol = ccx.tcx.map.with_path(closure_id.node, |path| {\n+    let symbol = ccx.tcx().map.with_path(closure_id.node, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n \n@@ -456,8 +456,8 @@ pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n     debug!(\"get_or_create_declaration_if_unboxed_closure(): inserting new \\\n             closure {} (type {})\",\n            closure_id,\n-           ccx.tn.type_to_string(val_ty(llfn)));\n-    ccx.unboxed_closure_vals.borrow_mut().insert(closure_id, llfn);\n+           ccx.tn().type_to_string(val_ty(llfn)));\n+    ccx.unboxed_closure_vals().borrow_mut().insert(closure_id, llfn);\n \n     Some(llfn)\n }\n@@ -554,7 +554,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         }\n     };\n \n-    match ccx.closure_bare_wrapper_cache.borrow().find(&fn_ptr) {\n+    match ccx.closure_bare_wrapper_cache().borrow().find(&fn_ptr) {\n         Some(&llval) => return llval,\n         None => {}\n     }\n@@ -581,7 +581,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         decl_rust_fn(ccx, closure_ty, name.as_slice())\n     };\n \n-    ccx.closure_bare_wrapper_cache.borrow_mut().insert(fn_ptr, llfn);\n+    ccx.closure_bare_wrapper_cache().borrow_mut().insert(fn_ptr, llfn);\n \n     // This is only used by statics inlined from a different crate.\n     if !is_local {"}, {"sha": "4ea60a4e128ad608b9053178fb501575e4260b04", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -14,7 +14,7 @@\n \n use driver::session::Session;\n use llvm;\n-use llvm::{ValueRef, BasicBlockRef, BuilderRef};\n+use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n use llvm::{True, False, Bool};\n use middle::def;\n use middle::freevars;\n@@ -82,7 +82,7 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n         ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n         ty::ty_unboxed_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n-            llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type)\n+            llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n         }\n         _ => type_is_zero_size(ccx, ty)\n     }\n@@ -297,7 +297,7 @@ pub struct FunctionContext<'a> {\n     pub block_arena: &'a TypedArena<Block<'a>>,\n \n     // This function's enclosing crate context.\n-    pub ccx: &'a CrateContext,\n+    pub ccx: &'a CrateContext<'a>,\n \n     // Used and maintained by the debuginfo module.\n     pub debug_context: debuginfo::FunctionDebugContext,\n@@ -342,7 +342,7 @@ impl<'a> FunctionContext<'a> {\n \n             self.llreturn.set(Some(unsafe {\n                 \"return\".with_c_str(|buf| {\n-                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx, self.llfn, buf)\n+                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn, buf)\n                 })\n             }))\n         }\n@@ -365,7 +365,7 @@ impl<'a> FunctionContext<'a> {\n                      -> &'a Block<'a> {\n         unsafe {\n             let llbb = name.with_c_str(|buf| {\n-                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx,\n+                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n                                                         self.llfn,\n                                                         buf)\n                 });\n@@ -449,9 +449,9 @@ impl<'a> Block<'a> {\n         })\n     }\n \n-    pub fn ccx(&self) -> &'a CrateContext { self.fcx.ccx }\n+    pub fn ccx(&self) -> &'a CrateContext<'a> { self.fcx.ccx }\n     pub fn tcx(&self) -> &'a ty::ctxt {\n-        &self.fcx.ccx.tcx\n+        self.fcx.ccx.tcx()\n     }\n     pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n \n@@ -478,11 +478,11 @@ impl<'a> Block<'a> {\n     }\n \n     pub fn val_to_string(&self, val: ValueRef) -> String {\n-        self.ccx().tn.val_to_string(val)\n+        self.ccx().tn().val_to_string(val)\n     }\n \n     pub fn llty_str(&self, ty: Type) -> String {\n-        self.ccx().tn.type_to_string(ty)\n+        self.ccx().tn().type_to_string(ty)\n     }\n \n     pub fn ty_to_string(&self, t: ty::t) -> String {\n@@ -601,11 +601,11 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n }\n \n pub fn C_int(ccx: &CrateContext, i: int) -> ValueRef {\n-    C_integral(ccx.int_type, i as u64, true)\n+    C_integral(ccx.int_type(), i as u64, true)\n }\n \n pub fn C_uint(ccx: &CrateContext, i: uint) -> ValueRef {\n-    C_integral(ccx.int_type, i as u64, false)\n+    C_integral(ccx.int_type(), i as u64, false)\n }\n \n pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n@@ -617,25 +617,25 @@ pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache.borrow().find(&s) {\n+        match cx.const_cstr_cache().borrow().find(&s) {\n             Some(&llval) => return llval,\n             None => ()\n         }\n \n-        let sc = llvm::LLVMConstStringInContext(cx.llcx,\n+        let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n                                                 s.get().as_ptr() as *const c_char,\n                                                 s.get().len() as c_uint,\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n         let g = format!(\"str{}\", gsym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n+            llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf)\n         });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::SetLinkage(g, llvm::InternalLinkage);\n \n-        cx.const_cstr_cache.borrow_mut().insert(s, g);\n+        cx.const_cstr_cache().borrow_mut().insert(s, g);\n         g\n     }\n }\n@@ -647,7 +647,7 @@ pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n         let len = s.get().len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s, false),\n                                             Type::i8p(cx).to_ref());\n-        C_named_struct(cx.tn.find_type(\"str_slice\").unwrap(), [cs, C_uint(cx, len)])\n+        C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), [cs, C_uint(cx, len)])\n     }\n }\n \n@@ -658,7 +658,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n \n         let gsym = token::gensym(\"binary\");\n         let g = format!(\"binary{}\", gsym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(lldata).to_ref(), buf)\n+            llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(), buf)\n         });\n         llvm::LLVMSetInitializer(g, lldata);\n         llvm::LLVMSetGlobalConstant(g, True);\n@@ -669,9 +669,13 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn C_struct(ccx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n+pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n+    C_struct_in_context(cx.llcx(), elts, packed)\n+}\n+\n+pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstStructInContext(ccx.llcx,\n+        llvm::LLVMConstStructInContext(llcx,\n                                        elts.as_ptr(), elts.len() as c_uint,\n                                        packed as Bool)\n     }\n@@ -689,10 +693,14 @@ pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn C_bytes(ccx: &CrateContext, bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n+    C_bytes_in_context(cx.llcx(), bytes)\n+}\n+\n+pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n     unsafe {\n         let ptr = bytes.as_ptr() as *const c_char;\n-        return llvm::LLVMConstStringInContext(ccx.llcx, ptr, bytes.len() as c_uint, True);\n+        return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n     }\n }\n \n@@ -702,7 +710,7 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n         debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n-               cx.tn.val_to_string(v), us, cx.tn.val_to_string(r));\n+               cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n \n         return r;\n     }"}, {"sha": "bd5132ea4273660ea8f128ecb07e76b8c1957b5d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -91,7 +91,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n-        assert!(cx.const_globals.borrow_mut().insert(b as int, a));\n+        assert!(cx.const_globals().borrow_mut().insert(b as int, a));\n         b\n     }\n }\n@@ -119,7 +119,7 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n     unsafe {\n         let gv = \"const\".with_c_str(|name| {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n+            llvm::LLVMAddGlobal(cx.llmod(), val_ty(cv).to_ref(), name)\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetGlobalConstant(gv,\n@@ -130,7 +130,7 @@ pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) ->\n }\n \n fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n-    let v = match cx.const_globals.borrow().find(&(v as int)) {\n+    let v = match cx.const_globals().borrow().find(&(v as int)) {\n         Some(&v) => v,\n         None => v\n     };\n@@ -178,22 +178,22 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n \n pub fn get_const_val(cx: &CrateContext,\n                      mut def_id: ast::DefId) -> (ValueRef, bool) {\n-    let contains_key = cx.const_values.borrow().contains_key(&def_id.node);\n+    let contains_key = cx.const_values().borrow().contains_key(&def_id.node);\n     if !ast_util::is_local(def_id) || !contains_key {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n \n-        match cx.tcx.map.expect_item(def_id.node).node {\n+        match cx.tcx().map.expect_item(def_id.node).node {\n             ast::ItemStatic(_, ast::MutImmutable, _) => {\n                 trans_const(cx, ast::MutImmutable, def_id.node);\n             }\n             _ => {}\n         }\n     }\n \n-    (cx.const_values.borrow().get_copy(&def_id.node),\n-     !cx.non_inlineable_statics.borrow().contains(&def_id.node))\n+    (cx.const_values().borrow().get_copy(&def_id.node),\n+     !cx.non_inlineable_statics().borrow().contains(&def_id.node))\n }\n \n pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool, ty::t) {\n@@ -202,7 +202,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx(), e);\n     let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n-    let opt_adj = cx.tcx.adjustments.borrow().find_copy(&e.id);\n+    let opt_adj = cx.tcx().adjustments.borrow().find_copy(&e.id);\n     match opt_adj {\n         None => { }\n         Some(adj) => {\n@@ -523,7 +523,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               (expr::cast_enum, expr::cast_integral) => {\n                 let repr = adt::represent_type(cx, basety);\n                 let discr = adt::const_get_discrim(cx, &*repr, v);\n-                let iv = C_integral(cx.int_type, discr, false);\n+                let iv = C_integral(cx.int_type(), discr, false);\n                 let ety_cast = expr::cast_type_kind(cx.tcx(), ety);\n                 match ety_cast {\n                     expr::cast_integral => {\n@@ -690,8 +690,17 @@ pub fn trans_const(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.const_values.borrow().get_copy(&id);\n+        let v = ccx.const_values().borrow().get_copy(&id);\n         llvm::LLVMSetInitializer(g, v);\n+\n+        // `get_item_val` left `g` with external linkage, but we just set an\n+        // initializer for it.  But we don't know yet if `g` should really be\n+        // defined in this compilation unit, so we set its linkage to\n+        // `AvailableExternallyLinkage`.  (It's still a definition, but acts\n+        // like a declaration for most purposes.)  If `g` really should be\n+        // declared here, then `trans_item` will fix up the linkage later on.\n+        llvm::SetLinkage(g, llvm::AvailableExternallyLinkage);\n+\n         if m != ast::MutMutable {\n             llvm::LLVMSetGlobalConstant(g, True);\n         }"}, {"sha": "5bdd5f6739d61428516782da7e8acbbed27eafc5", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 546, "deletions": 120, "changes": 666, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -11,7 +11,7 @@\n use driver::config::NoDebugInfo;\n use driver::session::Session;\n use llvm;\n-use llvm::{ContextRef, ModuleRef, ValueRef};\n+use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n use llvm::{TargetData};\n use llvm::mk_target_data;\n use metadata::common::LinkMeta;\n@@ -51,39 +51,61 @@ pub struct Stats {\n     pub fn_stats: RefCell<Vec<(String, uint, uint)> >,\n }\n \n-pub struct CrateContext {\n-    pub llmod: ModuleRef,\n-    pub llcx: ContextRef,\n-    pub metadata_llmod: ModuleRef,\n-    pub td: TargetData,\n-    pub tn: TypeNames,\n-    pub externs: RefCell<ExternMap>,\n-    pub item_vals: RefCell<NodeMap<ValueRef>>,\n-    pub exp_map2: resolve::ExportMap2,\n-    pub reachable: NodeSet,\n-    pub item_symbols: RefCell<NodeMap<String>>,\n-    pub link_meta: LinkMeta,\n-    pub drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n-    pub tydescs: RefCell<HashMap<ty::t, Rc<tydesc_info>>>,\n+/// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`\n+/// per crate.  The data here is shared between all compilation units of the\n+/// crate, so it must not contain references to any LLVM data structures\n+/// (aside from metadata-related ones).\n+pub struct SharedCrateContext {\n+    local_ccxs: Vec<LocalCrateContext>,\n+\n+    metadata_llmod: ModuleRef,\n+    metadata_llcx: ContextRef,\n+\n+    exp_map2: resolve::ExportMap2,\n+    reachable: NodeSet,\n+    item_symbols: RefCell<NodeMap<String>>,\n+    link_meta: LinkMeta,\n+    /// A set of static items which cannot be inlined into other crates. This\n+    /// will prevent in IIItem() structures from being encoded into the metadata\n+    /// that is generated\n+    non_inlineable_statics: RefCell<NodeSet>,\n+    symbol_hasher: RefCell<Sha256>,\n+    tcx: ty::ctxt,\n+    stats: Stats,\n+\n+    available_monomorphizations: RefCell<HashSet<String>>,\n+    available_drop_glues: RefCell<HashMap<ty::t, String>>,\n+    available_visit_glues: RefCell<HashMap<ty::t, String>>,\n+}\n+\n+/// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n+/// per compilation unit.  Each one has its own LLVM `ContextRef` so that\n+/// several compilation units may be optimized in parallel.  All other LLVM\n+/// data structures in the `LocalCrateContext` are tied to that `ContextRef`.\n+pub struct LocalCrateContext {\n+    llmod: ModuleRef,\n+    llcx: ContextRef,\n+    td: TargetData,\n+    tn: TypeNames,\n+    externs: RefCell<ExternMap>,\n+    item_vals: RefCell<NodeMap<ValueRef>>,\n+    drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n+    tydescs: RefCell<HashMap<ty::t, Rc<tydesc_info>>>,\n     /// Set when running emit_tydescs to enforce that no more tydescs are\n     /// created.\n-    pub finished_tydescs: Cell<bool>,\n+    finished_tydescs: Cell<bool>,\n     /// Track mapping of external ids to local items imported for inlining\n-    pub external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n+    external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n     /// came from)\n-    pub external_srcs: RefCell<NodeMap<ast::DefId>>,\n-    /// A set of static items which cannot be inlined into other crates. This\n-    /// will prevent in IIItem() structures from being encoded into the metadata\n-    /// that is generated\n-    pub non_inlineable_statics: RefCell<NodeSet>,\n+    external_srcs: RefCell<NodeMap<ast::DefId>>,\n     /// Cache instances of monomorphized functions\n-    pub monomorphized: RefCell<HashMap<MonoId, ValueRef>>,\n-    pub monomorphizing: RefCell<DefIdMap<uint>>,\n+    monomorphized: RefCell<HashMap<MonoId, ValueRef>>,\n+    monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<HashMap<(ty::t, MonoId), ValueRef>>,\n+    vtables: RefCell<HashMap<(ty::t, MonoId), ValueRef>>,\n     /// Cache of constant strings,\n-    pub const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n+    const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is an int, cast from a ValueRef holding a *T,\n@@ -93,106 +115,295 @@ pub struct CrateContext {\n     /// when we ptrcast, and we have to ptrcast during translation\n     /// of a [T] const because we form a slice, a [*T,int] pair, not\n     /// a pointer to an LLVM array type.\n-    pub const_globals: RefCell<HashMap<int, ValueRef>>,\n+    const_globals: RefCell<HashMap<int, ValueRef>>,\n \n     /// Cache of emitted const values\n-    pub const_values: RefCell<NodeMap<ValueRef>>,\n+    const_values: RefCell<NodeMap<ValueRef>>,\n \n     /// Cache of external const values\n-    pub extern_const_values: RefCell<DefIdMap<ValueRef>>,\n+    extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n-    pub impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n+    impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n \n     /// Cache of closure wrappers for bare fn's.\n-    pub closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n-\n-    pub lltypes: RefCell<HashMap<ty::t, Type>>,\n-    pub llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n-    pub adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n-    pub symbol_hasher: RefCell<Sha256>,\n-    pub type_hashcodes: RefCell<HashMap<ty::t, String>>,\n-    pub all_llvm_symbols: RefCell<HashSet<String>>,\n-    pub tcx: ty::ctxt,\n-    pub stats: Stats,\n-    pub int_type: Type,\n-    pub opaque_vec_type: Type,\n-    pub builder: BuilderRef_res,\n+    closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n+\n+    lltypes: RefCell<HashMap<ty::t, Type>>,\n+    llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n+    adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n+    type_hashcodes: RefCell<HashMap<ty::t, String>>,\n+    all_llvm_symbols: RefCell<HashSet<String>>,\n+    int_type: Type,\n+    opaque_vec_type: Type,\n+    builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    pub unboxed_closure_vals: RefCell<DefIdMap<ValueRef>>,\n+    unboxed_closure_vals: RefCell<DefIdMap<ValueRef>>,\n \n-    pub dbg_cx: Option<debuginfo::CrateDebugContext>,\n+    dbg_cx: Option<debuginfo::CrateDebugContext>,\n \n-    pub eh_personality: RefCell<Option<ValueRef>>,\n+    eh_personality: RefCell<Option<ValueRef>>,\n \n     intrinsics: RefCell<HashMap<&'static str, ValueRef>>,\n+\n+    /// Number of LLVM instructions translated into this `LocalCrateContext`.\n+    /// This is used to perform some basic load-balancing to keep all LLVM\n+    /// contexts around the same size.\n+    n_llvm_insns: Cell<uint>,\n+}\n+\n+pub struct CrateContext<'a> {\n+    shared: &'a SharedCrateContext,\n+    local: &'a LocalCrateContext,\n+    /// The index of `local` in `shared.local_ccxs`.  This is used in\n+    /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n+    index: uint,\n+}\n+\n+pub struct CrateContextIterator<'a> {\n+    shared: &'a SharedCrateContext,\n+    index: uint,\n+}\n+\n+impl<'a> Iterator<CrateContext<'a>> for CrateContextIterator<'a> {\n+    fn next(&mut self) -> Option<CrateContext<'a>> {\n+        if self.index >= self.shared.local_ccxs.len() {\n+            return None;\n+        }\n+\n+        let index = self.index;\n+        self.index += 1;\n+\n+        Some(CrateContext {\n+            shared: self.shared,\n+            local: &self.shared.local_ccxs[index],\n+            index: index,\n+        })\n+    }\n+}\n+\n+/// The iterator produced by `CrateContext::maybe_iter`.\n+pub struct CrateContextMaybeIterator<'a> {\n+    shared: &'a SharedCrateContext,\n+    index: uint,\n+    single: bool,\n+    origin: uint,\n }\n \n-impl CrateContext {\n-    pub fn new(name: &str,\n+impl<'a> Iterator<(CrateContext<'a>, bool)> for CrateContextMaybeIterator<'a> {\n+    fn next(&mut self) -> Option<(CrateContext<'a>, bool)> {\n+        if self.index >= self.shared.local_ccxs.len() {\n+            return None;\n+        }\n+\n+        let index = self.index;\n+        self.index += 1;\n+        if self.single {\n+            self.index = self.shared.local_ccxs.len();\n+        }\n+\n+        let ccx = CrateContext {\n+            shared: self.shared,\n+            local: &self.shared.local_ccxs[index],\n+            index: index,\n+        };\n+        Some((ccx, index == self.origin))\n+    }\n+}\n+\n+\n+unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n+    let llcx = llvm::LLVMContextCreate();\n+    let llmod = mod_name.with_c_str(|buf| {\n+        llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n+    });\n+    sess.targ_cfg\n+        .target_strs\n+        .data_layout\n+        .as_slice()\n+        .with_c_str(|buf| {\n+        llvm::LLVMSetDataLayout(llmod, buf);\n+    });\n+    sess.targ_cfg\n+        .target_strs\n+        .target_triple\n+        .as_slice()\n+        .with_c_str(|buf| {\n+        llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n+    });\n+    (llcx, llmod)\n+}\n+\n+impl SharedCrateContext {\n+    pub fn new(crate_name: &str,\n+               local_count: uint,\n                tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet)\n-               -> CrateContext {\n+               -> SharedCrateContext {\n+        let (metadata_llcx, metadata_llmod) = unsafe {\n+            create_context_and_module(&tcx.sess, \"metadata\")\n+        };\n+\n+        let mut shared_ccx = SharedCrateContext {\n+            local_ccxs: Vec::with_capacity(local_count),\n+            metadata_llmod: metadata_llmod,\n+            metadata_llcx: metadata_llcx,\n+            exp_map2: emap2,\n+            reachable: reachable,\n+            item_symbols: RefCell::new(NodeMap::new()),\n+            link_meta: link_meta,\n+            non_inlineable_statics: RefCell::new(NodeSet::new()),\n+            symbol_hasher: RefCell::new(symbol_hasher),\n+            tcx: tcx,\n+            stats: Stats {\n+                n_static_tydescs: Cell::new(0u),\n+                n_glues_created: Cell::new(0u),\n+                n_null_glues: Cell::new(0u),\n+                n_real_glues: Cell::new(0u),\n+                n_fns: Cell::new(0u),\n+                n_monos: Cell::new(0u),\n+                n_inlines: Cell::new(0u),\n+                n_closures: Cell::new(0u),\n+                n_llvm_insns: Cell::new(0u),\n+                llvm_insns: RefCell::new(HashMap::new()),\n+                fn_stats: RefCell::new(Vec::new()),\n+            },\n+            available_monomorphizations: RefCell::new(HashSet::new()),\n+            available_drop_glues: RefCell::new(HashMap::new()),\n+            available_visit_glues: RefCell::new(HashMap::new()),\n+        };\n+\n+        for i in range(0, local_count) {\n+            // Append \".rs\" to crate name as LLVM module identifier.\n+            //\n+            // LLVM code generator emits a \".file filename\" directive\n+            // for ELF backends. Value of the \"filename\" is set as the\n+            // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+            // crashes if the module identifier is same as other symbols\n+            // such as a function name in the module.\n+            // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+            let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n+            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id.as_slice());\n+            shared_ccx.local_ccxs.push(local_ccx);\n+        }\n+\n+        shared_ccx\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> CrateContextIterator<'a> {\n+        CrateContextIterator {\n+            shared: self,\n+            index: 0,\n+        }\n+    }\n+\n+    pub fn get_ccx<'a>(&'a self, index: uint) -> CrateContext<'a> {\n+        CrateContext {\n+            shared: self,\n+            local: &self.local_ccxs[index],\n+            index: index,\n+        }\n+    }\n+\n+    fn get_smallest_ccx<'a>(&'a self) -> CrateContext<'a> {\n+        let (local_ccx, index) =\n+            self.local_ccxs\n+                .iter()\n+                .zip(range(0, self.local_ccxs.len()))\n+                .min_by(|&(local_ccx, _idx)| local_ccx.n_llvm_insns.get())\n+                .unwrap();\n+        CrateContext {\n+            shared: self,\n+            local: local_ccx,\n+            index: index,\n+        }\n+    }\n+\n+\n+    pub fn metadata_llmod(&self) -> ModuleRef {\n+        self.metadata_llmod\n+    }\n+\n+    pub fn metadata_llcx(&self) -> ContextRef {\n+        self.metadata_llcx\n+    }\n+\n+    pub fn exp_map2<'a>(&'a self) -> &'a resolve::ExportMap2 {\n+        &self.exp_map2\n+    }\n+\n+    pub fn reachable<'a>(&'a self) -> &'a NodeSet {\n+        &self.reachable\n+    }\n+\n+    pub fn item_symbols<'a>(&'a self) -> &'a RefCell<NodeMap<String>> {\n+        &self.item_symbols\n+    }\n+\n+    pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n+        &self.link_meta\n+    }\n+\n+    pub fn non_inlineable_statics<'a>(&'a self) -> &'a RefCell<NodeSet> {\n+        &self.non_inlineable_statics\n+    }\n+\n+    pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n+        &self.symbol_hasher\n+    }\n+\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        &self.tcx\n+    }\n+\n+    pub fn take_tcx(self) -> ty::ctxt {\n+        self.tcx\n+    }\n+\n+    pub fn sess<'a>(&'a self) -> &'a Session {\n+        &self.tcx.sess\n+    }\n+\n+    pub fn stats<'a>(&'a self) -> &'a Stats {\n+        &self.stats\n+    }\n+}\n+\n+impl LocalCrateContext {\n+    fn new(shared: &SharedCrateContext,\n+           name: &str)\n+           -> LocalCrateContext {\n         unsafe {\n-            let llcx = llvm::LLVMContextCreate();\n-            let llmod = name.with_c_str(|buf| {\n-                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-            });\n-            let metadata_llmod = format!(\"{}_metadata\", name).with_c_str(|buf| {\n-                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-            });\n-            tcx.sess\n-               .targ_cfg\n-               .target_strs\n-               .data_layout\n-               .as_slice()\n-               .with_c_str(|buf| {\n-                llvm::LLVMSetDataLayout(llmod, buf);\n-                llvm::LLVMSetDataLayout(metadata_llmod, buf);\n-            });\n-            tcx.sess\n-               .targ_cfg\n-               .target_strs\n-               .target_triple\n-               .as_slice()\n-               .with_c_str(|buf| {\n-                llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n-                llvm::LLVMRustSetNormalizedTarget(metadata_llmod, buf);\n-            });\n-\n-            let td = mk_target_data(tcx.sess\n-                                       .targ_cfg\n-                                       .target_strs\n-                                       .data_layout\n-                                       .as_slice());\n-\n-            let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n+            let (llcx, llmod) = create_context_and_module(&shared.tcx.sess, name);\n+\n+            let td = mk_target_data(shared.tcx\n+                                          .sess\n+                                          .targ_cfg\n+                                          .target_strs\n+                                          .data_layout\n+                                          .as_slice());\n+\n+            let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n             } else {\n                 None\n             };\n \n-            let mut ccx = CrateContext {\n+            let mut local_ccx = LocalCrateContext {\n                 llmod: llmod,\n                 llcx: llcx,\n-                metadata_llmod: metadata_llmod,\n                 td: td,\n                 tn: TypeNames::new(),\n                 externs: RefCell::new(HashMap::new()),\n                 item_vals: RefCell::new(NodeMap::new()),\n-                exp_map2: emap2,\n-                reachable: reachable,\n-                item_symbols: RefCell::new(NodeMap::new()),\n-                link_meta: link_meta,\n                 drop_glues: RefCell::new(HashMap::new()),\n                 tydescs: RefCell::new(HashMap::new()),\n                 finished_tydescs: Cell::new(false),\n                 external: RefCell::new(DefIdMap::new()),\n                 external_srcs: RefCell::new(NodeMap::new()),\n-                non_inlineable_statics: RefCell::new(NodeSet::new()),\n                 monomorphized: RefCell::new(HashMap::new()),\n                 monomorphizing: RefCell::new(DefIdMap::new()),\n                 vtables: RefCell::new(HashMap::new()),\n@@ -205,67 +416,112 @@ impl CrateContext {\n                 lltypes: RefCell::new(HashMap::new()),\n                 llsizingtypes: RefCell::new(HashMap::new()),\n                 adt_reprs: RefCell::new(HashMap::new()),\n-                symbol_hasher: RefCell::new(symbol_hasher),\n                 type_hashcodes: RefCell::new(HashMap::new()),\n                 all_llvm_symbols: RefCell::new(HashSet::new()),\n-                tcx: tcx,\n-                stats: Stats {\n-                    n_static_tydescs: Cell::new(0u),\n-                    n_glues_created: Cell::new(0u),\n-                    n_null_glues: Cell::new(0u),\n-                    n_real_glues: Cell::new(0u),\n-                    n_fns: Cell::new(0u),\n-                    n_monos: Cell::new(0u),\n-                    n_inlines: Cell::new(0u),\n-                    n_closures: Cell::new(0u),\n-                    n_llvm_insns: Cell::new(0u),\n-                    llvm_insns: RefCell::new(HashMap::new()),\n-                    fn_stats: RefCell::new(Vec::new()),\n-                },\n                 int_type: Type::from_ref(ptr::mut_null()),\n                 opaque_vec_type: Type::from_ref(ptr::mut_null()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                 unboxed_closure_vals: RefCell::new(DefIdMap::new()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n                 intrinsics: RefCell::new(HashMap::new()),\n+                n_llvm_insns: Cell::new(0u),\n             };\n \n-            ccx.int_type = Type::int(&ccx);\n-            ccx.opaque_vec_type = Type::opaque_vec(&ccx);\n+            local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));\n+            local_ccx.opaque_vec_type = Type::opaque_vec(&local_ccx.dummy_ccx(shared));\n \n-            let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n-            str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type], false);\n-            ccx.tn.associate_type(\"str_slice\", &str_slice_ty);\n+            // Done mutating local_ccx directly.  (The rest of the\n+            // initialization goes through RefCell.)\n+            {\n+                let ccx = local_ccx.dummy_ccx(shared);\n \n-            ccx.tn.associate_type(\"tydesc\", &Type::tydesc(&ccx, str_slice_ty));\n+                let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n+                str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type()], false);\n+                ccx.tn().associate_type(\"str_slice\", &str_slice_ty);\n \n-            if ccx.sess().count_llvm_insns() {\n-                base::init_insn_ctxt()\n+                ccx.tn().associate_type(\"tydesc\", &Type::tydesc(&ccx, str_slice_ty));\n+\n+                if ccx.sess().count_llvm_insns() {\n+                    base::init_insn_ctxt()\n+                }\n             }\n \n-            ccx\n+            local_ccx\n         }\n     }\n \n+    /// Create a dummy `CrateContext` from `self` and  the provided\n+    /// `SharedCrateContext`.  This is somewhat dangerous because `self` may\n+    /// not actually be an element of `shared.local_ccxs`, which can cause some\n+    /// operations to `fail` unexpectedly.\n+    ///\n+    /// This is used in the `LocalCrateContext` constructor to allow calling\n+    /// functions that expect a complete `CrateContext`, even before the local\n+    /// portion is fully initialized and attached to the `SharedCrateContext`.\n+    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext) -> CrateContext<'a> {\n+        CrateContext {\n+            shared: shared,\n+            local: self,\n+            index: -1 as uint,\n+        }\n+    }\n+}\n+\n+impl<'b> CrateContext<'b> {\n+    pub fn shared(&self) -> &'b SharedCrateContext {\n+        self.shared\n+    }\n+\n+    pub fn local(&self) -> &'b LocalCrateContext {\n+        self.local\n+    }\n+\n+\n+    /// Get a (possibly) different `CrateContext` from the same\n+    /// `SharedCrateContext`.\n+    pub fn rotate(&self) -> CrateContext<'b> {\n+        self.shared.get_smallest_ccx()\n+    }\n+\n+    /// Either iterate over only `self`, or iterate over all `CrateContext`s in\n+    /// the `SharedCrateContext`.  The iterator produces `(ccx, is_origin)`\n+    /// pairs, where `is_origin` is `true` if `ccx` is `self` and `false`\n+    /// otherwise.  This method is useful for avoiding code duplication in\n+    /// cases where it may or may not be necessary to translate code into every\n+    /// context.\n+    pub fn maybe_iter(&self, iter_all: bool) -> CrateContextMaybeIterator<'b> {\n+        CrateContextMaybeIterator {\n+            shared: self.shared,\n+            index: if iter_all { 0 } else { self.index },\n+            single: !iter_all,\n+            origin: self.index,\n+        }\n+    }\n+\n+\n     pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n-        &self.tcx\n+        &self.shared.tcx\n     }\n \n     pub fn sess<'a>(&'a self) -> &'a Session {\n-        &self.tcx.sess\n+        &self.shared.tcx.sess\n     }\n \n     pub fn builder<'a>(&'a self) -> Builder<'a> {\n         Builder::new(self)\n     }\n \n+    pub fn raw_builder<'a>(&'a self) -> BuilderRef {\n+        self.local.builder.b\n+    }\n+\n     pub fn tydesc_type(&self) -> Type {\n-        self.tn.find_type(\"tydesc\").unwrap()\n+        self.local.tn.find_type(\"tydesc\").unwrap()\n     }\n \n     pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n-        match self.intrinsics.borrow().find_copy(key) {\n+        match self.intrinsics().borrow().find_copy(key) {\n             Some(v) => return v,\n             _ => {}\n         }\n@@ -286,22 +542,192 @@ impl CrateContext {\n         let ref cfg = self.sess().targ_cfg;\n         cfg.os != abi::OsiOS || cfg.arch != abi::Arm\n     }\n+\n+\n+    pub fn llmod(&self) -> ModuleRef {\n+        self.local.llmod\n+    }\n+\n+    pub fn llcx(&self) -> ContextRef {\n+        self.local.llcx\n+    }\n+\n+    pub fn td<'a>(&'a self) -> &'a TargetData {\n+        &self.local.td\n+    }\n+\n+    pub fn tn<'a>(&'a self) -> &'a TypeNames {\n+        &self.local.tn\n+    }\n+\n+    pub fn externs<'a>(&'a self) -> &'a RefCell<ExternMap> {\n+        &self.local.externs\n+    }\n+\n+    pub fn item_vals<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n+        &self.local.item_vals\n+    }\n+\n+    pub fn exp_map2<'a>(&'a self) -> &'a resolve::ExportMap2 {\n+        &self.shared.exp_map2\n+    }\n+\n+    pub fn reachable<'a>(&'a self) -> &'a NodeSet {\n+        &self.shared.reachable\n+    }\n+\n+    pub fn item_symbols<'a>(&'a self) -> &'a RefCell<NodeMap<String>> {\n+        &self.shared.item_symbols\n+    }\n+\n+    pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n+        &self.shared.link_meta\n+    }\n+\n+    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, ValueRef>> {\n+        &self.local.drop_glues\n+    }\n+\n+    pub fn tydescs<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Rc<tydesc_info>>> {\n+        &self.local.tydescs\n+    }\n+\n+    pub fn finished_tydescs<'a>(&'a self) -> &'a Cell<bool> {\n+        &self.local.finished_tydescs\n+    }\n+\n+    pub fn external<'a>(&'a self) -> &'a RefCell<DefIdMap<Option<ast::NodeId>>> {\n+        &self.local.external\n+    }\n+\n+    pub fn external_srcs<'a>(&'a self) -> &'a RefCell<NodeMap<ast::DefId>> {\n+        &self.local.external_srcs\n+    }\n+\n+    pub fn non_inlineable_statics<'a>(&'a self) -> &'a RefCell<NodeSet> {\n+        &self.shared.non_inlineable_statics\n+    }\n+\n+    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<HashMap<MonoId, ValueRef>> {\n+        &self.local.monomorphized\n+    }\n+\n+    pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<uint>> {\n+        &self.local.monomorphizing\n+    }\n+\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<HashMap<(ty::t, MonoId), ValueRef>> {\n+        &self.local.vtables\n+    }\n+\n+    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<HashMap<InternedString, ValueRef>> {\n+        &self.local.const_cstr_cache\n+    }\n+\n+    pub fn const_globals<'a>(&'a self) -> &'a RefCell<HashMap<int, ValueRef>> {\n+        &self.local.const_globals\n+    }\n+\n+    pub fn const_values<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n+        &self.local.const_values\n+    }\n+\n+    pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n+        &self.local.extern_const_values\n+    }\n+\n+    pub fn impl_method_cache<'a>(&'a self)\n+            -> &'a RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>> {\n+        &self.local.impl_method_cache\n+    }\n+\n+    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<HashMap<ValueRef, ValueRef>> {\n+        &self.local.closure_bare_wrapper_cache\n+    }\n+\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Type>> {\n+        &self.local.lltypes\n+    }\n+\n+    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Type>> {\n+        &self.local.llsizingtypes\n+    }\n+\n+    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Rc<adt::Repr>>> {\n+        &self.local.adt_reprs\n+    }\n+\n+    pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n+        &self.shared.symbol_hasher\n+    }\n+\n+    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, String>> {\n+        &self.local.type_hashcodes\n+    }\n+\n+    pub fn all_llvm_symbols<'a>(&'a self) -> &'a RefCell<HashSet<String>> {\n+        &self.local.all_llvm_symbols\n+    }\n+\n+    pub fn stats<'a>(&'a self) -> &'a Stats {\n+        &self.shared.stats\n+    }\n+\n+    pub fn available_monomorphizations<'a>(&'a self) -> &'a RefCell<HashSet<String>> {\n+        &self.shared.available_monomorphizations\n+    }\n+\n+    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, String>> {\n+        &self.shared.available_drop_glues\n+    }\n+\n+    pub fn available_visit_glues<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, String>> {\n+        &self.shared.available_visit_glues\n+    }\n+\n+    pub fn int_type(&self) -> Type {\n+        self.local.int_type\n+    }\n+\n+    pub fn opaque_vec_type(&self) -> Type {\n+        self.local.opaque_vec_type\n+    }\n+\n+    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n+        &self.local.unboxed_closure_vals\n+    }\n+\n+    pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext> {\n+        &self.local.dbg_cx\n+    }\n+\n+    pub fn eh_personality<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n+        &self.local.eh_personality\n+    }\n+\n+    fn intrinsics<'a>(&'a self) -> &'a RefCell<HashMap<&'static str, ValueRef>> {\n+        &self.local.intrinsics\n+    }\n+\n+    pub fn count_llvm_insn(&self) {\n+        self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n     macro_rules! ifn (\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, $name, Type::func([], &$ret), ty::mk_nil());\n-                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, $name,\n                                   Type::func([$($arg),*], &$ret), ty::mk_nil());\n-                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         )\n@@ -437,7 +863,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n                                       Type::func([$($arg),*], &$ret),\n                                       ty::mk_nil());\n-                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         )"}, {"sha": "008af804a60ba4e59f52f67afca2426d504dc23d", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -627,7 +627,7 @@ impl<K:KindOps> Datum<K> {\n     #[allow(dead_code)] // useful for debugging\n     pub fn to_string(&self, ccx: &CrateContext) -> String {\n         format!(\"Datum({}, {}, {:?})\",\n-                ccx.tn.val_to_string(self.val),\n+                ccx.tn().val_to_string(self.val),\n                 ty_to_string(ccx.tcx(), self.ty),\n                 self.kind)\n     }"}, {"sha": "01633bea9565ca6803c83a417a44835c94928704", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -538,7 +538,7 @@ impl TypeMap {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n-                match cx.external_srcs.borrow().find_copy(&def_id.node) {\n+                match cx.external_srcs().borrow().find_copy(&def_id.node) {\n                     Some(source_def_id) => {\n                         // The given def_id identifies the inlined copy of a\n                         // type definition, let's take the source of the copy.\n@@ -552,7 +552,7 @@ impl TypeMap {\n \n             // Get the crate hash as first part of the identifier.\n             let crate_hash = if source_def_id.krate == ast::LOCAL_CRATE {\n-                cx.link_meta.crate_hash.clone()\n+                cx.link_meta().crate_hash.clone()\n             } else {\n                 cx.sess().cstore.get_crate_hash(source_def_id.krate)\n             };\n@@ -721,7 +721,7 @@ enum VariableKind {\n \n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: &CrateContext) {\n-    if cx.dbg_cx.is_none() {\n+    if cx.dbg_cx().is_none() {\n         return;\n     }\n \n@@ -738,18 +738,18 @@ pub fn finalize(cx: &CrateContext) {\n         if cx.sess().targ_cfg.os == abi::OsMacos ||\n             cx.sess().targ_cfg.os == abi::OsiOS {\n             \"Dwarf Version\".with_c_str(\n-                |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s, 2));\n+                |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s, 2));\n         } else {\n             // FIXME(#13611) this is a kludge fix because the Linux bots have\n             //               gdb 7.4 which doesn't understand dwarf4, we should\n             //               do something more graceful here.\n             \"Dwarf Version\".with_c_str(\n-                |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s, 3));\n+                |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s, 3));\n         }\n \n         // Prevent bitcode readers from deleting the debug info.\n         \"Debug Info Version\".with_c_str(\n-            |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s,\n+            |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s,\n                                             llvm::LLVMRustDebugMetadataVersion));\n     };\n }\n@@ -760,19 +760,19 @@ pub fn finalize(cx: &CrateContext) {\n pub fn create_global_var_metadata(cx: &CrateContext,\n                                   node_id: ast::NodeId,\n                                   global: ValueRef) {\n-    if cx.dbg_cx.is_none() {\n+    if cx.dbg_cx().is_none() {\n         return;\n     }\n \n     // Don't create debuginfo for globals inlined from other crates. The other\n     // crate should already contain debuginfo for it. More importantly, the\n     // global might not even exist in un-inlined form anywhere which would lead\n     // to a linker errors.\n-    if cx.external_srcs.borrow().contains_key(&node_id) {\n+    if cx.external_srcs().borrow().contains_key(&node_id) {\n         return;\n     }\n \n-    let var_item = cx.tcx.map.get(node_id);\n+    let var_item = cx.tcx().map.get(node_id);\n \n     let (ident, span) = match var_item {\n         ast_map::NodeItem(item) => {\n@@ -838,7 +838,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     }\n \n     let cx = bcx.ccx();\n-    let def_map = &cx.tcx.def_map;\n+    let def_map = &cx.tcx().def_map;\n \n     pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n         let var_ident = path1.node;\n@@ -880,7 +880,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n \n     let cx = bcx.ccx();\n \n-    let ast_item = cx.tcx.map.find(node_id);\n+    let ast_item = cx.tcx().map.find(node_id);\n \n     let variable_ident = match ast_item {\n         None => {\n@@ -963,7 +963,7 @@ pub fn create_match_binding_metadata(bcx: &Block,\n \n     let scope_metadata = scope_metadata(bcx.fcx, binding.id, binding.span);\n     let aops = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref(bcx.ccx().int_type.to_ref())]\n+        [llvm::LLVMDIBuilderCreateOpDeref(bcx.ccx().int_type().to_ref())]\n     };\n     // Regardless of the actual type (`T`) we're always passed the stack slot (alloca)\n     // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n@@ -1002,7 +1002,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n \n-    let def_map = &cx.tcx.def_map;\n+    let def_map = &cx.tcx().def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n@@ -1120,7 +1120,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     let empty_generics = ast_util::empty_generics();\n \n-    let fnitem = cx.tcx.map.get(fn_ast_id);\n+    let fnitem = cx.tcx().map.get(fn_ast_id);\n \n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n@@ -1447,7 +1447,7 @@ fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // externally visible or by being inlined into something externally visible).\n     // It might better to use the `exported_items` set from `driver::CrateAnalysis`\n     // in the future, but (atm) this set is not available in the translation pass.\n-    !cx.reachable.contains(&node_id)\n+    !cx.reachable().contains(&node_id)\n }\n \n #[allow(non_snake_case)]\n@@ -1514,7 +1514,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n     });\n \n     fn fallback_path(cx: &CrateContext) -> CString {\n-        cx.link_meta.crate_name.as_slice().to_c_str()\n+        cx.link_meta().crate_name.as_slice().to_c_str()\n     }\n }\n \n@@ -1643,7 +1643,7 @@ fn scope_metadata(fcx: &FunctionContext,\n     match scope_map.borrow().find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n-            let node = fcx.ccx.tcx.map.get(node_id);\n+            let node = fcx.ccx.tcx().map.get(node_id);\n \n             fcx.ccx.sess().span_bug(span,\n                 format!(\"debuginfo: Could not find scope info for node {:?}\",\n@@ -2440,9 +2440,9 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                                   def_id: ast::DefId)\n                                   -> token::InternedString {\n         let name = if def_id.krate == ast::LOCAL_CRATE {\n-            cx.tcx.map.get_path_elem(def_id.node).name()\n+            cx.tcx().map.get_path_elem(def_id.node).name()\n         } else {\n-            csearch::get_item_path(&cx.tcx, def_id).last().unwrap().name()\n+            csearch::get_item_path(cx.tcx(), def_id).last().unwrap().name()\n         };\n \n         token::get_name(name)\n@@ -2685,7 +2685,7 @@ fn at_box_metadata(cx: &CrateContext,\n                              content_llvm_type: Type)\n                           -> bool {\n         member_llvm_types.len() == 5 &&\n-        member_llvm_types[0] == cx.int_type &&\n+        member_llvm_types[0] == cx.int_type() &&\n         member_llvm_types[1] == Type::generic_glue_fn(cx).ptr_to() &&\n         member_llvm_types[2] == Type::i8(cx).ptr_to() &&\n         member_llvm_types[3] == Type::i8(cx).ptr_to() &&\n@@ -2787,7 +2787,7 @@ fn vec_slice_metadata(cx: &CrateContext,\n                             -> bool {\n         member_llvm_types.len() == 2 &&\n         member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n-        member_llvm_types[1] == cx.int_type\n+        member_llvm_types[1] == cx.int_type()\n     }\n }\n \n@@ -3090,7 +3090,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n     };\n \n     unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(cx.builder.b, metadata_node);\n+        llvm::LLVMSetCurrentDebugLocation(cx.raw_builder(), metadata_node);\n     }\n \n     debug_context(cx).current_debug_location.set(debug_location);\n@@ -3125,14 +3125,14 @@ fn bytes_to_bits(bytes: u64) -> c_ulonglong {\n \n #[inline]\n fn debug_context<'a>(cx: &'a CrateContext) -> &'a CrateDebugContext {\n-    let debug_context: &'a CrateDebugContext = cx.dbg_cx.get_ref();\n+    let debug_context: &'a CrateDebugContext = cx.dbg_cx().get_ref();\n     debug_context\n }\n \n #[inline]\n #[allow(non_snake_case)]\n fn DIB(cx: &CrateContext) -> DIBuilderRef {\n-    cx.dbg_cx.get_ref().builder\n+    cx.dbg_cx().get_ref().builder\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n@@ -3143,7 +3143,7 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n }\n \n fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span: Span) {\n-    if !cx.tcx.node_types.borrow().contains_key(&(node_id as uint)) {\n+    if !cx.tcx().node_types.borrow().contains_key(&(node_id as uint)) {\n         cx.sess().span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n     }\n }\n@@ -3152,7 +3152,7 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n                                    -> (DIScope, Span) {\n     let containing_scope = namespace_for_item(cx, def_id).scope;\n     let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n-        cx.tcx.map.span(def_id.node)\n+        cx.tcx().map.span(def_id.node)\n     } else {\n         // For external items there is no span information\n         codemap::DUMMY_SP\n@@ -3173,7 +3173,7 @@ fn populate_scope_map(cx: &CrateContext,\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n-    let def_map = &cx.tcx.def_map;\n+    let def_map = &cx.tcx().def_map;\n \n     struct ScopeStackEntry {\n         scope_metadata: DIScope,\n@@ -3290,7 +3290,7 @@ fn populate_scope_map(cx: &CrateContext,\n                     scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n-        let def_map = &cx.tcx.def_map;\n+        let def_map = &cx.tcx().def_map;\n \n         // Unfortunately, we cannot just use pat_util::pat_bindings() or\n         // ast_util::walk_pat() here because we have to visit *all* nodes in\n@@ -3942,7 +3942,7 @@ impl NamespaceTreeNode {\n }\n \n fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    cx.link_meta.crate_name.as_slice()\n+    cx.link_meta().crate_name.as_slice()\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {"}, {"sha": "61c27292a3767c33c02b3d2840d734e1da93bd54", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -94,7 +94,7 @@ pub enum Dest {\n impl Dest {\n     pub fn to_string(&self, ccx: &CrateContext) -> String {\n         match *self {\n-            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn.val_to_string(v)),\n+            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn().val_to_string(v)),\n             Ignore => \"Ignore\".to_string()\n         }\n     }\n@@ -711,7 +711,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n     let mut bcx = bcx;\n \n     // Check for overloaded index.\n-    let method_ty = ccx.tcx\n+    let method_ty = ccx.tcx()\n                        .method_map\n                        .borrow()\n                        .find(&method_call)\n@@ -758,14 +758,14 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n             let ix_size = machine::llbitsize_of_real(bcx.ccx(),\n                                                      val_ty(ix_val));\n             let int_size = machine::llbitsize_of_real(bcx.ccx(),\n-                                                      ccx.int_type);\n+                                                      ccx.int_type());\n             let ix_val = {\n                 if ix_size < int_size {\n                     if ty::type_is_signed(expr_ty(bcx, idx)) {\n-                        SExt(bcx, ix_val, ccx.int_type)\n-                    } else { ZExt(bcx, ix_val, ccx.int_type) }\n+                        SExt(bcx, ix_val, ccx.int_type())\n+                    } else { ZExt(bcx, ix_val, ccx.int_type()) }\n                 } else if ix_size > int_size {\n-                    Trunc(bcx, ix_val, ccx.int_type)\n+                    Trunc(bcx, ix_val, ccx.int_type())\n                 } else {\n                     ix_val\n                 }\n@@ -817,13 +817,28 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n             trans_def_fn_unadjusted(bcx, ref_expr, def)\n         }\n         def::DefStatic(did, _) => {\n+            // There are three things that may happen here:\n+            //  1) If the static item is defined in this crate, it will be\n+            //     translated using `get_item_val`, and we return a pointer to\n+            //     the result.\n+            //  2) If the static item is defined in another crate, but is\n+            //     marked inlineable, then it will be inlined into this crate\n+            //     and then translated with `get_item_val`.  Again, we return a\n+            //     pointer to the result.\n+            //  3) If the static item is defined in another crate and is not\n+            //     marked inlineable, then we add (or reuse) a declaration of\n+            //     an external global, and return a pointer to that.\n             let const_ty = expr_ty(bcx, ref_expr);\n \n             fn get_did(ccx: &CrateContext, did: ast::DefId)\n                        -> ast::DefId {\n                 if did.krate != ast::LOCAL_CRATE {\n+                    // Case 2 or 3.  Which one we're in is determined by\n+                    // whether the DefId produced by `maybe_instantiate_inline`\n+                    // is in the LOCAL_CRATE or not.\n                     inline::maybe_instantiate_inline(ccx, did)\n                 } else {\n+                    // Case 1.\n                     did\n                 }\n             }\n@@ -832,14 +847,18 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                        -> ValueRef {\n                 // For external constants, we don't inline.\n                 if did.krate == ast::LOCAL_CRATE {\n+                    // Case 1 or 2.  (The inlining in case 2 produces a new\n+                    // DefId in LOCAL_CRATE.)\n+\n                     // The LLVM global has the type of its initializer,\n                     // which may not be equal to the enum's type for\n                     // non-C-like enums.\n                     let val = base::get_item_val(bcx.ccx(), did.node);\n                     let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n                     PointerCast(bcx, val, pty)\n                 } else {\n-                    match bcx.ccx().extern_const_values.borrow().find(&did) {\n+                    // Case 3.\n+                    match bcx.ccx().extern_const_values().borrow().find(&did) {\n                         None => {}  // Continue.\n                         Some(llval) => {\n                             return *llval;\n@@ -852,11 +871,11 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                             &bcx.ccx().sess().cstore,\n                             did);\n                         let llval = symbol.as_slice().with_c_str(|buf| {\n-                                llvm::LLVMAddGlobal(bcx.ccx().llmod,\n+                                llvm::LLVMAddGlobal(bcx.ccx().llmod(),\n                                                     llty.to_ref(),\n                                                     buf)\n                             });\n-                        bcx.ccx().extern_const_values.borrow_mut()\n+                        bcx.ccx().extern_const_values().borrow_mut()\n                            .insert(did, llval);\n                         llval\n                     }\n@@ -1439,7 +1458,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     // Otherwise, we should be in the RvalueDpsExpr path.\n     assert!(\n         op == ast::UnDeref ||\n-        !ccx.tcx.method_map.borrow().contains_key(&method_call));\n+        !ccx.tcx().method_map.borrow().contains_key(&method_call));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1706,7 +1725,7 @@ fn trans_binary<'a>(bcx: &'a Block<'a>,\n     let ccx = bcx.ccx();\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert!(!ccx.tcx.method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!ccx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n \n     match op {\n         ast::BiAnd => {\n@@ -2050,7 +2069,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n     let mut bcx = bcx;\n \n     // Check for overloaded deref.\n-    let method_ty = ccx.tcx.method_map.borrow()\n+    let method_ty = ccx.tcx().method_map.borrow()\n                        .find(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n         Some(method_ty) => {"}, {"sha": "8ed45f89c29e48dcc00577dcc1bbd085f6e64355", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -159,24 +159,32 @@ pub fn register_static(ccx: &CrateContext,\n                 }\n             };\n             unsafe {\n+                // Declare a symbol `foo` with the desired linkage.\n                 let g1 = ident.get().with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, llty2.to_ref(), buf)\n+                    llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(), buf)\n                 });\n                 llvm::SetLinkage(g1, linkage);\n \n+                // Declare an internal global `extern_with_linkage_foo` which\n+                // is initialized with the address of `foo`.  If `foo` is\n+                // discarded during linking (for example, if `foo` has weak\n+                // linkage and there are no definitions), then\n+                // `extern_with_linkage_foo` will instead be initialized to\n+                // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(ident.get());\n                 let g2 = real_name.with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n+                    llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf)\n                 });\n                 llvm::SetLinkage(g2, llvm::InternalLinkage);\n                 llvm::LLVMSetInitializer(g2, g1);\n                 g2\n             }\n         }\n         None => unsafe {\n+            // Generate an external declaration.\n             ident.get().with_c_str(|buf| {\n-                llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n+                llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf)\n             })\n         }\n     }\n@@ -229,7 +237,7 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n \n     let llfn = base::get_extern_fn(ccx,\n-                                   &mut *ccx.externs.borrow_mut(),\n+                                   &mut *ccx.externs().borrow_mut(),\n                                    name,\n                                    cc,\n                                    llfn_ty,\n@@ -271,8 +279,8 @@ pub fn trans_native_call<'a>(\n             llfn={}, \\\n             llretptr={})\",\n            callee_ty.repr(tcx),\n-           ccx.tn.val_to_string(llfn),\n-           ccx.tn.val_to_string(llretptr));\n+           ccx.tn().val_to_string(llfn),\n+           ccx.tn().val_to_string(llretptr));\n \n     let (fn_abi, fn_sig) = match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n@@ -319,9 +327,9 @@ pub fn trans_native_call<'a>(\n \n         debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n-               ccx.tn.val_to_string(llarg_rust),\n+               ccx.tn().val_to_string(llarg_rust),\n                rust_indirect,\n-               ccx.tn.type_to_string(arg_tys[i].ty));\n+               ccx.tn().type_to_string(arg_tys[i].ty));\n \n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n@@ -335,7 +343,7 @@ pub fn trans_native_call<'a>(\n         }\n \n         debug!(\"llarg_rust={} (after indirection)\",\n-               ccx.tn.val_to_string(llarg_rust));\n+               ccx.tn().val_to_string(llarg_rust));\n \n         // Check whether we need to do any casting\n         match arg_tys[i].cast {\n@@ -344,7 +352,7 @@ pub fn trans_native_call<'a>(\n         }\n \n         debug!(\"llarg_rust={} (after casting)\",\n-               ccx.tn.val_to_string(llarg_rust));\n+               ccx.tn().val_to_string(llarg_rust));\n \n         // Finally, load the value if needed for the foreign ABI\n         let foreign_indirect = arg_tys[i].is_indirect();\n@@ -360,7 +368,7 @@ pub fn trans_native_call<'a>(\n         };\n \n         debug!(\"argument {}, llarg_foreign={}\",\n-               i, ccx.tn.val_to_string(llarg_foreign));\n+               i, ccx.tn().val_to_string(llarg_foreign));\n \n         // fill padding with undef value\n         match arg_tys[i].pad {\n@@ -438,10 +446,10 @@ pub fn trans_native_call<'a>(\n             None => fn_type.ret_ty.ty\n         };\n \n-        debug!(\"llretptr={}\", ccx.tn.val_to_string(llretptr));\n-        debug!(\"llforeign_retval={}\", ccx.tn.val_to_string(llforeign_retval));\n-        debug!(\"llrust_ret_ty={}\", ccx.tn.type_to_string(llrust_ret_ty));\n-        debug!(\"llforeign_ret_ty={}\", ccx.tn.type_to_string(llforeign_ret_ty));\n+        debug!(\"llretptr={}\", ccx.tn().val_to_string(llretptr));\n+        debug!(\"llforeign_retval={}\", ccx.tn().val_to_string(llforeign_retval));\n+        debug!(\"llrust_ret_ty={}\", ccx.tn().type_to_string(llrust_ret_ty));\n+        debug!(\"llforeign_ret_ty={}\", ccx.tn().type_to_string(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n             base::store_ty(bcx, llforeign_retval, llretptr, fn_sig.output)\n@@ -490,13 +498,17 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                         register_foreign_item_fn(ccx, abi, ty,\n                                                  lname.get().as_slice(),\n                                                  Some(foreign_item.span));\n+                        // Unlike for other items, we shouldn't call\n+                        // `base::update_linkage` here.  Foreign items have\n+                        // special linkage requirements, which are handled\n+                        // inside `foreign::register_*`.\n                     }\n                 }\n             }\n             _ => {}\n         }\n \n-        ccx.item_symbols.borrow_mut().insert(foreign_item.id,\n+        ccx.item_symbols().borrow_mut().insert(foreign_item.id,\n                                              lname.get().to_string());\n     }\n }\n@@ -542,7 +554,7 @@ pub fn decl_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::mk_nil());\n     add_argument_attributes(&tys, llfn);\n     debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n-           ccx.tn.type_to_string(llfn_ty), ccx.tn.val_to_string(llfn));\n+           ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n     llfn\n }\n \n@@ -566,7 +578,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n     add_argument_attributes(&tys, llfn);\n     debug!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n-           node_id, ccx.tn.type_to_string(llfn_ty), ccx.tn.val_to_string(llfn));\n+           node_id, ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n     llfn\n }\n \n@@ -605,7 +617,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         let t = ty::node_id_to_type(tcx, id).subst(\n             ccx.tcx(), &param_substs.substs);\n \n-        let ps = ccx.tcx.map.with_path(id, |path| {\n+        let ps = ccx.tcx().map.with_path(id, |path| {\n             let abi = Some(ast_map::PathName(special_idents::clownshoe_abi.name));\n             link::mangle(path.chain(abi.move_iter()), hash)\n         });\n@@ -619,13 +631,13 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             _ => {\n                 ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n-                                       ccx.tcx.map.path_to_string(id),\n+                                       ccx.tcx().map.path_to_string(id),\n                                        t.repr(tcx)).as_slice());\n             }\n         };\n \n         debug!(\"build_rust_fn: path={} id={} t={}\",\n-               ccx.tcx.map.path_to_string(id),\n+               ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n         let llfn = base::decl_internal_rust_fn(ccx, t, ps.as_slice());\n@@ -644,8 +656,8 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         let tcx = ccx.tcx();\n \n         debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={})\",\n-               ccx.tn.val_to_string(llrustfn),\n-               ccx.tn.val_to_string(llwrapfn),\n+               ccx.tn().val_to_string(llrustfn),\n+               ccx.tn().val_to_string(llwrapfn),\n                t.repr(ccx.tcx()));\n \n         // Avoid all the Rust generation stuff and just generate raw\n@@ -661,7 +673,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n         let the_block =\n             \"the block\".with_c_str(\n-                |s| llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llwrapfn, s));\n+                |s| llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llwrapfn, s));\n \n         let builder = ccx.builder();\n         builder.position_at_end(the_block);\n@@ -702,11 +714,11 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             match foreign_outptr {\n                 Some(llforeign_outptr) => {\n                     debug!(\"out pointer, foreign={}\",\n-                           ccx.tn.val_to_string(llforeign_outptr));\n+                           ccx.tn().val_to_string(llforeign_outptr));\n                     let llrust_retptr =\n                         builder.bitcast(llforeign_outptr, llrust_ret_ty.ptr_to());\n                     debug!(\"out pointer, foreign={} (casted)\",\n-                           ccx.tn.val_to_string(llrust_retptr));\n+                           ccx.tn().val_to_string(llrust_retptr));\n                     llrust_args.push(llrust_retptr);\n                     return_alloca = None;\n                 }\n@@ -717,8 +729,8 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                             allocad={}, \\\n                             llrust_ret_ty={}, \\\n                             return_ty={}\",\n-                           ccx.tn.val_to_string(slot),\n-                           ccx.tn.type_to_string(llrust_ret_ty),\n+                           ccx.tn().val_to_string(slot),\n+                           ccx.tn().type_to_string(llrust_ret_ty),\n                            tys.fn_sig.output.repr(tcx));\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n@@ -752,7 +764,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             let mut llforeign_arg = get_param(llwrapfn, foreign_index);\n \n             debug!(\"llforeign_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn.val_to_string(llforeign_arg));\n+                   i, ccx.tn().val_to_string(llforeign_arg));\n             debug!(\"rust_indirect = {}, foreign_indirect = {}\",\n                    rust_indirect, foreign_indirect);\n \n@@ -791,12 +803,13 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             };\n \n             debug!(\"llrust_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn.val_to_string(llrust_arg));\n+                   i, ccx.tn().val_to_string(llrust_arg));\n             llrust_args.push(llrust_arg);\n         }\n \n         // Perform the call itself\n-        debug!(\"calling llrustfn = {}, t = {}\", ccx.tn.val_to_string(llrustfn), t.repr(ccx.tcx()));\n+        debug!(\"calling llrustfn = {}, t = {}\",\n+               ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n         let attributes = base::get_fn_llvm_attributes(ccx, t);\n         let llrust_ret_val = builder.call(llrustfn, llrust_args.as_slice(), Some(attributes));\n \n@@ -915,10 +928,10 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n-           ccx.tn.types_to_str(llsig.llarg_tys.as_slice()),\n-           ccx.tn.type_to_string(llsig.llret_ty),\n-           ccx.tn.types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n-           ccx.tn.type_to_string(fn_ty.ret_ty.ty),\n+           ccx.tn().types_to_str(llsig.llarg_tys.as_slice()),\n+           ccx.tn().type_to_string(llsig.llret_ty),\n+           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n+           ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n            ret_def);\n \n     ForeignTypes {"}, {"sha": "c8a47532a923ac8cb412a96d2dd79a3f054ba2d6", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -159,7 +159,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     let t = get_drop_glue_type(ccx, t);\n     debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    match ccx.drop_glues.borrow().find(&t) {\n+    match ccx.drop_glues().borrow().find(&t) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n@@ -171,11 +171,30 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     };\n \n     let llfnty = Type::glue_fn(ccx, llty);\n-    let glue = declare_generic_glue(ccx, t, llfnty, \"drop\");\n \n-    ccx.drop_glues.borrow_mut().insert(t, glue);\n+    let (glue, new_sym) = match ccx.available_drop_glues().borrow().find(&t) {\n+        Some(old_sym) => {\n+            let glue = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil());\n+            (glue, None)\n+        },\n+        None => {\n+            let (sym, glue) = declare_generic_glue(ccx, t, llfnty, \"drop\");\n+            (glue, Some(sym))\n+        },\n+    };\n \n-    make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n+    ccx.drop_glues().borrow_mut().insert(t, glue);\n+\n+    // To avoid infinite recursion, don't `make_drop_glue` until after we've\n+    // added the entry to the `drop_glues` cache.\n+    match new_sym {\n+        Some(sym) => {\n+            ccx.available_drop_glues().borrow_mut().insert(t, sym);\n+            // We're creating a new drop glue, so also generate a body.\n+            make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n+        },\n+        None => {},\n+    }\n \n     glue\n }\n@@ -189,9 +208,28 @@ pub fn lazily_emit_visit_glue(ccx: &CrateContext, ti: &tydesc_info) -> ValueRef\n         Some(visit_glue) => visit_glue,\n         None => {\n             debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_string(ccx.tcx(), ti.ty));\n-            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n+\n+            let (glue_fn, new_sym) = match ccx.available_visit_glues().borrow().find(&ti.ty) {\n+                Some(old_sym) => {\n+                    let glue_fn = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil());\n+                    (glue_fn, None)\n+                },\n+                None => {\n+                    let (sym, glue_fn) = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n+                    (glue_fn, Some(sym))\n+                },\n+            };\n+\n             ti.visit_glue.set(Some(glue_fn));\n-            make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n+\n+            match new_sym {\n+                Some(sym) => {\n+                    ccx.available_visit_glues().borrow_mut().insert(ti.ty, sym);\n+                    make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n+                },\n+                None => {},\n+            }\n+\n             debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_string(ccx.tcx(), ti.ty));\n             glue_fn\n         }\n@@ -566,7 +604,7 @@ fn incr_refcnt_of_boxed<'a>(bcx: &'a Block<'a>,\n pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n-    assert!(!ccx.finished_tydescs.get());\n+    assert!(!ccx.finished_tydescs().get());\n \n     let llty = type_of(ccx, t);\n \n@@ -581,7 +619,7 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n     let gvar = name.as_slice().with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type().to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(), buf)\n         }\n     });\n     note_unique_llvm_symbol(ccx, name);\n@@ -602,15 +640,15 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n }\n \n fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n-                        name: &str) -> ValueRef {\n+                        name: &str) -> (String, ValueRef) {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n         ccx,\n         t,\n         format!(\"glue_{}\", name).as_slice());\n     let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil());\n-    note_unique_llvm_symbol(ccx, fn_nm);\n-    return llfn;\n+    note_unique_llvm_symbol(ccx, fn_nm.clone());\n+    return (fn_nm, llfn);\n }\n \n fn make_generic_glue(ccx: &CrateContext,\n@@ -631,8 +669,9 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let bcx = init_function(&fcx, false, ty::mk_nil());\n \n-    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n-    ccx.stats.n_glues_created.set(ccx.stats.n_glues_created.get() + 1u);\n+    update_linkage(ccx, llfn, None, OriginalTranslation);\n+\n+    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1u);\n     // All glue functions take values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n     // the caller has no idea if it's dealing with something that can be\n@@ -651,27 +690,27 @@ fn make_generic_glue(ccx: &CrateContext,\n pub fn emit_tydescs(ccx: &CrateContext) {\n     let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n-    ccx.finished_tydescs.set(true);\n+    ccx.finished_tydescs().set(true);\n     let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n-    for (_, ti) in ccx.tydescs.borrow().iter() {\n+    for (_, ti) in ccx.tydescs().borrow().iter() {\n         // Each of the glue functions needs to be cast to a generic type\n         // before being put into the tydesc because we only have a singleton\n         // tydesc type. Then we'll recast each function to its real type when\n         // calling it.\n         let drop_glue = unsafe {\n             llvm::LLVMConstPointerCast(get_drop_glue(ccx, ti.ty), glue_fn_ty.to_ref())\n         };\n-        ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() + 1);\n+        ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() + 1);\n         let visit_glue =\n             match ti.visit_glue.get() {\n               None => {\n-                  ccx.stats.n_null_glues.set(ccx.stats.n_null_glues.get() +\n+                  ccx.stats().n_null_glues.set(ccx.stats().n_null_glues.get() +\n                                              1u);\n                   C_null(glue_fn_ty)\n               }\n               Some(v) => {\n                 unsafe {\n-                    ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() +\n+                    ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() +\n                                                1);\n                     llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }"}, {"sha": "0713b2b535c07d077011adee70dc50a89332e36e", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 61, "deletions": 32, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{AvailableExternallyLinkage, SetLinkage};\n+use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n use metadata::csearch;\n use middle::astencode;\n use middle::trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n@@ -22,7 +22,7 @@ use syntax::ast_util;\n pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> ast::DefId {\n     let _icx = push_ctxt(\"maybe_instantiate_inline\");\n-    match ccx.external.borrow().find(&fn_id) {\n+    match ccx.external().borrow().find(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline\n             debug!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n@@ -43,48 +43,74 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             |a,b,c,d| astencode::decode_inlined_item(a, b, c, d));\n     return match csearch_result {\n         csearch::not_found => {\n-            ccx.external.borrow_mut().insert(fn_id, None);\n+            ccx.external().borrow_mut().insert(fn_id, None);\n             fn_id\n         }\n         csearch::found(ast::IIItem(item)) => {\n-            ccx.external.borrow_mut().insert(fn_id, Some(item.id));\n-            ccx.external_srcs.borrow_mut().insert(item.id, fn_id);\n+            ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n+            ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n-            ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n+            ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n             trans_item(ccx, &*item);\n \n-            // We're bringing an external global into this crate, but we don't\n-            // want to create two copies of the global. If we do this, then if\n-            // you take the address of the global in two separate crates you get\n-            // two different addresses. This is bad for things like conditions,\n-            // but it could possibly have other adverse side effects. We still\n-            // want to achieve the optimizations related to this global,\n-            // however, so we use the available_externally linkage which llvm\n-            // provides\n-            match item.node {\n+            let linkage = match item.node {\n+                ast::ItemFn(_, _, _, ref generics, _) => {\n+                    if generics.is_type_parameterized() {\n+                        // Generics have no symbol, so they can't be given any\n+                        // linkage.\n+                        None\n+                    } else {\n+                        if ccx.sess().opts.cg.codegen_units == 1 {\n+                            // We could use AvailableExternallyLinkage here,\n+                            // but InternalLinkage allows LLVM to optimize more\n+                            // aggressively (at the cost of sometimes\n+                            // duplicating code).\n+                            Some(InternalLinkage)\n+                        } else {\n+                            // With multiple compilation units, duplicated code\n+                            // is more of a problem.  Also, `codegen_units > 1`\n+                            // means the user is okay with losing some\n+                            // performance.\n+                            Some(AvailableExternallyLinkage)\n+                        }\n+                    }\n+                }\n                 ast::ItemStatic(_, mutbl, _) => {\n-                    let g = get_item_val(ccx, item.id);\n-                    // see the comment in get_item_val() as to why this check is\n-                    // performed here.\n-                    if ast_util::static_has_significant_address(\n-                            mutbl,\n-                            item.attrs.as_slice()) {\n-                        SetLinkage(g, AvailableExternallyLinkage);\n+                    if !ast_util::static_has_significant_address(mutbl, item.attrs.as_slice()) {\n+                        // Inlined static items use internal linkage when\n+                        // possible, so that LLVM will coalesce globals with\n+                        // identical initializers.  (It only does this for\n+                        // globals with unnamed_addr and either internal or\n+                        // private linkage.)\n+                        Some(InternalLinkage)\n+                    } else {\n+                        // The address is significant, so we can't create an\n+                        // internal copy of the static.  (The copy would have a\n+                        // different address from the original.)\n+                        Some(AvailableExternallyLinkage)\n                     }\n                 }\n-                _ => {}\n+                _ => unreachable!(),\n+            };\n+\n+            match linkage {\n+                Some(linkage) => {\n+                    let g = get_item_val(ccx, item.id);\n+                    SetLinkage(g, linkage);\n+                }\n+                None => {}\n             }\n \n             local_def(item.id)\n         }\n         csearch::found(ast::IIForeign(item)) => {\n-            ccx.external.borrow_mut().insert(fn_id, Some(item.id));\n-            ccx.external_srcs.borrow_mut().insert(item.id, fn_id);\n+            ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n+            ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             local_def(item.id)\n         }\n         csearch::found_parent(parent_id, ast::IIItem(item)) => {\n-            ccx.external.borrow_mut().insert(parent_id, Some(item.id));\n-            ccx.external_srcs.borrow_mut().insert(item.id, parent_id);\n+            ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n+            ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n           let mut my_id = 0;\n           match item.node {\n@@ -93,14 +119,14 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n               let vs_there = ty::enum_variants(ccx.tcx(), parent_id);\n               for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n-                  ccx.external.borrow_mut().insert(there.id, Some(here.id.node));\n+                  ccx.external().borrow_mut().insert(there.id, Some(here.id.node));\n               }\n             }\n             ast::ItemStruct(ref struct_def, _) => {\n               match struct_def.ctor_id {\n                 None => {}\n                 Some(ctor_id) => {\n-                    ccx.external.borrow_mut().insert(fn_id, Some(ctor_id));\n+                    ccx.external().borrow_mut().insert(fn_id, Some(ctor_id));\n                     my_id = ctor_id;\n                 }\n               }\n@@ -119,10 +145,10 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             match impl_item {\n                 ast::ProvidedInlinedTraitItem(mth) |\n                 ast::RequiredInlinedTraitItem(mth) => {\n-                    ccx.external.borrow_mut().insert(fn_id, Some(mth.id));\n-                    ccx.external_srcs.borrow_mut().insert(mth.id, fn_id);\n+                    ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n+                    ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n \n-                    ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n+                    ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n                 }\n             }\n \n@@ -147,6 +173,9 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                                  &param_substs::empty(),\n                                  mth.id,\n                                  []);\n+                        // Use InternalLinkage so LLVM can optimize more\n+                        // aggressively.\n+                        SetLinkage(llfn, InternalLinkage);\n                     }\n                     local_def(mth.id)\n                 }"}, {"sha": "f10df00ca9184a875b2a779ceec2949012374b4d", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -89,7 +89,7 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Opti\n /// Performs late verification that intrinsics are used correctly. At present,\n /// the only intrinsic that needs such verification is `transmute`.\n pub fn check_intrinsics(ccx: &CrateContext) {\n-    for transmute_restriction in ccx.tcx\n+    for transmute_restriction in ccx.tcx()\n                                     .transmute_restrictions\n                                     .borrow()\n                                     .iter() {\n@@ -276,7 +276,7 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n             let hash = ty::hash_crate_independent(\n                 ccx.tcx(),\n                 *substs.types.get(FnSpace, 0),\n-                &ccx.link_meta.crate_hash);\n+                &ccx.link_meta().crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     the intrinsic module\n             C_named_struct(llret_ty, [C_u64(ccx, hash)])\n@@ -554,7 +554,7 @@ fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool,\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type);\n+    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n     let name = if allow_overlap {\n         if int_size == 32 {\n             \"llvm.memmove.p0i8.p0i8.i32\"\n@@ -583,7 +583,7 @@ fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let name = if machine::llbitsize_of_real(ccx, ccx.int_type) == 32 {\n+    let name = if machine::llbitsize_of_real(ccx, ccx.int_type()) == 32 {\n         \"llvm.memset.p0i8.i32\"\n     } else {\n         \"llvm.memset.p0i8.i64\""}, {"sha": "5aec1cfbf268a3001751b0d8e393f7ed0e8ab944", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -25,13 +25,13 @@ impl<'a, T:LlvmRepr> LlvmRepr for &'a [T] {\n \n impl LlvmRepr for Type {\n     fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn.type_to_string(*self)\n+        ccx.tn().type_to_string(*self)\n     }\n }\n \n impl LlvmRepr for ValueRef {\n     fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn.val_to_string(*self)\n+        ccx.tn().val_to_string(*self)\n     }\n }\n "}, {"sha": "938cbc21764687bedb5f79eff17bc59a14104e37", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -23,15 +23,15 @@ use middle::trans::type_::Type;\n // Returns the number of bytes clobbered by a Store to this type.\n pub fn llsize_of_store(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        return llvm::LLVMStoreSizeOfType(cx.td.lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMStoreSizeOfType(cx.td().lltd, ty.to_ref()) as u64;\n     }\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        return llvm::LLVMABISizeOfType(cx.td.lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMABISizeOfType(cx.td().lltd, ty.to_ref()) as u64;\n     }\n }\n \n@@ -45,7 +45,7 @@ pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> u64 {\n // below.\n pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, ty.to_ref()) as u64;\n+        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref()) as u64;\n         if nbits & 7 != 0 {\n             // Not an even number of bytes, spills into \"next\" byte.\n             1 + (nbits >> 3)\n@@ -58,7 +58,7 @@ pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n /// Returns the \"real\" size of the type in bits.\n pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        llvm::LLVMSizeOfTypeInBits(cx.td.lltd, ty.to_ref()) as u64\n+        llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref()) as u64\n     }\n }\n \n@@ -79,7 +79,7 @@ pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n // space to be consumed.\n pub fn nonzero_llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     if llbitsize_of_real(cx, ty) == 0 {\n-        unsafe { llvm::LLVMConstInt(cx.int_type.to_ref(), 1, False) }\n+        unsafe { llvm::LLVMConstInt(cx.int_type().to_ref(), 1, False) }\n     } else {\n         llsize_of(cx, ty)\n     }\n@@ -91,7 +91,7 @@ pub fn nonzero_llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n // allocations inside a stack frame, which LLVM has a free hand in.\n pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMPreferredAlignmentOfType(cx.td().lltd, ty.to_ref()) as u64;\n     }\n }\n \n@@ -100,7 +100,7 @@ pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> u64 {\n // and similar ABI-mandated things.\n pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        return llvm::LLVMABIAlignmentOfType(cx.td.lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMABIAlignmentOfType(cx.td().lltd, ty.to_ref()) as u64;\n     }\n }\n \n@@ -110,12 +110,12 @@ pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> u64 {\n pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstIntCast(\n-            llvm::LLVMAlignOf(ty.to_ref()), cx.int_type.to_ref(), False);\n+            llvm::LLVMAlignOf(ty.to_ref()), cx.int_type().to_ref(), False);\n     }\n }\n \n pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> u64 {\n     unsafe {\n-        return llvm::LLVMOffsetOfElement(cx.td.lltd, struct_ty.to_ref(), element as u32) as u64;\n+        return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(), element as u32) as u64;\n     }\n }"}, {"sha": "c002f3e72c89f753ef4b4a9c82176541e2109324", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -38,7 +38,7 @@ use util::ppaux::Repr;\n use std::c_str::ToCStr;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n-use syntax::{ast, ast_map, visit};\n+use syntax::{ast, ast_map, attr, visit};\n use syntax::ast_util::PostExpansionMethod;\n \n // drop_glue pointer, size, align.\n@@ -77,14 +77,21 @@ pub fn trans_impl(ccx: &CrateContext,\n         match *impl_item {\n             ast::MethodImplItem(method) => {\n                 if method.pe_generics().ty_params.len() == 0u {\n-                    let llfn = get_item_val(ccx, method.id);\n-                    trans_fn(ccx,\n-                             &*method.pe_fn_decl(),\n-                             &*method.pe_body(),\n-                             llfn,\n-                             &param_substs::empty(),\n-                             method.id,\n-                             []);\n+                    let trans_everywhere = attr::requests_inline(method.attrs.as_slice());\n+                    for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n+                        let llfn = get_item_val(ccx, method.id);\n+                        trans_fn(ccx,\n+                                 &*method.pe_fn_decl(),\n+                                 &*method.pe_body(),\n+                                 llfn,\n+                                 &param_substs::empty(),\n+                                 method.id,\n+                                 []);\n+                        update_linkage(ccx,\n+                                       llfn,\n+                                       Some(method.id),\n+                                       if is_origin { OriginalTranslation } else { InlinedCopy });\n+                    }\n                 }\n                 let mut v = TransItemVisitor {\n                     ccx: ccx,\n@@ -196,7 +203,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n     let vtable_key = MethodCall::expr(expr_id);\n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx,\n-        ccx.tcx.vtable_map.borrow().get(&vtable_key));\n+        ccx.tcx().vtable_map.borrow().get(&vtable_key));\n \n     match *vtbls.get_self().unwrap().get(0) {\n         typeck::vtable_static(impl_did, ref rcvr_substs, ref rcvr_origins) => {\n@@ -228,20 +235,20 @@ pub fn trans_static_method_callee(bcx: &Block,\n \n fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                     -> ast::DefId {\n-    match ccx.impl_method_cache.borrow().find_copy(&(impl_id, name)) {\n+    match ccx.impl_method_cache().borrow().find_copy(&(impl_id, name)) {\n         Some(m) => return m,\n         None => {}\n     }\n \n-    let impl_items = ccx.tcx.impl_items.borrow();\n+    let impl_items = ccx.tcx().impl_items.borrow();\n     let impl_items =\n         impl_items.find(&impl_id)\n                   .expect(\"could not find impl while translating\");\n     let meth_did = impl_items.iter()\n                              .find(|&did| {\n                                 match *did {\n                                     ty::MethodTraitItemId(did) => {\n-                                        ty::impl_or_trait_item(&ccx.tcx,\n+                                        ty::impl_or_trait_item(ccx.tcx(),\n                                                                did).ident()\n                                                                    .name ==\n                                             name\n@@ -250,7 +257,7 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                              }).expect(\"could not find method while \\\n                                         translating\");\n \n-    ccx.impl_method_cache.borrow_mut().insert((impl_id, name),\n+    ccx.impl_method_cache().borrow_mut().insert((impl_id, name),\n                                               meth_did.def_id());\n     meth_did.def_id()\n }\n@@ -502,7 +509,7 @@ fn get_vtable(bcx: &Block,\n \n     // Check the cache.\n     let hash_id = (self_ty, monomorphize::make_vtable_id(ccx, origins.get(0)));\n-    match ccx.vtables.borrow().find(&hash_id) {\n+    match ccx.vtables().borrow().find(&hash_id) {\n         Some(&val) => { return val }\n         None => { }\n     }\n@@ -594,7 +601,7 @@ fn get_vtable(bcx: &Block,\n     let drop_glue = glue::get_drop_glue(ccx, self_ty);\n     let vtable = make_vtable(ccx, drop_glue, ll_size, ll_align, methods);\n \n-    ccx.vtables.borrow_mut().insert(hash_id, vtable);\n+    ccx.vtables().borrow_mut().insert(hash_id, vtable);\n     vtable\n }\n \n@@ -614,7 +621,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n         let tbl = C_struct(ccx, components.as_slice(), false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(), buf)\n         });\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, llvm::True);\n@@ -684,9 +691,9 @@ pub fn vtable_ptr<'a>(bcx: &'a Block<'a>,\n                       self_ty: ty::t) -> ValueRef {\n     let ccx = bcx.ccx();\n     let origins = {\n-        let vtable_map = ccx.tcx.vtable_map.borrow();\n+        let vtable_map = ccx.tcx().vtable_map.borrow();\n         // This trait cast might be because of implicit coercion\n-        let adjs = ccx.tcx.adjustments.borrow();\n+        let adjs = ccx.tcx().adjustments.borrow();\n         let adjust = adjs.find(&id);\n         let method_call = if adjust.is_some() && ty::adjust_is_object(adjust.unwrap()) {\n             MethodCall::autoobject(id)"}, {"sha": "1cf3e55967d4e5b65013f040a5772b74e18818d2", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -11,6 +11,7 @@\n use back::link::exported_name;\n use driver::session;\n use llvm::ValueRef;\n+use llvm;\n use middle::subst;\n use middle::subst::Subst;\n use middle::trans::base::{set_llvm_fn_attrs, set_inline_hint};\n@@ -27,6 +28,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n+use syntax::attr;\n use std::hash::{sip, Hash};\n \n pub fn monomorphic_fn(ccx: &CrateContext,\n@@ -56,7 +58,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         params: real_substs.types.clone()\n     };\n \n-    match ccx.monomorphized.borrow().find(&hash_id) {\n+    match ccx.monomorphized().borrow().find(&hash_id) {\n         Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n             ty::item_path_str(ccx.tcx(), fn_id));\n@@ -83,7 +85,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     let map_node = session::expect(\n         ccx.sess(),\n-        ccx.tcx.map.find(fn_id.node),\n+        ccx.tcx().map.find(fn_id.node),\n         || {\n             format!(\"while monomorphizing {:?}, couldn't find it in \\\n                      the item map (may have attempted to monomorphize \\\n@@ -93,7 +95,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     match map_node {\n         ast_map::NodeForeignItem(_) => {\n-            if ccx.tcx.map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n+            if ccx.tcx().map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n                 // Foreign externs don't have to be monomorphized.\n                 return (get_item_val(ccx, fn_id.node), true);\n             }\n@@ -104,11 +106,11 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n     let mono_ty = llitem_ty.subst(ccx.tcx(), real_substs);\n \n-    ccx.stats.n_monos.set(ccx.stats.n_monos.get() + 1);\n+    ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n     let depth;\n     {\n-        let mut monomorphizing = ccx.monomorphizing.borrow_mut();\n+        let mut monomorphizing = ccx.monomorphizing().borrow_mut();\n         depth = match monomorphizing.find(&fn_id) {\n             Some(&d) => d, None => 0\n         };\n@@ -117,7 +119,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n         if depth > ccx.sess().recursion_limit.get() {\n-            ccx.sess().span_fatal(ccx.tcx.map.span(fn_id.node),\n+            ccx.sess().span_fatal(ccx.tcx().map.span(fn_id.node),\n                 \"reached the recursion limit during monomorphization\");\n         }\n \n@@ -131,7 +133,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         mono_ty.hash(&mut state);\n \n         hash = format!(\"h{}\", state.result());\n-        ccx.tcx.map.with_path(fn_id.node, |path| {\n+        ccx.tcx().map.with_path(fn_id.node, |path| {\n             exported_name(path, hash.as_slice())\n         })\n     };\n@@ -147,9 +149,28 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             decl_internal_rust_fn(ccx, mono_ty, s.as_slice())\n         };\n \n-        ccx.monomorphized.borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n+        ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n         lldecl\n     };\n+    let setup_lldecl = |lldecl, attrs: &[ast::Attribute]| {\n+        base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n+        set_llvm_fn_attrs(attrs, lldecl);\n+\n+        let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n+        if is_first {\n+            ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n+        }\n+\n+        let trans_everywhere = attr::requests_inline(attrs);\n+        if trans_everywhere && !is_first {\n+            llvm::SetLinkage(lldecl, llvm::AvailableExternallyLinkage);\n+        }\n+\n+        // If `true`, then `lldecl` should be given a function body.\n+        // Otherwise, it should be left as a declaration of an external\n+        // function, with no definition in the current compilation unit.\n+        trans_everywhere || is_first\n+    };\n \n     let lldecl = match map_node {\n         ast_map::NodeItem(i) => {\n@@ -159,14 +180,15 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);\n-                  set_llvm_fn_attrs(i.attrs.as_slice(), d);\n-\n-                  if abi != abi::Rust {\n-                      foreign::trans_rust_fn_with_foreign_abi(\n-                          ccx, &**decl, &**body, [], d, &psubsts, fn_id.node,\n-                          Some(hash.as_slice()));\n-                  } else {\n-                      trans_fn(ccx, &**decl, &**body, d, &psubsts, fn_id.node, []);\n+                  let needs_body = setup_lldecl(d, i.attrs.as_slice());\n+                  if needs_body {\n+                      if abi != abi::Rust {\n+                          foreign::trans_rust_fn_with_foreign_abi(\n+                              ccx, &**decl, &**body, [], d, &psubsts, fn_id.node,\n+                              Some(hash.as_slice()));\n+                      } else {\n+                          trans_fn(ccx, &**decl, &**body, d, &psubsts, fn_id.node, []);\n+                      }\n                   }\n \n                   d\n@@ -177,7 +199,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             }\n         }\n         ast_map::NodeVariant(v) => {\n-            let parent = ccx.tcx.map.get_parent(fn_id.node);\n+            let parent = ccx.tcx().map.get_parent(fn_id.node);\n             let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n             let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl(abi::Rust);\n@@ -201,14 +223,16 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             match *ii {\n                 ast::MethodImplItem(mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    trans_fn(ccx,\n-                             &*mth.pe_fn_decl(),\n-                             &*mth.pe_body(),\n-                             d,\n-                             &psubsts,\n-                             mth.id,\n-                             []);\n+                    let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n+                    if needs_body {\n+                        trans_fn(ccx,\n+                                 &*mth.pe_fn_decl(),\n+                                 &*mth.pe_body(),\n+                                 d,\n+                                 &psubsts,\n+                                 mth.id,\n+                                 []);\n+                    }\n                     d\n                 }\n             }\n@@ -217,9 +241,11 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             match *method {\n                 ast::ProvidedMethod(mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), d,\n-                             &psubsts, mth.id, []);\n+                    let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n+                    if needs_body {\n+                        trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), d,\n+                                 &psubsts, mth.id, []);\n+                    }\n                     d\n                 }\n                 _ => {\n@@ -254,7 +280,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n     };\n \n-    ccx.monomorphizing.borrow_mut().insert(fn_id, depth);\n+    ccx.monomorphizing().borrow_mut().insert(fn_id, depth);\n \n     debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx(), fn_id));\n     (lldecl, true)"}, {"sha": "1fcf4c189129b0b3cd7d82ad5b33787d62479953", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -335,7 +335,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                 let sym = mangle_internal_name_by_path_and_seq(\n                     ast_map::Values([].iter()).chain(None), \"get_disr\");\n \n-                let fn_ty = ty::mk_ctor_fn(&ccx.tcx, ast::DUMMY_NODE_ID,\n+                let fn_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n                                            [opaqueptrty], ty::mk_u64());\n                 let llfdecl = decl_internal_rust_fn(ccx,\n                                                     fn_ty,"}, {"sha": "3701d83d6a122e87910e16e9a237b5bbf902090c", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -94,8 +94,8 @@ impl VecTypes {\n         format!(\"VecTypes {{unit_ty={}, llunit_ty={}, \\\n                  llunit_size={}, llunit_alloc_size={}}}\",\n                 ty_to_string(ccx.tcx(), self.unit_ty),\n-                ccx.tn.type_to_string(self.llunit_ty),\n-                ccx.tn.val_to_string(self.llunit_size),\n+                ccx.tn().type_to_string(self.llunit_ty),\n+                ccx.tn().val_to_string(self.llunit_size),\n                 self.llunit_alloc_size)\n     }\n }\n@@ -546,7 +546,7 @@ pub fn iter_vec_loop<'r,\n \n     let loop_counter = {\n         // i = 0\n-        let i = alloca(loop_bcx, bcx.ccx().int_type, \"__i\");\n+        let i = alloca(loop_bcx, bcx.ccx().int_type(), \"__i\");\n         Store(loop_bcx, C_uint(bcx.ccx(), 0), i);\n \n         Br(loop_bcx, cond_bcx.llbb);"}, {"sha": "3df1ce32fc7d751fcba880fcfd77e235b07f8d1f", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -53,43 +53,43 @@ impl Type {\n     }\n \n     pub fn void(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx()))\n     }\n \n     pub fn nil(ccx: &CrateContext) -> Type {\n         Type::empty_struct(ccx)\n     }\n \n     pub fn metadata(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMMetadataTypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMMetadataTypeInContext(ccx.llcx()))\n     }\n \n     pub fn i1(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx()))\n     }\n \n     pub fn i8(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx()))\n     }\n \n     pub fn i16(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx()))\n     }\n \n     pub fn i32(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx()))\n     }\n \n     pub fn i64(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx()))\n     }\n \n     pub fn f32(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx()))\n     }\n \n     pub fn f64(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx()))\n     }\n \n     pub fn bool(ccx: &CrateContext) -> Type {\n@@ -105,15 +105,15 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match ccx.tcx.sess.targ_cfg.arch {\n+        match ccx.tcx().sess.targ_cfg.arch {\n             X86 | Arm | Mips | Mipsel => Type::i32(ccx),\n             X86_64 => Type::i64(ccx)\n         }\n     }\n \n     pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::TyI => ccx.int_type,\n+            ast::TyI => ccx.int_type(),\n             ast::TyI8 => Type::i8(ccx),\n             ast::TyI16 => Type::i16(ccx),\n             ast::TyI32 => Type::i32(ccx),\n@@ -123,7 +123,7 @@ impl Type {\n \n     pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::TyU => ccx.int_type,\n+            ast::TyU => ccx.int_type(),\n             ast::TyU8 => Type::i8(ccx),\n             ast::TyU16 => Type::i16(ccx),\n             ast::TyU32 => Type::i32(ccx),\n@@ -152,13 +152,13 @@ impl Type {\n \n     pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n         let els : &[TypeRef] = unsafe { mem::transmute(els) };\n-        ty!(llvm::LLVMStructTypeInContext(ccx.llcx, els.as_ptr(),\n+        ty!(llvm::LLVMStructTypeInContext(ccx.llcx(), els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool))\n     }\n \n     pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n-        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ccx.llcx, s)))\n+        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ccx.llcx(), s)))\n     }\n \n     pub fn empty_struct(ccx: &CrateContext) -> Type {\n@@ -170,13 +170,13 @@ impl Type {\n     }\n \n     pub fn generic_glue_fn(cx: &CrateContext) -> Type {\n-        match cx.tn.find_type(\"glue_fn\") {\n+        match cx.tn().find_type(\"glue_fn\") {\n             Some(ty) => return ty,\n             None => ()\n         }\n \n         let ty = Type::glue_fn(cx, Type::i8p(cx));\n-        cx.tn.associate_type(\"glue_fn\", &ty);\n+        cx.tn().associate_type(\"glue_fn\", &ty);\n \n         ty\n     }\n@@ -226,7 +226,7 @@ impl Type {\n     // The box pointed to by @T.\n     pub fn at_box(ccx: &CrateContext, ty: Type) -> Type {\n         Type::struct_(ccx, [\n-            ccx.int_type, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n+            ccx.int_type(), Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n             Type::i8p(ccx), Type::i8p(ccx), ty\n         ], false)\n     }"}, {"sha": "54f24516867f06438108fd9915522bdf8e93ca2e", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -156,7 +156,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n //     recursive types. For example, enum types rely on this behavior.\n \n pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n-    match cx.llsizingtypes.borrow().find_copy(&t) {\n+    match cx.llsizingtypes().borrow().find_copy(&t) {\n         Some(t) => return t,\n         None => ()\n     }\n@@ -217,7 +217,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => fail!(\"unreachable\")\n     };\n \n-    cx.llsizingtypes.borrow_mut().insert(t, llsizingty);\n+    cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n     llsizingty\n }\n \n@@ -249,7 +249,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     // Check the cache.\n-    match cx.lltypes.borrow().find(&t) {\n+    match cx.lltypes().borrow().find(&t) {\n         Some(&llty) => return llty,\n         None => ()\n     }\n@@ -270,8 +270,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                 t,\n                 t_norm.repr(cx.tcx()),\n                 t_norm,\n-                cx.tn.type_to_string(llty));\n-        cx.lltypes.borrow_mut().insert(t, llty);\n+                cx.tn().type_to_string(llty));\n+        cx.lltypes().borrow_mut().insert(t, llty);\n         return llty;\n     }\n \n@@ -308,7 +308,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               ty::ty_str => {\n                   // This means we get a nicer name in the output (str is always\n                   // unsized).\n-                  cx.tn.find_type(\"str_slice\").unwrap()\n+                  cx.tn().find_type(\"str_slice\").unwrap()\n               }\n               ty::ty_trait(..) => Type::opaque_trait(cx),\n               _ if !ty::type_is_sized(cx.tcx(), ty) => {\n@@ -385,9 +385,9 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     debug!(\"--> mapped t={} {:?} to llty={}\",\n             t.repr(cx.tcx()),\n             t,\n-            cx.tn.type_to_string(llty));\n+            cx.tn().type_to_string(llty));\n \n-    cx.lltypes.borrow_mut().insert(t, llty);\n+    cx.lltypes().borrow_mut().insert(t, llty);\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {"}, {"sha": "ceb29ddcf8fe5e0ab2f094b88fdcbf94df034c1b", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -331,7 +331,7 @@ pub enum AsmDialect {\n     AD_Intel = 1\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Clone)]\n #[repr(C)]\n pub enum CodeGenOptLevel {\n     CodeGenLevelNone = 0,"}, {"sha": "d2345614b25c218ce1433115dc215c1d1b7a78e4", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -20,7 +20,7 @@ use std::string::String;\n \n use std::collections::{HashSet, HashMap};\n use testing;\n-use rustc::back::link;\n+use rustc::back::write;\n use rustc::driver::config;\n use rustc::driver::driver;\n use rustc::driver::session;\n@@ -120,7 +120,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, externs: core::Exte\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(config::CrateTypeExecutable),\n-        output_types: vec!(link::OutputTypeExe),\n+        output_types: vec!(write::OutputTypeExe),\n         no_trans: no_run,\n         externs: externs,\n         cg: config::CodegenOptions {"}, {"sha": "dd422d021493fdd4d802681779d5987137822853", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -280,7 +280,7 @@ pub enum InlineAttr {\n     InlineNever,\n }\n \n-/// True if something like #[inline] is found in the list of attrs.\n+/// Determine what `#[inline]` attribute is present in `attrs`, if any.\n pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     attrs.iter().fold(InlineNone, |ia,attr| {\n@@ -304,6 +304,14 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     })\n }\n \n+/// True if `#[inline]` or `#[inline(always)]` is present in `attrs`.\n+pub fn requests_inline(attrs: &[Attribute]) -> bool {\n+    match find_inline_attr(attrs) {\n+        InlineHint | InlineAlways => true,\n+        InlineNone | InlineNever => false,\n+    }\n+}\n+\n /// Tests if any `cfg(...)` meta items in `metas` match `cfg`. e.g.\n ///\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(foo), cfg(bar)]`) == true"}, {"sha": "8f5d3b5768a1a1d6a56767fc0dc21447c59bb5dc", "filename": "src/test/auxiliary/sepcomp-extern-lib.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Fauxiliary%2Fsepcomp-extern-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Fauxiliary%2Fsepcomp-extern-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsepcomp-extern-lib.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_mangle]\n+pub extern \"C\" fn foo() -> uint {\n+    1234\n+}"}, {"sha": "1cb7ead2cff05a85e64be99693cd9143318e68a6", "filename": "src/test/auxiliary/sepcomp_cci_lib.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Fauxiliary%2Fsepcomp_cci_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Fauxiliary%2Fsepcomp_cci_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsepcomp_cci_lib.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[inline]\n+pub fn cci_fn() -> uint {\n+    1200\n+}\n+\n+#[inline]\n+pub static CCI_STATIC: uint = 34;"}, {"sha": "d1d9e3b8ff3ac7b12890e765d2fc546faa6d6d71", "filename": "src/test/auxiliary/sepcomp_lib.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Fauxiliary%2Fsepcomp_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Fauxiliary%2Fsepcomp_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsepcomp_lib.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C codegen-units=3 --crate-type=rlib,dylib\n+\n+pub mod a {\n+    pub fn one() -> uint {\n+        1\n+    }\n+}\n+\n+pub mod b {\n+    pub fn two() -> uint {\n+        2\n+    }\n+}\n+\n+pub mod c {\n+    use a::one;\n+    use b::two;\n+    pub fn three() -> uint {\n+        one() + two()\n+    }\n+}"}, {"sha": "59706e20bede29c154bbfd6ddbfe4e69a5d8e7b3", "filename": "src/test/compile-fail/sepcomp-lib-lto.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Fcompile-fail%2Fsepcomp-lib-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Fcompile-fail%2Fsepcomp-lib-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsepcomp-lib-lto.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure we give a sane error message when the user requests LTO with a\n+// library built with -C codegen-units > 1.\n+\n+// aux-build:sepcomp_lib.rs\n+// compile-flags: -Z lto\n+// error-pattern:missing compressed bytecode\n+// no-prefer-dynamic\n+\n+extern crate sepcomp_lib;\n+use sepcomp_lib::a::one;\n+use sepcomp_lib::b::two;\n+use sepcomp_lib::c::three;\n+\n+fn main() {\n+    assert_eq!(one(), 1);\n+    assert_eq!(two(), 2);\n+    assert_eq!(three(), 3);\n+}"}, {"sha": "fed071d1a43c28a27435a5169d058609cc829291", "filename": "src/test/run-make/output-type-permutations/Makefile", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Foutput-type-permutations%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Foutput-type-permutations%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Foutput-type-permutations%2FMakefile?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -5,40 +5,69 @@ all:\n \t$(call REMOVE_RLIBS,bar)\n \t$(call REMOVE_DYLIBS,bar)\n \trm $(TMPDIR)/$(call STATICLIB_GLOB,bar)\n+\t# Check that $(TMPDIR) is empty.\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --crate-type=bin\n \trm $(TMPDIR)/$(call BIN,bar)\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --emit=asm,ir,bc,obj,link\n \trm $(TMPDIR)/bar.ll\n \trm $(TMPDIR)/bar.bc\n \trm $(TMPDIR)/bar.s\n \trm $(TMPDIR)/bar.o\n \trm $(TMPDIR)/$(call BIN,bar)\n-\t$(RUSTC) foo.rs --emit=asm,ir,bc,obj,link --crate-type=staticlib\n-\trm $(TMPDIR)/bar.ll\n-\trm $(TMPDIR)/bar.s\n-\trm $(TMPDIR)/bar.o\n-\trm $(TMPDIR)/$(call STATICLIB_GLOB,bar)\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --emit=asm -o $(TMPDIR)/foo\n \trm $(TMPDIR)/foo\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --emit=bc -o $(TMPDIR)/foo\n \trm $(TMPDIR)/foo\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --emit=ir -o $(TMPDIR)/foo\n \trm $(TMPDIR)/foo\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --emit=obj -o $(TMPDIR)/foo\n \trm $(TMPDIR)/foo\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --emit=link -o $(TMPDIR)/foo\n \trm $(TMPDIR)/$(call BIN,foo)\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --crate-type=rlib -o $(TMPDIR)/foo\n \trm $(TMPDIR)/foo\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --crate-type=dylib -o $(TMPDIR)/foo\n \trm $(TMPDIR)/$(call BIN,foo)  # FIXME 13794\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --crate-type=staticlib -o $(TMPDIR)/foo\n \trm $(TMPDIR)/foo\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n \t$(RUSTC) foo.rs --crate-type=bin -o $(TMPDIR)/foo\n \trm $(TMPDIR)/$(call BIN,foo)\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\n+\t$(RUSTC) foo.rs --emit=asm,ir,bc,obj,link --crate-type=staticlib\n+\trm $(TMPDIR)/bar.ll\n+\trm $(TMPDIR)/bar.s\n+\trm $(TMPDIR)/bar.o\n+\trm $(TMPDIR)/$(call STATICLIB_GLOB,bar)\n \tmv $(TMPDIR)/bar.bc $(TMPDIR)/foo.bc\n+\t# Don't check that the $(TMPDIR) is empty - we left `foo.bc` for later\n+\t# comparison.\n+\n \t$(RUSTC) foo.rs --emit=bc,link --crate-type=rlib\n \tcmp $(TMPDIR)/foo.bc $(TMPDIR)/bar.bc\n \trm $(TMPDIR)/bar.bc\n \trm $(TMPDIR)/foo.bc\n \t$(call REMOVE_RLIBS,bar)\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]"}, {"sha": "fdb39f851970fe4cce09f920088217bb569117a9", "filename": "src/test/run-make/sepcomp-cci-copies/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,10 @@\n+-include ../tools.mk\n+\n+# Check that cross-crate inlined items are inlined in all compilation units\n+# that refer to them, and not in any other compilation units.\n+\n+all:\n+\t$(RUSTC) cci_lib.rs\n+\t$(RUSTC) foo.rs --emit=ir -C codegen-units=3\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ .*cci_fn)\" -eq \"2\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c CCI_STATIC.*=.*constant)\" -eq \"2\" ]"}, {"sha": "099101d6f26790ac9cf86c8bf6c9732c9f74922d", "filename": "src/test/run-make/sepcomp-cci-copies/cci_lib.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Fcci_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Fcci_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Fcci_lib.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+#[inline]\n+pub fn cci_fn() -> uint {\n+    1234\n+}\n+\n+#[inline]\n+pub static CCI_STATIC: uint = 2345;"}, {"sha": "c702e578c0965b20a00f2e950340d49d7dd85568", "filename": "src/test/run-make/sepcomp-cci-copies/foo.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Ffoo.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate cci_lib;\n+use cci_lib::{cci_fn, CCI_STATIC};\n+\n+fn call1() -> uint {\n+    cci_fn() + CCI_STATIC\n+}\n+\n+mod a {\n+    use cci_lib::cci_fn;\n+    pub fn call2() -> uint {\n+        cci_fn()\n+    }\n+}\n+\n+mod b {\n+    use cci_lib::CCI_STATIC;\n+    pub fn call3() -> uint {\n+        CCI_STATIC\n+    }\n+}\n+\n+fn main() {\n+    call1();\n+    a::call2();\n+    b::call3();\n+}"}, {"sha": "6cb9f9a3f31bc0fc510f143d26412f7da24e0554", "filename": "src/test/run-make/sepcomp-inlining/Makefile", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,13 @@\n+-include ../tools.mk\n+\n+# Test that #[inline(always)] functions still get inlined across compilation\n+# unit boundaries.  Compilation should produce three IR files, with each one\n+# containing a definition of the inlined function.  Also, the non-#[inline]\n+# function should be defined in only one compilation unit.\n+\n+all:\n+\t$(RUSTC) foo.rs --emit=ir -C codegen-units=3\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*inlined)\" -eq \"1\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ available_externally\\ i32\\ .*inlined)\" -eq \"2\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*normal)\" -eq \"1\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c declare\\ i32\\ .*normal)\" -eq \"2\" ]"}, {"sha": "20fd18b829562cd388cb02bf9363d91d6903be71", "filename": "src/test/run-make/sepcomp-inlining/foo.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2Ffoo.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[inline]\n+fn inlined() -> u32 {\n+    1234\n+}\n+\n+fn normal() -> u32 {\n+    2345\n+}\n+\n+mod a {\n+    pub fn f() -> u32 {\n+        ::inlined() + ::normal()\n+    }\n+}\n+\n+mod b {\n+    pub fn f() -> u32 {\n+        ::inlined() + ::normal()\n+    }\n+}\n+\n+fn main() {\n+    a::f();\n+    b::f();\n+}"}, {"sha": "265bd68bd2e8216ed722e7561f0635879b21585d", "filename": "src/test/run-make/sepcomp-separate/Makefile", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-separate%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-separate%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-separate%2FMakefile?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,9 @@\n+-include ../tools.mk\n+\n+# Test that separate compilation actually puts code into separate compilation\n+# units.  `foo.rs` defines `magic_fn` in three different modules, which should\n+# wind up in three different compilation units.\n+\n+all:\n+\t$(RUSTC) foo.rs --emit=ir -C codegen-units=3\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ .*magic_fn)\" -eq \"3\" ]"}, {"sha": "fe6a7b5a18f27c0115f4ebaa7d5c69fd21a0af97", "filename": "src/test/run-make/sepcomp-separate/foo.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-separate%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-make%2Fsepcomp-separate%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-separate%2Ffoo.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn magic_fn() -> uint {\n+    1234\n+}\n+\n+mod a {\n+    pub fn magic_fn() -> uint {\n+        2345\n+    }\n+}\n+\n+mod b {\n+    pub fn magic_fn() -> uint {\n+        3456\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "0178b5e786d65c6d36b73dd5e4ee52eacde77492", "filename": "src/test/run-pass/sepcomp-cci.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-cci.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-cci.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-cci.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C codegen-units=3\n+// aux-build:sepcomp_cci_lib.rs\n+\n+// Test accessing cross-crate inlined items from multiple compilation units.\n+\n+extern crate sepcomp_cci_lib;\n+use sepcomp_cci_lib::{cci_fn, CCI_STATIC};\n+\n+fn call1() -> uint {\n+    cci_fn() + CCI_STATIC\n+}\n+\n+mod a {\n+    use sepcomp_cci_lib::{cci_fn, CCI_STATIC};\n+    pub fn call2() -> uint {\n+        cci_fn() + CCI_STATIC\n+    }\n+}\n+\n+mod b {\n+    use sepcomp_cci_lib::{cci_fn, CCI_STATIC};\n+    pub fn call3() -> uint {\n+        cci_fn() + CCI_STATIC\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(call1(), 1234);\n+    assert_eq!(a::call2(), 1234);\n+    assert_eq!(b::call3(), 1234);\n+}"}, {"sha": "a5506e3fc761dc1deddd1a589041e17444168f42", "filename": "src/test/run-pass/sepcomp-extern.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-extern.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C codegen-units=3\n+// aux-build:sepcomp-extern-lib.rs\n+\n+// Test accessing external items from multiple compilation units.\n+\n+#[link(name = \"sepcomp-extern-lib\")]\n+extern {\n+    #[allow(ctypes)]\n+    fn foo() -> uint;\n+}\n+\n+fn call1() -> uint {\n+    unsafe { foo() }\n+}\n+\n+mod a {\n+    pub fn call2() -> uint {\n+        unsafe { ::foo() }\n+    }\n+}\n+\n+mod b {\n+    pub fn call3() -> uint {\n+        unsafe { ::foo() }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(call1(), 1234);\n+    assert_eq!(a::call2(), 1234);\n+    assert_eq!(b::call3(), 1234);\n+}"}, {"sha": "61f008ad854ebaef3432f2d61d2038d9587a3fe2", "filename": "src/test/run-pass/sepcomp-fns-backwards.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-fns-backwards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-fns-backwards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-fns-backwards.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C codegen-units=3\n+\n+// Test references to items that haven't been translated yet.\n+\n+// Generate some code in the first compilation unit before declaring any\n+// modules.  This ensures that the first module doesn't go into the same\n+// compilation unit as the top-level module.\n+fn pad() -> uint { 0 }\n+\n+mod b {\n+    pub fn three() -> uint {\n+        ::one() + ::a::two()\n+    }\n+}\n+\n+mod a {\n+    pub fn two() -> uint {\n+        ::one() + ::one()\n+    }\n+}\n+\n+fn one() -> uint {\n+    1\n+}\n+\n+fn main() {\n+    assert_eq!(one(), 1);\n+    assert_eq!(a::two(), 2);\n+    assert_eq!(b::three(), 3);\n+}\n+"}, {"sha": "09f2a4281be084021c8d7c8af21f58330de3149d", "filename": "src/test/run-pass/sepcomp-fns.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-fns.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C codegen-units=3\n+\n+// Test basic separate compilation functionality.  The functions should be able\n+// to call each other even though they will be placed in different compilation\n+// units.\n+\n+// Generate some code in the first compilation unit before declaring any\n+// modules.  This ensures that the first module doesn't go into the same\n+// compilation unit as the top-level module.\n+fn one() -> uint { 1 }\n+\n+mod a {\n+    pub fn two() -> uint {\n+        ::one() + ::one()\n+    }\n+}\n+\n+mod b {\n+    pub fn three() -> uint {\n+        ::one() + ::a::two()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(one(), 1);\n+    assert_eq!(a::two(), 2);\n+    assert_eq!(b::three(), 3);\n+}"}, {"sha": "28adb55399b44afdb998e0f0d11de88b3460d331", "filename": "src/test/run-pass/sepcomp-lib.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-lib.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:sepcomp_lib.rs\n+\n+// Test linking against a library built with -C codegen-units > 1\n+\n+extern crate sepcomp_lib;\n+use sepcomp_lib::a::one;\n+use sepcomp_lib::b::two;\n+use sepcomp_lib::c::three;\n+\n+fn main() {\n+    assert_eq!(one(), 1);\n+    assert_eq!(two(), 2);\n+    assert_eq!(three(), 3);\n+}"}, {"sha": "26a652ae0ea4ff0684891a0094035a38093b2d07", "filename": "src/test/run-pass/sepcomp-statics.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-statics.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C codegen-units=3\n+\n+// Test references to static items across compilation units.\n+\n+fn pad() -> uint { 0 }\n+\n+static ONE: uint = 1;\n+\n+mod b {\n+    // Separate compilation always switches to the LLVM module with the fewest\n+    // instructions.  Make sure we have some instructions in this module so\n+    // that `a` and `b` don't go into the same compilation unit.\n+    fn pad() -> uint { 0 }\n+\n+    pub static THREE: uint = ::ONE + ::a::TWO;\n+}\n+\n+mod a {\n+    fn pad() -> uint { 0 }\n+\n+    pub static TWO: uint = ::ONE + ::ONE;\n+}\n+\n+fn main() {\n+    assert_eq!(ONE, 1);\n+    assert_eq!(a::TWO, 2);\n+    assert_eq!(b::THREE, 3);\n+}\n+"}, {"sha": "5d154e02af67085e5d7808de78d1500517fb37b7", "filename": "src/test/run-pass/sepcomp-unwind.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bea7b3ed0856310fc64614e5bb01e348777c99f/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs?ref=4bea7b3ed0856310fc64614e5bb01e348777c99f", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C codegen-units=3\n+\n+// Test unwinding through multiple compilation units.\n+\n+// According to acrichto, in the distant past `ld -r` (which is used during\n+// linking when codegen-units > 1) was known to produce object files with\n+// damaged unwinding tables.  This may be related to GNU binutils bug #6893\n+// (\"Partial linking results in corrupt .eh_frame_hdr\"), but I'm not certain.\n+// In any case, this test should let us know if enabling parallel codegen ever\n+// breaks unwinding.\n+\n+fn pad() -> uint { 0 }\n+\n+mod a {\n+    pub fn f() {\n+        fail!();\n+    }\n+}\n+\n+mod b {\n+    pub fn g() {\n+        ::a::f();\n+    }\n+}\n+\n+fn main() {\n+    std::task::try(proc() { ::b::g() }).unwrap_err();\n+}"}]}