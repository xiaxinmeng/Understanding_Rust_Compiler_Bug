{"sha": "b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMzZmNmFhNDk5Zjk4OTg1YWNkMDdhMzRlYjBjMGQxNDdiZjhkNWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-08T10:44:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-08T10:44:30Z"}, "message": "Merge #2466\n\n2466: Handle partial resolve cases r=matklad a=edwin0cheng\n\nAnother try to fix #2443 :\r\n\r\nWe resolve all imports every time in `DefCollector::collect` loop even it is resolved previously.  \r\nThis is because other unresolved imports and macros will bring in another `PerNs`, so we can only assume that it has been partially resolved.\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "c42e1491fd61bbc2326d3d658d23cb19594d9ade", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c42e1491fd61bbc2326d3d658d23cb19594d9ade"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd7NQOCRBK7hj4Ov3rIwAAdHIIAGwzqP1OTLLe3JAF/Pgyy6jn\nEwvfqqP1HKK67bNm8W9sPEkYGmZHhz3gR7rupulvGwFK9RpUdq+ALOI+fDLkKITa\nllzIWYyFNEHz+iX7+KCOhW7yaVZxcaOO/tcQbFZENNGenAp3Ebz+qY4V5M246wQS\nITlxoex5B/tKY3TbsoVK/toEzuWONSB+DQQccOJstFqnaRK8EFzvZNNjPth+z1oj\nv3I71dc6VoysM4MVOm8HAst/ZOvc+d/pbbaxIjgiMmjqDRSMm9uSJNOmpVkNFYnE\nrCIUC2o5VYmsvR7Jl6W/cq14J2GHZELlVHRBItSRiy9wyiZjK1fBBD5v+AH8UiA=\n=O2Y/\n-----END PGP SIGNATURE-----\n", "payload": "tree c42e1491fd61bbc2326d3d658d23cb19594d9ade\nparent ffcdd25cc8e7f1fd7fb4e3e8478c4cd1adfbf843\nparent 51f4fb448f1993a20c9527a8e6d301a9202ce35a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575801870 +0000\ncommitter GitHub <noreply@github.com> 1575801870 +0000\n\nMerge #2466\n\n2466: Handle partial resolve cases r=matklad a=edwin0cheng\n\nAnother try to fix #2443 :\r\n\r\nWe resolve all imports every time in `DefCollector::collect` loop even it is resolved previously.  \r\nThis is because other unresolved imports and macros will bring in another `PerNs`, so we can only assume that it has been partially resolved.\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "html_url": "https://github.com/rust-lang/rust/commit/b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b236f6aa499f98985acd07a34eb0c0d147bf8d5f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffcdd25cc8e7f1fd7fb4e3e8478c4cd1adfbf843", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffcdd25cc8e7f1fd7fb4e3e8478c4cd1adfbf843", "html_url": "https://github.com/rust-lang/rust/commit/ffcdd25cc8e7f1fd7fb4e3e8478c4cd1adfbf843"}, {"sha": "51f4fb448f1993a20c9527a8e6d301a9202ce35a", "url": "https://api.github.com/repos/rust-lang/rust/commits/51f4fb448f1993a20c9527a8e6d301a9202ce35a", "html_url": "https://github.com/rust-lang/rust/commit/51f4fb448f1993a20c9527a8e6d301a9202ce35a"}], "stats": {"total": 238, "additions": 194, "deletions": 44}, "files": [{"sha": "3ff071f9eeb2633ba40fdafbca4af0b7d4304248", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 124, "deletions": 40, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/b236f6aa499f98985acd07a34eb0c0d147bf8d5f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b236f6aa499f98985acd07a34eb0c0d147bf8d5f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "patch": "@@ -58,6 +58,8 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         def_map,\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n+        resolved_imports: Vec::new(),\n+\n         unexpanded_macros: Vec::new(),\n         unexpanded_attribute_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n@@ -97,12 +99,41 @@ impl MacroStackMonitor {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+enum PartialResolvedImport {\n+    /// None of any namespaces is resolved\n+    Unresolved,\n+    /// One of namespaces is resolved\n+    Indeterminate(PerNs),\n+    /// All namespaces are resolved, OR it is came from other crate\n+    Resolved(PerNs),\n+}\n+\n+impl PartialResolvedImport {\n+    fn namespaces(&self) -> PerNs {\n+        match self {\n+            PartialResolvedImport::Unresolved => PerNs::none(),\n+            PartialResolvedImport::Indeterminate(ns) => *ns,\n+            PartialResolvedImport::Resolved(ns) => *ns,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct ImportDirective {\n+    module_id: LocalModuleId,\n+    import_id: LocalImportId,\n+    import: raw::ImportData,\n+    status: PartialResolvedImport,\n+}\n+\n /// Walks the tree of module recursively\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n-    unresolved_imports: Vec<(LocalModuleId, LocalImportId, raw::ImportData)>,\n+    unresolved_imports: Vec<ImportDirective>,\n+    resolved_imports: Vec<ImportDirective>,\n     unexpanded_macros: Vec<(LocalModuleId, AstId<ast::MacroCall>, Path)>,\n     unexpanded_attribute_macros: Vec<(LocalModuleId, AstId<ast::ModuleItem>, Path)>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n@@ -148,20 +179,38 @@ where\n         let mut i = 0;\n         loop {\n             self.db.check_canceled();\n-            match (self.resolve_imports(), self.resolve_macros()) {\n-                (ReachedFixedPoint::Yes, ReachedFixedPoint::Yes) => break,\n-                _ => i += 1,\n+            self.resolve_imports();\n+\n+            match self.resolve_macros() {\n+                ReachedFixedPoint::Yes => break,\n+                ReachedFixedPoint::No => i += 1,\n             }\n             if i == 1000 {\n                 log::error!(\"name resolution is stuck\");\n                 break;\n             }\n         }\n \n+        // Resolve all indeterminate resolved imports again\n+        // As some of the macros will expand newly import shadowing partial resolved imports\n+        // FIXME: We maybe could skip this, if we handle the Indetermine imports in `resolve_imports`\n+        // correctly\n+        let partial_resolved = self.resolved_imports.iter().filter_map(|directive| {\n+            if let PartialResolvedImport::Indeterminate(_) = directive.status {\n+                let mut directive = directive.clone();\n+                directive.status = PartialResolvedImport::Unresolved;\n+                Some(directive)\n+            } else {\n+                None\n+            }\n+        });\n+        self.unresolved_imports.extend(partial_resolved);\n+        self.resolve_imports();\n+\n         let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n         // show unresolved imports in completion, etc\n-        for (module_id, import, import_data) in unresolved_imports {\n-            self.record_resolved_import(module_id, PerNs::none(), import, &import_data)\n+        for directive in unresolved_imports {\n+            self.record_resolved_import(&directive)\n         }\n     }\n \n@@ -262,31 +311,43 @@ where\n         }\n     }\n \n-    fn resolve_imports(&mut self) -> ReachedFixedPoint {\n-        let mut imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n-        let mut resolved = Vec::new();\n-        imports.retain(|(module_id, import, import_data)| {\n-            let (def, fp) = self.resolve_import(*module_id, import_data);\n-            if fp == ReachedFixedPoint::Yes {\n-                resolved.push((*module_id, def, *import, import_data.clone()))\n+    /// Import resolution\n+    ///\n+    /// This is a fix point algorithm. We resolve imports until no forward\n+    /// progress in resolving imports is made\n+    fn resolve_imports(&mut self) {\n+        let mut n_previous_unresolved = self.unresolved_imports.len() + 1;\n+\n+        while self.unresolved_imports.len() < n_previous_unresolved {\n+            n_previous_unresolved = self.unresolved_imports.len();\n+            let imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+            for mut directive in imports {\n+                directive.status = self.resolve_import(directive.module_id, &directive.import);\n+\n+                match directive.status {\n+                    PartialResolvedImport::Indeterminate(_) => {\n+                        self.record_resolved_import(&directive);\n+                        // FIXME: For avoid performance regression,\n+                        // we consider an imported resolved if it is indeterminate (i.e not all namespace resolved)\n+                        self.resolved_imports.push(directive)\n+                    }\n+                    PartialResolvedImport::Resolved(_) => {\n+                        self.record_resolved_import(&directive);\n+                        self.resolved_imports.push(directive)\n+                    }\n+                    PartialResolvedImport::Unresolved => {\n+                        self.unresolved_imports.push(directive);\n+                    }\n+                }\n             }\n-            fp == ReachedFixedPoint::No\n-        });\n-        self.unresolved_imports = imports;\n-        // Resolves imports, filling-in module scopes\n-        let result =\n-            if resolved.is_empty() { ReachedFixedPoint::Yes } else { ReachedFixedPoint::No };\n-        for (module_id, def, import, import_data) in resolved {\n-            self.record_resolved_import(module_id, def, import, &import_data)\n         }\n-        result\n     }\n \n     fn resolve_import(\n         &self,\n         module_id: LocalModuleId,\n         import: &raw::ImportData,\n-    ) -> (PerNs, ReachedFixedPoint) {\n+    ) -> PartialResolvedImport {\n         log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n         if import.is_extern_crate {\n             let res = self.def_map.resolve_name_in_extern_prelude(\n@@ -295,7 +356,7 @@ where\n                     .as_ident()\n                     .expect(\"extern crate should have been desugared to one-element path\"),\n             );\n-            (res, ReachedFixedPoint::Yes)\n+            PartialResolvedImport::Resolved(res)\n         } else {\n             let res = self.def_map.resolve_path_fp_with_macro(\n                 self.db,\n@@ -305,17 +366,35 @@ where\n                 BuiltinShadowMode::Module,\n             );\n \n-            (res.resolved_def, res.reached_fixedpoint)\n+            let def = res.resolved_def;\n+            if res.reached_fixedpoint == ReachedFixedPoint::No {\n+                return PartialResolvedImport::Unresolved;\n+            }\n+\n+            if let Some(krate) = res.krate {\n+                if krate != self.def_map.krate {\n+                    return PartialResolvedImport::Resolved(def);\n+                }\n+            }\n+\n+            // Check whether all namespace is resolved\n+            if def.take_types().is_some()\n+                && def.take_values().is_some()\n+                && def.take_macros().is_some()\n+            {\n+                PartialResolvedImport::Resolved(def)\n+            } else {\n+                PartialResolvedImport::Indeterminate(def)\n+            }\n         }\n     }\n \n-    fn record_resolved_import(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        def: PerNs,\n-        import_id: LocalImportId,\n-        import: &raw::ImportData,\n-    ) {\n+    fn record_resolved_import(&mut self, directive: &ImportDirective) {\n+        let module_id = directive.module_id;\n+        let import_id = directive.import_id;\n+        let import = &directive.import;\n+        let def = directive.status.namespaces();\n+\n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n             match def.take_types() {\n@@ -352,10 +431,10 @@ where\n \n                         self.update(module_id, Some(import_id), &items);\n                         // record the glob import in case we add further items\n-                        self.glob_imports\n-                            .entry(m.local_id)\n-                            .or_default()\n-                            .push((module_id, import_id));\n+                        let glob = self.glob_imports.entry(m.local_id).or_default();\n+                        if !glob.iter().any(|it| *it == (module_id, import_id)) {\n+                            glob.push((module_id, import_id));\n+                        }\n                     }\n                 }\n                 Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n@@ -615,10 +694,14 @@ where\n                     raw::RawItemKind::Module(m) => {\n                         self.collect_module(&self.raw_items[m], &item.attrs)\n                     }\n-                    raw::RawItemKind::Import(import_id) => self\n-                        .def_collector\n-                        .unresolved_imports\n-                        .push((self.module_id, import_id, self.raw_items[import_id].clone())),\n+                    raw::RawItemKind::Import(import_id) => {\n+                        self.def_collector.unresolved_imports.push(ImportDirective {\n+                            module_id: self.module_id,\n+                            import_id,\n+                            import: self.raw_items[import_id].clone(),\n+                            status: PartialResolvedImport::Unresolved,\n+                        })\n+                    }\n                     raw::RawItemKind::Def(def) => {\n                         self.define_def(&self.raw_items[def], &item.attrs)\n                     }\n@@ -886,6 +969,7 @@ mod tests {\n             def_map,\n             glob_imports: FxHashMap::default(),\n             unresolved_imports: Vec::new(),\n+            resolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n             unexpanded_attribute_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),"}, {"sha": "aab4b1dd97672ac744a15c54f1d020e569ca0ccc", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b236f6aa499f98985acd07a34eb0c0d147bf8d5f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b236f6aa499f98985acd07a34eb0c0d147bf8d5f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     nameres::{BuiltinShadowMode, CrateDefMap},\n     path::{Path, PathKind},\n     per_ns::PerNs,\n-    AdtId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n+    AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -39,19 +39,21 @@ pub(super) struct ResolvePathResult {\n     pub(super) resolved_def: PerNs,\n     pub(super) segment_index: Option<usize>,\n     pub(super) reached_fixedpoint: ReachedFixedPoint,\n+    pub(super) krate: Option<CrateId>,\n }\n \n impl ResolvePathResult {\n     fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None, None)\n     }\n \n     fn with(\n         resolved_def: PerNs,\n         reached_fixedpoint: ReachedFixedPoint,\n         segment_index: Option<usize>,\n+        krate: Option<CrateId>,\n     ) -> ResolvePathResult {\n-        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n+        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index, krate }\n     }\n }\n \n@@ -175,6 +177,7 @@ impl CrateDefMap {\n                             def,\n                             ReachedFixedPoint::Yes,\n                             s.map(|s| s + i),\n+                            Some(module.krate),\n                         );\n                     }\n \n@@ -201,6 +204,7 @@ impl CrateDefMap {\n                                 PerNs::types(e.into()),\n                                 ReachedFixedPoint::Yes,\n                                 Some(i),\n+                                Some(self.krate),\n                             );\n                         }\n                     }\n@@ -218,12 +222,13 @@ impl CrateDefMap {\n                         PerNs::types(s),\n                         ReachedFixedPoint::Yes,\n                         Some(i),\n+                        Some(self.krate),\n                     );\n                 }\n             };\n         }\n \n-        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None, Some(self.krate))\n     }\n \n     fn resolve_name_in_module("}, {"sha": "61cdd768e87b5bf30f2de680526599e97798b218", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b236f6aa499f98985acd07a34eb0c0d147bf8d5f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b236f6aa499f98985acd07a34eb0c0d147bf8d5f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "patch": "@@ -558,3 +558,35 @@ fn cfg_test() {\n         \u22eeFoo: t v\n     \"###);\n }\n+\n+#[test]\n+fn infer_multiple_namespace() {\n+    let map = def_map(\n+        r#\"\n+//- /main.rs\n+mod a {\n+    pub type T = ();\n+    pub use crate::b::*;\n+}\n+\n+use crate::a::T;\n+\n+mod b {\n+    pub const T: () = ();\n+}\n+\"#,\n+    );\n+\n+    assert_snapshot!(map, @r###\"\n+    \u22eecrate\n+    \u22eeT: t v\n+    \u22eea: t\n+    \u22eeb: t\n+    \u22ee\n+    \u22eecrate::b\n+    \u22eeT: v\n+    \u22ee\n+    \u22eecrate::a\n+    \u22eeT: t v    \n+\"###);\n+}"}, {"sha": "812f171db8ed428ccf7a996294cd000b66f7d73e", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b236f6aa499f98985acd07a34eb0c0d147bf8d5f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b236f6aa499f98985acd07a34eb0c0d147bf8d5f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "patch": "@@ -210,6 +210,35 @@ pub fn baz() -> usize { 31usize }\n     assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n }\n \n+#[test]\n+fn infer_type_value_non_legacy_macro_use_as() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod m {\n+    macro_rules! _foo {\n+        ($x:ident) => { type $x = u64; }\n+    }\n+    pub(crate) use _foo as foo;\n+}\n+\n+m::foo!(foo);\n+use foo as bar;\n+fn f() -> bar { 0 }\n+fn main() {  \n+    let _a  = f();\n+}\n+\"#),\n+        @r###\"\n+        [159; 164) '{ 0 }': u64\n+        [161; 162) '0': u64\n+        [175; 199) '{     ...f(); }': ()\n+        [187; 189) '_a': u64\n+        [193; 194) 'f': fn f() -> u64\n+        [193; 196) 'f()': u64        \n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_builtin_macros_line() {\n     assert_snapshot!("}]}