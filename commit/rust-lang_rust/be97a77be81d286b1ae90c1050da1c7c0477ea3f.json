{"sha": "be97a77be81d286b1ae90c1050da1c7c0477ea3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlOTdhNzdiZTgxZDI4NmIxYWU5MGMxMDUwZGExYzdjMDQ3N2VhM2Y=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-03T22:40:57Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-03T22:40:57Z"}, "message": "Capture typarams into obj, independent of body tydesc.", "tree": {"sha": "82304060033c3ea6c2408c23564f398cb1cae227", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82304060033c3ea6c2408c23564f398cb1cae227"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be97a77be81d286b1ae90c1050da1c7c0477ea3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be97a77be81d286b1ae90c1050da1c7c0477ea3f", "html_url": "https://github.com/rust-lang/rust/commit/be97a77be81d286b1ae90c1050da1c7c0477ea3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be97a77be81d286b1ae90c1050da1c7c0477ea3f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce17fe2a90737425eed9305cd24e4c6f71b78dbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce17fe2a90737425eed9305cd24e4c6f71b78dbd", "html_url": "https://github.com/rust-lang/rust/commit/ce17fe2a90737425eed9305cd24e4c6f71b78dbd"}], "stats": {"total": 98, "additions": 79, "deletions": 19}, "files": [{"sha": "82a85a6c1f76fecc93453629cf55874d36cab910", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be97a77be81d286b1ae90c1050da1c7c0477ea3f/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be97a77be81d286b1ae90c1050da1c7c0477ea3f/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=be97a77be81d286b1ae90c1050da1c7c0477ea3f", "patch": "@@ -44,7 +44,8 @@ const int obj_field_vtbl = 0;\n const int obj_field_box = 1;\n \n const int obj_body_elt_tydesc = 0;\n-const int obj_body_elt_fields = 1;\n+const int obj_body_elt_typarams = 1;\n+const int obj_body_elt_fields = 2;\n \n const int fn_field_code = 0;\n const int fn_field_box = 1;"}, {"sha": "4610cef631cc944435492afe48fa087cf89b6eda", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 77, "deletions": 18, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/be97a77be81d286b1ae90c1050da1c7c0477ea3f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be97a77be81d286b1ae90c1050da1c7c0477ea3f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=be97a77be81d286b1ae90c1050da1c7c0477ea3f", "patch": "@@ -75,6 +75,7 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, ValueRef] consts,\n                             hashmap[ast.def_id,()] obj_methods,\n                             hashmap[@ty.t, ValueRef] tydescs,\n+                            vec[ast.ty_param] obj_typarams,\n                             vec[ast.obj_field] obj_fields,\n                             @glue_fns glues,\n                             namegen names,\n@@ -327,6 +328,24 @@ fn T_opaque_closure_ptr() -> TypeRef {\n                       T_nil());\n }\n \n+fn T_captured_tydescs(uint n) -> TypeRef {\n+    ret T_struct(_vec.init_elt[TypeRef](T_ptr(T_tydesc()), n));\n+}\n+\n+fn T_obj(uint n_captured_tydescs, TypeRef llfields_ty) -> TypeRef {\n+    ret T_struct(vec(T_ptr(T_tydesc()),\n+                     T_captured_tydescs(n_captured_tydescs),\n+                     llfields_ty));\n+}\n+\n+fn T_obj_ptr(uint n_captured_tydescs, TypeRef llfields_ty) -> TypeRef {\n+    ret T_ptr(T_box(T_obj(n_captured_tydescs, llfields_ty)));\n+}\n+\n+fn T_opaque_obj_ptr() -> TypeRef {\n+    ret T_obj_ptr(0u, T_nil());\n+}\n+\n \n fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     let TypeRef llty = type_of_inner(cx, t);\n@@ -455,11 +474,9 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n                 mtys += T_ptr(mty);\n             }\n             let TypeRef vtbl = T_struct(mtys);\n-            let TypeRef body = T_struct(vec(T_ptr(T_tydesc()),\n-                                            T_nil()));\n-            let TypeRef pair =\n-                T_struct(vec(T_ptr(vtbl),\n-                             T_ptr(T_box(body))));\n+            let TypeRef pair = T_struct(vec(T_ptr(vtbl),\n+                                            T_opaque_obj_ptr()));\n+\n             auto abs_pair = llvm.LLVMResolveTypeHandle(th.llth);\n             llvm.LLVMRefineType(abs_pair, pair);\n             abs_pair = llvm.LLVMResolveTypeHandle(th.llth);\n@@ -963,6 +980,7 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt (ty.type_param(t)) {\n         case (some[ast.def_id](?id)) {\n+            check (cx.fcx.lltydescs.contains_key(id));\n             ret res(cx, cx.fcx.lltydescs.get(id));\n         }\n         case (none[ast.def_id])      { /* fall through */ }\n@@ -3474,19 +3492,17 @@ fn ret_ty_of_fn(ast.ann ann) -> @ty.t {\n     ret ret_ty_of_fn_ty(ty.ann_to_type(ann));\n }\n \n-fn create_llobjfields_for_fields(@block_ctxt cx, ValueRef llself) {\n+fn populate_fn_ctxt_from_llself(@block_ctxt cx, ValueRef llself) {\n \n     let vec[TypeRef] llfield_tys = vec();\n \n     for (ast.obj_field f in cx.fcx.ccx.obj_fields) {\n         llfield_tys += node_type(cx.fcx.ccx, f.ann);\n     }\n \n-    let TypeRef llfields_ty = T_struct(llfield_tys);\n-    let TypeRef lltydesc_ty = T_ptr(T_tydesc());\n-    let TypeRef llobj_body_ty = T_struct(vec(lltydesc_ty,\n-                                             llfields_ty));\n-    let TypeRef llobj_box_ty = T_ptr(T_box(llobj_body_ty));\n+    auto n_typarams = _vec.len[ast.ty_param](cx.fcx.ccx.obj_typarams);\n+    let TypeRef llobj_box_ty = T_obj_ptr(n_typarams,\n+                                         T_struct(llfield_tys));\n \n     auto box_cell =\n         cx.build.GEP(llself,\n@@ -3497,12 +3513,28 @@ fn create_llobjfields_for_fields(@block_ctxt cx, ValueRef llself) {\n \n     box_ptr = cx.build.PointerCast(box_ptr, llobj_box_ty);\n \n+    auto obj_typarams = cx.build.GEP(box_ptr,\n+                                     vec(C_int(0),\n+                                         C_int(abi.box_rc_field_body),\n+                                         C_int(abi.obj_body_elt_typarams)));\n+\n     auto obj_fields = cx.build.GEP(box_ptr,\n                                    vec(C_int(0),\n                                        C_int(abi.box_rc_field_body),\n                                        C_int(abi.obj_body_elt_fields)));\n \n     let int i = 0;\n+\n+    for (ast.ty_param p in cx.fcx.ccx.obj_typarams) {\n+        let ValueRef lltyparam = cx.build.GEP(obj_typarams,\n+                                              vec(C_int(0),\n+                                                  C_int(i)));\n+        lltyparam = cx.build.Load(lltyparam);\n+        cx.fcx.lltydescs.insert(p.id, lltyparam);\n+        i += 1;\n+    }\n+\n+    i = 0;\n     for (ast.obj_field f in cx.fcx.ccx.obj_fields) {\n         let ValueRef llfield = cx.build.GEP(obj_fields,\n                                             vec(C_int(0),\n@@ -3529,7 +3561,7 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n \n     alt (fcx.llself) {\n         case (some[ValueRef](?llself)) {\n-            create_llobjfields_for_fields(bcx, llself);\n+            populate_fn_ctxt_from_llself(bcx, llself);\n         }\n         case (_) {\n         }\n@@ -3623,10 +3655,11 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n                                       C_int(abi.obj_field_box)));\n     bcx.build.Store(vtbl, pair_vtbl);\n \n-    let TypeRef llbox_ty = T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc()),\n-                                                    T_nil()))));\n-    if (_vec.len[ty.arg](arg_tys) == 0u) {\n-        // Store null into pair, if no args.\n+    let TypeRef llbox_ty = T_opaque_obj_ptr();\n+\n+    if (_vec.len[ast.ty_param](ty_params) == 0u &&\n+        _vec.len[ty.arg](arg_tys) == 0u) {\n+        // Store null into pair, if no args or typarams.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n         // Malloc a box for the body and copy args in.\n@@ -3636,8 +3669,16 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         }\n \n         // Synthesize an obj body type.\n+        auto tydesc_ty = plain_ty(ty.ty_type);\n+        let vec[@ty.t] tps = vec();\n+        for (ast.ty_param tp in ty_params) {\n+            append[@ty.t](tps, tydesc_ty);\n+        }\n+\n+        let @ty.t typarams_ty = plain_ty(ty.ty_tup(tps));\n         let @ty.t fields_ty = plain_ty(ty.ty_tup(obj_fields));\n-        let @ty.t body_ty = plain_ty(ty.ty_tup(vec(plain_ty(ty.ty_type),\n+        let @ty.t body_ty = plain_ty(ty.ty_tup(vec(tydesc_ty,\n+                                                   typarams_ty,\n                                                    fields_ty)));\n         let @ty.t boxed_body_ty = plain_ty(ty.ty_box(body_ty));\n \n@@ -3664,13 +3705,28 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         bcx = body_td.bcx;\n         bcx.build.Store(body_td.val, body_tydesc.val);\n \n+        // Copy typarams into captured typarams.\n+        auto body_typarams =\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         vec(0, abi.obj_body_elt_typarams));\n+        bcx = body_typarams.bcx;\n+        let int i = 0;\n+        for (ast.ty_param tp in ty_params) {\n+            auto typaram = bcx.fcx.lltydescs.get(tp.id);\n+            auto capture = GEP_tup_like(bcx, typarams_ty, body_typarams.val,\n+                                        vec(0, i));\n+            bcx = capture.bcx;\n+            bcx = copy_ty(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n+            i += 1;\n+        }\n+\n         // Copy args into body fields.\n         auto body_fields =\n             GEP_tup_like(bcx, body_ty, body.val,\n                          vec(0, abi.obj_body_elt_fields));\n         bcx = body_fields.bcx;\n \n-        let int i = 0;\n+        i = 0;\n         for (ast.obj_field f in ob.fields) {\n             auto arg = bcx.fcx.llargs.get(f.id);\n             arg = load_scalar_or_boxed(bcx, arg, arg_tys.(i).ty);\n@@ -3792,6 +3848,7 @@ fn trans_item(@crate_ctxt cx, &ast.item item) {\n         }\n         case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n             auto sub_cx = @rec(path=cx.path + \".\" + name,\n+                               obj_typarams=tps,\n                                obj_fields=ob.fields with *cx);\n             trans_obj(sub_cx, ob, oid, tps, ann);\n         }\n@@ -4353,6 +4410,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     auto hasher = ty.hash_ty;\n     auto eqer = ty.eq_ty;\n     auto tydescs = map.mk_hashmap[@ty.t,ValueRef](hasher, eqer);\n+    let vec[ast.ty_param] obj_typarams = vec();\n     let vec[ast.obj_field] obj_fields = vec();\n \n     auto cx = @rec(sess = sess,\n@@ -4369,6 +4427,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    consts = new_def_hash[ValueRef](),\n                    obj_methods = new_def_hash[()](),\n                    tydescs = tydescs,\n+                   obj_typarams = obj_typarams,\n                    obj_fields = obj_fields,\n                    glues = glues,\n                    names = namegen(0),"}]}