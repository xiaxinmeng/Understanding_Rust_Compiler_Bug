{"sha": "8256379832b5ecb7f71e8c5e2018446482223c12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNTYzNzk4MzJiNWVjYjdmNzFlOGM1ZTIwMTg0NDY0ODIyMjNjMTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-18T21:24:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-18T21:24:40Z"}, "message": "Auto merge of #78995 - Nadrieril:clean-empty-match, r=varkor\n\nHandle empty matches cleanly in exhaustiveness checking\n\nThis removes the special-casing of empty matches that was done in `check_match`. This fixes most of https://github.com/rust-lang/rust/issues/55123.\nSomewhat unrelatedly, I also made `_match.rs` more self-contained, because I think it's cleaner.\n\nr? `@varkor`\n`@rustbot` modify labels: +A-exhaustiveness-checking", "tree": {"sha": "1d5e866b6b006d84b3d8ce102a1022234ed2e4ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d5e866b6b006d84b3d8ce102a1022234ed2e4ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8256379832b5ecb7f71e8c5e2018446482223c12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8256379832b5ecb7f71e8c5e2018446482223c12", "html_url": "https://github.com/rust-lang/rust/commit/8256379832b5ecb7f71e8c5e2018446482223c12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8256379832b5ecb7f71e8c5e2018446482223c12/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d2d0014922e9f541694bfe87642749239990e0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2d0014922e9f541694bfe87642749239990e0e", "html_url": "https://github.com/rust-lang/rust/commit/8d2d0014922e9f541694bfe87642749239990e0e"}, {"sha": "69821cf8df86c8f4366e0c16a0a7de8d0135b90f", "url": "https://api.github.com/repos/rust-lang/rust/commits/69821cf8df86c8f4366e0c16a0a7de8d0135b90f", "html_url": "https://github.com/rust-lang/rust/commit/69821cf8df86c8f4366e0c16a0a7de8d0135b90f"}], "stats": {"total": 485, "additions": 317, "deletions": 168}, "files": [{"sha": "6bea2381862e93099c9358da8b96f18d8a3485a8", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 91, "deletions": 24, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8256379832b5ecb7f71e8c5e2018446482223c12/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256379832b5ecb7f71e8c5e2018446482223c12/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=8256379832b5ecb7f71e8c5e2018446482223c12", "patch": "@@ -364,14 +364,14 @@ impl<'tcx> Pat<'tcx> {\n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n #[derive(Debug, Clone)]\n-crate struct PatStack<'p, 'tcx> {\n+struct PatStack<'p, 'tcx> {\n     pats: SmallVec<[&'p Pat<'tcx>; 2]>,\n     /// Cache for the constructor of the head\n     head_ctor: OnceCell<Constructor<'tcx>>,\n }\n \n impl<'p, 'tcx> PatStack<'p, 'tcx> {\n-    crate fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n+    fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n         Self::from_vec(smallvec![pat])\n     }\n \n@@ -455,17 +455,17 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n \n /// A 2D matrix.\n #[derive(Clone, PartialEq)]\n-crate struct Matrix<'p, 'tcx> {\n+struct Matrix<'p, 'tcx> {\n     patterns: Vec<PatStack<'p, 'tcx>>,\n }\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n-    crate fn empty() -> Self {\n+    fn empty() -> Self {\n         Matrix { patterns: vec![] }\n     }\n \n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this expands it.\n-    crate fn push(&mut self, row: PatStack<'p, 'tcx>) {\n+    fn push(&mut self, row: PatStack<'p, 'tcx>) {\n         if let Some(rows) = row.expand_or_pat() {\n             for row in rows {\n                 // We recursively expand the or-patterns of the new rows.\n@@ -588,7 +588,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n \n     /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n-    crate fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n+    fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind() {\n             ty::Adt(def, ..) => {\n                 def.is_enum() && def.is_variant_list_non_exhaustive() && !def.did.is_local()\n@@ -1392,13 +1392,12 @@ impl<'tcx> Usefulness<'tcx> {\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-        is_top_level: bool,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n                 let new_witnesses = if ctor.is_wildcard() {\n                     let missing_ctors = MissingConstructors::new(pcx);\n-                    let new_patterns = missing_ctors.report_patterns(pcx, is_top_level);\n+                    let new_patterns = missing_ctors.report_patterns(pcx);\n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {\n@@ -1440,7 +1439,7 @@ impl<'tcx> Usefulness<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-crate enum WitnessPreference {\n+enum WitnessPreference {\n     ConstructWitness,\n     LeaveOutWitness,\n }\n@@ -1454,6 +1453,9 @@ struct PatCtxt<'a, 'p, 'tcx> {\n     ty: Ty<'tcx>,\n     /// Span of the current pattern under investigation.\n     span: Span,\n+    /// Whether the current pattern is the whole pattern as found in a match arm, or if it's a\n+    /// subpattern.\n+    is_top_level: bool,\n }\n \n /// A witness of non-exhaustiveness for error reporting, represented\n@@ -1493,7 +1495,8 @@ struct PatCtxt<'a, 'p, 'tcx> {\n crate struct Witness<'tcx>(Vec<Pat<'tcx>>);\n \n impl<'tcx> Witness<'tcx> {\n-    crate fn single_pattern(self) -> Pat<'tcx> {\n+    /// Asserts that the witness contains a single pattern, and returns it.\n+    fn single_pattern(self) -> Pat<'tcx> {\n         assert_eq!(self.0.len(), 1);\n         self.0.into_iter().next().unwrap()\n     }\n@@ -1585,11 +1588,12 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n \n             // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n-            // as though it had an \"unknown\" constructor to avoid exposing its emptyness. Note that\n-            // an empty match will still be considered exhaustive because that case is handled\n-            // separately in `check_match`.\n-            let is_secretly_empty =\n-                def.variants.is_empty() && !cx.tcx.features().exhaustive_patterns;\n+            // as though it had an \"unknown\" constructor to avoid exposing its emptiness. The\n+            // exception is if the pattern is at the top level, because we want empty matches to be\n+            // considered exhaustive.\n+            let is_secretly_empty = def.variants.is_empty()\n+                && !cx.tcx.features().exhaustive_patterns\n+                && !pcx.is_top_level;\n \n             if is_secretly_empty || is_declared_nonexhaustive {\n                 vec![NonExhaustive]\n@@ -1635,6 +1639,13 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             let max = size.truncate(u128::MAX);\n             vec![make_range(0, max)]\n         }\n+        // If `exhaustive_patterns` is disabled and our scrutinee is the never type, we cannot\n+        // expose its emptiness. The exception is if the pattern is at the top level, because we\n+        // want empty matches to be considered exhaustive.\n+        ty::Never if !cx.tcx.features().exhaustive_patterns && !pcx.is_top_level => {\n+            vec![NonExhaustive]\n+        }\n+        ty::Never => vec![],\n         _ if cx.is_uninhabited(pcx.ty) => vec![],\n         ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => vec![Single],\n         // This type is one for which we cannot list constructors, like `str` or `f64`.\n@@ -2012,11 +2023,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n \n     /// List the patterns corresponding to the missing constructors. In some cases, instead of\n     /// listing all constructors of a given type, we prefer to simply report a wildcard.\n-    fn report_patterns<'p>(\n-        &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        is_top_level: bool,\n-    ) -> SmallVec<[Pat<'tcx>; 1]> {\n+    fn report_patterns<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Pat<'tcx>; 1]> {\n         // There are 2 ways we can report a witness here.\n         // Commonly, we can report all the \"free\"\n         // constructors as witnesses, e.g., if we have:\n@@ -2044,7 +2051,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n         // `used_ctors` is empty.\n         // The exception is: if we are at the top-level, for example in an empty match, we\n         // sometimes prefer reporting the list of constructors instead of just `_`.\n-        let report_when_all_missing = is_top_level && !IntRange::is_integral(pcx.ty);\n+        let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n         if self.used_ctors.is_empty() && !report_when_all_missing {\n             // All constructors are unused. Report only a wildcard\n             // rather than each individual constructor.\n@@ -2086,7 +2093,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n-crate fn is_useful<'p, 'tcx>(\n+fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n@@ -2200,7 +2207,7 @@ crate fn is_useful<'p, 'tcx>(\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n     let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n-    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span };\n+    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span, is_top_level };\n \n     debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n \n@@ -2215,7 +2222,7 @@ crate fn is_useful<'p, 'tcx>(\n             let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n             let usefulness =\n                 is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns, is_top_level)\n+            usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns)\n         })\n         .find(|result| result.is_useful())\n         .unwrap_or(NotUseful);\n@@ -2283,3 +2290,63 @@ fn pat_constructor<'p, 'tcx>(\n         PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n     }\n }\n+\n+/// The arm of a match expression.\n+#[derive(Clone, Copy)]\n+crate struct MatchArm<'p, 'tcx> {\n+    /// The pattern must have been lowered through `MatchVisitor::lower_pattern`.\n+    crate pat: &'p super::Pat<'tcx>,\n+    crate hir_id: HirId,\n+    crate has_guard: bool,\n+}\n+\n+/// The output of checking a match for exhaustiveness and arm reachability.\n+crate struct UsefulnessReport<'p, 'tcx> {\n+    /// For each arm of the input, whether that arm is reachable after the arms above it.\n+    crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Usefulness<'tcx>)>,\n+    /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n+    /// exhaustiveness.\n+    crate non_exhaustiveness_witnesses: Vec<super::Pat<'tcx>>,\n+}\n+\n+/// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n+/// of its arms are reachable.\n+///\n+/// Note: the input patterns must have been lowered through `MatchVisitor::lower_pattern`.\n+crate fn compute_match_usefulness<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    arms: &[MatchArm<'p, 'tcx>],\n+    scrut_hir_id: HirId,\n+    scrut_ty: Ty<'tcx>,\n+) -> UsefulnessReport<'p, 'tcx> {\n+    let mut matrix = Matrix::empty();\n+    let arm_usefulness: Vec<_> = arms\n+        .iter()\n+        .copied()\n+        .map(|arm| {\n+            let v = PatStack::from_pattern(arm.pat);\n+            let usefulness =\n+                is_useful(cx, &matrix, &v, LeaveOutWitness, arm.hir_id, arm.has_guard, true);\n+            if !arm.has_guard {\n+                matrix.push(v);\n+            }\n+            (arm, usefulness)\n+        })\n+        .collect();\n+\n+    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(scrut_ty));\n+    let v = PatStack::from_pattern(wild_pattern);\n+    let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, scrut_hir_id, false, true);\n+    let non_exhaustiveness_witnesses = match usefulness {\n+        NotUseful => vec![], // Wildcard pattern isn't useful, so the match is exhaustive.\n+        UsefulWithWitness(pats) => {\n+            if pats.is_empty() {\n+                bug!(\"Exhaustiveness check returned no witnesses\")\n+            } else {\n+                pats.into_iter().map(|w| w.single_pattern()).collect()\n+            }\n+        }\n+        Useful(_) => bug!(),\n+    };\n+    UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n+}"}, {"sha": "f9fe261bcee028644eab36372beab401338326e5", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 50, "deletions": 87, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/8256379832b5ecb7f71e8c5e2018446482223c12/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256379832b5ecb7f71e8c5e2018446482223c12/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=8256379832b5ecb7f71e8c5e2018446482223c12", "patch": "@@ -1,6 +1,7 @@\n use super::_match::Usefulness::*;\n-use super::_match::WitnessPreference::*;\n-use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack};\n+use super::_match::{\n+    compute_match_usefulness, expand_pattern, MatchArm, MatchCheckCtxt, UsefulnessReport,\n+};\n use super::{PatCtxt, PatKind, PatternError};\n \n use rustc_arena::TypedArena;\n@@ -169,39 +170,50 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n         let mut have_errors = false;\n \n-        let inlined_arms: Vec<_> = arms\n+        let arms: Vec<_> = arms\n             .iter()\n-            .map(|hir::Arm { pat, guard, .. }| {\n-                (self.lower_pattern(&mut cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n+            .map(|hir::Arm { pat, guard, .. }| MatchArm {\n+                pat: self.lower_pattern(&mut cx, pat, &mut have_errors).0,\n+                hir_id: pat.hir_id,\n+                has_guard: guard.is_some(),\n             })\n             .collect();\n \n-        // Bail out early if inlining failed.\n+        // Bail out early if lowering failed.\n         if have_errors {\n             return;\n         }\n \n-        // Fourth, check for unreachable arms.\n-        let matrix = check_arms(&mut cx, &inlined_arms, source);\n+        let scrut_ty = self.typeck_results.expr_ty_adjusted(scrut);\n+        let report = compute_match_usefulness(&cx, &arms, scrut.hir_id, scrut_ty);\n+\n+        // Report unreachable arms.\n+        report_arm_reachability(&cx, &report, source);\n \n-        // Fifth, check if the match is exhaustive.\n+        // Check if the match is exhaustive.\n         // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n         // since an empty matrix can occur when there are arms, if those arms all have guards.\n-        let scrut_ty = self.typeck_results.expr_ty_adjusted(scrut);\n-        let is_empty_match = inlined_arms.is_empty();\n-        check_exhaustive(&mut cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n+        let is_empty_match = arms.is_empty();\n+        let witnesses = report.non_exhaustiveness_witnesses;\n+        if !witnesses.is_empty() {\n+            non_exhaustive_match(&cx, scrut_ty, scrut.span, witnesses, is_empty_match);\n+        }\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(pat.hir_id);\n \n         let (pattern, pattern_ty) = self.lower_pattern(&mut cx, pat, &mut false);\n-        let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n-\n-        let witnesses = match check_not_useful(&mut cx, pattern_ty, &pats, pat.hir_id) {\n-            Ok(_) => return,\n-            Err(err) => err,\n-        };\n+        let arms = vec![MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false }];\n+        let report = compute_match_usefulness(&cx, &arms, pat.hir_id, pattern_ty);\n+\n+        // Note: we ignore whether the pattern is unreachable (i.e. whether the type is empty). We\n+        // only care about exhaustiveness here.\n+        let witnesses = report.non_exhaustiveness_witnesses;\n+        if witnesses.is_empty() {\n+            // The pattern is irrefutable.\n+            return;\n+        }\n \n         let joined_patterns = joined_uncovered_patterns(&witnesses);\n         let mut err = struct_span_err!(\n@@ -354,17 +366,15 @@ fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::\n     });\n }\n \n-/// Check for unreachable patterns.\n-fn check_arms<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    arms: &[(&'p super::Pat<'tcx>, HirId, bool)],\n+/// Report unreachable arms, if any.\n+fn report_arm_reachability<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    report: &UsefulnessReport<'p, 'tcx>,\n     source: hir::MatchSource,\n-) -> Matrix<'p, 'tcx> {\n-    let mut seen = Matrix::empty();\n+) {\n     let mut catchall = None;\n-    for (arm_index, (pat, id, has_guard)) in arms.iter().copied().enumerate() {\n-        let v = PatStack::from_pattern(pat);\n-        match is_useful(cx, &seen, &v, LeaveOutWitness, id, has_guard, true) {\n+    for (arm_index, (arm, is_useful)) in report.arm_usefulness.iter().enumerate() {\n+        match is_useful {\n             NotUseful => {\n                 match source {\n                     hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n@@ -373,95 +383,48 @@ fn check_arms<'p, 'tcx>(\n                         // Check which arm we're on.\n                         match arm_index {\n                             // The arm with the user-specified pattern.\n-                            0 => unreachable_pattern(cx.tcx, pat.span, id, None),\n+                            0 => unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, None),\n                             // The arm with the wildcard pattern.\n-                            1 => irrefutable_let_pattern(cx.tcx, pat.span, id, source),\n+                            1 => irrefutable_let_pattern(cx.tcx, arm.pat.span, arm.hir_id, source),\n                             _ => bug!(),\n                         }\n                     }\n \n                     hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                        unreachable_pattern(cx.tcx, pat.span, id, catchall);\n+                        unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, catchall);\n                     }\n \n                     // Unreachable patterns in try and await expressions occur when one of\n                     // the arms are an uninhabited type. Which is OK.\n                     hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                 }\n             }\n+            Useful(unreachables) if unreachables.is_empty() => {}\n+            // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n             Useful(unreachables) => {\n-                let mut unreachables: Vec<_> = unreachables.into_iter().flatten().collect();\n+                let mut unreachables: Vec<_> = unreachables.iter().flatten().copied().collect();\n                 // Emit lints in the order in which they occur in the file.\n                 unreachables.sort_unstable();\n                 for span in unreachables {\n-                    unreachable_pattern(cx.tcx, span, id, None);\n+                    unreachable_pattern(cx.tcx, span, arm.hir_id, None);\n                 }\n             }\n             UsefulWithWitness(_) => bug!(),\n         }\n-        if !has_guard {\n-            seen.push(v);\n-            if catchall.is_none() && pat_is_catchall(pat) {\n-                catchall = Some(pat.span);\n-            }\n+        if !arm.has_guard && catchall.is_none() && pat_is_catchall(arm.pat) {\n+            catchall = Some(arm.pat.span);\n         }\n     }\n-    seen\n }\n \n-fn check_not_useful<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    ty: Ty<'tcx>,\n-    matrix: &Matrix<'p, 'tcx>,\n-    hir_id: HirId,\n-) -> Result<(), Vec<super::Pat<'tcx>>> {\n-    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(ty));\n-    let v = PatStack::from_pattern(wild_pattern);\n-\n-    // false is given for `is_under_guard` argument due to the wildcard\n-    // pattern not having a guard\n-    match is_useful(cx, matrix, &v, ConstructWitness, hir_id, false, true) {\n-        NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n-        UsefulWithWitness(pats) => Err(if pats.is_empty() {\n-            bug!(\"Exhaustiveness check returned no witnesses\")\n-        } else {\n-            pats.into_iter().map(|w| w.single_pattern()).collect()\n-        }),\n-        Useful(_) => bug!(),\n-    }\n-}\n-\n-fn check_exhaustive<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+/// Report that a match is not exhaustive.\n+fn non_exhaustive_match<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n-    matrix: &Matrix<'p, 'tcx>,\n-    hir_id: HirId,\n+    witnesses: Vec<super::Pat<'tcx>>,\n     is_empty_match: bool,\n ) {\n-    // In the absence of the `exhaustive_patterns` feature, empty matches are not detected by\n-    // `is_useful` to exhaustively match uninhabited types, so we manually check here.\n-    if is_empty_match && !cx.tcx.features().exhaustive_patterns {\n-        let scrutinee_is_visibly_uninhabited = match scrut_ty.kind() {\n-            ty::Never => true,\n-            ty::Adt(def, _) => {\n-                def.is_enum()\n-                    && def.variants.is_empty()\n-                    && !cx.is_foreign_non_exhaustive_enum(scrut_ty)\n-            }\n-            _ => false,\n-        };\n-        if scrutinee_is_visibly_uninhabited {\n-            // If the type *is* uninhabited, an empty match is vacuously exhaustive.\n-            return;\n-        }\n-    }\n-\n-    let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {\n-        Ok(_) => return,\n-        Err(err) => err,\n-    };\n-\n     let non_empty_enum = match scrut_ty.kind() {\n         ty::Adt(def, _) => def.is_enum() && !def.variants.is_empty(),\n         _ => false,"}, {"sha": "0b0719f48ee02b944c28c9c1ce14777063156146", "filename": "src/test/ui/pattern/usefulness/auxiliary/empty.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fauxiliary%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fauxiliary%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fauxiliary%2Fempty.rs?ref=8256379832b5ecb7f71e8c5e2018446482223c12", "patch": "@@ -0,0 +1,2 @@\n+#![crate_type = \"rlib\"]\n+pub enum EmptyForeignEnum {}"}, {"sha": "c5c3a214f9aff1d4f8a566040b2c12e597d0c2b5", "filename": "src/test/ui/pattern/usefulness/match-empty-exhaustive_patterns.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.rs?ref=8256379832b5ecb7f71e8c5e2018446482223c12", "patch": "@@ -1,7 +1,12 @@\n+// aux-build:empty.rs\n #![feature(never_type)]\n+#![feature(never_type_fallback)]\n #![feature(exhaustive_patterns)]\n #![deny(unreachable_patterns)]\n-enum Foo {}\n+\n+extern crate empty;\n+\n+enum EmptyEnum {}\n \n struct NonEmptyStruct(bool); //~ `NonEmptyStruct` defined here\n union NonEmptyUnion1 { //~ `NonEmptyUnion1` defined here\n@@ -41,8 +46,28 @@ macro_rules! match_false {\n     };\n }\n \n-fn foo(x: Foo) {\n-    match_empty!(x); // ok\n+fn empty_enum(x: EmptyEnum) {\n+    match x {} // ok\n+    match x {\n+        _ => {}, //~ ERROR unreachable pattern\n+    }\n+    match x {\n+        _ if false => {}, //~ ERROR unreachable pattern\n+    }\n+}\n+\n+fn empty_foreign_enum(x: empty::EmptyForeignEnum) {\n+    match x {} // ok\n+    match x {\n+        _ => {}, //~ ERROR unreachable pattern\n+    }\n+    match x {\n+        _ if false => {}, //~ ERROR unreachable pattern\n+    }\n+}\n+\n+fn never(x: !) {\n+    match x {} // ok\n     match x {\n         _ => {}, //~ ERROR unreachable pattern\n     }\n@@ -56,7 +81,7 @@ fn main() {\n         None => {}\n         Some(_) => {} //~ ERROR unreachable pattern\n     }\n-    match None::<Foo> {\n+    match None::<EmptyEnum> {\n         None => {}\n         Some(_) => {} //~ ERROR unreachable pattern\n     }"}, {"sha": "9d8b5f38e8cf5a9e6575967baea6204f4a89515d", "filename": "src/test/ui/pattern/usefulness/match-empty-exhaustive_patterns.stderr", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.stderr?ref=8256379832b5ecb7f71e8c5e2018446482223c12", "patch": "@@ -1,35 +1,59 @@\n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:47:9\n+  --> $DIR/match-empty-exhaustive_patterns.rs:52:9\n    |\n LL |         _ => {},\n    |         ^\n    |\n note: the lint level is defined here\n-  --> $DIR/match-empty-exhaustive_patterns.rs:3:9\n+  --> $DIR/match-empty-exhaustive_patterns.rs:5:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:50:9\n+  --> $DIR/match-empty-exhaustive_patterns.rs:55:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:57:9\n+  --> $DIR/match-empty-exhaustive_patterns.rs:62:9\n+   |\n+LL |         _ => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty-exhaustive_patterns.rs:65:9\n+   |\n+LL |         _ if false => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty-exhaustive_patterns.rs:72:9\n+   |\n+LL |         _ => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty-exhaustive_patterns.rs:75:9\n+   |\n+LL |         _ if false => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty-exhaustive_patterns.rs:82:9\n    |\n LL |         Some(_) => {}\n    |         ^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:61:9\n+  --> $DIR/match-empty-exhaustive_patterns.rs:86:9\n    |\n LL |         Some(_) => {}\n    |         ^^^^^^^\n \n error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n-  --> $DIR/match-empty-exhaustive_patterns.rs:64:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:89:18\n    |\n LL |     match_empty!(0u8);\n    |                  ^^^\n@@ -38,7 +62,7 @@ LL |     match_empty!(0u8);\n    = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n-  --> $DIR/match-empty-exhaustive_patterns.rs:66:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:91:18\n    |\n LL | struct NonEmptyStruct(bool);\n    | ---------------------------- `NonEmptyStruct` defined here\n@@ -50,7 +74,7 @@ LL |     match_empty!(NonEmptyStruct(true));\n    = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n-  --> $DIR/match-empty-exhaustive_patterns.rs:68:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:93:18\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n@@ -64,7 +88,7 @@ LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n-  --> $DIR/match-empty-exhaustive_patterns.rs:70:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:95:18\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n@@ -79,7 +103,7 @@ LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:72:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:97:18\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n@@ -96,7 +120,7 @@ LL |       match_empty!(NonEmptyEnum1::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:74:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:99:18\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n@@ -117,7 +141,7 @@ LL |       match_empty!(NonEmptyEnum2::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:76:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:101:18\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n@@ -131,7 +155,7 @@ LL |       match_empty!(NonEmptyEnum5::V1);\n    = note: the matched value is of type `NonEmptyEnum5`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:79:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:104:18\n    |\n LL |     match_false!(0u8);\n    |                  ^^^ pattern `_` not covered\n@@ -140,7 +164,7 @@ LL |     match_false!(0u8);\n    = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:81:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:106:18\n    |\n LL | struct NonEmptyStruct(bool);\n    | ---------------------------- `NonEmptyStruct` defined here\n@@ -152,7 +176,7 @@ LL |     match_false!(NonEmptyStruct(true));\n    = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:83:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:108:18\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n@@ -166,7 +190,7 @@ LL |       match_false!((NonEmptyUnion1 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:85:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:110:18\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n@@ -181,7 +205,7 @@ LL |       match_false!((NonEmptyUnion2 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:87:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:112:18\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n@@ -198,7 +222,7 @@ LL |       match_false!(NonEmptyEnum1::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:89:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:114:18\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n@@ -219,7 +243,7 @@ LL |       match_false!(NonEmptyEnum2::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:91:18\n+  --> $DIR/match-empty-exhaustive_patterns.rs:116:18\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n@@ -232,6 +256,6 @@ LL |       match_false!(NonEmptyEnum5::V1);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 22 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "10ea2a10406e367079f73c60ac4dd2bf17640fb4", "filename": "src/test/ui/pattern/usefulness/match-empty.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs?ref=8256379832b5ecb7f71e8c5e2018446482223c12", "patch": "@@ -1,6 +1,11 @@\n+// aux-build:empty.rs\n #![feature(never_type)]\n+#![feature(never_type_fallback)]\n #![deny(unreachable_patterns)]\n-enum Foo {}\n+\n+extern crate empty;\n+\n+enum EmptyEnum {}\n \n struct NonEmptyStruct(bool); //~ `NonEmptyStruct` defined here\n union NonEmptyUnion1 { //~ `NonEmptyUnion1` defined here\n@@ -40,12 +45,33 @@ macro_rules! match_false {\n     };\n }\n \n-fn foo(x: Foo) {\n-    match_empty!(x); // ok\n-    match_false!(x); // Not detected as unreachable nor exhaustive.\n-    //~^ ERROR non-exhaustive patterns: `_` not covered\n+fn empty_enum(x: EmptyEnum) {\n+    match x {} // ok\n+    match x {\n+        _ => {}, //~ ERROR unreachable pattern\n+    }\n+    match x {\n+        _ if false => {}, //~ ERROR unreachable pattern\n+    }\n+}\n+\n+fn empty_foreign_enum(x: empty::EmptyForeignEnum) {\n+    match x {} // ok\n+    match x {\n+        _ => {}, //~ ERROR unreachable pattern\n+    }\n+    match x {\n+        _ if false => {}, //~ ERROR unreachable pattern\n+    }\n+}\n+\n+fn never(x: !) {\n+    match x {} // ok\n+    match x {\n+        _ => {}, //~ ERROR unreachable pattern\n+    }\n     match x {\n-        _ => {}, // Not detected as unreachable, see #55123.\n+        _ if false => {}, //~ ERROR unreachable pattern\n     }\n }\n \n@@ -55,7 +81,7 @@ fn main() {\n         None => {}\n         Some(_) => {}\n     }\n-    match None::<Foo> {\n+    match None::<EmptyEnum> {\n         None => {}\n         Some(_) => {}\n     }"}, {"sha": "6065c552390e4469625f8be745865272a938f019", "filename": "src/test/ui/pattern/usefulness/match-empty.stderr", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr?ref=8256379832b5ecb7f71e8c5e2018446482223c12", "patch": "@@ -1,17 +1,47 @@\n-error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/match-empty.rs:45:18\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:51:9\n    |\n-LL | enum Foo {}\n-   | ----------- `Foo` defined here\n-...\n-LL |     match_false!(x); // Not detected as unreachable nor exhaustive.\n-   |                  ^ pattern `_` not covered\n+LL |         _ => {},\n+   |         ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `Foo`\n+note: the lint level is defined here\n+  --> $DIR/match-empty.rs:4:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:54:9\n+   |\n+LL |         _ if false => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:61:9\n+   |\n+LL |         _ => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:64:9\n+   |\n+LL |         _ if false => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:71:9\n+   |\n+LL |         _ => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:74:9\n+   |\n+LL |         _ if false => {},\n+   |         ^\n \n error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n-  --> $DIR/match-empty.rs:63:18\n+  --> $DIR/match-empty.rs:89:18\n    |\n LL |     match_empty!(0u8);\n    |                  ^^^\n@@ -20,7 +50,7 @@ LL |     match_empty!(0u8);\n    = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n-  --> $DIR/match-empty.rs:65:18\n+  --> $DIR/match-empty.rs:91:18\n    |\n LL | struct NonEmptyStruct(bool);\n    | ---------------------------- `NonEmptyStruct` defined here\n@@ -32,7 +62,7 @@ LL |     match_empty!(NonEmptyStruct(true));\n    = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n-  --> $DIR/match-empty.rs:67:18\n+  --> $DIR/match-empty.rs:93:18\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n@@ -46,7 +76,7 @@ LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n-  --> $DIR/match-empty.rs:69:18\n+  --> $DIR/match-empty.rs:95:18\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n@@ -61,7 +91,7 @@ LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty.rs:71:18\n+  --> $DIR/match-empty.rs:97:18\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n@@ -78,7 +108,7 @@ LL |       match_empty!(NonEmptyEnum1::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty.rs:73:18\n+  --> $DIR/match-empty.rs:99:18\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n@@ -99,7 +129,7 @@ LL |       match_empty!(NonEmptyEnum2::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty.rs:75:18\n+  --> $DIR/match-empty.rs:101:18\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n@@ -113,7 +143,7 @@ LL |       match_empty!(NonEmptyEnum5::V1);\n    = note: the matched value is of type `NonEmptyEnum5`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/match-empty.rs:78:18\n+  --> $DIR/match-empty.rs:104:18\n    |\n LL |     match_false!(0u8);\n    |                  ^^^ pattern `_` not covered\n@@ -122,7 +152,7 @@ LL |     match_false!(0u8);\n    = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n-  --> $DIR/match-empty.rs:80:18\n+  --> $DIR/match-empty.rs:106:18\n    |\n LL | struct NonEmptyStruct(bool);\n    | ---------------------------- `NonEmptyStruct` defined here\n@@ -134,7 +164,7 @@ LL |     match_false!(NonEmptyStruct(true));\n    = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n-  --> $DIR/match-empty.rs:82:18\n+  --> $DIR/match-empty.rs:108:18\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n@@ -148,7 +178,7 @@ LL |       match_false!((NonEmptyUnion1 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n-  --> $DIR/match-empty.rs:84:18\n+  --> $DIR/match-empty.rs:110:18\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n@@ -163,7 +193,7 @@ LL |       match_false!((NonEmptyUnion2 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty.rs:86:18\n+  --> $DIR/match-empty.rs:112:18\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n@@ -180,7 +210,7 @@ LL |       match_false!(NonEmptyEnum1::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty.rs:88:18\n+  --> $DIR/match-empty.rs:114:18\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n@@ -201,7 +231,7 @@ LL |       match_false!(NonEmptyEnum2::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty.rs:90:18\n+  --> $DIR/match-empty.rs:116:18\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n@@ -214,6 +244,6 @@ LL |       match_false!(NonEmptyEnum5::V1);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 20 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "70253a4fc901b17ad89b57a4fa679aeb48d35043", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs?ref=8256379832b5ecb7f71e8c5e2018446482223c12", "patch": "@@ -25,7 +25,7 @@ pub enum EmptyNonExhaustiveEnum {}\n fn empty_non_exhaustive(x: EmptyNonExhaustiveEnum) {\n     match x {}\n     match x {\n-        _ => {} // not detected as unreachable\n+        _ => {} //~ ERROR unreachable pattern\n     }\n }\n "}, {"sha": "966f3a2e414857f3e87aad7af9de953104b033d6", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8256379832b5ecb7f71e8c5e2018446482223c12/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr?ref=8256379832b5ecb7f71e8c5e2018446482223c12", "patch": "@@ -1,3 +1,15 @@\n+error: unreachable pattern\n+  --> $DIR/enum_same_crate_empty_match.rs:28:9\n+   |\n+LL |         _ => {}\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/enum_same_crate_empty_match.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/enum_same_crate_empty_match.rs:33:11\n    |\n@@ -42,6 +54,6 @@ LL |       match NormalEnum::Unit {}\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NormalEnum`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}]}