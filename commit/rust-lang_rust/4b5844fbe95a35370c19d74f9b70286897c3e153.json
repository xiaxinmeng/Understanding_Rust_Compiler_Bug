{"sha": "4b5844fbe95a35370c19d74f9b70286897c3e153", "node_id": "C_kwDOAAsO6NoAKDRiNTg0NGZiZTk1YTM1MzcwYzE5ZDc0ZjliNzAyODY4OTdjM2UxNTM", "commit": {"author": {"name": "Lukas Bergdoll", "email": "lukas.bergdoll@gmail.com", "date": "2022-11-21T13:30:56Z"}, "committer": {"name": "Lukas Bergdoll", "email": "lukas.bergdoll@gmail.com", "date": "2022-11-21T13:30:56Z"}, "message": "Document all unsafe blocks\n\nThere were several unsafe blocks in the existing implementation that\nwere not documented with a SAFETY comment.", "tree": {"sha": "e4760d9eefc2f5acfd6f2166a0d68b853e3e6f30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4760d9eefc2f5acfd6f2166a0d68b853e3e6f30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b5844fbe95a35370c19d74f9b70286897c3e153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b5844fbe95a35370c19d74f9b70286897c3e153", "html_url": "https://github.com/rust-lang/rust/commit/4b5844fbe95a35370c19d74f9b70286897c3e153", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b5844fbe95a35370c19d74f9b70286897c3e153/comments", "author": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c", "html_url": "https://github.com/rust-lang/rust/commit/1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c"}], "stats": {"total": 21, "additions": 20, "deletions": 1}, "files": [{"sha": "3da00b8f79672b23e9a69ac0abdbc3f6a4c45a1c", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b5844fbe95a35370c19d74f9b70286897c3e153/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5844fbe95a35370c19d74f9b70286897c3e153/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=4b5844fbe95a35370c19d74f9b70286897c3e153", "patch": "@@ -940,6 +940,7 @@ where\n     F: FnMut(&T, &T) -> bool,\n {\n     if v.len() >= 2 && is_less(&v[1], &v[0]) {\n+        // SAFETY: Copy tmp back even if panic, and ensure unique observation.\n         unsafe {\n             // There are three ways to implement insertion here:\n             //\n@@ -992,6 +993,7 @@ where\n \n     impl<T> Drop for InsertionHole<T> {\n         fn drop(&mut self) {\n+            // SAFETY: The caller must ensure that src and dest are correctly set.\n             unsafe {\n                 ptr::copy_nonoverlapping(self.src, self.dest, 1);\n             }\n@@ -1012,6 +1014,8 @@ where\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n+\n+    // SAFETY: mid and len must be in-bounds of v.\n     let (v_mid, v_end) = unsafe { (v.add(mid), v.add(len)) };\n \n     // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n@@ -1035,6 +1039,8 @@ where\n \n     if mid <= len - mid {\n         // The left run is shorter.\n+\n+        // SAFETY: buf must have enough capacity for `v[..mid]`.\n         unsafe {\n             ptr::copy_nonoverlapping(v, buf, mid);\n             hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n@@ -1048,6 +1054,8 @@ where\n         while *left < hole.end && right < v_end {\n             // Consume the lesser side.\n             // If equal, prefer the left run to maintain stability.\n+\n+            // SAFETY: left and right must be valid and part of v same for out.\n             unsafe {\n                 let to_copy = if is_less(&*right, &**left) {\n                     get_and_increment(&mut right)\n@@ -1059,6 +1067,8 @@ where\n         }\n     } else {\n         // The right run is shorter.\n+\n+        // SAFETY: buf must have enough capacity for `v[mid..]`.\n         unsafe {\n             ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n             hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n@@ -1072,6 +1082,8 @@ where\n         while v < *left && buf < *right {\n             // Consume the greater side.\n             // If equal, prefer the right run to maintain stability.\n+\n+            // SAFETY: left and right must be valid and part of v same for out.\n             unsafe {\n                 let to_copy = if is_less(&*right.sub(1), &*left.sub(1)) {\n                     decrement_and_get(left)\n@@ -1087,11 +1099,14 @@ where\n \n     unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n         let old = *ptr;\n+\n+        // SAFETY: ptr.add(1) must still be a valid pointer and part of `v`.\n         *ptr = unsafe { ptr.add(1) };\n         old\n     }\n \n     unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n+        // SAFETY: ptr.sub(1) must still be a valid pointer and part of `v`.\n         *ptr = unsafe { ptr.sub(1) };\n         *ptr\n     }\n@@ -1105,7 +1120,7 @@ where\n \n     impl<T> Drop for MergeHole<T> {\n         fn drop(&mut self) {\n-            // `T` is not a zero-sized type, and these are pointers into a slice's elements.\n+            // SAFETY: `T` is not a zero-sized type, and these are pointers into a slice's elements.\n             unsafe {\n                 let len = self.end.sub_ptr(self.start);\n                 ptr::copy_nonoverlapping(self.start, self.dest, len);\n@@ -1180,6 +1195,8 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         let mut start = end - 1;\n         if start > 0 {\n             start -= 1;\n+\n+            // SAFETY: The v.get_unchecked must be fed with correct inbound indicies.\n             unsafe {\n                 if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n                     while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n@@ -1210,6 +1227,8 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         while let Some(r) = collapse(runs.as_slice()) {\n             let left = runs[r + 1];\n             let right = runs[r];\n+            // SAFETY: `buf_ptr` must hold enough capacity for the shorter of the two sides, and\n+            // neither side may be on length 0.\n             unsafe {\n                 merge(&mut v[left.start..right.start + right.len], left.len, buf_ptr, is_less);\n             }"}]}