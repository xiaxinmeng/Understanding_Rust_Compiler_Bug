{"sha": "ce0896b78cec180fad11a631abbce38efad69697", "node_id": "C_kwDOAAsO6NoAKGNlMDg5NmI3OGNlYzE4MGZhZDExYTYzMWFiYmNlMzhlZmFkNjk2OTc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-14T10:05:11Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-14T10:05:11Z"}, "message": "Allocate ExprScopes ScopeEntries in a single arena instead of per ScopeData", "tree": {"sha": "0f2fd41a2ca5a1c6ccef8d7fbfb5c08a5d95bd40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f2fd41a2ca5a1c6ccef8d7fbfb5c08a5d95bd40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce0896b78cec180fad11a631abbce38efad69697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce0896b78cec180fad11a631abbce38efad69697", "html_url": "https://github.com/rust-lang/rust/commit/ce0896b78cec180fad11a631abbce38efad69697", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce0896b78cec180fad11a631abbce38efad69697/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c251a7e2bdd44120f900063bc1809c1475a7372", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c251a7e2bdd44120f900063bc1809c1475a7372", "html_url": "https://github.com/rust-lang/rust/commit/2c251a7e2bdd44120f900063bc1809c1475a7372"}], "stats": {"total": 62, "additions": 49, "deletions": 13}, "files": [{"sha": "1143f666eea182d9ad84086278e3476eeb8992bb", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ce0896b78cec180fad11a631abbce38efad69697/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0896b78cec180fad11a631abbce38efad69697/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=ce0896b78cec180fad11a631abbce38efad69697", "patch": "@@ -2,7 +2,7 @@\n use std::sync::Arc;\n \n use hir_expand::name::Name;\n-use la_arena::{Arena, Idx};\n+use la_arena::{Arena, Idx, IdxRange, RawIdx};\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -17,6 +17,7 @@ pub type ScopeId = Idx<ScopeData>;\n #[derive(Debug, PartialEq, Eq)]\n pub struct ExprScopes {\n     scopes: Arena<ScopeData>,\n+    scope_entries: Arena<ScopeEntry>,\n     scope_by_expr: FxHashMap<ExprId, ScopeId>,\n }\n \n@@ -41,7 +42,7 @@ pub struct ScopeData {\n     parent: Option<ScopeId>,\n     block: Option<BlockId>,\n     label: Option<(LabelId, Name)>,\n-    entries: Vec<ScopeEntry>,\n+    entries: IdxRange<ScopeEntry>,\n }\n \n impl ExprScopes {\n@@ -53,7 +54,7 @@ impl ExprScopes {\n     }\n \n     pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n+        &self.scope_entries[self.scopes[scope].entries.clone()]\n     }\n \n     /// If `scope` refers to a block expression scope, returns the corresponding `BlockId`.\n@@ -85,31 +86,48 @@ impl ExprScopes {\n     }\n }\n \n+fn empty_entries(idx: usize) -> IdxRange<ScopeEntry> {\n+    IdxRange::new(Idx::from_raw(RawIdx::from(idx as u32))..Idx::from_raw(RawIdx::from(idx as u32)))\n+}\n+\n impl ExprScopes {\n     fn new(body: &Body) -> ExprScopes {\n-        let mut scopes =\n-            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n+        let mut scopes = ExprScopes {\n+            scopes: Arena::default(),\n+            scope_entries: Arena::default(),\n+            scope_by_expr: FxHashMap::default(),\n+        };\n         let mut root = scopes.root_scope();\n         scopes.add_params_bindings(body, root, &body.params);\n         compute_expr_scopes(body.body_expr, body, &mut scopes, &mut root);\n         scopes\n     }\n \n     fn root_scope(&mut self) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: None, block: None, label: None, entries: vec![] })\n+        self.scopes.alloc(ScopeData {\n+            parent: None,\n+            block: None,\n+            label: None,\n+            entries: empty_entries(self.scope_entries.len()),\n+        })\n     }\n \n     fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n         self.scopes.alloc(ScopeData {\n             parent: Some(parent),\n             block: None,\n             label: None,\n-            entries: vec![],\n+            entries: empty_entries(self.scope_entries.len()),\n         })\n     }\n \n     fn new_labeled_scope(&mut self, parent: ScopeId, label: Option<(LabelId, Name)>) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: Some(parent), block: None, label, entries: vec![] })\n+        self.scopes.alloc(ScopeData {\n+            parent: Some(parent),\n+            block: None,\n+            label,\n+            entries: empty_entries(self.scope_entries.len()),\n+        })\n     }\n \n     fn new_block_scope(\n@@ -118,13 +136,19 @@ impl ExprScopes {\n         block: Option<BlockId>,\n         label: Option<(LabelId, Name)>,\n     ) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: Some(parent), block, label, entries: vec![] })\n+        self.scopes.alloc(ScopeData {\n+            parent: Some(parent),\n+            block,\n+            label,\n+            entries: empty_entries(self.scope_entries.len()),\n+        })\n     }\n \n     fn add_bindings(&mut self, body: &Body, scope: ScopeId, binding: BindingId) {\n         let Binding { name, .. } = &body.bindings[binding];\n-        let entry = ScopeEntry { name: name.clone(), binding };\n-        self.scopes[scope].entries.push(entry);\n+        let entry = self.scope_entries.alloc(ScopeEntry { name: name.clone(), binding });\n+        self.scopes[scope].entries =\n+            IdxRange::new_inclusive(self.scopes[scope].entries.start()..=entry);\n     }\n \n     fn add_pat_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n@@ -145,9 +169,9 @@ impl ExprScopes {\n     }\n \n     fn shrink_to_fit(&mut self) {\n-        let ExprScopes { scopes, scope_by_expr } = self;\n+        let ExprScopes { scopes, scope_entries, scope_by_expr } = self;\n         scopes.shrink_to_fit();\n-        scopes.values_mut().for_each(|it| it.entries.shrink_to_fit());\n+        scope_entries.shrink_to_fit();\n         scope_by_expr.shrink_to_fit();\n     }\n }"}, {"sha": "b03fa5b61d3058493b079aecd3967fe813c73922", "filename": "lib/la-arena/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce0896b78cec180fad11a631abbce38efad69697/lib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0896b78cec180fad11a631abbce38efad69697/lib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Flib.rs?ref=ce0896b78cec180fad11a631abbce38efad69697", "patch": "@@ -19,12 +19,14 @@ pub use map::{ArenaMap, Entry, OccupiedEntry, VacantEntry};\n pub struct RawIdx(u32);\n \n impl From<RawIdx> for u32 {\n+    #[inline]\n     fn from(raw: RawIdx) -> u32 {\n         raw.0\n     }\n }\n \n impl From<u32> for RawIdx {\n+    #[inline]\n     fn from(idx: u32) -> RawIdx {\n         RawIdx(idx)\n     }\n@@ -160,6 +162,16 @@ impl<T> IdxRange<T> {\n     pub fn is_empty(&self) -> bool {\n         self.range.is_empty()\n     }\n+\n+    /// Returns the start of the index range.\n+    pub fn start(&self) -> Idx<T> {\n+        Idx::from_raw(RawIdx::from(self.range.start))\n+    }\n+\n+    /// Returns the start of the index range.\n+    pub fn end(&self) -> Idx<T> {\n+        Idx::from_raw(RawIdx::from(self.range.end))\n+    }\n }\n \n impl<T> Iterator for IdxRange<T> {"}]}