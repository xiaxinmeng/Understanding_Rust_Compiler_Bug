{"sha": "7527084e629340503fbe15b8e21c73879b5bd253", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MjcwODRlNjI5MzQwNTAzZmJlMTViOGUyMWM3Mzg3OWI1YmQyNTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-09T00:57:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-09T01:05:45Z"}, "message": "rustc: Don't generate so many variables when typechecking functions; remove mo_either", "tree": {"sha": "0697daf9e470b8a5afb1792069a6f31cc07df391", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0697daf9e470b8a5afb1792069a6f31cc07df391"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7527084e629340503fbe15b8e21c73879b5bd253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7527084e629340503fbe15b8e21c73879b5bd253", "html_url": "https://github.com/rust-lang/rust/commit/7527084e629340503fbe15b8e21c73879b5bd253", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7527084e629340503fbe15b8e21c73879b5bd253/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8691a1a1e5900eaca70415bad0bffdbfe8bd7389", "url": "https://api.github.com/repos/rust-lang/rust/commits/8691a1a1e5900eaca70415bad0bffdbfe8bd7389", "html_url": "https://github.com/rust-lang/rust/commit/8691a1a1e5900eaca70415bad0bffdbfe8bd7389"}], "stats": {"total": 101, "additions": 51, "deletions": 50}, "files": [{"sha": "b433799ac3689458270a8bd16e81cb1a08deb928", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7527084e629340503fbe15b8e21c73879b5bd253/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7527084e629340503fbe15b8e21c73879b5bd253/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=7527084e629340503fbe15b8e21c73879b5bd253", "patch": "@@ -73,7 +73,6 @@ fn check_expr(ctx cx, &@ast::expr ex) {\n             auto i = 0u;\n             let vec[def_id] listed = [];\n             for (ty::arg argty in argtys) {\n-                // FIXME Treat mo_either specially here?\n                 if (argty.mode != ty::mo_val) {\n                     alt (check_rooted(cx, args.(i), false)) {\n                         case (some(?did)) {"}, {"sha": "0aa4a5c382190bd3ebddc5bf5af47211249548e6", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7527084e629340503fbe15b8e21c73879b5bd253/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7527084e629340503fbe15b8e21c73879b5bd253/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=7527084e629340503fbe15b8e21c73879b5bd253", "patch": "@@ -42,7 +42,6 @@ import util::data::interner;\n tag mode {\n     mo_val;\n     mo_alias;\n-    mo_either;\n }\n \n type arg = rec(mode mode, t ty);\n@@ -486,7 +485,6 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         alt (input.mode) {\n             case (mo_val) { s = \"\"; }\n             case (mo_alias) { s = \"&\"; }\n-            case (mo_either) { s = \"?\"; }\n         }\n \n         ret s + ty_to_str(cx, input.ty);\n@@ -1944,13 +1942,9 @@ mod unify {\n             auto expected_input = expected_inputs.(i);\n             auto actual_input = actual_inputs.(i);\n \n-            // Unify the result modes. \"mo_either\" unifies with both modes.\n+            // Unify the result modes.\n             auto result_mode;\n-            if (expected_input.mode == mo_either) {\n-                result_mode = actual_input.mode;\n-            } else if (actual_input.mode == mo_either) {\n-                result_mode = expected_input.mode;\n-            } else if (expected_input.mode != actual_input.mode) {\n+            if (expected_input.mode != actual_input.mode) {\n                 // FIXME this is the wrong error\n                 ret fn_common_res_err(ures_err(terr_arg_count));\n             } else {"}, {"sha": "2f475b9a464fec2e510c7fba27c9c58a7e633ca4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7527084e629340503fbe15b8e21c73879b5bd253/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7527084e629340503fbe15b8e21c73879b5bd253/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=7527084e629340503fbe15b8e21c73879b5bd253", "patch": "@@ -18,7 +18,6 @@ import middle::ty::field;\n import middle::ty::method;\n import middle::ty::mo_val;\n import middle::ty::mo_alias;\n-import middle::ty::mo_either;\n import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n import middle::ty::path_to_str;\n@@ -1401,52 +1400,60 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n-    fn check_call_or_bind(&@fn_ctxt fcx, &@ast::expr f,\n+    fn check_call_or_bind(&@fn_ctxt fcx, &span sp, &@ast::expr f,\n                           &vec[option::t[@ast::expr]] args) {\n         // Check the function.\n         check_expr(fcx, f);\n \n-        // Check the arguments and generate the argument signature.\n-        let vec[option::t[@ast::expr]] args_0 = [];\n-        let vec[arg] arg_tys_0 = [];\n+        // Get the function type. We need to have resolved it enough to know\n+        // it's a ty_fn or ty_native_fn.\n+        auto fty = expr_ty(fcx.ccx.tcx, f);\n+        fty = ty::unify::resolve_all_vars(fcx.ccx.tcx, fcx.var_bindings, fty);\n+\n+        // Grab the argument types and the return type.\n+        auto arg_tys;\n+        alt (ty::struct(fcx.ccx.tcx, fty)) {\n+            case (ty::ty_fn(_, ?arg_tys_0, _, _)) {\n+                arg_tys = arg_tys_0;\n+            }\n+            case (ty::ty_native_fn(_, ?arg_tys_0, _)) {\n+                arg_tys = arg_tys_0;\n+            }\n+            case (_) {\n+                fcx.ccx.tcx.sess.span_err(f.span, \"mismatched types: \" +\n+                    \"expected function or native function but found \" +\n+                    ty_to_str(fcx.ccx.tcx, fty));\n+            }\n+        }\n+\n+        // Check that the correct number of arguments were supplied.\n+        auto expected_arg_count = vec::len[ty::arg](arg_tys);\n+        auto supplied_arg_count = vec::len[option::t[@ast::expr]](args);\n+        if (expected_arg_count != supplied_arg_count) {\n+            fcx.ccx.tcx.sess.span_err(sp,\n+                #fmt(\"this function takes %u parameter%s but %u parameter%s \\\n+                     supplied\",\n+                     expected_arg_count,\n+                     if (expected_arg_count == 1u) { \"\" } else { \"s\" },\n+                     supplied_arg_count,\n+                     if (supplied_arg_count == 1u) { \" was\" }\n+                        else { \"s were\" }));\n+        }\n+\n+        // Check the arguments.\n+        // TODO: iter2\n+        auto i = 0u;\n         for (option::t[@ast::expr] a_opt in args) {\n             alt (a_opt) {\n                 case (some(?a)) {\n                     check_expr(fcx, a);\n-                    auto typ = expr_ty(fcx.ccx.tcx, a);\n-                    vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n+                    demand::simple(fcx, a.span, arg_tys.(i).ty,\n+                                   expr_ty(fcx.ccx.tcx, a));\n                 }\n-                case (none) {\n-                    auto typ = next_ty_var(fcx);\n-                    vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n-                }\n-            }\n-        }\n-\n-        auto rt_0 = next_ty_var(fcx);\n-        auto t_0;\n-        alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, f))) {\n-            case (ty::ty_fn(?proto, _, _, ?cf))   {\n-                t_0 = ty::mk_fn(fcx.ccx.tcx, proto, arg_tys_0, rt_0, cf);\n-            }\n-            case (ty::ty_native_fn(?abi, _, _))   {\n-                t_0 = ty::mk_native_fn(fcx.ccx.tcx, abi, arg_tys_0, rt_0);\n-            }\n-            case (?u) {\n-                fcx.ccx.tcx.sess.span_err(f.span,\n-                    \"check_call_or_bind(): fn expr doesn't have fn type,\"\n-                    + \" instead having: \" +\n-                    ty_to_str(fcx.ccx.tcx,\n-                              expr_ty(fcx.ccx.tcx, f)));\n+                case (none) { /* no-op */ }\n             }\n+            i += 1u;\n         }\n-\n-        // Unify the callee and arguments.\n-        auto f_ty = ty::expr_ty(fcx.ccx.tcx, f);\n-        auto f_tps = ty::expr_ty_params_and_ty(fcx.ccx.tcx, f)._0;\n-        auto tpt_1 = demand::full(fcx, f.span, f_ty, t_0, f_tps,\n-                                  NO_AUTODEREF);\n-        //replace_expr_type(fcx, f, tpt_1);\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1461,14 +1468,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     }\n \n     // A generic function for checking call expressions\n-    fn check_call(&@fn_ctxt fcx, &@ast::expr f, &vec[@ast::expr] args) {\n+    fn check_call(&@fn_ctxt fcx, &span sp, &@ast::expr f,\n+                  &vec[@ast::expr] args) {\n         let vec[option::t[@ast::expr]] args_opt_0 = [];\n         for (@ast::expr arg in args) {\n             args_opt_0 += [some[@ast::expr](arg)];\n         }\n \n         // Call the generic checker.\n-        check_call_or_bind(fcx, f, args_opt_0);\n+        check_call_or_bind(fcx, sp, f, args_opt_0);\n     }\n \n     // A generic function for checking for or for-each loops\n@@ -1861,7 +1869,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n         case (ast::expr_bind(?f, ?args, ?a)) {\n             // Call the generic checker.\n-            check_call_or_bind(fcx, f, args);\n+            check_call_or_bind(fcx, expr.span, f, args);\n \n             // Pull the argument and return types out.\n             auto proto_1;\n@@ -1904,7 +1912,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             function name onto purity-designation */\n             require_pure_call(fcx.ccx, fcx.purity, f, expr.span);\n \n-            check_call(fcx, f, args);\n+            check_call(fcx, expr.span, f, args);\n \n             // Pull the return type out of the type of the function.\n             auto rt_1 = ty::mk_nil(fcx.ccx.tcx); // FIXME: typestate botch\n@@ -1959,7 +1967,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         }\n \n         case (ast::expr_spawn(_, _, ?f, ?args, ?a)) {\n-            check_call(fcx, f, args);\n+            check_call(fcx, expr.span, f, args);\n \n             auto fty = expr_ty(fcx.ccx.tcx, f);\n             auto ret_ty = ty::ret_ty_of_fn_ty(fcx.ccx.tcx, fty);"}]}