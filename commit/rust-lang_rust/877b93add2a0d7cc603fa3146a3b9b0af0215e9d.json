{"sha": "877b93add2a0d7cc603fa3146a3b9b0af0215e9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3N2I5M2FkZDJhMGQ3Y2M2MDNmYTMxNDZhM2I5YjBhZjAyMTVlOWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-21T21:35:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-03T09:35:00Z"}, "message": "Move shifting code out of expr and into somewhere more accessible", "tree": {"sha": "cf20d723cb301744182b9d822269c08ff8211f98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf20d723cb301744182b9d822269c08ff8211f98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/877b93add2a0d7cc603fa3146a3b9b0af0215e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/877b93add2a0d7cc603fa3146a3b9b0af0215e9d", "html_url": "https://github.com/rust-lang/rust/commit/877b93add2a0d7cc603fa3146a3b9b0af0215e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/877b93add2a0d7cc603fa3146a3b9b0af0215e9d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81ff2c2f8e964c33ac8d4b3570fc881658301068", "url": "https://api.github.com/repos/rust-lang/rust/commits/81ff2c2f8e964c33ac8d4b3570fc881658301068", "html_url": "https://github.com/rust-lang/rust/commit/81ff2c2f8e964c33ac8d4b3570fc881658301068"}], "stats": {"total": 151, "additions": 88, "deletions": 63}, "files": [{"sha": "a536060efbd0f43be93adc87f777326d832ad19f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/877b93add2a0d7cc603fa3146a3b9b0af0215e9d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/877b93add2a0d7cc603fa3146a3b9b0af0215e9d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=877b93add2a0d7cc603fa3146a3b9b0af0215e9d", "patch": "@@ -75,6 +75,7 @@ use trans::intrinsic;\n use trans::machine;\n use trans::machine::{llsize_of, llsize_of_real};\n use trans::meth;\n+use trans::mir;\n use trans::monomorphize;\n use trans::tvec;\n use trans::type_::Type;\n@@ -1231,7 +1232,10 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         false\n     };\n \n+    let mir = ccx.mir_map().get(&id);\n+\n     let mut fcx = FunctionContext {\n+          mir: mir,\n           llfn: llfndecl,\n           llenv: None,\n           llretslotptr: Cell::new(None),\n@@ -1571,7 +1575,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    llfndecl: ValueRef,\n                                    param_substs: &'tcx Substs<'tcx>,\n                                    fn_ast_id: ast::NodeId,\n-                                   _attributes: &[ast::Attribute],\n+                                   attributes: &[ast::Attribute],\n                                    output_type: ty::FnOutput<'tcx>,\n                                    abi: Abi,\n                                    closure_env: closure::ClosureEnv<'b>) {\n@@ -1600,6 +1604,12 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                       &arena);\n     let mut bcx = init_function(&fcx, false, output_type);\n \n+    if attributes.iter().any(|item| item.check_name(\"rustc_mir\")) {\n+        mir::trans_mir(bcx);\n+        fcx.cleanup();\n+        return;\n+    }\n+\n     // cleanup scope for the incoming arguments\n     let fn_cleanup_debug_loc =\n         debuginfo::get_cleanup_debug_loc_for_ast_node(ccx, fn_ast_id, body.span, true);"}, {"sha": "b5f192b9727421cfba2fb384c9370e84aece07a6", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/877b93add2a0d7cc603fa3146a3b9b0af0215e9d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/877b93add2a0d7cc603fa3146a3b9b0af0215e9d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=877b93add2a0d7cc603fa3146a3b9b0af0215e9d", "patch": "@@ -16,7 +16,7 @@ pub use self::ExprOrMethodCall::*;\n \n use session::Session;\n use llvm;\n-use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n+use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool};\n use middle::cfg;\n use middle::def;\n@@ -40,6 +40,7 @@ use middle::traits;\n use middle::ty::{self, HasTypeFlags, Ty};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use rustc_front::hir;\n+use rustc_mir::repr::Mir;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n@@ -328,6 +329,11 @@ impl<'tcx> DropFlagHintsMap<'tcx> {\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n+    // The MIR for this function. At present, this is optional because\n+    // we only have MIR available for things that are local to the\n+    // crate.\n+    pub mir: Option<&'a Mir<'tcx>>,\n+\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n@@ -407,6 +413,10 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n+    pub fn mir(&self) -> &'a Mir<'tcx> {\n+        self.mir.unwrap()\n+    }\n+\n     pub fn arg_offset(&self) -> usize {\n         self.env_arg_pos() + if self.llenv.is_some() { 1 } else { 0 }\n     }\n@@ -644,6 +654,10 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n     pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n+    pub fn mir(&self) -> &'blk Mir<'tcx> {\n+        self.fcx.mir()\n+    }\n+\n     pub fn name(&self, name: ast::Name) -> String {\n         name.to_string()\n     }\n@@ -1132,3 +1146,65 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ccx.sess().bug(&format!(\"no variant for {:?}::{}\", adt_def, inlined_vid))\n     })\n }\n+\n+// To avoid UB from LLVM, these two functions mask RHS with an\n+// appropriate mask unconditionally (i.e. the fallback behavior for\n+// all shifts). For 32- and 64-bit types, this matches the semantics\n+// of Java. (See related discussion on #1877 and #10183.)\n+\n+pub fn build_unchecked_lshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          lhs: ValueRef,\n+                                          rhs: ValueRef,\n+                                          binop_debug_loc: DebugLoc) -> ValueRef {\n+    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShl, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n+    build::Shl(bcx, lhs, rhs, binop_debug_loc)\n+}\n+\n+pub fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          lhs_t: Ty<'tcx>,\n+                                          lhs: ValueRef,\n+                                          rhs: ValueRef,\n+                                          binop_debug_loc: DebugLoc) -> ValueRef {\n+    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n+    let is_signed = lhs_t.is_signed();\n+    if is_signed {\n+        build::AShr(bcx, lhs, rhs, binop_debug_loc)\n+    } else {\n+        build::LShr(bcx, lhs, rhs, binop_debug_loc)\n+    }\n+}\n+\n+fn shift_mask_rhs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              rhs: ValueRef,\n+                              debug_loc: DebugLoc) -> ValueRef {\n+    let rhs_llty = val_ty(rhs);\n+    build::And(bcx, rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false), debug_loc)\n+}\n+\n+pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              llty: Type,\n+                              mask_llty: Type,\n+                              invert: bool) -> ValueRef {\n+    let kind = llty.kind();\n+    match kind {\n+        TypeKind::Integer => {\n+            // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n+            let val = llty.int_width() - 1;\n+            if invert {\n+                C_integral(mask_llty, !val, true)\n+            } else {\n+                C_integral(mask_llty, val, false)\n+            }\n+        },\n+        TypeKind::Vector => {\n+            let mask = shift_mask_val(bcx, llty.element_type(), mask_llty.element_type(), invert);\n+            build::VectorSplat(bcx, mask_llty.vector_length(), mask)\n+        },\n+        _ => panic!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n+    }\n+}\n+"}, {"sha": "7648587e35268458c1a92b90beb66a0ef42aeb56", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/877b93add2a0d7cc603fa3146a3b9b0af0215e9d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/877b93add2a0d7cc603fa3146a3b9b0af0215e9d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=877b93add2a0d7cc603fa3146a3b9b0af0215e9d", "patch": "@@ -2574,29 +2574,6 @@ impl OverflowOpViaInputCheck {\n     }\n }\n \n-fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              llty: Type,\n-                              mask_llty: Type,\n-                              invert: bool) -> ValueRef {\n-    let kind = llty.kind();\n-    match kind {\n-        TypeKind::Integer => {\n-            // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n-            let val = llty.int_width() - 1;\n-            if invert {\n-                C_integral(mask_llty, !val, true)\n-            } else {\n-                C_integral(mask_llty, val, false)\n-            }\n-        },\n-        TypeKind::Vector => {\n-            let mask = shift_mask_val(bcx, llty.element_type(), mask_llty.element_type(), invert);\n-            VectorSplat(bcx, mask_llty.vector_length(), mask)\n-        },\n-        _ => panic!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n-    }\n-}\n-\n // Check if an integer or vector contains a nonzero element.\n fn build_nonzero_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    value: ValueRef,\n@@ -2616,44 +2593,6 @@ fn build_nonzero_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-// To avoid UB from LLVM, these two functions mask RHS with an\n-// appropriate mask unconditionally (i.e. the fallback behavior for\n-// all shifts). For 32- and 64-bit types, this matches the semantics\n-// of Java. (See related discussion on #1877 and #10183.)\n-\n-fn build_unchecked_lshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                      lhs: ValueRef,\n-                                      rhs: ValueRef,\n-                                      binop_debug_loc: DebugLoc) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShl, lhs, rhs);\n-    // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n-    Shl(bcx, lhs, rhs, binop_debug_loc)\n-}\n-\n-fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                      lhs_t: Ty<'tcx>,\n-                                      lhs: ValueRef,\n-                                      rhs: ValueRef,\n-                                      binop_debug_loc: DebugLoc) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n-    // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n-    let is_signed = lhs_t.is_signed();\n-    if is_signed {\n-        AShr(bcx, lhs, rhs, binop_debug_loc)\n-    } else {\n-        LShr(bcx, lhs, rhs, binop_debug_loc)\n-    }\n-}\n-\n-fn shift_mask_rhs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              rhs: ValueRef,\n-                              debug_loc: DebugLoc) -> ValueRef {\n-    let rhs_llty = val_ty(rhs);\n-    And(bcx, rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false), debug_loc)\n-}\n-\n fn with_overflow_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, oop: OverflowOp, info: NodeIdAndSpan,\n                                    lhs_t: Ty<'tcx>, lhs: ValueRef,\n                                    rhs: ValueRef,"}]}