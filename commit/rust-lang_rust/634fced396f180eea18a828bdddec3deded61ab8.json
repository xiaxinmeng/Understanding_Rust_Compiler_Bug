{"sha": "634fced396f180eea18a828bdddec3deded61ab8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNGZjZWQzOTZmMTgwZWVhMThhODI4YmRkZGVjM2RlZGVkNjFhYjg=", "commit": {"author": {"name": "Michael Sproul", "email": "micsproul@gmail.com", "date": "2015-06-20T06:30:01Z"}, "committer": {"name": "Michael Sproul", "email": "micsproul@gmail.com", "date": "2015-06-20T06:57:40Z"}, "message": "diagnostics: Resurrect the Compiler Error Index.", "tree": {"sha": "629f34b726d7484b04a9c51fe0094046f8486dc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/629f34b726d7484b04a9c51fe0094046f8486dc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/634fced396f180eea18a828bdddec3deded61ab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/634fced396f180eea18a828bdddec3deded61ab8", "html_url": "https://github.com/rust-lang/rust/commit/634fced396f180eea18a828bdddec3deded61ab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/634fced396f180eea18a828bdddec3deded61ab8/comments", "author": {"login": "michaelsproul", "id": 4452260, "node_id": "MDQ6VXNlcjQ0NTIyNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelsproul", "html_url": "https://github.com/michaelsproul", "followers_url": "https://api.github.com/users/michaelsproul/followers", "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}", "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions", "organizations_url": "https://api.github.com/users/michaelsproul/orgs", "repos_url": "https://api.github.com/users/michaelsproul/repos", "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelsproul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelsproul", "id": 4452260, "node_id": "MDQ6VXNlcjQ0NTIyNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelsproul", "html_url": "https://github.com/michaelsproul", "followers_url": "https://api.github.com/users/michaelsproul/followers", "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}", "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions", "organizations_url": "https://api.github.com/users/michaelsproul/orgs", "repos_url": "https://api.github.com/users/michaelsproul/repos", "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelsproul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f5683913c9815d9f12494784747f79b0f3b3066", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f5683913c9815d9f12494784747f79b0f3b3066", "html_url": "https://github.com/rust-lang/rust/commit/2f5683913c9815d9f12494784747f79b0f3b3066"}], "stats": {"total": 147, "additions": 54, "deletions": 93}, "files": [{"sha": "617c3ddf8dec1eb94fe49751d886d59102e9a730", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/634fced396f180eea18a828bdddec3deded61ab8/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/634fced396f180eea18a828bdddec3deded61ab8/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=634fced396f180eea18a828bdddec3deded61ab8", "patch": "@@ -77,8 +77,7 @@ ERR_IDX_GEN = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(ERR_IDX_GEN_EXE)\n \n D := $(S)src/doc\n \n-# FIXME (#25705) eventually may want to put error-index target back here.\n-DOC_TARGETS := trpl style\n+DOC_TARGETS := trpl style error-index\n COMPILER_DOC_TARGETS :=\n DOC_L10N_TARGETS :=\n "}, {"sha": "cbb67014e276025f4e3e3eb1473cbf642ff8a67f", "filename": "src/error-index-generator/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/634fced396f180eea18a828bdddec3deded61ab8/src%2Ferror-index-generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/634fced396f180eea18a828bdddec3deded61ab8/src%2Ferror-index-generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror-index-generator%2Fmain.rs?ref=634fced396f180eea18a828bdddec3deded61ab8", "patch": "@@ -17,6 +17,7 @@ extern crate serialize as rustc_serialize;\n use std::collections::BTreeMap;\n use std::fs::{read_dir, File};\n use std::io::{Read, Write};\n+use std::env;\n use std::path::Path;\n use std::error::Error;\n \n@@ -106,7 +107,8 @@ r##\"<!DOCTYPE html>\n }\n \n fn main_with_result() -> Result<(), Box<Error>> {\n-    let metadata_dir = get_metadata_dir();\n+    let build_arch = try!(env::var(\"CFG_BUILD\"));\n+    let metadata_dir = get_metadata_dir(&build_arch);\n     let err_map = try!(load_all_errors(&metadata_dir));\n     try!(render_error_page(&err_map, Path::new(\"doc/error-index.html\")));\n     Ok(())"}, {"sha": "448a9f2b960dcae5162c73e39e8d81f6a162c616", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/634fced396f180eea18a828bdddec3deded61ab8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/634fced396f180eea18a828bdddec3deded61ab8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=634fced396f180eea18a828bdddec3deded61ab8", "patch": "@@ -586,9 +586,11 @@ struct ListNode {\n This type cannot have a well-defined size, because it needs to be arbitrarily\n large (since we would be able to nest `ListNode`s to any depth). Specifically,\n \n-    size of `ListNode` = 1 byte for `head`\n-                       + 1 byte for the discriminant of the `Option`\n-                       + size of `ListNode`\n+```plain\n+size of `ListNode` = 1 byte for `head`\n+                   + 1 byte for the discriminant of the `Option`\n+                   + size of `ListNode`\n+```\n \n One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n "}, {"sha": "e988b74cb3d1d3ceedbefc4f179d87718a564069", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 29, "deletions": 83, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/634fced396f180eea18a828bdddec3deded61ab8/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/634fced396f180eea18a828bdddec3deded61ab8/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=634fced396f180eea18a828bdddec3deded61ab8", "patch": "@@ -14,24 +14,18 @@\n //! currently always a crate name.\n \n use std::collections::BTreeMap;\n-use std::env;\n use std::path::PathBuf;\n-use std::fs::{read_dir, create_dir_all, OpenOptions, File};\n-use std::io::{Read, Write};\n+use std::fs::{remove_file, create_dir_all, File};\n+use std::io::Write;\n use std::error::Error;\n-use rustc_serialize::json::{self, as_json};\n+use rustc_serialize::json::as_json;\n \n use codemap::Span;\n use ext::base::ExtCtxt;\n use diagnostics::plugin::{ErrorMap, ErrorInfo};\n \n-pub use self::Uniqueness::*;\n-\n // Default metadata directory to use for extended error JSON.\n-const ERROR_METADATA_DIR_DEFAULT: &'static str = \"tmp/extended-errors\";\n-\n-// The name of the environment variable that sets the metadata dir.\n-const ERROR_METADATA_VAR: &'static str = \"ERROR_METADATA_DIR\";\n+const ERROR_METADATA_PREFIX: &'static str = \"tmp/extended-errors\";\n \n /// JSON encodable/decodable version of `ErrorInfo`.\n #[derive(PartialEq, RustcDecodable, RustcEncodable)]\n@@ -61,84 +55,32 @@ impl ErrorLocation {\n     }\n }\n \n-/// Type for describing the uniqueness of a set of error codes, as returned by `check_uniqueness`.\n-pub enum Uniqueness {\n-    /// All errors in the set checked are unique according to the metadata files checked.\n-    Unique,\n-    /// One or more errors in the set occur in another metadata file.\n-    /// This variant contains the first duplicate error code followed by the name\n-    /// of the metadata file where the duplicate appears.\n-    Duplicate(String, String)\n-}\n-\n-/// Get the directory where metadata files should be stored.\n-pub fn get_metadata_dir() -> PathBuf {\n-    match env::var(ERROR_METADATA_VAR) {\n-        Ok(v) => From::from(v),\n-        Err(_) => From::from(ERROR_METADATA_DIR_DEFAULT)\n-    }\n-}\n-\n-/// Get the path where error metadata for the set named by `name` should be stored.\n-fn get_metadata_path(name: &str) -> PathBuf {\n-    get_metadata_dir().join(format!(\"{}.json\", name))\n+/// Get the directory where metadata for a given `prefix` should be stored.\n+///\n+/// See `output_metadata`.\n+pub fn get_metadata_dir(prefix: &str) -> PathBuf {\n+    PathBuf::from(ERROR_METADATA_PREFIX).join(prefix)\n }\n \n-/// Check that the errors in `err_map` aren't present in any metadata files in the\n-/// metadata directory except the metadata file corresponding to `name`.\n-pub fn check_uniqueness(name: &str, err_map: &ErrorMap) -> Result<Uniqueness, Box<Error>> {\n-    let metadata_dir = get_metadata_dir();\n-    let metadata_path = get_metadata_path(name);\n-\n-    // Create the error directory if it does not exist.\n-    try!(create_dir_all(&metadata_dir));\n-\n-    // Check each file in the metadata directory.\n-    for entry in try!(read_dir(&metadata_dir)) {\n-        let path = try!(entry).path();\n-\n-        // Skip any existing file for this set.\n-        if path == metadata_path {\n-            continue;\n-        }\n-\n-        // Read the metadata file into a string.\n-        let mut metadata_str = String::new();\n-        try!(\n-            File::open(&path).and_then(|mut f|\n-            f.read_to_string(&mut metadata_str))\n-        );\n-\n-        // Parse the JSON contents.\n-        let metadata: ErrorMetadataMap = try!(json::decode(&metadata_str));\n-\n-        // Check for duplicates.\n-        for err in err_map.keys() {\n-            let err_code = err.as_str();\n-            if metadata.contains_key(err_code) {\n-                return Ok(Duplicate(\n-                    err_code.to_string(),\n-                    path.to_string_lossy().into_owned()\n-                ));\n-            }\n-        }\n-    }\n-\n-    Ok(Unique)\n+/// Map `name` to a path in the given directory: <directory>/<name>.json\n+fn get_metadata_path(directory: PathBuf, name: &str) -> PathBuf {\n+    directory.join(format!(\"{}.json\", name))\n }\n \n-/// Write metadata for the errors in `err_map` to disk, to a file corresponding to `name`.\n-pub fn output_metadata(ecx: &ExtCtxt, name: &str, err_map: &ErrorMap)\n+/// Write metadata for the errors in `err_map` to disk, to a file corresponding to `prefix/name`.\n+///\n+/// For our current purposes the prefix is the target architecture and the name is a crate name.\n+/// If an error occurs steps will be taken to ensure that no file is created.\n+pub fn output_metadata(ecx: &ExtCtxt, prefix: &str, name: &str, err_map: &ErrorMap)\n     -> Result<(), Box<Error>>\n {\n-    let metadata_path = get_metadata_path(name);\n+    // Create the directory to place the file in.\n+    let metadata_dir = get_metadata_dir(prefix);\n+    try!(create_dir_all(&metadata_dir));\n \n-    // Open the dump file.\n-    let mut dump_file = try!(OpenOptions::new()\n-        .write(true)\n-        .create(true)\n-        .open(&metadata_path)\n-    );\n+    // Open the metadata file.\n+    let metadata_path = get_metadata_path(metadata_dir, name);\n+    let mut metadata_file = try!(File::create(&metadata_path));\n \n     // Construct a serializable map.\n     let json_map = err_map.iter().map(|(k, &ErrorInfo { description, use_site })| {\n@@ -150,6 +92,10 @@ pub fn output_metadata(ecx: &ExtCtxt, name: &str, err_map: &ErrorMap)\n         (key, value)\n     }).collect::<ErrorMetadataMap>();\n \n-    try!(write!(&mut dump_file, \"{}\", as_json(&json_map)));\n-    Ok(())\n+    // Write the data to the file, deleting it if the write fails.\n+    let result = write!(&mut metadata_file, \"{}\", as_json(&json_map));\n+    if result.is_err() {\n+        try!(remove_file(&metadata_path));\n+    }\n+    Ok(try!(result))\n }"}, {"sha": "aee066807f49a5fef9f6b21071428bf599f2c990", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/634fced396f180eea18a828bdddec3deded61ab8/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/634fced396f180eea18a828bdddec3deded61ab8/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=634fced396f180eea18a828bdddec3deded61ab8", "patch": "@@ -10,6 +10,7 @@\n \n use std::cell::RefCell;\n use std::collections::BTreeMap;\n+use std::env;\n \n use ast;\n use ast::{Ident, Name, TokenTree};\n@@ -20,6 +21,8 @@ use parse::token;\n use ptr::P;\n use util::small_vector::SmallVector;\n \n+use diagnostics::metadata::output_metadata;\n+\n // Maximum width of any line in an extended error description (inclusive).\n const MAX_DESCRIPTION_WIDTH: usize = 80;\n \n@@ -154,7 +157,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                                           token_tree: &[TokenTree])\n                                           -> Box<MacResult+'cx> {\n     assert_eq!(token_tree.len(), 3);\n-    let (_crate_name, name) = match (&token_tree[0], &token_tree[2]) {\n+    let (crate_name, name) = match (&token_tree[0], &token_tree[2]) {\n         (\n             // Crate name.\n             &ast::TtToken(_, token::Ident(ref crate_name, _)),\n@@ -164,9 +167,18 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n         _ => unreachable!()\n     };\n \n-    // FIXME (#25705): we used to ensure error code uniqueness and\n-    // output error description JSON metadata here, but the approach\n-    // employed was too brittle.\n+    // Output error metadata to `tmp/extended-errors/<target arch>/<crate name>.json`\n+    let target_triple = env::var(\"CFG_COMPILER_HOST_TRIPLE\")\n+        .ok().expect(\"unable to determine target arch from $CFG_COMPILER_HOST_TRIPLE\");\n+\n+    with_registered_diagnostics(|diagnostics| {\n+        if let Err(e) = output_metadata(ecx, &target_triple, crate_name, &diagnostics) {\n+            ecx.span_bug(span, &format!(\n+                \"error writing metadata for triple `{}` and crate `{}`, error: {}, cause: {:?}\",\n+                target_triple, crate_name, e.description(), e.cause()\n+            ));\n+        }\n+    });\n \n     // Construct the output expression.\n     let (count, expr) ="}]}