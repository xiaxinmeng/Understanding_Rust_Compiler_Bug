{"sha": "2a624c2039305db18db899eaa5883e86a0e0eb9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNjI0YzIwMzkzMDVkYjE4ZGI4OTllYWE1ODgzZTg2YTBlMGViOWE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-10-05T16:43:07Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-10-07T09:15:45Z"}, "message": "Add new test to heck if all error codes have tests", "tree": {"sha": "09d54a1235a213591f6dfffb587163bb7beeec71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09d54a1235a213591f6dfffb587163bb7beeec71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a624c2039305db18db899eaa5883e86a0e0eb9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a624c2039305db18db899eaa5883e86a0e0eb9a", "html_url": "https://github.com/rust-lang/rust/commit/2a624c2039305db18db899eaa5883e86a0e0eb9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a624c2039305db18db899eaa5883e86a0e0eb9a/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ac4809ccf5f77083ae7155dcc83e921341c2614", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac4809ccf5f77083ae7155dcc83e921341c2614", "html_url": "https://github.com/rust-lang/rust/commit/4ac4809ccf5f77083ae7155dcc83e921341c2614"}], "stats": {"total": 139, "additions": 139, "deletions": 0}, "files": [{"sha": "159baff184d1be900e530cef616243c79c6d6063", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/2a624c2039305db18db899eaa5883e86a0e0eb9a/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a624c2039305db18db899eaa5883e86a0e0eb9a/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=2a624c2039305db18db899eaa5883e86a0e0eb9a", "patch": "@@ -0,0 +1,137 @@\n+//! Checks that all error codes have at least one test to prevent having error\n+//! codes that are silently not thrown by the compiler anymore.\n+\n+use std::collections::HashMap;\n+use std::ffi::OsStr;\n+use std::path::Path;\n+\n+// A few of those error codes can't be tested but all the others can and *should* be tested!\n+const WHITELIST: &[&str] = &[\n+    \"E0183\",\n+    \"E0227\",\n+    \"E0279\",\n+    \"E0280\",\n+    \"E0311\",\n+    \"E0313\",\n+    \"E0314\",\n+    \"E0315\",\n+    \"E0377\",\n+    \"E0456\",\n+    \"E0461\",\n+    \"E0462\",\n+    \"E0464\",\n+    \"E0465\",\n+    \"E0472\",\n+    \"E0473\",\n+    \"E0474\",\n+    \"E0475\",\n+    \"E0476\",\n+    \"E0479\",\n+    \"E0480\",\n+    \"E0481\",\n+    \"E0482\",\n+    \"E0483\",\n+    \"E0484\",\n+    \"E0485\",\n+    \"E0486\",\n+    \"E0487\",\n+    \"E0488\",\n+    \"E0489\",\n+    \"E0514\",\n+    \"E0519\",\n+    \"E0523\",\n+    \"E0526\",\n+    \"E0554\",\n+    \"E0570\",\n+    \"E0629\",\n+    \"E0630\",\n+    \"E0640\",\n+    \"E0717\",\n+    \"E0727\",\n+    \"E0729\",\n+];\n+\n+fn extract_error_codes(f: &str, error_codes: &mut HashMap<String, bool>) {\n+    let mut reached_no_explanation = false;\n+    let mut last_error_code = None;\n+\n+    for line in f.lines() {\n+        let s = line.trim();\n+        if s.starts_with('E') && s.ends_with(\": r##\\\"\") {\n+            if let Some(err_code) = s.splitn(2, ':').next() {\n+                let err_code = err_code.to_owned();\n+                last_error_code = Some(err_code.clone());\n+                if !error_codes.contains_key(&err_code) {\n+                    error_codes.insert(err_code, false);\n+                }\n+            }\n+        } else if s.starts_with(\"```\") && s.contains(\"compile_fail\") && s.contains('E') {\n+            if let Some(err_code) = s.splitn(2, 'E').skip(1).next() {\n+                if let Some(err_code) = err_code.splitn(2, ',').next() {\n+                    let nb = error_codes.entry(format!(\"E{}\", err_code)).or_insert(false);\n+                    *nb = true;\n+                }\n+            }\n+        } else if s == \";\" {\n+            reached_no_explanation = true;\n+        } else if reached_no_explanation && s.starts_with('E') {\n+            if let Some(err_code) = s.splitn(2, ',').next() {\n+                let err_code = err_code.to_owned();\n+                if !error_codes.contains_key(&err_code) { // this check should *never* fail!\n+                    error_codes.insert(err_code, false);\n+                }\n+            }\n+        } else if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n+            if let Some(last) = last_error_code {\n+                error_codes.get_mut(&last).map(|x| *x = true);\n+            }\n+            last_error_code = None;\n+        }\n+    }\n+}\n+\n+fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, bool>) {\n+    for line in f.lines() {\n+        let s = line.trim();\n+        if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n+            if let Some(err_code) = s.splitn(2, ']').next() {\n+                if let Some(err_code) = err_code.splitn(2, '[').skip(1).next() {\n+                    let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n+                    *nb = true;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    println!(\"Checking which error codes lack tests...\");\n+    let mut error_codes: HashMap<String, bool> = HashMap::new();\n+    super::walk(path,\n+                &mut |path| super::filter_dirs(path),\n+                &mut |entry, contents| {\n+        let file_name = entry.file_name();\n+        if file_name == \"error_codes.rs\" {\n+            extract_error_codes(contents, &mut error_codes);\n+        } else if entry.path().extension() == Some(OsStr::new(\"stderr\")) {\n+            extract_error_codes_from_tests(contents, &mut error_codes);\n+        }\n+    });\n+    println!(\"Found {} error codes\", error_codes.len());\n+\n+    let mut errors = Vec::new();\n+    for (err_code, nb) in &error_codes {\n+        if !*nb && !WHITELIST.contains(&err_code.as_str()) {\n+            errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n+        }\n+    }\n+    errors.sort();\n+    for err in &errors {\n+        eprintln!(\"{}\", err);\n+    }\n+    println!(\"Found {} error codes with no tests\", errors.len());\n+    if !errors.is_empty() {\n+        *bad = true;\n+    }\n+    println!(\"Done!\");\n+}"}, {"sha": "eb93eb297479d03e37bc7fb15babcad4fb5c294b", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a624c2039305db18db899eaa5883e86a0e0eb9a/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a624c2039305db18db899eaa5883e86a0e0eb9a/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=2a624c2039305db18db899eaa5883e86a0e0eb9a", "patch": "@@ -41,6 +41,7 @@ pub mod extdeps;\n pub mod ui_tests;\n pub mod unit_tests;\n pub mod unstable_book;\n+pub mod error_codes_check;\n \n fn filter_dirs(path: &Path) -> bool {\n     let skip = ["}, {"sha": "e08c23c01fe2d337ef332352433716d0ceab0d8d", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a624c2039305db18db899eaa5883e86a0e0eb9a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a624c2039305db18db899eaa5883e86a0e0eb9a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=2a624c2039305db18db899eaa5883e86a0e0eb9a", "patch": "@@ -35,6 +35,7 @@ fn main() {\n     deps::check_whitelist(&path, &cargo, &mut bad);\n     extdeps::check(&path, &mut bad);\n     ui_tests::check(&path, &mut bad);\n+    error_codes_check::check(&path, &mut bad);\n \n     if bad {\n         eprintln!(\"some tidy checks failed\");"}]}