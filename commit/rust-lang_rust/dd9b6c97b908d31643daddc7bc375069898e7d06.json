{"sha": "dd9b6c97b908d31643daddc7bc375069898e7d06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkOWI2Yzk3YjkwOGQzMTY0M2RhZGRjN2JjMzc1MDY5ODk4ZTdkMDY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-25T00:37:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-25T00:37:49Z"}, "message": "tutorial: Overhaul the generics section", "tree": {"sha": "4d014ddbcfea9e449a8a3be22c2cec8179de6d54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d014ddbcfea9e449a8a3be22c2cec8179de6d54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd9b6c97b908d31643daddc7bc375069898e7d06", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9b6c97b908d31643daddc7bc375069898e7d06", "html_url": "https://github.com/rust-lang/rust/commit/dd9b6c97b908d31643daddc7bc375069898e7d06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd9b6c97b908d31643daddc7bc375069898e7d06/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "546f3dbbf5832e83abcb6ceb6f6b78b61ede587b", "url": "https://api.github.com/repos/rust-lang/rust/commits/546f3dbbf5832e83abcb6ceb6f6b78b61ede587b", "html_url": "https://github.com/rust-lang/rust/commit/546f3dbbf5832e83abcb6ceb6f6b78b61ede587b"}], "stats": {"total": 305, "additions": 167, "deletions": 138}, "files": [{"sha": "d72c317c4d185cc1d5f8f9c29124c81d71929cc2", "filename": "doc/tutorial.md", "status": "modified", "additions": 167, "deletions": 138, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/dd9b6c97b908d31643daddc7bc375069898e7d06/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd9b6c97b908d31643daddc7bc375069898e7d06/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=dd9b6c97b908d31643daddc7bc375069898e7d06", "patch": "@@ -1575,52 +1575,59 @@ enum Maybe<T> {\n These declarations produce valid types like `Set<int>`, `Stack<int>`\n and `Maybe<int>`.\n \n-## Traits\n-\n-Perhaps surprisingly, the 'copy' (duplicate) operation is not defined\n-for all Rust types. Types with user-defined destructors cannot be\n-copied, and neither can types that own other types containing\n-destructors.\n+Generic functions in Rust are compiled to very efficient runtime code\n+through a process called _monomorphisation_. This big word just means\n+that, for each generic function you call, the compiler generates a\n+specialized version that is optimized specifically for the argument\n+types. In this respect Rust's generics have similar performance\n+characteristics to C++ templates.\n \n-~~~\n-// Instances of this struct can't be copied, either implicitly\n-// or with the `copy` keyword\n-struct NotCopyable {\n-    foo: int,\n-\n-    drop { }\n-}\n+## Traits\n \n-// This owned box containing a NotCopyable is also not copyable\n-let not_copyable_box = ~NotCopyable { foo: 0 };\n-~~~\n+Within a generic function the operations available on generic types\n+are very limited. After all, since the function doesn't know what\n+types it is operating on, it can't safely modify or query their\n+values. This is where _traits_ come into play. Traits are Rust's most\n+powerful tool for writing polymorphic code. Java developers will see\n+in them aspects of Java interfaces, and Haskellers will notice their\n+similarities to type classes.\n+\n+As motivation, let us consider copying in Rust. Perhaps surprisingly,\n+the copy operation is not defined for all Rust types. In\n+particular, types with user-defined destructors cannot be copied,\n+either implicitly or explicitly, and neither can types that own other\n+types containing destructors (the actual mechanism for defining\n+destructors will be discussed elsewhere).\n \n This complicates handling of generic functions. If you have a type\n parameter `T`, can you copy values of that type? In Rust, you can't,\n-unless you explicitly declare that type parameter to have the\n-_trait_ for copying, called `Copy`.\n+and if you try to run the following code the compiler will complain.\n \n-~~~~ {.ignore}\n+~~~~ {.xfail-test}\n // This does not compile\n-fn head_bad<T>(v: ~[T]) -> T {\n-    copy v[0] // Elements of type T aren't copyable\n+fn head_bad<T>(v: &[T]) -> T {\n+    v[0] // error: copying a non-copyable value\n }\n ~~~~\n \n+We can tell the compiler though that the `head` function is only for\n+copyable types with the `Copy` trait.\n+\n ~~~~\n // This does\n-fn head<T: Copy>(v: ~[T]) -> T {\n-   copy v[0]\n+fn head<T: Copy>(v: &[T]) -> T {\n+    v[0]\n }\n ~~~~\n \n-When instantiating a generic function, you can only instantiate it\n-with types that implement the correct traits. So you could not apply\n-`head` to a type with a destructor.\n+This says that we can call `head` on any type `T` as long as that type\n+implements the `Copy` trait. When instantiating a generic function,\n+you can only instantiate it with types that implement the correct\n+trait, so you could not apply `head` to a type with a destructor.\n \n While most traits can be defined and implemented by user code, three\n-traits are derived for all applicable types by the compiler, and may\n-not be overridden:\n+traits are automatically derived and implemented for all applicable\n+types by the compiler, and may not be overridden:\n \n * `Copy` - Types that can be copied, either implicitly, or using the\n   `copy` expression. All types are copyable unless they are classes\n@@ -1636,92 +1643,55 @@ not be overridden:\n > ***Note:*** These three traits were referred to as 'kinds' in earlier\n > iterations of the language, and often still are.\n \n-Traits are Rust's take on value polymorphism\u2014the thing that\n-object-oriented languages tend to solve with methods and inheritance.\n-For example, writing a function that can operate on multiple types of\n-collections.\n-\n ## Declaring and implementing traits\n \n A trait consists of a set of methods, or may be empty, as is the case\n with `Copy`, `Send`, and `Const`. A method is a function that\n can be applied to a `self` value and a number of arguments, using the\n dot notation: `self.foo(arg1, arg2)`.\n \n-For example, we could declare the trait `Stringable` for things that\n-can be converted to a string, with a single method:\n+For example, we could declare the trait `Printable` for things that\n+can be printed to the console, with a single method:\n \n ~~~~\n-trait ToStr {\n-    fn to_str(self) -> ~str;\n+trait Printable {\n+    fn print();\n }\n ~~~~\n \n-To actually implement a trait for a given type, the `impl` form\n-is used. This defines implementations of `ToStr` for the `int` and\n+To actually implement a trait for a given type, the `impl` form is\n+used. This defines implementations of `Printable` for the `int` and\n `~str` types.\n \n ~~~~\n-# // FIXME: This example is no good because you can't actually\n-# // implement your own .to_str for int and ~str\n-# trait ToStr { fn to_str(self) -> ~str; }\n-impl int: ToStr {\n-    fn to_str(self) -> ~str { int::to_str(self, 10u) }\n+# trait Printable { fn print(); }\n+impl int: Printable {\n+    fn print() { io::println(fmt!(\"%d\", self)) }\n }\n-impl ~str: ToStr {\n-    fn to_str(self) -> ~str { self }\n+\n+impl ~str: Printable {\n+    fn print() { io::println(self) }\n }\n \n-# //1.to_str();\n-# //(~\"foo\").to_str();\n+# 1.print();\n+# (~\"foo\").print();\n ~~~~\n \n-Given these, we may call `1.to_str()` to get `\"1\"`, or\n-`(~\"foo\").to_str()` to get `\"foo\"` again. This is basically a form of\n-static overloading\u2014when the Rust compiler sees the `to_str` method\n+Given these, we may call `1.to_str()` to print `\"1\"`, or\n+`(~\"foo\").to_str()` to print `\"foo\"` again. This is basically a form of\n+static overloading\u2014when the Rust compiler sees the `print` method\n call, it looks for an implementation that matches the type with a\n method that matches the name, and simply calls that.\n \n-## Bounded type parameters\n-\n-The useful thing about value polymorphism is that it does not have to\n-be static. If object-oriented languages only let you call a method on\n-an object when they knew exactly which sub-type it had, that would not\n-get you very far. To be able to call methods on types that aren't\n-known at compile time, it is possible to specify 'bounds' for type\n-parameters.\n-\n-~~~~\n-# trait ToStr { fn to_str() -> ~str; }\n-fn comma_sep<T: ToStr>(elts: ~[T]) -> ~str {\n-    let mut result = ~\"\", first = true;\n-    for elts.each |elt| {\n-        if first { first = false; }\n-        else { result += ~\", \"; }\n-        result += elt.to_str();\n-    }\n-    return result;\n-}\n-~~~~\n-\n-The syntax for this is similar to the syntax for specifying that a\n-parameter type has to be copyable (which is, in principle, another\n-kind of bound). By declaring `T` as conforming to the `to_str`\n-trait, it becomes possible to call methods from that trait on\n-values of that type inside the function. It will also cause a\n-compile-time error when anyone tries to call `comma_sep` on an array\n-whose element type does not have a `to_str` implementation in scope.\n-\n-## Polymorphic traits\n-\n-Traits may contain type parameters. A trait for\n-generalized sequence types is:\n+Traits may themselves contain type parameters. A trait for\n+generalized sequence types might look like the following:\n \n ~~~~\n trait Seq<T> {\n     fn len() -> uint;\n     fn iter(b: fn(v: &T));\n }\n+\n impl<T> ~[T]: Seq<T> {\n     fn len() -> uint { vec::len(self) }\n     fn iter(b: fn(v: &T)) {\n@@ -1730,107 +1700,166 @@ impl<T> ~[T]: Seq<T> {\n }\n ~~~~\n \n-The implementation has to explicitly declare the type\n-parameter that it binds, `T`, before using it to specify its trait type. Rust requires this declaration because the `impl` could also, for example, specify an implementation of `seq<int>`. The trait type -- appearing after the colon in the `impl` -- *refers* to a type, rather than defining one.\n+The implementation has to explicitly declare the type parameter that\n+it binds, `T`, before using it to specify its trait type. Rust\n+requires this declaration because the `impl` could also, for example,\n+specify an implementation of `Seq<int>`. The trait type -- appearing\n+after the colon in the `impl` -- *refers* to a type, rather than\n+defining one.\n \n The type parameters bound by a trait are in scope in each of the\n method declarations. So, re-declaring the type parameter\n `T` as an explicit type parameter for `len` -- in either the trait or\n the impl -- would be a compile-time error.\n \n-## The `self` type in traits\n+## Bounded type parameters and static method dispatch\n \n-In a trait, `self` is a special type that you can think of as a\n-type parameter. An implementation of the trait for any given type\n-`T` replaces the `self` type parameter with `T`. The following\n-trait describes types that support an equality operation:\n+Traits give us a language for talking about the abstract capabilities\n+of types, and we can use this to place _bounds_ on type parameters,\n+so that we can then operate on generic types.\n \n ~~~~\n-trait Eq {\n-  fn equals(&&other: self) -> bool;\n+# trait Printable { fn print(); }\n+fn print_all<T: Printable>(printable_things: ~[T]) {\n+    for printable_things.each |thing| {\n+        thing.print();\n+    }\n }\n+~~~~\n \n-impl int: Eq {\n-  fn equals(&&other: int) -> bool { other == self }\n+By declaring `T` as conforming to the `Printable` trait (as we earlier\n+did with `Copy`), it becomes possible to call methods from that trait\n+on values of that type inside the function. It will also cause a\n+compile-time error when anyone tries to call `print_all` on an array\n+whose element type does not have a `Printable` implementation.\n+\n+Type parameters can have multiple bounds by separating them with spaces,\n+as in this version of `print_all` that makes copies of elements.\n+\n+~~~\n+# trait Printable { fn print(); }\n+fn print_all<T: Printable Copy>(printable_things: ~[T]) {\n+    let mut i = 0;\n+    while i < printable_things.len() {\n+        let copy_of_thing = printable_things[0];\n+        copy_of_thing.print();\n+    }\n }\n-~~~~\n+~~~\n \n-Notice that `equals` takes an `int` argument, rather than a `self` argument, in\n-an implementation for type `int`.\n+Method calls to bounded type parameters are _statically dispatched_,\n+imposing no more overhead than normal function invocation, so are\n+the preferred way to use traits polymorphically.\n \n-## Casting to a trait type\n+This usage of traits is similar to Haskell type classes.\n+\n+## Casting to a trait type and dynamic dispatch\n \n The above allows us to define functions that polymorphically act on\n-values of *an* unknown type that conforms to a given trait.\n+values of a single unknown type that conforms to a given trait.\n However, consider this function:\n \n ~~~~\n # type Circle = int; type Rectangle = int;\n-# trait Drawable { fn draw(); }\n # impl int: Drawable { fn draw() {} }\n # fn new_circle() -> int { 1 }\n+\n+trait Drawable { fn draw(); }\n+\n fn draw_all<T: Drawable>(shapes: ~[T]) {\n     for shapes.each |shape| { shape.draw(); }\n }\n+\n # let c: Circle = new_circle();\n # draw_all(~[c]);\n ~~~~\n \n You can call that on an array of circles, or an array of squares\n-(assuming those have suitable `drawable` traits defined), but not\n-on an array containing both circles and squares.\n-\n-When this is needed, a trait name can be used as a type, causing\n-the function to be written simply like this:\n+(assuming those have suitable `Drawable` traits defined), but not on\n+an array containing both circles and squares. When such behavior is\n+needed, a trait name can alternately be used as a type.\n \n ~~~~\n # trait Drawable { fn draw(); }\n-fn draw_all(shapes: ~[Drawable]) {\n+fn draw_all(shapes: ~[@Drawable]) {\n     for shapes.each |shape| { shape.draw(); }\n }\n ~~~~\n \n-There is no type parameter anymore (since there isn't a single type\n-that we're calling the function on). Instead, the `drawable` type is\n-used to refer to a type that is a reference-counted box containing a\n-value for which a `drawable` implementation exists, combined with\n-information on where to find the methods for this implementation. This\n-is very similar to the 'vtables' used in most object-oriented\n-languages.\n+In this example there is no type parameter. Instead, the `@Drawable`\n+type is used to refer to any managed box value that implements the\n+`Drawable` trait. To construct such a value, you use the `as` operator\n+to cast a value to a trait type:\n \n-To construct such a value, you use the `as` operator to cast a value\n-to a trait type:\n+~~~~\n+# type Circle = int; type Rectangle = bool;\n+# trait Drawable { fn draw(); }\n+# fn new_circle() -> Circle { 1 }\n+# fn new_rectangle() -> Rectangle { true }\n+# fn draw_all(shapes: ~[Drawable]) {}\n+\n+impl @Circle: Drawable { fn draw() { ... } }\n \n+impl @Rectangle: Drawable { fn draw() { ... } }\n+\n+let c: @Circle = @new_circle();\n+let r: @Rectangle = @new_rectangle();\n+draw_all(~[c as @Drawable, r as @Drawable]);\n ~~~~\n+\n+Note that, like strings and vectors, trait types have dynamic size\n+and may only be used via one of the pointer types. In turn, the\n+`impl` is defined for `@Circle` and `@Rectangle` instead of for\n+just `Circle` and `Rectangle`. Other pointer types work as well.\n+\n+~~~{.xfail-test}\n # type Circle = int; type Rectangle = int;\n # trait Drawable { fn draw(); }\n # impl int: Drawable { fn draw() {} }\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n-# fn draw_all(shapes: ~[Drawable]) {}\n-let c: Circle = new_circle();\n-let r: Rectangle = new_rectangle();\n-draw_all(~[c as Drawable, r as Drawable]);\n-~~~~\n+// A managed trait instance\n+let boxy: @Drawable = @new_circle() as @Drawable;\n+// An owned trait instance\n+let owny: ~Drawable = ~new_circle() as ~Drawable;\n+// A borrowed trait instance\n+let stacky: &Drawable = &new_circle() as &Drawable;\n+~~~\n+\n+> ***Note:*** Other pointer types actually _do not_ work here. This is\n+> an evolving corner of the language.\n \n-This will store the value into a box, along with information about the\n-implementation (which is looked up in the scope of the cast). The\n-`drawable` type simply refers to such boxes, and calling methods on it\n-always works, no matter what implementations are in scope.\n+Method calls to trait types are _dynamically dispatched_. Since the\n+compiler doesn't know specifically which functions to call at compile\n+time it uses a lookup table (vtable) to decide at runtime which\n+method to call.\n \n-Note that the allocation of a box is somewhat more expensive than\n-simply using a type parameter and passing in the value as-is, and much\n-more expensive than statically resolved method calls.\n+This usage of traits is similar to Java interfaces.\n \n-## Trait-less implementations\n+## The `self` type\n+\n+In a trait, `self` is a special type that you can think of as a\n+type parameter. An implementation of the trait for any given type\n+`T` replaces the `self` type parameter with `T`. Simply, in a trait,\n+`self` is a type, and in an impl, `self` is a value. The following\n+trait describes types that support an equality operation:\n+\n+~~~~\n+// In a trait, `self` refers to the type implementing the trait\n+trait Eq {\n+  fn equals(&&other: self) -> bool;\n+}\n+\n+// In an impl, self refers to the value of the receiver\n+impl int: Eq {\n+  fn equals(&&other: int) -> bool { other == self }\n+}\n+~~~~\n \n-If you only intend to use an implementation for static overloading,\n-and there is no trait available that it conforms to, you are free\n-to leave off the type after the colon.  However, this is only possible when you\n-are defining an implementation in the same module as the receiver\n-type, and the receiver type is a named type (i.e., an enum or a\n-class); [single-variant enums](#single_variant_enum) are a common\n-choice.\n+Notice that in the trait definition, `equals` takes a `self` type\n+argument, whereas, in the impl, `equals` takes an `int` type argument,\n+and uses `self` as the name of the receiver (analogous to the `this` pointer\n+in C++).\n \n # Modules and crates\n "}]}