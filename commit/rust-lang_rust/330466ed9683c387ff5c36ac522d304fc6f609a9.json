{"sha": "330466ed9683c387ff5c36ac522d304fc6f609a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMDQ2NmVkOTY4M2MzODdmZjVjMzZhYzUyMmQzMDRmYzZmNjA5YTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:55:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:55:41Z"}, "message": "rollup merge of #24273: steveklabnik/even_moar_editing\n\nThree more sections", "tree": {"sha": "9f678f7be3203e38b5b4aa89fca4f287383ec5c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f678f7be3203e38b5b4aa89fca4f287383ec5c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/330466ed9683c387ff5c36ac522d304fc6f609a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/330466ed9683c387ff5c36ac522d304fc6f609a9", "html_url": "https://github.com/rust-lang/rust/commit/330466ed9683c387ff5c36ac522d304fc6f609a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/330466ed9683c387ff5c36ac522d304fc6f609a9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb956dc5261aa96e6d22fd0d0909ae420b3619fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb956dc5261aa96e6d22fd0d0909ae420b3619fc", "html_url": "https://github.com/rust-lang/rust/commit/fb956dc5261aa96e6d22fd0d0909ae420b3619fc"}, {"sha": "6476a1e37844f6d1cd63914df616ae577fa6fc64", "url": "https://api.github.com/repos/rust-lang/rust/commits/6476a1e37844f6d1cd63914df616ae577fa6fc64", "html_url": "https://github.com/rust-lang/rust/commit/6476a1e37844f6d1cd63914df616ae577fa6fc64"}], "stats": {"total": 224, "additions": 148, "deletions": 76}, "files": [{"sha": "fa27d1c226cc494cdf06bc9ce24b2a71d7d1d3fc", "filename": "src/doc/trpl/comments.md", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/330466ed9683c387ff5c36ac522d304fc6f609a9/src%2Fdoc%2Ftrpl%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/330466ed9683c387ff5c36ac522d304fc6f609a9/src%2Fdoc%2Ftrpl%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcomments.md?ref=330466ed9683c387ff5c36ac522d304fc6f609a9", "patch": "@@ -1,47 +1,45 @@\n % Comments\n \n-Now that we have some functions, it's a good idea to learn about comments.\n+Now that we have some functions, it\u2019s a good idea to learn about comments.\n Comments are notes that you leave to other programmers to help explain things\n about your code. The compiler mostly ignores them.\n \n Rust has two kinds of comments that you should care about: *line comments*\n and *doc comments*.\n \n-```{rust}\n-// Line comments are anything after '//' and extend to the end of the line.\n+```rust\n+// Line comments are anything after \u2018//\u2019 and extend to the end of the line.\n \n let x = 5; // this is also a line comment.\n \n // If you have a long explanation for something, you can put line comments next\n-// to each other. Put a space between the // and your comment so that it's\n+// to each other. Put a space between the // and your comment so that it\u2019s\n // more readable.\n ```\n \n The other kind of comment is a doc comment. Doc comments use `///` instead of\n `//`, and support Markdown notation inside:\n \n-```{rust}\n-/// `hello` is a function that prints a greeting that is personalized based on\n-/// the name given.\n-///\n-/// # Arguments\n-///\n-/// * `name` - The name of the person you'd like to greet.\n+```rust\n+/// Adds one to the number given.\n ///\n /// # Examples\n ///\n-/// ```rust\n-/// let name = \"Steve\";\n-/// hello(name); // prints \"Hello, Steve!\"\n /// ```\n-fn hello(name: &str) {\n-    println!(\"Hello, {}!\", name);\n+/// let five = 5;\n+///\n+/// assert_eq!(6, add_one(5));\n+/// ```\n+fn add_one(x: i32) -> i32 {\n+    x + 1\n }\n ```\n \n-When writing doc comments, adding sections for any arguments, return values,\n-and providing some examples of usage is very, very helpful. Don't worry about\n-the `&str`, we'll get to it soon.\n+When writing doc comments, providing some examples of usage is very, very\n+helpful. You\u2019ll notice we\u2019ve used a new macro here: `assert_eq!`. This compares\n+two values, and `panic!`s if they\u2019re not equal to each other. It\u2019s very helpful\n+in documentation. There\u2019s another macro, `assert!`, which `panic!`s if the\n+value passed to it is `false`.\n \n You can use the [`rustdoc`](documentation.html) tool to generate HTML documentation\n-from these doc comments.\n+from these doc comments, and also to run the code examples as tests!"}, {"sha": "87af48532a050dd35a736ebe2fbfb8fc5cd754cf", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 85, "deletions": 51, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/330466ed9683c387ff5c36ac522d304fc6f609a9/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/330466ed9683c387ff5c36ac522d304fc6f609a9/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=330466ed9683c387ff5c36ac522d304fc6f609a9", "patch": "@@ -1,31 +1,31 @@\n % Functions\n \n-You've already seen one function so far, the `main` function:\n+Every Rust program has at least one function, the `main` function:\n \n ```rust\n fn main() {\n }\n ```\n \n This is the simplest possible function declaration. As we mentioned before,\n-`fn` says \"this is a function,\" followed by the name, some parentheses because\n+`fn` says \u2018this is a function\u2019, followed by the name, some parentheses because\n this function takes no arguments, and then some curly braces to indicate the\n-body. Here's a function named `foo`:\n+body. Here\u2019s a function named `foo`:\n \n ```rust\n fn foo() {\n }\n ```\n \n-So, what about taking arguments? Here's a function that prints a number:\n+So, what about taking arguments? Here\u2019s a function that prints a number:\n \n ```rust\n fn print_number(x: i32) {\n     println!(\"x is: {}\", x);\n }\n ```\n \n-Here's a complete program that uses `print_number`:\n+Here\u2019s a complete program that uses `print_number`:\n \n ```rust\n fn main() {\n@@ -40,7 +40,7 @@ fn print_number(x: i32) {\n As you can see, function arguments work very similar to `let` declarations:\n you add a type to the argument name, after a colon.\n \n-Here's a complete program that adds two numbers together and prints them:\n+Here\u2019s a complete program that adds two numbers together and prints them:\n \n ```rust\n fn main() {\n@@ -58,7 +58,7 @@ as when you declare it.\n Unlike `let`, you _must_ declare the types of function arguments. This does\n not work:\n \n-```{rust,ignore}\n+```rust,ignore\n fn print_sum(x, y) {\n     println!(\"sum is: {}\", x + y);\n }\n@@ -67,8 +67,8 @@ fn print_sum(x, y) {\n You get this error:\n \n ```text\n-hello.rs:5:18: 5:19 expected one of `!`, `:`, or `@`, found `)`\n-hello.rs:5 fn print_number(x, y) {\n+expected one of `!`, `:`, or `@`, found `)`\n+fn print_number(x, y) {\n ```\n \n This is a deliberate design decision. While full-program inference is possible,\n@@ -77,7 +77,7 @@ types explicitly is a best-practice. We agree that forcing functions to declare\n types while allowing for inference inside of function bodies is a wonderful\n sweet spot between full inference and no inference.\n \n-What about returning a value? Here's a function that adds one to an integer:\n+What about returning a value? Here\u2019s a function that adds one to an integer:\n \n ```rust\n fn add_one(x: i32) -> i32 {\n@@ -86,11 +86,11 @@ fn add_one(x: i32) -> i32 {\n ```\n \n Rust functions return exactly one value, and you declare the type after an\n-\"arrow,\" which is a dash (`-`) followed by a greater-than sign (`>`).\n+\u2018arrow\u2019, which is a dash (`-`) followed by a greater-than sign (`>`). The last\n+line of a function determines what it returns. You\u2019ll note the lack of a\n+semicolon here. If we added it in:\n \n-You'll note the lack of a semicolon here. If we added it in:\n-\n-```{rust,ignore}\n+```rust,ignore\n fn add_one(x: i32) -> i32 {\n     x + 1;\n }\n@@ -109,60 +109,99 @@ help: consider removing this semicolon:\n           ^\n ```\n \n-Remember our earlier discussions about semicolons and `()`? Our function claims\n-to return an `i32`, but with a semicolon, it would return `()` instead. Rust\n-realizes this probably isn't what we want, and suggests removing the semicolon.\n+This reveals two interesting things about Rust: it is an expression-based\n+language, and semicolons are different from semicolons in other \u2018curly brace\n+and semicolon\u2019-based languages. These two things are related.\n \n-This is very much like our `if` statement before: the result of the block\n-(`{}`) is the value of the expression. Other expression-oriented languages,\n-such as Ruby, work like this, but it's a bit unusual in the systems programming\n-world. When people first learn about this, they usually assume that it\n-introduces bugs. But because Rust's type system is so strong, and because unit\n-is its own unique type, we have never seen an issue where adding or removing a\n-semicolon in a return position would cause a bug.\n+## Expressions vs. Statements\n \n-But what about early returns? Rust does have a keyword for that, `return`:\n+Rust is primarily an expression-based language. There are only two kinds of\n+statements, and everything else is an expression.\n \n-```rust\n-fn foo(x: i32) -> i32 {\n-    if x < 5 { return x; }\n+So what's the difference? Expressions return a value, and statements do not.\n+That\u2019s why we end up with \u2018not all control paths return a value\u2019 here: the\n+statement `x + 1;` doesn\u2019t return a value. There are two kinds of statements in\n+Rust: \u2018declaration statements\u2019 and \u2018expression statements\u2019. Everything else is\n+an expression. Let\u2019s talk about declaration statements first.\n+\n+In some languages, variable bindings can be written as expressions, not just\n+statements. Like Ruby:\n+\n+```ruby\n+x = y = 5\n+```\n+\n+In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n+following will produce a compile-time error:\n+\n+```ignore\n+let x = (let y = 5); // expected identifier, found keyword `let`\n+```\n+\n+The compiler is telling us here that it was expecting to see the beginning of\n+an expression, and a `let` can only begin a statement, not an expression.\n+\n+Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n+expression, although its value is not particularly useful. Unlike other\n+languages where an assignment evaluates to the assigned value (e.g. `5` in the\n+previous example), in Rust the value of an assignment is an empty tuple `()`:\n+\n+```\n+let mut y = 5;\n+\n+let x = (y = 6);  // x has the value `()`, not `6`\n+```\n+\n+The second kind of statement in Rust is the *expression statement*. Its\n+purpose is to turn any expression into a statement. In practical terms, Rust's\n+grammar expects statements to follow other statements. This means that you use\n+semicolons to separate expressions from each other. This means that Rust\n+looks a lot like most other languages that require you to use semicolons\n+at the end of every line, and you will see semicolons at the end of almost\n+every line of Rust code you see.\n \n+What is this exception that makes us say \"almost\"? You saw it already, in this\n+code:\n+\n+```rust\n+fn add_one(x: i32) -> i32 {\n     x + 1\n }\n ```\n \n-Using a `return` as the last line of a function works, but is considered poor\n-style:\n+Our function claims to return an `i32`, but with a semicolon, it would return\n+`()` instead. Rust realizes this probably isn\u2019t what we want, and suggests\n+removing the semicolon in the error we saw before.\n+\n+## Early returns\n+\n+But what about early returns? Rust does have a keyword for that, `return`:\n \n ```rust\n fn foo(x: i32) -> i32 {\n-    if x < 5 { return x; }\n+    return x;\n \n-    return x + 1;\n+    // we never run this code!\n+    x + 1\n }\n ```\n \n-The previous definition without `return` may look a bit strange if you haven't\n-worked in an expression-based language before, but it becomes intuitive over\n-time. If this were production code, we wouldn't write it in that way anyway,\n-we'd write this:\n+Using a `return` as the last line of a function works, but is considered poor\n+style:\n \n ```rust\n fn foo(x: i32) -> i32 {\n-    if x < 5 {\n-        x\n-    } else {\n-        x + 1\n-    }\n+    return x + 1;\n }\n ```\n \n-Because `if` is an expression, and it's the only expression in this function,\n-the value will be the result of the `if`.\n+The previous definition without `return` may look a bit strange if you haven\u2019t\n+worked in an expression-based language before, but it becomes intuitive over\n+time.\n \n ## Diverging functions\n \n-Rust has some special syntax for 'diverging functions', which are functions that\n+Rust has some special syntax for \u2018diverging functions\u2019, which are functions that\n do not return:\n \n ```\n@@ -171,23 +210,18 @@ fn diverges() -> ! {\n }\n ```\n \n-`panic!` is a macro, similar to `println!()` that we've already seen. Unlike\n+`panic!` is a macro, similar to `println!()` that we\u2019ve already seen. Unlike\n `println!()`, `panic!()` causes the current thread of execution to crash with\n the given message.\n \n Because this function will cause a crash, it will never return, and so it has\n-the type '`!`', which is read \"diverges.\" A diverging function can be used\n+the type \u2018`!`\u2019, which is read \u2018diverges\u2019. A diverging function can be used\n as any type:\n \n ```should_panic\n # fn diverges() -> ! {\n #    panic!(\"This function never returns!\");\n # }\n-\n let x: i32 = diverges();\n let x: String = diverges();\n ```\n-\n-We don't have a good use for diverging functions yet, because they're used in\n-conjunction with other Rust features. But when you see `-> !` later, you'll\n-know what it's called."}, {"sha": "83d5a15bc2c0a831137e6233df6140e2f2827ba0", "filename": "src/doc/trpl/structs.md", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/330466ed9683c387ff5c36ac522d304fc6f609a9/src%2Fdoc%2Ftrpl%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/330466ed9683c387ff5c36ac522d304fc6f609a9/src%2Fdoc%2Ftrpl%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstructs.md?ref=330466ed9683c387ff5c36ac522d304fc6f609a9", "patch": "@@ -1,8 +1,15 @@\n % Structs\n \n-A struct is another form of a *record type*, just like a tuple. There's a\n-difference: structs give each element that they contain a name, called a\n-*field* or a *member*. Check it out:\n+Structs are a way of creating more complex datatypes. For example, if we were\n+doing calculations involving coordinates in 2D space, we would need both an `x`\n+and a `y` value:\n+\n+```rust\n+let origin_x = 0;\n+let origin_y = 0;\n+```\n+\n+A struct lets us combine these two into a single, unified datatype:\n \n ```rust\n struct Point {\n@@ -17,7 +24,7 @@ fn main() {\n }\n ```\n \n-There's a lot going on here, so let's break it down. We declare a struct with\n+There\u2019s a lot going on here, so let\u2019s break it down. We declare a struct with\n the `struct` keyword, and then with a name. By convention, structs begin with a\n capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.\n \n@@ -31,7 +38,7 @@ notation: `origin.x`.\n The values in structs are immutable by default, like other bindings in Rust.\n Use `mut` to make them mutable:\n \n-```{rust}\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -47,3 +54,36 @@ fn main() {\n ```\n \n This will print `The point is at (5, 0)`.\n+\n+Rust does not support field mutability at the language level, so you cannot\n+write something like this:\n+\n+```rust,ignore\n+struct Point {\n+    mut x: i32,\n+    y: i32,\n+}\n+```\n+\n+Mutability is a property of the binding, not of the structure itself. If you\u2019re\n+used to field-level mutability, this may seem strange at first, but it\n+significantly simplifies things. It even lets you make things mutable for a short\n+time only:\n+\n+\n+```rust,ignore\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut point = Point { x: 0, y: 0 };\n+\n+    point.x = 5;\n+\n+    let point = point; // this new binding can\u2019t change now\n+\n+    point.y = 6; // this causes an error\n+}\n+```"}]}