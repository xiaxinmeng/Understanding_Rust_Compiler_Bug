{"sha": "6af1015f74ee8395ea7fe8339d8748089f05e3e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZjEwMTVmNzRlZTgzOTVlYTdmZTgzMzlkODc0ODA4OWYwNWUzZTQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-04-04T08:07:22Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-04-09T04:22:45Z"}, "message": "Add rustc_server (ra_tt rustc bridge)", "tree": {"sha": "7ac7295e2ea65327ada7dcba23b2d06ca27a6b73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ac7295e2ea65327ada7dcba23b2d06ca27a6b73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6af1015f74ee8395ea7fe8339d8748089f05e3e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6af1015f74ee8395ea7fe8339d8748089f05e3e4", "html_url": "https://github.com/rust-lang/rust/commit/6af1015f74ee8395ea7fe8339d8748089f05e3e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6af1015f74ee8395ea7fe8339d8748089f05e3e4/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "080c983498afcac3eb54028af5c9f8bfe7f2c826", "url": "https://api.github.com/repos/rust-lang/rust/commits/080c983498afcac3eb54028af5c9f8bfe7f2c826", "html_url": "https://github.com/rust-lang/rust/commit/080c983498afcac3eb54028af5c9f8bfe7f2c826"}], "stats": {"total": 692, "additions": 691, "deletions": 1}, "files": [{"sha": "34f05e83a3329d0a4eb25f11b89cd236f15d938d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6af1015f74ee8395ea7fe8339d8748089f05e3e4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6af1015f74ee8395ea7fe8339d8748089f05e3e4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6af1015f74ee8395ea7fe8339d8748089f05e3e4", "patch": "@@ -1081,6 +1081,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata\",\n  \"difference\",\n+ \"ra_mbe\",\n  \"ra_proc_macro\",\n  \"ra_tt\",\n  \"serde_derive\","}, {"sha": "f08de5fc771a38f2f528980d4f825d8e304fcec6", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af1015f74ee8395ea7fe8339d8748089f05e3e4/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6af1015f74ee8395ea7fe8339d8748089f05e3e4/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=6af1015f74ee8395ea7fe8339d8748089f05e3e4", "patch": "@@ -10,9 +10,9 @@ doctest = false\n \n [dependencies]\n ra_tt = { path = \"../ra_tt\" }\n+ra_mbe = { path = \"../ra_mbe\" }\n ra_proc_macro = { path = \"../ra_proc_macro\" }\n \n-\n [dev-dependencies]\n cargo_metadata = \"0.9.1\"\n difference = \"2.0.0\""}, {"sha": "f376df2367f39672c4a8f85095d2427d2b392701", "filename": "crates/ra_proc_macro_srv/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6af1015f74ee8395ea7fe8339d8748089f05e3e4/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af1015f74ee8395ea7fe8339d8748089f05e3e4/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs?ref=6af1015f74ee8395ea7fe8339d8748089f05e3e4", "patch": "@@ -14,6 +14,9 @@\n #[doc(hidden)]\n mod proc_macro;\n \n+#[doc(hidden)]\n+mod rustc_server;\n+\n use proc_macro::bridge::client::TokenStream;\n use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n "}, {"sha": "76e6a2752ab1e05c4554546ee8cfa59a19b8a5b8", "filename": "crates/ra_proc_macro_srv/src/rustc_server.rs", "status": "added", "additions": 686, "deletions": 0, "changes": 686, "blob_url": "https://github.com/rust-lang/rust/blob/6af1015f74ee8395ea7fe8339d8748089f05e3e4/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af1015f74ee8395ea7fe8339d8748089f05e3e4/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs?ref=6af1015f74ee8395ea7fe8339d8748089f05e3e4", "patch": "@@ -0,0 +1,686 @@\n+//! Rustc proc-macro server implementation with ra_tt\n+//!\n+//! Based on idea from https://github.com/fedochet/rust-proc-macro-expander\n+//! The lib-proc-macro server backend is `TokenStream`-agnostic, such that\n+//! we could provide any TokenStream implementation.\n+//! The original idea from fedochet is using proc-macro2 as backend,\n+//! we use ra_tt instead for better intergation with RA.\n+//!\n+//! FIXME: No span and source file informatin is implemented yet\n+\n+use crate::proc_macro::bridge::{self, server};\n+use ra_tt as tt;\n+\n+use std::collections::{Bound, HashMap};\n+use std::hash::Hash;\n+use std::iter::FromIterator;\n+use std::str::FromStr;\n+use std::{ascii, vec::IntoIter};\n+\n+type Group = tt::Subtree;\n+type TokenTree = tt::TokenTree;\n+type Punct = tt::Punct;\n+type Spacing = tt::Spacing;\n+type Literal = tt::Literal;\n+type Span = tt::TokenId;\n+\n+#[derive(Debug, Clone)]\n+pub struct TokenStream {\n+    pub subtree: tt::Subtree,\n+}\n+\n+impl TokenStream {\n+    pub fn new() -> Self {\n+        TokenStream { subtree: Default::default() }\n+    }\n+    pub fn with_subtree(subtree: tt::Subtree) -> Self {\n+        TokenStream { subtree }\n+    }\n+    pub fn is_empty(&self) -> bool {\n+        self.subtree.token_trees.is_empty()\n+    }\n+}\n+\n+/// Creates a token stream containing a single token tree.\n+impl From<TokenTree> for TokenStream {\n+    fn from(tree: TokenTree) -> TokenStream {\n+        TokenStream { subtree: tt::Subtree { delimiter: None, token_trees: vec![tree] } }\n+    }\n+}\n+\n+/// Collects a number of token trees into a single stream.\n+impl FromIterator<TokenTree> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n+        trees.into_iter().map(TokenStream::from).collect()\n+    }\n+}\n+\n+/// A \"flattening\" operation on token streams, collects token trees\n+/// from multiple token streams into a single stream.\n+impl FromIterator<TokenStream> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n+        let mut builder = TokenStreamBuilder::new();\n+        streams.into_iter().for_each(|stream| builder.push(stream));\n+        builder.build()\n+    }\n+}\n+\n+impl Extend<TokenTree> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n+        self.extend(trees.into_iter().map(TokenStream::from));\n+    }\n+}\n+\n+impl Extend<TokenStream> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n+        for item in streams {\n+            self.subtree.token_trees.extend(&mut item.into_iter())\n+        }\n+    }\n+}\n+\n+type Level = crate::proc_macro::Level;\n+type LineColumn = crate::proc_macro::LineColumn;\n+type SourceFile = crate::proc_macro::SourceFile;\n+\n+/// A structure representing a diagnostic message and associated children\n+/// messages.\n+#[derive(Clone, Debug)]\n+pub struct Diagnostic {\n+    level: Level,\n+    message: String,\n+    spans: Vec<Span>,\n+    children: Vec<Diagnostic>,\n+}\n+\n+impl Diagnostic {\n+    /// Creates a new diagnostic with the given `level` and `message`.\n+    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n+        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n+    }\n+}\n+\n+// Rustc Server Ident has to be `Copyable`\n+// We use a stub here for bypassing\n+#[derive(Hash, Eq, PartialEq, Copy, Clone)]\n+pub struct IdentId(u32);\n+\n+#[derive(Clone, Hash, Eq, PartialEq)]\n+struct IdentData(tt::Ident);\n+\n+#[derive(Default)]\n+struct IdentInterner {\n+    idents: HashMap<IdentData, u32>,\n+    ident_data: Vec<IdentData>,\n+}\n+\n+impl IdentInterner {\n+    fn intern(&mut self, data: &IdentData) -> u32 {\n+        if let Some(index) = self.idents.get(data) {\n+            return *index;\n+        }\n+\n+        let index = self.idents.len() as u32;\n+        self.ident_data.push(data.clone());\n+        self.idents.insert(data.clone(), index);\n+        index\n+    }\n+\n+    fn get(&self, index: u32) -> &IdentData {\n+        &self.ident_data[index as usize]\n+    }\n+\n+    #[allow(unused)]\n+    fn get_mut(&mut self, index: u32) -> &mut IdentData {\n+        self.ident_data.get_mut(index as usize).expect(\"Should be consistent\")\n+    }\n+}\n+\n+pub struct TokenStreamBuilder {\n+    acc: TokenStream,\n+}\n+\n+/// Public implementation details for the `TokenStream` type, such as iterators.\n+pub mod token_stream {\n+    use super::{tt, TokenStream, TokenTree};\n+    use std::str::FromStr;\n+\n+    /// An iterator over `TokenStream`'s `TokenTree`s.\n+    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n+    /// and returns whole groups as token trees.\n+    impl IntoIterator for TokenStream {\n+        type Item = TokenTree;\n+        type IntoIter = super::IntoIter<TokenTree>;\n+\n+        fn into_iter(self) -> Self::IntoIter {\n+            self.subtree.token_trees.into_iter()\n+        }\n+    }\n+\n+    type LexError = String;\n+\n+    /// Attempts to break the string into tokens and parse those tokens into a token stream.\n+    /// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n+    /// or characters not existing in the language.\n+    /// All tokens in the parsed stream get `Span::call_site()` spans.\n+    ///\n+    /// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n+    /// change these errors into `LexError`s later.\n+    impl FromStr for TokenStream {\n+        type Err = LexError;\n+\n+        fn from_str(src: &str) -> Result<TokenStream, LexError> {\n+            let (subtree, _token_map) =\n+                ra_mbe::parse_to_token_tree(src).ok_or(\"Failed to parse from mbe\")?;\n+\n+            let tt: tt::TokenTree = subtree.into();\n+            Ok(tt.into())\n+        }\n+    }\n+\n+    impl ToString for TokenStream {\n+        fn to_string(&self) -> String {\n+            let tt = self.subtree.clone().into();\n+            to_text(&tt)\n+        }\n+    }\n+\n+    fn to_text(tkn: &tt::TokenTree) -> String {\n+        match tkn {\n+            tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => ident.text.clone().into(),\n+            tt::TokenTree::Leaf(tt::Leaf::Literal(literal)) => literal.text.clone().into(),\n+            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => format!(\"{}\", punct.char),\n+            tt::TokenTree::Subtree(subtree) => {\n+                let content = subtree\n+                    .token_trees\n+                    .iter()\n+                    .map(|tkn| {\n+                        let s = to_text(tkn);\n+                        if let tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) = tkn {\n+                            if punct.spacing == tt::Spacing::Alone {\n+                                return s + \" \";\n+                            }\n+                        }\n+                        s\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .concat();\n+                let (open, close) = match subtree.delimiter.map(|it| it.kind) {\n+                    None => (\"\", \"\"),\n+                    Some(tt::DelimiterKind::Brace) => (\"{\", \"}\"),\n+                    Some(tt::DelimiterKind::Parenthesis) => (\"(\", \")\"),\n+                    Some(tt::DelimiterKind::Bracket) => (\"[\", \"]\"),\n+                };\n+                format!(\"{}{}{}\", open, content, close)\n+            }\n+        }\n+    }\n+}\n+\n+impl TokenStreamBuilder {\n+    fn new() -> TokenStreamBuilder {\n+        TokenStreamBuilder { acc: TokenStream::new() }\n+    }\n+\n+    fn push(&mut self, stream: TokenStream) {\n+        self.acc.extend(stream.into_iter())\n+    }\n+\n+    fn build(self) -> TokenStream {\n+        self.acc\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct TokenStreamIter {\n+    trees: IntoIter<TokenTree>,\n+}\n+\n+#[derive(Default)]\n+pub struct Rustc {\n+    ident_interner: IdentInterner,\n+    // FIXME: store span information here.\n+}\n+\n+impl server::Types for Rustc {\n+    type TokenStream = TokenStream;\n+    type TokenStreamBuilder = TokenStreamBuilder;\n+    type TokenStreamIter = TokenStreamIter;\n+    type Group = Group;\n+    type Punct = Punct;\n+    type Ident = IdentId;\n+    type Literal = Literal;\n+    type SourceFile = SourceFile;\n+    type Diagnostic = Diagnostic;\n+    type Span = Span;\n+    type MultiSpan = Vec<Span>;\n+}\n+\n+impl server::TokenStream for Rustc {\n+    fn new(&mut self) -> Self::TokenStream {\n+        Self::TokenStream::new()\n+    }\n+\n+    fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n+        stream.is_empty()\n+    }\n+    fn from_str(&mut self, src: &str) -> Self::TokenStream {\n+        Self::TokenStream::from_str(src).expect(\"cannot parse string\")\n+    }\n+    fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n+        stream.to_string()\n+    }\n+    fn from_token_tree(\n+        &mut self,\n+        tree: bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>,\n+    ) -> Self::TokenStream {\n+        match tree {\n+            bridge::TokenTree::Group(group) => {\n+                let tree = TokenTree::from(group);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+\n+            bridge::TokenTree::Ident(IdentId(index)) => {\n+                let IdentData(ident) = self.ident_interner.get(index).clone();\n+                let ident: tt::Ident = ident;\n+                let leaf = tt::Leaf::from(ident);\n+                let tree = TokenTree::from(leaf);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+\n+            bridge::TokenTree::Literal(literal) => {\n+                let leaf = tt::Leaf::from(literal);\n+                let tree = TokenTree::from(leaf);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+\n+            bridge::TokenTree::Punct(p) => {\n+                let leaf = tt::Leaf::from(p);\n+                let tree = TokenTree::from(leaf);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+        }\n+    }\n+\n+    fn into_iter(&mut self, stream: Self::TokenStream) -> Self::TokenStreamIter {\n+        let trees: Vec<TokenTree> = stream.into_iter().collect();\n+        TokenStreamIter { trees: trees.into_iter() }\n+    }\n+}\n+\n+impl server::TokenStreamBuilder for Rustc {\n+    fn new(&mut self) -> Self::TokenStreamBuilder {\n+        Self::TokenStreamBuilder::new()\n+    }\n+    fn push(&mut self, builder: &mut Self::TokenStreamBuilder, stream: Self::TokenStream) {\n+        builder.push(stream)\n+    }\n+    fn build(&mut self, builder: Self::TokenStreamBuilder) -> Self::TokenStream {\n+        builder.build()\n+    }\n+}\n+\n+impl server::TokenStreamIter for Rustc {\n+    fn next(\n+        &mut self,\n+        iter: &mut Self::TokenStreamIter,\n+    ) -> Option<bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n+        iter.trees.next().map(|tree| match tree {\n+            TokenTree::Subtree(group) => bridge::TokenTree::Group(group),\n+            TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                bridge::TokenTree::Ident(IdentId(self.ident_interner.intern(&IdentData(ident))))\n+            }\n+            TokenTree::Leaf(tt::Leaf::Literal(literal)) => bridge::TokenTree::Literal(literal),\n+            TokenTree::Leaf(tt::Leaf::Punct(punct)) => bridge::TokenTree::Punct(punct),\n+        })\n+    }\n+}\n+\n+fn delim_to_internal(d: bridge::Delimiter) -> Option<tt::Delimiter> {\n+    let kind = match d {\n+        bridge::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n+        bridge::Delimiter::Brace => tt::DelimiterKind::Brace,\n+        bridge::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n+        bridge::Delimiter::None => return None,\n+    };\n+    Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind })\n+}\n+\n+fn delim_to_external(d: Option<tt::Delimiter>) -> bridge::Delimiter {\n+    match d.map(|it| it.kind) {\n+        Some(tt::DelimiterKind::Parenthesis) => bridge::Delimiter::Parenthesis,\n+        Some(tt::DelimiterKind::Brace) => bridge::Delimiter::Brace,\n+        Some(tt::DelimiterKind::Bracket) => bridge::Delimiter::Bracket,\n+        None => bridge::Delimiter::None,\n+    }\n+}\n+\n+fn spacing_to_internal(spacing: bridge::Spacing) -> Spacing {\n+    match spacing {\n+        bridge::Spacing::Alone => Spacing::Alone,\n+        bridge::Spacing::Joint => Spacing::Joint,\n+    }\n+}\n+\n+fn spacing_to_external(spacing: Spacing) -> bridge::Spacing {\n+    match spacing {\n+        Spacing::Alone => bridge::Spacing::Alone,\n+        Spacing::Joint => bridge::Spacing::Joint,\n+    }\n+}\n+\n+impl server::Group for Rustc {\n+    fn new(&mut self, delimiter: bridge::Delimiter, stream: Self::TokenStream) -> Self::Group {\n+        Self::Group {\n+            delimiter: delim_to_internal(delimiter),\n+            token_trees: stream.subtree.token_trees,\n+        }\n+    }\n+    fn delimiter(&mut self, group: &Self::Group) -> bridge::Delimiter {\n+        delim_to_external(group.delimiter)\n+    }\n+\n+    // NOTE: Return value of do not include delimiter\n+    fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n+        TokenStream {\n+            subtree: tt::Subtree { delimiter: None, token_trees: group.token_trees.clone() },\n+        }\n+    }\n+\n+    fn span(&mut self, group: &Self::Group) -> Self::Span {\n+        group.delimiter.map(|it| it.id).unwrap_or_else(|| tt::TokenId::unspecified())\n+    }\n+\n+    fn set_span(&mut self, _group: &mut Self::Group, _span: Self::Span) {\n+        // FIXME handle span\n+    }\n+\n+    fn span_open(&mut self, _group: &Self::Group) -> Self::Span {\n+        // FIXME handle span\n+        // MySpan(self.span_interner.intern(&MySpanData(group.span_open())))\n+        tt::TokenId::unspecified()\n+    }\n+\n+    fn span_close(&mut self, _group: &Self::Group) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+}\n+\n+impl server::Punct for Rustc {\n+    fn new(&mut self, ch: char, spacing: bridge::Spacing) -> Self::Punct {\n+        tt::Punct {\n+            char: ch,\n+            spacing: spacing_to_internal(spacing),\n+            id: tt::TokenId::unspecified(),\n+        }\n+    }\n+    fn as_char(&mut self, punct: Self::Punct) -> char {\n+        punct.char\n+    }\n+    fn spacing(&mut self, punct: Self::Punct) -> bridge::Spacing {\n+        spacing_to_external(punct.spacing)\n+    }\n+    fn span(&mut self, _punct: Self::Punct) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+    fn with_span(&mut self, punct: Self::Punct, _span: Self::Span) -> Self::Punct {\n+        // FIXME handle span\n+        punct\n+    }\n+}\n+\n+impl server::Ident for Rustc {\n+    fn new(&mut self, string: &str, _span: Self::Span, _is_raw: bool) -> Self::Ident {\n+        IdentId(\n+            self.ident_interner.intern(&IdentData(tt::Ident {\n+                text: string.into(),\n+                id: tt::TokenId::unspecified(),\n+            })),\n+        )\n+    }\n+\n+    fn span(&mut self, _ident: Self::Ident) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+    fn with_span(&mut self, ident: Self::Ident, _span: Self::Span) -> Self::Ident {\n+        // FIXME handle span\n+        ident\n+    }\n+}\n+\n+impl server::Literal for Rustc {\n+    // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n+    fn debug(&mut self, literal: &Self::Literal) -> String {\n+        format!(\"{:?}\", literal)\n+    }\n+\n+    fn integer(&mut self, n: &str) -> Self::Literal {\n+        let n: i128 = n.parse().unwrap();\n+        Literal { text: n.to_string().into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n+        macro_rules! def_suffixed_integer {\n+            ($kind:ident, $($ty:ty),*) => {\n+                match $kind {\n+                    $(\n+                        stringify!($ty) => {\n+                            let n: $ty = n.parse().unwrap();\n+                            format!(concat!(\"{}\", stringify!($ty)), n)\n+                        }\n+                    )*\n+                    _ => unimplemented!(\"unknown args for typed_integer: n {}, kind {}\", n, $kind),\n+                }\n+            }\n+        }\n+\n+        let text =\n+            def_suffixed_integer! {kind, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128};\n+\n+        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn float(&mut self, n: &str) -> Self::Literal {\n+        let n: f64 = n.parse().unwrap();\n+        let mut text = f64::to_string(&n);\n+        if !text.contains('.') {\n+            text += \".0\"\n+        }\n+        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn f32(&mut self, n: &str) -> Self::Literal {\n+        let n: f32 = n.parse().unwrap();\n+        let text = format!(\"{}f32\", n);\n+        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn f64(&mut self, n: &str) -> Self::Literal {\n+        let n: f64 = n.parse().unwrap();\n+        let text = format!(\"{}f64\", n);\n+        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn string(&mut self, string: &str) -> Self::Literal {\n+        let mut escaped = String::new();\n+        for ch in string.chars() {\n+            escaped.extend(ch.escape_debug());\n+        }\n+        Literal { text: format!(\"\\\"{}\\\"\", escaped).into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn character(&mut self, ch: char) -> Self::Literal {\n+        Literal { text: format!(\"'{}'\", ch).into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n+        let string = bytes\n+            .iter()\n+            .cloned()\n+            .flat_map(ascii::escape_default)\n+            .map(Into::<char>::into)\n+            .collect::<String>();\n+\n+        Literal { text: format!(\"b\\\"{}\\\"\", string).into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n+        literal.id\n+    }\n+\n+    fn set_span(&mut self, _literal: &mut Self::Literal, _span: Self::Span) {\n+        // FIXME handle span\n+    }\n+\n+    fn subspan(\n+        &mut self,\n+        _literal: &Self::Literal,\n+        _start: Bound<usize>,\n+        _end: Bound<usize>,\n+    ) -> Option<Self::Span> {\n+        // FIXME handle span\n+        None\n+    }\n+}\n+\n+impl server::SourceFile for Rustc {\n+    fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n+        file1.eq(file2)\n+    }\n+    fn path(&mut self, file: &Self::SourceFile) -> String {\n+        String::from(\n+            file.path().to_str().expect(\"non-UTF8 file path in `proc_macro::SourceFile::path`\"),\n+        )\n+    }\n+    fn is_real(&mut self, file: &Self::SourceFile) -> bool {\n+        file.is_real()\n+    }\n+}\n+\n+impl server::Diagnostic for Rustc {\n+    fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n+        let mut diag = Diagnostic::new(level, msg);\n+        diag.spans = spans;\n+        diag\n+    }\n+\n+    fn sub(\n+        &mut self,\n+        _diag: &mut Self::Diagnostic,\n+        _level: Level,\n+        _msg: &str,\n+        _spans: Self::MultiSpan,\n+    ) {\n+        // FIXME handle diagnostic\n+        //\n+    }\n+\n+    fn emit(&mut self, _diag: Self::Diagnostic) {\n+        // FIXME handle diagnostic\n+        // diag.emit()\n+    }\n+}\n+\n+impl server::Span for Rustc {\n+    fn debug(&mut self, span: Self::Span) -> String {\n+        format!(\"{:?}\", span.0)\n+    }\n+    fn def_site(&mut self) -> Self::Span {\n+        // MySpan(self.span_interner.intern(&MySpanData(Span::def_site())))\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+    fn call_site(&mut self) -> Self::Span {\n+        // MySpan(self.span_interner.intern(&MySpanData(Span::call_site())))\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+    fn source_file(&mut self, _span: Self::Span) -> Self::SourceFile {\n+        // let MySpanData(span) = self.span_interner.get(span.0);\n+        unimplemented!()\n+    }\n+\n+    /// Recent feature, not yet in the proc_macro\n+    ///\n+    /// See PR:\n+    /// https://github.com/rust-lang/rust/pull/55780\n+    fn source_text(&mut self, _span: Self::Span) -> Option<String> {\n+        None\n+    }\n+\n+    fn parent(&mut self, _span: Self::Span) -> Option<Self::Span> {\n+        // FIXME handle span\n+        None\n+    }\n+    fn source(&mut self, span: Self::Span) -> Self::Span {\n+        // FIXME handle span\n+        span\n+    }\n+    fn start(&mut self, _span: Self::Span) -> LineColumn {\n+        // FIXME handle span\n+        LineColumn { line: 0, column: 0 }\n+    }\n+    fn end(&mut self, _span: Self::Span) -> LineColumn {\n+        // FIXME handle span\n+        LineColumn { line: 0, column: 0 }\n+    }\n+    fn join(&mut self, _first: Self::Span, _second: Self::Span) -> Option<Self::Span> {\n+        None\n+    }\n+    fn resolved_at(&mut self, _span: Self::Span, _at: Self::Span) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+\n+    fn mixed_site(&mut self) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+}\n+\n+impl server::MultiSpan for Rustc {\n+    fn new(&mut self) -> Self::MultiSpan {\n+        // FIXME handle span\n+        vec![]\n+    }\n+\n+    fn push(&mut self, other: &mut Self::MultiSpan, span: Self::Span) {\n+        //TODP\n+        other.push(span)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::proc_macro::bridge::server::Literal;\n+\n+    #[test]\n+    fn test_rustc_server_literals() {\n+        let mut srv = Rustc { ident_interner: IdentInterner::default() };\n+        assert_eq!(srv.integer(\"1234\").text, \"1234\");\n+\n+        assert_eq!(srv.typed_integer(\"12\", \"u8\").text, \"12u8\");\n+        assert_eq!(srv.typed_integer(\"255\", \"u16\").text, \"255u16\");\n+        assert_eq!(srv.typed_integer(\"1234\", \"u32\").text, \"1234u32\");\n+        assert_eq!(srv.typed_integer(\"15846685\", \"u64\").text, \"15846685u64\");\n+        assert_eq!(srv.typed_integer(\"15846685258\", \"u128\").text, \"15846685258u128\");\n+        assert_eq!(srv.typed_integer(\"156788984\", \"usize\").text, \"156788984usize\");\n+        assert_eq!(srv.typed_integer(\"127\", \"i8\").text, \"127i8\");\n+        assert_eq!(srv.typed_integer(\"255\", \"i16\").text, \"255i16\");\n+        assert_eq!(srv.typed_integer(\"1234\", \"i32\").text, \"1234i32\");\n+        assert_eq!(srv.typed_integer(\"15846685\", \"i64\").text, \"15846685i64\");\n+        assert_eq!(srv.typed_integer(\"15846685258\", \"i128\").text, \"15846685258i128\");\n+        assert_eq!(srv.float(\"0\").text, \"0.0\");\n+        assert_eq!(srv.float(\"15684.5867\").text, \"15684.5867\");\n+        assert_eq!(srv.f32(\"15684.58\").text, \"15684.58f32\");\n+        assert_eq!(srv.f64(\"15684.58\").text, \"15684.58f64\");\n+\n+        assert_eq!(srv.string(\"hello_world\").text, \"\\\"hello_world\\\"\");\n+        assert_eq!(srv.character('c').text, \"'c'\");\n+        assert_eq!(srv.byte_string(b\"1234586\\x88\").text, \"b\\\"1234586\\\\x88\\\"\");\n+    }\n+}"}]}