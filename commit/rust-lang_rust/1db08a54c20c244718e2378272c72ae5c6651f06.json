{"sha": "1db08a54c20c244718e2378272c72ae5c6651f06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYjA4YTU0YzIwYzI0NDcxOGUyMzc4MjcyYzcyYWU1YzY2NTFmMDY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-09T08:04:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-09T08:04:00Z"}, "message": "Merge #1784\n\n1784: Support textual scoped macros r=matklad a=uHOOCCOOHu\n\nRefactor the old simulation with `global_macro_scope`.\r\n\r\nNow it is quite accurate to resolve textual scoped macros.\r\n- Expand textual scoped macros in item and non-item place.\r\n- Support `#[macro_use]` on `mod`.\r\n- Textual scoped macros are collected into `nameres::ModuleScope`, so I think it makes #1727 easier to fix.\r\n- It is implemented in a simple way to `clone()` current scoped macro ids into sub-modules. Though only indices are cloned, it will still increase some resolving time. Well, I've not bench-marked yet.\r\n\r\nIn my test with vscode extension, it can now successfully expand `dbg!` from `std` without `std::` prefix. \"Goto definition\" also works. Screenshot here:\r\n<img width=\"281\" alt=\"Screenshot_20190907_043442\" src=\"https://user-images.githubusercontent.com/14816024/64458794-ddb47900-d128-11e9-95e3-1c8569978825.png\">\r\n\n\nCo-authored-by: uHOOCCOOHu <hooccooh1896@gmail.com>", "tree": {"sha": "90fe99eb39d045d9bac34cc200a74d0410d51763", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90fe99eb39d045d9bac34cc200a74d0410d51763"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1db08a54c20c244718e2378272c72ae5c6651f06", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJddgdwCRBK7hj4Ov3rIwAAdHIIAEciX4/+4BWwI2mvNI4ex358\n7YzA795hxrpvjyDWWRW5VrR9REi9IkUNbSsSL4jinlRb1J7MWymfm657BC4LrKSG\nW7wmc+h/hBvJ5uP0BnsDXeIw7PjbGdhBDl9WhEDB8C6RvXFdsauoaLvL3qbEUmRS\nIDusAUvTFArMxL2Bz3ae0isWsxpPxcZ5CWstDR7d0asfH6EUN/rKbXYwlJ3Nl/zf\nCJv7L0TU15B1vrYKQeQ/4ZWAf/LOf85kQqmwYm6m9fZv2wzQ2/498iWeWVZTk0cu\nzAWdbXRU28f7+OLv7JXLlx5k3HjgSqgrjWMIjPAdz+SM2oitfgqHoqu48h8yo9k=\n=BO+R\n-----END PGP SIGNATURE-----\n", "payload": "tree 90fe99eb39d045d9bac34cc200a74d0410d51763\nparent 72259b67bf2393bec1faf6a9f95a575d6fe9cfea\nparent 9ed21d65fb6727f6de4961dfa440981864451af6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1568016240 +0000\ncommitter GitHub <noreply@github.com> 1568016240 +0000\n\nMerge #1784\n\n1784: Support textual scoped macros r=matklad a=uHOOCCOOHu\n\nRefactor the old simulation with `global_macro_scope`.\r\n\r\nNow it is quite accurate to resolve textual scoped macros.\r\n- Expand textual scoped macros in item and non-item place.\r\n- Support `#[macro_use]` on `mod`.\r\n- Textual scoped macros are collected into `nameres::ModuleScope`, so I think it makes #1727 easier to fix.\r\n- It is implemented in a simple way to `clone()` current scoped macro ids into sub-modules. Though only indices are cloned, it will still increase some resolving time. Well, I've not bench-marked yet.\r\n\r\nIn my test with vscode extension, it can now successfully expand `dbg!` from `std` without `std::` prefix. \"Goto definition\" also works. Screenshot here:\r\n<img width=\"281\" alt=\"Screenshot_20190907_043442\" src=\"https://user-images.githubusercontent.com/14816024/64458794-ddb47900-d128-11e9-95e3-1c8569978825.png\">\r\n\n\nCo-authored-by: uHOOCCOOHu <hooccooh1896@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1db08a54c20c244718e2378272c72ae5c6651f06", "html_url": "https://github.com/rust-lang/rust/commit/1db08a54c20c244718e2378272c72ae5c6651f06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1db08a54c20c244718e2378272c72ae5c6651f06/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72259b67bf2393bec1faf6a9f95a575d6fe9cfea", "url": "https://api.github.com/repos/rust-lang/rust/commits/72259b67bf2393bec1faf6a9f95a575d6fe9cfea", "html_url": "https://github.com/rust-lang/rust/commit/72259b67bf2393bec1faf6a9f95a575d6fe9cfea"}, {"sha": "9ed21d65fb6727f6de4961dfa440981864451af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed21d65fb6727f6de4961dfa440981864451af6", "html_url": "https://github.com/rust-lang/rust/commit/9ed21d65fb6727f6de4961dfa440981864451af6"}], "stats": {"total": 271, "additions": 229, "deletions": 42}, "files": [{"sha": "74546e5e29c9986db4a152ae127fcc1e4ec150e5", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=1db08a54c20c244718e2378272c72ae5c6651f06", "patch": "@@ -138,7 +138,21 @@ pub(crate) struct ModuleData {\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n     items: FxHashMap<Name, Resolution>,\n+    /// Macros in current module scoped\n+    ///\n+    /// This scope works exactly the same way that item scoping does.\n+    /// Macro invocation with quantified path will search in it.\n+    /// See details below.\n     macros: FxHashMap<Name, MacroDef>,\n+    /// Macros visable in current module in legacy textual scope\n+    ///\n+    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n+    /// If it yields no result, then it turns to module scoped `macros`.\n+    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n+    /// and only normal scoped `macros` will be searched in.\n+    ///\n+    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n+    legacy_macros: FxHashMap<Name, MacroDef>,\n }\n \n static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n@@ -164,13 +178,17 @@ impl ModuleScope {\n             _ => None,\n         })\n     }\n+    /// It resolves in module scope. Textual scoped macros are ignored here.\n     fn get_item_or_macro(&self, name: &Name) -> Option<ItemOrMacro> {\n         match (self.get(name), self.macros.get(name)) {\n             (Some(item), _) if !item.def.is_none() => Some(Either::A(item.def)),\n             (_, Some(macro_)) => Some(Either::B(*macro_)),\n             _ => None,\n         }\n     }\n+    fn get_legacy_macro(&self, name: &Name) -> Option<MacroDef> {\n+        self.legacy_macros.get(name).copied()\n+    }\n }\n \n type ItemOrMacro = Either<PerNs<ModuleDef>, MacroDef>;\n@@ -484,16 +502,21 @@ impl CrateDefMap {\n         name: &Name,\n     ) -> ItemOrMacro {\n         // Resolve in:\n+        //  - legacy scope\n         //  - current module / scope\n         //  - extern prelude\n         //  - std prelude\n+        let from_legacy_macro = self[module]\n+            .scope\n+            .get_legacy_macro(name)\n+            .map_or_else(|| Either::A(PerNs::none()), Either::B);\n         let from_scope =\n             self[module].scope.get_item_or_macro(name).unwrap_or_else(|| Either::A(PerNs::none()));\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n         let from_prelude = self.resolve_in_prelude(db, name);\n \n-        or(from_scope, or(Either::A(from_extern_prelude), from_prelude))\n+        or(from_legacy_macro, or(from_scope, or(Either::A(from_extern_prelude), from_prelude)))\n     }\n \n     fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {"}, {"sha": "09cda76567c7de968f6ffa31ce3ab8dd7dfb4883", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=1db08a54c20c244718e2378272c72ae5c6651f06", "patch": "@@ -14,8 +14,8 @@ use crate::{\n         raw, CrateDefMap, CrateModuleId, ItemOrMacro, ModuleData, ModuleDef, PerNs,\n         ReachedFixedPoint, Resolution, ResolveMode,\n     },\n-    AstId, Const, Enum, Function, HirFileId, MacroDef, Module, Name, Path, Static, Struct, Trait,\n-    TypeAlias, Union,\n+    AstId, Const, Enum, Function, HirFileId, MacroDef, Module, Name, Path, PathKind, Static,\n+    Struct, Trait, TypeAlias, Union,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -40,7 +40,6 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n-        global_macro_scope: FxHashMap::default(),\n         macro_stack_monitor: MacroStackMonitor::default(),\n     };\n     collector.collect();\n@@ -82,7 +81,6 @@ struct DefCollector<DB> {\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n     unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n-    global_macro_scope: FxHashMap<Name, MacroDefId>,\n \n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stack overflow, we add a deep counter here for prevent that.\n@@ -136,20 +134,6 @@ where\n         macro_id: MacroDefId,\n         export: bool,\n     ) {\n-        // macro-by-example in Rust have completely weird name resolution logic,\n-        // unlike anything else in the language. We'd don't fully implement yet,\n-        // just give a somewhat precise approximation.\n-        //\n-        // Specifically, we store a set of visible macros in each module, just\n-        // like how we do with usual items. This is wrong, however, because\n-        // macros can be shadowed and their scopes are mostly unrelated to\n-        // modules. To paper over the second problem, we also maintain\n-        // `global_macro_scope` which works when we construct `CrateDefMap`, but\n-        // is completely ignored in expressions.\n-        //\n-        // What we should do is that, in CrateDefMap, we should maintain a\n-        // separate tower of macro scopes, with ids. Then, for each item in the\n-        // module, we need to store it's macro scope.\n         let def = Either::B(MacroDef { id: macro_id });\n \n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n@@ -162,13 +146,29 @@ where\n             self.def_map.exported_macros.insert(name.clone(), macro_id);\n         }\n         self.update(module_id, None, &[(name.clone(), def)]);\n-        self.global_macro_scope.insert(name, macro_id);\n+        self.define_legacy_macro(module_id, name.clone(), macro_id);\n+    }\n+\n+    /// Define a legacy textual scoped macro in module\n+    ///\n+    /// We use a map `legacy_macros` to store all legacy textual scoped macros visable per module.\n+    /// It will clone all macros from parent legacy scope, whose definition is prior to\n+    /// the definition of current module.\n+    /// And also, `macro_use` on a module will import all legacy macros visable inside to\n+    /// current legacy scope, with possible shadowing.\n+    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_id: MacroDefId) {\n+        // Always shadowing\n+        self.def_map.modules[module_id].scope.legacy_macros.insert(name, MacroDef { id: macro_id });\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n     ///\n     /// They are non-scoped, and will only be inserted into mutable `global_macro_scope`.\n-    fn import_macros_from_extern_crate(&mut self, import: &raw::ImportData) {\n+    fn import_macros_from_extern_crate(\n+        &mut self,\n+        current_module_id: CrateModuleId,\n+        import: &raw::ImportData,\n+    ) {\n         log::debug!(\n             \"importing macros from extern crate: {:?} ({:?})\",\n             import,\n@@ -184,14 +184,14 @@ where\n \n         if let Some(ModuleDef::Module(m)) = res.take_types() {\n             tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(m);\n+            self.import_all_macros_exported(current_module_id, m);\n         }\n     }\n \n-    fn import_all_macros_exported(&mut self, module: Module) {\n+    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, module: Module) {\n         let item_map = self.db.crate_def_map(module.krate);\n         for (name, &macro_id) in &item_map.exported_macros {\n-            self.global_macro_scope.insert(name.clone(), macro_id);\n+            self.define_legacy_macro(current_module_id, name.clone(), macro_id);\n         }\n     }\n \n@@ -528,7 +528,7 @@ where\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n             if prelude_module.krate != self.def_collector.def_map.krate {\n                 tested_by!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(prelude_module);\n+                self.def_collector.import_all_macros_exported(self.module_id, prelude_module);\n             }\n         }\n \n@@ -539,7 +539,7 @@ where\n             if let raw::RawItem::Import(import_id) = *item {\n                 let import = self.raw_items[import_id].clone();\n                 if import.is_extern_crate && import.is_macro_use {\n-                    self.def_collector.import_macros_from_extern_crate(&import);\n+                    self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n                 }\n             }\n         }\n@@ -561,10 +561,11 @@ where\n     fn collect_module(&mut self, module: &raw::ModuleData) {\n         match module {\n             // inline module, just recurse\n-            raw::ModuleData::Definition { name, items, ast_id, attr_path } => {\n+            raw::ModuleData::Definition { name, items, ast_id, attr_path, is_macro_use } => {\n                 let module_id =\n                     self.push_child_module(name.clone(), ast_id.with_file_id(self.file_id), None);\n                 let parent_module = ParentModule { name, attr_path: attr_path.as_ref() };\n+\n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n                     module_id,\n@@ -573,9 +574,12 @@ where\n                     parent_module: Some(parent_module),\n                 }\n                 .collect(&*items);\n+                if *is_macro_use {\n+                    self.import_all_legacy_macros(module_id);\n+                }\n             }\n             // out of line module, resolve, parse and recurse\n-            raw::ModuleData::Declaration { name, ast_id, attr_path } => {\n+            raw::ModuleData::Declaration { name, ast_id, attr_path, is_macro_use } => {\n                 let ast_id = ast_id.with_file_id(self.file_id);\n                 let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n                 match resolve_submodule(\n@@ -596,7 +600,10 @@ where\n                             raw_items: &raw_items,\n                             parent_module: None,\n                         }\n-                        .collect(raw_items.items())\n+                        .collect(raw_items.items());\n+                        if *is_macro_use {\n+                            self.import_all_legacy_macros(module_id);\n+                        }\n                     }\n                     Err(candidate) => self.def_collector.def_map.diagnostics.push(\n                         DefDiagnostic::UnresolvedModule {\n@@ -621,6 +628,7 @@ where\n         modules[res].parent = Some(self.module_id);\n         modules[res].declaration = Some(declaration);\n         modules[res].definition = definition;\n+        modules[res].scope.legacy_macros = modules[self.module_id].scope.legacy_macros.clone();\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n             def: PerNs::types(\n@@ -674,20 +682,32 @@ where\n \n         let ast_id = mac.ast_id.with_file_id(self.file_id);\n \n-        // Case 2: try to expand macro_rules from this crate, triggering\n+        // Case 2: try to resolve in legacy scope and expand macro_rules, triggering\n         // recursive item collection.\n-        if let Some(macro_id) =\n-            mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(&name))\n-        {\n-            let def = *macro_id;\n+        if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n+            self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n+        }) {\n+            let def = macro_def.id;\n             let macro_call_id = MacroCallLoc { def, ast_id }.id(self.def_collector.db);\n \n             self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, def);\n             return;\n         }\n \n-        // Case 3: path to a macro from another crate, expand during name resolution\n-        self.def_collector.unexpanded_macros.push((self.module_id, ast_id, mac.path.clone()))\n+        // Case 3: resolve in module scope, expand during name resolution.\n+        // We rewrite simple path `macro_name` to `self::macro_name` to force resolve in module scope only.\n+        let mut path = mac.path.clone();\n+        if path.is_ident() {\n+            path.kind = PathKind::Self_;\n+        }\n+        self.def_collector.unexpanded_macros.push((self.module_id, ast_id, path));\n+    }\n+\n+    fn import_all_legacy_macros(&mut self, module_id: CrateModuleId) {\n+        let macros = self.def_collector.def_map[module_id].scope.legacy_macros.clone();\n+        for (name, macro_) in macros {\n+            self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_.id);\n+        }\n     }\n }\n \n@@ -715,7 +735,6 @@ mod tests {\n             glob_imports: FxHashMap::default(),\n             unresolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n-            global_macro_scope: FxHashMap::default(),\n             macro_stack_monitor: monitor,\n         };\n         collector.collect();"}, {"sha": "c646d3d005f2c1bc5f01792f63a9a7abebd4dc42", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=1db08a54c20c244718e2378272c72ae5c6651f06", "patch": "@@ -134,12 +134,14 @@ pub(super) enum ModuleData {\n         name: Name,\n         ast_id: FileAstId<ast::Module>,\n         attr_path: Option<SmolStr>,\n+        is_macro_use: bool,\n     },\n     Definition {\n         name: Name,\n         ast_id: FileAstId<ast::Module>,\n         items: Vec<RawItem>,\n         attr_path: Option<SmolStr>,\n+        is_macro_use: bool,\n     },\n }\n \n@@ -267,10 +269,15 @@ impl RawItemsCollector {\n         };\n \n         let ast_id = self.source_ast_id_map.ast_id(&module);\n+        let is_macro_use = module.has_atom_attr(\"macro_use\");\n         if module.has_semi() {\n             let attr_path = extract_mod_path_attribute(&module);\n-            let item =\n-                self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id, attr_path });\n+            let item = self.raw_items.modules.alloc(ModuleData::Declaration {\n+                name,\n+                ast_id,\n+                attr_path,\n+                is_macro_use,\n+            });\n             self.push_item(current_module, RawItem::Module(item));\n             return;\n         }\n@@ -282,6 +289,7 @@ impl RawItemsCollector {\n                 ast_id,\n                 items: Vec::new(),\n                 attr_path,\n+                is_macro_use,\n             });\n             self.process_module(Some(item), item_list);\n             self.push_item(current_module, RawItem::Module(item));"}, {"sha": "ebc4d6890ba98c859215947bf9c23eb6ccb926d8", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "modified", "additions": 105, "deletions": 3, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=1db08a54c20c244718e2378272c72ae5c6651f06", "patch": "@@ -268,12 +268,114 @@ fn prelude_cycle() {\n     );\n     assert_snapshot!(map, @r###\"\n         \u22eecrate\n-        \u22eefoo: t\n         \u22eeprelude: t\n         \u22ee\n         \u22eecrate::prelude\n         \u22eedeclare_mod: m\n-        \u22ee\n-        \u22eecrate::foo\n+    \"###);\n+}\n+\n+#[test]\n+fn plain_macros_are_legacy_textual_scoped() {\n+    let map = def_map(\n+        r#\"\n+        //- /main.rs\n+        mod m1;\n+        bar!(NotFoundNotMacroUse);\n+\n+        mod m2 {\n+            foo!(NotFoundBeforeInside2);\n+        }\n+\n+        macro_rules! foo {\n+            ($x:ident) => { struct $x; }\n+        }\n+        foo!(Ok);\n+\n+        mod m3;\n+        foo!(OkShadowStop);\n+        bar!(NotFoundMacroUseStop);\n+\n+        #[macro_use]\n+        mod m5 {\n+            #[macro_use]\n+            mod m6 {\n+                macro_rules! foo {\n+                    ($x:ident) => { fn $x() {} }\n+                }\n+            }\n+        }\n+        foo!(ok_double_macro_use_shadow);\n+\n+        baz!(NotFoundBefore);\n+        #[macro_use]\n+        mod m7 {\n+            macro_rules! baz {\n+                ($x:ident) => { struct $x; }\n+            }\n+        }\n+        baz!(OkAfter);\n+\n+        //- /m1.rs\n+        foo!(NotFoundBeforeInside1);\n+        macro_rules! bar {\n+            ($x:ident) => { struct $x; }\n+        }\n+\n+        //- /m3/mod.rs\n+        foo!(OkAfterInside);\n+        macro_rules! foo {\n+            ($x:ident) => { fn $x() {} }\n+        }\n+        foo!(ok_shadow);\n+\n+        #[macro_use]\n+        mod m4;\n+        bar!(OkMacroUse);\n+\n+        //- /m3/m4.rs\n+        foo!(ok_shadow_deep);\n+        macro_rules! bar {\n+            ($x:ident) => { struct $x; }\n+        }\n+        \"#,\n+    );\n+    assert_snapshot!(map, @r###\"\n+   \u22eecrate\n+   \u22eeOk: t v\n+   \u22eeOkAfter: t v\n+   \u22eeOkShadowStop: t v\n+   \u22eefoo: m\n+   \u22eem1: t\n+   \u22eem2: t\n+   \u22eem3: t\n+   \u22eem5: t\n+   \u22eem7: t\n+   \u22eeok_double_macro_use_shadow: v\n+   \u22ee\n+   \u22eecrate::m7\n+   \u22eebaz: m\n+   \u22ee\n+   \u22eecrate::m1\n+   \u22eebar: m\n+   \u22ee\n+   \u22eecrate::m5\n+   \u22eem6: t\n+   \u22ee\n+   \u22eecrate::m5::m6\n+   \u22eefoo: m\n+   \u22ee\n+   \u22eecrate::m2\n+   \u22ee\n+   \u22eecrate::m3\n+   \u22eeOkAfterInside: t v\n+   \u22eeOkMacroUse: t v\n+   \u22eefoo: m\n+   \u22eem4: t\n+   \u22eeok_shadow: v\n+   \u22ee\n+   \u22eecrate::m3::m4\n+   \u22eebar: m\n+   \u22eeok_shadow_deep: v\n     \"###);\n }"}, {"sha": "25716fe8c105d2316fbb1b4761dc9f341ef5ab3b", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db08a54c20c244718e2378272c72ae5c6651f06/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=1db08a54c20c244718e2378272c72ae5c6651f06", "patch": "@@ -2803,6 +2803,41 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn infer_legacy_textual_scoped_macros_expanded() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Foo(Vec<i32>);\n+\n+#[macro_use]\n+mod m {\n+    macro_rules! foo {\n+        ($($item:expr),*) => {\n+            {\n+                Foo(vec![$($item,)*])\n+            }\n+        };\n+    }\n+}\n+\n+fn main() {\n+    let x = foo!(1,2);\n+    let y = crate::foo!(1,2);\n+}\n+\"#),\n+        @r###\"\n+    ![0; 17) '{Foo(v...,2,])}': Foo\n+    ![1; 4) 'Foo': Foo({unknown}) -> Foo\n+    ![1; 16) 'Foo(vec![1,2,])': Foo\n+    ![5; 15) 'vec![1,2,]': {unknown}\n+    [195; 251) '{     ...,2); }': ()\n+    [205; 206) 'x': Foo\n+    [228; 229) 'y': {unknown}\n+    [232; 248) 'crate:...!(1,2)': {unknown}\n+    \"###\n+    );\n+}\n+\n #[ignore]\n #[test]\n fn method_resolution_trait_before_autoref() {"}]}