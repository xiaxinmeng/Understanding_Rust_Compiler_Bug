{"sha": "9187406da5ce8a6b4bfca6ee017e56230be0872c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxODc0MDZkYTVjZThhNmI0YmZjYTZlZTAxN2U1NjIzMGJlMDg3MmM=", "commit": {"author": {"name": "Zack Corr", "email": "zackcorr95@gmail.com", "date": "2012-06-06T08:55:44Z"}, "committer": {"name": "Zack Corr", "email": "zackcorr95@gmail.com", "date": "2012-06-06T08:55:44Z"}, "message": "Cargo: Added new source scheme, added sources CLI management, added source dumping", "tree": {"sha": "f087a2ccb3662827a219c3883355dbda39fe5086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f087a2ccb3662827a219c3883355dbda39fe5086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9187406da5ce8a6b4bfca6ee017e56230be0872c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9187406da5ce8a6b4bfca6ee017e56230be0872c", "html_url": "https://github.com/rust-lang/rust/commit/9187406da5ce8a6b4bfca6ee017e56230be0872c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9187406da5ce8a6b4bfca6ee017e56230be0872c/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99d6807ee009b0289d5a1ae46385d251e4f0da64", "url": "https://api.github.com/repos/rust-lang/rust/commits/99d6807ee009b0289d5a1ae46385d251e4f0da64", "html_url": "https://github.com/rust-lang/rust/commit/99d6807ee009b0289d5a1ae46385d251e4f0da64"}], "stats": {"total": 937, "additions": 748, "deletions": 189}, "files": [{"sha": "10a3f87b8278c1fb961a016d328f94b8f254779b", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 748, "deletions": 189, "changes": 937, "blob_url": "https://github.com/rust-lang/rust/blob/9187406da5ce8a6b4bfca6ee017e56230be0872c/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9187406da5ce8a6b4bfca6ee017e56230be0872c/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=9187406da5ce8a6b4bfca6ee017e56230be0872c", "patch": "@@ -16,21 +16,21 @@ import vec;\n import getopts::{optflag, optopt, opt_present};\n \n type package = {\n-    name: str,\n-    uuid: str,\n-    url: str,\n-    method: str,\n-    description: str,\n-    ref: option<str>,\n-    tags: [str]\n+    mut name: str,\n+    mut uuid: str,\n+    mut url: str,\n+    mut method: str,\n+    mut description: str,\n+    mut ref: option<str>,\n+    mut tags: [str]\n };\n \n type source = {\n-    name: str,\n-    url: str,\n-    sig: option<str>,\n-    key: option<str>,\n-    keyfp: option<str>,\n+    mut name: str,\n+    mut url: str,\n+    mut method: str,\n+    mut key: option<str>,\n+    mut keyfp: option<str>,\n     mut packages: [package]\n };\n \n@@ -47,12 +47,12 @@ type cargo = {\n };\n \n type pkg = {\n-    name: str,\n-    vers: str,\n-    uuid: str,\n-    desc: option<str>,\n-    sigs: option<str>,\n-    crate_type: option<str>\n+    mut name: str,\n+    mut vers: str,\n+    mut uuid: str,\n+    mut desc: option<str>,\n+    mut sigs: option<str>,\n+    mut crate_type: option<str>\n };\n \n type options = {\n@@ -108,17 +108,16 @@ fn is_uuid(id: str) -> bool {\n     if vec::len(parts) == 5u {\n         let mut correct = 0u;\n         for vec::eachi(parts) { |i, part|\n+            fn is_hex_digit(ch: char) -> bool {\n+                ('0' <= ch && ch <= '9') ||\n+                ('a' <= ch && ch <= 'f') ||\n+                ('A' <= ch && ch <= 'F')\n+            }\n \n             if !part.all(is_hex_digit) {\n                 ret false;\n             }\n \n-            fn is_hex_digit(ch: char) -> bool {\n-                ('0' <= ch && ch <= '9') ||\n-                    ('a' <= ch && ch <= 'f') ||\n-                    ('A' <= ch && ch <= 'F')\n-            }\n-\n             alt i {\n                 0u {\n                     if str::len(part) == 8u {\n@@ -156,27 +155,26 @@ fn test_is_uuid() {\n     assert !is_uuid(\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n }\n \n-// FIXME: implement URI/URL parsing so we don't have to resort to weak checks\n+// FIXME: implement url/URL parsing so we don't have to resort to weak checks\n+\n+fn has_archive_extension(p: str) -> bool {\n+    str::ends_with(p, \".tar\") ||\n+    str::ends_with(p, \".tar.gz\") ||\n+    str::ends_with(p, \".tar.xz\") ||\n+    str::ends_with(p, \".tar.bz2\")\n+}\n \n-fn is_archive_uri(uri: str) -> bool {\n-    str::ends_with(uri, \".tar\")\n-    || str::ends_with(uri, \".tar.gz\")\n-    || str::ends_with(uri, \".tar.xz\")\n-    || str::ends_with(uri, \".tar.bz2\")\n+fn is_archive_path(u: str) -> bool {\n+    has_archive_extension(u) && os::path_exists(u)\n }\n \n-fn is_archive_url(url: str) -> bool {\n-    // FIXME: this requires the protocol bit - if we had proper URI parsing,\n+fn is_archive_url(u: str) -> bool {\n+    // FIXME: this requires the protocol bit - if we had proper url parsing,\n     // we wouldn't need it\n \n-    alt str::find_str(url, \"://\") {\n-        option::some(idx) {\n-            str::ends_with(url, \".tar\")\n-            || str::ends_with(url, \".tar.gz\")\n-            || str::ends_with(url, \".tar.xz\")\n-            || str::ends_with(url, \".tar.bz2\")\n-        }\n-        option::none { false }\n+    alt str::find_str(u, \"://\") {\n+        option::some(i) { has_archive_extension(u) }\n+        _ { false }\n     }\n }\n \n@@ -187,6 +185,15 @@ fn is_git_url(url: str) -> bool {\n     }\n }\n \n+fn assume_source_method(url: str) -> str {\n+    if is_git_url(url) { ret \"git\"; }\n+    if str::starts_with(url, \"file://\") || os::path_exists(url) {\n+        ret \"file\";\n+    }\n+\n+    \"curl\"\n+}\n+\n fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n                                          option<str>,\n                                          option<str>) {\n@@ -253,12 +260,12 @@ fn load_pkg(filename: str) -> option<pkg> {\n     alt (name, vers, uuid) {\n         (some(name0), some(vers0), some(uuid0)) {\n             some({\n-                name: name0,\n-                vers: vers0,\n-                uuid: uuid0,\n-                desc: desc,\n-                sigs: sigs,\n-                crate_type: crate_type})\n+                mut name: name0,\n+                mut vers: vers0,\n+                mut uuid: uuid0,\n+                mut desc: desc,\n+                mut sigs: sigs,\n+                mut crate_type: crate_type})\n         }\n         _ { ret none; }\n     }\n@@ -283,20 +290,36 @@ fn need_dir(s: str) {\n     }\n }\n \n+fn valid_pkg_name(s: str) -> bool {\n+    fn is_valid_digit(c: char) -> bool {\n+        ('0' <= c && c <= '9') ||\n+        ('a' <= c && c <= 'z') ||\n+        ('A' <= c && c <= 'Z') ||\n+        c == '-' ||\n+        c == '_'\n+    }\n+\n+    s.all(is_valid_digit)\n+}\n+\n fn parse_source(name: str, j: json::json) -> source {\n+    if !valid_pkg_name(name) {\n+        fail #fmt(\"'%s' is an invalid source name\", name);\n+    }\n+\n     alt j {\n         json::dict(_j) {\n-            let url = alt _j.find(\"url\") {\n+            let mut url = alt _j.find(\"url\") {\n                 some(json::string(u)) {\n                     u\n                 }\n                 _ { fail \"needed 'url' field in source\"; }\n             };\n-            let sig = alt _j.find(\"sig\") {\n+            let method = alt _j.find(\"method\") {\n                 some(json::string(u)) {\n-                    some(u)\n+                    u\n                 }\n-                _ { none }\n+                _ { assume_source_method(url) }\n             };\n             let key = alt _j.find(\"key\") {\n                 some(json::string(u)) {\n@@ -310,7 +333,14 @@ fn parse_source(name: str, j: json::json) -> source {\n                 }\n                 _ { none }\n             };\n-            ret { name: name, url: url, sig: sig, key: key, keyfp: keyfp,\n+            if method == \"file\" {\n+                url = os::make_absolute(url);\n+            }\n+            ret { mut name: name,\n+                  mut url: url,\n+                  mut method: method,\n+                  mut key: key,\n+                  mut keyfp: keyfp,\n                   mut packages: [] };\n         }\n         _ { fail \"needed dict value in source\"; }\n@@ -334,15 +364,30 @@ fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n \n fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n     let name = alt p.find(\"name\") {\n-        some(json::string(_n)) { _n }\n+        some(json::string(_n)) {\n+            if !valid_pkg_name(_n) {\n+                warn(\"malformed source json: \" + src.name + \", '\" + _n + \"'\"+\n+                     \" is an invalid name (alphanumeric, underscores and\" +\n+                     \" dashes only)\");\n+                ret;\n+            }\n+            _n\n+        }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing name)\");\n             ret;\n         }\n     };\n \n     let uuid = alt p.find(\"uuid\") {\n-        some(json::string(_n)) { _n }\n+        some(json::string(_n)) {\n+            if !is_uuid(_n) {\n+                warn(\"malformed source json: \" + src.name + \", '\" + _n + \"'\"+\n+                     \" is an invalid uuid\");\n+                ret;\n+            }\n+            _n\n+        }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing uuid)\");\n             ret;\n@@ -392,18 +437,55 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n         }\n     };\n \n-    vec::grow(src.packages, 1u, {\n-        name: name,\n-        uuid: uuid,\n-        url: url,\n-        method: method,\n-        description: description,\n-        ref: ref,\n-        tags: tags\n-    });\n+    let newpkg = {\n+        mut name: name,\n+        mut uuid: uuid,\n+        mut url: url,\n+        mut method: method,\n+        mut description: description,\n+        mut ref: ref,\n+        mut tags: tags\n+    };\n+\n+    for src.packages.each { |pkg|\n+        if pkg.uuid == uuid {\n+            pkg.name = newpkg.name;\n+            pkg.uuid = newpkg.uuid;\n+            pkg.url = newpkg.url;\n+            pkg.method = newpkg.method;\n+            pkg.description = newpkg.description;\n+            pkg.ref = newpkg.ref;\n+            pkg.tags = newpkg.tags;\n+            log(debug, \"  updated package: \" + src.name + \"/\" + name);\n+            ret;\n+        }\n+    }\n+\n+    vec::grow(src.packages, 1u, newpkg);\n     log(debug, \"  loaded package: \" + src.name + \"/\" + name);\n }\n \n+fn load_source_info(&c: cargo, &src: source) {\n+    let dir = path::connect(c.sourcedir, src.name);\n+    let srcfile = path::connect(dir, \"source.json\");\n+    if !os::path_exists(srcfile) { ret; }\n+    let srcstr = io::read_whole_file_str(srcfile);\n+    alt json::from_str(result::get(srcstr)) {\n+        ok(json::dict(_s)) {\n+            let o = parse_source(src.name, json::dict(_s));\n+\n+            src.key = o.key;\n+            src.keyfp = o.keyfp;\n+        }\n+        ok(_) {\n+            warn(\"malformed source.json: \" + src.name +\n+                 \"(source info is not a dict)\");\n+        }\n+        err(e) {\n+            warn(#fmt(\"%s:%u:%u: %s\", src.name, e.line, e.col, e.msg));\n+        }\n+    };\n+}\n fn load_source_packages(&c: cargo, &src: source) {\n     log(debug, \"loading source: \" + src.name);\n     let dir = path::connect(c.sourcedir, src.name);\n@@ -425,7 +507,7 @@ fn load_source_packages(&c: cargo, &src: source) {\n             }\n         }\n         ok(_) {\n-            warn(\"malformed source json: \" + src.name +\n+            warn(\"malformed packages.json: \" + src.name +\n                  \"(packages is not a list)\");\n         }\n         err(e) {\n@@ -519,7 +601,7 @@ fn configure(opts: options) -> cargo {\n     c\n }\n \n-fn for_each_package(c: cargo, b: fn(source, package)) {\n+fn for_each_package(&c: cargo, b: fn(source, package)) {\n     for c.sources.each_value {|v|\n         // FIXME (#2280): this temporary shouldn't be\n         // necessary, but seems to be, for borrowing.\n@@ -563,7 +645,7 @@ fn test_one_crate(_c: cargo, path: str, cf: str) {\n   run_programs(buildpath);\n }\n \n-fn install_one_crate(c: cargo, path: str, cf: str) {\n+fn install_one_crate(&c: cargo, path: str, cf: str) {\n     let buildpath = alt run_in_buildpath(\"installing\", path,\n                                          \"/build\", cf, []) {\n       none { ret; }\n@@ -603,7 +685,7 @@ fn rustc_sysroot() -> str {\n     }\n }\n \n-fn install_source(c: cargo, path: str) {\n+fn install_source(&c: cargo, path: str) {\n     #debug(\"source: %s\", path);\n     os::change_dir(path);\n \n@@ -632,9 +714,8 @@ fn install_source(c: cargo, path: str) {\n     }\n }\n \n-fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n-    info(\"installing with git from \" + url + \"...\");\n-    run::run_program(\"git\", [\"clone\", url, wd]);\n+fn install_git(&c: cargo, wd: str, url: str, ref: option<str>) {\n+    run::program_output(\"git\", [\"clone\", url, wd]);\n     if option::is_some::<str>(ref) {\n         let r = option::get::<str>(ref);\n         os::change_dir(wd);\n@@ -644,8 +725,7 @@ fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n     install_source(c, wd);\n }\n \n-fn install_curl(c: cargo, wd: str, url: str) {\n-    info(\"installing with curl from \" + url + \"...\");\n+fn install_curl(&c: cargo, wd: str, url: str) {\n     let tarpath = path::connect(wd, \"pkg.tar\");\n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n                                          tarpath, url]);\n@@ -657,96 +737,95 @@ fn install_curl(c: cargo, wd: str, url: str) {\n     install_source(c, wd);\n }\n \n-fn install_file(c: cargo, wd: str, path: str) {\n-    info(\"installing with tar from \" + path + \"...\");\n-    run::run_program(\"tar\", [\"-x\", \"--strip-components=1\",\n+fn install_file(&c: cargo, wd: str, path: str) {\n+    run::program_output(\"tar\", [\"-x\", \"--strip-components=1\",\n                              \"-C\", wd, \"-f\", path]);\n     install_source(c, wd);\n }\n \n-fn install_package(c: cargo, wd: str, pkg: package) {\n-    alt pkg.method {\n-        \"git\" { install_git(c, wd, pkg.url, pkg.ref); }\n-        \"http\" | \"ftp\" | \"curl\" { install_curl(c, wd, pkg.url); }\n-        \"file\" { install_file(c, wd, pkg.url); }\n-        _ { fail #fmt(\"don't know how to install with: %s\", pkg.method) }\n+fn install_package(&c: cargo, src: str, wd: str, pkg: package) {\n+    let url = copy pkg.url;\n+    let method = alt pkg.method {\n+        \"git\" { \"git\" }\n+        \"file\" { \"file\" }\n+        _ { \"curl\" }\n+    };\n+\n+    info(#fmt[\"installing %s/%s via %s...\", src, pkg.name, method]);\n+\n+    alt method {\n+        \"git\" { install_git(c, wd, url, copy pkg.ref); }\n+        \"file\" { install_file(c, wd, url); }\n+        \"curl\" { install_curl(c, wd, copy url); }\n+        _ {}\n     }\n }\n \n-fn cargo_suggestion(c: cargo, syncing: bool, fallback: fn())\n+fn cargo_suggestion(&c: cargo, fallback: fn())\n {\n     if c.sources.size() == 0u {\n         error(\"no sources defined - you may wish to run \" +\n-              \"`cargo init` then `cargo sync`\");\n+              \"`cargo init`\");\n         ret;\n     }\n-    if !syncing {\n-        let mut npkg = 0u;\n-        for c.sources.each_value { |v| npkg += vec::len(v.packages) }\n-        if npkg == 0u {\n-            error(\"no packages synced - you may wish to run \" +\n-                  \"`cargo sync`\");\n-            ret;\n-        }\n-    }\n     fallback();\n }\n \n-fn install_uuid(c: cargo, wd: str, uuid: str) {\n+fn install_uuid(&c: cargo, wd: str, uuid: str) {\n     let mut ps = [];\n     for_each_package(c, { |s, p|\n         if p.uuid == uuid {\n-            vec::grow(ps, 1u, (s.name, p));\n+            vec::grow(ps, 1u, (s.name, copy p));\n         }\n     });\n     if vec::len(ps) == 1u {\n-        let (_, p) = ps[0];\n-        install_package(c, wd, p);\n+        let (sname, p) = copy ps[0];\n+        install_package(c, sname, wd, p);\n         ret;\n     } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, false, { ||\n+        cargo_suggestion(c, { ||\n             error(\"can't find package: \" + uuid);\n         });\n         ret;\n     }\n     error(\"found multiple packages:\");\n     for ps.each {|elt|\n-        let (sname,p) = elt;\n+        let (sname,p) = copy elt;\n         info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }\n \n-fn install_named(c: cargo, wd: str, name: str) {\n+fn install_named(&c: cargo, wd: str, name: str) {\n     let mut ps = [];\n     for_each_package(c, { |s, p|\n         if p.name == name {\n-            vec::grow(ps, 1u, (s.name, p));\n+            vec::grow(ps, 1u, (s.name, copy p));\n         }\n     });\n     if vec::len(ps) == 1u {\n-        let (_, p) = ps[0];\n-        install_package(c, wd, p);\n+        let (sname, p) = copy ps[0];\n+        install_package(c, sname, wd, p);\n         ret;\n     } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, false, { ||\n+        cargo_suggestion(c, { ||\n             error(\"can't find package: \" + name);\n         });\n         ret;\n     }\n     error(\"found multiple packages:\");\n     for ps.each {|elt|\n-        let (sname,p) = elt;\n+        let (sname,p) = copy elt;\n         info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }\n \n-fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n+fn install_uuid_specific(&c: cargo, wd: str, src: str, uuid: str) {\n     alt c.sources.find(src) {\n       some(s) {\n         let packages = copy s.packages;\n         if vec::any(packages, { |p|\n             if p.uuid == uuid {\n-                install_package(c, wd, p);\n+                install_package(c, src, wd, p);\n                 true\n             } else { false }\n         }) { ret; }\n@@ -756,13 +835,13 @@ fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n     error(\"can't find package: \" + src + \"/\" + uuid);\n }\n \n-fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n+fn install_named_specific(&c: cargo, wd: str, src: str, name: str) {\n     alt c.sources.find(src) {\n         some(s) {\n           let packages = copy s.packages;\n           if vec::any(packages, { |p|\n                 if p.name == name {\n-                    install_package(c, wd, p);\n+                    install_package(c, src, wd, p);\n                     true\n                 } else { false }\n             }) { ret; }\n@@ -772,7 +851,7 @@ fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n     error(\"can't find package: \" + src + \"/\" + name);\n }\n \n-fn cmd_uninstall(c: cargo) {\n+fn cmd_uninstall(&c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         ret;\n@@ -837,13 +916,7 @@ fn cmd_uninstall(c: cargo) {\n     }\n }\n \n-fn cmd_install(c: cargo) unsafe {\n-    // cargo install [pkg]\n-    if vec::len(c.opts.free) < 2u {\n-        cmd_usage();\n-        ret;\n-    }\n-\n+fn cmd_install(&c: cargo) unsafe {\n     let wd_base = c.workdir + path::path_sep();\n     let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n         some(_wd) { _wd }\n@@ -862,19 +935,22 @@ fn cmd_install(c: cargo) unsafe {\n         ret;\n     }\n \n+    sync(c);\n+\n     let target = c.opts.free[2];\n \n-    if is_archive_url(target) {\n-        install_curl(c, wd, target);\n+    if is_archive_path(target) {\n+        install_file(c, wd, target);\n+        ret;\n     } else if is_git_url(target) {\n         let ref = if c.opts.free.len() >= 4u {\n             some(c.opts.free[3u])\n         } else {\n             none\n         };\n         install_git(c, wd, target, ref)\n-    } else if is_archive_uri(target) {\n-        install_file(c, wd, target);\n+    } else if !valid_pkg_name(target) && has_archive_extension(target) {\n+        install_curl(c, wd, target);\n         ret;\n     } else {\n         let mut ps = copy target;\n@@ -900,80 +976,323 @@ fn cmd_install(c: cargo) unsafe {\n     }\n }\n \n-fn sync_one(c: cargo, name: str, src: source) {\n-    let dir = path::connect(c.sourcedir, name);\n+fn sync(&c: cargo) {\n+    for c.sources.each_key { |k|\n+        let mut s = c.sources.get(k);\n+\n+        sync_one(c, s);\n+        // FIXME: mutability hack\n+        c.sources.insert(k, s);\n+    }\n+}\n+\n+fn sync_one_file(&c: cargo, dir: str, &src: source) -> bool {\n+    let name = src.name;\n+    let srcfile = path::connect(dir, \"source.json.new\");\n+    let destsrcfile = path::connect(dir, \"source.json\");\n     let pkgfile = path::connect(dir, \"packages.json.new\");\n     let destpkgfile = path::connect(dir, \"packages.json\");\n-    let sigfile = path::connect(dir, \"packages.json.sig\");\n     let keyfile = path::connect(dir, \"key.gpg\");\n+    let srcsigfile = path::connect(dir, \"source.json.sig\");\n+    let sigfile = path::connect(dir, \"packages.json.sig\");\n     let url = src.url;\n-    need_dir(dir);\n-    info(#fmt[\"fetching source %s...\", name]);\n-    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", pkgfile, url]);\n-    if p.status != 0 {\n-        warn(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n-    } else {\n-        info(#fmt[\"fetched source: %s\", name]);\n+    let mut has_src_file = false;\n+\n+    if !os::copy_file(path::connect(url, \"packages.json\"), pkgfile) {\n+        error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+        ret false;\n     }\n-    alt src.sig {\n+\n+    if os::copy_file(path::connect(url, \"source.json\"), srcfile) {\n+        has_src_file = false;\n+    }\n+\n+    os::copy_file(path::connect(url, \"source.json.sig\"), srcsigfile);\n+    os::copy_file(path::connect(url, \"packages.json.sig\"), sigfile);\n+\n+    alt src.key {\n         some(u) {\n-            let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", sigfile,\n-                                                 u]);\n+            let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n+                                                  u]);\n             if p.status != 0 {\n-                warn(#fmt[\"fetch for source %s (sig %s) failed\", name, u]);\n+                error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                ret false;\n             }\n+            pgp::add(c.root, keyfile);\n         }\n         _ { }\n     }\n+    alt (src.key, src.keyfp) {\n+        (some(_), some(f)) {\n+            let r = pgp::verify(c.root, pkgfile, sigfile, f);\n+\n+            if !r {\n+                error(#fmt[\"signature verification failed for source %s\",\n+                          name]);\n+                ret false;\n+            }\n+\n+            if has_src_file {\n+                let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n+\n+                if !e {\n+                    error(#fmt[\"signature verification failed for source %s\",\n+                              name]);\n+                    ret false;\n+                }\n+            }\n+        }\n+        _ {}\n+    }\n+\n+    copy_warn(pkgfile, destpkgfile);\n+\n+    if has_src_file {\n+        copy_warn(srcfile, destsrcfile);\n+    }\n+\n+    os::remove_file(keyfile);\n+    os::remove_file(srcfile);\n+    os::remove_file(srcsigfile);\n+    os::remove_file(pkgfile);\n+    os::remove_file(sigfile);\n+\n+    info(#fmt[\"synced source: %s\", name]);\n+\n+    ret true;\n+}\n+\n+fn sync_one_git(&c: cargo, dir: str, &src: source) -> bool {\n+    let name = src.name;\n+    let srcfile = path::connect(dir, \"source.json\");\n+    let pkgfile = path::connect(dir, \"packages.json\");\n+    let keyfile = path::connect(dir, \"key.gpg\");\n+    let srcsigfile = path::connect(dir, \"source.json.sig\");\n+    let sigfile = path::connect(dir, \"packages.json.sig\");\n+    let url = src.url;\n+\n+    fn rollback(name: str, dir: str, insecure: bool) {\n+        fn msg(name: str, insecure: bool) {\n+            error(#fmt[\"could not rollback source: %s\", name]);\n+\n+            if insecure {\n+                warn(\"a past security check failed on source \" +\n+                     name + \" and rolling back the source failed -\"\n+                     + \" this source may be compromised\");\n+            }\n+        }\n+\n+        if !os::change_dir(dir) {\n+            msg(name, insecure);\n+        }\n+        else {\n+            let p = run::program_output(\"git\", [\"reset\", \"--hard\",\n+                                                \"HEAD@{1}\"]);\n+\n+            if p.status != 0 {\n+                msg(name, insecure);\n+            }\n+        }\n+    }\n+\n+    if !os::path_exists(path::connect(dir, \".git\")) {\n+        let p = run::program_output(\"git\", [\"clone\", url, dir]);\n+\n+        if p.status != 0 {\n+            error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+            ret false;\n+        }\n+    }\n+    else {\n+        if !os::change_dir(dir) {\n+            error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+            ret false;\n+        }\n+\n+        let p = run::program_output(\"git\", [\"pull\"]);\n+\n+        if p.status != 0 {\n+            error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+            ret false;\n+        }\n+    }\n+\n+    let has_src_file = os::path_exists(srcfile);\n+\n     alt src.key {\n         some(u) {\n             let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n                                                   u]);\n             if p.status != 0 {\n-                warn(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                rollback(name, dir, false);\n+                ret false;\n             }\n             pgp::add(c.root, keyfile);\n         }\n         _ { }\n     }\n-    alt (src.sig, src.key, src.keyfp) {\n-        (some(_), some(_), some(f)) {\n+    alt (src.key, src.keyfp) {\n+        (some(_), some(f)) {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n+\n             if !r {\n-                warn(#fmt[\"signature verification failed for source %s\",\n+                error(#fmt[\"signature verification failed for source %s\",\n                           name]);\n-            } else {\n-                info(#fmt[\"signature ok for source %s\", name]);\n+                rollback(name, dir, false);\n+                ret false;\n+            }\n+\n+            if has_src_file {\n+                let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n+\n+                if !e {\n+                    error(#fmt[\"signature verification failed for source %s\",\n+                              name]);\n+                    rollback(name, dir, false);\n+                    ret false;\n+                }\n             }\n         }\n-        _ {\n-            info(#fmt[\"no signature for source %s\", name]);\n-        }\n+        _ {}\n     }\n-    copy_warn(pkgfile, destpkgfile);\n+\n+    os::remove_file(keyfile);\n+\n+    info(#fmt[\"synced source: %s\", name]);\n+\n+    ret true;\n }\n \n-fn cmd_sync(c: cargo) {\n-    if vec::len(c.opts.free) >= 3u {\n-        vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) { |name|\n-            alt c.sources.find(name) {\n-                some(source) {\n-                    sync_one(c, name, source);\n+fn sync_one_curl(&c: cargo, dir: str, &src: source) -> bool {\n+    let name = src.name;\n+    let srcfile = path::connect(dir, \"source.json.new\");\n+    let destsrcfile = path::connect(dir, \"source.json\");\n+    let pkgfile = path::connect(dir, \"packages.json.new\");\n+    let destpkgfile = path::connect(dir, \"packages.json\");\n+    let keyfile = path::connect(dir, \"key.gpg\");\n+    let srcsigfile = path::connect(dir, \"source.json.sig\");\n+    let sigfile = path::connect(dir, \"packages.json.sig\");\n+    let mut url = src.url;\n+    let smart = !str::ends_with(src.url, \"packages.json\");\n+    let mut has_src_file = false;\n+\n+    if smart {\n+        url += \"/packages.json\";\n+    }\n+\n+    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", pkgfile, url]);\n+\n+    if p.status != 0 {\n+        error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+        ret false;\n+    }\n+    if smart {\n+        url = src.url + \"/source.json\";\n+        let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcfile, url]);\n+\n+        if p.status == 0 {\n+            has_src_file = true;\n+        }\n+    }\n+\n+    alt src.key {\n+        some(u) {\n+            let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n+                                                  u]);\n+            if p.status != 0 {\n+                error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                ret false;\n+            }\n+            pgp::add(c.root, keyfile);\n+        }\n+        _ { }\n+    }\n+    alt (src.key, src.keyfp) {\n+        (some(_), some(f)) {\n+            if smart {\n+                url = src.url + \"/packages.json.sig\";\n+            }\n+            else {\n+                url = src.url + \".sig\";\n+            }\n+\n+            let mut p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n+                        sigfile, url]);\n+            if p.status != 0 {\n+                error(#fmt[\"fetch for source %s (sig %s) failed\", name, url]);\n+                ret false;\n+            }\n+\n+            let r = pgp::verify(c.root, pkgfile, sigfile, f);\n+\n+            if !r {\n+                error(#fmt[\"signature verification failed for source %s\",\n+                          name]);\n+                ret false;\n+            }\n+\n+            if smart && has_src_file {\n+                url = src.url + \"/source.json.sig\";\n+\n+                p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcsigfile,\n+                                                     url]);\n+                if p.status != 0 {\n+                    error(#fmt[\"fetch for source %s (sig %s) failed\",\n+                          name, url]);\n+                    ret false;\n                 }\n-                none {\n-                    error(#fmt(\"no such source: %s\", name));\n+\n+                let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n+\n+                if !e {\n+                    error(\"signature verification failed for \" +\n+                          \"source \" + name);\n+                    ret false;\n                 }\n             }\n         }\n-    } else {\n-        cargo_suggestion(c, true, { || } );\n-        for c.sources.each_value { |v|\n-            sync_one(c, v.name, v);\n-        }\n+        _ {}\n+    }\n+\n+    copy_warn(pkgfile, destpkgfile);\n+\n+    if smart && has_src_file {\n+        copy_warn(srcfile, destsrcfile);\n+    }\n+\n+    os::remove_file(keyfile);\n+    os::remove_file(srcfile);\n+    os::remove_file(srcsigfile);\n+    os::remove_file(pkgfile);\n+    os::remove_file(sigfile);\n+\n+    info(#fmt[\"synced source: %s\", name]);\n+\n+    ret true;\n+}\n+\n+fn sync_one(&c: cargo, &src: source) {\n+    let name = src.name;\n+    let dir = path::connect(c.sourcedir, name);\n+\n+    info(#fmt[\"syncing source: %s...\", name]);\n+\n+    need_dir(dir);\n+\n+    let result = alt src.method {\n+        \"git\" { sync_one_git(c, dir, src) }\n+        \"file\" { sync_one_file(c, dir, src) }\n+        _ { sync_one_curl(c, dir, src) }\n+    };\n+\n+    if result {\n+        load_source_info(c, src);\n+        load_source_packages(c, src);\n     }\n }\n \n-fn cmd_init(c: cargo) {\n+fn cmd_init(&c: cargo) {\n     let srcurl = \"http://www.rust-lang.org/cargo/sources.json\";\n     let sigurl = \"http://www.rust-lang.org/cargo/sources.json.sig\";\n \n@@ -995,11 +1314,13 @@ fn cmd_init(c: cargo) {\n \n     let r = pgp::verify(c.root, srcfile, sigfile, pgp::signing_key_fp());\n     if !r {\n-        warn(#fmt[\"signature verification failed for '%s'\", srcfile]);\n-    } else {\n-        info(#fmt[\"signature ok for '%s'\", srcfile]);\n+        error(#fmt[\"signature verification failed for '%s'\", srcfile]);\n+        ret;\n     }\n+\n     copy_warn(srcfile, destsrcfile);\n+    os::remove_file(srcfile);\n+    os::remove_file(sigfile);\n \n     info(#fmt[\"initialized .cargo in %s\", c.root]);\n }\n@@ -1038,15 +1359,21 @@ fn print_source(s: source) {\n     });\n }\n \n-fn cmd_list(c: cargo) {\n+fn cmd_list(&c: cargo) {\n+    sync(c);\n+\n     if vec::len(c.opts.free) >= 3u {\n         vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) { |name|\n-            alt c.sources.find(name) {\n-                some(source) {\n-                    print_source(source);\n-                }\n-                none {\n-                    error(#fmt(\"no such source: %s\", name));\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+            } else {\n+                alt c.sources.find(name) {\n+                    some(source) {\n+                        print_source(source);\n+                    }\n+                    none {\n+                        error(#fmt(\"no such source: %s\", name));\n+                    }\n                 }\n             }\n         }\n@@ -1057,11 +1384,14 @@ fn cmd_list(c: cargo) {\n     }\n }\n \n-fn cmd_search(c: cargo) {\n+fn cmd_search(&c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         ret;\n     }\n+\n+    sync(c);\n+\n     let mut n = 0;\n     let name = c.opts.free[2];\n     let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n@@ -1086,10 +1416,233 @@ fn install_to_dir(srcfile: str, destdir: str) {\n     }\n }\n \n+fn dump_cache(c: cargo) {\n+    need_dir(c.root);\n+\n+    let out = path::connect(c.root, \"cache.json\");\n+    let root = json::dict(map::str_hash());\n+\n+    if os::path_exists(out) {\n+        copy_warn(out, path::connect(c.root, \"cache.json.old\"));\n+    }\n+}\n+fn dump_sources(c: cargo) {\n+    need_dir(c.root);\n+\n+    let out = path::connect(c.root, \"sources.json\");\n+\n+    if os::path_exists(out) {\n+        copy_warn(out, path::connect(c.root, \"sources.json.old\"));\n+    }\n+\n+    alt io::buffered_file_writer(out) {\n+        result::ok(writer) {\n+            let hash = map::str_hash();\n+            let root = json::dict(hash);\n+\n+            for c.sources.each { |k, v|\n+                let chash = map::str_hash();\n+                let child = json::dict(chash);\n+\n+                chash.insert(\"url\", json::string(v.url));\n+                chash.insert(\"method\", json::string(v.method));\n+\n+                alt v.key {\n+                    some(key) {\n+                        chash.insert(\"key\", json::string(key));\n+                    }\n+                    _ {}\n+                }\n+                alt v.keyfp {\n+                    some(keyfp) {\n+                        chash.insert(\"keyfp\", json::string(keyfp));\n+                    }\n+                    _ {}\n+                }\n+\n+                hash.insert(k, child);\n+            }\n+\n+            writer.write_str(json::to_str(root));\n+        }\n+        result::err(e) {\n+            error(#fmt(\"could not dump sources: %s\", e));\n+        }\n+    }\n+}\n+\n fn copy_warn(srcfile: str, destfile: str) {\n-  if !os::copy_file(srcfile, destfile) {\n-      warn(#fmt[\"copying %s to %s failed\", srcfile, destfile]);\n-  }\n+    if !os::copy_file(srcfile, destfile) {\n+        warn(#fmt[\"copying %s to %s failed\", srcfile, destfile]);\n+    }\n+}\n+\n+fn cmd_sources(&c: cargo) {\n+    if vec::len(c.opts.free) < 3u {\n+        for c.sources.each_value { |v|\n+            info(#fmt(\"%s (%s) via %s\", v.name, v.url, v.method));\n+        }\n+        ret;\n+    }\n+\n+    let action = c.opts.free[2u];\n+\n+    alt action {\n+        \"clear\" {\n+            for c.sources.each_key { |k|\n+                c.sources.remove(k);\n+            }\n+\n+            info(\"cleared sources\");\n+        }\n+        \"add\" {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let url = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    error(#fmt(\"source already exists: %s\", name));\n+                }\n+                none {\n+                    c.sources.insert(name, {\n+                        mut name: name,\n+                        mut url: url,\n+                        mut method: assume_source_method(url),\n+                        mut key: none,\n+                        mut keyfp: none,\n+                        mut packages: []\n+                    });\n+                    info(#fmt(\"added source: %s\", name));\n+                }\n+            }\n+        }\n+        \"remove\" {\n+            if vec::len(c.opts.free) < 4u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    c.sources.remove(name);\n+                    info(#fmt(\"removed source: %s\", name));\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        \"set-url\" {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let url = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    let old = copy source.url;\n+\n+                    source.url = if source.method == \"file\" {\n+                        os::make_absolute(url)\n+                    } else {\n+                        url\n+                    };\n+\n+                    info(#fmt(\"changed source url: '%s' to '%s'\", old, url));\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        \"set-method\" {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let method = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    let old = copy source.method;\n+\n+                    source.method = alt method {\n+                        \"git\" { \"git\" }\n+                        \"file\" { \"file\" }\n+                        _ { \"curl\" }\n+                    };\n+\n+                    info(#fmt(\"changed source method: '%s' to '%s'\", old,\n+                         method));\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        \"rename\" {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let newn = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+            if !valid_pkg_name(newn) {\n+                error(#fmt(\"'%s' is an invalid source name\", newn));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    c.sources.remove(name);\n+                    c.sources.insert(newn, source);\n+                    info(#fmt(\"renamed source: %s to %s\", name, newn));\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        _ { cmd_usage(); }\n+    }\n }\n \n fn cmd_usage() {\n@@ -1100,13 +1653,22 @@ fn cmd_usage() {\n General:\n     init                    Reinitialize cargo in ~/.cargo\n     usage                   Display this message\n-    sync [sources..]        Sync all sources (or specific sources)\n \n Querying:\n-    list [sources..]                        List sources and their packages\n-                                            or a single source\n+    list [sources..]                        List the packages in sources\n     search <name | '*'> [tags...]           Search packages\n \n+Sources:\n+    sources                                 List sources\n+    sources add <name> <url>                Add a source\n+    sources remove <name>                   Remove a source\n+    sources rename <name> <new>             Rename a source\n+    sources set-url <name> <url>            Change the source URL\n+    sources set-method <name> <method>      Change the method (guesses from\n+                                            the URL by default) can be ;git',\n+                                            'file' or 'curl'\n+    sources clear                           Remove all sources\n+\n Packages:\n     install [options]                       Install a package from source\n                                             code in the current directory\n@@ -1115,14 +1677,15 @@ Packages:\n     install [options] <url>                 Install a package via curl (HTTP,\n                                             FTP, etc.) from an\n                                             .tar[.gz|bz2|xz] file\n-    install [options] <url> [ref]           Install a package via git\n+    install [options] <url> [ref]           Install a package via read-only\n+                                            git\n     install [options] <file>                Install a package directly from an\n                                             .tar[.gz|bz2|xz] file\n-    uninstall [options] <name>              Remove a package by (meta) name\n-    uninstall [options] <uuid>              Remove a package by (meta) uuid\n+    uninstall [options] [source/]<name>     Remove a package by [meta]name\n+    uninstall [options] [source/]<uuid>     Remove a package by [meta]uuid\n \n Package installation options:\n-    --tests         Run crate tests before installing\n+    --test         Run crate tests before installing\n \n Package [un]installation options:\n     -g              Work at the user level (~/.cargo/bin/ instead of\n@@ -1143,17 +1706,11 @@ fn main(argv: [str]) {\n     }\n \n     let mut c = configure(o);\n-    let mut sources = c.sources;\n     let home = c.root;\n+    let first_time = os::path_exists(path::connect(home, \"sources.json\"));\n \n-    if !os::path_exists(path::connect(home, \"sources.json\")) {\n+    if !first_time && o.free[1] != \"init\" {\n         cmd_init(c);\n-        try_parse_sources(path::connect(home, \"sources.json\"), sources);\n-        try_parse_sources(path::connect(home, \"local-sources.json\"), sources);\n-\n-        for sources.each_value { |v|\n-            sync_one(c, v.name, v);\n-        }\n \n         // FIXME: shouldn't need to reconfigure\n         c = configure(o);\n@@ -1165,8 +1722,10 @@ fn main(argv: [str]) {\n         \"uninstall\" { cmd_uninstall(c); }\n         \"list\" { cmd_list(c); }\n         \"search\" { cmd_search(c); }\n-        \"sync\" { cmd_sync(c); }\n-        \"usage\" { cmd_usage(); }\n+        \"sources\" { cmd_sources(c); }\n         _ { cmd_usage(); }\n     }\n-}\n+\n+    dump_cache(c);\n+    dump_sources(c);\n+}\n\\ No newline at end of file"}]}