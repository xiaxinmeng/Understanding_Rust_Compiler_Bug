{"sha": "42cafcee2c740c6d2a85018a947b78338d2afa8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyY2FmY2VlMmM3NDBjNmQyYTg1MDE4YTk0N2I3ODMzOGQyYWZhOGU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-29T22:04:25Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-30T02:30:55Z"}, "message": "add is_disjoint to the Set trait", "tree": {"sha": "5c106f66dd90edb755290c22f9cad8623e20a1d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c106f66dd90edb755290c22f9cad8623e20a1d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42cafcee2c740c6d2a85018a947b78338d2afa8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42cafcee2c740c6d2a85018a947b78338d2afa8e", "html_url": "https://github.com/rust-lang/rust/commit/42cafcee2c740c6d2a85018a947b78338d2afa8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42cafcee2c740c6d2a85018a947b78338d2afa8e/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfa9c9a00f0a301a5e936ae14c6a95e98f3bf5ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa9c9a00f0a301a5e936ae14c6a95e98f3bf5ee", "html_url": "https://github.com/rust-lang/rust/commit/bfa9c9a00f0a301a5e936ae14c6a95e98f3bf5ee"}], "stats": {"total": 91, "additions": 61, "deletions": 30}, "files": [{"sha": "3c9ee50855e278dd6228a8668e92bf1ed7f68b3f", "filename": "src/libcore/container.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42cafcee2c740c6d2a85018a947b78338d2afa8e/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42cafcee2c740c6d2a85018a947b78338d2afa8e/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=42cafcee2c740c6d2a85018a947b78338d2afa8e", "patch": "@@ -66,6 +66,10 @@ pub trait Set<T>: Mutable {\n     /// present in the set.\n     fn remove(&mut self, value: &T) -> bool;\n \n+    /// Return true if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    pure fn is_disjoint(&self, other: &self) -> bool;\n+\n     /// Return true if the set is a subset of another\n     pure fn is_subset(&self, other: &self) -> bool;\n "}, {"sha": "cf99c0e46b9762924727d2cbbcf1b6305648098d", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/42cafcee2c740c6d2a85018a947b78338d2afa8e/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42cafcee2c740c6d2a85018a947b78338d2afa8e/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=42cafcee2c740c6d2a85018a947b78338d2afa8e", "patch": "@@ -14,16 +14,15 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+use container::{Container, Mutable, Map, Set};\n use cmp::Eq;\n use hash::Hash;\n use to_bytes::IterBytes;\n \n /// Open addressing with linear probing.\n pub mod linear {\n+    use super::*;\n     use iter::BaseIter;\n-    use container::{Container, Mutable, Map, Set};\n-    use cmp::Eq;\n-    use cmp;\n     use hash::Hash;\n     use iter;\n     use kinds::Copy;\n@@ -455,6 +454,12 @@ pub mod linear {\n         /// present in the set.\n         fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n \n+        /// Return true if the set has no elements in common with `other`.\n+        /// This is equivalent to checking for an empty intersection.\n+        pure fn is_disjoint(&self, other: &LinearSet<T>) -> bool {\n+            iter::all(self, |v| !other.contains(v))\n+        }\n+\n         /// Return true if the set is a subset of another\n         pure fn is_subset(&self, other: &LinearSet<T>) -> bool {\n             iter::all(self, |v| other.contains(v))\n@@ -626,6 +631,28 @@ mod test_map {\n mod test_set {\n     use super::*;\n \n+    #[test]\n+    fn test_disjoint() {\n+        let mut xs = linear::LinearSet::new();\n+        let mut ys = linear::LinearSet::new();\n+        assert xs.is_disjoint(&ys);\n+        assert ys.is_disjoint(&xs);\n+        assert xs.insert(5);\n+        assert ys.insert(11);\n+        assert xs.is_disjoint(&ys);\n+        assert ys.is_disjoint(&xs);\n+        assert xs.insert(7);\n+        assert xs.insert(19);\n+        assert xs.insert(4);\n+        assert ys.insert(2);\n+        assert ys.insert(-11);\n+        assert xs.is_disjoint(&ys);\n+        assert ys.is_disjoint(&xs);\n+        assert ys.insert(7);\n+        assert !xs.is_disjoint(&ys);\n+        assert !ys.is_disjoint(&xs);\n+    }\n+\n     #[test]\n     fn test_subset_and_superset() {\n         let mut a = linear::LinearSet::new();"}, {"sha": "b1c22f86c96a5a9eed4193e7cc670d38e170a6a8", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/42cafcee2c740c6d2a85018a947b78338d2afa8e/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42cafcee2c740c6d2a85018a947b78338d2afa8e/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=42cafcee2c740c6d2a85018a947b78338d2afa8e", "patch": "@@ -292,6 +292,33 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n     /// present in the set.\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n \n+    /// Return true if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    pure fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+        unsafe { // purity workaround\n+            x = x.next();\n+            y = y.next();\n+            let mut a = x.get();\n+            let mut b = y.get();\n+            while a.is_some() && b.is_some() {\n+                let a1 = a.unwrap();\n+                let b1 = b.unwrap();\n+                if a1 < b1 {\n+                    x = x.next();\n+                    a = x.get();\n+                } else if b1 < a1 {\n+                    y = y.next();\n+                    b = y.get();\n+                } else {\n+                    return false;\n+                }\n+            }\n+        }\n+        true\n+    }\n+\n     /// Return true if the set is a subset of another\n     pure fn is_subset(&self, other: &TreeSet<T>) -> bool {\n         other.is_superset(self)\n@@ -345,33 +372,6 @@ impl <T: Ord> TreeSet<T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n \n-    /// Return true if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    pure fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n-            let mut a = x.get();\n-            let mut b = y.get();\n-            while a.is_some() && b.is_some() {\n-                let a1 = a.unwrap();\n-                let b1 = b.unwrap();\n-                if a1 < b1 {\n-                    x = x.next();\n-                    a = x.get();\n-                } else if b1 < a1 {\n-                    y = y.next();\n-                    b = y.get();\n-                } else {\n-                    return false;\n-                }\n-            }\n-        }\n-        true\n-    }\n-\n     /// Visit the values (in-order) representing the difference\n     pure fn difference(&self, other: &TreeSet<T>, f: fn(&T) -> bool) {\n         let mut x = self.iter();"}]}