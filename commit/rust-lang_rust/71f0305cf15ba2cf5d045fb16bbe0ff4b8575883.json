{"sha": "71f0305cf15ba2cf5d045fb16bbe0ff4b8575883", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZjAzMDVjZjE1YmEyY2Y1ZDA0NWZiMTZiYmUwZmY0Yjg1NzU4ODM=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-09-10T05:38:43Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-09-11T04:26:28Z"}, "message": "Buffered I/O wrappers\n\nThe default buffer size is the same as the one in Java's BufferedWriter.\n\nWe may want BufferedWriter to have a Drop impl that flushes, but that\nisn't possible right now due to #4252/#4430. This would be a bit\nawkward due to the possibility of the inner flush failing. For what it's\nworth, Java's BufferedReader doesn't have a flushing finalizer, but that\nmay just be because Java's finalizer support is awful.\n\nCloses #8953", "tree": {"sha": "8eb8a703760431ae3a0d76806fc496d7e7c16a8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eb8a703760431ae3a0d76806fc496d7e7c16a8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71f0305cf15ba2cf5d045fb16bbe0ff4b8575883", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71f0305cf15ba2cf5d045fb16bbe0ff4b8575883", "html_url": "https://github.com/rust-lang/rust/commit/71f0305cf15ba2cf5d045fb16bbe0ff4b8575883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71f0305cf15ba2cf5d045fb16bbe0ff4b8575883/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af259a651d52e7243c74a833b2b39a61890e89fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/af259a651d52e7243c74a833b2b39a61890e89fe", "html_url": "https://github.com/rust-lang/rust/commit/af259a651d52e7243c74a833b2b39a61890e89fe"}], "stats": {"total": 358, "additions": 358, "deletions": 0}, "files": [{"sha": "66446de4492c1467f1e31929a69605586ac26490", "filename": "src/libstd/rt/io/buffered.rs", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/71f0305cf15ba2cf5d045fb16bbe0ff4b8575883/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f0305cf15ba2cf5d045fb16bbe0ff4b8575883/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs?ref=71f0305cf15ba2cf5d045fb16bbe0ff4b8575883", "patch": "@@ -0,0 +1,355 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Buffering wrappers for I/O traits\n+//!\n+//! It can be excessively inefficient to work directly with a `Reader` or\n+//! `Writer`. Every call to `read` or `write` on `TcpStream` results in a\n+//! system call, for example. This module provides structures that wrap\n+//! `Readers`, `Writers`, and `Streams` and buffer input and output to them.\n+//!\n+//! # Examples\n+//!\n+//! ~~~\n+//! let tcp_stream = TcpStream::connect(addr);\n+//! let reader = BufferedReader::new(tcp_stream);\n+//!\n+//! let mut buf: ~[u8] = vec::from_elem(100, 0u8);\n+//! match reader.read(buf.as_slice()) {\n+//!     Some(nread) => println!(\"Read {} bytes\", nread),\n+//!     None => println!(\"At the end of the stream!\")\n+//! }\n+//! ~~~\n+//!\n+//! ~~~\n+//! let tcp_stream = TcpStream::connect(addr);\n+//! let writer = BufferedWriter::new(tcp_stream);\n+//!\n+//! writer.write(\"hello, world\".as_bytes());\n+//! writer.flush();\n+//! ~~~\n+//!\n+//! ~~~\n+//! let tcp_stream = TcpStream::connect(addr);\n+//! let stream = BufferedStream::new(tcp_stream);\n+//!\n+//! stream.write(\"hello, world\".as_bytes());\n+//! stream.flush();\n+//!\n+//! let mut buf = vec::from_elem(100, 0u8);\n+//! match stream.read(buf.as_slice()) {\n+//!     Some(nread) => println!(\"Read {} bytes\", nread),\n+//!     None => println!(\"At the end of the stream!\")\n+//! }\n+//! ~~~\n+//!\n+\n+use prelude::*;\n+\n+use num;\n+use vec;\n+use super::{Reader, Writer, Stream, Decorator};\n+\n+// libuv recommends 64k buffers to maximize throughput\n+// https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n+static DEFAULT_CAPACITY: uint = 64 * 1024;\n+\n+/// Wraps a Reader and buffers input from it\n+pub struct BufferedReader<R> {\n+    priv inner: R,\n+    priv buf: ~[u8],\n+    priv pos: uint,\n+    priv cap: uint\n+}\n+\n+impl<R: Reader> BufferedReader<R> {\n+    /// Creates a new `BufferedReader` with with the specified buffer capacity\n+    pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> {\n+        BufferedReader {\n+            inner: inner,\n+            buf: vec::from_elem(cap, 0u8),\n+            pos: 0,\n+            cap: 0\n+        }\n+    }\n+\n+    /// Creates a new `BufferedReader` with a default buffer capacity\n+    pub fn new(inner: R) -> BufferedReader<R> {\n+        BufferedReader::with_capacity(DEFAULT_CAPACITY, inner)\n+    }\n+}\n+\n+impl<R: Reader> Reader for BufferedReader<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        if self.pos == self.cap {\n+            match self.inner.read(self.buf) {\n+                Some(cap) => {\n+                    self.pos = 0;\n+                    self.cap = cap;\n+                }\n+                None => return None\n+            }\n+        }\n+\n+        let src = self.buf.slice(self.pos, self.cap);\n+        let nread = num::min(src.len(), buf.len());\n+        vec::bytes::copy_memory(buf, src, nread);\n+        self.pos += nread;\n+        Some(nread)\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        self.pos == self.cap && self.inner.eof()\n+    }\n+}\n+\n+impl<R: Reader> Decorator<R> for BufferedReader<R> {\n+    fn inner(self) -> R {\n+        self.inner\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a R {\n+        &self.inner\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R {\n+        &mut self.inner\n+    }\n+}\n+\n+/// Wraps a Writer and buffers output to it\n+///\n+/// NOTE: `BufferedWriter` will NOT flush its buffer when dropped.\n+pub struct BufferedWriter<W> {\n+    priv inner: W,\n+    priv buf: ~[u8],\n+    priv pos: uint\n+}\n+\n+impl<W: Writer> BufferedWriter<W> {\n+    /// Creates a new `BufferedWriter` with with the specified buffer capacity\n+    pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> {\n+        BufferedWriter {\n+            inner: inner,\n+            buf: vec::from_elem(cap, 0u8),\n+            pos: 0\n+        }\n+    }\n+\n+    /// Creates a new `BufferedWriter` with a default buffer capacity\n+    pub fn new(inner: W) -> BufferedWriter<W> {\n+        BufferedWriter::with_capacity(DEFAULT_CAPACITY, inner)\n+    }\n+}\n+\n+impl<W: Writer> Writer for BufferedWriter<W> {\n+    fn write(&mut self, buf: &[u8]) {\n+        if self.pos + buf.len() > self.buf.len() {\n+            self.flush();\n+        }\n+\n+        if buf.len() > self.buf.len() {\n+            self.inner.write(buf);\n+        } else {\n+            let dst = self.buf.mut_slice_from(self.pos);\n+            vec::bytes::copy_memory(dst, buf, buf.len());\n+            self.pos += buf.len();\n+        }\n+    }\n+\n+    fn flush(&mut self) {\n+        if self.pos != 0 {\n+            self.inner.write(self.buf.slice_to(self.pos));\n+            self.pos = 0;\n+        }\n+        self.inner.flush();\n+    }\n+}\n+\n+impl<W: Writer> Decorator<W> for BufferedWriter<W> {\n+    fn inner(self) -> W {\n+        self.inner\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a W {\n+        &self.inner\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W {\n+        &mut self.inner\n+    }\n+}\n+\n+struct InternalBufferedWriter<W>(BufferedWriter<W>);\n+\n+impl<W: Reader> Reader for InternalBufferedWriter<W> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        self.inner.read(buf)\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        self.inner.eof()\n+    }\n+}\n+\n+/// Wraps a Stream and buffers input and output to and from it\n+///\n+/// NOTE: `BufferedStream` will NOT flush its output buffer when dropped.\n+pub struct BufferedStream<S>(BufferedReader<InternalBufferedWriter<S>>);\n+\n+impl<S: Stream> BufferedStream<S> {\n+    pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)\n+                           -> BufferedStream<S> {\n+        let writer = BufferedWriter::with_capacity(writer_cap, inner);\n+        let internal_writer = InternalBufferedWriter(writer);\n+        let reader = BufferedReader::with_capacity(reader_cap,\n+                                                   internal_writer);\n+        BufferedStream(reader)\n+    }\n+\n+    pub fn new(inner: S) -> BufferedStream<S> {\n+        BufferedStream::with_capacities(DEFAULT_CAPACITY, DEFAULT_CAPACITY,\n+                                        inner)\n+    }\n+}\n+\n+impl<S: Stream> Reader for BufferedStream<S> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        (**self).read(buf)\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        (**self).eof()\n+    }\n+}\n+\n+impl<S: Stream> Writer for BufferedStream<S> {\n+    fn write(&mut self, buf: &[u8]) {\n+        self.inner.write(buf)\n+    }\n+\n+    fn flush(&mut self) {\n+        self.inner.flush()\n+    }\n+}\n+\n+impl<S: Stream> Decorator<S> for BufferedStream<S> {\n+    fn inner(self) -> S {\n+        self.inner.inner()\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a S {\n+        self.inner.inner_ref()\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut S {\n+        self.inner.inner_mut_ref()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use super::*;\n+    use super::super::mem::{MemReader, MemWriter};\n+\n+    #[test]\n+    fn test_buffered_reader() {\n+        let inner = MemReader::new(~[0, 1, 2, 3, 4]);\n+        let mut reader = BufferedReader::with_capacity(2, inner);\n+\n+        let mut buf = [0, 0, 0];\n+        let nread = reader.read(buf);\n+        assert_eq!(Some(2), nread);\n+        assert_eq!([0, 1, 0], buf);\n+        assert!(!reader.eof());\n+\n+        let mut buf = [0];\n+        let nread = reader.read(buf);\n+        assert_eq!(Some(1), nread);\n+        assert_eq!([2], buf);\n+        assert!(!reader.eof());\n+\n+        let mut buf = [0, 0, 0];\n+        let nread = reader.read(buf);\n+        assert_eq!(Some(1), nread);\n+        assert_eq!([3, 0, 0], buf);\n+        assert!(!reader.eof());\n+\n+        let nread = reader.read(buf);\n+        assert_eq!(Some(1), nread);\n+        assert_eq!([4, 0, 0], buf);\n+        assert!(reader.eof());\n+\n+        assert_eq!(None, reader.read(buf));\n+    }\n+\n+    #[test]\n+    fn test_buffered_writer() {\n+        let inner = MemWriter::new();\n+        let mut writer = BufferedWriter::with_capacity(2, inner);\n+\n+        writer.write([0, 1]);\n+        assert_eq!([], writer.inner_ref().inner_ref().as_slice());\n+\n+        writer.write([2]);\n+        assert_eq!([0, 1], writer.inner_ref().inner_ref().as_slice());\n+\n+        writer.write([3]);\n+        assert_eq!([0, 1], writer.inner_ref().inner_ref().as_slice());\n+\n+        writer.flush();\n+        assert_eq!([0, 1, 2, 3], writer.inner_ref().inner_ref().as_slice());\n+\n+        writer.write([4]);\n+        writer.write([5]);\n+        assert_eq!([0, 1, 2, 3], writer.inner_ref().inner_ref().as_slice());\n+\n+        writer.write([6]);\n+        assert_eq!([0, 1, 2, 3, 4, 5],\n+                   writer.inner_ref().inner_ref().as_slice());\n+\n+        writer.write([7, 8]);\n+        assert_eq!([0, 1, 2, 3, 4, 5, 6],\n+                   writer.inner_ref().inner_ref().as_slice());\n+\n+        writer.write([9, 10, 11]);\n+        assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n+                   writer.inner_ref().inner_ref().as_slice());\n+\n+        writer.flush();\n+        assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n+                   writer.inner_ref().inner_ref().as_slice());\n+    }\n+\n+    // This is just here to make sure that we don't infinite loop in the\n+    // newtype struct autoderef weirdness\n+    #[test]\n+    fn test_buffered_stream() {\n+        struct S;\n+\n+        impl Writer for S {\n+            fn write(&mut self, _: &[u8]) {}\n+            fn flush(&mut self) {}\n+        }\n+\n+        impl Reader for S {\n+            fn read(&mut self, _: &mut [u8]) -> Option<uint> { None }\n+            fn eof(&mut self) -> bool { true }\n+        }\n+\n+        let mut stream = BufferedStream::new(S);\n+        let mut buf = [];\n+        stream.read(buf);\n+        stream.eof();\n+        stream.write(buf);\n+        stream.flush();\n+    }\n+}"}, {"sha": "59ca5d5775980db4843f58e45f6e377c13be9cc4", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71f0305cf15ba2cf5d045fb16bbe0ff4b8575883/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f0305cf15ba2cf5d045fb16bbe0ff4b8575883/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=71f0305cf15ba2cf5d045fb16bbe0ff4b8575883", "patch": "@@ -295,6 +295,9 @@ mod support;\n /// Basic Timer\n pub mod timer;\n \n+/// Buffered I/O wrappers\n+pub mod buffered;\n+\n /// Thread-blocking implementations\n pub mod native {\n     /// Posix file I/O"}]}