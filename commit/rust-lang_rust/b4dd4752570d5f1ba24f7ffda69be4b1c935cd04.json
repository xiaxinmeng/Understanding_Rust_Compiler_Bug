{"sha": "b4dd4752570d5f1ba24f7ffda69be4b1c935cd04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZGQ0NzUyNTcwZDVmMWJhMjRmN2ZmZGE2OWJlNGIxYzkzNWNkMDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-29T12:49:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-29T12:51:44Z"}, "message": "More principled approach for finding From trait", "tree": {"sha": "d922c9af05c682086d7a3f6f93c0fed51327ee0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d922c9af05c682086d7a3f6f93c0fed51327ee0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04", "html_url": "https://github.com/rust-lang/rust/commit/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "html_url": "https://github.com/rust-lang/rust/commit/c3dfeba165e4d13821bba34d21cdc5242ea2fa71"}], "stats": {"total": 134, "additions": 95, "deletions": 39}, "files": [{"sha": "49deb670175c0c6e213c6a18b262718c08fd8cf1", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=b4dd4752570d5f1ba24f7ffda69be4b1c935cd04", "patch": "@@ -1,11 +1,12 @@\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n     TextSize,\n };\n use stdx::format_to;\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use ra_ide_db::RootDatabase;\n+use crate::{utils::FamousDefs, Assist, AssistCtx, AssistId};\n+use test_utils::tested_by;\n \n // Assist add_from_impl_for_enum\n //\n@@ -41,7 +42,8 @@ pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n         _ => return None,\n     };\n \n-    if already_has_from_impl(ctx.sema, &variant) {\n+    if existing_from_impl(ctx.sema, &variant).is_some() {\n+        tested_by!(test_add_from_impl_already_exists);\n         return None;\n     }\n \n@@ -70,41 +72,33 @@ impl From<{0}> for {1} {{\n     )\n }\n \n-fn already_has_from_impl(\n+fn existing_from_impl(\n     sema: &'_ hir::Semantics<'_, RootDatabase>,\n     variant: &ast::EnumVariant,\n-) -> bool {\n-    let scope = sema.scope(&variant.syntax());\n+) -> Option<()> {\n+    let variant = sema.to_def(variant)?;\n+    let enum_ = variant.parent_enum(sema.db);\n+    let krate = enum_.module(sema.db).krate();\n \n-    let from_path = ast::make::path_from_text(\"From\");\n-    let from_hir_path = match hir::Path::from_ast(from_path) {\n-        Some(p) => p,\n-        None => return false,\n-    };\n-    let from_trait = match scope.resolve_hir_path(&from_hir_path) {\n-        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(t))) => t,\n-        _ => return false,\n-    };\n+    let from_trait = FamousDefs(sema, krate).core_convert_From()?;\n \n-    let e: hir::Enum = match sema.to_def(&variant.parent_enum()) {\n-        Some(e) => e,\n-        None => return false,\n-    };\n-    let e_ty = e.ty(sema.db);\n+    let enum_type = enum_.ty(sema.db);\n \n-    let hir_enum_var: hir::EnumVariant = match sema.to_def(variant) {\n-        Some(ev) => ev,\n-        None => return false,\n-    };\n-    let var_ty = hir_enum_var.fields(sema.db)[0].signature_ty(sema.db);\n+    let wrapped_type = variant.fields(sema.db).get(0)?.signature_ty(sema.db);\n \n-    e_ty.impls_trait(sema.db, from_trait, &[var_ty])\n+    if enum_type.impls_trait(sema.db, from_trait, &[wrapped_type]) {\n+        Some(())\n+    } else {\n+        None\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n+\n     use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use test_utils::covers;\n \n     #[test]\n     fn test_add_from_impl_for_enum() {\n@@ -136,36 +130,40 @@ mod tests {\n         );\n     }\n \n+    fn check_not_applicable(ra_fixture: &str) {\n+        let fixture =\n+            format!(\"//- main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n+        check_assist_not_applicable(add_from_impl_for_enum, &fixture)\n+    }\n+\n     #[test]\n     fn test_add_from_impl_no_element() {\n-        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One }\");\n+        check_not_applicable(\"enum A { <|>One }\");\n     }\n \n     #[test]\n     fn test_add_from_impl_more_than_one_element_in_tuple() {\n-        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One(u32, String) }\");\n+        check_not_applicable(\"enum A { <|>One(u32, String) }\");\n     }\n \n     #[test]\n     fn test_add_from_impl_struct_variant() {\n-        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One { x: u32 } }\");\n+        check_not_applicable(\"enum A { <|>One { x: u32 } }\");\n     }\n \n     #[test]\n     fn test_add_from_impl_already_exists() {\n-        check_assist_not_applicable(\n-            add_from_impl_for_enum,\n-            r#\"enum A { <|>One(u32), }\n+        covers!(test_add_from_impl_already_exists);\n+        check_not_applicable(\n+            r#\"\n+enum A { <|>One(u32), }\n \n impl From<u32> for A {\n     fn from(v: u32) -> Self {\n         A::One(v)\n     }\n }\n-\n-pub trait From<T> {\n-    fn from(T) -> Self;\n-}\"#,\n+\"#,\n         );\n     }\n "}, {"sha": "8d910205f0ab332d9fecc40cc94909e3c242abee", "filename": "crates/ra_assists/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fmarks.rs?ref=b4dd4752570d5f1ba24f7ffda69be4b1c935cd04", "patch": "@@ -8,4 +8,5 @@ test_utils::marks![\n     test_not_inline_mut_variable\n     test_not_applicable_if_variable_unused\n     change_visibility_field_false_positive\n+    test_add_from_impl_already_exists\n ];"}, {"sha": "efd9886978a59b8f9aedec2663cf0a13441a010f", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=b4dd4752570d5f1ba24f7ffda69be4b1c935cd04", "patch": "@@ -3,7 +3,7 @@ pub(crate) mod insert_use;\n \n use std::iter;\n \n-use hir::{Adt, Semantics, Type};\n+use hir::{Adt, Crate, Semantics, Trait, Type};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, make, NameOwner},\n@@ -149,3 +149,61 @@ impl TryEnum {\n         }\n     }\n }\n+\n+/// Helps with finding well-know things inside the standard library. This is\n+/// somewhat similar to the known paths infra inside hir, but it different; We\n+/// want to make sure that IDE specific paths don't become interesting inside\n+/// the compiler itself as well.\n+pub(crate) struct FamousDefs<'a, 'b>(pub(crate) &'a Semantics<'b, RootDatabase>, pub(crate) Crate);\n+\n+#[allow(non_snake_case)]\n+impl FamousDefs<'_, '_> {\n+    #[cfg(test)]\n+    pub(crate) const FIXTURE: &'static str = r#\"\n+//- /libcore.rs crate:core\n+pub mod convert{\n+    pub trait From<T> {\n+        fn from(T) -> Self;\n+    }\n+}\n+\n+pub mod prelude { pub use crate::convert::From }\n+#[prelude_import]\n+pub use prelude::*;\n+\"#;\n+\n+    pub(crate) fn core_convert_From(&self) -> Option<Trait> {\n+        self.find_trait(\"core:convert:From\")\n+    }\n+\n+    fn find_trait(&self, path: &str) -> Option<Trait> {\n+        let db = self.0.db;\n+        let mut path = path.split(':');\n+        let trait_ = path.next_back()?;\n+        let std_crate = path.next()?;\n+        let std_crate = self\n+            .1\n+            .dependencies(db)\n+            .into_iter()\n+            .find(|dep| &dep.name.to_string() == std_crate)?\n+            .krate;\n+\n+        let mut module = std_crate.root_module(db)?;\n+        for segment in path {\n+            module = module.children(db).find_map(|child| {\n+                let name = child.name(db)?;\n+                if &name.to_string() == segment {\n+                    Some(child)\n+                } else {\n+                    None\n+                }\n+            })?;\n+        }\n+        let def =\n+            module.scope(db, None).into_iter().find(|(name, _def)| &name.to_string() == trait_)?.1;\n+        match def {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "492088353254e9bcc18ce67d4d774ae4725ccd91", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4dd4752570d5f1ba24f7ffda69be4b1c935cd04/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=b4dd4752570d5f1ba24f7ffda69be4b1c935cd04", "patch": "@@ -22,8 +22,7 @@ pub fn path_unqualified(segment: ast::PathSegment) -> ast::Path {\n pub fn path_qualified(qual: ast::Path, segment: ast::PathSegment) -> ast::Path {\n     path_from_text(&format!(\"{}::{}\", qual, segment))\n }\n-\n-pub fn path_from_text(text: &str) -> ast::Path {\n+fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(text)\n }\n "}]}