{"sha": "70569b3d2d8d648faa2d0acf106d6ba065c082d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNTY5YjNkMmQ4ZDY0OGZhYTJkMGFjZjEwNmQ2YmEwNjVjMDgyZDI=", "commit": {"author": {"name": "Adam Perry", "email": "adam.n.perry@gmail.com", "date": "2016-10-09T18:36:12Z"}, "committer": {"name": "Adam Perry", "email": "adam.n.perry@gmail.com", "date": "2016-10-12T05:12:13Z"}, "message": "Using a type alias of Slice<Kind<'tcx>> to intern Substs<'tcx>.\n\nFixing now incorrect Hash impl for TransItem.\nUsing as_ptr() rather than a pointer cast for string formatting.\nFixing Borrow and Lift impls for Substs.\nMove usages of tcx.mk_substs to Substs::new iterator-based version.", "tree": {"sha": "07a63f709c32960787f06a7ce426bcc5da1b1f69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07a63f709c32960787f06a7ce426bcc5da1b1f69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70569b3d2d8d648faa2d0acf106d6ba065c082d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70569b3d2d8d648faa2d0acf106d6ba065c082d2", "html_url": "https://github.com/rust-lang/rust/commit/70569b3d2d8d648faa2d0acf106d6ba065c082d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70569b3d2d8d648faa2d0acf106d6ba065c082d2/comments", "author": {"login": "anp", "id": 6812281, "node_id": "MDQ6VXNlcjY4MTIyODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6812281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anp", "html_url": "https://github.com/anp", "followers_url": "https://api.github.com/users/anp/followers", "following_url": "https://api.github.com/users/anp/following{/other_user}", "gists_url": "https://api.github.com/users/anp/gists{/gist_id}", "starred_url": "https://api.github.com/users/anp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anp/subscriptions", "organizations_url": "https://api.github.com/users/anp/orgs", "repos_url": "https://api.github.com/users/anp/repos", "events_url": "https://api.github.com/users/anp/events{/privacy}", "received_events_url": "https://api.github.com/users/anp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anp", "id": 6812281, "node_id": "MDQ6VXNlcjY4MTIyODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6812281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anp", "html_url": "https://github.com/anp", "followers_url": "https://api.github.com/users/anp/followers", "following_url": "https://api.github.com/users/anp/following{/other_user}", "gists_url": "https://api.github.com/users/anp/gists{/gist_id}", "starred_url": "https://api.github.com/users/anp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anp/subscriptions", "organizations_url": "https://api.github.com/users/anp/orgs", "repos_url": "https://api.github.com/users/anp/repos", "events_url": "https://api.github.com/users/anp/events{/privacy}", "received_events_url": "https://api.github.com/users/anp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aa7f47fcc2d9f58c684aa5cbbd97ec873510990", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aa7f47fcc2d9f58c684aa5cbbd97ec873510990", "html_url": "https://github.com/rust-lang/rust/commit/9aa7f47fcc2d9f58c684aa5cbbd97ec873510990"}], "stats": {"total": 167, "additions": 68, "deletions": 99}, "files": [{"sha": "20955dfa432625c1bb7bcaa2c2919677330a954e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=70569b3d2d8d648faa2d0acf106d6ba065c082d2", "patch": "@@ -25,7 +25,7 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::region::CodeExtent;\n use mir::tcx::LvalueTy;\n-use ty::subst::{Subst, Substs};\n+use ty::subst::{Kind, Subst, Substs};\n use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n@@ -1208,7 +1208,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn type_var_for_def(&self,\n                             span: Span,\n                             def: &ty::TypeParameterDef<'tcx>,\n-                            substs: &Substs<'tcx>)\n+                            substs: &[Kind<'tcx>])\n                             -> Ty<'tcx> {\n         let default = def.default.map(|default| {\n             type_variable::Default {"}, {"sha": "455a7cefdc536c6687625097d78d05a38934b26d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=70569b3d2d8d648faa2d0acf106d6ba065c082d2", "patch": "@@ -22,7 +22,7 @@ use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n use middle::stability;\n-use ty::subst::Substs;\n+use ty::subst::{Kind, Substs};\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n@@ -55,7 +55,7 @@ pub struct CtxtArenas<'tcx> {\n     // internings\n     type_: TypedArena<TyS<'tcx>>,\n     type_list: TypedArena<Vec<Ty<'tcx>>>,\n-    substs: TypedArena<Substs<'tcx>>,\n+    substs: TypedArena<Vec<Kind<'tcx>>>,\n     bare_fn: TypedArena<BareFnTy<'tcx>>,\n     region: TypedArena<Region>,\n     stability: TypedArena<attr::Stability>,\n@@ -824,7 +824,7 @@ impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n-        if let Some(&Interned(substs)) = tcx.interners.substs.borrow().get(*self) {\n+        if let Some(&Interned(substs)) = tcx.interners.substs.borrow().get(&self[..]) {\n             if *self as *const _ == substs as *const _ {\n                 return Some(substs);\n             }\n@@ -1097,9 +1097,9 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, Slice<Ty<'tcx>>> {\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<Substs<'lcx>> for Interned<'tcx, Substs<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a Substs<'lcx> {\n-        self.0\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a [Kind<'lcx>] {\n+        &self.0[..]\n     }\n }\n \n@@ -1189,9 +1189,6 @@ fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n }\n \n direct_interners!('tcx,\n-    substs: mk_substs(|substs: &Substs| {\n-        substs.params().iter().any(keep_local)\n-    }) -> Substs<'tcx>,\n     bare_fn: mk_bare_fn(|fty: &BareFnTy| {\n         keep_local(&fty.sig)\n     }) -> BareFnTy<'tcx>,\n@@ -1209,6 +1206,12 @@ intern_method!('tcx,\n     }, keep_local) -> Slice<Ty<'tcx>>\n );\n \n+intern_method!('tcx,\n+    substs: mk_substs(Vec<Kind<'tcx>>, Deref::deref, |xs: &[Kind]| -> &Slice<Kind> {\n+        unsafe { mem::transmute(xs) }\n+    }, keep_local) -> Slice<Kind<'tcx>>\n+);\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {"}, {"sha": "14deb6820ee85b660144b7eb4ba35d29a136521d", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 46, "deletions": 59, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=70569b3d2d8d648faa2d0acf106d6ba065c082d2", "patch": "@@ -11,7 +11,7 @@\n // Type substitutions.\n \n use hir::def_id::DefId;\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, Slice, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -161,26 +161,19 @@ impl<'tcx> Decodable for Kind<'tcx> {\n }\n \n /// A substitution mapping type/region parameters to new values.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable)]\n-pub struct Substs<'tcx> {\n-    params: Vec<Kind<'tcx>>\n-}\n+pub type Substs<'tcx> = Slice<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     pub fn new<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>, params: I)\n                   -> &'tcx Substs<'tcx>\n     where I: IntoIterator<Item=Kind<'tcx>> {\n-        tcx.mk_substs(Substs {\n-            params: params.into_iter().collect()\n-        })\n+        tcx.mk_substs(params.into_iter().collect())\n     }\n \n     pub fn maybe_new<I, E>(tcx: TyCtxt<'a, 'gcx, 'tcx>, params: I)\n                            -> Result<&'tcx Substs<'tcx>, E>\n     where I: IntoIterator<Item=Result<Kind<'tcx>, E>> {\n-        Ok(tcx.mk_substs(Substs {\n-            params: params.into_iter().collect::<Result<_, _>>()?\n-        }))\n+        Ok(Substs::new(tcx, params.into_iter().collect::<Result<Vec<_>, _>>()?))\n     }\n \n     pub fn new_trait(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -193,7 +186,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     pub fn empty(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n-        Substs::new(tcx, vec![])\n+        Substs::new(tcx, iter::empty())\n     }\n \n     /// Creates a Substs for generic parameter definitions,\n@@ -206,82 +199,81 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             mut mk_region: FR,\n                             mut mk_type: FT)\n                             -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> &'tcx ty::Region,\n-          FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n         let defs = tcx.lookup_generics(def_id);\n-        let mut substs = Substs {\n-            params: Vec::with_capacity(defs.count())\n-        };\n+        let mut substs = Vec::with_capacity(defs.count());\n \n-        substs.fill_item(tcx, defs, &mut mk_region, &mut mk_type);\n+        Substs::fill_item(&mut substs, tcx, defs, &mut mk_region, &mut mk_type);\n \n-        tcx.mk_substs(substs)\n+        Substs::new(tcx, substs)\n     }\n \n-    fn fill_item<FR, FT>(&mut self,\n+    fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          defs: &ty::Generics<'tcx>,\n                          mk_region: &mut FR,\n                          mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> &'tcx ty::Region,\n-          FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n+\n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.lookup_generics(def_id);\n-            self.fill_item(tcx, parent_defs, mk_region, mk_type);\n+            Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n         }\n \n         // Handle Self first, before all regions.\n         let mut types = defs.types.iter();\n         if defs.parent.is_none() && defs.has_self {\n             let def = types.next().unwrap();\n-            let ty = mk_type(def, self);\n-            assert_eq!(def.index as usize, self.params.len());\n-            self.params.push(Kind::from(ty));\n+            let ty = mk_type(def, substs);\n+            assert_eq!(def.index as usize, substs.len());\n+            substs.push(Kind::from(ty));\n         }\n \n         for def in &defs.regions {\n-            let region = mk_region(def, self);\n-            assert_eq!(def.index as usize, self.params.len());\n-            self.params.push(Kind::from(region));\n+            let region = mk_region(def, substs);\n+            assert_eq!(def.index as usize, substs.len());\n+            substs.push(Kind::from(region));\n         }\n \n         for def in types {\n-            let ty = mk_type(def, self);\n-            assert_eq!(def.index as usize, self.params.len());\n-            self.params.push(Kind::from(ty));\n+            let ty = mk_type(def, substs);\n+            assert_eq!(def.index as usize, substs.len());\n+            substs.push(Kind::from(ty));\n         }\n     }\n \n     pub fn is_noop(&self) -> bool {\n-        self.params.is_empty()\n+        self.is_empty()\n     }\n \n     #[inline]\n     pub fn params(&self) -> &[Kind<'tcx>] {\n-        &self.params\n+        &self\n     }\n \n     #[inline]\n     pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n-        self.params.iter().filter_map(|k| k.as_type())\n+        self.iter().filter_map(|k| k.as_type())\n     }\n \n     #[inline]\n     pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=&'tcx ty::Region> + 'a {\n-        self.params.iter().filter_map(|k| k.as_region())\n+        self.iter().filter_map(|k| k.as_region())\n     }\n \n     #[inline]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n-        self.params[i].as_type().unwrap_or_else(|| {\n-            bug!(\"expected type for param #{} in {:?}\", i, self.params);\n+        self[i].as_type().unwrap_or_else(|| {\n+            bug!(\"expected type for param #{} in {:?}\", i, self);\n         })\n     }\n \n     #[inline]\n     pub fn region_at(&self, i: usize) -> &'tcx ty::Region {\n-        self.params[i].as_region().unwrap_or_else(|| {\n-            bug!(\"expected region for param #{} in {:?}\", i, self.params);\n+        self[i].as_region().unwrap_or_else(|| {\n+            bug!(\"expected region for param #{} in {:?}\", i, self);\n         })\n     }\n \n@@ -305,27 +297,22 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n         let defs = tcx.lookup_generics(source_ancestor);\n-        tcx.mk_substs(Substs {\n-            params: target_substs.params.iter()\n-                .chain(&self.params[defs.own_count()..]).cloned().collect()\n-        })\n+        Substs::new(tcx, target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let params = self.params.iter().map(|k| k.fold_with(folder)).collect();\n-        folder.tcx().mk_substs(Substs {\n-            params: params\n-        })\n+        let params = self.iter().map(|k| k.fold_with(folder)).collect();\n+        folder.tcx().mk_substs(params)\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_substs(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.params.visit_with(visitor)\n+        self.iter().any(|t| t.visit_with(visitor))\n     }\n }\n \n@@ -340,19 +327,19 @@ impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n pub trait Subst<'tcx> : Sized {\n     fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      substs: &Substs<'tcx>) -> Self {\n+                      substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n     fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                               substs: &Substs<'tcx>,\n+                               substs: &[Kind<'tcx>],\n                                span: Option<Span>)\n                                -> Self;\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n     fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                               substs: &Substs<'tcx>,\n+                               substs: &[Kind<'tcx>],\n                                span: Option<Span>)\n                                -> T\n     {\n@@ -371,7 +358,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n \n struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    substs: &'a Substs<'tcx>,\n+    substs: &'a [Kind<'tcx>],\n \n     // The location for which the substitution is performed, if available.\n     span: Option<Span>,\n@@ -404,7 +391,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         // the specialized routine `ty::replace_late_regions()`.\n         match *r {\n             ty::ReEarlyBound(data) => {\n-                let r = self.substs.params.get(data.index as usize)\n+                let r = self.substs.get(data.index as usize)\n                             .and_then(|k| k.as_region());\n                 match r {\n                     Some(r) => {\n@@ -461,7 +448,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.params.get(p.idx as usize)\n+        let opt_ty = self.substs.get(p.idx as usize)\n                          .and_then(|k| k.as_type());\n         let ty = match opt_ty {\n             Some(t) => t,\n@@ -475,7 +462,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n                     source_ty,\n                     p.idx,\n                     self.root_ty,\n-                    self.substs.params);\n+                    self.substs);\n             }\n         };\n \n@@ -552,7 +539,7 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        -> ty::TraitRef<'tcx> {\n         let defs = tcx.lookup_generics(trait_id);\n \n-        let params = substs.params[..defs.own_count()].iter().cloned();\n+        let params = substs[..defs.own_count()].iter().cloned();\n         ty::TraitRef {\n             def_id: trait_id,\n             substs: Substs::new(tcx, params)\n@@ -567,7 +554,7 @@ impl<'a, 'gcx, 'tcx> ty::ExistentialTraitRef<'tcx> {\n         // Assert there is a Self.\n         trait_ref.substs.type_at(0);\n \n-        let params = trait_ref.substs.params[1..].iter().cloned();\n+        let params = trait_ref.substs[1..].iter().cloned();\n         ty::ExistentialTraitRef {\n             def_id: trait_ref.def_id,\n             substs: Substs::new(tcx, params)\n@@ -587,7 +574,7 @@ impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n         assert!(!self_ty.has_escaping_regions());\n \n         self.map_bound(|trait_ref| {\n-            let params = trait_ref.substs.params.iter().cloned();\n+            let params = trait_ref.substs.iter().cloned();\n             let params = iter::once(Kind::from(self_ty)).chain(params);\n             ty::TraitRef {\n                 def_id: trait_ref.def_id,"}, {"sha": "3f3268bb569a303a999616731adc0d04b6c3e1df", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=70569b3d2d8d648faa2d0acf106d6ba065c082d2", "patch": "@@ -28,41 +28,20 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n use rustc_const_eval::fatal_const_eval_err;\n-use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n use type_of;\n use glue;\n use abi::{Abi, FnType};\n use back::symbol_names;\n \n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum TransItem<'tcx> {\n     DropGlue(DropGlueKind<'tcx>),\n     Fn(Instance<'tcx>),\n     Static(NodeId)\n }\n \n-impl<'tcx> Hash for TransItem<'tcx> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        match *self {\n-            TransItem::DropGlue(t) => {\n-                0u8.hash(s);\n-                t.hash(s);\n-            },\n-            TransItem::Fn(instance) => {\n-                1u8.hash(s);\n-                instance.def.hash(s);\n-                (instance.substs as *const _ as usize).hash(s);\n-            }\n-            TransItem::Static(node_id) => {\n-                2u8.hash(s);\n-                node_id.hash(s);\n-            }\n-        };\n-    }\n-}\n-\n impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n@@ -359,7 +338,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n                          instance.def,\n-                         instance.substs as *const _ as usize)\n+                         instance.substs.as_ptr() as usize)\n             }\n             TransItem::Static(id) => {\n                 format!(\"Static({:?})\", id)"}, {"sha": "4e780537706efb571b00bb0f4cd5deb59d35b3e7", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=70569b3d2d8d648faa2d0acf106d6ba065c082d2", "patch": "@@ -55,7 +55,7 @@ use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -124,7 +124,7 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// Same as ty_infer, but with a known type parameter definition.\n     fn ty_infer_for_def(&self,\n                         _def: &ty::TypeParameterDef<'tcx>,\n-                        _substs: &Substs<'tcx>,\n+                        _substs: &[Kind<'tcx>],\n                         span: Span) -> Ty<'tcx> {\n         self.ty_infer(span)\n     }\n@@ -620,7 +620,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn convert_parenthesized_parameters(&self,\n                                         rscope: &RegionScope,\n-                                        region_substs: &Substs<'tcx>,\n+                                        region_substs: &[Kind<'tcx>],\n                                         data: &hir::ParenthesizedParameterData)\n                                         -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n     {\n@@ -1431,7 +1431,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn ast_ty_arg_to_ty(&self,\n                         rscope: &RegionScope,\n                         def: Option<&ty::TypeParameterDef<'tcx>>,\n-                        region_substs: &Substs<'tcx>,\n+                        region_substs: &[Kind<'tcx>],\n                         ast_ty: &hir::Ty)\n                         -> Ty<'tcx>\n     {"}, {"sha": "0a810f599910fc447ad90d51f18698801b1be99d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70569b3d2d8d648faa2d0acf106d6ba065c082d2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=70569b3d2d8d648faa2d0acf106d6ba065c082d2", "patch": "@@ -87,7 +87,7 @@ use hir::def::{Def, CtorKind, PathResolution};\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n@@ -1361,7 +1361,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn ty_infer_for_def(&self,\n                         ty_param_def: &ty::TypeParameterDef<'tcx>,\n-                        substs: &Substs<'tcx>,\n+                        substs: &[Kind<'tcx>],\n                         span: Span) -> Ty<'tcx> {\n         self.type_var_for_def(span, ty_param_def, substs)\n     }"}]}