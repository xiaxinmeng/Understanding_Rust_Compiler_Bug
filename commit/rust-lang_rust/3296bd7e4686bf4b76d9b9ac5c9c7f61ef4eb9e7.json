{"sha": "3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOTZiZDdlNDY4NmJmNGI3NmQ5YjlhYzVjOWM3ZjYxZWY0ZWI5ZTc=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-04T01:10:04Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-08T19:06:21Z"}, "message": "Rename slice::unzip() to vec::unzip()\n\nunzip() has nothing to do with slices, so it belongs in vec.", "tree": {"sha": "bf754254629c4597314e035ba0ceca82e162f75c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf754254629c4597314e035ba0ceca82e162f75c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7", "html_url": "https://github.com/rust-lang/rust/commit/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "html_url": "https://github.com/rust-lang/rust/commit/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e"}], "stats": {"total": 74, "additions": 38, "deletions": 36}, "files": [{"sha": "9c03fb27e39a271dbd3f9ba27dfa39d94a825dff", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7", "patch": "@@ -33,7 +33,7 @@ use middle::ty;\n use util::ppaux::{Repr, ty_to_str};\n \n use std::c_str::ToCStr;\n-use std::slice;\n+use std::{slice, vec};\n use std::vec::Vec;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n@@ -94,7 +94,7 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = slice::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n+    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n         C_struct(cx, vs, false)\n@@ -539,7 +539,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               };\n \n               expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n-                  let (cs, inlineable) = slice::unzip(field_tys.iter().enumerate()\n+                  let (cs, inlineable) = vec::unzip(field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n                           Some(f) => const_expr(cx, (*f).expr, is_local),"}, {"sha": "17c09b0a427f38b28f31b506bd0517d9220e3f29", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7", "patch": "@@ -155,25 +155,6 @@ impl<'a, T: Clone, V: Vector<T>> VectorVector<T> for &'a [V] {\n     }\n }\n \n-/**\n- * Convert an iterator of pairs into a pair of vectors.\n- *\n- * Returns a tuple containing two vectors where the i-th element of the first\n- * vector contains the first element of the i-th tuple of the input iterator,\n- * and the i-th element of the second vector contains the second element\n- * of the i-th tuple of the input iterator.\n- */\n-pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {\n-    let (lo, _) = iter.size_hint();\n-    let mut ts = Vec::with_capacity(lo);\n-    let mut us = Vec::with_capacity(lo);\n-    for (t, u) in iter {\n-        ts.push(t);\n-        us.push(u);\n-    }\n-    (ts.move_iter().collect(), us.move_iter().collect())\n-}\n-\n /// An Iterator that yields the element swaps needed to produce\n /// a sequence of all possible permutations for an indexed sequence of\n /// elements. Each permutation is only a single swap apart.\n@@ -1242,18 +1223,6 @@ mod tests {\n         assert_eq!(v, vec![1, 3, 5]);\n     }\n \n-    #[test]\n-    fn test_zip_unzip() {\n-        let z1 = vec![(1, 4), (2, 5), (3, 6)];\n-\n-        let (left, right) = unzip(z1.iter().map(|&x| x));\n-\n-        let (left, right) = (left.as_slice(), right.as_slice());\n-        assert_eq!((1, 4), (left[0], right[0]));\n-        assert_eq!((2, 5), (left[1], right[1]));\n-        assert_eq!((3, 6), (left[2], right[2]));\n-    }\n-\n     #[test]\n     fn test_element_swaps() {\n         let mut v = [1, 2, 3];"}, {"sha": "8dfd691e6ffdc09f500af0e84d4d8c26a5aad01f", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7", "patch": "@@ -407,7 +407,7 @@ mod tests {\n     use rand::Rng;\n     use sync::atomics::{AtomicBool, INIT_ATOMIC_BOOL, SeqCst,\n                         AtomicUint, INIT_ATOMIC_UINT};\n-    use slice;\n+    use vec;\n \n     #[test]\n     fn smoke() {\n@@ -603,7 +603,7 @@ mod tests {\n         let mut pool = BufferPool::<(int, uint)>::new();\n         let (mut w, s) = pool.deque();\n \n-        let (threads, hits) = slice::unzip(range(0, NTHREADS).map(|_| {\n+        let (threads, hits) = vec::unzip(range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n             let unique_box = box AtomicUint::new(0);\n             let thread_box = unsafe {"}, {"sha": "257dcc0fcfe33818018aeee51df849d59d99b37f", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=3296bd7e4686bf4b76d9b9ac5c9c7f61ef4eb9e7", "patch": "@@ -1436,10 +1436,31 @@ impl<T> Drop for MoveItems<T> {\n     }\n }\n \n+/**\n+ * Convert an iterator of pairs into a pair of vectors.\n+ *\n+ * Returns a tuple containing two vectors where the i-th element of the first\n+ * vector contains the first element of the i-th tuple of the input iterator,\n+ * and the i-th element of the second vector contains the second element\n+ * of the i-th tuple of the input iterator.\n+ */\n+pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n+    let (lo, _) = iter.size_hint();\n+    let mut ts = Vec::with_capacity(lo);\n+    let mut us = Vec::with_capacity(lo);\n+    for (t, u) in iter {\n+        ts.push(t);\n+        us.push(u);\n+    }\n+    (ts, us)\n+}\n+\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use mem::size_of;\n+    use super::unzip;\n \n     #[test]\n     fn test_small_vec_struct() {\n@@ -1687,4 +1708,16 @@ mod tests {\n         assert_eq!([&[1], &[2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n         assert_eq!([&[1], &[2], &[3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n+\n+    #[test]\n+    fn test_zip_unzip() {\n+        let z1 = vec![(1, 4), (2, 5), (3, 6)];\n+\n+        let (left, right) = unzip(z1.iter().map(|&x| x));\n+\n+        let (left, right) = (left.as_slice(), right.as_slice());\n+        assert_eq!((1, 4), (left[0], right[0]));\n+        assert_eq!((2, 5), (left[1], right[1]));\n+        assert_eq!((3, 6), (left[2], right[2]));\n+    }\n }"}]}