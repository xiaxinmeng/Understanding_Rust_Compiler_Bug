{"sha": "9e0171f7c8e3ac30f7219a8c3154775e3996a789", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMDE3MWY3YzhlM2FjMzBmNzIxOWE4YzMxNTQ3NzVlMzk5NmE3ODk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-17T15:33:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-17T19:47:39Z"}, "message": "remove vestiges of the old suggestion machinery", "tree": {"sha": "23f0916e5e4882760c167c17a19edcd2de14cf67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f0916e5e4882760c167c17a19edcd2de14cf67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e0171f7c8e3ac30f7219a8c3154775e3996a789", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e0171f7c8e3ac30f7219a8c3154775e3996a789", "html_url": "https://github.com/rust-lang/rust/commit/9e0171f7c8e3ac30f7219a8c3154775e3996a789", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e0171f7c8e3ac30f7219a8c3154775e3996a789/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5167ac87199cbf58d9cc46e3ba34dd3d75c88e4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5167ac87199cbf58d9cc46e3ba34dd3d75c88e4c", "html_url": "https://github.com/rust-lang/rust/commit/5167ac87199cbf58d9cc46e3ba34dd3d75c88e4c"}], "stats": {"total": 377, "additions": 117, "deletions": 260}, "files": [{"sha": "9295fb2ee327b4f5910b4c29be7b12c8fc4491a6", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 24, "deletions": 221, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=9e0171f7c8e3ac30f7219a8c3154775e3996a789", "patch": "@@ -65,9 +65,6 @@ use super::region_inference::ConcreteFailure;\n use super::region_inference::SubSupConflict;\n use super::region_inference::GenericBoundFailure;\n use super::region_inference::GenericKind;\n-use super::region_inference::ProcessedErrors;\n-use super::region_inference::ProcessedErrorOrigin;\n-use super::region_inference::SameRegions;\n \n use hir::map as hir_map;\n use hir;\n@@ -77,11 +74,10 @@ use infer;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n-use ty::{Region, ReFree, Issue32330};\n+use ty::{Region, Issue32330};\n use ty::error::TypeError;\n \n use std::fmt;\n-use syntax::ast;\n use syntax_pos::{Pos, Span};\n use errors::DiagnosticBuilder;\n \n@@ -255,8 +251,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // try to pre-process the errors, which will group some of them\n         // together into a `ProcessedErrors` group:\n-        let processed_errors = self.process_errors(errors);\n-        let errors = processed_errors.as_ref().unwrap_or(errors);\n+        let errors = self.process_errors(errors);\n \n         debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n \n@@ -278,13 +273,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                  sub_origin, sub_r,\n                                                  sup_origin, sup_r);\n                 }\n-\n-                ProcessedErrors(ref origins,\n-                                ref same_regions) => {\n-                    if !same_regions.is_empty() {\n-                        self.report_processed_errors(origins);\n-                    }\n-                }\n             }\n         }\n     }\n@@ -300,202 +288,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // duplicates that will be unhelpful to the end-user. But\n     // obviously it never weeds out ALL errors.\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Option<Vec<RegionResolutionError<'tcx>>> {\n+                      -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n-        let mut origins = Vec::new();\n-\n-        // we collect up ConcreteFailures and SubSupConflicts that are\n-        // relating free-regions bound on the fn-header and group them\n-        // together into this vector\n-        let mut same_regions = Vec::new();\n-\n-        // here we put errors that we will not be able to process nicely\n-        let mut other_errors = Vec::new();\n-\n-        // we collect up GenericBoundFailures in here.\n-        let mut bound_failures = Vec::new();\n-\n-        for error in errors {\n-            // Check whether we can process this error into some other\n-            // form; if not, fall through.\n-            match *error {\n-                ConcreteFailure(ref origin, sub, sup) => {\n-                    debug!(\"processing ConcreteFailure\");\n-                    if let SubregionOrigin::CompareImplMethodObligation { .. } = *origin {\n-                        // When comparing an impl method against a\n-                        // trait method, it is not helpful to suggest\n-                        // changes to the impl method.  This is\n-                        // because the impl method signature is being\n-                        // checked using the trait's environment, so\n-                        // usually the changes we suggest would\n-                        // actually have to be applied to the *trait*\n-                        // method (and it's not clear that the trait\n-                        // method is even under the user's control).\n-                    } else if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n-                        origins.push(\n-                            ProcessedErrorOrigin::ConcreteFailure(\n-                                origin.clone(),\n-                                sub,\n-                                sup));\n-                        append_to_same_regions(&mut same_regions, &same_frs);\n-                        continue;\n-                    }\n-                }\n-                SubSupConflict(ref var_origin, ref sub_origin, sub, ref sup_origin, sup) => {\n-                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub, sup);\n-                    match (sub_origin, sup_origin) {\n-                        (&SubregionOrigin::CompareImplMethodObligation { .. }, _) => {\n-                            // As above, when comparing an impl method\n-                            // against a trait method, it is not helpful\n-                            // to suggest changes to the impl method.\n-                        }\n-                        (_, &SubregionOrigin::CompareImplMethodObligation { .. }) => {\n-                            // See above.\n-                        }\n-                        _ => {\n-                            if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n-                                origins.push(\n-                                    ProcessedErrorOrigin::VariableFailure(\n-                                        var_origin.clone()));\n-                                append_to_same_regions(&mut same_regions, &same_frs);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n-                GenericBoundFailure(ref origin, ref kind, region) => {\n-                    bound_failures.push((origin.clone(), kind.clone(), region));\n-                    continue;\n-                }\n-                ProcessedErrors(..) => {\n-                    bug!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n-                }\n-            }\n-\n-            // No changes to this error.\n-            other_errors.push(error.clone());\n-        }\n-\n-        // ok, let's pull together the errors, sorted in an order that\n-        // we think will help user the best\n-        let mut processed_errors = vec![];\n-\n-        // first, put the processed errors, if any\n-        if !same_regions.is_empty() {\n-            let common_scope_id = same_regions[0].scope_id;\n-            for sr in &same_regions {\n-                // Since ProcessedErrors is used to reconstruct the function\n-                // declaration, we want to make sure that they are, in fact,\n-                // from the same scope\n-                if sr.scope_id != common_scope_id {\n-                    debug!(\"returning empty result from process_errors because\n-                            {} != {}\", sr.scope_id, common_scope_id);\n-                    return None;\n-                }\n-            }\n-            assert!(origins.len() > 0);\n-            let pe = ProcessedErrors(origins, same_regions);\n-            debug!(\"errors processed: {:?}\", pe);\n-            processed_errors.push(pe);\n-        }\n-\n-        // next, put the other misc errors\n-        processed_errors.extend(other_errors);\n-\n-        // finally, put the `T: 'a` errors, but only if there were no\n-        // other errors. otherwise, these have a very high rate of\n-        // being unhelpful in practice. This is because they are\n-        // basically secondary checks that test the state of the\n-        // region graph after the rest of inference is done, and the\n-        // other kinds of errors indicate that the region constraint\n-        // graph is internally inconsistent, so these test results are\n-        // likely to be meaningless.\n-        if processed_errors.is_empty() {\n-            for (origin, kind, region) in bound_failures {\n-                processed_errors.push(GenericBoundFailure(origin, kind, region));\n-            }\n-        }\n \n-        // we should always wind up with SOME errors, unless there were no\n-        // errors to start\n-        assert!(if errors.len() > 0 {processed_errors.len() > 0} else {true});\n-\n-        return Some(processed_errors);\n-\n-        #[derive(Debug)]\n-        struct FreeRegionsFromSameFn {\n-            sub_fr: ty::FreeRegion,\n-            sup_fr: ty::FreeRegion,\n-            scope_id: ast::NodeId\n-        }\n-\n-        impl FreeRegionsFromSameFn {\n-            fn new(sub_fr: ty::FreeRegion,\n-                   sup_fr: ty::FreeRegion,\n-                   scope_id: ast::NodeId)\n-                   -> FreeRegionsFromSameFn {\n-                FreeRegionsFromSameFn {\n-                    sub_fr: sub_fr,\n-                    sup_fr: sup_fr,\n-                    scope_id: scope_id\n-                }\n-            }\n-        }\n-\n-        fn free_regions_from_same_fn<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                     sub: &'tcx Region,\n-                                                     sup: &'tcx Region)\n-                                                     -> Option<FreeRegionsFromSameFn> {\n-            debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n-            let (scope_id, fr1, fr2) = match (sub, sup) {\n-                (&ReFree(fr1), &ReFree(fr2)) => {\n-                    if fr1.scope != fr2.scope {\n-                        return None\n-                    }\n-                    assert!(fr1.scope == fr2.scope);\n-                    (fr1.scope.node_id(&tcx.region_maps), fr1, fr2)\n-                },\n-                _ => return None\n-            };\n-            let parent = tcx.hir.get_parent(scope_id);\n-            let parent_node = tcx.hir.find(parent);\n-            match parent_node {\n-                Some(node) => match node {\n-                    hir_map::NodeItem(item) => match item.node {\n-                        hir::ItemFn(..) => {\n-                            Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n-                        },\n-                        _ => None\n-                    },\n-                    hir_map::NodeImplItem(..) |\n-                    hir_map::NodeTraitItem(..) => {\n-                        Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n-                    },\n-                    _ => None\n-                },\n-                None => {\n-                    debug!(\"no parent node of scope_id {}\", scope_id);\n-                    None\n-                }\n-            }\n-        }\n+        // We want to avoid reporting generic-bound failures if we can\n+        // avoid it: these have a very high rate of being unhelpful in\n+        // practice. This is because they are basically secondary\n+        // checks that test the state of the region graph after the\n+        // rest of inference is done, and the other kinds of errors\n+        // indicate that the region constraint graph is internally\n+        // inconsistent, so these test results are likely to be\n+        // meaningless.\n+        //\n+        // Therefore, we filter them out of the list unless they are\n+        // the only thing in the list.\n+\n+        let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n+            ConcreteFailure(..) => false,\n+            SubSupConflict(..) => false,\n+            GenericBoundFailure(..) => true,\n+        };\n \n-        fn append_to_same_regions(same_regions: &mut Vec<SameRegions>,\n-                                  same_frs: &FreeRegionsFromSameFn) {\n-            debug!(\"append_to_same_regions(same_regions={:?}, same_frs={:?})\",\n-                   same_regions, same_frs);\n-            let scope_id = same_frs.scope_id;\n-            let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n-            for sr in same_regions.iter_mut() {\n-                if sr.contains(&sup_fr.bound_region) && scope_id == sr.scope_id {\n-                    sr.push(sub_fr.bound_region);\n-                    return\n-                }\n-            }\n-            same_regions.push(SameRegions {\n-                scope_id: scope_id,\n-                regions: vec![sub_fr.bound_region, sup_fr.bound_region]\n-            })\n+        if errors.iter().all(|e| is_bound_failure(e)) {\n+            errors.clone()\n+        } else {\n+            errors.iter().filter(|&e| !is_bound_failure(e)).cloned().collect()\n         }\n     }\n \n@@ -1072,20 +889,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.note_region_origin(&mut err, &sub_origin);\n         err.emit();\n     }\n-\n-    fn report_processed_errors(&self,\n-                               origins: &[ProcessedErrorOrigin<'tcx>]) {\n-        for origin in origins.iter() {\n-            let mut err = match *origin {\n-                ProcessedErrorOrigin::VariableFailure(ref var_origin) =>\n-                    self.report_inference_failure(var_origin.clone()),\n-                ProcessedErrorOrigin::ConcreteFailure(ref sr_origin, sub, sup) =>\n-                    self.report_concrete_failure(sr_origin.clone(), sub, sup),\n-            };\n-\n-            err.emit();\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "0bb9e2c7fa15c91345ea6c7ec0c7acb630d91410", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=9e0171f7c8e3ac30f7219a8c3154775e3996a789", "patch": "@@ -24,7 +24,7 @@ use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n use ty::{self, Ty, TyCtxt};\n-use ty::{BoundRegion, Region, RegionVid};\n+use ty::{Region, RegionVid};\n use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n \n@@ -171,13 +171,6 @@ pub enum RegionResolutionError<'tcx> {\n                    &'tcx Region,\n                    SubregionOrigin<'tcx>,\n                    &'tcx Region),\n-\n-    /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n-    /// more specific errors message by suggesting to the user where they\n-    /// should put a lifetime. In those cases we process and put those errors\n-    /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<ProcessedErrorOrigin<'tcx>>,\n-                    Vec<SameRegions>),\n }\n \n #[derive(Clone, Debug)]\n@@ -186,33 +179,6 @@ pub enum ProcessedErrorOrigin<'tcx> {\n     VariableFailure(RegionVariableOrigin),\n }\n \n-/// SameRegions is used to group regions that we think are the same and would\n-/// like to indicate so to the user.\n-/// For example, the following function\n-/// ```\n-/// struct Foo { bar: i32 }\n-/// fn foo2<'a, 'b>(x: &'a Foo) -> &'b i32 {\n-///    &x.bar\n-/// }\n-/// ```\n-/// would report an error because we expect 'a and 'b to match, and so we group\n-/// 'a and 'b together inside a SameRegions struct\n-#[derive(Clone, Debug)]\n-pub struct SameRegions {\n-    pub scope_id: ast::NodeId,\n-    pub regions: Vec<BoundRegion>,\n-}\n-\n-impl SameRegions {\n-    pub fn contains(&self, other: &BoundRegion) -> bool {\n-        self.regions.contains(other)\n-    }\n-\n-    pub fn push(&mut self, other: BoundRegion) {\n-        self.regions.push(other);\n-    }\n-}\n-\n pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {"}, {"sha": "9724d17bef1eaf446e77c95e0a0d7b59975fe0e1", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=9e0171f7c8e3ac30f7219a8c3154775e3996a789", "patch": "@@ -108,9 +108,6 @@ impl Debug for Player {\n \n fn str_to_direction(to_parse: &str) -> RoomDirection {\n     match to_parse { //~ ERROR match arms have incompatible types\n-    //~^ expected enum `RoomDirection`, found enum `std::option::Option`\n-    //~| expected type `RoomDirection`\n-    //~| found type `std::option::Option<_>`\n         \"w\" | \"west\" => RoomDirection::West,\n         \"e\" | \"east\" => RoomDirection::East,\n         \"n\" | \"north\" => RoomDirection::North,\n@@ -119,7 +116,7 @@ fn str_to_direction(to_parse: &str) -> RoomDirection {\n         \"out\" => RoomDirection::Out,\n         \"up\" => RoomDirection::Up,\n         \"down\" => RoomDirection::Down,\n-        _ => None //~ NOTE match arm with an incompatible type\n+        _ => None\n     }\n }\n "}, {"sha": "755b71d4a1d9e9eabb90fbfaacda6d517096d634", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.stderr", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr?ref=9e0171f7c8e3ac30f7219a8c3154775e3996a789", "patch": "@@ -3,6 +3,35 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n    |\n 16 |     let z = Ref { data: y.data };\n    |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let z = Ref { data: y.data };\n+17 | |     x.push(z);\n+18 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2c-push-inference-variable.rs:16:25\n+   |\n+16 |     let z = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let z = Ref { data: y.data };\n+17 | |     x.push(z);\n+18 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected Ref<'b, i32>, found Ref<'_, i32>)\n+  --> $DIR/ex2c-push-inference-variable.rs:17:12\n+   |\n+17 |     x.push(z);\n+   |            ^\n \n error: aborting due to previous error\n "}, {"sha": "daa6ea2d91aa3b567334a89cf84fad9a32e713ab", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.stderr", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr?ref=9e0171f7c8e3ac30f7219a8c3154775e3996a789", "patch": "@@ -3,6 +3,37 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n    |\n 17 |     let b = Ref { data: y.data };\n    |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     a.push(b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2d-push-inference-variable-2.rs:17:25\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     a.push(b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n+  --> $DIR/ex2d-push-inference-variable-2.rs:16:33\n+   |\n+16 |     let a: &mut Vec<Ref<i32>> = x;\n+   |                                 ^\n \n error: aborting due to previous error\n "}, {"sha": "b679532a4d91086ef85d0a22b5a81541e9780e01", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.stderr", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e0171f7c8e3ac30f7219a8c3154775e3996a789/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr?ref=9e0171f7c8e3ac30f7219a8c3154775e3996a789", "patch": "@@ -3,6 +3,37 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n    |\n 17 |     let b = Ref { data: y.data };\n    |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     Vec::push(a, b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2e-push-inference-variable-3.rs:17:25\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     Vec::push(a, b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n+  --> $DIR/ex2e-push-inference-variable-3.rs:16:33\n+   |\n+16 |     let a: &mut Vec<Ref<i32>> = x;\n+   |                                 ^\n \n error: aborting due to previous error\n "}]}