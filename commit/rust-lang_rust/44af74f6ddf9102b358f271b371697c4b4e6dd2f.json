{"sha": "44af74f6ddf9102b358f271b371697c4b4e6dd2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0YWY3NGY2ZGRmOTEwMmIzNThmMjcxYjM3MTY5N2M0YjRlNmRkMmY=", "commit": {"author": {"name": "Cassandra Fridkin", "email": "cass@swag.lgbt", "date": "2020-10-05T22:49:51Z"}, "committer": {"name": "Cassandra Fridkin", "email": "cass@swag.lgbt", "date": "2020-10-05T22:49:51Z"}, "message": "Merge branch 'master' into hooks", "tree": {"sha": "fd20034f9565a59750cdd1781a6a6e5f20d15a94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd20034f9565a59750cdd1781a6a6e5f20d15a94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44af74f6ddf9102b358f271b371697c4b4e6dd2f", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEdn8arGOPUN7UUjx9sGOAzKYTMzoFAl97oxMACgkQsGOAzKYT\nMzqwiA//eRD8sIHfVWRdqjuE3aJEDFJPoHN4rnz4eF7N76N98sXn9ZFS9YHT+v2k\nNOPzHtJ9FEaVyRInRvmZcwIu0kRohAaWWfr+MfwwQHaA712Ze3dYstfUgY63plqY\nUzELSqwycfrq/S6jhIPJWtzka6Rhx379216U+uFdaMBntA6kOqSJygRMUmQrD/OF\nZrrEzSniFBhzrNuC2cwyYsDxijwcI1mENX0bzxKQsnpxX+4sM47SpyEfhqdaZBKR\nE8x4+jpmRZ9ho6aiJtgMnFCR6kAAMCN9vpafbKcZXKCMznslAS/gaWgGTexRHc/q\nxFJJUlB8X7p9t35xAVeIYbIf2rqkNNO1xWUtI/cV1g1LdIc3DlkrdJvVjKTDDhLa\nFeQq6ShHGDG+LHF8mirqxcgZW1SVLaSq9VNu91XJ/iA2EqL5S41Xr6JM0/R6JQSF\n1pxie51p8/B54jRpmyVseIH3MGf8Q/x1/FeatKv3pCgERP4L7VEYR089Wr+1ytKT\nCUHjXxIq6BYizyxIxrcSP6i2TUngnFLOUSNjBUpox0rUHkleNlsygPVMNhPf9Oms\nkSRVtvPeXf1kp4cVgYrLbpoYIi8t5i2ZOODzjGZOfIVtXvFhLlZjpaOeGMJGOT5i\nReagLc6YSqCpfqYmNjSJCoux33TkuYNPsx1oLv8bXExXa1WrINQ=\n=6TrF\n-----END PGP SIGNATURE-----", "payload": "tree fd20034f9565a59750cdd1781a6a6e5f20d15a94\nparent a009e2838b25df2761093d727d322a59f69d8f68\nparent a1dfd2490a6cb456b92e469fa550dc217e20ad6d\nauthor Cassandra Fridkin <cass@swag.lgbt> 1601938191 -0400\ncommitter Cassandra Fridkin <cass@swag.lgbt> 1601938191 -0400\n\nMerge branch 'master' into hooks\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44af74f6ddf9102b358f271b371697c4b4e6dd2f", "html_url": "https://github.com/rust-lang/rust/commit/44af74f6ddf9102b358f271b371697c4b4e6dd2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44af74f6ddf9102b358f271b371697c4b4e6dd2f/comments", "author": {"login": "caass", "id": 25358963, "node_id": "MDQ6VXNlcjI1MzU4OTYz", "avatar_url": "https://avatars.githubusercontent.com/u/25358963?v=4", "gravatar_id": "", "url": "https://api.github.com/users/caass", "html_url": "https://github.com/caass", "followers_url": "https://api.github.com/users/caass/followers", "following_url": "https://api.github.com/users/caass/following{/other_user}", "gists_url": "https://api.github.com/users/caass/gists{/gist_id}", "starred_url": "https://api.github.com/users/caass/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/caass/subscriptions", "organizations_url": "https://api.github.com/users/caass/orgs", "repos_url": "https://api.github.com/users/caass/repos", "events_url": "https://api.github.com/users/caass/events{/privacy}", "received_events_url": "https://api.github.com/users/caass/received_events", "type": "User", "site_admin": false}, "committer": {"login": "caass", "id": 25358963, "node_id": "MDQ6VXNlcjI1MzU4OTYz", "avatar_url": "https://avatars.githubusercontent.com/u/25358963?v=4", "gravatar_id": "", "url": "https://api.github.com/users/caass", "html_url": "https://github.com/caass", "followers_url": "https://api.github.com/users/caass/followers", "following_url": "https://api.github.com/users/caass/following{/other_user}", "gists_url": "https://api.github.com/users/caass/gists{/gist_id}", "starred_url": "https://api.github.com/users/caass/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/caass/subscriptions", "organizations_url": "https://api.github.com/users/caass/orgs", "repos_url": "https://api.github.com/users/caass/repos", "events_url": "https://api.github.com/users/caass/events{/privacy}", "received_events_url": "https://api.github.com/users/caass/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a009e2838b25df2761093d727d322a59f69d8f68", "url": "https://api.github.com/repos/rust-lang/rust/commits/a009e2838b25df2761093d727d322a59f69d8f68", "html_url": "https://github.com/rust-lang/rust/commit/a009e2838b25df2761093d727d322a59f69d8f68"}, {"sha": "a1dfd2490a6cb456b92e469fa550dc217e20ad6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1dfd2490a6cb456b92e469fa550dc217e20ad6d", "html_url": "https://github.com/rust-lang/rust/commit/a1dfd2490a6cb456b92e469fa550dc217e20ad6d"}], "stats": {"total": 137493, "additions": 95425, "deletions": 42068}, "files": [{"sha": "24f43213897130267337f92ee6fad8ae33c2bd5f", "filename": ".github/ISSUE_TEMPLATE/tracking_issue.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -23,7 +23,7 @@ The feature gate for the issue is `#![feature(FFF)]`.\n ### About tracking issues\n \n Tracking issues are used to record the overall progress of implementation.\n-They are also uses as hubs connecting to other relevant issues, e.g., bugs or open design questions.\n+They are also used as hubs connecting to other relevant issues, e.g., bugs or open design questions.\n A tracking issue is however *not* meant for large scale discussion, questions, or bug reports about a feature.\n Instead, open a dedicated issue for the specific matter and add the relevant feature gate label.\n "}, {"sha": "23058b7a80826afb6af1f489393f1849b1354cd2", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 140, "deletions": 143, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -76,111 +76,7 @@ jobs:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && !env.RUST_CI_TEMP_SKIP_CANCEL_OUTDATED\"\n-      - name: collect CPU statistics\n-        run: src/ci/scripts/collect-cpu-stats.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: show the current environment\n-        run: src/ci/scripts/dump-environment.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install awscli\n-        run: src/ci/scripts/install-awscli.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install sccache\n-        run: src/ci/scripts/install-sccache.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install clang\n-        run: src/ci/scripts/install-clang.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install WIX\n-        run: src/ci/scripts/install-wix.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: ensure the build happens on a partition with enough space\n-        run: src/ci/scripts/symlink-build-dir.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: disable git crlf conversion\n-        run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install MSYS2\n-        run: src/ci/scripts/install-msys2.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install MinGW\n-        run: src/ci/scripts/install-mingw.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install ninja\n-        run: src/ci/scripts/install-ninja.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: enable ipv6 on Docker\n-        run: src/ci/scripts/enable-docker-ipv6.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: disable git crlf conversion\n-        run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: checkout submodules\n-        run: src/ci/scripts/checkout-submodules.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: ensure line endings are correct\n-        run: src/ci/scripts/verify-line-endings.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: run the build\n-        run: src/ci/scripts/run-build-from-ci.sh\n-        env:\n-          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n-          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n-          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n-        if: success() && !env.SKIP_JOB\n-      - name: upload artifacts to S3\n-        run: src/ci/scripts/upload-artifacts.sh\n-        env:\n-          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n-          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n-        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n-  try:\n-    name: try\n-    env:\n-      CI_JOB_NAME: \"${{ matrix.name }}\"\n-      SCCACHE_BUCKET: rust-lang-ci-sccache2\n-      DEPLOY_BUCKET: rust-lang-ci2\n-      TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n-      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/rust-lang/rust/issues\"\n-      TOOLSTATE_PUBLISH: 1\n-      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZI5DHEBFL\n-      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZN24CBO55\n-      CACHE_DOMAIN: ci-caches.rust-lang.org\n-    if: \"github.event_name == 'push' && (github.ref == 'refs/heads/try' || github.ref == 'refs/heads/try-perf') && github.repository == 'rust-lang-ci/rust'\"\n-    strategy:\n-      matrix:\n-        include:\n-          - name: dist-x86_64-linux\n-            os: ubuntu-latest-xl\n-            env: {}\n-    timeout-minutes: 600\n-    runs-on: \"${{ matrix.os }}\"\n-    steps:\n-      - name: disable git crlf conversion\n-        run: git config --global core.autocrlf false\n-      - name: checkout the source code\n-        uses: actions/checkout@v1\n-        with:\n-          fetch-depth: 2\n-      - name: configure the PR in which the error message will be posted\n-        run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n-        env:\n-          num: \"${{ github.event.number }}\"\n-        if: \"success() && !env.SKIP_JOBS && github.event_name == 'pull_request'\"\n-      - name: add extra environment variables\n-        run: src/ci/scripts/setup-environment.sh\n-        env:\n-          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n-        if: success() && !env.SKIP_JOB\n-      - name: decide whether to skip this job\n-        run: src/ci/scripts/should-skip-this.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: configure GitHub Actions to kill the build when outdated\n-        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n-        with:\n-          github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && !env.RUST_CI_TEMP_SKIP_CANCEL_OUTDATED\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB\n@@ -375,6 +271,35 @@ jobs:\n             env:\n               DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n             os: ubuntu-latest-xl\n+          - name: dist-x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--host=x86_64-apple-darwin --target=x86_64-apple-darwin,aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: macos-latest\n+          - name: dist-x86_64-apple-alt\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n+          - name: x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py --stage 2 test\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n@@ -431,26 +356,26 @@ jobs:\n           - name: x86_64-mingw-1\n             env:\n               SCRIPT: make ci-mingw-subset-1\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n               CUSTOM_MINGW: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_LLVM_ASSERTIONS: 1\n             os: windows-latest-xl\n           - name: x86_64-mingw-2\n             env:\n               SCRIPT: make ci-mingw-subset-2\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n               CUSTOM_MINGW: 1\n             os: windows-latest-xl\n           - name: dist-x86_64-msvc\n             env:\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: python x.py dist\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-i686-msvc\n             env:\n-              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc --target=i586-pc-windows-msvc --enable-full-tools --enable-profiler\"\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc --host=i686-pc-windows-msvc --target=i686-pc-windows-msvc,i586-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: python x.py dist\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n@@ -499,7 +424,7 @@ jobs:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && !env.RUST_CI_TEMP_SKIP_CANCEL_OUTDATED\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB\n@@ -580,38 +505,6 @@ jobs:\n               - self-hosted\n               - ARM64\n               - linux\n-          - name: dist-x86_64-apple\n-            env:\n-              SCRIPT: \"./x.py dist\"\n-              RUST_CONFIGURE_ARGS: \"--target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-              DIST_REQUIRE_ALL_TOOLS: 1\n-              RUST_CI_TEMP_SKIP_CANCEL_OUTDATED: 1\n-            os: macos-latest\n-          - name: dist-x86_64-apple-alt\n-            env:\n-              SCRIPT: \"./x.py dist\"\n-              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-              RUST_CI_TEMP_SKIP_CANCEL_OUTDATED: 1\n-            os: macos-latest\n-          - name: x86_64-apple\n-            env:\n-              SCRIPT: \"./x.py --stage 2 test\"\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.8\n-              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-              RUST_CI_TEMP_SKIP_CANCEL_OUTDATED: 1\n-            os: macos-latest\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n     steps:\n@@ -638,7 +531,111 @@ jobs:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && !env.RUST_CI_TEMP_SKIP_CANCEL_OUTDATED\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  try:\n+    name: try\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-ci-sccache2\n+      DEPLOY_BUCKET: rust-lang-ci2\n+      TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/rust-lang/rust/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZI5DHEBFL\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZN24CBO55\n+      CACHE_DOMAIN: ci-caches.rust-lang.org\n+    if: \"github.event_name == 'push' && (github.ref == 'refs/heads/try' || github.ref == 'refs/heads/try-perf') && github.repository == 'rust-lang-ci/rust'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: dist-x86_64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure the PR in which the error message will be posted\n+        run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n+        env:\n+          num: \"${{ github.event.number }}\"\n+        if: \"success() && !env.SKIP_JOBS && github.event_name == 'pull_request'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB"}, {"sha": "1c50d9b054ddc8b1edd734fe1d404af8da742974", "filename": ".gitignore", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -33,7 +33,6 @@ __pycache__/\n /mingw-build/\n # Created by default with `src/ci/docker/run.sh`:\n /obj/\n-/rustllvm/\n /unicode-downloads\n /target\n # Generated by compiletest for incremental:"}, {"sha": "d460b6508f6203e611a72a2e6cc21411abcc6ca5", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -37,7 +37,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/11.0-2020-08-20\n+\tbranch = rustc/11.0-2020-09-22\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "fa0728bd794612d969cc8a913225c69df7b7a087", "filename": ".mailmap", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -55,6 +55,9 @@ Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccer\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n Chris Vittal <christopher.vittal@gmail.com> Christopher Vittal <christopher.vittal@gmail.com>\n+Christiaan Dirkx <christiaan@dirkx.email> <christiaan@dirkx.com>\n+Christiaan Dirkx <christiaan@dirkx.email> CDirkx <christiaan@dirkx.com>\n+Christiaan Dirkx <christiaan@dirkx.email> CDirkx <christiaan@dirkx.email>\n Christian Poveda <git@christianpoveda.xyz> <christianpoveda@protonmail.com>\n Christian Poveda <git@christianpoveda.xyz> <cn.poveda.ruiz@gmail.com>\n Christian Poveda <git@christianpoveda.xyz> <z1mvader@protonmail.com>"}, {"sha": "6bff377a660ee0f8c5ab0d4a14208fe84602b492", "filename": "Cargo.lock", "status": "modified", "additions": 274, "deletions": 122, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -183,7 +183,16 @@ dependencies = [\n  \"block-padding\",\n  \"byte-tools\",\n  \"byteorder\",\n- \"generic-array\",\n+ \"generic-array 0.12.3\",\n+]\n+\n+[[package]]\n+name = \"block-buffer\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4152116fd6e9dadb291ae18fc1ec3575ed6d84c29642d97890f4b4a3417297e4\"\n+dependencies = [\n+ \"generic-array 0.14.4\",\n ]\n \n [[package]]\n@@ -207,6 +216,7 @@ dependencies = [\n  \"ignore\",\n  \"lazy_static\",\n  \"libc\",\n+ \"merge\",\n  \"num_cpus\",\n  \"opener\",\n  \"pretty_assertions\",\n@@ -230,8 +240,14 @@ dependencies = [\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n+ \"anyhow\",\n+ \"flate2\",\n+ \"hex 0.4.2\",\n+ \"rayon\",\n  \"serde\",\n  \"serde_json\",\n+ \"sha2\",\n+ \"tar\",\n  \"toml\",\n ]\n \n@@ -342,7 +358,6 @@ dependencies = [\n name = \"cargo-miri\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo_metadata 0.11.1\",\n  \"directories\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n@@ -408,9 +423,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.58\"\n+version = \"1.0.60\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f9a06fb2e53271d7c279ec1efea6ab691c35a2ae67ec0d91d7acec0caf13b518\"\n+checksum = \"ef611cc68ff783f18535d77ddd080185275713d852c4f5cbb6122c462a7a825c\"\n dependencies = [\n  \"jobserver\",\n ]\n@@ -427,9 +442,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.14.0\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d463e01905d607e181de72e8608721d3269f29176c9a14ce037011316ae7131d\"\n+checksum = \"3a7f257e3bcdc56d8877ae31c012bd69fba0be66929d588e603905f2632c0c59\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -439,40 +454,42 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.14.0\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"efaf428f5398d36284f79690cf988762b7c091249f50a6c11db613a46c057000\"\n+checksum = \"c43fcc7edf4d51b42f44ed50e2337bd90ddc8e088d0cd78a71db92a6f780f782\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n+ \"chalk-solve\",\n  \"rustc-hash\",\n  \"tracing\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.14.0\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd3fdc1e9f68498ffe80f4a23b0b95f1ca6fb21d5a4c9b0c085fab3ca712bdbe\"\n+checksum = \"03a4050029ecb2b5a1ff3bfc64c39279179b294821ec2e8891a4a5c6e3a08db0\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.14.0\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5b9fd4102807b7ebe8fb034fa0f488c5656e1966d3261b558b81a08d519cdb29\"\n+checksum = \"828c1f80d4eaf681027cce02050c54a3c97370f81988d31bf2a56df54048746c\"\n dependencies = [\n  \"chalk-derive\",\n- \"chalk-engine\",\n  \"chalk-ir\",\n  \"ena\",\n  \"itertools 0.9.0\",\n  \"petgraph\",\n  \"rustc-hash\",\n  \"tracing\",\n+ \"tracing-subscriber\",\n+ \"tracing-tree\",\n ]\n \n [[package]]\n@@ -532,7 +549,7 @@ dependencies = [\n  \"if_chain\",\n  \"itertools 0.9.0\",\n  \"lazy_static\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.8.0\",\n  \"quine-mc_cluskey\",\n  \"quote\",\n  \"regex-syntax\",\n@@ -574,9 +591,9 @@ dependencies = [\n \n [[package]]\n name = \"colored\"\n-version = \"1.9.3\"\n+version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f4ffc801dacf156c5854b9df4f425a626539c3a6ef7893cc0c5084a23f0b6c59\"\n+checksum = \"b3616f750b84d8f0de8a58bda93e08e2a81ad3f523089b05f1dffecab48c6cbd\"\n dependencies = [\n  \"atty\",\n  \"lazy_static\",\n@@ -682,6 +699,12 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a21fa21941700a3cd8fcb4091f361a6a712fac632f85d9f487cc892045d55c6\"\n \n+[[package]]\n+name = \"cpuid-bool\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8aebca1129a03dc6dc2b127edd729435bbc4a37e1d5f4d7513165089ceb02634\"\n+\n [[package]]\n name = \"crates-io\"\n version = \"0.31.1\"\n@@ -879,16 +902,24 @@ version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f3d0c8c8752312f9713efd397ff63acb9f85585afbf179282e720e7704954dd5\"\n dependencies = [\n- \"generic-array\",\n+ \"generic-array 0.12.3\",\n+]\n+\n+[[package]]\n+name = \"digest\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d3dd60d1080a57a05ab032377049e0591415d2b31afd7028356dbf3cc6dcb066\"\n+dependencies = [\n+ \"generic-array 0.14.4\",\n ]\n \n [[package]]\n name = \"directories\"\n-version = \"2.0.2\"\n+version = \"3.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"551a778172a450d7fc12e629ca3b0428d00f6afa9a43da1b630d54604e97371c\"\n+checksum = \"f8fed639d60b58d0f53498ab13d26f621fd77569cc6edb031f4cc36a2ad9da0f\"\n dependencies = [\n- \"cfg-if\",\n  \"dirs-sys\",\n ]\n \n@@ -1162,6 +1193,16 @@ dependencies = [\n  \"typenum\",\n ]\n \n+[[package]]\n+name = \"generic-array\"\n+version = \"0.14.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"501466ecc8a30d1d3b7fc9229b122b2ce8ed6e9d9223f1138d4babb253e51817\"\n+dependencies = [\n+ \"typenum\",\n+ \"version_check\",\n+]\n+\n [[package]]\n name = \"getopts\"\n version = \"0.2.21\"\n@@ -1184,6 +1225,17 @@ dependencies = [\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee8025cf36f917e6a52cce185b7c7177689b838b7ec138364e50cc2277a56cf4\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"wasi\",\n+]\n+\n [[package]]\n name = \"gimli\"\n version = \"0.22.0\"\n@@ -1257,11 +1309,10 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.8.2\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e91b62f79061a0bc2e046024cb7ba44b08419ed238ecbd9adbd787434b9e8c25\"\n+checksum = \"00d63df3d41950fb462ed38308eea019113ad1508da725bbedcd0fa5a85ef5f7\"\n dependencies = [\n- \"autocfg\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -1399,9 +1450,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.5.1\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"86b45e59b16c76b11bf9738fd5d38879d3bd28ad292d7b313608becb17ae2df9\"\n+checksum = \"55e2e4c765aa53a0424761bf9f41aa7a6ac1efa87238f59560640e27fca028f2\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\",\n@@ -1613,9 +1664,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.74\"\n+version = \"0.2.77\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2f02823cf78b754822df5f7f268fb59822e7296276d3e069d8e8cb26a14bd10\"\n+checksum = \"f2f96b10ec2560088a8e76961b00d47107b3a625fecb76dedb29ee7ccbf98235\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1660,9 +1711,9 @@ dependencies = [\n \n [[package]]\n name = \"libz-sys\"\n-version = \"1.0.27\"\n+version = \"1.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6ca8894883d250240341478bf987467332fbdd5da5c42426c69a8f93dbc302f2\"\n+checksum = \"602113192b08db8f38796c4e85c39e960c145965140e918018bcde1952429655\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1680,6 +1731,15 @@ version = \"0.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8dd5a6d5999d9907cda8ed67bbd137d3af8085216c2ac62de5be860bd41f304a\"\n \n+[[package]]\n+name = \"lint-docs\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"serde_json\",\n+ \"tempfile\",\n+ \"walkdir\",\n+]\n+\n [[package]]\n name = \"lock_api\"\n version = \"0.3.4\"\n@@ -1707,15 +1767,6 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n-[[package]]\n-name = \"log_settings\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"19af41f0565d7c19b2058153ad0b42d4d5ce89ec4dbf06ed6741114a8b63e7cd\"\n-dependencies = [\n- \"lazy_static\",\n-]\n-\n [[package]]\n name = \"lsp-codec\"\n version = \"0.1.2\"\n@@ -1825,16 +1876,16 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a18af3dcaf2b0219366cdb4e2af65a6101457b415c3d1a5c71dd9c2b7c77b9c8\"\n dependencies = [\n- \"block-buffer\",\n- \"digest\",\n- \"opaque-debug\",\n+ \"block-buffer 0.7.3\",\n+ \"digest 0.8.1\",\n+ \"opaque-debug 0.2.3\",\n ]\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.4.2\"\n+version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b75e31ae4eaa0e45e17ee2b6b9e3ed969c3c6ff12bb4c2e352c42493f4ebb706\"\n+checksum = \"29be448fcafb00c5a8966c4020c2a5ffbbc333e5b96d0bb5ef54b5bd0524d9ff\"\n dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n@@ -1847,7 +1898,7 @@ dependencies = [\n  \"log\",\n  \"memchr\",\n  \"open\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.7.2\",\n  \"regex\",\n  \"serde\",\n  \"serde_derive\",\n@@ -1894,6 +1945,28 @@ dependencies = [\n  \"autocfg\",\n ]\n \n+[[package]]\n+name = \"merge\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"10bbef93abb1da61525bbc45eeaff6473a41907d19f8f9aa5168d214e10693e9\"\n+dependencies = [\n+ \"merge_derive\",\n+ \"num-traits\",\n+]\n+\n+[[package]]\n+name = \"merge_derive\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"209d075476da2e63b4b29e72a2ef627b840589588e71400a25e3565c4f849d07\"\n+dependencies = [\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"minifier\"\n version = \"0.0.33\"\n@@ -1986,7 +2059,7 @@ dependencies = [\n  \"colored\",\n  \"compiletest_rs\",\n  \"env_logger 0.7.1\",\n- \"getrandom\",\n+ \"getrandom 0.2.0\",\n  \"hex 0.4.2\",\n  \"libc\",\n  \"log\",\n@@ -2058,16 +2131,19 @@ name = \"once_cell\"\n version = \"1.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"260e51e7efe62b592207e9e13a68e43692a7a279171d6ba57abd208bf23645ad\"\n-dependencies = [\n- \"parking_lot 0.11.0\",\n-]\n \n [[package]]\n name = \"opaque-debug\"\n version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2839e79665f131bdb5782e51f2c6c9599c133c6098982a54c794358bf432529c\"\n \n+[[package]]\n+name = \"opaque-debug\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"624a8340c38c1b80fd549087862da4ba43e08858af025b236e509b6649fc13d5\"\n+\n [[package]]\n name = \"open\"\n version = \"1.4.0\"\n@@ -2508,6 +2584,17 @@ dependencies = [\n  \"unicase\",\n ]\n \n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ffade02495f22453cd593159ea2f59827aae7f53fa8323f756799b670881dcf8\"\n+dependencies = [\n+ \"bitflags\",\n+ \"memchr\",\n+ \"unicase\",\n+]\n+\n [[package]]\n name = \"punycode\"\n version = \"0.4.1\"\n@@ -2543,9 +2630,9 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.37\"\n+version = \"2.1.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"db975752fc2c2430b4159d262585f7e45eb9aa43d733bf02c5f2fde512b00bfb\"\n+checksum = \"51dd5fd4247115b28f3e038eb8cda76a0c6f9cb473f769f41f930af8adff22d0\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n@@ -2570,7 +2657,7 @@ version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n- \"getrandom\",\n+ \"getrandom 0.1.14\",\n  \"libc\",\n  \"rand_chacha\",\n  \"rand_core\",\n@@ -2594,7 +2681,7 @@ version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19\"\n dependencies = [\n- \"getrandom\",\n+ \"getrandom 0.1.14\",\n ]\n \n [[package]]\n@@ -2670,7 +2757,7 @@ version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"09b23093265f8d200fa7b4c2c76297f47e681c655f6f1285a8780d6a022f7431\"\n dependencies = [\n- \"getrandom\",\n+ \"getrandom 0.1.14\",\n  \"redox_syscall\",\n  \"rust-argon2\",\n ]\n@@ -2855,8 +2942,9 @@ dependencies = [\n \n [[package]]\n name = \"rust-demangler\"\n-version = \"0.0.0\"\n+version = \"0.0.1\"\n dependencies = [\n+ \"regex\",\n  \"rustc-demangle\",\n ]\n \n@@ -2870,40 +2958,38 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_arena\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4a3941333c39ffa778611a34692244052fc9ba0f6b02dcf019c8d24925707dd6\"\n+checksum = \"2958af0d6e0458434a25cd3a96f6e19f24f71bf50b900add520dec52e212866b\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"smallvec 1.4.2\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_ast\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"27c579f7d89e6fc971b433e92bb2b8c65b716d7c797b21de8685945be9455610\"\n+checksum = \"0c82c2510460f2133548e62399e5acd30c25ae6ece30245baab3d1e00c2fefac\"\n dependencies = [\n  \"bitflags\",\n- \"log\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_index\",\n  \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_span\",\n- \"scoped-tls\",\n  \"smallvec 1.4.2\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_ast_passes\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f9914fadee461568d19ca2ebaec8699ff898f8ffec9928154659a57ee018e5fd\"\n+checksum = \"83977da57f81c6edd89bad47e49136680eaa33288de4abb702e95358c2a0fc6c\"\n dependencies = [\n  \"itertools 0.8.2\",\n- \"log\",\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n  \"rustc-ap-rustc_attr\",\n@@ -2913,31 +2999,33 @@ dependencies = [\n  \"rustc-ap-rustc_parse\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_ast_pretty\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2a78c5cc50a2f294d3c4e9131a15676724c9f136d3ed54e9ba419850b6025cb3\"\n+checksum = \"becf4ca1638b214694c71a8752192683048ab8bd47947cc481f57bd48157eeb9\"\n dependencies = [\n- \"log\",\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_span\",\n  \"rustc-ap-rustc_target\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_attr\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a78ce08227d146949755175c0cf710280a4b5bf6ee504c0e3f7ccc30d66fbfd9\"\n+checksum = \"0f21ca5dadce8a40d75a2756b77eab75b4c2d827f645c622dd93ee2285599640\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_feature\",\n+ \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_session\",\n@@ -2947,9 +3035,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9d5ac3735c38d2d0e95991ebcd7eb1618b60e784194a738e0ce2e8d39c39b809\"\n+checksum = \"a4cd204764727fde9abf75333eb661f058bfc7242062d91019440fe1b240688b\"\n dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n@@ -2959,47 +3047,48 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static\",\n  \"libc\",\n- \"log\",\n  \"measureme\",\n- \"once_cell\",\n  \"parking_lot 0.10.2\",\n  \"rustc-ap-rustc_graphviz\",\n  \"rustc-ap-rustc_index\",\n+ \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"smallvec 1.4.2\",\n  \"stable_deref_trait\",\n  \"stacker\",\n+ \"tempfile\",\n+ \"tracing\",\n  \"winapi 0.3.9\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5166a95afa6e3b78ccbece4c2f1e163634854297f1147c6fd90e2712ed3fede5\"\n+checksum = \"58116f119e37f14c029f99077b347069621118e048a69df74695b98204e7c136\"\n dependencies = [\n  \"annotate-snippets 0.8.0\",\n  \"atty\",\n- \"log\",\n  \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_span\",\n  \"termcolor\",\n  \"termize\",\n+ \"tracing\",\n  \"unicode-width\",\n  \"winapi 0.3.9\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_expand\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1a0586e83bdfe70eda8393429a8a38ecb529525dd252d787e479af075d3cab08\"\n+checksum = \"48e3c4bda9b64b92805bebe7431fdb8e24fd112b35a8c6d2174827441f10a6b2\"\n dependencies = [\n- \"log\",\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_passes\",\n  \"rustc-ap-rustc_ast_pretty\",\n@@ -3008,18 +3097,20 @@ dependencies = [\n  \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_feature\",\n  \"rustc-ap-rustc_lexer\",\n+ \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_parse\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n  \"smallvec 1.4.2\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_feature\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"48fc3aa8de0737a8c5a4353e6948548f469150d2b5d3eac391843de32c6c6ca2\"\n+checksum = \"4b612bb67d3fc49f395b03fc4ea4384a0145b05afbadab725803074ec827632b\"\n dependencies = [\n  \"lazy_static\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3028,40 +3119,41 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_fs_util\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"59fd3380f4029020b693bbfd5a14ec8c893ec33c5c0063ad2e68e46d3fbd6a1f\"\n+checksum = \"7630ad1a73a8434ee920676148cb5440ac57509bd20e94ec41087fb0b1d11c28\"\n \n [[package]]\n name = \"rustc-ap-rustc_graphviz\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b54bd98f70e04291bf611151d1fcd4d7770b35f7ec603d301c4aee0d1979cca4\"\n+checksum = \"a603fca4817062eb4fb23ff129d475bd66a69fb32f34ed4362ae950cf814b49d\"\n \n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"335bfb187a2489a59ee8c67fcf5d1760e9dcdbe0f02025c199a74caa05096b15\"\n+checksum = \"9850c4a5d7c341513e10802bca9588bf8f452ceea2d5cfa87b934246a52622bc\"\n dependencies = [\n  \"arrayvec\",\n+ \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22e1221f3bfa2943c942cf8da319ab2346887f8757778c29c7f1822cd27b521f\"\n+checksum = \"6d86722e5a1a615b198327d0d794cd9cbc8b9db4542276fc51fe078924de68ea\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8b774df26c4ef513555b3a303cb209f44cf68a9e6a5481b41ac832301c6487cb\"\n+checksum = \"b3fc8482e44cabdda7ac9a8e224aef62ebdf95274d629dac8db3b42321025fea\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -3071,12 +3163,11 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_parse\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"065e632101bdd57a271f38ee7a4d72b5a3d0467ec845104346c284b2c6c69960\"\n+checksum = \"3716cdcd978a91dbd4a2788400e90e809527f841426fbeb92f882f9b8582f3ab\"\n dependencies = [\n  \"bitflags\",\n- \"log\",\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3085,47 +3176,49 @@ dependencies = [\n  \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n+ \"smallvec 1.4.2\",\n+ \"tracing\",\n  \"unicode-normalization\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_serialize\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0e8c0b704e3dedb97cbb1ac566bbc0ab397ec4a4743098326a8f2230463fd9f9\"\n+checksum = \"c68046d07988b349b2e1c8bc1c9664a1d06519354aa677b9df358c5c5c058da0\"\n dependencies = [\n  \"indexmap\",\n  \"smallvec 1.4.2\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_session\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dda99ede4e6e260712754f8548b0a175b615686ad393653a3bd11f6c5e41a04e\"\n+checksum = \"85735553501a4de0c8904e37b7ccef79cc1c585a7d7f2cfa02cc38e0d149f982\"\n dependencies = [\n  \"bitflags\",\n  \"getopts\",\n- \"log\",\n  \"num_cpus\",\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_feature\",\n  \"rustc-ap-rustc_fs_util\",\n+ \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_span\",\n  \"rustc-ap-rustc_target\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_span\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53453791c2c0b501a921927ce8e305a801eef130920873f8da92d83dad595236\"\n+checksum = \"1c49ae8a0d3b9e27c6ffe8febeaa30f899294fff012de70625f9ee81c54fda85\"\n dependencies = [\n  \"cfg-if\",\n- \"log\",\n  \"md-5\",\n  \"rustc-ap-rustc_arena\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3134,22 +3227,23 @@ dependencies = [\n  \"rustc-ap-rustc_serialize\",\n  \"scoped-tls\",\n  \"sha-1\",\n+ \"tracing\",\n  \"unicode-width\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"671.0.0\"\n+version = \"677.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ac82006fdb31ef44e24e1623f8b72ac2b404ef15ba20b7ebec0df35e5d20bbef\"\n+checksum = \"1765f447594740c501c7b666b87639aa7c1dae2bf8c3166d5d2dca16646fd034\"\n dependencies = [\n  \"bitflags\",\n- \"log\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_index\",\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_span\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3291,7 +3385,7 @@ dependencies = [\n name = \"rustc_ast_passes\"\n version = \"0.0.0\"\n dependencies = [\n- \"itertools 0.8.2\",\n+ \"itertools 0.9.0\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_attr\",\n@@ -3415,6 +3509,7 @@ dependencies = [\n name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arrayvec\",\n  \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n@@ -3423,7 +3518,7 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"measureme\",\n- \"parking_lot 0.10.2\",\n+ \"parking_lot 0.11.0\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -3467,6 +3562,7 @@ dependencies = [\n  \"rustc_target\",\n  \"tracing\",\n  \"tracing-subscriber\",\n+ \"tracing-tree\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -3703,6 +3799,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_expand\",\n+ \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n@@ -3724,7 +3821,6 @@ name = \"rustc_middle\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"byteorder\",\n  \"chalk-ir\",\n  \"measureme\",\n  \"polonius-engine\",\n@@ -3753,9 +3849,9 @@ name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n  \"either\",\n- \"itertools 0.8.2\",\n- \"log_settings\",\n+ \"itertools 0.9.0\",\n  \"polonius-engine\",\n+ \"regex\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3837,6 +3933,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3877,7 +3974,7 @@ dependencies = [\n name = \"rustc_query_system\"\n version = \"0.0.0\"\n dependencies = [\n- \"parking_lot 0.10.2\",\n+ \"parking_lot 0.11.0\",\n  \"rustc-rayon-core\",\n  \"rustc_arena\",\n  \"rustc_data_structures\",\n@@ -4042,6 +4139,7 @@ dependencies = [\n name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n+ \"chalk-engine\",\n  \"chalk-ir\",\n  \"chalk-solve\",\n  \"rustc_ast\",\n@@ -4085,6 +4183,7 @@ dependencies = [\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4108,9 +4207,9 @@ name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n  \"expect-test\",\n- \"itertools 0.8.2\",\n+ \"itertools 0.9.0\",\n  \"minifier\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.8.0\",\n  \"rustc-rayon\",\n  \"serde\",\n  \"serde_json\",\n@@ -4153,7 +4252,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.20\"\n+version = \"1.4.21\"\n dependencies = [\n  \"annotate-snippets 0.6.1\",\n  \"anyhow\",\n@@ -4311,10 +4410,23 @@ version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f7d94d0bede923b3cea61f3f1ff57ff8cdfd77b400fb8f9998949e0cf04163df\"\n dependencies = [\n- \"block-buffer\",\n- \"digest\",\n+ \"block-buffer 0.7.3\",\n+ \"digest 0.8.1\",\n  \"fake-simd\",\n- \"opaque-debug\",\n+ \"opaque-debug 0.2.3\",\n+]\n+\n+[[package]]\n+name = \"sha2\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2933378ddfeda7ea26f48c555bdad8bb446bf8a3d17832dc83e380d444cfb8c1\"\n+dependencies = [\n+ \"block-buffer 0.9.0\",\n+ \"cfg-if\",\n+ \"cpuid-bool\",\n+ \"digest 0.9.0\",\n+ \"opaque-debug 0.3.0\",\n ]\n \n [[package]]\n@@ -4411,9 +4523,9 @@ checksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n \n [[package]]\n name = \"stacker\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a92bc346006ae78c539d6ab2cf1a1532bc657b8339c464877a990ec82073c66f\"\n+checksum = \"21ccb4c06ec57bc82d0f610f1a2963d7648700e43a6f513e564b9c89f7991786\"\n dependencies = [\n  \"cc\",\n  \"cfg-if\",\n@@ -4982,9 +5094,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.10\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1fe233f4227389ab7df5b32649239da7ebe0b281824b4e84b342d04d3fd8c25e\"\n+checksum = \"80e0ccfc3378da0cce270c946b676a376943f5cd16aeba64568e7939806f4ada\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -4993,11 +5105,32 @@ dependencies = [\n \n [[package]]\n name = \"tracing-core\"\n-version = \"0.1.14\"\n+version = \"0.1.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4f0e00789804e99b20f12bc7003ca416309d28a6f495d6af58d1e2c2842461b5\"\n+dependencies = [\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"tracing-log\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"db63662723c316b43ca36d833707cc93dff82a02ba3d7e354f342682cc8b3545\"\n+checksum = \"5e0f8c7178e13481ff6765bd169b33e8d554c5d2bbede5e32c356194be02b9b9\"\n dependencies = [\n  \"lazy_static\",\n+ \"log\",\n+ \"tracing-core\",\n+]\n+\n+[[package]]\n+name = \"tracing-serde\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b6ccba2f8f16e0ed268fc765d9b7ff22e965e7185d32f8f1ec8294fe17d86e79\"\n+dependencies = [\n+ \"serde\",\n+ \"tracing-core\",\n ]\n \n [[package]]\n@@ -5007,14 +5140,33 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"abd165311cc4d7a555ad11cc77a37756df836182db0d81aac908c8184c584f40\"\n dependencies = [\n  \"ansi_term 0.12.1\",\n+ \"chrono\",\n  \"lazy_static\",\n  \"matchers\",\n  \"parking_lot 0.11.0\",\n  \"regex\",\n+ \"serde\",\n+ \"serde_json\",\n  \"sharded-slab\",\n  \"smallvec 1.4.2\",\n  \"thread_local\",\n  \"tracing-core\",\n+ \"tracing-log\",\n+ \"tracing-serde\",\n+]\n+\n+[[package]]\n+name = \"tracing-tree\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"43aac8afb493b08e1e1904956f7407c1e671b9c83b26a17e1bd83d6a3520e350\"\n+dependencies = [\n+ \"ansi_term 0.12.1\",\n+ \"atty\",\n+ \"chrono\",\n+ \"termcolor\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n ]\n \n [[package]]"}, {"sha": "35e26695bdcabcbec6bd341d04147f5edc0a03bd", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -10,6 +10,7 @@ members = [\n   \"src/tools/error_index_generator\",\n   \"src/tools/install-git-hook\",\n   \"src/tools/linkchecker\",\n+  \"src/tools/lint-docs\",\n   \"src/tools/rustbook\",\n   \"src/tools/unstable-book-gen\",\n   \"src/tools/tidy\","}, {"sha": "d445bbdf6e8423a7a41df536db568f44ad22a1c1", "filename": "README.md", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -7,7 +7,10 @@ standard library, and documentation.\n \n [Rust]: https://www.rust-lang.org\n \n-**Note: this README is for _users_ rather than _contributors_.**\n+**Note: this README is for _users_ rather than _contributors_.\n+If you wish to _contribute_ to the compiler, you should read the\n+[Getting Started][gettingstarted] of the rustc-dev-guide instead of this\n+section.**\n \n ## Quick Start\n \n@@ -18,10 +21,6 @@ Read [\"Installation\"] from [The Book].\n \n ## Installing from Source\n \n-**Note: If you wish to _contribute_ to the compiler, you should read the\n-[Getting Started][gettingstarted] of the rustc-dev-guide instead of this\n-section.**\n-\n The Rust build system uses a Python script called `x.py` to build the compiler,\n which manages the bootstrapping process. More information about it can be found\n by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n@@ -45,8 +44,8 @@ by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n 2. Clone the [source] with `git`:\n \n    ```sh\n-   $ git clone https://github.com/rust-lang/rust.git\n-   $ cd rust\n+   git clone https://github.com/rust-lang/rust.git\n+   cd rust\n    ```\n \n [source]: https://github.com/rust-lang/rust\n@@ -58,7 +57,7 @@ by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n     Copy the default `config.toml.example` to `config.toml` to get started.\n \n     ```sh\n-    $ cp config.toml.example config.toml\n+    cp config.toml.example config.toml\n     ```\n \n     If you plan to use `x.py install` to create an installation, it is recommended\n@@ -69,7 +68,7 @@ by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n 4. Build and install:\n \n     ```sh\n-    $ ./x.py build && ./x.py install\n+    ./x.py build && ./x.py install\n     ```\n \n     When complete, `./x.py install` will place several programs into\n@@ -107,15 +106,15 @@ build.\n \n    ```sh\n    # Update package mirrors (may be needed if you have a fresh install of MSYS2)\n-   $ pacman -Sy pacman-mirrors\n+   pacman -Sy pacman-mirrors\n \n    # Install build tools needed for Rust. If you're building a 32-bit compiler,\n    # then replace \"x86_64\" below with \"i686\". If you've already got git, python,\n    # or CMake installed and in PATH you can remove them from this list. Note\n    # that it is important that you do **not** use the 'python2', 'cmake' and 'ninja'\n    # packages from the 'msys2' subsystem. The build has historically been known\n    # to fail with these packages.\n-   $ pacman -S git \\\n+   pacman -S git \\\n                make \\\n                diffutils \\\n                tar \\\n@@ -128,7 +127,7 @@ build.\n 4. Navigate to Rust's source code (or clone it), then build it:\n \n    ```sh\n-   $ ./x.py build && ./x.py install\n+   ./x.py build && ./x.py install\n    ```\n \n #### MSVC\n@@ -146,7 +145,7 @@ With these dependencies installed, you can build the compiler in a `cmd.exe`\n shell with:\n \n ```sh\n-> python x.py build\n+python x.py build\n ```\n \n Currently, building Rust only works with some known versions of Visual Studio. If\n@@ -155,8 +154,8 @@ you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```batch\n-> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n-> python x.py build\n+CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n+python x.py build\n ```\n \n #### Specifying an ABI\n@@ -182,8 +181,8 @@ While it's not the recommended build system, this project also provides a\n configure script and makefile (the latter of which just invokes `x.py`).\n \n ```sh\n-$ ./configure\n-$ make && sudo make install\n+./configure\n+make && sudo make install\n ```\n \n When using the configure script, the generated `config.mk` file may override the\n@@ -195,7 +194,7 @@ When using the configure script, the generated `config.mk` file may override the\n If you\u2019d like to build the documentation, it\u2019s almost the same:\n \n ```sh\n-$ ./x.py doc\n+./x.py doc\n ```\n \n The generated documentation will appear under `doc` in the `build` directory for\n@@ -243,6 +242,8 @@ The Rust community congregates in a few places:\n If you are interested in contributing to the Rust project, please take a look\n at the [Getting Started][gettingstarted] guide in the [rustc-dev-guide].\n \n+[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org\n+\n ## License\n \n Rust is primarily distributed under the terms of both the MIT license"}, {"sha": "ce11a74b71f53d0f3a4f86da8e690966a434c542", "filename": "RELEASES.md", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,3 +1,138 @@\n+Version 1.47.0 (2020-10-08)\n+==========================\n+\n+Language\n+--------\n+- [Closures will now warn when not used.][74869]\n+\n+Compiler\n+--------\n+- [Stabilized the `-C control-flow-guard` codegen option][73893], which enables\n+  [Control Flow Guard][1.47.0-cfg] for Windows platforms, and is ignored on other\n+  platforms.\n+- [Upgraded to LLVM 11.][73526]\n+- [Added tier 3\\* support for the `thumbv4t-none-eabi` target.][74419]\n+- [Upgrade the FreeBSD toolchain to version 11.4][75204]\n+- [`RUST_BACKTRACE`'s output is now more compact.][75048]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+- [`CStr` now implements `Index<RangeFrom<usize>>`.][74021]\n+- [Traits in `std`/`core` are now implemented for arrays of any length, not just\n+  those of length less than 33.][74060]\n+- [`ops::RangeFull` and `ops::Range` now implement Default.][73197]\n+- [`panic::Location` now implements `Copy`, `Clone`, `Eq`, `Hash`, `Ord`,\n+  `PartialEq`, and `PartialOrd`.][73583]\n+\n+Stabilized APIs\n+---------------\n+- [`Ident::new_raw`]\n+- [`Range::is_empty`]\n+- [`RangeInclusive::is_empty`]\n+- [`Result::as_deref`]\n+- [`Result::as_deref_mut`]\n+- [`Vec::leak`]\n+- [`pointer::offset_from`]\n+- [`f32::TAU`]\n+- [`f64::TAU`]\n+\n+The following previously stable APIs have now been made const.\n+\n+- [The `new` method for all `NonZero` integers.][73858]\n+- [The `checked_add`,`checked_sub`,`checked_mul`,`checked_neg`, `checked_shl`,\n+  `checked_shr`, `saturating_add`, `saturating_sub`, and `saturating_mul`\n+  methods for all integers.][73858]\n+- [The `checked_abs`, `saturating_abs`, `saturating_neg`, and `signum`  for all\n+  signed integers.][73858]\n+- [The `is_ascii_alphabetic`, `is_ascii_uppercase`, `is_ascii_lowercase`,\n+  `is_ascii_alphanumeric`, `is_ascii_digit`, `is_ascii_hexdigit`,\n+  `is_ascii_punctuation`, `is_ascii_graphic`, `is_ascii_whitespace`, and\n+  `is_ascii_control` methods for `char` and `u8`.][73858]\n+\n+Cargo\n+-----\n+- [`build-dependencies` are now built with opt-level 0 by default.][cargo/8500]\n+  You can override this by setting the following in your `Cargo.toml`.\n+  ```toml\n+  [profile.release.build-override]\n+  opt-level = 3\n+  ```\n+- [`cargo-help` will now display man pages for commands rather just the\n+  `--help` text.][cargo/8456]\n+- [`cargo-metadata` now emits a `test` field indicating if a target has\n+  tests enabled.][cargo/8478]\n+- [`workspace.default-members` now respects `workspace.exclude`.][cargo/8485]\n+- [`cargo-publish` will now use an alternative registry by default if it's the\n+  only registry specified in `package.publish`.][cargo/8571]\n+\n+Misc\n+----\n+- [Added a help button beside Rustdoc's searchbar that explains rustdoc's\n+  type based search.][75366]\n+- [Added the Ayu theme to rustdoc.][71237]\n+\n+Compatibility Notes\n+-------------------\n+- [Bumped the minimum supported Emscripten version to 1.39.20.][75716]\n+- [Fixed a regression parsing `{} && false` in tail expressions.][74650]\n+- [Added changes to how proc-macros are expanded in `macro_rules!` that should\n+  help to preserve more span information.][73084] These changes may cause\n+  compiliation errors if your macro was unhygenic or didn't correctly handle\n+  `Delimiter::None`.\n+- [Moved support for the CloudABI target to tier 3.][75568]\n+- [`linux-gnu` targets now require minimum kernel 2.6.32 and glibc 2.11.][74163]\n+- [Added the `rustc-docs` component.][75560] This allows you to install\n+  and read the documentation for the compiler internal APIs. (Currently only\n+  available for `x86_64-unknown-linux-gnu`.)\n+\n+Internal Only\n+--------\n+- [Improved default settings for bootstrapping in `x.py`.][73964] You can read details about this change in the [\"Changes to `x.py` defaults\"](https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html) post on the Inside Rust blog.\n+\n+[1.47.0-cfg]: https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard\n+[75048]: https://github.com/rust-lang/rust/pull/75048/\n+[74163]: https://github.com/rust-lang/rust/pull/74163/\n+[71237]: https://github.com/rust-lang/rust/pull/71237/\n+[74869]: https://github.com/rust-lang/rust/pull/74869/\n+[73858]: https://github.com/rust-lang/rust/pull/73858/\n+[75716]: https://github.com/rust-lang/rust/pull/75716/\n+[75908]: https://github.com/rust-lang/rust/pull/75908/\n+[75516]: https://github.com/rust-lang/rust/pull/75516/\n+[75560]: https://github.com/rust-lang/rust/pull/75560/\n+[75568]: https://github.com/rust-lang/rust/pull/75568/\n+[75366]: https://github.com/rust-lang/rust/pull/75366/\n+[75204]: https://github.com/rust-lang/rust/pull/75204/\n+[74650]: https://github.com/rust-lang/rust/pull/74650/\n+[74419]: https://github.com/rust-lang/rust/pull/74419/\n+[73964]: https://github.com/rust-lang/rust/pull/73964/\n+[74021]: https://github.com/rust-lang/rust/pull/74021/\n+[74060]: https://github.com/rust-lang/rust/pull/74060/\n+[73893]: https://github.com/rust-lang/rust/pull/73893/\n+[73526]: https://github.com/rust-lang/rust/pull/73526/\n+[73583]: https://github.com/rust-lang/rust/pull/73583/\n+[73084]: https://github.com/rust-lang/rust/pull/73084/\n+[73197]: https://github.com/rust-lang/rust/pull/73197/\n+[72488]: https://github.com/rust-lang/rust/pull/72488/\n+[cargo/8456]: https://github.com/rust-lang/cargo/pull/8456/\n+[cargo/8478]: https://github.com/rust-lang/cargo/pull/8478/\n+[cargo/8485]: https://github.com/rust-lang/cargo/pull/8485/\n+[cargo/8500]: https://github.com/rust-lang/cargo/pull/8500/\n+[cargo/8571]: https://github.com/rust-lang/cargo/pull/8571/\n+[`Ident::new_raw`]:  https://doc.rust-lang.org/nightly/proc_macro/struct.Ident.html#method.new_raw\n+[`Range::is_empty`]: https://doc.rust-lang.org/nightly/std/ops/struct.Range.html#method.is_empty\n+[`RangeInclusive::is_empty`]: https://doc.rust-lang.org/nightly/std/ops/struct.RangeInclusive.html#method.is_empty\n+[`Result::as_deref_mut`]: https://doc.rust-lang.org/nightly/std/result/enum.Result.html#method.as_deref_mut\n+[`Result::as_deref`]: https://doc.rust-lang.org/nightly/std/result/enum.Result.html#method.as_deref\n+[`TypeId::of`]: https://doc.rust-lang.org/nightly/std/any/struct.TypeId.html#method.of\n+[`Vec::leak`]: https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.leak\n+[`f32::TAU`]: https://doc.rust-lang.org/nightly/std/f32/consts/constant.TAU.html\n+[`f64::TAU`]: https://doc.rust-lang.org/nightly/std/f64/consts/constant.TAU.html\n+[`pointer::offset_from`]: https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from\n+\n+\n Version 1.46.0 (2020-08-27)\n ==========================\n "}, {"sha": "6e6c0c71a1f3b61c438515ab51e93137f6739289", "filename": "compiler/rustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -19,3 +19,4 @@ features = ['unprefixed_malloc_on_supported_platforms']\n [features]\n jemalloc = ['jemalloc-sys']\n llvm = ['rustc_driver/llvm']\n+max_level_info = ['rustc_driver/max_level_info']"}, {"sha": "71bcb8f090d07f98a9f50fe31c0e63a83ef9b113", "filename": "compiler/rustc_apfloat/src/ieee.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1511,11 +1511,16 @@ impl<S: Semantics, T: Semantics> FloatConvert<IeeeFloat<T>> for IeeeFloat<S> {\n                 sig::set_bit(&mut r.sig, T::PRECISION - 1);\n             }\n \n-            // gcc forces the Quiet bit on, which means (float)(double)(float_sNan)\n-            // does not give you back the same bits. This is dubious, and we\n-            // don't currently do it. You're really supposed to get\n-            // an invalid operation signal at runtime, but nobody does that.\n-            status = Status::OK;\n+            // Convert of sNaN creates qNaN and raises an exception (invalid op).\n+            // This also guarantees that a sNaN does not become Inf on a truncation\n+            // that loses all payload bits.\n+            if self.is_signaling() {\n+                // Quiet signaling NaN.\n+                sig::set_bit(&mut r.sig, T::QNAN_BIT);\n+                status = Status::INVALID_OP;\n+            } else {\n+                status = Status::OK;\n+            }\n         } else {\n             *loses_info = false;\n             status = Status::OK;"}, {"sha": "4a845fcb6917b76f57e7d6474cba13ede8ff805c", "filename": "compiler/rustc_apfloat/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -30,7 +30,7 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(nll)]"}, {"sha": "63d925cce9ad7f6e22e55388ef772b127c57bba6", "filename": "compiler/rustc_apfloat/tests/ieee.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Ftests%2Fieee.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -566,6 +566,17 @@ fn fma() {\n     }\n }\n \n+#[test]\n+fn issue_69532() {\n+    let f = Double::from_bits(0x7FF0_0000_0000_0001u64 as u128);\n+    let mut loses_info = false;\n+    let sta = f.convert(&mut loses_info);\n+    let r: Single = sta.value;\n+    assert!(loses_info);\n+    assert!(r.is_nan());\n+    assert_eq!(sta.status, Status::INVALID_OP);\n+}\n+\n #[test]\n fn min_num() {\n     let f1 = Double::from_f64(1.0);\n@@ -1492,27 +1503,32 @@ fn convert() {\n     assert_eq!(4294967295.0, test.to_f64());\n     assert!(!loses_info);\n \n-    let test = Single::snan(None);\n-    let x87_snan = X87DoubleExtended::snan(None);\n-    let test: X87DoubleExtended = test.convert(&mut loses_info).value;\n-    assert!(test.bitwise_eq(x87_snan));\n-    assert!(!loses_info);\n-\n     let test = Single::qnan(None);\n     let x87_qnan = X87DoubleExtended::qnan(None);\n     let test: X87DoubleExtended = test.convert(&mut loses_info).value;\n     assert!(test.bitwise_eq(x87_qnan));\n     assert!(!loses_info);\n \n-    let test = X87DoubleExtended::snan(None);\n-    let test: X87DoubleExtended = test.convert(&mut loses_info).value;\n-    assert!(test.bitwise_eq(x87_snan));\n+    let test = Single::snan(None);\n+    let sta = test.convert(&mut loses_info);\n+    let test: X87DoubleExtended = sta.value;\n+    assert!(test.is_nan());\n+    assert!(!test.is_signaling());\n     assert!(!loses_info);\n+    assert_eq!(sta.status, Status::INVALID_OP);\n \n     let test = X87DoubleExtended::qnan(None);\n     let test: X87DoubleExtended = test.convert(&mut loses_info).value;\n     assert!(test.bitwise_eq(x87_qnan));\n     assert!(!loses_info);\n+\n+    let test = X87DoubleExtended::snan(None);\n+    let sta = test.convert(&mut loses_info);\n+    let test: X87DoubleExtended = sta.value;\n+    assert!(test.is_nan());\n+    assert!(!test.is_signaling());\n+    assert!(!loses_info);\n+    assert_eq!(sta.status, Status::INVALID_OP);\n }\n \n #[test]"}, {"sha": "166f7f53c41ac103c7226a4f65c21e3bc361be5b", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 35, "deletions": 51, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -8,31 +8,25 @@\n //! This crate implements several kinds of arena.\n \n #![doc(\n-    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+    html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\",\n     test(no_crate_inject, attr(deny(warnings)))\n )]\n-#![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(raw_vec_internals)]\n+#![feature(new_uninit)]\n+#![feature(maybe_uninit_slice)]\n #![cfg_attr(test, feature(test))]\n-#![allow(deprecated)]\n-\n-extern crate alloc;\n \n use rustc_data_structures::cold_path;\n use smallvec::SmallVec;\n \n use std::alloc::Layout;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n-use std::intrinsics;\n use std::marker::{PhantomData, Send};\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n use std::ptr;\n use std::slice;\n \n-use alloc::raw_vec::RawVec;\n-\n /// An arena that can hold objects of only one type.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated.\n@@ -52,15 +46,15 @@ pub struct TypedArena<T> {\n \n struct TypedArenaChunk<T> {\n     /// The raw storage for the arena chunk.\n-    storage: RawVec<T>,\n+    storage: Box<[MaybeUninit<T>]>,\n     /// The number of valid entries in the chunk.\n     entries: usize,\n }\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n-        TypedArenaChunk { storage: RawVec::with_capacity(capacity), entries: 0 }\n+        TypedArenaChunk { storage: Box::new_uninit_slice(capacity), entries: 0 }\n     }\n \n     /// Destroys this arena chunk.\n@@ -69,30 +63,25 @@ impl<T> TypedArenaChunk<T> {\n         // The branch on needs_drop() is an -O1 performance optimization.\n         // Without the branch, dropping TypedArena<u8> takes linear time.\n         if mem::needs_drop::<T>() {\n-            let mut start = self.start();\n-            // Destroy all allocated objects.\n-            for _ in 0..len {\n-                ptr::drop_in_place(start);\n-                start = start.offset(1);\n-            }\n+            ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut self.storage[..len]));\n         }\n     }\n \n     // Returns a pointer to the first allocated object.\n     #[inline]\n-    fn start(&self) -> *mut T {\n-        self.storage.ptr()\n+    fn start(&mut self) -> *mut T {\n+        MaybeUninit::slice_as_mut_ptr(&mut self.storage)\n     }\n \n     // Returns a pointer to the end of the allocated space.\n     #[inline]\n-    fn end(&self) -> *mut T {\n+    fn end(&mut self) -> *mut T {\n         unsafe {\n             if mem::size_of::<T>() == 0 {\n                 // A pointer as large as possible for zero-sized elements.\n                 !0 as *mut T\n             } else {\n-                self.start().add(self.storage.capacity())\n+                self.start().add(self.storage.len())\n             }\n         }\n     }\n@@ -130,7 +119,7 @@ impl<T> TypedArena<T> {\n \n         unsafe {\n             if mem::size_of::<T>() == 0 {\n-                self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n+                self.ptr.set((self.ptr.get() as *mut u8).wrapping_offset(1) as *mut T);\n                 let ptr = mem::align_of::<T>() as *mut T;\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n@@ -226,10 +215,10 @@ impl<T> TypedArena<T> {\n                 let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n                 last_chunk.entries = used_bytes / mem::size_of::<T>();\n \n-                // If the previous chunk's capacity is less than HUGE_PAGE\n+                // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.capacity();\n+                new_cap = last_chunk.storage.len();\n                 if new_cap < HUGE_PAGE / elem_size {\n                     new_cap = new_cap.checked_mul(2).unwrap();\n                 }\n@@ -239,7 +228,7 @@ impl<T> TypedArena<T> {\n             // Also ensure that this chunk can fit `additional`.\n             new_cap = cmp::max(additional, new_cap);\n \n-            let chunk = TypedArenaChunk::<T>::new(new_cap);\n+            let mut chunk = TypedArenaChunk::<T>::new(new_cap);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);\n@@ -301,19 +290,21 @@ unsafe impl<#[may_dangle] T> Drop for TypedArena<T> {\n                     chunk.destroy(chunk.entries);\n                 }\n             }\n-            // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n+            // Box handles deallocation of `last_chunk` and `self.chunks`.\n         }\n     }\n }\n \n unsafe impl<T: Send> Send for TypedArena<T> {}\n \n pub struct DroplessArena {\n-    /// A pointer to the next object to be allocated.\n-    ptr: Cell<*mut u8>,\n+    /// A pointer to the start of the free space.\n+    start: Cell<*mut u8>,\n \n-    /// A pointer to the end of the allocated area. When this pointer is\n-    /// reached, a new chunk is allocated.\n+    /// A pointer to the end of free space.\n+    ///\n+    /// The allocation proceeds from the end of the chunk towards the start.\n+    /// When this pointer crosses the start pointer, a new chunk is allocated.\n     end: Cell<*mut u8>,\n \n     /// A vector of arena chunks.\n@@ -326,7 +317,7 @@ impl Default for DroplessArena {\n     #[inline]\n     fn default() -> DroplessArena {\n         DroplessArena {\n-            ptr: Cell::new(ptr::null_mut()),\n+            start: Cell::new(ptr::null_mut()),\n             end: Cell::new(ptr::null_mut()),\n             chunks: Default::default(),\n         }\n@@ -344,10 +335,10 @@ impl DroplessArena {\n                 // There is no need to update `last_chunk.entries` because that\n                 // field isn't used by `DroplessArena`.\n \n-                // If the previous chunk's capacity is less than HUGE_PAGE\n+                // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.capacity();\n+                new_cap = last_chunk.storage.len();\n                 if new_cap < HUGE_PAGE {\n                     new_cap = new_cap.checked_mul(2).unwrap();\n                 }\n@@ -357,8 +348,8 @@ impl DroplessArena {\n             // Also ensure that this chunk can fit `additional`.\n             new_cap = cmp::max(additional, new_cap);\n \n-            let chunk = TypedArenaChunk::<u8>::new(new_cap);\n-            self.ptr.set(chunk.start());\n+            let mut chunk = TypedArenaChunk::<u8>::new(new_cap);\n+            self.start.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);\n         }\n@@ -369,24 +360,17 @@ impl DroplessArena {\n     /// request.\n     #[inline]\n     fn alloc_raw_without_grow(&self, layout: Layout) -> Option<*mut u8> {\n-        let ptr = self.ptr.get() as usize;\n+        let start = self.start.get() as usize;\n         let end = self.end.get() as usize;\n+\n         let align = layout.align();\n         let bytes = layout.size();\n-        // The allocation request fits into the current chunk iff:\n-        //\n-        // let aligned = align_to(ptr, align);\n-        // ptr <= aligned && aligned + bytes <= end\n-        //\n-        // Except that we work with fixed width integers and need to be careful\n-        // about potential overflow in the calcuation. If the overflow does\n-        // happen, then we definitely don't have enough free and need to grow\n-        // the arena.\n-        let aligned = ptr.checked_add(align - 1)? & !(align - 1);\n-        let new_ptr = aligned.checked_add(bytes)?;\n-        if new_ptr <= end {\n-            self.ptr.set(new_ptr as *mut u8);\n-            Some(aligned as *mut u8)\n+\n+        let new_end = end.checked_sub(bytes)? & !(align - 1);\n+        if start <= new_end {\n+            let new_end = new_end as *mut u8;\n+            self.end.set(new_end);\n+            Some(new_end)\n         } else {\n             None\n         }"}, {"sha": "e8a1f2db1a16b029b380b4f0004306f0ab43ac63", "filename": "compiler/rustc_arena/src/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -121,6 +121,17 @@ pub fn bench_typed_arena_clear(b: &mut Bencher) {\n     })\n }\n \n+#[bench]\n+pub fn bench_typed_arena_clear_100(b: &mut Bencher) {\n+    let mut arena = TypedArena::default();\n+    b.iter(|| {\n+        for _ in 0..100 {\n+            arena.alloc(Point { x: 1, y: 2, z: 3 });\n+        }\n+        arena.clear();\n+    })\n+}\n+\n // Drop tests\n \n struct DropCounter<'a> {"}, {"sha": "95abf552915063abeece8f75ca747e6cd5460a1c", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -96,6 +96,7 @@ pub struct Path {\n     /// The segments in the path: the things separated by `::`.\n     /// Global paths begin with `kw::PathRoot`.\n     pub segments: Vec<PathSegment>,\n+    pub tokens: Option<TokenStream>,\n }\n \n impl PartialEq<Symbol> for Path {\n@@ -117,7 +118,7 @@ impl Path {\n     // Convert a span and an identifier to the corresponding\n     // one-segment path.\n     pub fn from_ident(ident: Ident) -> Path {\n-        Path { segments: vec![PathSegment::from_ident(ident)], span: ident.span }\n+        Path { segments: vec![PathSegment::from_ident(ident)], span: ident.span, tokens: None }\n     }\n \n     pub fn is_global(&self) -> bool {\n@@ -540,6 +541,7 @@ pub struct Block {\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n     pub span: Span,\n+    pub tokens: Option<TokenStream>,\n }\n \n /// A match pattern.\n@@ -586,7 +588,7 @@ impl Pat {\n             _ => return None,\n         };\n \n-        Some(P(Ty { kind, id: self.id, span: self.span }))\n+        Some(P(Ty { kind, id: self.id, span: self.span, tokens: None }))\n     }\n \n     /// Walk top-down and call `it` in each place where a pattern occurs\n@@ -916,6 +918,7 @@ pub struct Stmt {\n     pub id: NodeId,\n     pub kind: StmtKind,\n     pub span: Span,\n+    pub tokens: Option<TokenStream>,\n }\n \n impl Stmt {\n@@ -1068,7 +1071,7 @@ pub struct Expr {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Expr, 104);\n+rustc_data_structures::static_assert_size!(Expr, 112);\n \n impl Expr {\n     /// Returns `true` if this expression would be valid somewhere that expects a value;\n@@ -1168,7 +1171,7 @@ impl Expr {\n             _ => return None,\n         };\n \n-        Some(P(Ty { kind, id: self.id, span: self.span }))\n+        Some(P(Ty { kind, id: self.id, span: self.span, tokens: None }))\n     }\n \n     pub fn precedence(&self) -> ExprPrecedence {\n@@ -1866,6 +1869,7 @@ pub struct Ty {\n     pub id: NodeId,\n     pub kind: TyKind,\n     pub span: Span,\n+    pub tokens: Option<TokenStream>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -1927,7 +1931,7 @@ pub enum TyKind {\n \n impl TyKind {\n     pub fn is_implicit_self(&self) -> bool {\n-        if let TyKind::ImplicitSelf = *self { true } else { false }\n+        matches!(self, TyKind::ImplicitSelf)\n     }\n \n     pub fn is_unit(&self) -> bool {\n@@ -2144,7 +2148,7 @@ impl Param {\n     /// Builds a `Param` object from `ExplicitSelf`.\n     pub fn from_self(attrs: AttrVec, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n-        let infer_ty = P(Ty { id: DUMMY_NODE_ID, kind: TyKind::ImplicitSelf, span });\n+        let infer_ty = P(Ty { id: DUMMY_NODE_ID, kind: TyKind::ImplicitSelf, span, tokens: None });\n         let param = |mutbl, ty| Param {\n             attrs,\n             pat: P(Pat {\n@@ -2167,6 +2171,7 @@ impl Param {\n                     id: DUMMY_NODE_ID,\n                     kind: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl }),\n                     span,\n+                    tokens: None,\n                 }),\n             ),\n         }\n@@ -2222,7 +2227,7 @@ pub enum Async {\n \n impl Async {\n     pub fn is_async(self) -> bool {\n-        if let Async::Yes { .. } = self { true } else { false }\n+        matches!(self, Async::Yes { .. })\n     }\n \n     /// In this case this is an `async` return, the `NodeId` for the generated `impl Trait` item.\n@@ -2289,22 +2294,28 @@ impl FnRetTy {\n /// Module declaration.\n ///\n /// E.g., `mod foo;` or `mod foo { .. }`.\n-#[derive(Clone, Encodable, Decodable, Debug, Default)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n+    /// `unsafe` keyword accepted syntactically for macro DSLs, but not\n+    /// semantically by Rust.\n+    pub unsafety: Unsafe,\n     pub items: Vec<P<Item>>,\n     /// `true` for `mod foo { .. }`; `false` for `mod foo;`.\n     pub inline: bool,\n }\n \n /// Foreign module declaration.\n ///\n-/// E.g., `extern { .. }` or `extern C { .. }`.\n+/// E.g., `extern { .. }` or `extern \"C\" { .. }`.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ForeignMod {\n+    /// `unsafe` keyword accepted syntactically for macro DSLs, but not\n+    /// semantically by Rust.\n+    pub unsafety: Unsafe,\n     pub abi: Option<StrLit>,\n     pub items: Vec<P<ForeignItem>>,\n }\n@@ -2410,6 +2421,7 @@ impl<D: Decoder> rustc_serialize::Decodable<D> for AttrId {\n pub struct AttrItem {\n     pub path: Path,\n     pub args: MacArgs,\n+    pub tokens: Option<TokenStream>,\n }\n \n /// A list of attributes.\n@@ -2479,7 +2491,12 @@ pub enum CrateSugar {\n     JustCrate,\n }\n \n-pub type Visibility = Spanned<VisibilityKind>;\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct Visibility {\n+    pub kind: VisibilityKind,\n+    pub span: Span,\n+    pub tokens: Option<TokenStream>,\n+}\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum VisibilityKind {\n@@ -2491,7 +2508,7 @@ pub enum VisibilityKind {\n \n impl VisibilityKind {\n     pub fn is_pub(&self) -> bool {\n-        if let VisibilityKind::Public = *self { true } else { false }\n+        matches!(self, VisibilityKind::Public)\n     }\n }\n "}, {"sha": "2782869fb885a13a773f432927d8c48a1d799eb5", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -8,7 +8,7 @@ use crate::ast::{Path, PathSegment};\n use crate::mut_visit::visit_clobber;\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Token};\n-use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n+use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n \n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::source_map::{BytePos, Spanned};\n@@ -330,7 +330,7 @@ crate fn mk_attr_id() -> AttrId {\n }\n \n pub fn mk_attr(style: AttrStyle, path: Path, args: MacArgs, span: Span) -> Attribute {\n-    mk_attr_from_item(style, AttrItem { path, args }, span)\n+    mk_attr_from_item(style, AttrItem { path, args, tokens: None }, span)\n }\n \n pub fn mk_attr_from_item(style: AttrStyle, item: AttrItem, span: Span) -> Attribute {\n@@ -361,7 +361,7 @@ pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n }\n \n impl MetaItem {\n-    fn token_trees_and_joints(&self) -> Vec<TreeAndJoint> {\n+    fn token_trees_and_spacings(&self) -> Vec<TreeAndSpacing> {\n         let mut idents = vec![];\n         let mut last_pos = BytePos(0 as u32);\n         for (i, segment) in self.path.segments.iter().enumerate() {\n@@ -374,7 +374,7 @@ impl MetaItem {\n             idents.push(TokenTree::Token(Token::from_ast_ident(segment.ident)).into());\n             last_pos = segment.ident.span.hi();\n         }\n-        idents.extend(self.kind.token_trees_and_joints(self.span));\n+        idents.extend(self.kind.token_trees_and_spacings(self.span));\n         idents\n     }\n \n@@ -415,7 +415,7 @@ impl MetaItem {\n                     }\n                 }\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n-                Path { span, segments }\n+                Path { span, segments, tokens: None }\n             }\n             Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n                 token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n@@ -447,7 +447,7 @@ impl MetaItemKind {\n                     if i > 0 {\n                         tts.push(TokenTree::token(token::Comma, span).into());\n                     }\n-                    tts.extend(item.token_trees_and_joints())\n+                    tts.extend(item.token_trees_and_spacings())\n                 }\n                 MacArgs::Delimited(\n                     DelimSpan::from_single(span),\n@@ -458,7 +458,7 @@ impl MetaItemKind {\n         }\n     }\n \n-    fn token_trees_and_joints(&self, span: Span) -> Vec<TreeAndJoint> {\n+    fn token_trees_and_spacings(&self, span: Span) -> Vec<TreeAndSpacing> {\n         match *self {\n             MetaItemKind::Word => vec![],\n             MetaItemKind::NameValue(ref lit) => {\n@@ -470,7 +470,7 @@ impl MetaItemKind {\n                     if i > 0 {\n                         tokens.push(TokenTree::token(token::Comma, span).into());\n                     }\n-                    tokens.extend(item.token_trees_and_joints())\n+                    tokens.extend(item.token_trees_and_spacings())\n                 }\n                 vec![\n                     TokenTree::Delimited(\n@@ -553,9 +553,9 @@ impl NestedMetaItem {\n         }\n     }\n \n-    fn token_trees_and_joints(&self) -> Vec<TreeAndJoint> {\n+    fn token_trees_and_spacings(&self) -> Vec<TreeAndSpacing> {\n         match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.token_trees_and_joints(),\n+            NestedMetaItem::MetaItem(ref item) => item.token_trees_and_spacings(),\n             NestedMetaItem::Literal(ref lit) => vec![lit.token_tree().into()],\n         }\n     }"}, {"sha": "6e47ff7d740810bde946274239b707f571f8b3d4", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,18 +4,18 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n-#![feature(bool_to_option)]\n+#![doc(\n+    html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\",\n+    test(attr(deny(warnings)))\n+)]\n #![feature(box_syntax)]\n #![feature(const_fn)] // For the `transmute` in `P::new`\n-#![feature(const_panic)]\n #![feature(const_fn_transmute)]\n+#![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n #![feature(nll)]\n #![feature(or_patterns)]\n-#![feature(try_trait)]\n-#![feature(unicode_internals)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "425ef83b57af5ab203cb056f16dd40bb56e875d4", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -14,7 +14,7 @@ use crate::tokenstream::*;\n \n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::sync::Lrc;\n-use rustc_span::source_map::{respan, Spanned};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n@@ -451,7 +451,7 @@ pub fn noop_visit_ty_constraint<T: MutVisitor>(\n }\n \n pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n-    let Ty { id, kind, span } = ty.deref_mut();\n+    let Ty { id, kind, span, tokens: _ } = ty.deref_mut();\n     vis.visit_id(id);\n     match kind {\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err | TyKind::Never | TyKind::CVarArgs => {}\n@@ -490,7 +490,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n }\n \n pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis: &mut T) {\n-    let ForeignMod { abi: _, items } = foreign_mod;\n+    let ForeignMod { unsafety: _, abi: _, items } = foreign_mod;\n     items.flat_map_in_place(|item| vis.flat_map_foreign_item(item));\n }\n \n@@ -513,7 +513,7 @@ pub fn noop_visit_ident<T: MutVisitor>(Ident { name: _, span }: &mut Ident, vis:\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_path<T: MutVisitor>(Path { segments, span }: &mut Path, vis: &mut T) {\n+pub fn noop_visit_path<T: MutVisitor>(Path { segments, span, tokens: _ }: &mut Path, vis: &mut T) {\n     vis.visit_span(span);\n     for PathSegment { ident, id, args } in segments {\n         vis.visit_ident(ident);\n@@ -579,7 +579,7 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n     let Attribute { kind, id: _, style: _, span } = attr;\n     match kind {\n-        AttrKind::Normal(AttrItem { path, args }) => {\n+        AttrKind::Normal(AttrItem { path, args, tokens: _ }) => {\n             vis.visit_path(path);\n             visit_mac_args(args, vis);\n         }\n@@ -709,7 +709,7 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n         token::NtLifetime(ident) => vis.visit_ident(ident),\n         token::NtLiteral(expr) => vis.visit_expr(expr),\n         token::NtMeta(item) => {\n-            let AttrItem { path, args } = item.deref_mut();\n+            let AttrItem { path, args, tokens: _ } = item.deref_mut();\n             vis.visit_path(path);\n             visit_mac_args(args, vis);\n         }\n@@ -871,7 +871,7 @@ pub fn noop_visit_mt<T: MutVisitor>(MutTy { ty, mutbl: _ }: &mut MutTy, vis: &mu\n }\n \n pub fn noop_visit_block<T: MutVisitor>(block: &mut P<Block>, vis: &mut T) {\n-    let Block { id, stmts, rules: _, span } = block.deref_mut();\n+    let Block { id, stmts, rules: _, span, tokens: _ } = block.deref_mut();\n     vis.visit_id(id);\n     stmts.flat_map_in_place(|stmt| vis.flat_map_stmt(stmt));\n     vis.visit_span(span);\n@@ -970,18 +970,21 @@ pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n     vis.visit_asyncness(asyncness);\n }\n \n-pub fn noop_visit_mod<T: MutVisitor>(Mod { inner, items, inline: _ }: &mut Mod, vis: &mut T) {\n+pub fn noop_visit_mod<T: MutVisitor>(module: &mut Mod, vis: &mut T) {\n+    let Mod { inner, unsafety: _, items, inline: _ } = module;\n     vis.visit_span(inner);\n     items.flat_map_in_place(|item| vis.flat_map_item(item));\n }\n \n pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n     visit_clobber(krate, |Crate { module, attrs, span, proc_macros }| {\n+        let item_vis =\n+            Visibility { kind: VisibilityKind::Public, span: span.shrink_to_lo(), tokens: None };\n         let item = P(Item {\n             ident: Ident::invalid(),\n             attrs,\n             id: DUMMY_NODE_ID,\n-            vis: respan(span.shrink_to_lo(), VisibilityKind::Public),\n+            vis: item_vis,\n             span,\n             kind: ItemKind::Mod(module),\n             tokens: None,\n@@ -990,7 +993,7 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n \n         let len = items.len();\n         if len == 0 {\n-            let module = Mod { inner: span, items: vec![], inline: true };\n+            let module = Mod { inner: span, unsafety: Unsafe::No, items: vec![], inline: true };\n             Crate { module, attrs: vec![], span, proc_macros }\n         } else if len == 1 {\n             let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();\n@@ -1283,12 +1286,15 @@ pub fn noop_filter_map_expr<T: MutVisitor>(mut e: P<Expr>, vis: &mut T) -> Optio\n }\n \n pub fn noop_flat_map_stmt<T: MutVisitor>(\n-    Stmt { kind, mut span, mut id }: Stmt,\n+    Stmt { kind, mut span, mut id, tokens }: Stmt,\n     vis: &mut T,\n ) -> SmallVec<[Stmt; 1]> {\n     vis.visit_id(&mut id);\n     vis.visit_span(&mut span);\n-    noop_flat_map_stmt_kind(kind, vis).into_iter().map(|kind| Stmt { id, kind, span }).collect()\n+    noop_flat_map_stmt_kind(kind, vis)\n+        .into_iter()\n+        .map(|kind| Stmt { id, kind, span, tokens: tokens.clone() })\n+        .collect()\n }\n \n pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n@@ -1313,13 +1319,13 @@ pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n     }\n }\n \n-pub fn noop_visit_vis<T: MutVisitor>(Spanned { node, span }: &mut Visibility, vis: &mut T) {\n-    match node {\n+pub fn noop_visit_vis<T: MutVisitor>(visibility: &mut Visibility, vis: &mut T) {\n+    match &mut visibility.kind {\n         VisibilityKind::Public | VisibilityKind::Crate(_) | VisibilityKind::Inherited => {}\n         VisibilityKind::Restricted { path, id } => {\n             vis.visit_path(path);\n             vis.visit_id(id);\n         }\n     }\n-    vis.visit_span(span);\n+    vis.visit_span(&mut visibility.span);\n }"}, {"sha": "d5b3e87adc36a021c14b6b381c282848a042ac01", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -173,6 +173,7 @@ pub fn ident_can_begin_expr(name: Symbol, span: Span, is_raw: bool) -> bool {\n             kw::Move,\n             kw::Return,\n             kw::True,\n+            kw::Try,\n             kw::Unsafe,\n             kw::While,\n             kw::Yield,\n@@ -699,7 +700,7 @@ pub enum Nonterminal {\n \n // `Nonterminal` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Nonterminal, 40);\n+rustc_data_structures::static_assert_size!(Nonterminal, 48);\n \n #[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable)]\n pub enum NonterminalKind {\n@@ -809,9 +810,19 @@ impl Nonterminal {\n             if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n                 let filename = source_map.span_to_filename(orig_span);\n                 if let FileName::Real(RealFileName::Named(path)) = filename {\n-                    if (path.ends_with(\"time-macros-impl/src/lib.rs\")\n-                        && macro_name == sym::impl_macros)\n-                        || (path.ends_with(\"js-sys/src/lib.rs\") && macro_name == sym::arrays)\n+                    let matches_prefix = |prefix| {\n+                        // Check for a path that ends with 'prefix*/src/lib.rs'\n+                        let mut iter = path.components().rev();\n+                        iter.next().and_then(|p| p.as_os_str().to_str()) == Some(\"lib.rs\")\n+                            && iter.next().and_then(|p| p.as_os_str().to_str()) == Some(\"src\")\n+                            && iter\n+                                .next()\n+                                .and_then(|p| p.as_os_str().to_str())\n+                                .map_or(false, |p| p.starts_with(prefix))\n+                    };\n+\n+                    if (macro_name == sym::impl_macros && matches_prefix(\"time-macros-impl\"))\n+                        || (macro_name == sym::arrays && matches_prefix(\"js-sys\"))\n                     {\n                         let snippet = source_map.span_to_snippet(orig_span);\n                         if snippet.as_deref() == Ok(\"$name\") {"}, {"sha": "f201f0b5c66430ebe4d6b89c50d943e804600377", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -83,7 +83,7 @@ impl TokenTree {\n     }\n \n     pub fn joint(self) -> TokenStream {\n-        TokenStream::new(vec![(self, Joint)])\n+        TokenStream::new(vec![(self, Spacing::Joint)])\n     }\n \n     pub fn token(kind: TokenKind, span: Span) -> TokenTree {\n@@ -125,22 +125,20 @@ where\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for back-compat.\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n-pub struct TokenStream(pub Lrc<Vec<TreeAndJoint>>);\n+pub struct TokenStream(pub Lrc<Vec<TreeAndSpacing>>);\n \n-pub type TreeAndJoint = (TokenTree, IsJoint);\n+pub type TreeAndSpacing = (TokenTree, Spacing);\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(TokenStream, 8);\n \n #[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable)]\n-pub enum IsJoint {\n+pub enum Spacing {\n+    Alone,\n     Joint,\n-    NonJoint,\n }\n \n-use IsJoint::*;\n-\n impl TokenStream {\n     /// Given a `TokenStream` with a `Stream` of only two arguments, return a new `TokenStream`\n     /// separating the two arguments with a comma for diagnostic suggestions.\n@@ -153,7 +151,7 @@ impl TokenStream {\n                 let sp = match (&ts, &next) {\n                     (_, (TokenTree::Token(Token { kind: token::Comma, .. }), _)) => continue,\n                     (\n-                        (TokenTree::Token(token_left), NonJoint),\n+                        (TokenTree::Token(token_left), Spacing::Alone),\n                         (TokenTree::Token(token_right), _),\n                     ) if ((token_left.is_ident() && !token_left.is_reserved_ident())\n                         || token_left.is_lit())\n@@ -162,11 +160,11 @@ impl TokenStream {\n                     {\n                         token_left.span\n                     }\n-                    ((TokenTree::Delimited(sp, ..), NonJoint), _) => sp.entire(),\n+                    ((TokenTree::Delimited(sp, ..), Spacing::Alone), _) => sp.entire(),\n                     _ => continue,\n                 };\n                 let sp = sp.shrink_to_hi();\n-                let comma = (TokenTree::token(token::Comma, sp), NonJoint);\n+                let comma = (TokenTree::token(token::Comma, sp), Spacing::Alone);\n                 suggestion = Some((pos, comma, sp));\n             }\n         }\n@@ -184,19 +182,19 @@ impl TokenStream {\n \n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream::new(vec![(tree, NonJoint)])\n+        TokenStream::new(vec![(tree, Spacing::Alone)])\n     }\n }\n \n-impl From<TokenTree> for TreeAndJoint {\n-    fn from(tree: TokenTree) -> TreeAndJoint {\n-        (tree, NonJoint)\n+impl From<TokenTree> for TreeAndSpacing {\n+    fn from(tree: TokenTree) -> TreeAndSpacing {\n+        (tree, Spacing::Alone)\n     }\n }\n \n impl iter::FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(iter: I) -> Self {\n-        TokenStream::new(iter.into_iter().map(Into::into).collect::<Vec<TreeAndJoint>>())\n+        TokenStream::new(iter.into_iter().map(Into::into).collect::<Vec<TreeAndSpacing>>())\n     }\n }\n \n@@ -209,7 +207,7 @@ impl PartialEq<TokenStream> for TokenStream {\n }\n \n impl TokenStream {\n-    pub fn new(streams: Vec<TreeAndJoint>) -> TokenStream {\n+    pub fn new(streams: Vec<TreeAndSpacing>) -> TokenStream {\n         TokenStream(Lrc::new(streams))\n     }\n \n@@ -320,11 +318,11 @@ impl TokenStreamBuilder {\n         // If `self` is not empty and the last tree within the last stream is a\n         // token tree marked with `Joint`...\n         if let Some(TokenStream(ref mut last_stream_lrc)) = self.0.last_mut() {\n-            if let Some((TokenTree::Token(last_token), Joint)) = last_stream_lrc.last() {\n+            if let Some((TokenTree::Token(last_token), Spacing::Joint)) = last_stream_lrc.last() {\n                 // ...and `stream` is not empty and the first tree within it is\n                 // a token tree...\n                 let TokenStream(ref mut stream_lrc) = stream;\n-                if let Some((TokenTree::Token(token), is_joint)) = stream_lrc.first() {\n+                if let Some((TokenTree::Token(token), spacing)) = stream_lrc.first() {\n                     // ...and the two tokens can be glued together...\n                     if let Some(glued_tok) = last_token.glue(&token) {\n                         // ...then do so, by overwriting the last token\n@@ -337,8 +335,7 @@ impl TokenStreamBuilder {\n                         // Overwrite the last token tree with the merged\n                         // token.\n                         let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n-                        *last_vec_mut.last_mut().unwrap() =\n-                            (TokenTree::Token(glued_tok), *is_joint);\n+                        *last_vec_mut.last_mut().unwrap() = (TokenTree::Token(glued_tok), *spacing);\n \n                         // Remove the first token tree from `stream`. (This\n                         // is almost always the only tree in `stream`.)\n@@ -375,7 +372,7 @@ impl Iterator for Cursor {\n     type Item = TokenTree;\n \n     fn next(&mut self) -> Option<TokenTree> {\n-        self.next_with_joint().map(|(tree, _)| tree)\n+        self.next_with_spacing().map(|(tree, _)| tree)\n     }\n }\n \n@@ -384,7 +381,7 @@ impl Cursor {\n         Cursor { stream, index: 0 }\n     }\n \n-    pub fn next_with_joint(&mut self) -> Option<TreeAndJoint> {\n+    pub fn next_with_spacing(&mut self) -> Option<TreeAndSpacing> {\n         if self.index < self.stream.len() {\n             self.index += 1;\n             Some(self.stream.0[self.index - 1].clone())"}, {"sha": "754b1f13381cb5980e998e00b5b6e16f58dec5f6", "filename": "compiler/rustc_ast/src/util/lev_distance.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -103,6 +103,7 @@ fn find_match_by_sorted_words<'a>(iter_names: Vec<&'a Symbol>, lookup: &str) ->\n \n fn sort_by_words(name: &str) -> String {\n     let mut split_words: Vec<&str> = name.split('_').collect();\n-    split_words.sort();\n+    // We are sorting primitive &strs and can use unstable sort here\n+    split_words.sort_unstable();\n     split_words.join(\"_\")\n }"}, {"sha": "86fd87f6c42c5a88977f617cab70a14ae9327f26", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -879,7 +879,7 @@ pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n }\n \n pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n-    if let VisibilityKind::Restricted { ref path, id } = vis.node {\n+    if let VisibilityKind::Restricted { ref path, id } = vis.kind {\n         visitor.visit_path(path, id);\n     }\n }"}, {"sha": "c97f80cf09ba17ceeddf36937ecbe75c2117e9f8", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1121,7 +1121,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // features. We check that at least one type is available for\n                 // the current target.\n                 let reg_class = reg.reg_class();\n-                let mut required_features = vec![];\n+                let mut required_features: Vec<&str> = vec![];\n                 for &(_, feature) in reg_class.supported_types(asm_arch) {\n                     if let Some(feature) = feature {\n                         if self.sess.target_features.contains(&Symbol::intern(feature)) {\n@@ -1135,7 +1135,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         break;\n                     }\n                 }\n-                required_features.sort();\n+                // We are sorting primitive strs here and can use unstable sort here\n+                required_features.sort_unstable();\n                 required_features.dedup();\n                 match &required_features[..] {\n                     [] => {}"}, {"sha": "617cacee0e7f1d580a2003e6b68931a632fc587b", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -27,7 +27,7 @@ pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n impl ItemLowerer<'_, '_, '_> {\n     fn with_trait_impl_ref(&mut self, impl_ref: &Option<TraitRef>, f: impl FnOnce(&mut Self)) {\n         let old = self.lctx.is_in_trait_impl;\n-        self.lctx.is_in_trait_impl = if let &None = impl_ref { false } else { true };\n+        self.lctx.is_in_trait_impl = impl_ref.is_some();\n         f(self);\n         self.lctx.is_in_trait_impl = old;\n     }\n@@ -251,7 +251,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n             ItemKind::Use(ref use_tree) => {\n                 // Start with an empty prefix.\n-                let prefix = Path { segments: vec![], span: use_tree.span };\n+                let prefix = Path { segments: vec![], span: use_tree.span, tokens: None };\n \n                 self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n             }\n@@ -488,7 +488,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 *ident = tree.ident();\n \n                 // First, apply the prefix to the path.\n-                let mut path = Path { segments, span: path.span };\n+                let mut path = Path { segments, span: path.span, tokens: None };\n \n                 // Correctly resolve `self` imports.\n                 if path.segments.len() > 1\n@@ -540,8 +540,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n-                let path =\n-                    self.lower_path(id, &Path { segments, span: path.span }, ParamMode::Explicit);\n+                let path = self.lower_path(\n+                    id,\n+                    &Path { segments, span: path.span, tokens: None },\n+                    ParamMode::Explicit,\n+                );\n                 hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n@@ -569,7 +572,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // for that we return the `{}` import (called the\n                 // `ListStem`).\n \n-                let prefix = Path { segments, span: prefix.span.to(path.span) };\n+                let prefix = Path { segments, span: prefix.span.to(path.span), tokens: None };\n \n                 // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n@@ -927,7 +930,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         v: &Visibility,\n         explicit_owner: Option<NodeId>,\n     ) -> hir::Visibility<'hir> {\n-        let node = match v.node {\n+        let node = match v.kind {\n             VisibilityKind::Public => hir::VisibilityKind::Public,\n             VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n             VisibilityKind::Restricted { ref path, id } => {"}, {"sha": "a28d022c66139c01e2c7de0e93e821dd0ee6d064", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -967,6 +967,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             AttrKind::Normal(ref item) => AttrKind::Normal(AttrItem {\n                 path: item.path.clone(),\n                 args: self.lower_mac_args(&item.args),\n+                tokens: None,\n             }),\n             AttrKind::DocComment(comment_kind, data) => AttrKind::DocComment(comment_kind, data),\n         };\n@@ -1106,6 +1107,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 id: node_id,\n                                 kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n                                 span: constraint.span,\n+                                tokens: None,\n                             },\n                             itctx,\n                         );"}, {"sha": "9ed6bdc3d6a1aa036c68f7a12fd34e8de58a699b", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -5,7 +5,7 @@ version = \"0.0.0\"\n edition = \"2018\"\n \n [dependencies]\n-itertools = \"0.8\"\n+itertools = \"0.9\"\n tracing = \"0.1\"\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_attr = { path = \"../rustc_attr\" }"}, {"sha": "232ee35c4f7df82d9d780346c21ed379ce03d70a", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -198,13 +198,13 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn invalid_visibility(&self, vis: &Visibility, note: Option<&str>) {\n-        if let VisibilityKind::Inherited = vis.node {\n+        if let VisibilityKind::Inherited = vis.kind {\n             return;\n         }\n \n         let mut err =\n             struct_span_err!(self.session, vis.span, E0449, \"unnecessary visibility qualifier\");\n-        if vis.node.is_pub() {\n+        if vis.kind.is_pub() {\n             err.span_label(vis.span, \"`pub` not permitted here because it's implied\");\n         }\n         if let Some(note) = note {\n@@ -868,10 +868,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     .emit();\n                 }\n \n-                if !bounds\n-                    .iter()\n-                    .any(|b| if let GenericBound::Trait(..) = *b { true } else { false })\n-                {\n+                if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n                     self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n                 }\n \n@@ -990,12 +987,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.error_item_without_body(item.span, \"function\", msg, \" { <body> }\");\n                 }\n             }\n-            ItemKind::ForeignMod(_) => {\n+            ItemKind::ForeignMod(ForeignMod { unsafety, .. }) => {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n                     Some(\"place qualifiers on individual foreign items instead\"),\n                 );\n+                if let Unsafe::Yes(span) = unsafety {\n+                    self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n+                }\n                 visit::walk_item(self, item);\n                 self.extern_mod = old_item;\n                 return; // Avoid visiting again.\n@@ -1029,7 +1029,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return;\n             }\n-            ItemKind::Mod(Mod { inline, .. }) => {\n+            ItemKind::Mod(Mod { inline, unsafety, .. }) => {\n+                if let Unsafe::Yes(span) = unsafety {\n+                    self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n+                }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 if !inline && !self.session.contains_name(&item.attrs, sym::path) {\n                     self.check_mod_file_item_asciionly(item.ident);"}, {"sha": "00d3db73766ac6fc62ee10d09693737702db0d1f", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -260,7 +260,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     cfg => doc_cfg\n                     masked => doc_masked\n                     spotlight => doc_spotlight\n-                    alias => doc_alias\n                     keyword => doc_keyword\n                 );\n             }\n@@ -594,7 +593,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n-        if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.node {\n+        if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.kind {\n             gate_feature_post!(\n                 &self,\n                 crate_visibility_modifier,\n@@ -608,6 +607,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     maybe_stage_features(sess, krate);\n+    check_incompatible_features(sess);\n     let mut visitor = PostExpansionVisitor { sess, features: &sess.features_untracked() };\n \n     let spans = sess.parse_sess.gated_spans.spans.borrow();\n@@ -677,3 +677,36 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n         }\n     }\n }\n+\n+fn check_incompatible_features(sess: &Session) {\n+    let features = sess.features_untracked();\n+\n+    let declared_features = features\n+        .declared_lang_features\n+        .iter()\n+        .copied()\n+        .map(|(name, span, _)| (name, span))\n+        .chain(features.declared_lib_features.iter().copied());\n+\n+    for (f1, f2) in rustc_feature::INCOMPATIBLE_FEATURES\n+        .iter()\n+        .filter(|&&(f1, f2)| features.enabled(f1) && features.enabled(f2))\n+    {\n+        if let Some((f1_name, f1_span)) = declared_features.clone().find(|(name, _)| name == f1) {\n+            if let Some((f2_name, f2_span)) = declared_features.clone().find(|(name, _)| name == f2)\n+            {\n+                let spans = vec![f1_span, f2_span];\n+                sess.struct_span_err(\n+                    spans.clone(),\n+                    &format!(\n+                        \"features `{}` and `{}` are incompatible, using them at the same time \\\n+                        is not allowed\",\n+                        f1_name, f2_name\n+                    ),\n+                )\n+                .help(\"remove one of these features\")\n+                .emit();\n+            }\n+        }\n+    }\n+}"}, {"sha": "d16b541c6999e7b52671b94e7cba7bca4ca9dcef", "filename": "compiler/rustc_ast_pretty/src/pprust.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1139,7 +1139,11 @@ impl<'a> State<'a> {\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, def, body, &item.attrs);\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n-                self.head(visibility_qualified(&item.vis, \"mod\"));\n+                self.head(to_string(|s| {\n+                    s.print_visibility(&item.vis);\n+                    s.print_unsafety(_mod.unsafety);\n+                    s.word(\"mod\");\n+                }));\n                 self.print_ident(item.ident);\n \n                 if _mod.inline || self.is_expanded {\n@@ -1154,7 +1158,10 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n-                self.head(\"extern\");\n+                self.head(to_string(|s| {\n+                    s.print_unsafety(nmod.unsafety);\n+                    s.word(\"extern\");\n+                }));\n                 if let Some(abi) = nmod.abi {\n                     self.print_literal(&abi.as_lit());\n                     self.nbsp();\n@@ -1352,7 +1359,7 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_visibility(&mut self, vis: &ast::Visibility) {\n-        match vis.node {\n+        match vis.kind {\n             ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n             ast::VisibilityKind::Crate(sugar) => match sugar {\n                 ast::CrateSugar::PubCrate => self.word_nbsp(\"pub(crate)\"),"}, {"sha": "b1a73a0bf02778ee001e706fec743a92834d91b6", "filename": "compiler/rustc_ast_pretty/src/pprust/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,7 +1,6 @@\n use super::*;\n \n use rustc_ast as ast;\n-use rustc_span::source_map::respan;\n use rustc_span::symbol::Ident;\n use rustc_span::with_default_session_globals;\n \n@@ -45,7 +44,11 @@ fn test_variant_to_string() {\n \n         let var = ast::Variant {\n             ident,\n-            vis: respan(rustc_span::DUMMY_SP, ast::VisibilityKind::Inherited),\n+            vis: ast::Visibility {\n+                span: rustc_span::DUMMY_SP,\n+                kind: ast::VisibilityKind::Inherited,\n+                tokens: None,\n+            },\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n             data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),"}, {"sha": "94e2a40e1fe368ca2da564cb0d568d6d711426e5", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -145,8 +145,6 @@ pub struct ConstStability {\n     pub feature: Symbol,\n     /// whether the function has a `#[rustc_promotable]` attribute\n     pub promotable: bool,\n-    /// whether the function has a `#[rustc_allow_const_fn_ptr]` attribute\n-    pub allow_const_fn_ptr: bool,\n }\n \n /// The available stability levels.\n@@ -160,10 +158,10 @@ pub enum StabilityLevel {\n \n impl StabilityLevel {\n     pub fn is_unstable(&self) -> bool {\n-        if let StabilityLevel::Unstable { .. } = *self { true } else { false }\n+        matches!(self, StabilityLevel::Unstable { .. })\n     }\n     pub fn is_stable(&self) -> bool {\n-        if let StabilityLevel::Stable { .. } = *self { true } else { false }\n+        matches!(self, StabilityLevel::Stable { .. })\n     }\n }\n \n@@ -190,7 +188,6 @@ where\n     let mut stab: Option<Stability> = None;\n     let mut const_stab: Option<ConstStability> = None;\n     let mut promotable = false;\n-    let mut allow_const_fn_ptr = false;\n     let diagnostic = &sess.parse_sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n@@ -200,7 +197,6 @@ where\n             sym::unstable,\n             sym::stable,\n             sym::rustc_promotable,\n-            sym::rustc_allow_const_fn_ptr,\n         ]\n         .iter()\n         .any(|&s| attr.has_name(s))\n@@ -215,9 +211,6 @@ where\n         if attr.has_name(sym::rustc_promotable) {\n             promotable = true;\n         }\n-        if attr.has_name(sym::rustc_allow_const_fn_ptr) {\n-            allow_const_fn_ptr = true;\n-        }\n         // attributes with data\n         else if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta {\n             let meta = meta.as_ref().unwrap();\n@@ -301,7 +294,7 @@ where\n                                                 .emit();\n                                             };\n                                             match issue.parse() {\n-                                                Ok(num) if num == 0 => {\n+                                                Ok(0) => {\n                                                     emit_diag(\n                                                         \"`issue` must not be \\\"0\\\", \\\n                                                         use \\\"none\\\" instead\",\n@@ -360,12 +353,8 @@ where\n                             if sym::unstable == meta_name {\n                                 stab = Some(Stability { level, feature });\n                             } else {\n-                                const_stab = Some(ConstStability {\n-                                    level,\n-                                    feature,\n-                                    promotable: false,\n-                                    allow_const_fn_ptr: false,\n-                                });\n+                                const_stab =\n+                                    Some(ConstStability { level, feature, promotable: false });\n                             }\n                         }\n                         (None, _, _) => {\n@@ -440,12 +429,8 @@ where\n                             if sym::stable == meta_name {\n                                 stab = Some(Stability { level, feature });\n                             } else {\n-                                const_stab = Some(ConstStability {\n-                                    level,\n-                                    feature,\n-                                    promotable: false,\n-                                    allow_const_fn_ptr: false,\n-                                });\n+                                const_stab =\n+                                    Some(ConstStability { level, feature, promotable: false });\n                             }\n                         }\n                         (None, _) => {\n@@ -464,18 +449,16 @@ where\n     }\n \n     // Merge the const-unstable info into the stability info\n-    if promotable || allow_const_fn_ptr {\n+    if promotable {\n         if let Some(ref mut stab) = const_stab {\n             stab.promotable = promotable;\n-            stab.allow_const_fn_ptr = allow_const_fn_ptr;\n         } else {\n             struct_span_err!(\n                 diagnostic,\n                 item_sp,\n                 E0717,\n-                \"rustc_promotable and rustc_allow_const_fn_ptr attributes \\\n-                      must be paired with either a rustc_const_unstable or a rustc_const_stable \\\n-                      attribute\"\n+                \"`rustc_promotable` attribute must be paired with either a `rustc_const_unstable` \\\n+                or a `rustc_const_stable` attribute\"\n             )\n             .emit();\n         }\n@@ -1022,14 +1005,21 @@ pub fn find_transparency(\n \n pub fn allow_internal_unstable<'a>(\n     sess: &'a Session,\n-    attrs: &[Attribute],\n+    attrs: &'a [Attribute],\n ) -> Option<impl Iterator<Item = Symbol> + 'a> {\n-    let attr = sess.find_by_name(attrs, sym::allow_internal_unstable)?;\n-    let list = attr.meta_item_list().or_else(|| {\n-        sess.diagnostic()\n-            .span_err(attr.span, \"allow_internal_unstable expects list of feature names\");\n-        None\n-    })?;\n+    let attrs = sess.filter_by_name(attrs, sym::allow_internal_unstable);\n+    let list = attrs\n+        .filter_map(move |attr| {\n+            attr.meta_item_list().or_else(|| {\n+                sess.diagnostic().span_err(\n+                    attr.span,\n+                    \"`allow_internal_unstable` expects a list of feature names\",\n+                );\n+                None\n+            })\n+        })\n+        .flatten();\n+\n     Some(list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {"}, {"sha": "09985959b67b80c10b4ca000104e6ed5a6ee063a", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -368,7 +368,7 @@ fn parse_reg<'a>(\n     explicit_reg: &mut bool,\n ) -> Result<ast::InlineAsmRegOrRegClass, DiagnosticBuilder<'a>> {\n     p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n-    let result = match p.token.kind {\n+    let result = match p.token.uninterpolate().kind {\n         token::Ident(name, false) => ast::InlineAsmRegOrRegClass::RegClass(name),\n         token::Literal(token::Lit { kind: token::LitKind::Str, symbol, suffix: _ }) => {\n             *explicit_reg = true;"}, {"sha": "5ed8b69d92ab7841d9c1f39715fcc937804a3279", "filename": "compiler/rustc_builtin_macros/src/cmdline_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -15,7 +15,7 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n         );\n \n         let start_span = parser.token.span;\n-        let AttrItem { path, args } = match parser.parse_attr_item() {\n+        let AttrItem { path, args, tokens: _ } = match parser.parse_attr_item() {\n             Ok(ai) => ai,\n             Err(mut err) => {\n                 err.emit();"}, {"sha": "209158ce39206f4765495afcf4e758e0d3328346", "filename": "compiler/rustc_builtin_macros/src/concat_idents.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -27,15 +27,15 @@ pub fn expand_concat_idents<'cx>(\n                 }\n             }\n         } else {\n-            match e {\n-                TokenTree::Token(Token { kind: token::Ident(name, _), .. }) => {\n-                    res_str.push_str(&name.as_str())\n-                }\n-                _ => {\n-                    cx.span_err(sp, \"concat_idents! requires ident args.\");\n-                    return DummyResult::any(sp);\n+            if let TokenTree::Token(token) = e {\n+                if let Some((ident, _)) = token.ident() {\n+                    res_str.push_str(&ident.name.as_str());\n+                    continue;\n                 }\n             }\n+\n+            cx.span_err(sp, \"concat_idents! requires ident args.\");\n+            return DummyResult::any(sp);\n         }\n     }\n \n@@ -61,6 +61,7 @@ pub fn expand_concat_idents<'cx>(\n                 id: ast::DUMMY_NODE_ID,\n                 kind: ast::TyKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n+                tokens: None,\n             }))\n         }\n     }"}, {"sha": "d84b3956475d848be81faa7645c34327b4a5c08c", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -133,5 +133,5 @@ fn stmt_let_underscore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> as\n         span: sp,\n         attrs: ast::AttrVec::new(),\n     });\n-    ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span: sp }\n+    ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span: sp, tokens: None }\n }"}, {"sha": "f4924997d1af960ababae9bed61987be0d4e89a5", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -187,7 +187,6 @@ use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::source_map::respan;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n@@ -532,7 +531,11 @@ impl<'a> TraitDef<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident,\n-                vis: respan(self.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+                vis: ast::Visibility {\n+                    span: self.span.shrink_to_lo(),\n+                    kind: ast::VisibilityKind::Inherited,\n+                    tokens: None,\n+                },\n                 attrs: Vec::new(),\n                 kind: ast::AssocItemKind::TyAlias(\n                     ast::Defaultness::Final,\n@@ -933,7 +936,11 @@ impl<'a> MethodDef<'a> {\n             id: ast::DUMMY_NODE_ID,\n             attrs: self.attributes.clone(),\n             span: trait_.span,\n-            vis: respan(trait_lo_sp, ast::VisibilityKind::Inherited),\n+            vis: ast::Visibility {\n+                span: trait_lo_sp,\n+                kind: ast::VisibilityKind::Inherited,\n+                tokens: None,\n+            },\n             ident: method_ident,\n             kind: ast::AssocItemKind::Fn(def, sig, fn_generics, Some(body_block)),\n             tokens: None,\n@@ -1522,7 +1529,7 @@ impl<'a> TraitDef<'a> {\n             }\n         }\n \n-        let is_tuple = if let ast::VariantData::Tuple(..) = struct_def { true } else { false };\n+        let is_tuple = matches!(struct_def, ast::VariantData::Tuple(..));\n         match (just_spans.is_empty(), named_idents.is_empty()) {\n             (false, false) => cx.span_bug(\n                 self.span,"}, {"sha": "9c8e0fc2f016ccef14eb39ee1e048b82c783d024", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -75,6 +75,7 @@ fn call_intrinsic(\n         id: ast::DUMMY_NODE_ID,\n         rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n         span,\n+        tokens: None,\n     }))\n }\n "}, {"sha": "550524e652af7eb20327b5ac4b17503cea1552d4", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -543,9 +543,12 @@ impl<'a, 'b> Context<'a, 'b> {\n                             let idx = self.args.len();\n                             self.arg_types.push(Vec::new());\n                             self.arg_unique_types.push(Vec::new());\n-                            self.args.push(\n-                                self.ecx.expr_ident(self.fmtsp, Ident::new(name, self.fmtsp)),\n-                            );\n+                            let span = if self.is_literal {\n+                                *self.arg_spans.get(self.curpiece).unwrap_or(&self.fmtsp)\n+                            } else {\n+                                self.fmtsp\n+                            };\n+                            self.args.push(self.ecx.expr_ident(span, Ident::new(name, span)));\n                             self.names.insert(name, idx);\n                             self.verify_arg_type(Exact(idx), ty)\n                         } else {"}, {"sha": "ff81b5eca13a7e397c257fb2211197b59d6022d1", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -166,14 +166,14 @@ pub mod printf {\n             let cap = self.span.len() + if has_options { 2 } else { 0 };\n             let mut s = String::with_capacity(cap);\n \n-            s.push_str(\"{\");\n+            s.push('{');\n \n             if let Some(arg) = self.parameter {\n                 write!(s, \"{}\", arg.checked_sub(1)?).ok()?;\n             }\n \n             if has_options {\n-                s.push_str(\":\");\n+                s.push(':');\n \n                 let align = if let Some(fill) = fill {\n                     s.push_str(fill);\n@@ -191,19 +191,19 @@ pub mod printf {\n                 }\n \n                 if alt {\n-                    s.push_str(\"#\");\n+                    s.push('#');\n                 }\n \n                 if zero_fill {\n-                    s.push_str(\"0\");\n+                    s.push('0');\n                 }\n \n                 if let Some(width) = width {\n                     width.translate(&mut s).ok()?;\n                 }\n \n                 if let Some(precision) = precision {\n-                    s.push_str(\".\");\n+                    s.push('.');\n                     precision.translate(&mut s).ok()?;\n                 }\n \n@@ -212,7 +212,7 @@ pub mod printf {\n                 }\n             }\n \n-            s.push_str(\"}\");\n+            s.push('}');\n             Some(s)\n         }\n     }\n@@ -518,8 +518,7 @@ pub mod printf {\n                         .and_then(|end| end.at_next_cp())\n                         .map(|end| (next.slice_between(end).unwrap(), end));\n                     let end = match end {\n-                        Some((\"32\", end)) => end,\n-                        Some((\"64\", end)) => end,\n+                        Some((\"32\" | \"64\", end)) => end,\n                         _ => next,\n                     };\n                     state = Type;"}, {"sha": "3689e33be6f0f39b9bb7bea2a18bc42b9ed3665c", "filename": "compiler/rustc_builtin_macros/src/global_asm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -14,7 +14,6 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_errors::DiagnosticBuilder;\n use rustc_expand::base::{self, *};\n-use rustc_span::source_map::respan;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use smallvec::smallvec;\n@@ -30,7 +29,11 @@ pub fn expand_global_asm<'cx>(\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n             kind: ast::ItemKind::GlobalAsm(P(global_asm)),\n-            vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+            vis: ast::Visibility {\n+                span: sp.shrink_to_lo(),\n+                kind: ast::VisibilityKind::Inherited,\n+                tokens: None,\n+            },\n             span: cx.with_def_site_ctxt(sp),\n             tokens: None,\n         })]),"}, {"sha": "97cadb913cacff2d60c172df9954dd78c5f47a31", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,7 +1,7 @@\n //! This crate contains implementations of built-in macros and other code generating facilities\n //! injecting code into the crate before it is lowered to HIR.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]"}, {"sha": "c6ab3faf568979806feaf69aef02555a0996fc2a", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -98,7 +98,7 @@ pub fn inject(\n \n impl<'a> CollectProcMacros<'a> {\n     fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n-        if self.is_proc_macro_crate && self.in_root && vis.node.is_pub() {\n+        if self.is_proc_macro_crate && self.in_root && vis.kind.is_pub() {\n             self.handler.span_err(\n                 sp,\n                 \"`proc-macro` crate types currently cannot export any items other \\\n@@ -184,7 +184,7 @@ impl<'a> CollectProcMacros<'a> {\n             Vec::new()\n         };\n \n-        if self.in_root && item.vis.node.is_pub() {\n+        if self.in_root && item.vis.kind.is_pub() {\n             self.macros.push(ProcMacro::Derive(ProcMacroDerive {\n                 id: item.id,\n                 span: item.span,\n@@ -204,7 +204,7 @@ impl<'a> CollectProcMacros<'a> {\n     }\n \n     fn collect_attr_proc_macro(&mut self, item: &'a ast::Item) {\n-        if self.in_root && item.vis.node.is_pub() {\n+        if self.in_root && item.vis.kind.is_pub() {\n             self.macros.push(ProcMacro::Def(ProcMacroDef {\n                 id: item.id,\n                 span: item.span,\n@@ -223,7 +223,7 @@ impl<'a> CollectProcMacros<'a> {\n     }\n \n     fn collect_bang_proc_macro(&mut self, item: &'a ast::Item) {\n-        if self.in_root && item.vis.node.is_pub() {\n+        if self.in_root && item.vis.kind.is_pub() {\n             self.macros.push(ProcMacro::Def(ProcMacroDef {\n                 id: item.id,\n                 span: item.span,"}, {"sha": "1de0b32f5196b3b27b8a5632b171cbfaf42ca88e", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -7,7 +7,6 @@ use rustc_ast::attr;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::*;\n use rustc_session::Session;\n-use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n@@ -35,7 +34,11 @@ pub fn expand_test_case(\n     let sp = ecx.with_def_site_ctxt(attr_sp);\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n-        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n+        item.vis = ast::Visibility {\n+            span: item.vis.span,\n+            kind: ast::VisibilityKind::Public,\n+            tokens: None,\n+        };\n         item.ident.span = item.ident.span.with_ctxt(sp.ctxt());\n         item.attrs.push(ecx.attribute(ecx.meta_word(sp, sym::rustc_test_marker)));\n         item\n@@ -292,7 +295,7 @@ pub fn expand_test_or_bench(\n         ),\n     );\n     test_const = test_const.map(|mut tc| {\n-        tc.vis.node = ast::VisibilityKind::Public;\n+        tc.vis.kind = ast::VisibilityKind::Public;\n         tc\n     });\n "}, {"sha": "0a60ca8faaa12db7ad2a90d34cb6f318d9cc11b4", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -10,7 +10,6 @@ use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_feature::Features;\n use rustc_session::Session;\n use rustc_span::hygiene::{AstPass, SyntaxContext, Transparency};\n-use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::PanicStrategy;\n@@ -333,7 +332,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         kind: main,\n-        vis: respan(sp, ast::VisibilityKind::Public),\n+        vis: ast::Visibility { span: sp, kind: ast::VisibilityKind::Public, tokens: None },\n         span: sp,\n         tokens: None,\n     });"}, {"sha": "04792b334d553ff0ab70d7456208bebf8fe7bffb", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -25,7 +25,7 @@ rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_incremental = { path = \"../rustc_incremental\" }\n rustc_index = { path = \"../rustc_index\" }\n-rustc_llvm = { path = \"../../src/librustc_llvm\" }\n+rustc_llvm = { path = \"../rustc_llvm\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "e028b2c2dc763a1d57954ee4d27fccf22f43eb36", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -3,11 +3,17 @@ use libc::c_uint;\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n+use rustc_span::symbol::sym;\n \n use crate::llvm::{self, False, True};\n use crate::ModuleLlvm;\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n+pub(crate) unsafe fn codegen(\n+    tcx: TyCtxt<'_>,\n+    mods: &mut ModuleLlvm,\n+    kind: AllocatorKind,\n+    has_alloc_error_handler: bool,\n+) {\n     let llcx = &*mods.llcx;\n     let llmod = mods.llmod();\n     let usize = match &tcx.sess.target.target.target_pointer_width[..] {\n@@ -82,4 +88,41 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut ModuleLlvm, kind: Alloc\n         }\n         llvm::LLVMDisposeBuilder(llbuilder);\n     }\n+\n+    // rust alloc error handler\n+    let args = [usize, usize]; // size, align\n+\n+    let ty = llvm::LLVMFunctionType(void, args.as_ptr(), args.len() as c_uint, False);\n+    let name = format!(\"__rust_alloc_error_handler\");\n+    let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n+    // -> ! DIFlagNoReturn\n+    llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);\n+\n+    if tcx.sess.target.target.options.default_hidden_visibility {\n+        llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+    }\n+    if tcx.sess.must_emit_unwind_tables() {\n+        attributes::emit_uwtable(llfn, true);\n+    }\n+\n+    let kind = if has_alloc_error_handler { AllocatorKind::Global } else { AllocatorKind::Default };\n+    let callee = kind.fn_name(sym::oom);\n+    let callee = llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n+    // -> ! DIFlagNoReturn\n+    llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, callee);\n+    llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+\n+    let llbb = llvm::LLVMAppendBasicBlockInContext(llcx, llfn, \"entry\\0\".as_ptr().cast());\n+\n+    let llbuilder = llvm::LLVMCreateBuilderInContext(llcx);\n+    llvm::LLVMPositionBuilderAtEnd(llbuilder, llbb);\n+    let args = args\n+        .iter()\n+        .enumerate()\n+        .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n+        .collect::<Vec<_>>();\n+    let ret = llvm::LLVMRustBuildCall(llbuilder, callee, args.as_ptr(), args.len() as c_uint, None);\n+    llvm::LLVMSetTailCall(ret, True);\n+    llvm::LLVMBuildRetVoid(llbuilder);\n+    llvm::LLVMDisposeBuilder(llbuilder);\n }"}, {"sha": "f801f845ac16c410848f6fea06a90e1a016e7579", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -259,6 +259,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n                 InlineAsmArch::Nvptx64 => {}\n                 InlineAsmArch::Hexagon => {}\n+                InlineAsmArch::Mips => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -505,6 +506,8 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n             InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n@@ -551,6 +554,7 @@ fn modifier_to_llvm(\n             }\n         }\n         InlineAsmRegClass::Hexagon(_) => None,\n+        InlineAsmRegClass::Mips(_) => None,\n         InlineAsmRegClass::Nvptx(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n         | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n@@ -603,6 +607,8 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n             cx.type_vector(cx.type_i64(), 2)\n         }\n         InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n@@ -700,6 +706,12 @@ fn llvm_fixup_input(\n                 value\n             }\n         }\n+        (InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg), Abi::Scalar(s)) => match s.value {\n+            // MIPS only supports register-length arithmetics.\n+            Primitive::Int(Integer::I8 | Integer::I16, _) => bx.zext(value, bx.cx.type_i32()),\n+            Primitive::F32 => bx.bitcast(value, bx.cx.type_i32()),\n+            _ => value,\n+        },\n         _ => value,\n     }\n }\n@@ -768,6 +780,13 @@ fn llvm_fixup_output(\n                 value\n             }\n         }\n+        (InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg), Abi::Scalar(s)) => match s.value {\n+            // MIPS only supports register-length arithmetics.\n+            Primitive::Int(Integer::I8, _) => bx.trunc(value, bx.cx.type_i8()),\n+            Primitive::Int(Integer::I16, _) => bx.trunc(value, bx.cx.type_i16()),\n+            Primitive::F32 => bx.bitcast(value, bx.cx.type_f32()),\n+            _ => value,\n+        },\n         _ => value,\n     }\n }\n@@ -831,6 +850,12 @@ fn llvm_fixup_output_type(\n                 layout.llvm_type(cx)\n             }\n         }\n+        (InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg), Abi::Scalar(s)) => match s.value {\n+            // MIPS only supports register-length arithmetics.\n+            Primitive::Int(Integer::I8 | Integer::I16, _) => cx.type_i32(),\n+            Primitive::F32 => cx.type_i32(),\n+            _ => layout.llvm_type(cx),\n+        },\n         _ => layout.llvm_type(cx),\n     }\n }"}, {"sha": "a633ea5e5a9ae558a1c8b7c66097a52b51191e24", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -294,6 +294,9 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::ALLOCATOR) {\n         Attribute::NoAlias.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n     }\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY) {\n+        llvm::AddFunctionAttrString(llfn, Function, const_cstr!(\"cmse_nonsecure_entry\"));\n+    }\n     sanitize(cx, codegen_fn_attrs.no_sanitize, llfn);\n \n     // Always annotate functions with the target-cpu they are compiled for.\n@@ -346,17 +349,15 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n }\n \n pub fn provide(providers: &mut Providers) {\n+    use rustc_codegen_ssa::target_features::{all_known_features, supported_target_features};\n     providers.supported_target_features = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         if tcx.sess.opts.actually_rustdoc {\n             // rustdoc needs to be able to document functions that use all the features, so\n             // provide them all.\n-            llvm_util::all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n+            all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n         } else {\n-            llvm_util::supported_target_features(tcx.sess)\n-                .iter()\n-                .map(|&(a, b)| (a.to_string(), b))\n-                .collect()\n+            supported_target_features(tcx.sess).iter().map(|&(a, b)| (a.to_string(), b)).collect()\n         }\n     };\n "}, {"sha": "4b2d5907a02f46739dffe316149641aa579d76a9", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -346,14 +346,14 @@ fn fat_lto(\n     Ok(LtoModuleCodegen::Fat { module: Some(module), _serialized_bitcode: serialized_bitcode })\n }\n \n-struct Linker<'a>(&'a mut llvm::Linker<'a>);\n+crate struct Linker<'a>(&'a mut llvm::Linker<'a>);\n \n impl Linker<'a> {\n-    fn new(llmod: &'a llvm::Module) -> Self {\n+    crate fn new(llmod: &'a llvm::Module) -> Self {\n         unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n     }\n \n-    fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n+    crate fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n         unsafe {\n             if llvm::LLVMRustLinkerAdd(\n                 self.0,"}, {"sha": "f35c1016f86be77fcf0f9cec5275f2ca8f9adc4c", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -344,6 +344,13 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n             .expect(\"non-UTF8 diagnostic\");\n             diag_handler.warn(&msg);\n         }\n+        llvm::diagnostic::Unsupported(diagnostic_ref) => {\n+            let msg = llvm::build_string(|s| {\n+                llvm::LLVMRustWriteDiagnosticInfoToString(diagnostic_ref, s)\n+            })\n+            .expect(\"non-UTF8 diagnostic\");\n+            diag_handler.err(&msg);\n+        }\n         llvm::diagnostic::UnknownDiagnostic(..) => {}\n     }\n }\n@@ -617,6 +624,31 @@ unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static\n     }\n }\n \n+pub(crate) fn link(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n+    mut modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+) -> Result<ModuleCodegen<ModuleLlvm>, FatalError> {\n+    use super::lto::{Linker, ModuleBuffer};\n+    // Sort the modules by name to ensure to ensure deterministic behavior.\n+    modules.sort_by(|a, b| a.name.cmp(&b.name));\n+    let (first, elements) =\n+        modules.split_first().expect(\"Bug! modules must contain at least one module.\");\n+\n+    let mut linker = Linker::new(first.module_llvm.llmod());\n+    for module in elements {\n+        let _timer =\n+            cgcx.prof.generic_activity_with_arg(\"LLVM_link_module\", format!(\"{:?}\", module.name));\n+        let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n+        linker.add(&buffer.data()).map_err(|()| {\n+            let msg = format!(\"failed to serialize module {:?}\", module.name);\n+            llvm_err(&diag_handler, &msg)\n+        })?;\n+    }\n+    drop(linker);\n+    Ok(modules.remove(0))\n+}\n+\n pub(crate) unsafe fn codegen(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,"}, {"sha": "f35708b1d0965c4bc734a8f417ae9faf1d202102", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -108,7 +108,7 @@ pub fn compile_codegen_unit(\n \n     // We assume that the cost to run LLVM on a CGU is proportional to\n     // the time we needed for codegenning it.\n-    let cost = time_to_codegen.as_secs() * 1_000_000_000 + time_to_codegen.subsec_nanos() as u64;\n+    let cost = time_to_codegen.as_nanos() as u64;\n \n     fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);"}, {"sha": "0c172dc33baf00c27b419e0c05ab50b3e55112c2", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -21,7 +21,6 @@ use rustc_target::abi::{self, Align, Size};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n use std::ffi::CStr;\n-use std::iter::TrustedLen;\n use std::ops::{Deref, Range};\n use std::ptr;\n use tracing::debug;\n@@ -179,7 +178,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self,\n         v: &'ll Value,\n         else_llbb: &'ll BasicBlock,\n-        cases: impl ExactSizeIterator<Item = (u128, &'ll BasicBlock)> + TrustedLen,\n+        cases: impl ExactSizeIterator<Item = (u128, &'ll BasicBlock)>,\n     ) {\n         let switch =\n             unsafe { llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, cases.len() as c_uint) };\n@@ -931,7 +930,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, UNNAMED) }\n     }\n \n-    #[allow(dead_code)]\n     fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         unsafe { llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED) }\n     }"}, {"sha": "0992410a728bdac420428421d783add0e2bc3e91", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,5 +1,3 @@\n-#![allow(non_camel_case_types, non_snake_case)]\n-\n //! Code that is useful in various codegen modules.\n \n use crate::consts::{self, const_alloc_to_llvm};"}, {"sha": "6d3582d30276e87880f99aecd26339c8ac29430e", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -7,12 +7,13 @@ use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use libc::c_uint;\n use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::const_cstr;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer,\n+    read_target_uint, Allocation, ErrorHandled, GlobalAlloc, Pointer,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n@@ -22,8 +23,6 @@ use rustc_span::Span;\n use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n use tracing::debug;\n \n-use std::ffi::CStr;\n-\n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n     let dl = cx.data_layout();\n@@ -85,10 +84,7 @@ pub fn codegen_static_initializer(\n     cx: &CodegenCx<'ll, 'tcx>,\n     def_id: DefId,\n ) -> Result<(&'ll Value, &'tcx Allocation), ErrorHandled> {\n-    let alloc = match cx.tcx.const_eval_poly(def_id)? {\n-        ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => alloc,\n-        val => bug!(\"static const eval returned {:#?}\", val),\n-    };\n+    let alloc = cx.tcx.eval_static_initializer(def_id)?;\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))\n }\n \n@@ -457,9 +453,9 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                             .all(|&byte| byte == 0);\n \n                     let sect_name = if all_bytes_are_zero {\n-                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n+                        const_cstr!(\"__DATA,__thread_bss\")\n                     } else {\n-                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n+                        const_cstr!(\"__DATA,__thread_data\")\n                     };\n                     llvm::LLVMSetSection(g, sect_name.as_ptr());\n                 }"}, {"sha": "1696f35563d91a21448426ad6389b18481426db2", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -433,6 +433,17 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             llvm::LLVMSetSection(g, section.as_ptr());\n         }\n     }\n+\n+    fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n+        if self.get_declared_value(\"main\").is_none() {\n+            Some(self.declare_cfn(\"main\", fn_type))\n+        } else {\n+            // If the symbol already exists, it is an error: for example, the user wrote\n+            // #[no_mangle] extern \"C\" fn main(..) {..}\n+            // instead of #[start]\n+            None\n+        }\n+    }\n }\n \n impl CodegenCx<'b, 'tcx> {"}, {"sha": "0098555a3736b977aa175e572d1dda24c1a47fc5", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -126,6 +126,7 @@ impl CoverageMapGenerator {\n                 let (filenames_index, _) = self.filenames.insert_full(c_filename);\n                 virtual_file_mapping.push(filenames_index as u32);\n             }\n+            debug!(\"Adding counter {:?} to map for {:?}\", counter, region,);\n             mapping_regions.push(CounterMappingRegion::code_region(\n                 counter,\n                 current_file_id,"}, {"sha": "987149cb4c25c53ac587ea1c6d97fcbf920522bc", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1845,7 +1845,6 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n         None\n     }\n \n-    #[allow(dead_code)]\n     fn is_artificial(&self) -> bool {\n         match self {\n             VariantInfo::Generator { .. } => true,"}, {"sha": "9945d4f4282597901b1f84cf2c09d9ef0c2982a3", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/namespace.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fnamespace.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -27,11 +27,18 @@ pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n         .parent\n         .map(|parent| item_namespace(cx, DefId { krate: def_id.krate, index: parent }));\n \n+    let crate_name_as_str;\n+    let name_to_string;\n     let namespace_name = match def_key.disambiguated_data.data {\n-        DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate),\n-        data => data.as_symbol(),\n+        DefPathData::CrateRoot => {\n+            crate_name_as_str = cx.tcx.crate_name(def_id.krate).as_str();\n+            &*crate_name_as_str\n+        }\n+        data => {\n+            name_to_string = data.to_string();\n+            &*name_to_string\n+        }\n     };\n-    let namespace_name = namespace_name.as_str();\n \n     let scope = unsafe {\n         llvm::LLVMRustDIBuilderCreateNameSpace("}, {"sha": "a3d6882940a09b6e7f33822d32fe57e82bd180f3", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -51,42 +51,69 @@ fn declare_raw_fn(\n     llfn\n }\n \n-impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn declare_global(&self, name: &str, ty: &'ll Type) -> &'ll Value {\n+impl CodegenCx<'ll, 'tcx> {\n+    /// Declare a global value.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// return its Value instead.\n+    pub fn declare_global(&self, name: &str, ty: &'ll Type) -> &'ll Value {\n         debug!(\"declare_global(name={:?})\", name);\n         unsafe { llvm::LLVMRustGetOrInsertGlobal(self.llmod, name.as_ptr().cast(), name.len(), ty) }\n     }\n \n-    fn declare_cfn(&self, name: &str, fn_type: &'ll Type) -> &'ll Value {\n+    /// Declare a C ABI function.\n+    ///\n+    /// Only use this for foreign function ABIs and glue. For Rust functions use\n+    /// `declare_fn` instead.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// update the declaration and return existing Value instead.\n+    pub fn declare_cfn(&self, name: &str, fn_type: &'ll Type) -> &'ll Value {\n         declare_raw_fn(self, name, llvm::CCallConv, fn_type)\n     }\n \n-    fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Value {\n+    /// Declare a Rust function.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// update the declaration and return existing Value instead.\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Value {\n         debug!(\"declare_rust_fn(name={:?}, fn_abi={:?})\", name, fn_abi);\n \n         let llfn = declare_raw_fn(self, name, fn_abi.llvm_cconv(), fn_abi.llvm_type(self));\n         fn_abi.apply_attrs_llfn(self, llfn);\n         llfn\n     }\n \n-    fn define_global(&self, name: &str, ty: &'ll Type) -> Option<&'ll Value> {\n+    /// Declare a global with an intention to define it.\n+    ///\n+    /// Use this function when you intend to define a global. This function will\n+    /// return `None` if the name already has a definition associated with it. In that\n+    /// case an error should be reported to the user, because it usually happens due\n+    /// to user\u2019s fault (e.g., misuse of `#[no_mangle]` or `#[export_name]` attributes).\n+    pub fn define_global(&self, name: &str, ty: &'ll Type) -> Option<&'ll Value> {\n         if self.get_defined_value(name).is_some() {\n             None\n         } else {\n             Some(self.declare_global(name, ty))\n         }\n     }\n \n-    fn define_private_global(&self, ty: &'ll Type) -> &'ll Value {\n+    /// Declare a private global\n+    ///\n+    /// Use this function when you intend to define a global without a name.\n+    pub fn define_private_global(&self, ty: &'ll Type) -> &'ll Value {\n         unsafe { llvm::LLVMRustInsertPrivateGlobal(self.llmod, ty) }\n     }\n \n-    fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n+    /// Gets declared value by name.\n+    pub fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n         debug!(\"get_declared_value(name={:?})\", name);\n         unsafe { llvm::LLVMRustGetNamedValue(self.llmod, name.as_ptr().cast(), name.len()) }\n     }\n \n-    fn get_defined_value(&self, name: &str) -> Option<&'ll Value> {\n+    /// Gets defined or externally defined (AvailableExternally linkage) value by\n+    /// name.\n+    pub fn get_defined_value(&self, name: &str) -> Option<&'ll Value> {\n         self.get_declared_value(name).and_then(|val| {\n             let declaration = unsafe { llvm::LLVMIsDeclaration(val) != 0 };\n             if !declaration { Some(val) } else { None }"}, {"sha": "e76e86f56510ba02ef77c1fa81990bfafe93c670", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 523, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -7,15 +7,12 @@ use crate::type_of::LayoutLlvmExt;\n use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n-use rustc_ast as ast;\n use rustc_codegen_ssa::base::{compare_simd_types, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n-use rustc_codegen_ssa::glue;\n-use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n+use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n-use rustc_codegen_ssa::MemFlags;\n use rustc_hir as hir;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n@@ -71,8 +68,6 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<&'ll Va\n         sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n         sym::roundf32 => \"llvm.round.f32\",\n         sym::roundf64 => \"llvm.round.f64\",\n-        sym::assume => \"llvm.assume\",\n-        sym::abort => \"llvm.trap\",\n         _ => return None,\n     };\n     Some(cx.get_intrinsic(&llvm_name))\n@@ -112,9 +107,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                 None,\n             ),\n-            sym::unreachable => {\n-                return;\n-            }\n             sym::likely => {\n                 let expect = self.get_intrinsic(&(\"llvm.expect.i1\"));\n                 self.call(expect, &[args[0].immediate(), self.const_bool(true)], None)\n@@ -137,8 +129,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n-            sym::va_start => self.va_start(args[0].immediate()),\n-            sym::va_end => self.va_end(args[0].immediate()),\n             sym::va_copy => {\n                 let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n                 self.call(intrinsic, &[args[0].immediate(), args[1].immediate()], None)\n@@ -169,123 +159,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     _ => bug!(\"the va_arg intrinsic does not work with non-scalar types\"),\n                 }\n             }\n-            sym::size_of_val => {\n-                let tp_ty = substs.type_at(0);\n-                if let OperandValue::Pair(_, meta) = args[0].val {\n-                    let (llsize, _) = glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n-                    llsize\n-                } else {\n-                    self.const_usize(self.size_of(tp_ty).bytes())\n-                }\n-            }\n-            sym::min_align_of_val => {\n-                let tp_ty = substs.type_at(0);\n-                if let OperandValue::Pair(_, meta) = args[0].val {\n-                    let (_, llalign) = glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n-                    llalign\n-                } else {\n-                    self.const_usize(self.align_of(tp_ty).bytes())\n-                }\n-            }\n-            sym::size_of\n-            | sym::pref_align_of\n-            | sym::min_align_of\n-            | sym::needs_drop\n-            | sym::type_id\n-            | sym::type_name\n-            | sym::variant_count => {\n-                let value = self\n-                    .tcx\n-                    .const_eval_instance(ty::ParamEnv::reveal_all(), instance, None)\n-                    .unwrap();\n-                OperandRef::from_const(self, value, ret_ty).immediate_or_packed_pair(self)\n-            }\n-            // Effectively no-op\n-            sym::forget => {\n-                return;\n-            }\n-            sym::offset => {\n-                let ptr = args[0].immediate();\n-                let offset = args[1].immediate();\n-                self.inbounds_gep(ptr, &[offset])\n-            }\n-            sym::arith_offset => {\n-                let ptr = args[0].immediate();\n-                let offset = args[1].immediate();\n-                self.gep(ptr, &[offset])\n-            }\n-\n-            sym::copy_nonoverlapping => {\n-                copy_intrinsic(\n-                    self,\n-                    false,\n-                    false,\n-                    substs.type_at(0),\n-                    args[1].immediate(),\n-                    args[0].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n-            sym::copy => {\n-                copy_intrinsic(\n-                    self,\n-                    true,\n-                    false,\n-                    substs.type_at(0),\n-                    args[1].immediate(),\n-                    args[0].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n-            sym::write_bytes => {\n-                memset_intrinsic(\n-                    self,\n-                    false,\n-                    substs.type_at(0),\n-                    args[0].immediate(),\n-                    args[1].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n \n-            sym::volatile_copy_nonoverlapping_memory => {\n-                copy_intrinsic(\n-                    self,\n-                    false,\n-                    true,\n-                    substs.type_at(0),\n-                    args[0].immediate(),\n-                    args[1].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n-            sym::volatile_copy_memory => {\n-                copy_intrinsic(\n-                    self,\n-                    true,\n-                    true,\n-                    substs.type_at(0),\n-                    args[0].immediate(),\n-                    args[1].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n-            sym::volatile_set_memory => {\n-                memset_intrinsic(\n-                    self,\n-                    true,\n-                    substs.type_at(0),\n-                    args[0].immediate(),\n-                    args[1].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n             sym::volatile_load | sym::unaligned_volatile_load => {\n                 let tp_ty = substs.type_at(0);\n                 let mut ptr = args[0].immediate();\n@@ -343,20 +217,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             | sym::ctpop\n             | sym::bswap\n             | sym::bitreverse\n-            | sym::add_with_overflow\n-            | sym::sub_with_overflow\n-            | sym::mul_with_overflow\n-            | sym::wrapping_add\n-            | sym::wrapping_sub\n-            | sym::wrapping_mul\n-            | sym::unchecked_div\n-            | sym::unchecked_rem\n-            | sym::unchecked_shl\n-            | sym::unchecked_shr\n-            | sym::unchecked_add\n-            | sym::unchecked_sub\n-            | sym::unchecked_mul\n-            | sym::exact_div\n             | sym::rotate_left\n             | sym::rotate_right\n             | sym::saturating_add\n@@ -396,84 +256,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                             &[args[0].immediate()],\n                             None,\n                         ),\n-                        sym::add_with_overflow\n-                        | sym::sub_with_overflow\n-                        | sym::mul_with_overflow => {\n-                            let intrinsic = format!(\n-                                \"llvm.{}{}.with.overflow.i{}\",\n-                                if signed { 's' } else { 'u' },\n-                                &name_str[..3],\n-                                width\n-                            );\n-                            let llfn = self.get_intrinsic(&intrinsic);\n-\n-                            // Convert `i1` to a `bool`, and write it to the out parameter\n-                            let pair =\n-                                self.call(llfn, &[args[0].immediate(), args[1].immediate()], None);\n-                            let val = self.extract_value(pair, 0);\n-                            let overflow = self.extract_value(pair, 1);\n-                            let overflow = self.zext(overflow, self.type_bool());\n-\n-                            let dest = result.project_field(self, 0);\n-                            self.store(val, dest.llval, dest.align);\n-                            let dest = result.project_field(self, 1);\n-                            self.store(overflow, dest.llval, dest.align);\n-\n-                            return;\n-                        }\n-                        sym::wrapping_add => self.add(args[0].immediate(), args[1].immediate()),\n-                        sym::wrapping_sub => self.sub(args[0].immediate(), args[1].immediate()),\n-                        sym::wrapping_mul => self.mul(args[0].immediate(), args[1].immediate()),\n-                        sym::exact_div => {\n-                            if signed {\n-                                self.exactsdiv(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.exactudiv(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_div => {\n-                            if signed {\n-                                self.sdiv(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.udiv(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_rem => {\n-                            if signed {\n-                                self.srem(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.urem(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_shl => self.shl(args[0].immediate(), args[1].immediate()),\n-                        sym::unchecked_shr => {\n-                            if signed {\n-                                self.ashr(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.lshr(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_add => {\n-                            if signed {\n-                                self.unchecked_sadd(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.unchecked_uadd(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_sub => {\n-                            if signed {\n-                                self.unchecked_ssub(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.unchecked_usub(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_mul => {\n-                            if signed {\n-                                self.unchecked_smul(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.unchecked_umul(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n                         sym::rotate_left | sym::rotate_right => {\n                             let is_left = name == sym::rotate_left;\n                             let val = args[0].immediate();\n@@ -513,250 +295,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     }\n                 }\n             }\n-            sym::fadd_fast | sym::fsub_fast | sym::fmul_fast | sym::fdiv_fast | sym::frem_fast => {\n-                match float_type_width(arg_tys[0]) {\n-                    Some(_width) => match name {\n-                        sym::fadd_fast => self.fadd_fast(args[0].immediate(), args[1].immediate()),\n-                        sym::fsub_fast => self.fsub_fast(args[0].immediate(), args[1].immediate()),\n-                        sym::fmul_fast => self.fmul_fast(args[0].immediate(), args[1].immediate()),\n-                        sym::fdiv_fast => self.fdiv_fast(args[0].immediate(), args[1].immediate()),\n-                        sym::frem_fast => self.frem_fast(args[0].immediate(), args[1].immediate()),\n-                        _ => bug!(),\n-                    },\n-                    None => {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic float type, found `{}`\",\n-                                name, arg_tys[0]\n-                            ),\n-                        );\n-                        return;\n-                    }\n-                }\n-            }\n-\n-            sym::float_to_int_unchecked => {\n-                if float_type_width(arg_tys[0]).is_none() {\n-                    span_invalid_monomorphization_error(\n-                        tcx.sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                  intrinsic: expected basic float type, \\\n-                                  found `{}`\",\n-                            arg_tys[0]\n-                        ),\n-                    );\n-                    return;\n-                }\n-                let (width, signed) = match int_type_width_signed(ret_ty, self.cx) {\n-                    Some(pair) => pair,\n-                    None => {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                      intrinsic:  expected basic integer type, \\\n-                                      found `{}`\",\n-                                ret_ty\n-                            ),\n-                        );\n-                        return;\n-                    }\n-                };\n-                if signed {\n-                    self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n-                } else {\n-                    self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n-                }\n-            }\n-\n-            sym::discriminant_value => {\n-                if ret_ty.is_integral() {\n-                    args[0].deref(self.cx()).codegen_get_discr(self, ret_ty)\n-                } else {\n-                    span_bug!(span, \"Invalid discriminant type for `{:?}`\", arg_tys[0])\n-                }\n-            }\n \n             _ if name_str.starts_with(\"simd_\") => {\n                 match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                     Ok(llval) => llval,\n                     Err(()) => return,\n                 }\n             }\n-            // This requires that atomic intrinsics follow a specific naming pattern:\n-            // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n-            name if name_str.starts_with(\"atomic_\") => {\n-                use rustc_codegen_ssa::common::AtomicOrdering::*;\n-                use rustc_codegen_ssa::common::{AtomicRmwBinOp, SynchronizationScope};\n-\n-                let split: Vec<&str> = name_str.split('_').collect();\n-\n-                let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n-                let (order, failorder) = match split.len() {\n-                    2 => (SequentiallyConsistent, SequentiallyConsistent),\n-                    3 => match split[2] {\n-                        \"unordered\" => (Unordered, Unordered),\n-                        \"relaxed\" => (Monotonic, Monotonic),\n-                        \"acq\" => (Acquire, Acquire),\n-                        \"rel\" => (Release, Monotonic),\n-                        \"acqrel\" => (AcquireRelease, Acquire),\n-                        \"failrelaxed\" if is_cxchg => (SequentiallyConsistent, Monotonic),\n-                        \"failacq\" if is_cxchg => (SequentiallyConsistent, Acquire),\n-                        _ => self.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n-                    },\n-                    4 => match (split[2], split[3]) {\n-                        (\"acq\", \"failrelaxed\") if is_cxchg => (Acquire, Monotonic),\n-                        (\"acqrel\", \"failrelaxed\") if is_cxchg => (AcquireRelease, Monotonic),\n-                        _ => self.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n-                    },\n-                    _ => self.sess().fatal(\"Atomic intrinsic not in correct format\"),\n-                };\n-\n-                let invalid_monomorphization = |ty| {\n-                    span_invalid_monomorphization_error(\n-                        tcx.sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `{}` intrinsic: \\\n-                                  expected basic integer type, found `{}`\",\n-                            name, ty\n-                        ),\n-                    );\n-                };\n-\n-                match split[1] {\n-                    \"cxchg\" | \"cxchgweak\" => {\n-                        let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, self).is_some() {\n-                            let weak = split[1] == \"cxchgweak\";\n-                            let pair = self.atomic_cmpxchg(\n-                                args[0].immediate(),\n-                                args[1].immediate(),\n-                                args[2].immediate(),\n-                                order,\n-                                failorder,\n-                                weak,\n-                            );\n-                            let val = self.extract_value(pair, 0);\n-                            let success = self.extract_value(pair, 1);\n-                            let success = self.zext(success, self.type_bool());\n-\n-                            let dest = result.project_field(self, 0);\n-                            self.store(val, dest.llval, dest.align);\n-                            let dest = result.project_field(self, 1);\n-                            self.store(success, dest.llval, dest.align);\n-                            return;\n-                        } else {\n-                            return invalid_monomorphization(ty);\n-                        }\n-                    }\n-\n-                    \"load\" => {\n-                        let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, self).is_some() {\n-                            let size = self.size_of(ty);\n-                            self.atomic_load(args[0].immediate(), order, size)\n-                        } else {\n-                            return invalid_monomorphization(ty);\n-                        }\n-                    }\n-\n-                    \"store\" => {\n-                        let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, self).is_some() {\n-                            let size = self.size_of(ty);\n-                            self.atomic_store(\n-                                args[1].immediate(),\n-                                args[0].immediate(),\n-                                order,\n-                                size,\n-                            );\n-                            return;\n-                        } else {\n-                            return invalid_monomorphization(ty);\n-                        }\n-                    }\n-\n-                    \"fence\" => {\n-                        self.atomic_fence(order, SynchronizationScope::CrossThread);\n-                        return;\n-                    }\n-\n-                    \"singlethreadfence\" => {\n-                        self.atomic_fence(order, SynchronizationScope::SingleThread);\n-                        return;\n-                    }\n-\n-                    // These are all AtomicRMW ops\n-                    op => {\n-                        let atom_op = match op {\n-                            \"xchg\" => AtomicRmwBinOp::AtomicXchg,\n-                            \"xadd\" => AtomicRmwBinOp::AtomicAdd,\n-                            \"xsub\" => AtomicRmwBinOp::AtomicSub,\n-                            \"and\" => AtomicRmwBinOp::AtomicAnd,\n-                            \"nand\" => AtomicRmwBinOp::AtomicNand,\n-                            \"or\" => AtomicRmwBinOp::AtomicOr,\n-                            \"xor\" => AtomicRmwBinOp::AtomicXor,\n-                            \"max\" => AtomicRmwBinOp::AtomicMax,\n-                            \"min\" => AtomicRmwBinOp::AtomicMin,\n-                            \"umax\" => AtomicRmwBinOp::AtomicUMax,\n-                            \"umin\" => AtomicRmwBinOp::AtomicUMin,\n-                            _ => self.sess().fatal(\"unknown atomic operation\"),\n-                        };\n-\n-                        let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, self).is_some() {\n-                            self.atomic_rmw(\n-                                atom_op,\n-                                args[0].immediate(),\n-                                args[1].immediate(),\n-                                order,\n-                            )\n-                        } else {\n-                            return invalid_monomorphization(ty);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            sym::nontemporal_store => {\n-                let dst = args[0].deref(self.cx());\n-                args[1].val.nontemporal_store(self, dst);\n-                return;\n-            }\n-\n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                let a = args[0].immediate();\n-                let b = args[1].immediate();\n-                if name == sym::ptr_guaranteed_eq {\n-                    self.icmp(IntPredicate::IntEQ, a, b)\n-                } else {\n-                    self.icmp(IntPredicate::IntNE, a, b)\n-                }\n-            }\n-\n-            sym::ptr_offset_from => {\n-                let ty = substs.type_at(0);\n-                let pointee_size = self.size_of(ty);\n-\n-                // This is the same sequence that Clang emits for pointer subtraction.\n-                // It can be neither `nsw` nor `nuw` because the input is treated as\n-                // unsigned but then the output is treated as signed, so neither works.\n-                let a = args[0].immediate();\n-                let b = args[1].immediate();\n-                let a = self.ptrtoint(a, self.type_isize());\n-                let b = self.ptrtoint(b, self.type_isize());\n-                let d = self.sub(a, b);\n-                let pointee_size = self.const_usize(pointee_size.bytes());\n-                // this is where the signed magic happens (notice the `s` in `exactsdiv`)\n-                self.exactsdiv(d, pointee_size)\n-            }\n \n             _ => bug!(\"unknown intrinsic '{}'\", name),\n         };\n@@ -807,39 +352,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-fn copy_intrinsic(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n-    allow_overlap: bool,\n-    volatile: bool,\n-    ty: Ty<'tcx>,\n-    dst: &'ll Value,\n-    src: &'ll Value,\n-    count: &'ll Value,\n-) {\n-    let (size, align) = bx.size_and_align_of(ty);\n-    let size = bx.mul(bx.const_usize(size.bytes()), count);\n-    let flags = if volatile { MemFlags::VOLATILE } else { MemFlags::empty() };\n-    if allow_overlap {\n-        bx.memmove(dst, align, src, align, size, flags);\n-    } else {\n-        bx.memcpy(dst, align, src, align, size, flags);\n-    }\n-}\n-\n-fn memset_intrinsic(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n-    volatile: bool,\n-    ty: Ty<'tcx>,\n-    dst: &'ll Value,\n-    val: &'ll Value,\n-    count: &'ll Value,\n-) {\n-    let (size, align) = bx.size_and_align_of(ty);\n-    let size = bx.mul(bx.const_usize(size.bytes()), count);\n-    let flags = if volatile { MemFlags::VOLATILE } else { MemFlags::empty() };\n-    bx.memset(dst, val, size, align, flags);\n-}\n-\n fn try_intrinsic(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n     try_func: &'ll Value,\n@@ -1281,14 +793,18 @@ fn generic_simd_intrinsic(\n         require_simd!(arg_tys[1], \"argument\");\n         let v_len = arg_tys[1].simd_size(tcx);\n         require!(\n-            m_len == v_len,\n+            // Allow masks for vectors with fewer than 8 elements to be\n+            // represented with a u8 or i8.\n+            m_len == v_len || (m_len == 8 && v_len < 8),\n             \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n             m_len,\n             v_len\n         );\n         let i1 = bx.type_i1();\n-        let i1xn = bx.type_vector(i1, m_len);\n-        let m_i1s = bx.bitcast(args[0].immediate(), i1xn);\n+        let im = bx.type_ix(v_len);\n+        let i1xn = bx.type_vector(i1, v_len);\n+        let m_im = bx.trunc(args[0].immediate(), im);\n+        let m_i1s = bx.bitcast(m_im, i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n \n@@ -2205,37 +1721,12 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n // stuffs.\n fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, bool)> {\n     match ty.kind() {\n-        ty::Int(t) => Some((\n-            match t {\n-                ast::IntTy::Isize => u64::from(cx.tcx.sess.target.ptr_width),\n-                ast::IntTy::I8 => 8,\n-                ast::IntTy::I16 => 16,\n-                ast::IntTy::I32 => 32,\n-                ast::IntTy::I64 => 64,\n-                ast::IntTy::I128 => 128,\n-            },\n-            true,\n-        )),\n-        ty::Uint(t) => Some((\n-            match t {\n-                ast::UintTy::Usize => u64::from(cx.tcx.sess.target.ptr_width),\n-                ast::UintTy::U8 => 8,\n-                ast::UintTy::U16 => 16,\n-                ast::UintTy::U32 => 32,\n-                ast::UintTy::U64 => 64,\n-                ast::UintTy::U128 => 128,\n-            },\n-            false,\n-        )),\n-        _ => None,\n-    }\n-}\n-\n-// Returns the width of a float Ty\n-// Returns None if the type is not a float\n-fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n-    match ty.kind() {\n-        ty::Float(t) => Some(t.bit_width()),\n+        ty::Int(t) => {\n+            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.ptr_width)), true))\n+        }\n+        ty::Uint(t) => {\n+            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.ptr_width)), false))\n+        }\n         _ => None,\n     }\n }"}, {"sha": "1237b39b300ff0912a7d4b4ea185ac7cff209857", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,15 +4,14 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(const_cstr_unchecked)]\n #![feature(crate_visibility_modifier)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n-#![feature(trusted_len)]\n #![recursion_limit = \"256\"]\n \n use back::write::{create_informational_target_machine, create_target_machine};\n@@ -96,8 +95,9 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         tcx: TyCtxt<'tcx>,\n         mods: &mut ModuleLlvm,\n         kind: AllocatorKind,\n+        has_alloc_error_handler: bool,\n     ) {\n-        unsafe { allocator::codegen(tcx, mods, kind) }\n+        unsafe { allocator::codegen(tcx, mods, kind, has_alloc_error_handler) }\n     }\n     fn compile_codegen_unit(\n         &self,\n@@ -130,6 +130,13 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n             llvm::LLVMRustPrintPassTimings();\n         }\n     }\n+    fn run_link(\n+        cgcx: &CodegenContext<Self>,\n+        diag_handler: &Handler,\n+        modules: Vec<ModuleCodegen<Self::Module>>,\n+    ) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n+        back::write::link(cgcx, diag_handler, modules)\n+    }\n     fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<FatLTOInput<Self>>,"}, {"sha": "ccd3e42e458fd3aa9b7ff4c0e67adb1e0d898eb6", "filename": "compiler/rustc_codegen_llvm/src/llvm/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -118,6 +118,7 @@ pub enum Diagnostic<'ll> {\n     InlineAsm(InlineAsmDiagnostic<'ll>),\n     PGO(&'ll DiagnosticInfo),\n     Linker(&'ll DiagnosticInfo),\n+    Unsupported(&'ll DiagnosticInfo),\n \n     /// LLVM has other types that we do not wrap here.\n     UnknownDiagnostic(&'ll DiagnosticInfo),\n@@ -159,6 +160,7 @@ impl Diagnostic<'ll> {\n \n             Dk::PGOProfile => PGO(di),\n             Dk::Linker => Linker(di),\n+            Dk::Unsupported => Unsupported(di),\n \n             _ => UnknownDiagnostic(di),\n         }"}, {"sha": "af3f3e7aa03c0bbdae75a4c4ef665a8bd9836bc0", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -96,7 +96,7 @@ pub enum DLLStorageClass {\n     DllExport = 2, // Function to be accessible from DLL.\n }\n \n-/// Matches LLVMRustAttribute in rustllvm.h\n+/// Matches LLVMRustAttribute in LLVMWrapper.h\n /// Semantically a subset of the C++ enum llvm::Attribute::AttrKind,\n /// though it is not ABI compatible (since it's a C++ enum)\n #[repr(C)]\n@@ -483,6 +483,7 @@ pub enum DiagnosticKind {\n     OptimizationFailure,\n     PGOProfile,\n     Linker,\n+    Unsupported,\n }\n \n /// LLVMRustDiagnosticLevel\n@@ -948,7 +949,6 @@ extern \"C\" {\n \n     // Operations on other types\n     pub fn LLVMVoidTypeInContext(C: &Context) -> &Type;\n-    pub fn LLVMX86MMXTypeInContext(C: &Context) -> &Type;\n     pub fn LLVMRustMetadataTypeInContext(C: &Context) -> &Type;\n \n     // Operations on all values\n@@ -1705,7 +1705,7 @@ extern \"C\" {\n         PM: &PassManager<'_>,\n     );\n \n-    // Stuff that's in rustllvm/ because it's not upstream yet.\n+    // Stuff that's in llvm-wrapper/ because it's not upstream yet.\n \n     /// Opens an object file.\n     pub fn LLVMCreateObjectFile("}, {"sha": "ed9b99188bb9032deab557d0749b396a5b85c738", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -37,6 +37,12 @@ pub fn AddFunctionAttrStringValue(llfn: &'a Value, idx: AttributePlace, attr: &C\n     }\n }\n \n+pub fn AddFunctionAttrString(llfn: &'a Value, idx: AttributePlace, attr: &CStr) {\n+    unsafe {\n+        LLVMRustAddFunctionAttrStringValue(llfn, idx.as_uint(), attr.as_ptr(), std::ptr::null())\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub enum AttributePlace {\n     ReturnValue,"}, {"sha": "d42020047fddd44f4cf776a3f4e003c3877727e8", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 150, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,12 +1,12 @@\n use crate::back::write::create_informational_target_machine;\n use crate::llvm;\n use libc::c_int;\n+use rustc_codegen_ssa::target_features::supported_target_features;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_feature::UnstableFeatures;\n use rustc_middle::bug;\n use rustc_session::config::PrintRequest;\n use rustc_session::Session;\n-use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n use std::ffi::CString;\n@@ -139,141 +139,6 @@ pub fn time_trace_profiler_finish(file_name: &str) {\n // WARNING: the features after applying `to_llvm_feature` must be known\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n-\n-const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"aclass\", Some(sym::arm_target_feature)),\n-    (\"mclass\", Some(sym::arm_target_feature)),\n-    (\"rclass\", Some(sym::arm_target_feature)),\n-    (\"dsp\", Some(sym::arm_target_feature)),\n-    (\"neon\", Some(sym::arm_target_feature)),\n-    (\"crc\", Some(sym::arm_target_feature)),\n-    (\"crypto\", Some(sym::arm_target_feature)),\n-    (\"v5te\", Some(sym::arm_target_feature)),\n-    (\"v6\", Some(sym::arm_target_feature)),\n-    (\"v6k\", Some(sym::arm_target_feature)),\n-    (\"v6t2\", Some(sym::arm_target_feature)),\n-    (\"v7\", Some(sym::arm_target_feature)),\n-    (\"v8\", Some(sym::arm_target_feature)),\n-    (\"vfp2\", Some(sym::arm_target_feature)),\n-    (\"vfp3\", Some(sym::arm_target_feature)),\n-    (\"vfp4\", Some(sym::arm_target_feature)),\n-    // This is needed for inline assembly, but shouldn't be stabilized as-is\n-    // since it should be enabled per-function using #[instruction_set], not\n-    // #[target_feature].\n-    (\"thumb-mode\", Some(sym::arm_target_feature)),\n-];\n-\n-const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"fp\", Some(sym::aarch64_target_feature)),\n-    (\"neon\", Some(sym::aarch64_target_feature)),\n-    (\"sve\", Some(sym::aarch64_target_feature)),\n-    (\"crc\", Some(sym::aarch64_target_feature)),\n-    (\"crypto\", Some(sym::aarch64_target_feature)),\n-    (\"ras\", Some(sym::aarch64_target_feature)),\n-    (\"lse\", Some(sym::aarch64_target_feature)),\n-    (\"rdm\", Some(sym::aarch64_target_feature)),\n-    (\"fp16\", Some(sym::aarch64_target_feature)),\n-    (\"rcpc\", Some(sym::aarch64_target_feature)),\n-    (\"dotprod\", Some(sym::aarch64_target_feature)),\n-    (\"tme\", Some(sym::aarch64_target_feature)),\n-    (\"v8.1a\", Some(sym::aarch64_target_feature)),\n-    (\"v8.2a\", Some(sym::aarch64_target_feature)),\n-    (\"v8.3a\", Some(sym::aarch64_target_feature)),\n-];\n-\n-const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"adx\", Some(sym::adx_target_feature)),\n-    (\"aes\", None),\n-    (\"avx\", None),\n-    (\"avx2\", None),\n-    (\"avx512bw\", Some(sym::avx512_target_feature)),\n-    (\"avx512cd\", Some(sym::avx512_target_feature)),\n-    (\"avx512dq\", Some(sym::avx512_target_feature)),\n-    (\"avx512er\", Some(sym::avx512_target_feature)),\n-    (\"avx512f\", Some(sym::avx512_target_feature)),\n-    (\"avx512ifma\", Some(sym::avx512_target_feature)),\n-    (\"avx512pf\", Some(sym::avx512_target_feature)),\n-    (\"avx512vbmi\", Some(sym::avx512_target_feature)),\n-    (\"avx512vl\", Some(sym::avx512_target_feature)),\n-    (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n-    (\"bmi1\", None),\n-    (\"bmi2\", None),\n-    (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n-    (\"f16c\", Some(sym::f16c_target_feature)),\n-    (\"fma\", None),\n-    (\"fxsr\", None),\n-    (\"lzcnt\", None),\n-    (\"mmx\", Some(sym::mmx_target_feature)),\n-    (\"movbe\", Some(sym::movbe_target_feature)),\n-    (\"pclmulqdq\", None),\n-    (\"popcnt\", None),\n-    (\"rdrand\", None),\n-    (\"rdseed\", None),\n-    (\"rtm\", Some(sym::rtm_target_feature)),\n-    (\"sha\", None),\n-    (\"sse\", None),\n-    (\"sse2\", None),\n-    (\"sse3\", None),\n-    (\"sse4.1\", None),\n-    (\"sse4.2\", None),\n-    (\"sse4a\", Some(sym::sse4a_target_feature)),\n-    (\"ssse3\", None),\n-    (\"tbm\", Some(sym::tbm_target_feature)),\n-    (\"xsave\", None),\n-    (\"xsavec\", None),\n-    (\"xsaveopt\", None),\n-    (\"xsaves\", None),\n-];\n-\n-const HEXAGON_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"hvx\", Some(sym::hexagon_target_feature)),\n-    (\"hvx-length128b\", Some(sym::hexagon_target_feature)),\n-];\n-\n-const POWERPC_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"altivec\", Some(sym::powerpc_target_feature)),\n-    (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n-    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n-    (\"power8-vector\", Some(sym::powerpc_target_feature)),\n-    (\"power9-vector\", Some(sym::powerpc_target_feature)),\n-    (\"vsx\", Some(sym::powerpc_target_feature)),\n-];\n-\n-const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] =\n-    &[(\"fp64\", Some(sym::mips_target_feature)), (\"msa\", Some(sym::mips_target_feature))];\n-\n-const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"m\", Some(sym::riscv_target_feature)),\n-    (\"a\", Some(sym::riscv_target_feature)),\n-    (\"c\", Some(sym::riscv_target_feature)),\n-    (\"f\", Some(sym::riscv_target_feature)),\n-    (\"d\", Some(sym::riscv_target_feature)),\n-    (\"e\", Some(sym::riscv_target_feature)),\n-];\n-\n-const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"simd128\", Some(sym::wasm_target_feature)),\n-    (\"atomics\", Some(sym::wasm_target_feature)),\n-    (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n-];\n-\n-/// When rustdoc is running, provide a list of all known features so that all their respective\n-/// primitives may be documented.\n-///\n-/// IMPORTANT: If you're adding another feature list above, make sure to add it to this iterator!\n-pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol>)> {\n-    std::iter::empty()\n-        .chain(ARM_ALLOWED_FEATURES.iter())\n-        .chain(AARCH64_ALLOWED_FEATURES.iter())\n-        .chain(X86_ALLOWED_FEATURES.iter())\n-        .chain(HEXAGON_ALLOWED_FEATURES.iter())\n-        .chain(POWERPC_ALLOWED_FEATURES.iter())\n-        .chain(MIPS_ALLOWED_FEATURES.iter())\n-        .chain(RISCV_ALLOWED_FEATURES.iter())\n-        .chain(WASM_ALLOWED_FEATURES.iter())\n-        .cloned()\n-}\n-\n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n     let arch = if sess.target.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.target.arch };\n     match (arch, s) {\n@@ -307,20 +172,6 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n         .collect()\n }\n \n-pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Option<Symbol>)] {\n-    match &*sess.target.target.arch {\n-        \"arm\" => ARM_ALLOWED_FEATURES,\n-        \"aarch64\" => AARCH64_ALLOWED_FEATURES,\n-        \"x86\" | \"x86_64\" => X86_ALLOWED_FEATURES,\n-        \"hexagon\" => HEXAGON_ALLOWED_FEATURES,\n-        \"mips\" | \"mips64\" => MIPS_ALLOWED_FEATURES,\n-        \"powerpc\" | \"powerpc64\" => POWERPC_ALLOWED_FEATURES,\n-        \"riscv32\" | \"riscv64\" => RISCV_ALLOWED_FEATURES,\n-        \"wasm32\" => WASM_ALLOWED_FEATURES,\n-        _ => &[],\n-    }\n-}\n-\n pub fn print_version() {\n     // Can be called without initializing LLVM\n     unsafe {"}, {"sha": "a43724fd49599089a4f2c0e0ac2f61bd648068a6", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -62,10 +62,6 @@ impl CodegenCx<'ll, 'tcx> {\n         unsafe { llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint) }\n     }\n \n-    crate fn type_x86_mmx(&self) -> &'ll Type {\n-        unsafe { llvm::LLVMX86MMXTypeInContext(self.llcx) }\n-    }\n-\n     crate fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe { llvm::LLVMVectorType(ty, len as c_uint) }\n     }"}, {"sha": "e0754d21df1f09e38581da69ada26beabed6cc68", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -21,23 +21,8 @@ fn uncached_llvm_type<'a, 'tcx>(\n     match layout.abi {\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         Abi::Vector { ref element, count } => {\n-            // LLVM has a separate type for 64-bit SIMD vectors on X86 called\n-            // `x86_mmx` which is needed for some SIMD operations. As a bit of a\n-            // hack (all SIMD definitions are super unstable anyway) we\n-            // recognize any one-element SIMD vector as \"this should be an\n-            // x86_mmx\" type. In general there shouldn't be a need for other\n-            // one-element SIMD vectors, so it's assumed this won't clash with\n-            // much else.\n-            let use_x86_mmx = count == 1\n-                && layout.size.bits() == 64\n-                && (cx.sess().target.target.arch == \"x86\"\n-                    || cx.sess().target.target.arch == \"x86_64\");\n-            if use_x86_mmx {\n-                return cx.type_x86_mmx();\n-            } else {\n-                let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n-                return cx.type_vector(element, count);\n-            }\n+            let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n+            return cx.type_vector(element, count);\n         }\n         Abi::ScalarPair(..) => {\n             return cx.type_struct("}, {"sha": "22ed4dd7576b594374e427c5fa0a51a5062eb840", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -11,7 +11,6 @@ use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::Ty;\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size};\n \n-#[allow(dead_code)]\n fn round_pointer_up_to_alignment(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n     addr: &'ll Value,"}, {"sha": "503c51d24b682a74c03b33dd545d7242c6a0b96e", "filename": "compiler/rustc_codegen_ssa/src/back/command.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fcommand.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -111,6 +111,12 @@ impl Command {\n                     LldFlavor::Link => \"link\",\n                     LldFlavor::Ld64 => \"darwin\",\n                 });\n+                if let LldFlavor::Wasm = flavor {\n+                    // LLVM expects host-specific formatting for @file\n+                    // arguments, but we always generate posix formatted files\n+                    // at this time. Indicate as such.\n+                    c.arg(\"--rsp-quoting=posix\");\n+                }\n                 c\n             }\n         };"}, {"sha": "010fd4e9c5a2b675024a382f5ed7c382431ac898", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 90, "deletions": 4, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1076,7 +1076,7 @@ fn exec_linker(\n             }\n             .to_string(),\n         );\n-        args.push_str(\"\\n\");\n+        args.push('\\n');\n     }\n     let file = tmpdir.join(\"linker-arguments\");\n     let bytes = if sess.target.target.options.is_like_msvc {\n@@ -1333,9 +1333,6 @@ fn add_late_link_args(\n     crate_type: CrateType,\n     codegen_results: &CodegenResults,\n ) {\n-    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n     let any_dynamic_crate = crate_type == CrateType::Dylib\n         || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n             *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n@@ -1349,6 +1346,9 @@ fn add_late_link_args(\n             cmd.args(args);\n         }\n     }\n+    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n }\n \n /// Add arbitrary \"post-link\" args defined by the target spec.\n@@ -1524,6 +1524,9 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n     add_pre_link_args(cmd, sess, flavor);\n \n+    // NO-OPT-OUT, OBJECT-FILES-NO\n+    add_apple_sdk(cmd, sess, flavor);\n+\n     // NO-OPT-OUT\n     add_link_script(cmd, sess, tmpdir, crate_type);\n \n@@ -2083,3 +2086,86 @@ fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n         config::Lto::No | config::Lto::ThinLocal => false,\n     }\n }\n+\n+fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n+    let arch = &sess.target.target.arch;\n+    let os = &sess.target.target.target_os;\n+    let llvm_target = &sess.target.target.llvm_target;\n+    if sess.target.target.target_vendor != \"apple\"\n+        || !matches!(os.as_str(), \"ios\" | \"tvos\")\n+        || flavor != LinkerFlavor::Gcc\n+    {\n+        return;\n+    }\n+    let sdk_name = match (arch.as_str(), os.as_str()) {\n+        (\"aarch64\", \"tvos\") => \"appletvos\",\n+        (\"x86_64\", \"tvos\") => \"appletvsimulator\",\n+        (\"arm\", \"ios\") => \"iphoneos\",\n+        (\"aarch64\", \"ios\") => \"iphoneos\",\n+        (\"x86\", \"ios\") => \"iphonesimulator\",\n+        (\"x86_64\", \"ios\") if llvm_target.contains(\"macabi\") => \"macosx10.15\",\n+        (\"x86_64\", \"ios\") => \"iphonesimulator\",\n+        _ => {\n+            sess.err(&format!(\"unsupported arch `{}` for os `{}`\", arch, os));\n+            return;\n+        }\n+    };\n+    let sdk_root = match get_apple_sdk_root(sdk_name) {\n+        Ok(s) => s,\n+        Err(e) => {\n+            sess.err(&e);\n+            return;\n+        }\n+    };\n+    let arch_name = llvm_target.split('-').next().expect(\"LLVM target must have a hyphen\");\n+    cmd.args(&[\"-arch\", arch_name, \"-isysroot\", &sdk_root, \"-Wl,-syslibroot\", &sdk_root]);\n+}\n+\n+fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n+    // Following what clang does\n+    // (https://github.com/llvm/llvm-project/blob/\n+    // 296a80102a9b72c3eda80558fb78a3ed8849b341/clang/lib/Driver/ToolChains/Darwin.cpp#L1661-L1678)\n+    // to allow the SDK path to be set. (For clang, xcrun sets\n+    // SDKROOT; for rustc, the user or build system can set it, or we\n+    // can fall back to checking for xcrun on PATH.)\n+    if let Ok(sdkroot) = env::var(\"SDKROOT\") {\n+        let p = Path::new(&sdkroot);\n+        match sdk_name {\n+            // Ignore `SDKROOT` if it's clearly set for the wrong platform.\n+            \"appletvos\"\n+                if sdkroot.contains(\"TVSimulator.platform\")\n+                    || sdkroot.contains(\"MacOSX.platform\") => {}\n+            \"appletvsimulator\"\n+                if sdkroot.contains(\"TVOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {}\n+            \"iphoneos\"\n+                if sdkroot.contains(\"iPhoneSimulator.platform\")\n+                    || sdkroot.contains(\"MacOSX.platform\") => {}\n+            \"iphonesimulator\"\n+                if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {\n+            }\n+            \"macosx10.15\"\n+                if sdkroot.contains(\"iPhoneOS.platform\")\n+                    || sdkroot.contains(\"iPhoneSimulator.platform\") => {}\n+            // Ignore `SDKROOT` if it's not a valid path.\n+            _ if !p.is_absolute() || p == Path::new(\"/\") || !p.exists() => {}\n+            _ => return Ok(sdkroot),\n+        }\n+    }\n+    let res =\n+        Command::new(\"xcrun\").arg(\"--show-sdk-path\").arg(\"-sdk\").arg(sdk_name).output().and_then(\n+            |output| {\n+                if output.status.success() {\n+                    Ok(String::from_utf8(output.stdout).unwrap())\n+                } else {\n+                    let error = String::from_utf8(output.stderr);\n+                    let error = format!(\"process exit with error: {}\", error.unwrap());\n+                    Err(io::Error::new(io::ErrorKind::Other, &error[..]))\n+                }\n+            },\n+        );\n+\n+    match res {\n+        Ok(output) => Ok(output.trim().to_string()),\n+        Err(e) => Err(format!(\"failed to get {} SDK path: {}\", sdk_name, e)),\n+    }\n+}"}, {"sha": "0edf0fcd1a2642998b2bc59be8d47182f3bfa531", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -702,6 +702,7 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n \n enum WorkItemResult<B: WriteBackendMethods> {\n     Compiled(CompiledModule),\n+    NeedsLink(ModuleCodegen<B::Module>),\n     NeedsFatLTO(FatLTOInput<B>),\n     NeedsThinLTO(String, B::ThinBuffer),\n }\n@@ -801,31 +802,28 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n         None\n     };\n \n-    Ok(match lto_type {\n-        ComputedLtoType::No => {\n-            let module = unsafe { B::codegen(cgcx, &diag_handler, module, module_config)? };\n-            WorkItemResult::Compiled(module)\n-        }\n+    match lto_type {\n+        ComputedLtoType::No => finish_intra_module_work(cgcx, module, module_config),\n         ComputedLtoType::Thin => {\n             let (name, thin_buffer) = B::prepare_thin(module);\n             if let Some(path) = bitcode {\n                 fs::write(&path, thin_buffer.data()).unwrap_or_else(|e| {\n                     panic!(\"Error writing pre-lto-bitcode file `{}`: {}\", path.display(), e);\n                 });\n             }\n-            WorkItemResult::NeedsThinLTO(name, thin_buffer)\n+            Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))\n         }\n         ComputedLtoType::Fat => match bitcode {\n             Some(path) => {\n                 let (name, buffer) = B::serialize_module(module);\n                 fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n                     panic!(\"Error writing pre-lto-bitcode file `{}`: {}\", path.display(), e);\n                 });\n-                WorkItemResult::NeedsFatLTO(FatLTOInput::Serialized { name, buffer })\n+                Ok(WorkItemResult::NeedsFatLTO(FatLTOInput::Serialized { name, buffer }))\n             }\n-            None => WorkItemResult::NeedsFatLTO(FatLTOInput::InMemory(module)),\n+            None => Ok(WorkItemResult::NeedsFatLTO(FatLTOInput::InMemory(module))),\n         },\n-    })\n+    }\n }\n \n fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n@@ -870,13 +868,26 @@ fn execute_lto_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     mut module: lto::LtoModuleCodegen<B>,\n     module_config: &ModuleConfig,\n+) -> Result<WorkItemResult<B>, FatalError> {\n+    let module = unsafe { module.optimize(cgcx)? };\n+    finish_intra_module_work(cgcx, module, module_config)\n+}\n+\n+fn finish_intra_module_work<B: ExtraBackendMethods>(\n+    cgcx: &CodegenContext<B>,\n+    module: ModuleCodegen<B::Module>,\n+    module_config: &ModuleConfig,\n ) -> Result<WorkItemResult<B>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n \n-    unsafe {\n-        let module = module.optimize(cgcx)?;\n-        let module = B::codegen(cgcx, &diag_handler, module, module_config)?;\n+    if !cgcx.opts.debugging_opts.combine_cgu\n+        || module.kind == ModuleKind::Metadata\n+        || module.kind == ModuleKind::Allocator\n+    {\n+        let module = unsafe { B::codegen(cgcx, &diag_handler, module, module_config)? };\n         Ok(WorkItemResult::Compiled(module))\n+    } else {\n+        Ok(WorkItemResult::NeedsLink(module))\n     }\n }\n \n@@ -891,6 +902,10 @@ pub enum Message<B: WriteBackendMethods> {\n         thin_buffer: B::ThinBuffer,\n         worker_id: usize,\n     },\n+    NeedsLink {\n+        module: ModuleCodegen<B::Module>,\n+        worker_id: usize,\n+    },\n     Done {\n         result: Result<CompiledModule, Option<WorkerFatalError>>,\n         worker_id: usize,\n@@ -1178,6 +1193,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         let mut compiled_modules = vec![];\n         let mut compiled_metadata_module = None;\n         let mut compiled_allocator_module = None;\n+        let mut needs_link = Vec::new();\n         let mut needs_fat_lto = Vec::new();\n         let mut needs_thin_lto = Vec::new();\n         let mut lto_import_only_modules = Vec::new();\n@@ -1434,6 +1450,10 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                         }\n                     }\n                 }\n+                Message::NeedsLink { module, worker_id } => {\n+                    free_worker(worker_id);\n+                    needs_link.push(module);\n+                }\n                 Message::NeedsFatLTO { result, worker_id } => {\n                     assert!(!started_lto);\n                     free_worker(worker_id);\n@@ -1462,6 +1482,18 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             }\n         }\n \n+        let needs_link = mem::take(&mut needs_link);\n+        if !needs_link.is_empty() {\n+            assert!(compiled_modules.is_empty());\n+            let diag_handler = cgcx.create_diag_handler();\n+            let module = B::run_link(&cgcx, &diag_handler, needs_link).map_err(|_| ())?;\n+            let module = unsafe {\n+                B::codegen(&cgcx, &diag_handler, module, cgcx.config(ModuleKind::Regular))\n+                    .map_err(|_| ())?\n+            };\n+            compiled_modules.push(module);\n+        }\n+\n         // Drop to print timings\n         drop(llvm_start_time);\n \n@@ -1521,6 +1553,9 @@ fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>\n                     Some(Ok(WorkItemResult::Compiled(m))) => {\n                         Message::Done::<B> { result: Ok(m), worker_id }\n                     }\n+                    Some(Ok(WorkItemResult::NeedsLink(m))) => {\n+                        Message::NeedsLink::<B> { module: m, worker_id }\n+                    }\n                     Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n                         Message::NeedsFatLTO::<B> { result: m, worker_id }\n                     }"}, {"sha": "8e6f8e193c0e23024ddc9e4caf2bd8f4514716ed", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -407,16 +407,18 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         // listing.\n         let main_ret_ty = cx.tcx().erase_regions(&main_ret_ty.no_bound_vars().unwrap());\n \n-        if cx.get_declared_value(\"main\").is_some() {\n-            // FIXME: We should be smart and show a better diagnostic here.\n-            cx.sess()\n-                .struct_span_err(sp, \"entry symbol `main` declared multiple times\")\n-                .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n-                .emit();\n-            cx.sess().abort_if_errors();\n-            bug!();\n-        }\n-        let llfn = cx.declare_cfn(\"main\", llfty);\n+        let llfn = match cx.declare_c_main(llfty) {\n+            Some(llfn) => llfn,\n+            None => {\n+                // FIXME: We should be smart and show a better diagnostic here.\n+                cx.sess()\n+                    .struct_span_err(sp, \"entry symbol `main` declared multiple times\")\n+                    .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n+                    .emit();\n+                cx.sess().abort_if_errors();\n+                bug!();\n+            }\n+        };\n \n         // `main` should respect same config for frame pointer elimination as rest of code\n         cx.set_frame_pointer_elimination(llfn);\n@@ -536,8 +538,9 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let mut modules = backend.new_metadata(tcx, &llmod_id);\n-        tcx.sess\n-            .time(\"write_allocator_module\", || backend.codegen_allocator(tcx, &mut modules, kind));\n+        tcx.sess.time(\"write_allocator_module\", || {\n+            backend.codegen_allocator(tcx, &mut modules, kind, tcx.lang_items().oom().is_some())\n+        });\n \n         Some(ModuleCodegen { name: llmod_id, module_llvm: modules, kind: ModuleKind::Allocator })\n     } else {"}, {"sha": "780b1d2cd9433cc698a4d85061084bf888fe238b", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,4 +1,4 @@\n-#![allow(non_camel_case_types, non_snake_case)]\n+#![allow(non_camel_case_types)]\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -25,7 +25,6 @@ pub enum IntPredicate {\n     IntSLE,\n }\n \n-#[allow(dead_code)]\n pub enum RealPredicate {\n     RealPredicateFalse,\n     RealOEQ,\n@@ -60,7 +59,6 @@ pub enum AtomicRmwBinOp {\n }\n \n pub enum AtomicOrdering {\n-    #[allow(dead_code)]\n     NotAtomic,\n     Unordered,\n     Monotonic,"}, {"sha": "d8bde8ee70533afc75e7abe745b48bf1de619357", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -143,7 +143,9 @@ impl FunctionCoverage {\n         let id_to_counter =\n             |new_indexes: &IndexVec<InjectedExpressionIndex, MappedExpressionIndex>,\n              id: ExpressionOperandId| {\n-                if id.index() < self.counters.len() {\n+                if id == ExpressionOperandId::ZERO {\n+                    Some(Counter::zero())\n+                } else if id.index() < self.counters.len() {\n                     let index = CounterValueReference::from(id.index());\n                     self.counters\n                         .get(index)\n@@ -179,14 +181,19 @@ impl FunctionCoverage {\n                 // been assigned a `new_index`.\n                 let mapped_expression_index =\n                     MappedExpressionIndex::from(counter_expressions.len());\n-                counter_expressions.push(CounterExpression::new(\n+                let expression = CounterExpression::new(\n                     lhs_counter,\n                     match op {\n                         Op::Add => ExprKind::Add,\n                         Op::Subtract => ExprKind::Subtract,\n                     },\n                     rhs_counter,\n-                ));\n+                );\n+                debug!(\n+                    \"Adding expression {:?} = {:?} at {:?}\",\n+                    mapped_expression_index, expression, region\n+                );\n+                counter_expressions.push(expression);\n                 new_indexes[original_index] = mapped_expression_index;\n                 expression_regions.push((Counter::expression(mapped_expression_index), region));\n             }"}, {"sha": "45ecb793387d0cb454a10db70b1be8bca5bbbc6f", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -5,6 +5,8 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, subst::SubstsRef, Ty, TyCtxt};\n \n+use std::fmt::Write;\n+\n // Compute the name of the type as it should be stored in debuginfo. Does not do\n // any caching, i.e., calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n@@ -37,7 +39,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n         ty::Bool => output.push_str(\"bool\"),\n         ty::Char => output.push_str(\"char\"),\n         ty::Str => output.push_str(\"str\"),\n-        ty::Never => output.push_str(\"!\"),\n+        ty::Never => output.push('!'),\n         ty::Int(int_ty) => output.push_str(int_ty.name_str()),\n         ty::Uint(uint_ty) => output.push_str(uint_ty.name_str()),\n         ty::Float(float_ty) => output.push_str(float_ty.name_str()),\n@@ -228,8 +230,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n         if qualified {\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());\n             for path_element in tcx.def_path(def_id).data {\n-                output.push_str(\"::\");\n-                output.push_str(&path_element.data.as_symbol().as_str());\n+                write!(output, \"::{}\", path_element.data).unwrap();\n             }\n         } else {\n             output.push_str(&tcx.item_name(def_id).as_str());"}, {"sha": "e34371ef59ac4b45987f9ef39bf5a28e0d7ca260", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,15 +1,12 @@\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(option_expect_none)]\n #![feature(box_patterns)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n-#![feature(trusted_len)]\n #![feature(associated_type_bounds)]\n-#![feature(const_fn)] // for rustc_index::newtype_index\n-#![feature(const_panic)] // for rustc_index::newtype_index\n #![recursion_limit = \"256\"]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n@@ -45,6 +42,7 @@ pub mod glue;\n pub mod meth;\n pub mod mir;\n pub mod mono_item;\n+pub mod target_features;\n pub mod traits;\n \n pub struct ModuleCodegen<M> {"}, {"sha": "703a17b200a345abc2fc5758c6899dfa29b14d3c", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -13,7 +13,7 @@ use rustc_ast as ast;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{AllocId, ConstValue, Pointer, Scalar};\n+use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -687,7 +687,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 })\n                 .collect();\n \n-            bx.codegen_intrinsic_call(\n+            Self::codegen_intrinsic_call(\n+                &mut bx,\n                 *instance.as_ref().unwrap(),\n                 &fn_abi,\n                 &args,\n@@ -867,24 +868,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let ty = constant.literal.ty;\n                         let size = bx.layout_of(ty).size;\n                         let scalar = match const_value {\n-                            // Promoted constants are evaluated into a ByRef instead of a Scalar,\n-                            // but we want the scalar value here.\n-                            ConstValue::ByRef { alloc, offset } => {\n-                                let ptr = Pointer::new(AllocId(0), offset);\n-                                alloc\n-                                    .read_scalar(&bx, ptr, size)\n-                                    .and_then(|s| s.check_init())\n-                                    .unwrap_or_else(|e| {\n-                                        bx.tcx().sess.span_err(\n-                                            span,\n-                                            &format!(\"Could not evaluate asm const: {}\", e),\n-                                        );\n-\n-                                        // We are erroring out, just emit a dummy constant.\n-                                        Scalar::from_u64(0)\n-                                    })\n-                            }\n-                            _ => span_bug!(span, \"expected ByRef for promoted asm const\"),\n+                            ConstValue::Scalar(s) => s,\n+                            _ => span_bug!(\n+                                span,\n+                                \"expected Scalar for promoted asm const, but got {:#?}\",\n+                                const_value\n+                            ),\n                         };\n                         let value = scalar.assert_bits(size);\n                         let string = match ty.kind() {"}, {"sha": "14f1ed59a67c5f1704e9f5d7a0100df80c0e80b7", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,596 @@\n+use super::operand::{OperandRef, OperandValue};\n+use super::place::PlaceRef;\n+use super::FunctionCx;\n+use crate::common::{span_invalid_monomorphization_error, IntPredicate};\n+use crate::glue;\n+use crate::traits::*;\n+use crate::MemFlags;\n+\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::{sym, Span};\n+use rustc_target::abi::call::{FnAbi, PassMode};\n+\n+fn copy_intrinsic<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    allow_overlap: bool,\n+    volatile: bool,\n+    ty: Ty<'tcx>,\n+    dst: Bx::Value,\n+    src: Bx::Value,\n+    count: Bx::Value,\n+) {\n+    let layout = bx.layout_of(ty);\n+    let size = layout.size;\n+    let align = layout.align.abi;\n+    let size = bx.mul(bx.const_usize(size.bytes()), count);\n+    let flags = if volatile { MemFlags::VOLATILE } else { MemFlags::empty() };\n+    if allow_overlap {\n+        bx.memmove(dst, align, src, align, size, flags);\n+    } else {\n+        bx.memcpy(dst, align, src, align, size, flags);\n+    }\n+}\n+\n+fn memset_intrinsic<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    volatile: bool,\n+    ty: Ty<'tcx>,\n+    dst: Bx::Value,\n+    val: Bx::Value,\n+    count: Bx::Value,\n+) {\n+    let layout = bx.layout_of(ty);\n+    let size = layout.size;\n+    let align = layout.align.abi;\n+    let size = bx.mul(bx.const_usize(size.bytes()), count);\n+    let flags = if volatile { MemFlags::VOLATILE } else { MemFlags::empty() };\n+    bx.memset(dst, val, size, align, flags);\n+}\n+\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn codegen_intrinsic_call(\n+        bx: &mut Bx,\n+        instance: ty::Instance<'tcx>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        args: &[OperandRef<'tcx, Bx::Value>],\n+        llresult: Bx::Value,\n+        span: Span,\n+    ) {\n+        let callee_ty = instance.ty(bx.tcx(), ty::ParamEnv::reveal_all());\n+\n+        let (def_id, substs) = match *callee_ty.kind() {\n+            ty::FnDef(def_id, substs) => (def_id, substs),\n+            _ => bug!(\"expected fn item type, found {}\", callee_ty),\n+        };\n+\n+        let sig = callee_ty.fn_sig(bx.tcx());\n+        let sig = bx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        let arg_tys = sig.inputs();\n+        let ret_ty = sig.output();\n+        let name = bx.tcx().item_name(def_id);\n+        let name_str = &*name.as_str();\n+\n+        let llret_ty = bx.backend_type(bx.layout_of(ret_ty));\n+        let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n+\n+        let llval = match name {\n+            sym::assume => {\n+                bx.assume(args[0].immediate());\n+                return;\n+            }\n+            sym::abort => {\n+                bx.abort();\n+                return;\n+            }\n+\n+            sym::unreachable => {\n+                return;\n+            }\n+            sym::va_start => bx.va_start(args[0].immediate()),\n+            sym::va_end => bx.va_end(args[0].immediate()),\n+            sym::size_of_val => {\n+                let tp_ty = substs.type_at(0);\n+                if let OperandValue::Pair(_, meta) = args[0].val {\n+                    let (llsize, _) = glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n+                    llsize\n+                } else {\n+                    bx.const_usize(bx.layout_of(tp_ty).size.bytes())\n+                }\n+            }\n+            sym::min_align_of_val => {\n+                let tp_ty = substs.type_at(0);\n+                if let OperandValue::Pair(_, meta) = args[0].val {\n+                    let (_, llalign) = glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n+                    llalign\n+                } else {\n+                    bx.const_usize(bx.layout_of(tp_ty).align.abi.bytes())\n+                }\n+            }\n+            sym::size_of\n+            | sym::pref_align_of\n+            | sym::min_align_of\n+            | sym::needs_drop\n+            | sym::type_id\n+            | sym::type_name\n+            | sym::variant_count => {\n+                let value = bx\n+                    .tcx()\n+                    .const_eval_instance(ty::ParamEnv::reveal_all(), instance, None)\n+                    .unwrap();\n+                OperandRef::from_const(bx, value, ret_ty).immediate_or_packed_pair(bx)\n+            }\n+            // Effectively no-op\n+            sym::forget => {\n+                return;\n+            }\n+            sym::offset => {\n+                let ptr = args[0].immediate();\n+                let offset = args[1].immediate();\n+                bx.inbounds_gep(ptr, &[offset])\n+            }\n+            sym::arith_offset => {\n+                let ptr = args[0].immediate();\n+                let offset = args[1].immediate();\n+                bx.gep(ptr, &[offset])\n+            }\n+\n+            sym::copy_nonoverlapping => {\n+                copy_intrinsic(\n+                    bx,\n+                    false,\n+                    false,\n+                    substs.type_at(0),\n+                    args[1].immediate(),\n+                    args[0].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::copy => {\n+                copy_intrinsic(\n+                    bx,\n+                    true,\n+                    false,\n+                    substs.type_at(0),\n+                    args[1].immediate(),\n+                    args[0].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::write_bytes => {\n+                memset_intrinsic(\n+                    bx,\n+                    false,\n+                    substs.type_at(0),\n+                    args[0].immediate(),\n+                    args[1].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+\n+            sym::volatile_copy_nonoverlapping_memory => {\n+                copy_intrinsic(\n+                    bx,\n+                    false,\n+                    true,\n+                    substs.type_at(0),\n+                    args[0].immediate(),\n+                    args[1].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::volatile_copy_memory => {\n+                copy_intrinsic(\n+                    bx,\n+                    true,\n+                    true,\n+                    substs.type_at(0),\n+                    args[0].immediate(),\n+                    args[1].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::volatile_set_memory => {\n+                memset_intrinsic(\n+                    bx,\n+                    true,\n+                    substs.type_at(0),\n+                    args[0].immediate(),\n+                    args[1].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::volatile_store => {\n+                let dst = args[0].deref(bx.cx());\n+                args[1].val.volatile_store(bx, dst);\n+                return;\n+            }\n+            sym::unaligned_volatile_store => {\n+                let dst = args[0].deref(bx.cx());\n+                args[1].val.unaligned_volatile_store(bx, dst);\n+                return;\n+            }\n+            sym::add_with_overflow\n+            | sym::sub_with_overflow\n+            | sym::mul_with_overflow\n+            | sym::wrapping_add\n+            | sym::wrapping_sub\n+            | sym::wrapping_mul\n+            | sym::unchecked_div\n+            | sym::unchecked_rem\n+            | sym::unchecked_shl\n+            | sym::unchecked_shr\n+            | sym::unchecked_add\n+            | sym::unchecked_sub\n+            | sym::unchecked_mul\n+            | sym::exact_div => {\n+                let ty = arg_tys[0];\n+                match int_type_width_signed(ty, bx.tcx()) {\n+                    Some((_width, signed)) => match name {\n+                        sym::add_with_overflow\n+                        | sym::sub_with_overflow\n+                        | sym::mul_with_overflow => {\n+                            let op = match name {\n+                                sym::add_with_overflow => OverflowOp::Add,\n+                                sym::sub_with_overflow => OverflowOp::Sub,\n+                                sym::mul_with_overflow => OverflowOp::Mul,\n+                                _ => bug!(),\n+                            };\n+                            let (val, overflow) =\n+                                bx.checked_binop(op, ty, args[0].immediate(), args[1].immediate());\n+                            // Convert `i1` to a `bool`, and write it to the out parameter\n+                            let val = bx.from_immediate(val);\n+                            let overflow = bx.from_immediate(overflow);\n+\n+                            let dest = result.project_field(bx, 0);\n+                            bx.store(val, dest.llval, dest.align);\n+                            let dest = result.project_field(bx, 1);\n+                            bx.store(overflow, dest.llval, dest.align);\n+\n+                            return;\n+                        }\n+                        sym::wrapping_add => bx.add(args[0].immediate(), args[1].immediate()),\n+                        sym::wrapping_sub => bx.sub(args[0].immediate(), args[1].immediate()),\n+                        sym::wrapping_mul => bx.mul(args[0].immediate(), args[1].immediate()),\n+                        sym::exact_div => {\n+                            if signed {\n+                                bx.exactsdiv(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.exactudiv(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_div => {\n+                            if signed {\n+                                bx.sdiv(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.udiv(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_rem => {\n+                            if signed {\n+                                bx.srem(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.urem(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_shl => bx.shl(args[0].immediate(), args[1].immediate()),\n+                        sym::unchecked_shr => {\n+                            if signed {\n+                                bx.ashr(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.lshr(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_add => {\n+                            if signed {\n+                                bx.unchecked_sadd(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.unchecked_uadd(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_sub => {\n+                            if signed {\n+                                bx.unchecked_ssub(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.unchecked_usub(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_mul => {\n+                            if signed {\n+                                bx.unchecked_smul(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.unchecked_umul(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        _ => bug!(),\n+                    },\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            bx.tcx().sess,\n+                            span,\n+                            &format!(\n+                                \"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\",\n+                                name, ty\n+                            ),\n+                        );\n+                        return;\n+                    }\n+                }\n+            }\n+            sym::fadd_fast | sym::fsub_fast | sym::fmul_fast | sym::fdiv_fast | sym::frem_fast => {\n+                match float_type_width(arg_tys[0]) {\n+                    Some(_width) => match name {\n+                        sym::fadd_fast => bx.fadd_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fsub_fast => bx.fsub_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fmul_fast => bx.fmul_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fdiv_fast => bx.fdiv_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::frem_fast => bx.frem_fast(args[0].immediate(), args[1].immediate()),\n+                        _ => bug!(),\n+                    },\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            bx.tcx().sess,\n+                            span,\n+                            &format!(\n+                                \"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic float type, found `{}`\",\n+                                name, arg_tys[0]\n+                            ),\n+                        );\n+                        return;\n+                    }\n+                }\n+            }\n+\n+            sym::float_to_int_unchecked => {\n+                if float_type_width(arg_tys[0]).is_none() {\n+                    span_invalid_monomorphization_error(\n+                        bx.tcx().sess,\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `float_to_int_unchecked` \\\n+                                  intrinsic: expected basic float type, \\\n+                                  found `{}`\",\n+                            arg_tys[0]\n+                        ),\n+                    );\n+                    return;\n+                }\n+                let (_width, signed) = match int_type_width_signed(ret_ty, bx.tcx()) {\n+                    Some(pair) => pair,\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            bx.tcx().sess,\n+                            span,\n+                            &format!(\n+                                \"invalid monomorphization of `float_to_int_unchecked` \\\n+                                      intrinsic:  expected basic integer type, \\\n+                                      found `{}`\",\n+                                ret_ty\n+                            ),\n+                        );\n+                        return;\n+                    }\n+                };\n+                if signed {\n+                    bx.fptosi(args[0].immediate(), llret_ty)\n+                } else {\n+                    bx.fptoui(args[0].immediate(), llret_ty)\n+                }\n+            }\n+\n+            sym::discriminant_value => {\n+                if ret_ty.is_integral() {\n+                    args[0].deref(bx.cx()).codegen_get_discr(bx, ret_ty)\n+                } else {\n+                    span_bug!(span, \"Invalid discriminant type for `{:?}`\", arg_tys[0])\n+                }\n+            }\n+\n+            // This requires that atomic intrinsics follow a specific naming pattern:\n+            // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n+            name if name_str.starts_with(\"atomic_\") => {\n+                use crate::common::AtomicOrdering::*;\n+                use crate::common::{AtomicRmwBinOp, SynchronizationScope};\n+\n+                let split: Vec<&str> = name_str.split('_').collect();\n+\n+                let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n+                let (order, failorder) = match split.len() {\n+                    2 => (SequentiallyConsistent, SequentiallyConsistent),\n+                    3 => match split[2] {\n+                        \"unordered\" => (Unordered, Unordered),\n+                        \"relaxed\" => (Monotonic, Monotonic),\n+                        \"acq\" => (Acquire, Acquire),\n+                        \"rel\" => (Release, Monotonic),\n+                        \"acqrel\" => (AcquireRelease, Acquire),\n+                        \"failrelaxed\" if is_cxchg => (SequentiallyConsistent, Monotonic),\n+                        \"failacq\" if is_cxchg => (SequentiallyConsistent, Acquire),\n+                        _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n+                    },\n+                    4 => match (split[2], split[3]) {\n+                        (\"acq\", \"failrelaxed\") if is_cxchg => (Acquire, Monotonic),\n+                        (\"acqrel\", \"failrelaxed\") if is_cxchg => (AcquireRelease, Monotonic),\n+                        _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n+                    },\n+                    _ => bx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n+                };\n+\n+                let invalid_monomorphization = |ty| {\n+                    span_invalid_monomorphization_error(\n+                        bx.tcx().sess,\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `{}` intrinsic: \\\n+                                  expected basic integer type, found `{}`\",\n+                            name, ty\n+                        ),\n+                    );\n+                };\n+\n+                match split[1] {\n+                    \"cxchg\" | \"cxchgweak\" => {\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                            let weak = split[1] == \"cxchgweak\";\n+                            let pair = bx.atomic_cmpxchg(\n+                                args[0].immediate(),\n+                                args[1].immediate(),\n+                                args[2].immediate(),\n+                                order,\n+                                failorder,\n+                                weak,\n+                            );\n+                            let val = bx.extract_value(pair, 0);\n+                            let success = bx.extract_value(pair, 1);\n+                            let val = bx.from_immediate(val);\n+                            let success = bx.from_immediate(success);\n+\n+                            let dest = result.project_field(bx, 0);\n+                            bx.store(val, dest.llval, dest.align);\n+                            let dest = result.project_field(bx, 1);\n+                            bx.store(success, dest.llval, dest.align);\n+                            return;\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n+                    }\n+\n+                    \"load\" => {\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                            let size = bx.layout_of(ty).size;\n+                            bx.atomic_load(args[0].immediate(), order, size)\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n+                    }\n+\n+                    \"store\" => {\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                            let size = bx.layout_of(ty).size;\n+                            bx.atomic_store(args[1].immediate(), args[0].immediate(), order, size);\n+                            return;\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n+                    }\n+\n+                    \"fence\" => {\n+                        bx.atomic_fence(order, SynchronizationScope::CrossThread);\n+                        return;\n+                    }\n+\n+                    \"singlethreadfence\" => {\n+                        bx.atomic_fence(order, SynchronizationScope::SingleThread);\n+                        return;\n+                    }\n+\n+                    // These are all AtomicRMW ops\n+                    op => {\n+                        let atom_op = match op {\n+                            \"xchg\" => AtomicRmwBinOp::AtomicXchg,\n+                            \"xadd\" => AtomicRmwBinOp::AtomicAdd,\n+                            \"xsub\" => AtomicRmwBinOp::AtomicSub,\n+                            \"and\" => AtomicRmwBinOp::AtomicAnd,\n+                            \"nand\" => AtomicRmwBinOp::AtomicNand,\n+                            \"or\" => AtomicRmwBinOp::AtomicOr,\n+                            \"xor\" => AtomicRmwBinOp::AtomicXor,\n+                            \"max\" => AtomicRmwBinOp::AtomicMax,\n+                            \"min\" => AtomicRmwBinOp::AtomicMin,\n+                            \"umax\" => AtomicRmwBinOp::AtomicUMax,\n+                            \"umin\" => AtomicRmwBinOp::AtomicUMin,\n+                            _ => bx.sess().fatal(\"unknown atomic operation\"),\n+                        };\n+\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                            bx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            sym::nontemporal_store => {\n+                let dst = args[0].deref(bx.cx());\n+                args[1].val.nontemporal_store(bx, dst);\n+                return;\n+            }\n+\n+            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                if name == sym::ptr_guaranteed_eq {\n+                    bx.icmp(IntPredicate::IntEQ, a, b)\n+                } else {\n+                    bx.icmp(IntPredicate::IntNE, a, b)\n+                }\n+            }\n+\n+            sym::ptr_offset_from => {\n+                let ty = substs.type_at(0);\n+                let pointee_size = bx.layout_of(ty).size;\n+\n+                // This is the same sequence that Clang emits for pointer subtraction.\n+                // It can be neither `nsw` nor `nuw` because the input is treated as\n+                // unsigned but then the output is treated as signed, so neither works.\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                let a = bx.ptrtoint(a, bx.type_isize());\n+                let b = bx.ptrtoint(b, bx.type_isize());\n+                let d = bx.sub(a, b);\n+                let pointee_size = bx.const_usize(pointee_size.bytes());\n+                // this is where the signed magic happens (notice the `s` in `exactsdiv`)\n+                bx.exactsdiv(d, pointee_size)\n+            }\n+\n+            _ => {\n+                // Need to use backend-specific things in the implementation.\n+                bx.codegen_intrinsic_call(instance, fn_abi, args, llresult, span);\n+                return;\n+            }\n+        };\n+\n+        if !fn_abi.ret.is_ignore() {\n+            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                let ptr_llty = bx.type_ptr_to(bx.cast_backend_type(&ty));\n+                let ptr = bx.pointercast(result.llval, ptr_llty);\n+                bx.store(llval, ptr, result.align);\n+            } else {\n+                OperandRef::from_immediate_or_packed_pair(bx, llval, result.layout)\n+                    .val\n+                    .store(bx, result);\n+            }\n+        }\n+    }\n+}\n+\n+// Returns the width of an int Ty, and if it's signed or not\n+// Returns None if the type is not an integer\n+// FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n+// stuffs.\n+fn int_type_width_signed(ty: Ty<'_>, tcx: TyCtxt<'_>) -> Option<(u64, bool)> {\n+    match ty.kind() {\n+        ty::Int(t) => Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.ptr_width)), true)),\n+        ty::Uint(t) => Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.ptr_width)), false)),\n+        _ => None,\n+    }\n+}\n+\n+// Returns the width of a float Ty\n+// Returns None if the type is not a float\n+fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n+    match ty.kind() {\n+        ty::Float(t) => Some(t.bit_width()),\n+        _ => None,\n+    }\n+}"}, {"sha": "64d456fb7aa67b8dd6afb816e61d215eb31873a2", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -486,6 +486,7 @@ mod block;\n pub mod constant;\n pub mod coverageinfo;\n pub mod debuginfo;\n+mod intrinsic;\n pub mod operand;\n pub mod place;\n mod rvalue;"}, {"sha": "91609b226158bbf8dbdc1511e24d2234fc8e12e1", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -93,15 +93,33 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         let effective_field_align = self.align.restrict_for_offset(offset);\n \n         let mut simple = || {\n-            // Unions and newtypes only use an offset of 0.\n-            let llval = if offset.bytes() == 0 {\n-                self.llval\n-            } else if let Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n-                // Offsets have to match either first or second field.\n-                assert_eq!(offset, a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi));\n-                bx.struct_gep(self.llval, 1)\n-            } else {\n-                bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix))\n+            let llval = match self.layout.abi {\n+                _ if offset.bytes() == 0 => {\n+                    // Unions and newtypes only use an offset of 0.\n+                    // Also handles the first field of Scalar, ScalarPair, and Vector layouts.\n+                    self.llval\n+                }\n+                Abi::ScalarPair(ref a, ref b)\n+                    if offset == a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi) =>\n+                {\n+                    // Offset matches second field.\n+                    bx.struct_gep(self.llval, 1)\n+                }\n+                Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. } if field.is_zst() => {\n+                    // ZST fields are not included in Scalar, ScalarPair, and Vector layouts, so manually offset the pointer.\n+                    let byte_ptr = bx.pointercast(self.llval, bx.cx().type_i8p());\n+                    bx.gep(byte_ptr, &[bx.const_usize(offset.bytes())])\n+                }\n+                Abi::Scalar(_) | Abi::ScalarPair(..) => {\n+                    // All fields of Scalar and ScalarPair layouts must have been handled by this point.\n+                    // Vector layouts have additional fields for each element of the vector, so don't panic in that case.\n+                    bug!(\n+                        \"offset of non-ZST field `{:?}` does not match layout `{:#?}`\",\n+                        field,\n+                        self.layout\n+                    );\n+                }\n+                _ => bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix)),\n             };\n             PlaceRef {\n                 // HACK(eddyb): have to bitcast pointers until LLVM removes pointee types."}, {"sha": "4c61e21901bcd1064798c3dba182066d460b46cb", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,150 @@\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use rustc_span::symbol::Symbol;\n+\n+const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"aclass\", Some(sym::arm_target_feature)),\n+    (\"mclass\", Some(sym::arm_target_feature)),\n+    (\"rclass\", Some(sym::arm_target_feature)),\n+    (\"dsp\", Some(sym::arm_target_feature)),\n+    (\"neon\", Some(sym::arm_target_feature)),\n+    (\"crc\", Some(sym::arm_target_feature)),\n+    (\"crypto\", Some(sym::arm_target_feature)),\n+    (\"v5te\", Some(sym::arm_target_feature)),\n+    (\"v6\", Some(sym::arm_target_feature)),\n+    (\"v6k\", Some(sym::arm_target_feature)),\n+    (\"v6t2\", Some(sym::arm_target_feature)),\n+    (\"v7\", Some(sym::arm_target_feature)),\n+    (\"v8\", Some(sym::arm_target_feature)),\n+    (\"vfp2\", Some(sym::arm_target_feature)),\n+    (\"vfp3\", Some(sym::arm_target_feature)),\n+    (\"vfp4\", Some(sym::arm_target_feature)),\n+    // This is needed for inline assembly, but shouldn't be stabilized as-is\n+    // since it should be enabled per-function using #[instruction_set], not\n+    // #[target_feature].\n+    (\"thumb-mode\", Some(sym::arm_target_feature)),\n+];\n+\n+const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"fp\", Some(sym::aarch64_target_feature)),\n+    (\"neon\", Some(sym::aarch64_target_feature)),\n+    (\"sve\", Some(sym::aarch64_target_feature)),\n+    (\"crc\", Some(sym::aarch64_target_feature)),\n+    (\"crypto\", Some(sym::aarch64_target_feature)),\n+    (\"ras\", Some(sym::aarch64_target_feature)),\n+    (\"lse\", Some(sym::aarch64_target_feature)),\n+    (\"rdm\", Some(sym::aarch64_target_feature)),\n+    (\"fp16\", Some(sym::aarch64_target_feature)),\n+    (\"rcpc\", Some(sym::aarch64_target_feature)),\n+    (\"dotprod\", Some(sym::aarch64_target_feature)),\n+    (\"tme\", Some(sym::aarch64_target_feature)),\n+    (\"v8.1a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.2a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.3a\", Some(sym::aarch64_target_feature)),\n+];\n+\n+const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"adx\", Some(sym::adx_target_feature)),\n+    (\"aes\", None),\n+    (\"avx\", None),\n+    (\"avx2\", None),\n+    (\"avx512bw\", Some(sym::avx512_target_feature)),\n+    (\"avx512cd\", Some(sym::avx512_target_feature)),\n+    (\"avx512dq\", Some(sym::avx512_target_feature)),\n+    (\"avx512er\", Some(sym::avx512_target_feature)),\n+    (\"avx512f\", Some(sym::avx512_target_feature)),\n+    (\"avx512ifma\", Some(sym::avx512_target_feature)),\n+    (\"avx512pf\", Some(sym::avx512_target_feature)),\n+    (\"avx512vbmi\", Some(sym::avx512_target_feature)),\n+    (\"avx512vl\", Some(sym::avx512_target_feature)),\n+    (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n+    (\"bmi1\", None),\n+    (\"bmi2\", None),\n+    (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n+    (\"f16c\", Some(sym::f16c_target_feature)),\n+    (\"fma\", None),\n+    (\"fxsr\", None),\n+    (\"lzcnt\", None),\n+    (\"movbe\", Some(sym::movbe_target_feature)),\n+    (\"pclmulqdq\", None),\n+    (\"popcnt\", None),\n+    (\"rdrand\", None),\n+    (\"rdseed\", None),\n+    (\"rtm\", Some(sym::rtm_target_feature)),\n+    (\"sha\", None),\n+    (\"sse\", None),\n+    (\"sse2\", None),\n+    (\"sse3\", None),\n+    (\"sse4.1\", None),\n+    (\"sse4.2\", None),\n+    (\"sse4a\", Some(sym::sse4a_target_feature)),\n+    (\"ssse3\", None),\n+    (\"tbm\", Some(sym::tbm_target_feature)),\n+    (\"xsave\", None),\n+    (\"xsavec\", None),\n+    (\"xsaveopt\", None),\n+    (\"xsaves\", None),\n+];\n+\n+const HEXAGON_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"hvx\", Some(sym::hexagon_target_feature)),\n+    (\"hvx-length128b\", Some(sym::hexagon_target_feature)),\n+];\n+\n+const POWERPC_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-vector\", Some(sym::powerpc_target_feature)),\n+    (\"power9-vector\", Some(sym::powerpc_target_feature)),\n+    (\"vsx\", Some(sym::powerpc_target_feature)),\n+];\n+\n+const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] =\n+    &[(\"fp64\", Some(sym::mips_target_feature)), (\"msa\", Some(sym::mips_target_feature))];\n+\n+const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"m\", Some(sym::riscv_target_feature)),\n+    (\"a\", Some(sym::riscv_target_feature)),\n+    (\"c\", Some(sym::riscv_target_feature)),\n+    (\"f\", Some(sym::riscv_target_feature)),\n+    (\"d\", Some(sym::riscv_target_feature)),\n+    (\"e\", Some(sym::riscv_target_feature)),\n+];\n+\n+const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"simd128\", Some(sym::wasm_target_feature)),\n+    (\"atomics\", Some(sym::wasm_target_feature)),\n+    (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n+];\n+\n+/// When rustdoc is running, provide a list of all known features so that all their respective\n+/// primitives may be documented.\n+///\n+/// IMPORTANT: If you're adding another feature list above, make sure to add it to this iterator!\n+pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol>)> {\n+    std::iter::empty()\n+        .chain(ARM_ALLOWED_FEATURES.iter())\n+        .chain(AARCH64_ALLOWED_FEATURES.iter())\n+        .chain(X86_ALLOWED_FEATURES.iter())\n+        .chain(HEXAGON_ALLOWED_FEATURES.iter())\n+        .chain(POWERPC_ALLOWED_FEATURES.iter())\n+        .chain(MIPS_ALLOWED_FEATURES.iter())\n+        .chain(RISCV_ALLOWED_FEATURES.iter())\n+        .chain(WASM_ALLOWED_FEATURES.iter())\n+        .cloned()\n+}\n+\n+pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Option<Symbol>)] {\n+    match &*sess.target.target.arch {\n+        \"arm\" => ARM_ALLOWED_FEATURES,\n+        \"aarch64\" => AARCH64_ALLOWED_FEATURES,\n+        \"x86\" | \"x86_64\" => X86_ALLOWED_FEATURES,\n+        \"hexagon\" => HEXAGON_ALLOWED_FEATURES,\n+        \"mips\" | \"mips64\" => MIPS_ALLOWED_FEATURES,\n+        \"powerpc\" | \"powerpc64\" => POWERPC_ALLOWED_FEATURES,\n+        \"riscv32\" | \"riscv64\" => RISCV_ALLOWED_FEATURES,\n+        \"wasm32\" => WASM_ALLOWED_FEATURES,\n+        _ => &[],\n+    }\n+}"}, {"sha": "48c07b0089420559557219d5928054035bad3b4c", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -15,6 +15,7 @@ use rustc_session::{\n };\n use rustc_span::symbol::Symbol;\n use rustc_target::abi::LayoutOf;\n+use rustc_target::spec::Target;\n \n pub use rustc_data_structures::sync::MetadataRef;\n \n@@ -54,6 +55,12 @@ pub trait CodegenBackend {\n     fn print_passes(&self) {}\n     fn print_version(&self) {}\n \n+    /// If this plugin provides additional builtin targets, provide the one enabled by the options here.\n+    /// Be careful: this is called *before* init() is called.\n+    fn target_override(&self, _opts: &config::Options) -> Option<Target> {\n+        None\n+    }\n+\n     fn metadata_loader(&self) -> Box<MetadataLoaderDyn>;\n     fn provide(&self, _providers: &mut Providers);\n     fn provide_extern(&self, _providers: &mut Providers);\n@@ -102,6 +109,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         tcx: TyCtxt<'tcx>,\n         mods: &mut Self::Module,\n         kind: AllocatorKind,\n+        has_alloc_error_handler: bool,\n     );\n     /// This generates the codegen unit and returns it along with\n     /// a `u64` giving an estimate of the unit's processing cost."}, {"sha": "b35b0f24208b267b4957c362fbd0b8e44e122389", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -18,7 +18,6 @@ use rustc_middle::ty::Ty;\n use rustc_target::abi::{Abi, Align, Scalar, Size};\n use rustc_target::spec::HasTargetSpec;\n \n-use std::iter::TrustedLen;\n use std::ops::Range;\n \n #[derive(Copy, Clone)]\n@@ -60,7 +59,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n         &mut self,\n         v: Self::Value,\n         else_llbb: Self::BasicBlock,\n-        cases: impl ExactSizeIterator<Item = (u128, Self::BasicBlock)> + TrustedLen,\n+        cases: impl ExactSizeIterator<Item = (u128, Self::BasicBlock)>,\n     );\n     fn invoke(\n         &mut self,"}, {"sha": "655afcd17f0da75784e4bd5b85851e1b538182d9", "filename": "compiler/rustc_codegen_ssa/src/traits/declare.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdeclare.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,51 +1,7 @@\n use super::BackendTypes;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n-use rustc_middle::ty::{Instance, Ty};\n-use rustc_target::abi::call::FnAbi;\n-\n-pub trait DeclareMethods<'tcx>: BackendTypes {\n-    /// Declare a global value.\n-    ///\n-    /// If there\u2019s a value with the same name already declared, the function will\n-    /// return its Value instead.\n-    fn declare_global(&self, name: &str, ty: Self::Type) -> Self::Value;\n-\n-    /// Declare a C ABI function.\n-    ///\n-    /// Only use this for foreign function ABIs and glue. For Rust functions use\n-    /// `declare_fn` instead.\n-    ///\n-    /// If there\u2019s a value with the same name already declared, the function will\n-    /// update the declaration and return existing Value instead.\n-    fn declare_cfn(&self, name: &str, fn_type: Self::Type) -> Self::Function;\n-\n-    /// Declare a Rust function.\n-    ///\n-    /// If there\u2019s a value with the same name already declared, the function will\n-    /// update the declaration and return existing Value instead.\n-    fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Function;\n-\n-    /// Declare a global with an intention to define it.\n-    ///\n-    /// Use this function when you intend to define a global. This function will\n-    /// return `None` if the name already has a definition associated with it. In that\n-    /// case an error should be reported to the user, because it usually happens due\n-    /// to user\u2019s fault (e.g., misuse of `#[no_mangle]` or `#[export_name]` attributes).\n-    fn define_global(&self, name: &str, ty: Self::Type) -> Option<Self::Value>;\n-\n-    /// Declare a private global\n-    ///\n-    /// Use this function when you intend to define a global without a name.\n-    fn define_private_global(&self, ty: Self::Type) -> Self::Value;\n-\n-    /// Gets declared value by name.\n-    fn get_declared_value(&self, name: &str) -> Option<Self::Value>;\n-\n-    /// Gets defined or externally defined (AvailableExternally linkage) value by\n-    /// name.\n-    fn get_defined_value(&self, name: &str) -> Option<Self::Value>;\n-}\n+use rustc_middle::ty::Instance;\n \n pub trait PreDefineMethods<'tcx>: BackendTypes {\n     fn predefine_static("}, {"sha": "ccd294d92b2f473f8036f2a0f595ec04c2e400a3", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -5,9 +5,9 @@ use rustc_span::Span;\n use rustc_target::abi::call::FnAbi;\n \n pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n-    /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n-    /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n-    /// add them to librustc_codegen_llvm/context.rs\n+    /// Remember to add all intrinsics here, in `compiler/rustc_typeck/src/check/mod.rs`,\n+    /// and in `library/core/src/intrinsics.rs`; if you need access to any LLVM intrinsics,\n+    /// add them to `compiler/rustc_codegen_llvm/src/context.rs`.\n     fn codegen_intrinsic_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "6fff64bfcb6c5a4bdce2848d784b39e81ce866fb", "filename": "compiler/rustc_codegen_ssa/src/traits/misc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -19,4 +19,6 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n     fn set_frame_pointer_elimination(&self, llfn: Self::Function);\n     fn apply_target_cpu_attr(&self, llfn: Self::Function);\n     fn create_used_variable(&self);\n+    /// Declares the extern \"C\" main function for the entry point. Returns None if the symbol already exists.\n+    fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function>;\n }"}, {"sha": "698ef6083e674ba201b92f3079fe62cbf795e7aa", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -35,7 +35,7 @@ pub use self::builder::{BuilderMethods, OverflowOp};\n pub use self::consts::ConstMethods;\n pub use self::coverageinfo::{CoverageInfoBuilderMethods, CoverageInfoMethods};\n pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};\n-pub use self::declare::{DeclareMethods, PreDefineMethods};\n+pub use self::declare::PreDefineMethods;\n pub use self::intrinsic::IntrinsicCallMethods;\n pub use self::misc::MiscMethods;\n pub use self::statics::{StaticBuilderMethods, StaticMethods};\n@@ -60,7 +60,6 @@ pub trait CodegenMethods<'tcx>:\n     + StaticMethods\n     + CoverageInfoMethods\n     + DebugInfoMethods<'tcx>\n-    + DeclareMethods<'tcx>\n     + AsmMethods\n     + PreDefineMethods<'tcx>\n     + HasParamEnv<'tcx>\n@@ -77,7 +76,6 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + StaticMethods\n         + CoverageInfoMethods\n         + DebugInfoMethods<'tcx>\n-        + DeclareMethods<'tcx>\n         + AsmMethods\n         + PreDefineMethods<'tcx>\n         + HasParamEnv<'tcx>"}, {"sha": "264e7c2aa92c0c44551aa53a7f20166ba238016b", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -13,6 +13,12 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     type ThinData: Send + Sync;\n     type ThinBuffer: ThinBufferMethods;\n \n+    /// Merge all modules into main_module and returning it\n+    fn run_link(\n+        cgcx: &CodegenContext<Self>,\n+        diag_handler: &Handler,\n+        modules: Vec<ModuleCodegen<Self::Module>>,\n+    ) -> Result<ModuleCodegen<Self::Module>, FatalError>;\n     /// Performs fat LTO by merging all modules into a single one and returning it\n     /// for further optimization.\n     fn run_fat_lto("}, {"sha": "caaf7c0c3c2505ae927833ac7e3d14836d3553eb", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -8,6 +8,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+arrayvec = { version = \"0.5.1\", default-features = false }\n ena = \"0.14\"\n indexmap = \"1.5.1\"\n tracing = \"0.1\"\n@@ -26,11 +27,11 @@ rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n bitflags = \"1.2.1\"\n measureme = \"0.7.1\"\n libc = \"0.2\"\n-stacker = \"0.1.11\"\n+stacker = \"0.1.12\"\n tempfile = \"3.0.5\"\n \n [dependencies.parking_lot]\n-version = \"0.10\"\n+version = \"0.11\"\n features = [\"nightly\"]\n \n [target.'cfg(windows)'.dependencies]"}, {"sha": "1cfbce2355e3a7a2c567ffd454d5881a4b945297", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -9,6 +9,7 @@ use super::iterate::reverse_post_order;\n use super::ControlFlowGraph;\n use rustc_index::vec::{Idx, IndexVec};\n use std::borrow::BorrowMut;\n+use std::cmp::Ordering;\n \n #[cfg(test)]\n mod tests;\n@@ -108,6 +109,14 @@ impl<Node: Idx> Dominators<Node> {\n         // FIXME -- could be optimized by using post-order-rank\n         self.dominators(node).any(|n| n == dom)\n     }\n+\n+    /// Provide deterministic ordering of nodes such that, if any two nodes have a dominator\n+    /// relationship, the dominator will always precede the dominated. (The relative ordering\n+    /// of two unrelated nodes will also be consistent, but otherwise the order has no\n+    /// meaning.) This method cannot be used to determine if either Node dominates the other.\n+    pub fn rank_partial_cmp(&self, lhs: Node, rhs: Node) -> Option<Ordering> {\n+        self.post_order_rank[lhs].partial_cmp(&self.post_order_rank[rhs])\n+    }\n }\n \n pub struct Iter<'dom, Node: Idx> {"}, {"sha": "bc3d1ce53bac5d2ebaf840513f36cf142e836c41", "filename": "compiler/rustc_data_structures/src/graph/iterate/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -87,11 +87,8 @@ where\n }\n \n /// Allows searches to terminate early with a value.\n-#[derive(Clone, Copy, Debug)]\n-pub enum ControlFlow<T> {\n-    Break(T),\n-    Continue,\n-}\n+// FIXME (#75744): remove the alias once the generics are in a better order and `C=()`.\n+pub type ControlFlow<T> = std::ops::ControlFlow<(), T>;\n \n /// The status of a node in the depth-first search.\n ///\n@@ -260,12 +257,12 @@ where\n         _node: G::Node,\n         _prior_status: Option<NodeStatus>,\n     ) -> ControlFlow<Self::BreakVal> {\n-        ControlFlow::Continue\n+        ControlFlow::CONTINUE\n     }\n \n     /// Called after all nodes reachable from this one have been examined.\n     fn node_settled(&mut self, _node: G::Node) -> ControlFlow<Self::BreakVal> {\n-        ControlFlow::Continue\n+        ControlFlow::CONTINUE\n     }\n \n     /// Behave as if no edges exist from `source` to `target`.\n@@ -289,8 +286,8 @@ where\n         prior_status: Option<NodeStatus>,\n     ) -> ControlFlow<Self::BreakVal> {\n         match prior_status {\n-            Some(NodeStatus::Visited) => ControlFlow::Break(()),\n-            _ => ControlFlow::Continue,\n+            Some(NodeStatus::Visited) => ControlFlow::BREAK,\n+            _ => ControlFlow::CONTINUE,\n         }\n     }\n }"}, {"sha": "9958e5dd5e0ee5f67d828e970924f2301554928a", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -6,13 +6,14 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![allow(incomplete_features)]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(array_windows)]\n+#![feature(control_flow_enum)]\n #![feature(in_band_lifetimes)]\n #![feature(unboxed_closures)]\n-#![feature(generators)]\n #![feature(generator_trait)]\n #![feature(fn_traits)]\n+#![feature(int_bits_const)]\n #![feature(min_specialization)]\n #![feature(optin_builtin_traits)]\n #![feature(nll)]\n@@ -25,7 +26,7 @@\n #![feature(thread_id_value)]\n #![feature(extend_one)]\n #![feature(const_panic)]\n-#![feature(const_generics)]\n+#![feature(min_const_generics)]\n #![feature(once_cell)]\n #![allow(rustc::default_hash_types)]\n \n@@ -86,25 +87,27 @@ pub mod sorted_map;\n pub mod stable_set;\n #[macro_use]\n pub mod stable_hasher;\n+mod atomic_ref;\n+pub mod fingerprint;\n+pub mod profiling;\n pub mod sharded;\n pub mod stack;\n pub mod sync;\n pub mod thin_vec;\n pub mod tiny_list;\n pub mod transitive_relation;\n-pub use ena::undo_log;\n-pub use ena::unify;\n-mod atomic_ref;\n-pub mod fingerprint;\n-pub mod profiling;\n pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n+pub mod sso;\n pub mod tagged_ptr;\n pub mod temp_dir;\n pub mod unhash;\n \n+pub use ena::undo_log;\n+pub use ena::unify;\n+\n pub struct OnDrop<F: Fn()>(pub F);\n \n impl<F: Fn()> OnDrop<F> {"}, {"sha": "b918ed9458cdae1d0bd405e7a9fea783e0844aa2", "filename": "compiler/rustc_data_structures/src/macros.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,15 +1,3 @@\n-/// A simple static assertion macro.\n-#[macro_export]\n-#[allow_internal_unstable(type_ascription)]\n-macro_rules! static_assert {\n-    ($test:expr) => {\n-        // Use the bool to access an array such that if the bool is false, the access\n-        // is out-of-bounds.\n-        #[allow(dead_code)]\n-        const _: () = [()][!($test: bool) as usize];\n-    };\n-}\n-\n /// Type size assertion. The first argument is a type and the second argument is its expected size.\n #[macro_export]\n macro_rules! static_assert_size {"}, {"sha": "363879cbb1d197329ba35419a3917f398b3d6b32", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -600,10 +600,7 @@ pub fn print_time_passes_entry(do_it: bool, what: &str, dur: Duration) {\n // Hack up our own formatting for the duration to make it easier for scripts\n // to parse (always use the same number of decimal places and the same unit).\n pub fn duration_to_secs_str(dur: std::time::Duration) -> String {\n-    const NANOS_PER_SEC: f64 = 1_000_000_000.0;\n-    let secs = dur.as_secs() as f64 + dur.subsec_nanos() as f64 / NANOS_PER_SEC;\n-\n-    format!(\"{:.3}\", secs)\n+    format!(\"{:.3}\", dur.as_secs_f64())\n }\n \n // Memory reporting"}, {"sha": "2c4eff618c6854c838ff0ae2a30a8dc9d3d25206", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -125,15 +125,28 @@ impl SipHasher128 {\n \n     // A specialized write function for values with size <= 8.\n     //\n-    // The hashing of multi-byte integers depends on endianness. E.g.:\n+    // The input must be zero-extended to 64-bits by the caller. This extension\n+    // isn't hashed, but the implementation requires it for correctness.\n+    //\n+    // This function, given the same integer size and value, has the same effect\n+    // on both little- and big-endian hardware. It operates on values without\n+    // depending on their sequence in memory, so is independent of endianness.\n+    //\n+    // However, we want SipHasher128 to be platform-dependent, in order to be\n+    // consistent with the platform-dependent SipHasher in libstd. In other\n+    // words, we want:\n+    //\n     // - little-endian: `write_u32(0xDDCCBBAA)` == `write([0xAA, 0xBB, 0xCC, 0xDD])`\n     // - big-endian:    `write_u32(0xDDCCBBAA)` == `write([0xDD, 0xCC, 0xBB, 0xAA])`\n     //\n-    // This function does the right thing for little-endian hardware. On\n-    // big-endian hardware `x` must be byte-swapped first to give the right\n-    // behaviour. After any byte-swapping, the input must be zero-extended to\n-    // 64-bits. The caller is responsible for the byte-swapping and\n-    // zero-extension.\n+    // Therefore, in order to produce endian-dependent results, SipHasher128's\n+    // `write_xxx` Hasher trait methods byte-swap `x` prior to zero-extending.\n+    //\n+    // If clients of SipHasher128 itself want platform-independent results, they\n+    // *also* must byte-swap integer inputs before invoking the `write_xxx`\n+    // methods on big-endian hardware (that is, two byte-swaps must occur--one\n+    // in the client, and one in SipHasher128). Additionally, they must extend\n+    // `usize` and `isize` types to 64 bits on 32-bit systems.\n     #[inline]\n     fn short_write<T>(&mut self, _x: T, x: u64) {\n         let size = mem::size_of::<T>();"}, {"sha": "2e2274a7b775e94df3ddbc81fd320cf6a2eddf3c", "filename": "compiler/rustc_data_structures/src/sip128/tests.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,7 +1,6 @@\n use super::*;\n \n use std::hash::{Hash, Hasher};\n-use std::{mem, slice};\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n@@ -399,20 +398,55 @@ fn test_hash_no_concat_alias() {\n }\n \n #[test]\n-fn test_write_short_works() {\n-    let test_usize = 0xd0c0b0a0usize;\n+fn test_short_write_works() {\n+    let test_u8 = 0xFF_u8;\n+    let test_u16 = 0x1122_u16;\n+    let test_u32 = 0x22334455_u32;\n+    let test_u64 = 0x33445566_778899AA_u64;\n+    let test_u128 = 0x11223344_55667788_99AABBCC_DDEEFF77_u128;\n+    let test_usize = 0xD0C0B0A0_usize;\n+\n+    let test_i8 = -1_i8;\n+    let test_i16 = -2_i16;\n+    let test_i32 = -3_i32;\n+    let test_i64 = -4_i64;\n+    let test_i128 = -5_i128;\n+    let test_isize = -6_isize;\n+\n     let mut h1 = SipHasher128::new_with_keys(0, 0);\n-    h1.write_usize(test_usize);\n     h1.write(b\"bytes\");\n     h1.write(b\"string\");\n-    h1.write_u8(0xFFu8);\n-    h1.write_u8(0x01u8);\n+    h1.write_u8(test_u8);\n+    h1.write_u16(test_u16);\n+    h1.write_u32(test_u32);\n+    h1.write_u64(test_u64);\n+    h1.write_u128(test_u128);\n+    h1.write_usize(test_usize);\n+    h1.write_i8(test_i8);\n+    h1.write_i16(test_i16);\n+    h1.write_i32(test_i32);\n+    h1.write_i64(test_i64);\n+    h1.write_i128(test_i128);\n+    h1.write_isize(test_isize);\n+\n     let mut h2 = SipHasher128::new_with_keys(0, 0);\n-    h2.write(unsafe {\n-        slice::from_raw_parts(&test_usize as *const _ as *const u8, mem::size_of::<usize>())\n-    });\n     h2.write(b\"bytes\");\n     h2.write(b\"string\");\n-    h2.write(&[0xFFu8, 0x01u8]);\n-    assert_eq!(h1.finish128(), h2.finish128());\n+    h2.write(&test_u8.to_ne_bytes());\n+    h2.write(&test_u16.to_ne_bytes());\n+    h2.write(&test_u32.to_ne_bytes());\n+    h2.write(&test_u64.to_ne_bytes());\n+    h2.write(&test_u128.to_ne_bytes());\n+    h2.write(&test_usize.to_ne_bytes());\n+    h2.write(&test_i8.to_ne_bytes());\n+    h2.write(&test_i16.to_ne_bytes());\n+    h2.write(&test_i32.to_ne_bytes());\n+    h2.write(&test_i64.to_ne_bytes());\n+    h2.write(&test_i128.to_ne_bytes());\n+    h2.write(&test_isize.to_ne_bytes());\n+\n+    let h1_hash = h1.finish128();\n+    let h2_hash = h2.finish128();\n+\n+    assert_eq!(h1_hash, h2_hash);\n }"}, {"sha": "4807380595db7267446061203cf4f7c26dbaee6e", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -34,7 +34,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n     /// and that there are no duplicates.\n     #[inline]\n     pub fn from_presorted_elements(elements: Vec<(K, V)>) -> SortedMap<K, V> {\n-        debug_assert!(elements.windows(2).all(|w| w[0].0 < w[1].0));\n+        debug_assert!(elements.array_windows().all(|[fst, snd]| fst.0 < snd.0));\n \n         SortedMap { data: elements }\n     }\n@@ -159,7 +159,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n             return;\n         }\n \n-        debug_assert!(elements.windows(2).all(|w| w[0].0 < w[1].0));\n+        debug_assert!(elements.array_windows().all(|[fst, snd]| fst.0 < snd.0));\n \n         let start_index = self.lookup_index_for(&elements[0].0);\n "}, {"sha": "af8ffcf4c13a58ba2f9b7ff70fe69d00bec0ea61", "filename": "compiler/rustc_data_structures/src/sso/either_iter.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,75 @@\n+use std::fmt;\n+use std::iter::ExactSizeIterator;\n+use std::iter::FusedIterator;\n+use std::iter::Iterator;\n+\n+/// Iterator which may contain instance of\n+/// one of two specific implementations.\n+///\n+/// Note: For most methods providing custom\n+///       implementation may margianlly\n+///       improve performance by avoiding\n+///       doing Left/Right match on every step\n+///       and doing it only once instead.\n+#[derive(Clone)]\n+pub enum EitherIter<L, R> {\n+    Left(L),\n+    Right(R),\n+}\n+\n+impl<L, R> Iterator for EitherIter<L, R>\n+where\n+    L: Iterator,\n+    R: Iterator<Item = L::Item>,\n+{\n+    type Item = L::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self {\n+            EitherIter::Left(l) => l.next(),\n+            EitherIter::Right(r) => r.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match self {\n+            EitherIter::Left(l) => l.size_hint(),\n+            EitherIter::Right(r) => r.size_hint(),\n+        }\n+    }\n+}\n+\n+impl<L, R> ExactSizeIterator for EitherIter<L, R>\n+where\n+    L: ExactSizeIterator,\n+    R: ExactSizeIterator,\n+    EitherIter<L, R>: Iterator,\n+{\n+    fn len(&self) -> usize {\n+        match self {\n+            EitherIter::Left(l) => l.len(),\n+            EitherIter::Right(r) => r.len(),\n+        }\n+    }\n+}\n+\n+impl<L, R> FusedIterator for EitherIter<L, R>\n+where\n+    L: FusedIterator,\n+    R: FusedIterator,\n+    EitherIter<L, R>: Iterator,\n+{\n+}\n+\n+impl<L, R> fmt::Debug for EitherIter<L, R>\n+where\n+    L: fmt::Debug,\n+    R: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            EitherIter::Left(l) => l.fmt(f),\n+            EitherIter::Right(r) => r.fmt(f),\n+        }\n+    }\n+}"}, {"sha": "fa510e58314af06fcdf9c78754f0c78cfc26852d", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,560 @@\n+use super::either_iter::EitherIter;\n+use crate::fx::FxHashMap;\n+use arrayvec::ArrayVec;\n+use std::fmt;\n+use std::hash::Hash;\n+use std::iter::FromIterator;\n+use std::ops::Index;\n+\n+// For pointer-sized arguments arrays\n+// are faster than set/map for up to 64\n+// arguments.\n+//\n+// On the other hand such a big array\n+// hurts cache performance, makes passing\n+// sso structures around very expensive.\n+//\n+// Biggest performance benefit is gained\n+// for reasonably small arrays that stay\n+// small in vast majority of cases.\n+//\n+// '8' is choosen as a sane default, to be\n+// reevaluated later.\n+//\n+// Note: As of now ArrayVec design prevents\n+//       us from making it user-customizable.\n+const SSO_ARRAY_SIZE: usize = 8;\n+\n+/// Small-storage-optimized implementation of a map.\n+///\n+/// Stores elements in a small array up to a certain length\n+/// and switches to `HashMap` when that length is exceeded.\n+//\n+// FIXME: Implements subset of HashMap API.\n+//\n+// Missing HashMap API:\n+//   all hasher-related\n+//   try_reserve (unstable)\n+//   shrink_to (unstable)\n+//   drain_filter (unstable)\n+//   into_keys/into_values (unstable)\n+//   all raw_entry-related\n+//   PartialEq/Eq (requires sorting the array)\n+//   Entry::or_insert_with_key (unstable)\n+//   Vacant/Occupied entries and related\n+//\n+// FIXME: In HashMap most methods accepting key reference\n+// accept reference to generic `Q` where `K: Borrow<Q>`.\n+//\n+// However, using this approach in `HashMap::get` apparently\n+// breaks inlining and noticeably reduces performance.\n+//\n+// Performance *should* be the same given that borrow is\n+// a NOP in most cases, but in practice that's not the case.\n+//\n+// Further investigation is required.\n+//\n+// Affected methods:\n+//   SsoHashMap::get\n+//   SsoHashMap::get_mut\n+//   SsoHashMap::get_entry\n+//   SsoHashMap::get_key_value\n+//   SsoHashMap::contains_key\n+//   SsoHashMap::remove\n+//   SsoHashMap::remove_entry\n+//   Index::index\n+//   SsoHashSet::take\n+//   SsoHashSet::get\n+//   SsoHashSet::remove\n+//   SsoHashSet::contains\n+\n+#[derive(Clone)]\n+pub enum SsoHashMap<K, V> {\n+    Array(ArrayVec<[(K, V); SSO_ARRAY_SIZE]>),\n+    Map(FxHashMap<K, V>),\n+}\n+\n+impl<K, V> SsoHashMap<K, V> {\n+    /// Creates an empty `SsoHashMap`.\n+    #[inline]\n+    pub fn new() -> Self {\n+        SsoHashMap::Array(ArrayVec::new())\n+    }\n+\n+    /// Creates an empty `SsoHashMap` with the specified capacity.\n+    pub fn with_capacity(cap: usize) -> Self {\n+        if cap <= SSO_ARRAY_SIZE {\n+            Self::new()\n+        } else {\n+            SsoHashMap::Map(FxHashMap::with_capacity_and_hasher(cap, Default::default()))\n+        }\n+    }\n+\n+    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n+    /// for reuse.\n+    pub fn clear(&mut self) {\n+        match self {\n+            SsoHashMap::Array(array) => array.clear(),\n+            SsoHashMap::Map(map) => map.clear(),\n+        }\n+    }\n+\n+    /// Returns the number of elements the map can hold without reallocating.\n+    pub fn capacity(&self) -> usize {\n+        match self {\n+            SsoHashMap::Array(_) => SSO_ARRAY_SIZE,\n+            SsoHashMap::Map(map) => map.capacity(),\n+        }\n+    }\n+\n+    /// Returns the number of elements in the map.\n+    pub fn len(&self) -> usize {\n+        match self {\n+            SsoHashMap::Array(array) => array.len(),\n+            SsoHashMap::Map(map) => map.len(),\n+        }\n+    }\n+\n+    /// Returns `true` if the map contains no elements.\n+    pub fn is_empty(&self) -> bool {\n+        match self {\n+            SsoHashMap::Array(array) => array.is_empty(),\n+            SsoHashMap::Map(map) => map.is_empty(),\n+        }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order.\n+    /// The iterator element type is `(&'a K, &'a V)`.\n+    #[inline]\n+    pub fn iter(&self) -> <&Self as IntoIterator>::IntoIter {\n+        self.into_iter()\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order,\n+    /// with mutable references to the values.\n+    /// The iterator element type is `(&'a K, &'a mut V)`.\n+    #[inline]\n+    pub fn iter_mut(&mut self) -> impl Iterator<Item = (&'_ K, &'_ mut V)> {\n+        self.into_iter()\n+    }\n+\n+    /// An iterator visiting all keys in arbitrary order.\n+    /// The iterator element type is `&'a K`.\n+    pub fn keys(&self) -> impl Iterator<Item = &'_ K> {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(k, _v)| k)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.keys()),\n+        }\n+    }\n+\n+    /// An iterator visiting all values in arbitrary order.\n+    /// The iterator element type is `&'a V`.\n+    pub fn values(&self) -> impl Iterator<Item = &'_ V> {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.values()),\n+        }\n+    }\n+\n+    /// An iterator visiting all values mutably in arbitrary order.\n+    /// The iterator element type is `&'a mut V`.\n+    pub fn values_mut(&mut self) -> impl Iterator<Item = &'_ mut V> {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.iter_mut().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.values_mut()),\n+        }\n+    }\n+\n+    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n+    /// allocated memory for reuse.\n+    pub fn drain(&mut self) -> impl Iterator<Item = (K, V)> + '_ {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.drain(..)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.drain()),\n+        }\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n+    /// Changes underlying storage from array to hashmap\n+    /// if array is full.\n+    fn migrate_if_full(&mut self) {\n+        if let SsoHashMap::Array(array) = self {\n+            if array.is_full() {\n+                *self = SsoHashMap::Map(array.drain(..).collect());\n+            }\n+        }\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the `SsoHashMap`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    pub fn reserve(&mut self, additional: usize) {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if SSO_ARRAY_SIZE < (array.len() + additional) {\n+                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n+                    map.reserve(additional);\n+                    *self = SsoHashMap::Map(map);\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.reserve(additional),\n+        }\n+    }\n+\n+    /// Shrinks the capacity of the map as much as possible. It will drop\n+    /// down as much as possible while maintaining the internal rules\n+    /// and possibly leaving some space in accordance with the resize policy.\n+    pub fn shrink_to_fit(&mut self) {\n+        if let SsoHashMap::Map(map) = self {\n+            if map.len() <= SSO_ARRAY_SIZE {\n+                *self = SsoHashMap::Array(map.drain().collect());\n+            } else {\n+                map.shrink_to_fit();\n+            }\n+        }\n+    }\n+\n+    /// Retains only the elements specified by the predicate.\n+    pub fn retain<F>(&mut self, mut f: F)\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        match self {\n+            SsoHashMap::Array(array) => array.retain(|(k, v)| f(k, v)),\n+            SsoHashMap::Map(map) => map.retain(f),\n+        }\n+    }\n+\n+    /// Inserts a key-value pair into the map.\n+    ///\n+    /// If the map did not have this key present, [`None`] is returned.\n+    ///\n+    /// If the map did have this key present, the value is updated, and the old\n+    /// value is returned. The key is not updated, though; this matters for\n+    /// types that can be `==` without being identical. See the [module-level\n+    /// documentation] for more.\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array.iter_mut() {\n+                    if *k == key {\n+                        let old_value = std::mem::replace(v, value);\n+                        return Some(old_value);\n+                    }\n+                }\n+                if let Err(error) = array.try_push((key, value)) {\n+                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n+                    let (key, value) = error.element();\n+                    map.insert(key, value);\n+                    *self = SsoHashMap::Map(map);\n+                }\n+                None\n+            }\n+            SsoHashMap::Map(map) => map.insert(key, value),\n+        }\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    pub fn remove(&mut self, key: &K) -> Option<V> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if let Some(index) = array.iter().position(|(k, _v)| k == key) {\n+                    Some(array.swap_remove(index).1)\n+                } else {\n+                    None\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.remove(key),\n+        }\n+    }\n+\n+    /// Removes a key from the map, returning the stored key and value if the\n+    /// key was previously in the map.\n+    pub fn remove_entry(&mut self, key: &K) -> Option<(K, V)> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if let Some(index) = array.iter().position(|(k, _v)| k == key) {\n+                    Some(array.swap_remove(index))\n+                } else {\n+                    None\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.remove_entry(key),\n+        }\n+    }\n+\n+    /// Returns a reference to the value corresponding to the key.\n+    pub fn get(&self, key: &K) -> Option<&V> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array {\n+                    if k == key {\n+                        return Some(v);\n+                    }\n+                }\n+                None\n+            }\n+            SsoHashMap::Map(map) => map.get(key),\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the value corresponding to the key.\n+    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array {\n+                    if k == key {\n+                        return Some(v);\n+                    }\n+                }\n+                None\n+            }\n+            SsoHashMap::Map(map) => map.get_mut(key),\n+        }\n+    }\n+\n+    /// Returns the key-value pair corresponding to the supplied key.\n+    pub fn get_key_value(&self, key: &K) -> Option<(&K, &V)> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array {\n+                    if k == key {\n+                        return Some((k, v));\n+                    }\n+                }\n+                None\n+            }\n+            SsoHashMap::Map(map) => map.get_key_value(key),\n+        }\n+    }\n+\n+    /// Returns `true` if the map contains a value for the specified key.\n+    pub fn contains_key(&self, key: &K) -> bool {\n+        match self {\n+            SsoHashMap::Array(array) => array.iter().any(|(k, _v)| k == key),\n+            SsoHashMap::Map(map) => map.contains_key(key),\n+        }\n+    }\n+\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    #[inline]\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n+        Entry { ssomap: self, key }\n+    }\n+}\n+\n+impl<K, V> Default for SsoHashMap<K, V> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> FromIterator<(K, V)> for SsoHashMap<K, V> {\n+    fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> SsoHashMap<K, V> {\n+        let mut map: SsoHashMap<K, V> = Default::default();\n+        map.extend(iter);\n+        map\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> Extend<(K, V)> for SsoHashMap<K, V> {\n+    fn extend<I>(&mut self, iter: I)\n+    where\n+        I: IntoIterator<Item = (K, V)>,\n+    {\n+        for (key, value) in iter.into_iter() {\n+            self.insert(key, value);\n+        }\n+    }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (k, v): (K, V)) {\n+        self.insert(k, v);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if SSO_ARRAY_SIZE < (array.len() + additional) {\n+                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n+                    map.extend_reserve(additional);\n+                    *self = SsoHashMap::Map(map);\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.extend_reserve(additional),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> Extend<(&'a K, &'a V)> for SsoHashMap<K, V>\n+where\n+    K: Eq + Hash + Copy,\n+    V: Copy,\n+{\n+    fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n+        self.extend(iter.into_iter().map(|(k, v)| (k.clone(), v.clone())))\n+    }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n+        self.insert(k, v);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<(K, V)>::extend_reserve(self, additional)\n+    }\n+}\n+\n+impl<K, V> IntoIterator for SsoHashMap<K, V> {\n+    type IntoIter = EitherIter<\n+        <ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+        <FxHashMap<K, V> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter()),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+        }\n+    }\n+}\n+\n+/// adapts Item of array reference iterator to Item of hashmap reference iterator.\n+#[inline(always)]\n+fn adapt_array_ref_it<K, V>(pair: &'a (K, V)) -> (&'a K, &'a V) {\n+    let (a, b) = pair;\n+    (a, b)\n+}\n+\n+/// adapts Item of array mut reference iterator to Item of hashmap mut reference iterator.\n+#[inline(always)]\n+fn adapt_array_mut_it<K, V>(pair: &'a mut (K, V)) -> (&'a K, &'a mut V) {\n+    let (a, b) = pair;\n+    (a, b)\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n+    type IntoIter = EitherIter<\n+        std::iter::Map<\n+            <&'a ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+            fn(&'a (K, V)) -> (&'a K, &'a V),\n+        >,\n+        <&'a FxHashMap<K, V> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_ref_it)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a mut SsoHashMap<K, V> {\n+    type IntoIter = EitherIter<\n+        std::iter::Map<\n+            <&'a mut ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+            fn(&'a mut (K, V)) -> (&'a K, &'a mut V),\n+        >,\n+        <&'a mut FxHashMap<K, V> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_mut_it)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+        }\n+    }\n+}\n+\n+impl<K, V> fmt::Debug for SsoHashMap<K, V>\n+where\n+    K: fmt::Debug,\n+    V: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_map().entries(self.iter()).finish()\n+    }\n+}\n+\n+impl<'a, K, V> Index<&'a K> for SsoHashMap<K, V>\n+where\n+    K: Eq + Hash,\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, key: &K) -> &V {\n+        self.get(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n+/// A view into a single entry in a map.\n+pub struct Entry<'a, K, V> {\n+    ssomap: &'a mut SsoHashMap<K, V>,\n+    key: K,\n+}\n+\n+impl<'a, K: Eq + Hash, V> Entry<'a, K, V> {\n+    /// Provides in-place mutable access to an occupied entry before any\n+    /// potential inserts into the map.\n+    pub fn and_modify<F>(self, f: F) -> Self\n+    where\n+        F: FnOnce(&mut V),\n+    {\n+        if let Some(value) = self.ssomap.get_mut(&self.key) {\n+            f(value);\n+        }\n+        self\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    #[inline]\n+    pub fn or_insert(self, value: V) -> &'a mut V {\n+        self.or_insert_with(|| value)\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n+        self.ssomap.migrate_if_full();\n+        match self.ssomap {\n+            SsoHashMap::Array(array) => {\n+                let key_ref = &self.key;\n+                let found_index = array.iter().position(|(k, _v)| k == key_ref);\n+                let index = if let Some(index) = found_index {\n+                    index\n+                } else {\n+                    let index = array.len();\n+                    array.try_push((self.key, default())).unwrap();\n+                    index\n+                };\n+                &mut array[index].1\n+            }\n+            SsoHashMap::Map(map) => map.entry(self.key).or_insert_with(default),\n+        }\n+    }\n+\n+    /// Returns a reference to this entry's key.\n+    #[inline]\n+    pub fn key(&self) -> &K {\n+        &self.key\n+    }\n+}\n+\n+impl<'a, K: Eq + Hash, V: Default> Entry<'a, K, V> {\n+    /// Ensures a value is in the entry by inserting the default value if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    #[inline]\n+    pub fn or_default(self) -> &'a mut V {\n+        self.or_insert_with(Default::default)\n+    }\n+}"}, {"sha": "dd21bc8e6963680253ac03c0e59bdd5ce59ce2a7", "filename": "compiler/rustc_data_structures/src/sso/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,6 @@\n+mod either_iter;\n+mod map;\n+mod set;\n+\n+pub use map::SsoHashMap;\n+pub use set::SsoHashSet;"}, {"sha": "23cff0206c530367de30922de990535788f63721", "filename": "compiler/rustc_data_structures/src/sso/set.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,237 @@\n+use std::fmt;\n+use std::hash::Hash;\n+use std::iter::FromIterator;\n+\n+use super::map::SsoHashMap;\n+\n+/// Small-storage-optimized implementation of a set.\n+///\n+/// Stores elements in a small array up to a certain length\n+/// and switches to `HashSet` when that length is exceeded.\n+//\n+// FIXME: Implements subset of HashSet API.\n+//\n+// Missing HashSet API:\n+//   all hasher-related\n+//   try_reserve (unstable)\n+//   shrink_to (unstable)\n+//   drain_filter (unstable)\n+//   replace\n+//   get_or_insert/get_or_insert_owned/get_or_insert_with (unstable)\n+//   difference/symmetric_difference/intersection/union\n+//   is_disjoint/is_subset/is_superset\n+//   PartialEq/Eq (requires SsoHashMap implementation)\n+//   BitOr/BitAnd/BitXor/Sub\n+#[derive(Clone)]\n+pub struct SsoHashSet<T> {\n+    map: SsoHashMap<T, ()>,\n+}\n+\n+/// Adapter function used ot return\n+/// result if SsoHashMap functions into\n+/// result SsoHashSet should return.\n+#[inline(always)]\n+fn entry_to_key<K, V>((k, _v): (K, V)) -> K {\n+    k\n+}\n+\n+impl<T> SsoHashSet<T> {\n+    /// Creates an empty `SsoHashSet`.\n+    #[inline]\n+    pub fn new() -> Self {\n+        Self { map: SsoHashMap::new() }\n+    }\n+\n+    /// Creates an empty `SsoHashSet` with the specified capacity.\n+    #[inline]\n+    pub fn with_capacity(cap: usize) -> Self {\n+        Self { map: SsoHashMap::with_capacity(cap) }\n+    }\n+\n+    /// Clears the set, removing all values.\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.map.clear()\n+    }\n+\n+    /// Returns the number of elements the set can hold without reallocating.\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.map.capacity()\n+    }\n+\n+    /// Returns the number of elements in the set.\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.map.len()\n+    }\n+\n+    /// Returns `true` if the set contains no elements.\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.map.is_empty()\n+    }\n+\n+    /// An iterator visiting all elements in arbitrary order.\n+    /// The iterator element type is `&'a T`.\n+    #[inline]\n+    pub fn iter(&'a self) -> impl Iterator<Item = &'a T> {\n+        self.into_iter()\n+    }\n+\n+    /// Clears the set, returning all elements in an iterator.\n+    #[inline]\n+    pub fn drain(&mut self) -> impl Iterator<Item = T> + '_ {\n+        self.map.drain().map(entry_to_key)\n+    }\n+}\n+\n+impl<T: Eq + Hash> SsoHashSet<T> {\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the `SsoHashSet`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    #[inline]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.map.reserve(additional)\n+    }\n+\n+    /// Shrinks the capacity of the set as much as possible. It will drop\n+    /// down as much as possible while maintaining the internal rules\n+    /// and possibly leaving some space in accordance with the resize policy.\n+    #[inline]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.map.shrink_to_fit()\n+    }\n+\n+    /// Retains only the elements specified by the predicate.\n+    #[inline]\n+    pub fn retain<F>(&mut self, mut f: F)\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        self.map.retain(|k, _v| f(k))\n+    }\n+\n+    /// Removes and returns the value in the set, if any, that is equal to the given one.\n+    #[inline]\n+    pub fn take(&mut self, value: &T) -> Option<T> {\n+        self.map.remove_entry(value).map(entry_to_key)\n+    }\n+\n+    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n+    #[inline]\n+    pub fn get(&self, value: &T) -> Option<&T> {\n+        self.map.get_key_value(value).map(entry_to_key)\n+    }\n+\n+    /// Adds a value to the set.\n+    ///\n+    /// If the set did not have this value present, `true` is returned.\n+    ///\n+    /// If the set did have this value present, `false` is returned.\n+    #[inline]\n+    pub fn insert(&mut self, elem: T) -> bool {\n+        self.map.insert(elem, ()).is_none()\n+    }\n+\n+    /// Removes a value from the set. Returns whether the value was\n+    /// present in the set.\n+    #[inline]\n+    pub fn remove(&mut self, value: &T) -> bool {\n+        self.map.remove(value).is_some()\n+    }\n+\n+    /// Returns `true` if the set contains a value.\n+    #[inline]\n+    pub fn contains(&self, value: &T) -> bool {\n+        self.map.contains_key(value)\n+    }\n+}\n+\n+impl<T: Eq + Hash> FromIterator<T> for SsoHashSet<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> SsoHashSet<T> {\n+        let mut set: SsoHashSet<T> = Default::default();\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+impl<T> Default for SsoHashSet<T> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<T: Eq + Hash> Extend<T> for SsoHashSet<T> {\n+    fn extend<I>(&mut self, iter: I)\n+    where\n+        I: IntoIterator<Item = T>,\n+    {\n+        for val in iter.into_iter() {\n+            self.insert(val);\n+        }\n+    }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.insert(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.map.extend_reserve(additional)\n+    }\n+}\n+\n+impl<'a, T> Extend<&'a T> for SsoHashSet<T>\n+where\n+    T: 'a + Eq + Hash + Copy,\n+{\n+    #[inline]\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n+        self.extend(iter.into_iter().cloned());\n+    }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.insert(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<T>::extend_reserve(self, additional)\n+    }\n+}\n+\n+impl<T> IntoIterator for SsoHashSet<T> {\n+    type IntoIter = std::iter::Map<<SsoHashMap<T, ()> as IntoIterator>::IntoIter, fn((T, ())) -> T>;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.map.into_iter().map(entry_to_key)\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a SsoHashSet<T> {\n+    type IntoIter = std::iter::Map<\n+        <&'a SsoHashMap<T, ()> as IntoIterator>::IntoIter,\n+        fn((&'a T, &'a ())) -> &'a T,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.map.iter().map(entry_to_key)\n+    }\n+}\n+\n+impl<T> fmt::Debug for SsoHashSet<T>\n+where\n+    T: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_set().entries(self.iter()).finish()\n+    }\n+}"}, {"sha": "68875b3fbde9b39d265bd2cb3c2cc2e976feba0a", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -5,6 +5,9 @@ use smallvec::SmallVec;\n use std::hash::{BuildHasher, Hash, Hasher};\n use std::mem;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// When hashing something that ends up affecting properties like symbol names,\n /// we want these symbol names to be calculated independently of other factors\n /// like what architecture you're compiling *from*.\n@@ -129,7 +132,8 @@ impl Hasher for StableHasher {\n     fn write_isize(&mut self, i: isize) {\n         // Always treat isize as i64 so we get the same results on 32 and 64 bit\n         // platforms. This is important for symbol hashes when cross compiling,\n-        // for example.\n+        // for example. Sign extending here is preferable as it means that the\n+        // same negative number hashes the same on both 32 and 64 bit platforms.\n         self.state.write_i64((i as i64).to_le());\n     }\n }"}, {"sha": "cd6ff96a555f4785a4b47f53f4dff2fc20fd414c", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,73 @@\n+use super::*;\n+\n+// The tests below compare the computed hashes to particular expected values\n+// in order to test that we produce the same results on different platforms,\n+// regardless of endianness and `usize` and `isize` size differences (this\n+// of course assumes we run these tests on platforms that differ in those\n+// ways). The expected values depend on the hashing algorithm used, so they\n+// need to be updated whenever StableHasher changes its hashing algorithm.\n+\n+#[test]\n+fn test_hash_integers() {\n+    // Test that integers are handled consistently across platforms.\n+    let test_u8 = 0xAB_u8;\n+    let test_u16 = 0xFFEE_u16;\n+    let test_u32 = 0x445577AA_u32;\n+    let test_u64 = 0x01234567_13243546_u64;\n+    let test_u128 = 0x22114433_66557788_99AACCBB_EEDDFF77_u128;\n+    let test_usize = 0xD0C0B0A0_usize;\n+\n+    let test_i8 = -100_i8;\n+    let test_i16 = -200_i16;\n+    let test_i32 = -300_i32;\n+    let test_i64 = -400_i64;\n+    let test_i128 = -500_i128;\n+    let test_isize = -600_isize;\n+\n+    let mut h = StableHasher::new();\n+    test_u8.hash(&mut h);\n+    test_u16.hash(&mut h);\n+    test_u32.hash(&mut h);\n+    test_u64.hash(&mut h);\n+    test_u128.hash(&mut h);\n+    test_usize.hash(&mut h);\n+    test_i8.hash(&mut h);\n+    test_i16.hash(&mut h);\n+    test_i32.hash(&mut h);\n+    test_i64.hash(&mut h);\n+    test_i128.hash(&mut h);\n+    test_isize.hash(&mut h);\n+\n+    // This depends on the hashing algorithm. See note at top of file.\n+    let expected = (2736651863462566372, 8121090595289675650);\n+\n+    assert_eq!(h.finalize(), expected);\n+}\n+\n+#[test]\n+fn test_hash_usize() {\n+    // Test that usize specifically is handled consistently across platforms.\n+    let test_usize = 0xABCDEF01_usize;\n+\n+    let mut h = StableHasher::new();\n+    test_usize.hash(&mut h);\n+\n+    // This depends on the hashing algorithm. See note at top of file.\n+    let expected = (5798740672699530587, 11186240177685111648);\n+\n+    assert_eq!(h.finalize(), expected);\n+}\n+\n+#[test]\n+fn test_hash_isize() {\n+    // Test that isize specifically is handled consistently across platforms.\n+    let test_isize = -7_isize;\n+\n+    let mut h = StableHasher::new();\n+    test_isize.hash(&mut h);\n+\n+    // This depends on the hashing algorithm. See note at top of file.\n+    let expected = (14721296605626097289, 11385941877786388409);\n+\n+    assert_eq!(h.finalize(), expected);\n+}"}, {"sha": "d63bcdb3c2b0425d4993010dccc6fb0aee679cab", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -48,7 +48,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n-    const TAG_BIT_SHIFT: usize = (8 * std::mem::size_of::<usize>()) - T::BITS;\n+    const TAG_BIT_SHIFT: usize = usize::BITS as usize - T::BITS;\n     const ASSERTION: () = {\n         assert!(T::BITS <= P::BITS);\n         // Used for the transmute_copy's below"}, {"sha": "a780d2386a63c20674aefb2a94202093da0c8032", "filename": "compiler/rustc_data_structures/src/temp_dir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Ftemp_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_data_structures%2Fsrc%2Ftemp_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftemp_dir.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -12,7 +12,7 @@ pub struct MaybeTempDir {\n \n impl Drop for MaybeTempDir {\n     fn drop(&mut self) {\n-        // Safety: We are in the destructor, and no further access will\n+        // SAFETY: We are in the destructor, and no further access will\n         // occur.\n         let dir = unsafe { ManuallyDrop::take(&mut self.dir) };\n         if self.keep {"}, {"sha": "f610e88b7fce5fe7cee95c9179fc6ba151bdbe8b", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -9,8 +9,9 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n libc = \"0.2\"\n-tracing = { version = \"0.1.18\", features = [\"release_max_level_info\"]  }\n+tracing = { version = \"0.1.18\" }\n tracing-subscriber = { version = \"0.2.10\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n+tracing-tree = \"0.1.6\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_target = { path = \"../rustc_target\" }\n@@ -38,3 +39,4 @@ winapi = { version = \"0.3\", features = [\"consoleapi\", \"debugapi\", \"processenv\"]\n \n [features]\n llvm = ['rustc_interface/llvm']\n+max_level_info = ['tracing/max_level_info']"}, {"sha": "4f2febf04b135acf54afa8009bd74a46d42a1705", "filename": "compiler/rustc_driver/src/args.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fargs.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,8 +4,7 @@ use std::fs;\n use std::io;\n \n pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n-    if arg.starts_with('@') {\n-        let path = &arg[1..];\n+    if let Some(path) = arg.strip_prefix('@') {\n         let file = match fs::read_to_string(path) {\n             Ok(file) => file,\n             Err(ref err) if err.kind() == io::ErrorKind::InvalidData => {"}, {"sha": "3f50c68e3ebf54ff3b93d0fafcef306c3db2301c", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,7 +4,7 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(nll)]\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n@@ -141,6 +141,9 @@ pub fn run_compiler(\n     callbacks: &mut (dyn Callbacks + Send),\n     file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n     emitter: Option<Box<dyn Write + Send>>,\n+    make_codegen_backend: Option<\n+        Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n+    >,\n ) -> interface::Result<()> {\n     let mut args = Vec::new();\n     for arg in at_args {\n@@ -162,6 +165,11 @@ pub fn run_compiler(\n     let sopts = config::build_session_options(&matches);\n     let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n \n+    // We wrap `make_codegen_backend` in another `Option` such that `dummy_config` can take\n+    // ownership of it when necessary, while also allowing the non-dummy config to take ownership\n+    // when `dummy_config` is not used.\n+    let mut make_codegen_backend = Some(make_codegen_backend);\n+\n     let mut dummy_config = |sopts, cfg, diagnostic_output| {\n         let mut config = interface::Config {\n             opts: sopts,\n@@ -177,6 +185,7 @@ pub fn run_compiler(\n             lint_caps: Default::default(),\n             register_lints: None,\n             override_queries: None,\n+            make_codegen_backend: make_codegen_backend.take().unwrap(),\n             registry: diagnostics_registry(),\n         };\n         callbacks.config(&mut config);\n@@ -253,6 +262,7 @@ pub fn run_compiler(\n         lint_caps: Default::default(),\n         register_lints: None,\n         override_queries: None,\n+        make_codegen_backend: make_codegen_backend.unwrap(),\n         registry: diagnostics_registry(),\n     };\n \n@@ -1241,11 +1251,21 @@ pub fn init_env_logger(env: &str) {\n         Ok(s) if s.is_empty() => return,\n         Ok(_) => {}\n     }\n-    let builder = tracing_subscriber::FmtSubscriber::builder();\n-\n-    let builder = builder.with_env_filter(tracing_subscriber::EnvFilter::from_env(env));\n-\n-    builder.init()\n+    let filter = tracing_subscriber::EnvFilter::from_env(env);\n+    let layer = tracing_tree::HierarchicalLayer::default()\n+        .with_indent_lines(true)\n+        .with_ansi(true)\n+        .with_targets(true)\n+        .with_thread_ids(true)\n+        .with_thread_names(true)\n+        .with_wraparound(10)\n+        .with_verbose_exit(true)\n+        .with_verbose_entry(true)\n+        .with_indent_amount(2);\n+\n+    use tracing_subscriber::layer::SubscriberExt;\n+    let subscriber = tracing_subscriber::Registry::default().with(filter).with(layer);\n+    tracing::subscriber::set_global_default(subscriber).unwrap();\n }\n \n pub fn main() -> ! {\n@@ -1265,7 +1285,7 @@ pub fn main() -> ! {\n                 })\n             })\n             .collect::<Vec<_>>();\n-        run_compiler(&args, &mut callbacks, None, None)\n+        run_compiler(&args, &mut callbacks, None, None, None)\n     });\n     // The extra `\\t` is necessary to align this label with the others.\n     print_time_passes_entry(callbacks.time_passes, \"\\ttotal\", start.elapsed());"}, {"sha": "981b5bb8ba72f43599ca439fcfc39e9ca330baa8", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -18,7 +18,6 @@ E0010: include_str!(\"./error_codes/E0010.md\"),\n E0013: include_str!(\"./error_codes/E0013.md\"),\n E0014: include_str!(\"./error_codes/E0014.md\"),\n E0015: include_str!(\"./error_codes/E0015.md\"),\n-E0019: include_str!(\"./error_codes/E0019.md\"),\n E0023: include_str!(\"./error_codes/E0023.md\"),\n E0025: include_str!(\"./error_codes/E0025.md\"),\n E0026: include_str!(\"./error_codes/E0026.md\"),\n@@ -440,6 +439,8 @@ E0751: include_str!(\"./error_codes/E0751.md\"),\n E0752: include_str!(\"./error_codes/E0752.md\"),\n E0753: include_str!(\"./error_codes/E0753.md\"),\n E0754: include_str!(\"./error_codes/E0754.md\"),\n+E0755: include_str!(\"./error_codes/E0755.md\"),\n+E0756: include_str!(\"./error_codes/E0756.md\"),\n E0758: include_str!(\"./error_codes/E0758.md\"),\n E0759: include_str!(\"./error_codes/E0759.md\"),\n E0760: include_str!(\"./error_codes/E0760.md\"),\n@@ -455,9 +456,14 @@ E0769: include_str!(\"./error_codes/E0769.md\"),\n E0770: include_str!(\"./error_codes/E0770.md\"),\n E0771: include_str!(\"./error_codes/E0771.md\"),\n E0773: include_str!(\"./error_codes/E0773.md\"),\n+E0774: include_str!(\"./error_codes/E0774.md\"),\n+E0775: include_str!(\"./error_codes/E0775.md\"),\n+E0776: include_str!(\"./error_codes/E0776.md\"),\n+E0777: include_str!(\"./error_codes/E0777.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard\n+//  E0019, merged into E0015\n //  E0035, merged into E0087/E0089\n //  E0036, merged into E0087/E0089\n //  E0068,\n@@ -631,8 +637,6 @@ E0773: include_str!(\"./error_codes/E0773.md\"),\n     E0722, // Malformed `#[optimize]` attribute\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n-    E0755, // `#[ffi_pure]` is only allowed on foreign functions\n-    E0756, // `#[ffi_const]` is only allowed on foreign functions\n     E0757, // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n     E0772, // `'static' obligation coming from `impl dyn Trait {}` or `impl Foo for dyn Bar {}`.\n }"}, {"sha": "7832468a539d315c71cab09ebc1e936258fe616b", "filename": "compiler/rustc_error_codes/src/error_codes/E0019.md", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a009e2838b25df2761093d727d322a59f69d8f68/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0019.md", "raw_url": "https://github.com/rust-lang/rust/raw/a009e2838b25df2761093d727d322a59f69d8f68/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0019.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0019.md?ref=a009e2838b25df2761093d727d322a59f69d8f68", "patch": "@@ -1,36 +0,0 @@\n-A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0019\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    struct MyOwned;\n-\n-    static STATIC11: Box<MyOwned> = box MyOwned; // error!\n-}\n-```\n-\n-Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it anywhere else:\n-\n-```\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn func(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    FOO.func(); // here is good\n-    let x = FOO.func(); // or even here!\n-}\n-```"}, {"sha": "496174b28efac4cd65257d1b09d01fad33a53d50", "filename": "compiler/rustc_error_codes/src/error_codes/E0092.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0092.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0092.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0092.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -12,8 +12,8 @@ extern \"rust-intrinsic\" {\n ```\n \n Please check you didn't make a mistake in the function's name. All intrinsic\n-functions are defined in `librustc_codegen_llvm/intrinsic.rs` and in\n-`libcore/intrinsics.rs` in the Rust source code. Example:\n+functions are defined in `compiler/rustc_codegen_llvm/src/intrinsic.rs` and in\n+`library/core/src/intrinsics.rs` in the Rust source code. Example:\n \n ```\n #![feature(intrinsics)]"}, {"sha": "6d58e50ec8813d515f80c6925995c75890e18743", "filename": "compiler/rustc_error_codes/src/error_codes/E0093.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -17,8 +17,8 @@ fn main() {\n ```\n \n Please check you didn't make a mistake in the function's name. All intrinsic\n-functions are defined in `librustc_codegen_llvm/intrinsic.rs` and in\n-`libcore/intrinsics.rs` in the Rust source code. Example:\n+functions are defined in `compiler/rustc_codegen_llvm/src/intrinsic.rs` and in\n+`library/core/src/intrinsics.rs` in the Rust source code. Example:\n \n ```\n #![feature(intrinsics)]"}, {"sha": "345ec341c3f40f726c3dcab2b20112621128bddb", "filename": "compiler/rustc_error_codes/src/error_codes/E0118.md", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0118.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0118.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0118.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,10 +1,10 @@\n-An inherent implementation was defined for something which isn't a struct nor\n-an enum.\n+An inherent implementation was defined for something which isn't a struct,\n+enum, union, or trait object.\n \n Erroneous code example:\n \n ```compile_fail,E0118\n-impl (u8, u8) { // error: no base type found for inherent implementation\n+impl (u8, u8) { // error: no nominal type found for inherent implementation\n     fn get_state(&self) -> String {\n         // ...\n     }\n@@ -41,3 +41,24 @@ impl TypeWrapper {\n     }\n }\n ```\n+\n+Instead of defining an inherent implementation on a reference, you could also\n+move the reference inside the implementation:\n+\n+```compile_fail,E0118\n+struct Foo;\n+\n+impl &Foo { // error: no nominal type found for inherent implementation\n+    fn bar(self, other: Self) {}\n+}\n+```\n+\n+becomes\n+\n+```\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(&self, other: &Self) {}\n+}\n+```"}, {"sha": "628488575b2f80c97aaecc6521fd5fc13b5413a1", "filename": "compiler/rustc_error_codes/src/error_codes/E0224.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0224.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0224.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0224.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,4 +1,4 @@\n-A trait object was declaired with no traits.\n+A trait object was declared with no traits.\n \n Erroneous code example:\n \n@@ -8,7 +8,7 @@ type Foo = dyn 'static +;\n \n Rust does not currently support this.\n \n-To solve ensure the the trait object has at least one trait:\n+To solve, ensure that the trait object has at least one trait:\n \n ```\n type Foo = dyn 'static + Copy;"}, {"sha": "5a64c13c9af512f0bb1e136476ee3e5c30837bb2", "filename": "compiler/rustc_error_codes/src/error_codes/E0433.md", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0433.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0433.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0433.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,17 +1,27 @@\n-An undeclared type or module was used.\n+An undeclared crate, module, or type was used.\n \n Erroneous code example:\n \n ```compile_fail,E0433\n let map = HashMap::new();\n-// error: failed to resolve: use of undeclared type or module `HashMap`\n+// error: failed to resolve: use of undeclared type `HashMap`\n ```\n \n Please verify you didn't misspell the type/module's name or that you didn't\n forget to import it:\n \n-\n ```\n use std::collections::HashMap; // HashMap has been imported.\n let map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n ```\n+\n+If you've expected to use a crate name:\n+\n+```compile_fail\n+use ferris_wheel::BigO;\n+// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n+```\n+\n+Make sure the crate has been added as a dependency in `Cargo.toml`.\n+\n+To use a module from your current crate, add the `crate::` prefix to the path."}, {"sha": "0545246929f489e8a55c878f6d34c4ecf4d16acb", "filename": "compiler/rustc_error_codes/src/error_codes/E0607.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0607.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0607.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0607.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -12,15 +12,15 @@ First: what are thin and fat pointers?\n Thin pointers are \"simple\" pointers: they are purely a reference to a memory\n address.\n \n-Fat pointers are pointers referencing Dynamically Sized Types (also called DST).\n-DST don't have a statically known size, therefore they can only exist behind\n-some kind of pointers that contain additional information. Slices and trait\n-objects are DSTs. In the case of slices, the additional information the fat\n-pointer holds is their size.\n+Fat pointers are pointers referencing Dynamically Sized Types (also called\n+DSTs). DSTs don't have a statically known size, therefore they can only exist\n+behind some kind of pointer that contains additional information. For example,\n+slices and trait objects are DSTs. In the case of slices, the additional\n+information the fat pointer holds is their size.\n \n To fix this error, don't try to cast directly between thin and fat pointers.\n \n-For more information about casts, take a look at the Type cast section in\n-[The Reference Book][1].\n+For more information about type casts, take a look at the section of the\n+[The Rust Reference][1] on type cast expressions.\n \n [1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions"}, {"sha": "88b7f48496906d614f69538b5bb0256d2057804d", "filename": "compiler/rustc_error_codes/src/error_codes/E0755.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0755.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0755.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0755.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,28 @@\n+The `ffi_pure` attribute was used on a non-foreign function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0755\n+#![feature(ffi_pure)]\n+\n+#[ffi_pure] // error!\n+pub fn foo() {}\n+# fn main() {}\n+```\n+\n+The `ffi_pure` attribute can only be used on foreign functions which do not have\n+side effects or infinite loops:\n+\n+```\n+#![feature(ffi_pure)]\n+\n+extern \"C\" {\n+    #[ffi_pure] // ok!\n+    pub fn strlen(s: *const i8) -> isize;\n+}\n+# fn main() {}\n+```\n+\n+You can find more information about it in the [unstable Rust Book].\n+\n+[unstable Rust Book]: https://doc.rust-lang.org/unstable-book/language-features/ffi-pure.html"}, {"sha": "ffdc421aab58408f40ad0ff76109a7e1ebf18f89", "filename": "compiler/rustc_error_codes/src/error_codes/E0756.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0756.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0756.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0756.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,29 @@\n+The `ffi_const` attribute was used on something other than a foreign function\n+declaration.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0756\n+#![feature(ffi_const)]\n+\n+#[ffi_const] // error!\n+pub fn foo() {}\n+# fn main() {}\n+```\n+\n+The `ffi_const` attribute can only be used on foreign function declarations\n+which have no side effects except for their return value:\n+\n+```\n+#![feature(ffi_const)]\n+\n+extern \"C\" {\n+    #[ffi_const] // ok!\n+    pub fn strlen(s: *const i8) -> i32;\n+}\n+# fn main() {}\n+```\n+\n+You can get more information about it in the [unstable Rust Book].\n+\n+[unstable Rust Book]: https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-const.html"}, {"sha": "79793ba9d7d3d484e35cb1ea5e068d8d2586b525", "filename": "compiler/rustc_error_codes/src/error_codes/E0774.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0774.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0774.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0774.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,24 @@\n+`derive` was applied on something which is not a struct, a union or an enum.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0774\n+trait Foo {\n+    #[derive(Clone)] // error!\n+    type Bar;\n+}\n+```\n+\n+As said above, the `derive` attribute is only allowed on structs, unions or\n+enums:\n+\n+```\n+#[derive(Clone)] // ok!\n+struct Bar {\n+    field: u32,\n+}\n+```\n+\n+You can find more information about `derive` in the [Rust Book].\n+\n+[Rust Book]: https://doc.rust-lang.org/book/appendix-03-derivable-traits.html"}, {"sha": "9bafd52f75cf2d63c0dd97a0c7b4b60d90fa6361", "filename": "compiler/rustc_error_codes/src/error_codes/E0775.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0775.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0775.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0775.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,17 @@\n+`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M\n+extension.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0775\n+#![feature(cmse_nonsecure_entry)]\n+\n+#[cmse_nonsecure_entry]\n+pub extern \"C\" fn entry_function() {}\n+```\n+\n+To fix this error, compile your code for a Rust target that supports the\n+TrustZone-M extension. The current possible targets are:\n+* `thumbv8m.main-none-eabi`\n+* `thumbv8m.main-none-eabihf`\n+* `thumbv8m.base-none-eabi`"}, {"sha": "d65beebe07c61b27c7fea14f162e00a12d1de98e", "filename": "compiler/rustc_error_codes/src/error_codes/E0776.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0776.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0776.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0776.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,13 @@\n+`#[cmse_nonsecure_entry]` functions require a C ABI\n+\n+Erroneous code example:\n+\n+```compile_fail,E0776\n+#![feature(cmse_nonsecure_entry)]\n+\n+#[no_mangle]\n+#[cmse_nonsecure_entry]\n+pub fn entry_function(input: Vec<u32>) {}\n+```\n+\n+To fix this error, declare your entry function with a C ABI, using `extern \"C\"`."}, {"sha": "8c5c6e28b65c6750a4eef3a4f9d443b0da723467", "filename": "compiler/rustc_error_codes/src/error_codes/E0777.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0777.md", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0777.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0777.md?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,19 @@\n+A literal value was used inside `#[derive]`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0777\n+#[derive(\"Clone\")] // error!\n+struct Foo;\n+```\n+\n+Only paths to traits are allowed as argument inside `#[derive]`. You can find\n+more information about the `#[derive]` attribute in the [Rust Book].\n+\n+\n+```\n+#[derive(Clone)] // ok!\n+struct Foo;\n+```\n+\n+[Rust Book]: https://doc.rust-lang.org/book/appendix-03-derivable-traits.html"}, {"sha": "98cbf98df92b4d0888e20c3d95adf40923138998", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -959,15 +959,15 @@ impl EmitterWriter {\n                         '_',\n                         line_offset + pos,\n                         width_offset + depth,\n-                        code_offset + annotation.start_col - left,\n+                        (code_offset + annotation.start_col).saturating_sub(left),\n                         style,\n                     );\n                 }\n                 _ if self.teach => {\n                     buffer.set_style_range(\n                         line_offset,\n-                        code_offset + annotation.start_col - left,\n-                        code_offset + annotation.end_col - left,\n+                        (code_offset + annotation.start_col).saturating_sub(left),\n+                        (code_offset + annotation.end_col).saturating_sub(left),\n                         style,\n                         annotation.is_primary,\n                     );\n@@ -1227,26 +1227,22 @@ impl EmitterWriter {\n             }\n             draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n             if *level != Level::FailureNote {\n-                let level_str = level.to_string();\n-                if !level_str.is_empty() {\n-                    buffer.append(0, &level_str, Style::MainHeaderMsg);\n-                    buffer.append(0, \": \", Style::NoStyle);\n-                }\n+                buffer.append(0, level.to_str(), Style::MainHeaderMsg);\n+                buffer.append(0, \": \", Style::NoStyle);\n             }\n             self.msg_to_buffer(&mut buffer, msg, max_line_num_len, \"note\", None);\n         } else {\n-            let level_str = level.to_string();\n             // The failure note level itself does not provide any useful diagnostic information\n-            if *level != Level::FailureNote && !level_str.is_empty() {\n-                buffer.append(0, &level_str, Style::Level(*level));\n+            if *level != Level::FailureNote {\n+                buffer.append(0, level.to_str(), Style::Level(*level));\n             }\n             // only render error codes, not lint codes\n             if let Some(DiagnosticId::Error(ref code)) = *code {\n                 buffer.append(0, \"[\", Style::Level(*level));\n                 buffer.append(0, &code, Style::Level(*level));\n                 buffer.append(0, \"]\", Style::Level(*level));\n             }\n-            if *level != Level::FailureNote && !level_str.is_empty() {\n+            if *level != Level::FailureNote {\n                 buffer.append(0, \": \", header_style);\n             }\n             for &(ref text, _) in msg.iter() {\n@@ -1548,11 +1544,9 @@ impl EmitterWriter {\n         let mut buffer = StyledBuffer::new();\n \n         // Render the suggestion message\n-        let level_str = level.to_string();\n-        if !level_str.is_empty() {\n-            buffer.append(0, &level_str, Style::Level(*level));\n-            buffer.append(0, \": \", Style::HeaderMsg);\n-        }\n+        buffer.append(0, level.to_str(), Style::Level(*level));\n+        buffer.append(0, \": \", Style::HeaderMsg);\n+\n         self.msg_to_buffer(\n             &mut buffer,\n             &[(suggestion.msg.to_owned(), Style::NoStyle)],"}, {"sha": "2e8a4ef327ac4474751025d59cf8f2fd9c6a9b4d", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -2,7 +2,7 @@\n //!\n //! This module contains the code for creating and emitting diagnostics.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(backtrace)]\n #![feature(nll)]\n@@ -973,16 +973,14 @@ impl HandlerInner {\n \n     fn panic_if_treat_err_as_bug(&self) {\n         if self.treat_err_as_bug() {\n-            let s = match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n-                (0, _) => return,\n-                (1, 1) => \"aborting due to `-Z treat-err-as-bug=1`\".to_string(),\n-                (1, _) => return,\n-                (count, as_bug) => format!(\n+            match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n+                (1, 1) => panic!(\"aborting due to `-Z treat-err-as-bug=1`\"),\n+                (0, _) | (1, _) => {}\n+                (count, as_bug) => panic!(\n                     \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n                     count, as_bug,\n                 ),\n-            };\n-            panic!(s);\n+            }\n         }\n     }\n }"}, {"sha": "fae5b94b3a81edc650fd124051888f4b919e47c7", "filename": "compiler/rustc_errors/src/snippet.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -118,17 +118,15 @@ pub struct Annotation {\n impl Annotation {\n     /// Whether this annotation is a vertical line placeholder.\n     pub fn is_line(&self) -> bool {\n-        if let AnnotationType::MultilineLine(_) = self.annotation_type { true } else { false }\n+        matches!(self.annotation_type, AnnotationType::MultilineLine(_))\n     }\n \n     pub fn is_multiline(&self) -> bool {\n-        match self.annotation_type {\n+        matches!(self.annotation_type,\n             AnnotationType::Multiline(_)\n             | AnnotationType::MultilineStart(_)\n             | AnnotationType::MultilineLine(_)\n-            | AnnotationType::MultilineEnd(_) => true,\n-            _ => false,\n-        }\n+            | AnnotationType::MultilineEnd(_))\n     }\n \n     pub fn len(&self) -> usize {"}, {"sha": "f7651ca0ba6dd1e23d53b38340ccc144fb8ec4b7", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,10 +1,9 @@\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirectoryOwnership;\n \n-use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{self, TokenStream};\n+use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_ast::{self as ast, Attribute, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n@@ -313,7 +312,7 @@ where\n         ts: TokenStream,\n     ) -> Result<TokenStream, ErrorReported> {\n         // FIXME setup implicit context in TLS before calling self.\n-        Ok((*self)(ts))\n+        Ok(self(ts))\n     }\n }\n \n@@ -339,7 +338,7 @@ where\n         annotated: TokenStream,\n     ) -> Result<TokenStream, ErrorReported> {\n         // FIXME setup implicit context in TLS before calling self.\n-        Ok((*self)(annotation, annotated))\n+        Ok(self(annotation, annotated))\n     }\n }\n \n@@ -364,31 +363,9 @@ where\n         &self,\n         ecx: &'cx mut ExtCtxt<'_>,\n         span: Span,\n-        mut input: TokenStream,\n+        input: TokenStream,\n     ) -> Box<dyn MacResult + 'cx> {\n-        struct AvoidInterpolatedIdents;\n-\n-        impl MutVisitor for AvoidInterpolatedIdents {\n-            fn visit_tt(&mut self, tt: &mut tokenstream::TokenTree) {\n-                if let tokenstream::TokenTree::Token(token) = tt {\n-                    if let token::Interpolated(nt) = &token.kind {\n-                        if let token::NtIdent(ident, is_raw) = **nt {\n-                            *tt = tokenstream::TokenTree::token(\n-                                token::Ident(ident.name, is_raw),\n-                                ident.span,\n-                            );\n-                        }\n-                    }\n-                }\n-                mut_visit::noop_visit_tt(tt, self)\n-            }\n-\n-            fn visit_mac(&mut self, mac: &mut ast::MacCall) {\n-                mut_visit::noop_visit_mac(mac, self)\n-            }\n-        }\n-        AvoidInterpolatedIdents.visit_tts(&mut input);\n-        (*self)(ecx, span, input)\n+        self(ecx, span, input)\n     }\n }\n \n@@ -400,6 +377,7 @@ macro_rules! make_stmts_default {\n                 id: ast::DUMMY_NODE_ID,\n                 span: e.span,\n                 kind: ast::StmtKind::Expr(e),\n+                tokens: None\n             }]\n         })\n     };\n@@ -607,6 +585,7 @@ impl DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             kind: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(Vec::new()) },\n             span: sp,\n+            tokens: None,\n         })\n     }\n }\n@@ -641,6 +620,7 @@ impl MacResult for DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             kind: ast::StmtKind::Expr(DummyResult::raw_expr(self.span, self.is_error)),\n             span: self.span,\n+            tokens: None\n         }])\n     }\n "}, {"sha": "a5a7ee6c9a349532e3e1b9ee45f1a7c0f50fd048", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -3,7 +3,7 @@ use crate::base::ExtCtxt;\n use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, AttrVec, BlockCheckMode, Expr, PatKind, UnOp};\n-use rustc_span::source_map::{respan, Spanned};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n \n use rustc_span::Span;\n@@ -46,15 +46,15 @@ impl<'a> ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             args,\n         });\n-        ast::Path { span, segments }\n+        ast::Path { span, segments, tokens: None }\n     }\n \n     pub fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n         ast::MutTy { ty, mutbl }\n     }\n \n     pub fn ty(&self, span: Span, kind: ast::TyKind) -> P<ast::Ty> {\n-        P(ast::Ty { id: ast::DUMMY_NODE_ID, span, kind })\n+        P(ast::Ty { id: ast::DUMMY_NODE_ID, span, kind, tokens: None })\n     }\n \n     pub fn ty_path(&self, path: ast::Path) -> P<ast::Ty> {\n@@ -158,7 +158,12 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n-        ast::Stmt { id: ast::DUMMY_NODE_ID, span: expr.span, kind: ast::StmtKind::Expr(expr) }\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: expr.span,\n+            kind: ast::StmtKind::Expr(expr),\n+            tokens: None,\n+        }\n     }\n \n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: Ident, ex: P<ast::Expr>) -> ast::Stmt {\n@@ -176,7 +181,12 @@ impl<'a> ExtCtxt<'a> {\n             span: sp,\n             attrs: AttrVec::new(),\n         });\n-        ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span: sp }\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            kind: ast::StmtKind::Local(local),\n+            span: sp,\n+            tokens: None,\n+        }\n     }\n \n     // Generates `let _: Type;`, which is usually used for type assertions.\n@@ -189,11 +199,16 @@ impl<'a> ExtCtxt<'a> {\n             span,\n             attrs: AttrVec::new(),\n         });\n-        ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span }\n+        ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span, tokens: None }\n     }\n \n     pub fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n-        ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Item(item), span: sp }\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            kind: ast::StmtKind::Item(item),\n+            span: sp,\n+            tokens: None,\n+        }\n     }\n \n     pub fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n@@ -203,11 +218,18 @@ impl<'a> ExtCtxt<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 span: expr.span,\n                 kind: ast::StmtKind::Expr(expr),\n+                tokens: None,\n             }],\n         )\n     }\n     pub fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n-        P(ast::Block { stmts, id: ast::DUMMY_NODE_ID, rules: BlockCheckMode::Default, span })\n+        P(ast::Block {\n+            stmts,\n+            id: ast::DUMMY_NODE_ID,\n+            rules: BlockCheckMode::Default,\n+            span,\n+            tokens: None,\n+        })\n     }\n \n     pub fn expr(&self, span: Span, kind: ast::ExprKind) -> P<ast::Expr> {\n@@ -578,7 +600,11 @@ impl<'a> ExtCtxt<'a> {\n             attrs,\n             id: ast::DUMMY_NODE_ID,\n             kind,\n-            vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+            vis: ast::Visibility {\n+                span: span.shrink_to_lo(),\n+                kind: ast::VisibilityKind::Inherited,\n+                tokens: None,\n+            },\n             span,\n             tokens: None,\n         })\n@@ -592,7 +618,11 @@ impl<'a> ExtCtxt<'a> {\n                 span: ty.span,\n                 ty,\n                 ident: None,\n-                vis: respan(vis_span, ast::VisibilityKind::Inherited),\n+                vis: ast::Visibility {\n+                    span: vis_span,\n+                    kind: ast::VisibilityKind::Inherited,\n+                    tokens: None,\n+                },\n                 attrs: Vec::new(),\n                 id: ast::DUMMY_NODE_ID,\n                 is_placeholder: false,\n@@ -611,7 +641,11 @@ impl<'a> ExtCtxt<'a> {\n             disr_expr: None,\n             id: ast::DUMMY_NODE_ID,\n             ident,\n-            vis: respan(vis_span, ast::VisibilityKind::Inherited),\n+            vis: ast::Visibility {\n+                span: vis_span,\n+                kind: ast::VisibilityKind::Inherited,\n+                tokens: None,\n+            },\n             span,\n             is_placeholder: false,\n         }"}, {"sha": "dd087ab91509bf6cc797ff67e7ecdd35b7837d89", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -399,7 +399,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     pub fn configure_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        let ast::ForeignMod { abi: _, items } = foreign_mod;\n+        let ast::ForeignMod { unsafety: _, abi: _, items } = foreign_mod;\n         items.flat_map_in_place(|item| self.configure(item));\n     }\n "}, {"sha": "c6287693dc9e62ae0013f56fadb65a715eb4a756", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -13,20 +13,19 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AttrItem, Block, LitKind, NodeId, PatKind, Path};\n-use rustc_ast::{ItemKind, MacArgs, MacCallStmt, MacStmtStyle, StmtKind};\n+use rustc_ast::{ItemKind, MacArgs, MacCallStmt, MacStmtStyle, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{Applicability, PResult};\n+use rustc_errors::{struct_span_err, Applicability, PResult};\n use rustc_feature::Features;\n use rustc_parse::parser::Parser;\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n use rustc_session::Limit;\n-use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{ExpnId, FileName, Span, DUMMY_SP};\n \n@@ -358,7 +357,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             kind: ast::ItemKind::Mod(krate.module),\n             ident: Ident::invalid(),\n             id: ast::DUMMY_NODE_ID,\n-            vis: respan(krate.span.shrink_to_lo(), ast::VisibilityKind::Public),\n+            vis: ast::Visibility {\n+                span: krate.span.shrink_to_lo(),\n+                kind: ast::VisibilityKind::Public,\n+                tokens: None,\n+            },\n             tokens: None,\n         })]);\n \n@@ -370,11 +373,21 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             None => {\n                 // Resolution failed so we return an empty expansion\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod { inner: orig_mod_span, items: vec![], inline: true };\n+                krate.module = ast::Mod {\n+                    inner: orig_mod_span,\n+                    unsafety: Unsafe::No,\n+                    items: vec![],\n+                    inline: true,\n+                };\n             }\n             Some(ast::Item { span, kind, .. }) => {\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod { inner: orig_mod_span, items: vec![], inline: true };\n+                krate.module = ast::Mod {\n+                    inner: orig_mod_span,\n+                    unsafety: Unsafe::No,\n+                    items: vec![],\n+                    inline: true,\n+                };\n                 self.cx.span_err(\n                     span,\n                     &format!(\n@@ -529,9 +542,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn error_derive_forbidden_on_non_adt(&self, derives: &[Path], item: &Annotatable) {\n         let attr = self.cx.sess.find_by_name(item.attrs(), sym::derive);\n         let span = attr.map_or(item.span(), |attr| attr.span);\n-        let mut err = self\n-            .cx\n-            .struct_span_err(span, \"`derive` may only be applied to structs, enums and unions\");\n+        let mut err = struct_span_err!(\n+            self.cx.sess,\n+            span,\n+            E0774,\n+            \"`derive` may only be applied to structs, enums and unions\",\n+        );\n         if let Some(ast::Attribute { style: ast::AttrStyle::Inner, .. }) = attr {\n             let trait_list = derives.iter().map(|t| pprust::path_to_string(t)).collect::<Vec<_>>();\n             let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n@@ -1380,10 +1396,10 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         // The placeholder expander gives ids to statements, so we avoid folding the id here.\n-        let ast::Stmt { id, kind, span } = stmt;\n+        let ast::Stmt { id, kind, span, tokens } = stmt;\n         noop_flat_map_stmt_kind(kind, self)\n             .into_iter()\n-            .map(|kind| ast::Stmt { id, kind, span })\n+            .map(|kind| ast::Stmt { id, kind, span, tokens: tokens.clone() })\n             .collect()\n     }\n \n@@ -1438,8 +1454,15 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     push_directory(&self.cx.sess, ident, &item.attrs, dir)\n                 } else {\n                     // We have an outline `mod foo;` so we need to parse the file.\n-                    let (new_mod, dir) =\n-                        parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n+                    let (new_mod, dir) = parse_external_mod(\n+                        &self.cx.sess,\n+                        ident,\n+                        span,\n+                        old_mod.unsafety,\n+                        dir,\n+                        &mut attrs,\n+                        pushed,\n+                    );\n \n                     let krate = ast::Crate {\n                         span: new_mod.inner,\n@@ -1757,6 +1780,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 kind: ast::AttrKind::Normal(AttrItem {\n                     path: meta.path,\n                     args: meta.kind.mac_args(meta.span),\n+                    tokens: None,\n                 }),\n                 span: at.span,\n                 id: at.id,"}, {"sha": "47247294f5dc69ed5b90bc18d5695ad5d8f39fd1", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,5 +1,4 @@\n #![feature(bool_to_option)]\n-#![feature(cow_is_borrowed)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(or_patterns)]"}, {"sha": "0e5c5fe4d447394f4708f566edc2853dfdbbbc1a", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,7 +4,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n \n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::token::{self, NtTT, Token};\n-use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n+use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n use rustc_ast::MacCall;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -111,7 +111,7 @@ pub(super) fn transcribe<'a>(\n     //\n     // Thus, if we try to pop the `result_stack` and it is empty, we have reached the top-level\n     // again, and we are done transcribing.\n-    let mut result: Vec<TreeAndJoint> = Vec::new();\n+    let mut result: Vec<TreeAndSpacing> = Vec::new();\n     let mut result_stack = Vec::new();\n     let mut marker = Marker(cx.current_expansion.id, transparency);\n "}, {"sha": "171cb3fa8e6e920088095fb7a085a0adfaab62cc", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::{token, Attribute, Mod};\n+use rustc_ast::{token, Attribute, Mod, Unsafe};\n use rustc_errors::{struct_span_err, PResult};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n@@ -42,6 +42,7 @@ crate fn parse_external_mod(\n     sess: &Session,\n     id: Ident,\n     span: Span, // The span to blame on errors.\n+    unsafety: Unsafe,\n     Directory { mut ownership, path }: Directory,\n     attrs: &mut Vec<Attribute>,\n     pop_mod_stack: &mut bool,\n@@ -60,13 +61,16 @@ crate fn parse_external_mod(\n         drop(included_mod_stack);\n \n         // Actually parse the external file as a module.\n-        let mut module =\n-            new_parser_from_file(&sess.parse_sess, &mp.path, Some(span)).parse_mod(&token::Eof)?;\n+        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n+        let mut module = parser.parse_mod(&token::Eof, unsafety)?;\n         module.0.inline = false;\n         module\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n+    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_else(|_| {\n+        let module = Mod { inner: Span::default(), unsafety, items: Vec::new(), inline: false };\n+        (module, Vec::new())\n+    });\n     attrs.append(&mut new_attrs);\n \n     // Extract the directory path for submodules of `module`.\n@@ -219,8 +223,7 @@ fn error_cannot_declare_mod_here<'a, T>(\n \n /// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n /// The provided `dir_path` is joined with the `path_string`.\n-// Public for rustfmt usage.\n-pub fn submod_path_from_attr(\n+pub(super) fn submod_path_from_attr(\n     sess: &Session,\n     attrs: &[Attribute],\n     dir_path: &Path,"}, {"sha": "4c9271a58df58b469691d61f7c18de909c6230c3", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,7 +4,7 @@ use crate::expand::{AstFragment, AstFragmentKind};\n use rustc_ast as ast;\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n-use rustc_span::source_map::{dummy_spanned, DUMMY_SP};\n+use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::Ident;\n \n use smallvec::{smallvec, SmallVec};\n@@ -18,15 +18,19 @@ pub fn placeholder(\n ) -> AstFragment {\n     fn mac_placeholder() -> ast::MacCall {\n         ast::MacCall {\n-            path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n+            path: ast::Path { span: DUMMY_SP, segments: Vec::new(), tokens: None },\n             args: P(ast::MacArgs::Empty),\n             prior_type_ascription: None,\n         }\n     }\n \n     let ident = Ident::invalid();\n     let attrs = Vec::new();\n-    let vis = vis.unwrap_or_else(|| dummy_spanned(ast::VisibilityKind::Inherited));\n+    let vis = vis.unwrap_or(ast::Visibility {\n+        span: DUMMY_SP,\n+        kind: ast::VisibilityKind::Inherited,\n+        tokens: None,\n+    });\n     let span = DUMMY_SP;\n     let expr_placeholder = || {\n         P(ast::Expr {\n@@ -37,7 +41,8 @@ pub fn placeholder(\n             tokens: None,\n         })\n     };\n-    let ty = || P(ast::Ty { id, kind: ast::TyKind::MacCall(mac_placeholder()), span });\n+    let ty =\n+        || P(ast::Ty { id, kind: ast::TyKind::MacCall(mac_placeholder()), span, tokens: None });\n     let pat =\n         || P(ast::Pat { id, kind: ast::PatKind::MacCall(mac_placeholder()), span, tokens: None });\n \n@@ -88,16 +93,19 @@ pub fn placeholder(\n             kind: ast::PatKind::MacCall(mac_placeholder()),\n             tokens: None,\n         })),\n-        AstFragmentKind::Ty => {\n-            AstFragment::Ty(P(ast::Ty { id, span, kind: ast::TyKind::MacCall(mac_placeholder()) }))\n-        }\n+        AstFragmentKind::Ty => AstFragment::Ty(P(ast::Ty {\n+            id,\n+            span,\n+            kind: ast::TyKind::MacCall(mac_placeholder()),\n+            tokens: None,\n+        })),\n         AstFragmentKind::Stmts => AstFragment::Stmts(smallvec![{\n             let mac = P(ast::MacCallStmt {\n                 mac: mac_placeholder(),\n                 style: ast::MacStmtStyle::Braces,\n                 attrs: ast::AttrVec::new(),\n             });\n-            ast::Stmt { id, span, kind: ast::StmtKind::MacCall(mac) }\n+            ast::Stmt { id, span, kind: ast::StmtKind::MacCall(mac), tokens: None }\n         }]),\n         AstFragmentKind::Arms => AstFragment::Arms(smallvec![ast::Arm {\n             attrs: Default::default(),"}, {"sha": "4c95f19b96dc69113bc9e65e3d5c3eb349e4f337", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -5,7 +5,8 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, ErrorReported};\n+use rustc_errors::{struct_span_err, Applicability, ErrorReported};\n+use rustc_lexer::is_ident;\n use rustc_parse::nt_to_tokenstream;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n@@ -182,9 +183,22 @@ crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>)\n             .filter_map(|nmi| match nmi {\n                 NestedMetaItem::Literal(lit) => {\n                     error_reported_filter_map = true;\n-                    cx.struct_span_err(lit.span, \"expected path to a trait, found literal\")\n-                        .help(\"for example, write `#[derive(Debug)]` for `Debug`\")\n-                        .emit();\n+                    let mut err = struct_span_err!(\n+                        cx.sess,\n+                        lit.span,\n+                        E0777,\n+                        \"expected path to a trait, found literal\",\n+                    );\n+                    let token = lit.token.to_string();\n+                    if token.starts_with('\"')\n+                        && token.len() > 2\n+                        && is_ident(&token[1..token.len() - 1])\n+                    {\n+                        err.help(&format!(\"try using `#[derive({})]`\", &token[1..token.len() - 1]));\n+                    } else {\n+                        err.help(\"for example, write `#[derive(Debug)]` for `Debug`\");\n+                    }\n+                    err.emit();\n                     None\n                 }\n                 NestedMetaItem::MetaItem(mi) => Some(mi),"}, {"sha": "4cfb188783ba110c42165132188d698c3a535152", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -2,7 +2,7 @@ use crate::base::ExtCtxt;\n \n use rustc_ast as ast;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n+use rustc_ast::tokenstream::{self, DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::Diagnostic;\n@@ -47,15 +47,15 @@ impl ToInternal<token::DelimToken> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n+impl FromInternal<(TreeAndSpacing, &'_ ParseSess, &'_ mut Vec<Self>)>\n     for TokenTree<Group, Punct, Ident, Literal>\n {\n     fn from_internal(\n-        ((tree, is_joint), sess, stack): (TreeAndJoint, &ParseSess, &mut Vec<Self>),\n+        ((tree, spacing), sess, stack): (TreeAndSpacing, &ParseSess, &mut Vec<Self>),\n     ) -> Self {\n         use rustc_ast::token::*;\n \n-        let joint = is_joint == Joint;\n+        let joint = spacing == Joint;\n         let Token { kind, span } = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n                 let delimiter = Delimiter::from_internal(delim);\n@@ -261,7 +261,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n         };\n \n         let tree = tokenstream::TokenTree::token(kind, span);\n-        TokenStream::new(vec![(tree, if joint { Joint } else { NonJoint })])\n+        TokenStream::new(vec![(tree, if joint { Joint } else { Alone })])\n     }\n }\n \n@@ -444,7 +444,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n     ) -> Option<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n         loop {\n             let tree = iter.stack.pop().or_else(|| {\n-                let next = iter.cursor.next_with_joint()?;\n+                let next = iter.cursor.next_with_spacing()?;\n                 Some(TokenTree::from_internal((next, self.sess, &mut iter.stack)))\n             })?;\n             // A hack used to pass AST fragments to attribute and derive macros\n@@ -584,12 +584,12 @@ impl server::Literal for Rustc<'_> {\n \n         let start = match start {\n             Bound::Included(lo) => lo,\n-            Bound::Excluded(lo) => lo + 1,\n+            Bound::Excluded(lo) => lo.checked_add(1)?,\n             Bound::Unbounded => 0,\n         };\n \n         let end = match end {\n-            Bound::Included(hi) => hi + 1,\n+            Bound::Included(hi) => hi.checked_add(1)?,\n             Bound::Excluded(hi) => hi,\n             Bound::Unbounded => length,\n         };"}, {"sha": "e2492efb9d79ed4c758787765ff3b3fedb756aa8", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,6 +1,6 @@\n //! List of the accepted feature gates.\n \n-use super::{Feature, State};\n+use super::{to_nonzero, Feature, State};\n use rustc_span::symbol::sym;\n \n macro_rules! declare_features {\n@@ -14,7 +14,7 @@ macro_rules! declare_features {\n                     state: State::Accepted,\n                     name: sym::$feature,\n                     since: $ver,\n-                    issue: $issue,\n+                    issue: to_nonzero($issue),\n                     edition: None,\n                     description: concat!($($doc,)*),\n                 }\n@@ -268,6 +268,8 @@ declare_features! (\n     /// Allows `#[track_caller]` to be used which provides\n     /// accurate caller location reporting during panic (RFC 2091).\n     (accepted, track_caller, \"1.46.0\", Some(47809), None),\n+    /// Allows `#[doc(alias = \"...\")]`.\n+    (accepted, doc_alias, \"1.48.0\", Some(50146), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "cd018ae1204f9a2c527cf5064fb9014c9edd7ff5", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,6 +1,6 @@\n //! List of the active feature gates.\n \n-use super::{Feature, State};\n+use super::{to_nonzero, Feature, State};\n \n use rustc_span::edition::Edition;\n use rustc_span::symbol::{sym, Symbol};\n@@ -29,7 +29,7 @@ macro_rules! declare_features {\n                     state: State::Active { set: set!($feature) },\n                     name: sym::$feature,\n                     since: $ver,\n-                    issue: $issue,\n+                    issue: to_nonzero($issue),\n                     edition: $edition,\n                     description: concat!($($doc,)*),\n                 }\n@@ -229,7 +229,6 @@ declare_features! (\n     (active, powerpc_target_feature, \"1.27.0\", Some(44839), None),\n     (active, mips_target_feature, \"1.27.0\", Some(44839), None),\n     (active, avx512_target_feature, \"1.27.0\", Some(44839), None),\n-    (active, mmx_target_feature, \"1.27.0\", Some(44839), None),\n     (active, sse4a_target_feature, \"1.27.0\", Some(44839), None),\n     (active, tbm_target_feature, \"1.27.0\", Some(44839), None),\n     (active, wasm_target_feature, \"1.30.0\", Some(44839), None),\n@@ -404,9 +403,6 @@ declare_features! (\n     /// Allows dereferencing raw pointers during const eval.\n     (active, const_raw_ptr_deref, \"1.27.0\", Some(51911), None),\n \n-    /// Allows `#[doc(alias = \"...\")]`.\n-    (active, doc_alias, \"1.27.0\", Some(50146), None),\n-\n     /// Allows inconsistent bounds in where clauses.\n     (active, trivial_bounds, \"1.28.0\", Some(48214), None),\n \n@@ -585,6 +581,21 @@ declare_features! (\n     /// Allows `if let` guard in match arms.\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n \n+    /// Allows non-trivial generic constants which have to be manually propageted upwards.\n+    (active, const_evaluatable_checked, \"1.48.0\", Some(76560), None),\n+\n+    /// Allows basic arithmetic on floating point types in a `const fn`.\n+    (active, const_fn_floating_point_arithmetic, \"1.48.0\", Some(57241), None),\n+\n+    /// Allows using and casting function pointers in a `const fn`.\n+    (active, const_fn_fn_ptr_basics, \"1.48.0\", Some(57563), None),\n+\n+    /// Allows to use the `#[cmse_nonsecure_entry]` attribute.\n+    (active, cmse_nonsecure_entry, \"1.48.0\", Some(75835), None),\n+\n+    /// Allows rustc to inject a default alloc_error_handler\n+    (active, default_alloc_error_handler, \"1.48.0\", Some(66741), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -600,8 +611,14 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::const_generics,\n     sym::let_chains,\n     sym::raw_dylib,\n+    sym::const_evaluatable_checked,\n     sym::const_trait_impl,\n     sym::const_trait_bound_opt_out,\n     sym::lazy_normalization_consts,\n     sym::specialization,\n ];\n+\n+/// Some features are not allowed to be used together at the same time, if\n+/// the two are present, produce an error.\n+pub const INCOMPATIBLE_FEATURES: &[(Symbol, Symbol)] =\n+    &[(sym::const_generics, sym::min_const_generics)];"}, {"sha": "b7e113e601007b3d39a3096966bf0cfae158573e", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -26,6 +26,11 @@ const GATED_CFGS: &[GatedCfg] = &[\n     (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n     (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n     (sym::target_has_atomic_load_store, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (\n+        sym::target_has_atomic_equal_alignment,\n+        sym::cfg_target_has_atomic,\n+        cfg_fn!(cfg_target_has_atomic),\n+    ),\n     (sym::sanitize, sym::cfg_sanitize, cfg_fn!(cfg_sanitize)),\n     (sym::version, sym::cfg_version, cfg_fn!(cfg_version)),\n ];\n@@ -344,6 +349,8 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         experimental!(register_tool),\n     ),\n \n+    gated!(cmse_nonsecure_entry, AssumedUsed, template!(Word), experimental!(cmse_nonsecure_entry)),\n+\n     // ==========================================================================\n     // Internal attributes: Stability, deprecation, and unsafe:\n     // ==========================================================================\n@@ -459,7 +466,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     rustc_attr!(rustc_promotable, AssumedUsed, template!(Word), IMPL_DETAIL),\n-    rustc_attr!(rustc_allow_const_fn_ptr, AssumedUsed, template!(Word), IMPL_DETAIL),\n     rustc_attr!(rustc_args_required_const, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n \n     // =========================================================================="}, {"sha": "68ac2841fed70a62fafbcc9ae6ea04363c2b6b7b", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -46,17 +46,11 @@ pub struct Feature {\n     pub state: State,\n     pub name: Symbol,\n     pub since: &'static str,\n-    issue: Option<u32>, // FIXME: once #58732 is done make this an Option<NonZeroU32>\n+    issue: Option<NonZeroU32>,\n     pub edition: Option<Edition>,\n     description: &'static str,\n }\n \n-impl Feature {\n-    fn issue(&self) -> Option<NonZeroU32> {\n-        self.issue.and_then(NonZeroU32::new)\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum Stability {\n     Unstable,\n@@ -102,8 +96,8 @@ impl UnstableFeatures {\n fn find_lang_feature_issue(feature: Symbol) -> Option<NonZeroU32> {\n     if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.name == feature) {\n         // FIXME (#28244): enforce that active features have issue numbers\n-        // assert!(info.issue().is_some())\n-        info.issue()\n+        // assert!(info.issue.is_some())\n+        info.issue\n     } else {\n         // search in Accepted, Removed, or Stable Removed features\n         let found = ACCEPTED_FEATURES\n@@ -112,12 +106,21 @@ fn find_lang_feature_issue(feature: Symbol) -> Option<NonZeroU32> {\n             .chain(STABLE_REMOVED_FEATURES)\n             .find(|t| t.name == feature);\n         match found {\n-            Some(found) => found.issue(),\n+            Some(found) => found.issue,\n             None => panic!(\"feature `{}` is not declared anywhere\", feature),\n         }\n     }\n }\n \n+const fn to_nonzero(n: Option<u32>) -> Option<NonZeroU32> {\n+    // Can be replaced with `n.and_then(NonZeroU32::new)` if that is ever usable\n+    // in const context. Requires https://github.com/rust-lang/rfcs/pull/2632.\n+    match n {\n+        None => None,\n+        Some(n) => NonZeroU32::new(n),\n+    }\n+}\n+\n pub enum GateIssue {\n     Language,\n     Library(Option<NonZeroU32>),\n@@ -131,7 +134,7 @@ pub fn find_feature_issue(feature: Symbol, issue: GateIssue) -> Option<NonZeroU3\n }\n \n pub use accepted::ACCEPTED_FEATURES;\n-pub use active::{Features, ACTIVE_FEATURES, INCOMPLETE_FEATURES};\n+pub use active::{Features, ACTIVE_FEATURES, INCOMPATIBLE_FEATURES, INCOMPLETE_FEATURES};\n pub use builtin_attrs::{\n     deprecated_attributes, find_gated_cfg, is_builtin_attr_name, AttributeGate, AttributeTemplate,\n     AttributeType, BuiltinAttribute, GatedCfg, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,"}, {"sha": "a480ddc7f34b1f2e41b8004b300272ac6dbe73f6", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,6 +1,6 @@\n //! List of the removed feature gates.\n \n-use super::{Feature, State};\n+use super::{to_nonzero, Feature, State};\n use rustc_span::symbol::sym;\n \n macro_rules! declare_features {\n@@ -14,7 +14,7 @@ macro_rules! declare_features {\n                     state: State::Removed { reason: $reason },\n                     name: sym::$feature,\n                     since: $ver,\n-                    issue: $issue,\n+                    issue: to_nonzero($issue),\n                     edition: None,\n                     description: concat!($($doc,)*),\n                 }\n@@ -32,7 +32,7 @@ macro_rules! declare_features {\n                     state: State::Stabilized { reason: None },\n                     name: sym::$feature,\n                     since: $ver,\n-                    issue: $issue,\n+                    issue: to_nonzero($issue),\n                     edition: None,\n                     description: concat!($($doc,)*),\n                 }"}, {"sha": "76e33bed97f27f3999da68b8970e8695a2e97b1a", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -272,7 +272,7 @@\n //! * [DOT language](http://www.graphviz.org/doc/info/lang.html)\n \n #![doc(\n-    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+    html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\",\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n #![feature(nll)]\n@@ -591,14 +591,15 @@ pub trait GraphWalk<'a> {\n     fn target(&'a self, edge: &Self::Edge) -> Self::Node;\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub enum RenderOption {\n     NoEdgeLabels,\n     NoNodeLabels,\n     NoEdgeStyles,\n     NoNodeStyles,\n \n-    Monospace,\n+    Fontname(String),\n+    DarkTheme,\n }\n \n /// Returns vec holding all the default render options.\n@@ -630,10 +631,26 @@ where\n     writeln!(w, \"digraph {} {{\", g.graph_id().as_slice())?;\n \n     // Global graph properties\n-    if options.contains(&RenderOption::Monospace) {\n-        writeln!(w, r#\"    graph[fontname=\"monospace\"];\"#)?;\n-        writeln!(w, r#\"    node[fontname=\"monospace\"];\"#)?;\n-        writeln!(w, r#\"    edge[fontname=\"monospace\"];\"#)?;\n+    let mut graph_attrs = Vec::new();\n+    let mut content_attrs = Vec::new();\n+    let font;\n+    if let Some(fontname) = options.iter().find_map(|option| {\n+        if let RenderOption::Fontname(fontname) = option { Some(fontname) } else { None }\n+    }) {\n+        font = format!(r#\"fontname=\"{}\"\"#, fontname);\n+        graph_attrs.push(&font[..]);\n+        content_attrs.push(&font[..]);\n+    }\n+    if options.contains(&RenderOption::DarkTheme) {\n+        graph_attrs.push(r#\"bgcolor=\"black\"\"#);\n+        content_attrs.push(r#\"color=\"white\"\"#);\n+        content_attrs.push(r#\"fontcolor=\"white\"\"#);\n+    }\n+    if !(graph_attrs.is_empty() && content_attrs.is_empty()) {\n+        writeln!(w, r#\"    graph[{}];\"#, graph_attrs.join(\" \"))?;\n+        let content_attrs_str = content_attrs.join(\" \");\n+        writeln!(w, r#\"    node[{}];\"#, content_attrs_str)?;\n+        writeln!(w, r#\"    edge[{}];\"#, content_attrs_str)?;\n     }\n \n     for n in g.nodes().iter() {"}, {"sha": "62b1254287724aedacab6f5a7642124dbfd2bcdb", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::NodeId;\n use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n \n+use std::array::IntoIter;\n use std::fmt::Debug;\n \n /// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n@@ -198,7 +199,16 @@ pub enum Res<Id = hir::HirId> {\n \n     // Type namespace\n     PrimTy(hir::PrimTy),\n-    SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n+    /// `Self`, with both an optional trait and impl `DefId`.\n+    ///\n+    /// HACK(min_const_generics): impl self types also have an optional requirement to not mention\n+    /// any generic parameters to allow the following with `min_const_generics`:\n+    /// ```rust\n+    /// impl Foo { fn test() -> [u8; std::mem::size_of::<Self>()] {} }\n+    /// ```\n+    ///\n+    /// FIXME(lazy_normalization_consts): Remove this bodge once this feature is stable.\n+    SelfTy(Option<DefId> /* trait */, Option<(DefId, bool)> /* impl */),\n     ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n     // Value namespace\n@@ -291,6 +301,14 @@ impl<T> PerNS<T> {\n     pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> PerNS<U> {\n         PerNS { value_ns: f(self.value_ns), type_ns: f(self.type_ns), macro_ns: f(self.macro_ns) }\n     }\n+\n+    pub fn into_iter(self) -> IntoIter<T, 3> {\n+        IntoIter::new([self.value_ns, self.type_ns, self.macro_ns])\n+    }\n+\n+    pub fn iter(&self) -> IntoIter<&T, 3> {\n+        IntoIter::new([&self.value_ns, &self.type_ns, &self.macro_ns])\n+    }\n }\n \n impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n@@ -323,9 +341,7 @@ impl<T> PerNS<Option<T>> {\n \n     /// Returns an iterator over the items which are `Some`.\n     pub fn present_items(self) -> impl Iterator<Item = T> {\n-        use std::iter::once;\n-\n-        once(self.type_ns).chain(once(self.value_ns)).chain(once(self.macro_ns)).filter_map(|it| it)\n+        IntoIter::new([self.type_ns, self.value_ns, self.macro_ns]).filter_map(|it| it)\n     }\n }\n "}, {"sha": "afefde07f92973b52f9d39d3bb8e42a087af5b24", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 55, "deletions": 42, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -13,9 +13,9 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Symbol};\n \n-use std::fmt::Write;\n+use std::fmt::{self, Write};\n use std::hash::Hash;\n use tracing::debug;\n \n@@ -155,6 +155,29 @@ pub struct DisambiguatedDefPathData {\n     pub disambiguator: u32,\n }\n \n+impl DisambiguatedDefPathData {\n+    pub fn fmt_maybe_verbose(&self, writer: &mut impl Write, verbose: bool) -> fmt::Result {\n+        match self.data.name() {\n+            DefPathDataName::Named(name) => {\n+                if verbose && self.disambiguator != 0 {\n+                    write!(writer, \"{}#{}\", name, self.disambiguator)\n+                } else {\n+                    writer.write_str(&name.as_str())\n+                }\n+            }\n+            DefPathDataName::Anon { namespace } => {\n+                write!(writer, \"{{{}#{}}}\", namespace, self.disambiguator)\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Display for DisambiguatedDefPathData {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.fmt_maybe_verbose(f, true)\n+    }\n+}\n+\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct DefPath {\n     /// The path leading from the crate root to the item.\n@@ -198,33 +221,11 @@ impl DefPath {\n     /// Returns a string representation of the `DefPath` without\n     /// the crate-prefix. This method is useful if you don't have\n     /// a `TyCtxt` available.\n-    pub fn to_string_no_crate(&self) -> String {\n+    pub fn to_string_no_crate_verbose(&self) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n         for component in &self.data {\n-            write!(s, \"::{}[{}]\", component.data.as_symbol(), component.disambiguator).unwrap();\n-        }\n-\n-        s\n-    }\n-\n-    /// Returns a filename-friendly string for the `DefPath`, with the\n-    /// crate-prefix.\n-    pub fn to_string_friendly<F>(&self, crate_imported_name: F) -> String\n-    where\n-        F: FnOnce(CrateNum) -> Symbol,\n-    {\n-        let crate_name_str = crate_imported_name(self.krate).as_str();\n-        let mut s = String::with_capacity(crate_name_str.len() + self.data.len() * 16);\n-\n-        write!(s, \"::{}\", crate_name_str).unwrap();\n-\n-        for component in &self.data {\n-            if component.disambiguator == 0 {\n-                write!(s, \"::{}\", component.data.as_symbol()).unwrap();\n-            } else {\n-                write!(s, \"{}[{}]\", component.data.as_symbol(), component.disambiguator).unwrap();\n-            }\n+            write!(s, \"::{}\", component).unwrap();\n         }\n \n         s\n@@ -240,12 +241,9 @@ impl DefPath {\n         for component in &self.data {\n             s.extend(opt_delimiter);\n             opt_delimiter = Some('-');\n-            if component.disambiguator == 0 {\n-                write!(s, \"{}\", component.data.as_symbol()).unwrap();\n-            } else {\n-                write!(s, \"{}[{}]\", component.data.as_symbol(), component.disambiguator).unwrap();\n-            }\n+            write!(s, \"{}\", component).unwrap();\n         }\n+\n         s\n     }\n }\n@@ -313,6 +311,7 @@ impl Definitions {\n     }\n \n     #[inline]\n+    #[track_caller]\n     pub fn local_def_id_to_hir_id(&self, id: LocalDefId) -> hir::HirId {\n         self.def_id_to_hir_id[id].unwrap()\n     }\n@@ -426,6 +425,12 @@ impl Definitions {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum DefPathDataName {\n+    Named(Symbol),\n+    Anon { namespace: Symbol },\n+}\n+\n impl DefPathData {\n     pub fn get_opt_name(&self) -> Option<Symbol> {\n         use self::DefPathData::*;\n@@ -436,22 +441,30 @@ impl DefPathData {\n         }\n     }\n \n-    pub fn as_symbol(&self) -> Symbol {\n+    pub fn name(&self) -> DefPathDataName {\n         use self::DefPathData::*;\n         match *self {\n-            TypeNs(name) | ValueNs(name) | MacroNs(name) | LifetimeNs(name) => name,\n+            TypeNs(name) | ValueNs(name) | MacroNs(name) | LifetimeNs(name) => {\n+                DefPathDataName::Named(name)\n+            }\n             // Note that this does not show up in user print-outs.\n-            CrateRoot => sym::double_braced_crate,\n-            Impl => sym::double_braced_impl,\n-            Misc => sym::double_braced_misc,\n-            ClosureExpr => sym::double_braced_closure,\n-            Ctor => sym::double_braced_constructor,\n-            AnonConst => sym::double_braced_constant,\n-            ImplTrait => sym::double_braced_opaque,\n+            CrateRoot => DefPathDataName::Anon { namespace: kw::Crate },\n+            Impl => DefPathDataName::Anon { namespace: kw::Impl },\n+            Misc => DefPathDataName::Anon { namespace: sym::misc },\n+            ClosureExpr => DefPathDataName::Anon { namespace: sym::closure },\n+            Ctor => DefPathDataName::Anon { namespace: sym::constructor },\n+            AnonConst => DefPathDataName::Anon { namespace: sym::constant },\n+            ImplTrait => DefPathDataName::Anon { namespace: sym::opaque },\n         }\n     }\n+}\n \n-    pub fn to_string(&self) -> String {\n-        self.as_symbol().to_string()\n+impl fmt::Display for DefPathData {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.name() {\n+            DefPathDataName::Named(name) => f.write_str(&name.as_str()),\n+            // FIXME(#70334): this will generate legacy {{closure}}, {{impl}}, etc\n+            DefPathDataName::Anon { namespace } => write!(f, \"{{{{{}}}}}\", namespace),\n+        }\n     }\n }"}, {"sha": "636f67a77c890a4035373c58d5550110d106948c", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -2004,6 +2004,30 @@ pub enum PrimTy {\n     Char,\n }\n \n+impl PrimTy {\n+    pub fn name_str(self) -> &'static str {\n+        match self {\n+            PrimTy::Int(i) => i.name_str(),\n+            PrimTy::Uint(u) => u.name_str(),\n+            PrimTy::Float(f) => f.name_str(),\n+            PrimTy::Str => \"str\",\n+            PrimTy::Bool => \"bool\",\n+            PrimTy::Char => \"char\",\n+        }\n+    }\n+\n+    pub fn name(self) -> Symbol {\n+        match self {\n+            PrimTy::Int(i) => i.name(),\n+            PrimTy::Uint(u) => u.name(),\n+            PrimTy::Float(f) => f.name(),\n+            PrimTy::Str => sym::str,\n+            PrimTy::Bool => sym::bool,\n+            PrimTy::Char => sym::char,\n+        }\n+    }\n+}\n+\n #[derive(Debug, HashStable_Generic)]\n pub struct BareFnTy<'hir> {\n     pub unsafety: Unsafety,"}, {"sha": "820d664c07d924eda931c4a8f0859a6b621162a4", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -256,7 +256,6 @@ pub trait Visitor<'v>: Sized {\n     /// patterns described on `itemlikevisit::ItemLikeVisitor`. The only\n     /// reason to override this method is if you want a nested pattern\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n-    #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n         let opt_item = self.nested_visit_map().inter().map(|map| map.item(id.id));\n         walk_list!(self, visit_item, opt_item);\n@@ -265,7 +264,6 @@ pub trait Visitor<'v>: Sized {\n     /// Like `visit_nested_item()`, but for trait items. See\n     /// `visit_nested_item()` for advice on when to override this\n     /// method.\n-    #[allow(unused_variables)]\n     fn visit_nested_trait_item(&mut self, id: TraitItemId) {\n         let opt_item = self.nested_visit_map().inter().map(|map| map.trait_item(id));\n         walk_list!(self, visit_trait_item, opt_item);\n@@ -274,7 +272,6 @@ pub trait Visitor<'v>: Sized {\n     /// Like `visit_nested_item()`, but for impl items. See\n     /// `visit_nested_item()` for advice on when to override this\n     /// method.\n-    #[allow(unused_variables)]\n     fn visit_nested_impl_item(&mut self, id: ImplItemId) {\n         let opt_item = self.nested_visit_map().inter().map(|map| map.impl_item(id));\n         walk_list!(self, visit_impl_item, opt_item);"}, {"sha": "9d931b3a9e1e561cff533c98b91c0e6ca220c852", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -2,6 +2,7 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n \n+#![feature(array_value_iter)]\n #![feature(crate_visibility_modifier)]\n #![feature(const_fn)] // For the unsizing cast on `&[]`\n #![feature(const_panic)]"}, {"sha": "fd6a312ef3af967cfc8ba2953f39fa5758d13576", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -9,13 +9,13 @@ use crate::{Item, ItemKind, TraitItem, TraitItemKind};\n \n use std::fmt::{self, Display};\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum MethodKind {\n     Trait { body: bool },\n     Inherent,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Target {\n     ExternCrate,\n     Use,"}, {"sha": "a80c4be3e93352aeca28814bbc463a6ae977a301", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,6 +1,6 @@\n //! Support for serializing the dep-graph and reloading it.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]"}, {"sha": "6e1471df195b1a9b002880c056fcf85233ee759e", "filename": "compiler/rustc_index/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -8,6 +8,6 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n-arrayvec = \"0.5.1\"\n+arrayvec = { version = \"0.5.1\", default-features = false }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "8e00e54650df0405269a9671bdd3572c22df64f2", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -28,13 +28,20 @@ pub const WORD_BITS: usize = WORD_BYTES * 8;\n /// will panic if the bitsets have differing domain sizes.\n ///\n /// [`GrowableBitSet`]: struct.GrowableBitSet.html\n-#[derive(Clone, Eq, PartialEq, Decodable, Encodable)]\n-pub struct BitSet<T: Idx> {\n+#[derive(Eq, PartialEq, Decodable, Encodable)]\n+pub struct BitSet<T> {\n     domain_size: usize,\n     words: Vec<Word>,\n     marker: PhantomData<T>,\n }\n \n+impl<T> BitSet<T> {\n+    /// Gets the domain size.\n+    pub fn domain_size(&self) -> usize {\n+        self.domain_size\n+    }\n+}\n+\n impl<T: Idx> BitSet<T> {\n     /// Creates a new, empty bitset with a given `domain_size`.\n     #[inline]\n@@ -52,11 +59,6 @@ impl<T: Idx> BitSet<T> {\n         result\n     }\n \n-    /// Gets the domain size.\n-    pub fn domain_size(&self) -> usize {\n-        self.domain_size\n-    }\n-\n     /// Clear all elements.\n     #[inline]\n     pub fn clear(&mut self) {\n@@ -75,12 +77,6 @@ impl<T: Idx> BitSet<T> {\n         }\n     }\n \n-    /// Efficiently overwrite `self` with `other`.\n-    pub fn overwrite(&mut self, other: &BitSet<T>) {\n-        assert!(self.domain_size == other.domain_size);\n-        self.words.clone_from_slice(&other.words);\n-    }\n-\n     /// Count the number of set bits in the set.\n     pub fn count(&self) -> usize {\n         self.words.iter().map(|e| e.count_ones() as usize).sum()\n@@ -243,6 +239,21 @@ impl<T: Idx> SubtractFromBitSet<T> for BitSet<T> {\n     }\n }\n \n+impl<T> Clone for BitSet<T> {\n+    fn clone(&self) -> Self {\n+        BitSet { domain_size: self.domain_size, words: self.words.clone(), marker: PhantomData }\n+    }\n+\n+    fn clone_from(&mut self, from: &Self) {\n+        if self.domain_size != from.domain_size {\n+            self.words.resize(from.domain_size, 0);\n+            self.domain_size = from.domain_size;\n+        }\n+\n+        self.words.copy_from_slice(&from.words);\n+    }\n+}\n+\n impl<T: Idx> fmt::Debug for BitSet<T> {\n     fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n         w.debug_list().entries(self.iter()).finish()\n@@ -363,7 +374,7 @@ const SPARSE_MAX: usize = 8;\n ///\n /// This type is used by `HybridBitSet`; do not use directly.\n #[derive(Clone, Debug)]\n-pub struct SparseBitSet<T: Idx> {\n+pub struct SparseBitSet<T> {\n     domain_size: usize,\n     elems: ArrayVec<[T; SPARSE_MAX]>,\n }\n@@ -464,18 +475,27 @@ impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n /// All operations that involve an element will panic if the element is equal\n /// to or greater than the domain size. All operations that involve two bitsets\n /// will panic if the bitsets have differing domain sizes.\n-#[derive(Clone, Debug)]\n-pub enum HybridBitSet<T: Idx> {\n+#[derive(Clone)]\n+pub enum HybridBitSet<T> {\n     Sparse(SparseBitSet<T>),\n     Dense(BitSet<T>),\n }\n \n+impl<T: Idx> fmt::Debug for HybridBitSet<T> {\n+    fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Sparse(b) => b.fmt(w),\n+            Self::Dense(b) => b.fmt(w),\n+        }\n+    }\n+}\n+\n impl<T: Idx> HybridBitSet<T> {\n     pub fn new_empty(domain_size: usize) -> Self {\n         HybridBitSet::Sparse(SparseBitSet::new_empty(domain_size))\n     }\n \n-    fn domain_size(&self) -> usize {\n+    pub fn domain_size(&self) -> usize {\n         match self {\n             HybridBitSet::Sparse(sparse) => sparse.domain_size,\n             HybridBitSet::Dense(dense) => dense.domain_size,"}, {"sha": "6a1715ef8189992e1b6742cda5c1bd72b34fbee4", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 243, "deletions": 13, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -35,14 +35,15 @@ use super::{InferCtxt, MiscVariable, TypeTrace};\n use crate::traits::{Obligation, PredicateObligations};\n \n use rustc_ast as ast;\n+use rustc_data_structures::sso::SsoHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{IntType, UintType};\n-use rustc_span::DUMMY_SP;\n+use rustc_span::{Span, DUMMY_SP};\n \n #[derive(Clone)]\n pub struct CombineFields<'infcx, 'tcx> {\n@@ -159,11 +160,11 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             }\n \n             (ty::ConstKind::Infer(InferConst::Var(vid)), _) => {\n-                return self.unify_const_variable(a_is_expected, vid, b);\n+                return self.unify_const_variable(relation.param_env(), vid, b, a_is_expected);\n             }\n \n             (_, ty::ConstKind::Infer(InferConst::Var(vid))) => {\n-                return self.unify_const_variable(!a_is_expected, vid, a);\n+                return self.unify_const_variable(relation.param_env(), vid, a, !a_is_expected);\n             }\n             (ty::ConstKind::Unevaluated(..), _) if self.tcx.lazy_normalization() => {\n                 // FIXME(#59490): Need to remove the leak check to accommodate\n@@ -187,17 +188,66 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         ty::relate::super_relate_consts(relation, a, b)\n     }\n \n-    pub fn unify_const_variable(\n+    /// Unifies the const variable `target_vid` with the given constant.\n+    ///\n+    /// This also tests if the given const `ct` contains an inference variable which was previously\n+    /// unioned with `target_vid`. If this is the case, inferring `target_vid` to `ct`\n+    /// would result in an infinite type as we continously replace an inference variable\n+    /// in `ct` with `ct` itself.\n+    ///\n+    /// This is especially important as unevaluated consts use their parents generics.\n+    /// They therefore often contain unused substs, making these errors far more likely.\n+    ///\n+    /// A good example of this is the following:\n+    ///\n+    /// ```rust\n+    /// #![feature(const_generics)]\n+    ///\n+    /// fn bind<const N: usize>(value: [u8; N]) -> [u8; 3 + 4] {\n+    ///     todo!()\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let mut arr = Default::default();\n+    ///     arr = bind(arr);\n+    /// }\n+    /// ```\n+    ///\n+    /// Here `3 + 4` ends up as `ConstKind::Unevaluated` which uses the generics\n+    /// of `fn bind` (meaning that its substs contain `N`).\n+    ///\n+    /// `bind(arr)` now infers that the type of `arr` must be `[u8; N]`.\n+    /// The assignment `arr = bind(arr)` now tries to equate `N` with `3 + 4`.\n+    ///\n+    /// As `3 + 4` contains `N` in its substs, this must not succeed.\n+    ///\n+    /// See `src/test/ui/const-generics/occurs-check/` for more examples where this is relevant.\n+    fn unify_const_variable(\n         &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        target_vid: ty::ConstVid<'tcx>,\n+        ct: &'tcx ty::Const<'tcx>,\n         vid_is_expected: bool,\n-        vid: ty::ConstVid<'tcx>,\n-        value: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        let (for_universe, span) = {\n+            let mut inner = self.inner.borrow_mut();\n+            let variable_table = &mut inner.const_unification_table();\n+            let var_value = variable_table.probe_value(target_vid);\n+            match var_value.val {\n+                ConstVariableValue::Known { value } => {\n+                    bug!(\"instantiating {:?} which has a known value {:?}\", target_vid, value)\n+                }\n+                ConstVariableValue::Unknown { universe } => (universe, var_value.origin.span),\n+            }\n+        };\n+        let value = ConstInferUnifier { infcx: self, span, param_env, for_universe, target_vid }\n+            .relate(ct, ct)?;\n+\n         self.inner\n             .borrow_mut()\n             .const_unification_table()\n             .unify_var_value(\n-                vid,\n+                target_vid,\n                 ConstVarValue {\n                     origin: ConstVariableOrigin {\n                         kind: ConstVariableOriginKind::ConstInference,\n@@ -206,8 +256,8 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n                     val: ConstVariableValue::Known { value },\n                 },\n             )\n-            .map_err(|e| const_unification_error(vid_is_expected, e))?;\n-        Ok(value)\n+            .map(|()| value)\n+            .map_err(|e| const_unification_error(vid_is_expected, e))\n     }\n \n     fn unify_integral_variable(\n@@ -362,7 +412,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n \n         let for_universe = match self.infcx.inner.borrow_mut().type_variables().probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n-                panic!(\"instantiating {:?} which has a known value {:?}\", for_vid, v,)\n+                bug!(\"instantiating {:?} which has a known value {:?}\", for_vid, v,)\n             }\n             TypeVariableValue::Unknown { universe } => universe,\n         };\n@@ -379,6 +429,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             needs_wf: false,\n             root_ty: ty,\n             param_env: self.param_env,\n+            cache: SsoHashMap::new(),\n         };\n \n         let ty = match generalize.relate(ty, ty) {\n@@ -438,6 +489,8 @@ struct Generalizer<'cx, 'tcx> {\n     root_ty: Ty<'tcx>,\n \n     param_env: ty::ParamEnv<'tcx>,\n+\n+    cache: SsoHashMap<Ty<'tcx>, RelateResult<'tcx, Ty<'tcx>>>,\n }\n \n /// Result from a generalization operation. This includes\n@@ -535,13 +588,16 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         assert_eq!(t, t2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n+        if let Some(result) = self.cache.get(&t) {\n+            return result.clone();\n+        }\n         debug!(\"generalize: t={:?}\", t);\n \n         // Check to see whether the type we are generalizing references\n         // any other type variable related to `vid` via\n         // subtyping. This is basically our \"occurs check\", preventing\n         // us from creating infinitely sized types.\n-        match *t.kind() {\n+        let result = match *t.kind() {\n             ty::Infer(ty::TyVar(vid)) => {\n                 let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n                 let sub_vid = self.infcx.inner.borrow_mut().type_variables().sub_root_var(vid);\n@@ -598,7 +654,10 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 Ok(t)\n             }\n             _ => relate::super_relate_tys(self, t, t),\n-        }\n+        };\n+\n+        self.cache.insert(t, result.clone());\n+        return result;\n     }\n \n     fn regions(\n@@ -671,7 +730,6 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     }\n                 }\n             }\n-            ty::ConstKind::Unevaluated(..) if self.tcx().lazy_normalization() => Ok(c),\n             _ => relate::super_relate_consts(self, c, c),\n         }\n     }\n@@ -721,3 +779,175 @@ fn float_unification_error<'tcx>(\n     let (ty::FloatVarValue(a), ty::FloatVarValue(b)) = v;\n     TypeError::FloatMismatch(ty::relate::expected_found_bool(a_is_expected, a, b))\n }\n+\n+struct ConstInferUnifier<'cx, 'tcx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+\n+    span: Span,\n+\n+    param_env: ty::ParamEnv<'tcx>,\n+\n+    for_universe: ty::UniverseIndex,\n+\n+    /// The vid of the const variable that is in the process of being\n+    /// instantiated; if we find this within the const we are folding,\n+    /// that means we would have created a cyclic const.\n+    target_vid: ty::ConstVid<'tcx>,\n+}\n+\n+// We use `TypeRelation` here to propagate `RelateResult` upwards.\n+//\n+// Both inputs are expected to be the same.\n+impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"ConstInferUnifier\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _variance: ty::Variance,\n+        a: T,\n+        b: T,\n+    ) -> RelateResult<'tcx, T> {\n+        // We don't care about variance here.\n+        self.relate(a, b)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+    }\n+\n+    fn tys(&mut self, t: Ty<'tcx>, _t: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug_assert_eq!(t, _t);\n+        debug!(\"ConstInferUnifier: t={:?}\", t);\n+\n+        match t.kind() {\n+            &ty::Infer(ty::TyVar(vid)) => {\n+                let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n+                let probe = self.infcx.inner.borrow_mut().type_variables().probe(vid);\n+                match probe {\n+                    TypeVariableValue::Known { value: u } => {\n+                        debug!(\"ConstOccursChecker: known value {:?}\", u);\n+                        self.tys(u, u)\n+                    }\n+                    TypeVariableValue::Unknown { universe } => {\n+                        if self.for_universe.can_name(universe) {\n+                            return Ok(t);\n+                        }\n+\n+                        let origin =\n+                            *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n+                        let new_var_id = self.infcx.inner.borrow_mut().type_variables().new_var(\n+                            self.for_universe,\n+                            false,\n+                            origin,\n+                        );\n+                        let u = self.tcx().mk_ty_var(new_var_id);\n+                        debug!(\n+                            \"ConstInferUnifier: replacing original vid={:?} with new={:?}\",\n+                            vid, u\n+                        );\n+                        Ok(u)\n+                    }\n+                }\n+            }\n+            _ => relate::super_relate_tys(self, t, t),\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        r: ty::Region<'tcx>,\n+        _r: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug_assert_eq!(r, _r);\n+        debug!(\"ConstInferUnifier: r={:?}\", r);\n+\n+        match r {\n+            // Never make variables for regions bound within the type itself,\n+            // nor for erased regions.\n+            ty::ReLateBound(..) | ty::ReErased => {\n+                return Ok(r);\n+            }\n+\n+            ty::RePlaceholder(..)\n+            | ty::ReVar(..)\n+            | ty::ReEmpty(_)\n+            | ty::ReStatic\n+            | ty::ReEarlyBound(..)\n+            | ty::ReFree(..) => {\n+                // see common code below\n+            }\n+        }\n+\n+        let r_universe = self.infcx.universe_of_region(r);\n+        if self.for_universe.can_name(r_universe) {\n+            return Ok(r);\n+        } else {\n+            // FIXME: This is non-ideal because we don't give a\n+            // very descriptive origin for this region variable.\n+            Ok(self.infcx.next_region_var_in_universe(MiscVariable(self.span), self.for_universe))\n+        }\n+    }\n+\n+    fn consts(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+        _c: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug_assert_eq!(c, _c);\n+        debug!(\"ConstInferUnifier: c={:?}\", c);\n+\n+        match c.val {\n+            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let variable_table = &mut inner.const_unification_table();\n+\n+                // Check if the current unification would end up\n+                // unifying `target_vid` with a const which contains\n+                // an inference variable which is unioned with `target_vid`.\n+                //\n+                // Not doing so can easily result in stack overflows.\n+                if variable_table.unioned(self.target_vid, vid) {\n+                    return Err(TypeError::CyclicConst(c));\n+                }\n+\n+                let var_value = variable_table.probe_value(vid);\n+                match var_value.val {\n+                    ConstVariableValue::Known { value: u } => self.consts(u, u),\n+                    ConstVariableValue::Unknown { universe } => {\n+                        if self.for_universe.can_name(universe) {\n+                            Ok(c)\n+                        } else {\n+                            let new_var_id = variable_table.new_key(ConstVarValue {\n+                                origin: var_value.origin,\n+                                val: ConstVariableValue::Unknown { universe: self.for_universe },\n+                            });\n+                            Ok(self.tcx().mk_const_var(new_var_id, c.ty))\n+                        }\n+                    }\n+                }\n+            }\n+            _ => relate::super_relate_consts(self, c, c),\n+        }\n+    }\n+}"}, {"sha": "795c5a64d26b72e44b6b1c2d15dbed318f907b14", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -70,7 +70,7 @@ use rustc_middle::ty::{\n     subst::{Subst, SubstsRef},\n     Region, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{DesugaringKind, Pos, Span};\n+use rustc_span::{BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::{cmp, fmt};\n \n@@ -531,7 +531,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 disambiguated_data: &DisambiguatedDefPathData,\n             ) -> Result<Self::Path, Self::Error> {\n                 let mut path = print_prefix(self)?;\n-                path.push(disambiguated_data.data.as_symbol().to_string());\n+                path.push(disambiguated_data.to_string());\n                 Ok(path)\n             }\n             fn path_generic_args(\n@@ -617,11 +617,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ref prior_arms,\n                 last_ty,\n                 scrut_hir_id,\n+                opt_suggest_box_span,\n+                arm_span,\n                 ..\n             }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arms have incompatible types\";\n                     err.span_label(cause.span, msg);\n+                    if let Some(ret_sp) = opt_suggest_box_span {\n+                        self.suggest_boxing_for_return_impl_trait(\n+                            err,\n+                            ret_sp,\n+                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n+                        );\n+                    }\n                 }\n                 hir::MatchSource::TryDesugar => {\n                     if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n@@ -675,9 +684,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     }\n+                    if let Some(ret_sp) = opt_suggest_box_span {\n+                        // Get return type span and point to it.\n+                        self.suggest_boxing_for_return_impl_trait(\n+                            err,\n+                            ret_sp,\n+                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n+                        );\n+                    }\n                 }\n             },\n-            ObligationCauseCode::IfExpression(box IfExpressionCause { then, outer, semicolon }) => {\n+            ObligationCauseCode::IfExpression(box IfExpressionCause {\n+                then,\n+                else_sp,\n+                outer,\n+                semicolon,\n+                opt_suggest_box_span,\n+            }) => {\n                 err.span_label(then, \"expected because of this\");\n                 if let Some(sp) = outer {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n@@ -690,11 +713,48 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         Applicability::MachineApplicable,\n                     );\n                 }\n+                if let Some(ret_sp) = opt_suggest_box_span {\n+                    self.suggest_boxing_for_return_impl_trait(\n+                        err,\n+                        ret_sp,\n+                        vec![then, else_sp].into_iter(),\n+                    );\n+                }\n             }\n             _ => (),\n         }\n     }\n \n+    fn suggest_boxing_for_return_impl_trait(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        return_sp: Span,\n+        arm_spans: impl Iterator<Item = Span>,\n+    ) {\n+        err.multipart_suggestion(\n+            \"you could change the return type to be a boxed trait object\",\n+            vec![\n+                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n+                (return_sp.shrink_to_hi(), \">\".to_string()),\n+            ],\n+            Applicability::MaybeIncorrect,\n+        );\n+        let sugg = arm_spans\n+            .flat_map(|sp| {\n+                vec![\n+                    (sp.shrink_to_lo(), \"Box::new(\".to_string()),\n+                    (sp.shrink_to_hi(), \")\".to_string()),\n+                ]\n+                .into_iter()\n+            })\n+            .collect::<Vec<_>>();\n+        err.multipart_suggestion(\n+            \"if you change the return type to expect trait objects, box the returned expressions\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// Given that `other_ty` is the same as a type argument for `name` in `sub`, populate `value`\n     /// highlighting `name` and every type argument that isn't at `pos` (which is `other_ty`), and\n     /// populate `other_value` with `other_ty`.\n@@ -2093,7 +2153,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 _ => String::new(),\n             };\n             if !s.is_empty() {\n-                s.push_str(\" \");\n+                s.push(' ');\n             }\n             s\n         };"}, {"sha": "2f3089f1a92c10d9e7c9b5ad40c03e5cb16c2868", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 176, "deletions": 92, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -6,9 +6,10 @@ use rustc_hir::def::{DefKind, Namespace};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, Pat};\n use rustc_middle::hir::map::Map;\n+use rustc_middle::infer::unify_key::ConstVariableOriginKind;\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_middle::ty::{self, DefIdTree, InferConst, Ty};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n@@ -175,7 +176,10 @@ fn closure_return_type_suggestion(\n         suggestion,\n         Applicability::HasPlaceholders,\n     );\n-    err.span_label(span, InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr));\n+    err.span_label(\n+        span,\n+        InferCtxt::cannot_infer_msg(\"type\", &name, &descr, parent_name, parent_descr),\n+    );\n }\n \n /// Given a closure signature, return a `String` containing a list of all its argument types.\n@@ -216,65 +220,151 @@ impl Into<rustc_errors::DiagnosticId> for TypeAnnotationNeeded {\n     }\n }\n \n+/// Information about a constant or a type containing inference variables.\n+pub struct InferenceDiagnosticsData {\n+    pub name: String,\n+    pub span: Option<Span>,\n+    pub description: Cow<'static, str>,\n+    pub parent_name: Option<String>,\n+    pub parent_description: Option<&'static str>,\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn extract_type_name(\n+    /// Extracts data used by diagnostic for either types or constants\n+    /// which were stuck during inference.\n+    pub fn extract_inference_diagnostics_data(\n         &self,\n-        ty: Ty<'tcx>,\n+        arg: GenericArg<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n-    ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n-        if let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind() {\n-            let mut inner = self.inner.borrow_mut();\n-            let ty_vars = &inner.type_variables();\n-            let var_origin = ty_vars.var_origin(ty_vid);\n-            if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) = var_origin.kind {\n-                let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n-                let (parent_name, parent_desc) = if let Some(parent_def_id) = parent_def_id {\n-                    let parent_name = self\n-                        .tcx\n-                        .def_key(parent_def_id)\n-                        .disambiguated_data\n-                        .data\n-                        .get_opt_name()\n-                        .map(|parent_symbol| parent_symbol.to_string());\n-\n-                    (parent_name, Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)))\n-                } else {\n-                    (None, None)\n-                };\n+    ) -> InferenceDiagnosticsData {\n+        match arg.unpack() {\n+            GenericArgKind::Type(ty) => {\n+                if let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind() {\n+                    let mut inner = self.inner.borrow_mut();\n+                    let ty_vars = &inner.type_variables();\n+                    let var_origin = ty_vars.var_origin(ty_vid);\n+                    if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) =\n+                        var_origin.kind\n+                    {\n+                        let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n+                        let (parent_name, parent_description) =\n+                            if let Some(parent_def_id) = parent_def_id {\n+                                let parent_name = self\n+                                    .tcx\n+                                    .def_key(parent_def_id)\n+                                    .disambiguated_data\n+                                    .data\n+                                    .get_opt_name()\n+                                    .map(|parent_symbol| parent_symbol.to_string());\n+\n+                                (\n+                                    parent_name,\n+                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n+                                )\n+                            } else {\n+                                (None, None)\n+                            };\n+\n+                        if name != kw::SelfUpper {\n+                            return InferenceDiagnosticsData {\n+                                name: name.to_string(),\n+                                span: Some(var_origin.span),\n+                                description: \"type parameter\".into(),\n+                                parent_name,\n+                                parent_description,\n+                            };\n+                        }\n+                    }\n+                }\n \n-                if name != kw::SelfUpper {\n-                    return (\n-                        name.to_string(),\n-                        Some(var_origin.span),\n-                        \"type parameter\".into(),\n-                        parent_name,\n-                        parent_desc,\n-                    );\n+                let mut s = String::new();\n+                let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n+                if let Some(highlight) = highlight {\n+                    printer.region_highlight_mode = highlight;\n+                }\n+                let _ = ty.print(printer);\n+                InferenceDiagnosticsData {\n+                    name: s,\n+                    span: None,\n+                    description: ty.prefix_string(),\n+                    parent_name: None,\n+                    parent_description: None,\n                 }\n             }\n-        }\n+            GenericArgKind::Const(ct) => {\n+                if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val {\n+                    let origin =\n+                        self.inner.borrow_mut().const_unification_table().probe_value(vid).origin;\n+                    if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n+                        origin.kind\n+                    {\n+                        let parent_def_id = self.tcx.parent(def_id);\n+                        let (parent_name, parent_description) =\n+                            if let Some(parent_def_id) = parent_def_id {\n+                                let parent_name = self\n+                                    .tcx\n+                                    .def_key(parent_def_id)\n+                                    .disambiguated_data\n+                                    .data\n+                                    .get_opt_name()\n+                                    .map(|parent_symbol| parent_symbol.to_string());\n+\n+                                (\n+                                    parent_name,\n+                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n+                                )\n+                            } else {\n+                                (None, None)\n+                            };\n+\n+                        return InferenceDiagnosticsData {\n+                            name: name.to_string(),\n+                            span: Some(origin.span),\n+                            description: \"const parameter\".into(),\n+                            parent_name,\n+                            parent_description,\n+                        };\n+                    }\n \n-        let mut s = String::new();\n-        let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n-        if let Some(highlight) = highlight {\n-            printer.region_highlight_mode = highlight;\n+                    debug_assert!(!origin.span.is_dummy());\n+                    let mut s = String::new();\n+                    let mut printer =\n+                        ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::ValueNS);\n+                    if let Some(highlight) = highlight {\n+                        printer.region_highlight_mode = highlight;\n+                    }\n+                    let _ = ct.print(printer);\n+                    InferenceDiagnosticsData {\n+                        name: s,\n+                        span: Some(origin.span),\n+                        description: \"the constant\".into(),\n+                        parent_name: None,\n+                        parent_description: None,\n+                    }\n+                } else {\n+                    bug!(\"unexpect const: {:?}\", ct);\n+                }\n+            }\n+            GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n         }\n-        let _ = ty.print(printer);\n-        (s, None, ty.prefix_string(), None, None)\n     }\n \n-    // FIXME(eddyb) generalize all of this to handle `ty::Const` inference variables as well.\n-    pub fn need_type_info_err(\n+    pub fn emit_inference_failure_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n         span: Span,\n-        ty: Ty<'tcx>,\n+        arg: GenericArg<'tcx>,\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx> {\n-        let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n+        let arg = self.resolve_vars_if_possible(&arg);\n+        let arg_data = self.extract_inference_diagnostics_data(arg, None);\n+        let kind_str = match arg.unpack() {\n+            GenericArgKind::Type(_) => \"type\",\n+            GenericArgKind::Const(_) => \"the value\",\n+            GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n+        };\n \n-        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into(), span);\n+        let mut local_visitor = FindHirNodeVisitor::new(&self, arg, span);\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -304,7 +394,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n         let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n             pattern.span\n-        } else if let Some(span) = name_sp {\n+        } else if let Some(span) = arg_data.span {\n             // `span` here lets us point at `sum` instead of the entire right hand side expr:\n             // error[E0282]: type annotations needed\n             //  --> file2.rs:3:15\n@@ -351,7 +441,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => String::new(),\n         };\n \n-        // When `name` corresponds to a type argument, show the path of the full type we're\n+        // When `arg_data.name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n         // \" in `std::result::Result<i32, E>`\":\n         // ```\n@@ -390,11 +480,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         &mut err,\n                         &decl.output,\n                         self.tcx.hir().body(body_id),\n-                        &descr,\n-                        &name,\n+                        &arg_data.description,\n+                        &arg_data.name,\n                         &ret,\n-                        parent_name,\n-                        parent_descr,\n+                        arg_data.parent_name,\n+                        arg_data.parent_description,\n                     );\n                     // We don't want to give the other suggestions when the problem is the\n                     // closure return type.\n@@ -408,15 +498,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // nudge them in the right direction.\n                 format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && name == \"_\" => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && arg_data.name == \"_\" => {\n                 let ty = ty_to_string(ty);\n                 format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != name => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != arg_data.name => {\n                 let ty = ty_to_string(ty);\n                 format!(\n                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n-                    ty, name,\n+                    ty, arg_data.name,\n                 )\n             }\n             _ => \"a type\".to_string(),\n@@ -533,7 +623,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |               ^^^ cannot infer type for `S`\n         //   |\n         //   = note: type must be known at this point\n-        let span = name_sp.unwrap_or(err_span);\n+        let span = arg_data.span.unwrap_or(err_span);\n         if !err\n             .span\n             .span_labels()\n@@ -544,43 +634,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // Avoid multiple labels pointing at `span`.\n             err.span_label(\n                 span,\n-                InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr),\n+                InferCtxt::cannot_infer_msg(\n+                    kind_str,\n+                    &arg_data.name,\n+                    &arg_data.description,\n+                    arg_data.parent_name,\n+                    arg_data.parent_description,\n+                ),\n             );\n         }\n \n         err\n     }\n \n-    // FIXME(const_generics): We should either try and merge this with `need_type_info_err`\n-    // or improve the errors created here.\n-    //\n-    // Unlike for type inference variables, we don't yet store the origin of const inference variables.\n-    // This is needed for to get a more relevant error span.\n-    pub fn need_type_info_err_const(\n-        &self,\n-        body_id: Option<hir::BodyId>,\n-        span: Span,\n-        ct: &'tcx ty::Const<'tcx>,\n-        error_code: TypeAnnotationNeeded,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let mut local_visitor = FindHirNodeVisitor::new(&self, ct.into(), span);\n-        if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n-            local_visitor.visit_expr(expr);\n-        }\n-\n-        let error_code = error_code.into();\n-        let mut err = self.tcx.sess.struct_span_err_with_code(\n-            local_visitor.target_span,\n-            \"type annotations needed\",\n-            error_code,\n-        );\n-\n-        err.note(\"unable to infer the value of a const parameter\");\n-\n-        err\n-    }\n-\n     /// If the `FnSig` for the method call can be found and type arguments are identified as\n     /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n     fn annotate_method_call(\n@@ -634,7 +700,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, _, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n+        let data = self.extract_inference_diagnostics_data(ty.into(), None);\n \n         let mut err = struct_span_err!(\n             self.tcx.sess,\n@@ -643,18 +709,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"type inside {} must be known in this context\",\n             kind,\n         );\n-        err.span_label(span, InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr));\n+        err.span_label(\n+            span,\n+            InferCtxt::cannot_infer_msg(\n+                \"type\",\n+                &data.name,\n+                &data.description,\n+                data.parent_name,\n+                data.parent_description,\n+            ),\n+        );\n         err\n     }\n \n-    fn missing_type_msg(\n+    fn cannot_infer_msg(\n+        kind_str: &str,\n         type_name: &str,\n         descr: &str,\n         parent_name: Option<String>,\n         parent_descr: Option<&str>,\n-    ) -> Cow<'static, str> {\n+    ) -> String {\n         if type_name == \"_\" {\n-            \"cannot infer type\".into()\n+            format!(\"cannot infer {}\", kind_str)\n         } else {\n             let parent_desc = if let Some(parent_name) = parent_name {\n                 let parent_type_descr = if let Some(parent_descr) = parent_descr {\n@@ -668,7 +744,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 \"\".to_string()\n             };\n \n-            format!(\"cannot infer type for {} `{}`{}\", descr, type_name, parent_desc).into()\n+            // FIXME: We really shouldn't be dealing with strings here\n+            // but instead use a sensible enum for cases like this.\n+            let preposition = if \"the value\" == kind_str { \"of\" } else { \"for\" };\n+            // For example: \"cannot infer type for type parameter `T`\"\n+            format!(\n+                \"cannot infer {} {} {} `{}`{}\",\n+                kind_str, preposition, descr, type_name, parent_desc\n+            )\n+            .into()\n         }\n     }\n }"}, {"sha": "e3c613b1d6a12876cf5066a97d9ec09a7e8d90de", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n                 debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n                 if sub == &ty::ReStatic\n-                    && v.0.into_iter().find(|t| t.span.desugaring_kind().is_none()).is_some()\n+                    && v.0.into_iter().any(|t| t.span.desugaring_kind().is_none())\n                 {\n                     // If the failure is due to a `'static` requirement coming from a `dyn` or\n                     // `impl` Trait that *isn't* caused by `async fn` desugaring, handle this case"}, {"sha": "441cfeea20a48d3a78894264e7d0eaff76dd3d7c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -488,18 +488,16 @@ impl<'tcx> Visitor<'tcx> for HirTraitObjectVisitor {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n-        match t.kind {\n-            TyKind::TraitObject(\n-                poly_trait_refs,\n-                Lifetime { name: LifetimeName::ImplicitObjectLifetimeDefault, .. },\n-            ) => {\n-                for ptr in poly_trait_refs {\n-                    if Some(self.1) == ptr.trait_ref.trait_def_id() {\n-                        self.0.push(ptr.span);\n-                    }\n+        if let TyKind::TraitObject(\n+            poly_trait_refs,\n+            Lifetime { name: LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+        ) = t.kind\n+        {\n+            for ptr in poly_trait_refs {\n+                if Some(self.1) == ptr.trait_ref.trait_def_id() {\n+                    self.0.push(ptr.span);\n                 }\n             }\n-            _ => {}\n         }\n         walk_ty(self, t);\n     }"}, {"sha": "9f43fac0916b5ed865d4219cdbba2212c390fe5b", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -50,7 +50,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n             // FIXME(#41044) -- not correct, need test\n-            ty::Bivariant => Ok(a.clone()),\n+            ty::Bivariant => Ok(a),\n             ty::Contravariant => self.fields.glb(self.a_is_expected).relate(a, b),\n         }\n     }"}, {"sha": "07a55c7f859c34f08dc6ee173edebbf92550baf0", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::ConstEvalResult;\n+use rustc_middle::mir::interpret::EvalToConstValueResult;\n use rustc_middle::traits::select;\n use rustc_middle::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n@@ -1163,7 +1163,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             GenericParamDefKind::Const { .. } => {\n                 let origin = ConstVariableOrigin {\n-                    kind: ConstVariableOriginKind::ConstParameterDefinition(param.name),\n+                    kind: ConstVariableOriginKind::ConstParameterDefinition(\n+                        param.name,\n+                        param.def_id,\n+                    ),\n                     span,\n                 };\n                 let const_var_id =\n@@ -1275,7 +1278,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Gives temporary access to the region constraint data.\n-    #[allow(non_camel_case_types)] // bug with impl trait\n     pub fn with_region_constraints<R>(\n         &self,\n         op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n@@ -1542,7 +1544,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         promoted: Option<mir::Promoted>,\n         span: Option<Span>,\n-    ) -> ConstEvalResult<'tcx> {\n+    ) -> EvalToConstValueResult<'tcx> {\n         let mut original_values = OriginalQueryValues::default();\n         let canonical = self.canonicalize_query(&(param_env, substs), &mut original_values);\n "}, {"sha": "de98cccf25689db74a4f1e78c91cde3dc50cee0a", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -26,7 +26,8 @@ pub fn explicit_outlives_bounds<'tcx>(\n             | ty::PredicateAtom::ClosureKind(..)\n             | ty::PredicateAtom::TypeOutlives(..)\n             | ty::PredicateAtom::ConstEvaluatable(..)\n-            | ty::PredicateAtom::ConstEquate(..) => None,\n+            | ty::PredicateAtom::ConstEquate(..)\n+            | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n             ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n                 Some(OutlivesBound::RegionSubRegion(r_b, r_a))\n             }"}, {"sha": "07924298c241bc67adcbfcf64836c917df347a4f", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,6 +1,7 @@\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::{GenericKind, VerifyBound};\n use rustc_data_structures::captures::Captures;\n+use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -31,16 +32,23 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// Returns a \"verify bound\" that encodes what we know about\n     /// `generic` and the regions it outlives.\n     pub fn generic_bound(&self, generic: GenericKind<'tcx>) -> VerifyBound<'tcx> {\n+        let mut visited = SsoHashSet::new();\n         match generic {\n             GenericKind::Param(param_ty) => self.param_bound(param_ty),\n-            GenericKind::Projection(projection_ty) => self.projection_bound(projection_ty),\n+            GenericKind::Projection(projection_ty) => {\n+                self.projection_bound(projection_ty, &mut visited)\n+            }\n         }\n     }\n \n-    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+    fn type_bound(\n+        &self,\n+        ty: Ty<'tcx>,\n+        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n         match *ty.kind() {\n             ty::Param(p) => self.param_bound(p),\n-            ty::Projection(data) => self.projection_bound(data),\n+            ty::Projection(data) => self.projection_bound(data, visited),\n             ty::FnDef(_, substs) => {\n                 // HACK(eddyb) ignore lifetimes found shallowly in `substs`.\n                 // This is inconsistent with `ty::Adt` (including all substs),\n@@ -50,9 +58,9 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                 let mut bounds = substs\n                     .iter()\n                     .filter_map(|child| match child.unpack() {\n-                        GenericArgKind::Type(ty) => Some(self.type_bound(ty)),\n+                        GenericArgKind::Type(ty) => Some(self.type_bound(ty, visited)),\n                         GenericArgKind::Lifetime(_) => None,\n-                        GenericArgKind::Const(_) => Some(self.recursive_bound(child)),\n+                        GenericArgKind::Const(_) => Some(self.recursive_bound(child, visited)),\n                     })\n                     .filter(|bound| {\n                         // Remove bounds that must hold, since they are not interesting.\n@@ -66,7 +74,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                     ),\n                 }\n             }\n-            _ => self.recursive_bound(ty.into()),\n+            _ => self.recursive_bound(ty.into(), visited),\n         }\n     }\n \n@@ -137,7 +145,11 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         self.declared_projection_bounds_from_trait(projection_ty)\n     }\n \n-    pub fn projection_bound(&self, projection_ty: ty::ProjectionTy<'tcx>) -> VerifyBound<'tcx> {\n+    pub fn projection_bound(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n         debug!(\"projection_bound(projection_ty={:?})\", projection_ty);\n \n         let projection_ty_as_ty =\n@@ -166,21 +178,25 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n \n         // see the extensive comment in projection_must_outlive\n         let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_bound(ty.into());\n+        let recursive_bound = self.recursive_bound(ty.into(), visited);\n \n         VerifyBound::AnyBound(env_bounds.chain(trait_bounds).collect()).or(recursive_bound)\n     }\n \n-    fn recursive_bound(&self, parent: GenericArg<'tcx>) -> VerifyBound<'tcx> {\n+    fn recursive_bound(\n+        &self,\n+        parent: GenericArg<'tcx>,\n+        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n         let mut bounds = parent\n-            .walk_shallow()\n+            .walk_shallow(visited)\n             .filter_map(|child| match child.unpack() {\n-                GenericArgKind::Type(ty) => Some(self.type_bound(ty)),\n+                GenericArgKind::Type(ty) => Some(self.type_bound(ty, visited)),\n                 GenericArgKind::Lifetime(lt) => {\n                     // Ignore late-bound regions.\n                     if !lt.is_late_bound() { Some(VerifyBound::OutlivedBy(lt)) } else { None }\n                 }\n-                GenericArgKind::Const(_) => Some(self.recursive_bound(child)),\n+                GenericArgKind::Const(_) => Some(self.recursive_bound(child, visited)),\n             })\n             .filter(|bound| {\n                 // Remove bounds that must hold, since they are not interesting."}, {"sha": "ea9a46613484ab983a551c0b9c8d476a38e8a4b2", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -12,8 +12,7 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![feature(bindings_after_at)]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n@@ -23,7 +22,6 @@\n #![feature(never_type)]\n #![feature(or_patterns)]\n #![feature(in_band_lifetimes)]\n-#![feature(crate_visibility_modifier)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "a3c4920fa8af3dc593adff29ef4e209edb9b0165", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -57,7 +57,7 @@ pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n // `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateObligation<'_>, 40);\n+static_assert_size!(PredicateObligation<'_>, 32);\n \n pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;"}, {"sha": "9c0d934a03529a75c39e2fac97710f4a4d02f9c0", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -236,6 +236,9 @@ impl Elaborator<'tcx> {\n                         .map(|predicate| predicate_obligation(predicate, None)),\n                 );\n             }\n+            ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+                // Nothing to elaborate\n+            }\n         }\n     }\n }"}, {"sha": "73a51ad477b22e90b886cd14288e5ae0542045a3", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -154,6 +154,10 @@ pub struct Config {\n     pub override_queries:\n         Option<fn(&Session, &mut ty::query::Providers, &mut ty::query::Providers)>,\n \n+    /// This is a callback from the driver that is called to create a codegen backend.\n+    pub make_codegen_backend:\n+        Option<Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>>,\n+\n     /// Registry of diagnostics codes.\n     pub registry: Registry,\n }\n@@ -167,6 +171,7 @@ pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R\n         config.file_loader,\n         config.input_path.clone(),\n         config.lint_caps,\n+        config.make_codegen_backend,\n         registry.clone(),\n     );\n "}, {"sha": "07ce9d0cd9484611b8e15840382f30d720b9b549", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -40,6 +40,7 @@ fn mk_session(matches: getopts::Matches) -> (Session, CfgSpecs) {\n         DiagnosticOutput::Default,\n         Default::default(),\n         None,\n+        None,\n     );\n     (sess, cfg)\n }\n@@ -567,6 +568,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(osx_rpath_install_name, true);\n     tracked!(panic_abort_tests, true);\n     tracked!(plt, Some(true));\n+    tracked!(precise_enum_drop_elaboration, false);\n     tracked!(print_fuel, Some(\"abc\".to_string()));\n     tracked!(profile, true);\n     tracked!(profile_emit, Some(PathBuf::from(\"abc\")));"}, {"sha": "7ace707cc88e9d0d00204b85bdc09e5ada7ba8aa", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -63,18 +63,31 @@ pub fn create_session(\n     file_loader: Option<Box<dyn FileLoader + Send + Sync + 'static>>,\n     input_path: Option<PathBuf>,\n     lint_caps: FxHashMap<lint::LintId, lint::Level>,\n+    make_codegen_backend: Option<\n+        Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n+    >,\n     descriptions: Registry,\n ) -> (Lrc<Session>, Lrc<Box<dyn CodegenBackend>>) {\n+    let codegen_backend = if let Some(make_codegen_backend) = make_codegen_backend {\n+        make_codegen_backend(&sopts)\n+    } else {\n+        get_codegen_backend(&sopts)\n+    };\n+\n+    // target_override is documented to be called before init(), so this is okay\n+    let target_override = codegen_backend.target_override(&sopts);\n+\n     let mut sess = session::build_session(\n         sopts,\n         input_path,\n         descriptions,\n         diagnostic_output,\n         lint_caps,\n         file_loader,\n+        target_override,\n     );\n \n-    let codegen_backend = get_codegen_backend(&sess);\n+    codegen_backend.init(&sess);\n \n     let mut cfg = config::build_configuration(&sess, config::to_crate_config(cfg));\n     add_configuration(&mut cfg, &mut sess, &*codegen_backend);\n@@ -219,13 +232,13 @@ fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n     }\n }\n \n-pub fn get_codegen_backend(sess: &Session) -> Box<dyn CodegenBackend> {\n+pub fn get_codegen_backend(sopts: &config::Options) -> Box<dyn CodegenBackend> {\n     static INIT: Once = Once::new();\n \n     static mut LOAD: fn() -> Box<dyn CodegenBackend> = || unreachable!();\n \n     INIT.call_once(|| {\n-        let codegen_name = sess.opts.debugging_opts.codegen_backend.as_deref().unwrap_or(\"llvm\");\n+        let codegen_name = sopts.debugging_opts.codegen_backend.as_deref().unwrap_or(\"llvm\");\n         let backend = match codegen_name {\n             filename if filename.contains('.') => load_backend_from_dylib(filename.as_ref()),\n             codegen_name => get_builtin_codegen_backend(codegen_name),\n@@ -235,9 +248,7 @@ pub fn get_codegen_backend(sess: &Session) -> Box<dyn CodegenBackend> {\n             LOAD = backend;\n         }\n     });\n-    let backend = unsafe { LOAD() };\n-    backend.init(sess);\n-    backend\n+    unsafe { LOAD() }\n }\n \n // This is used for rustdoc, but it uses similar machinery to codegen backend\n@@ -693,6 +704,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n                 rules,\n                 id: resolver.next_node_id(),\n                 span: rustc_span::DUMMY_SP,\n+                tokens: None,\n             }\n         }\n \n@@ -709,6 +721,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n                 id: resolver.next_node_id(),\n                 kind: ast::StmtKind::Expr(expr),\n                 span: rustc_span::DUMMY_SP,\n+                tokens: None,\n             }\n         }\n \n@@ -725,6 +738,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n             id: self.resolver.next_node_id(),\n             span: rustc_span::DUMMY_SP,\n             kind: ast::StmtKind::Expr(loop_expr),\n+            tokens: None,\n         };\n \n         if self.within_static_or_const {"}, {"sha": "d784a86f14ceede0341d74b561530c1f6552082d", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The idea with `librustc_lexer` is to make a reusable library,\n //! by separating out pure lexing and rustc-specific concerns, like spans,\n-//! error reporting an interning.  So, rustc_lexer operates directly on `&str`,\n+//! error reporting, and interning.  So, rustc_lexer operates directly on `&str`,\n //! produces simple tokens which are a pair of type-tag and a bit of original text,\n //! and does not report errors, instead storing them as flags on the token.\n //!"}, {"sha": "e6be082da0e9967aba913bddbe6aacd70ff99de3", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -7,6 +7,31 @@ use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::symbol::sym;\n \n declare_lint! {\n+    /// The `array_into_iter` lint detects calling `into_iter` on arrays.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// [1, 2, 3].into_iter().for_each(|n| { *n; });\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In the future, it is planned to add an `IntoIter` implementation for\n+    /// arrays such that it will iterate over *values* of the array instead of\n+    /// references. Due to how method resolution works, this will change\n+    /// existing code that uses `into_iter` on arrays. The solution to avoid\n+    /// this warning is to use `iter()` instead of `into_iter()`.\n+    ///\n+    /// This is a [future-incompatible] lint to transition this to a hard error\n+    /// in the future. See [issue #66145] for more details and a more thorough\n+    /// description of the lint.\n+    ///\n+    /// [issue #66145]: https://github.com/rust-lang/rust/issues/66145\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub ARRAY_INTO_ITER,\n     Warn,\n     \"detects calling `into_iter` on arrays\","}, {"sha": "abd899e8db4d33b6d9447bc7078dd15d296281b1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 538, "deletions": 28, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -21,7 +21,8 @@\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n use crate::{\n-    types::CItemKind, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n+    types::{transparent_newtype_field, CItemKind},\n+    EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n use rustc_ast::attr::{self, HasAttrs};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -61,6 +62,23 @@ use tracing::{debug, trace};\n pub use rustc_session::lint::builtin::*;\n \n declare_lint! {\n+    /// The `while_true` lint detects `while true { }`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,no_run\n+    /// while true {\n+    ///\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// `while true` should be replaced with `loop`. A `loop` expression is\n+    /// the preferred way to write an infinite loop because it more directly\n+    /// expresses the intent of the loop.\n     WHILE_TRUE,\n     Warn,\n     \"suggest using `loop { }` instead of `while true { }`\"\n@@ -102,6 +120,24 @@ impl EarlyLintPass for WhileTrue {\n }\n \n declare_lint! {\n+    /// The `box_pointers` lints use of the Box type.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(box_pointers)]\n+    /// struct Foo {\n+    ///     x: Box<isize>,\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is mostly historical, and not particularly useful. `Box<T>`\n+    /// used to be built into the language, and the only way to do heap\n+    /// allocation. Today's Rust can call into other allocators, etc.\n     BOX_POINTERS,\n     Allow,\n     \"use of owned (Box type) heap memory\"\n@@ -156,6 +192,36 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n }\n \n declare_lint! {\n+    /// The `non_shorthand_field_patterns` lint detects using `Struct { x: x }`\n+    /// instead of `Struct { x }` in a pattern.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// struct Point {\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    ///\n+    ///\n+    /// fn main() {\n+    ///     let p = Point {\n+    ///         x: 5,\n+    ///         y: 5,\n+    ///     };\n+    ///\n+    ///     match p {\n+    ///         Point { x: x, y: y } => (),\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The preferred style is to avoid the repetition of specifying both the\n+    /// field name and the binding name if both identifiers are the same.\n     NON_SHORTHAND_FIELD_PATTERNS,\n     Warn,\n     \"using `Struct { x: x }` instead of `Struct { x }` in a pattern\"\n@@ -216,6 +282,25 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n }\n \n declare_lint! {\n+    /// The `unsafe_code` lint catches usage of `unsafe` code.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unsafe_code)]\n+    /// fn main() {\n+    ///     unsafe {\n+    ///\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is intended to restrict the usage of `unsafe`, which can be\n+    /// difficult to use correctly.\n     UNSAFE_CODE,\n     Allow,\n     \"usage of `unsafe` code\"\n@@ -303,6 +388,25 @@ impl EarlyLintPass for UnsafeCode {\n }\n \n declare_lint! {\n+    /// The `missing_docs` lint detects missing documentation for public items.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(missing_docs)]\n+    /// pub fn foo() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is intended to ensure that a library is well-documented.\n+    /// Items without documentation can be difficult for users to understand\n+    /// how to use properly.\n+    ///\n+    /// This lint is \"allow\" by default because it can be noisy, and not all\n+    /// projects may want to enforce everything to be documented.\n     pub MISSING_DOCS,\n     Allow,\n     \"detects missing documentation for public members\",\n@@ -509,6 +613,19 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         );\n     }\n \n+    fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n+        let def_id = cx.tcx.hir().local_def_id(foreign_item.hir_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        self.check_missing_docs_attrs(\n+            cx,\n+            Some(foreign_item.hir_id),\n+            &foreign_item.attrs,\n+            foreign_item.span,\n+            article,\n+            desc,\n+        );\n+    }\n+\n     fn check_struct_field(&mut self, cx: &LateContext<'_>, sf: &hir::StructField<'_>) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(\n@@ -528,6 +645,34 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n }\n \n declare_lint! {\n+    /// The `missing_copy_implementations` lint detects potentially-forgotten\n+    /// implementations of [`Copy`].\n+    ///\n+    /// [`Copy`]: https://doc.rust-lang.org/std/marker/trait.Copy.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(missing_copy_implementations)]\n+    /// pub struct Foo {\n+    ///     pub field: i32\n+    /// }\n+    /// # fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Historically (before 1.0), types were automatically marked as `Copy`\n+    /// if possible. This was changed so that it required an explicit opt-in\n+    /// by implementing the `Copy` trait. As part of this change, a lint was\n+    /// added to alert if a copyable type was not marked `Copy`.\n+    ///\n+    /// This lint is \"allow\" by default because this code isn't bad; it is\n+    /// common to write newtypes like this specifically so that a `Copy` type\n+    /// is no longer `Copy`. `Copy` types can result in unintended copies of\n+    /// large data which can impact performance.\n     pub MISSING_COPY_IMPLEMENTATIONS,\n     Allow,\n     \"detects potentially-forgotten implementations of `Copy`\"\n@@ -584,6 +729,32 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n }\n \n declare_lint! {\n+    /// The `missing_debug_implementations` lint detects missing\n+    /// implementations of [`fmt::Debug`].\n+    ///\n+    /// [`fmt::Debug`]: https://doc.rust-lang.org/std/fmt/trait.Debug.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(missing_debug_implementations)]\n+    /// pub struct Foo;\n+    /// # fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Having a `Debug` implementation on all types can assist with\n+    /// debugging, as it provides a convenient way to format and display a\n+    /// value. Using the `#[derive(Debug)]` attribute will automatically\n+    /// generate a typical implementation, or a custom implementation can be\n+    /// added by manually implementing the `Debug` trait.\n+    ///\n+    /// This lint is \"allow\" by default because adding `Debug` to all types can\n+    /// have a negative impact on compile time and code size. It also requires\n+    /// boilerplate to be added to every type, which can be an impediment.\n     MISSING_DEBUG_IMPLEMENTATIONS,\n     Allow,\n     \"detects missing implementations of Debug\"\n@@ -640,6 +811,45 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n }\n \n declare_lint! {\n+    /// The `anonymous_parameters` lint detects anonymous parameters in trait\n+    /// definitions.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,edition2015,compile_fail\n+    /// #![deny(anonymous_parameters)]\n+    /// // edition 2015\n+    /// pub trait Foo {\n+    ///     fn foo(usize);\n+    /// }\n+    /// fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This syntax is mostly a historical accident, and can be worked around\n+    /// quite easily by adding an `_` pattern or a descriptive identifier:\n+    ///\n+    /// ```rust\n+    /// trait Foo {\n+    ///     fn foo(_: usize);\n+    /// }\n+    /// ```\n+    ///\n+    /// This syntax is now a hard error in the 2018 edition. In the 2015\n+    /// edition, this lint is \"allow\" by default, because the old code is\n+    /// still valid, and warning for all old code can be noisy. This lint\n+    /// enables the [`cargo fix`] tool with the `--edition` flag to\n+    /// automatically transition old code from the 2015 edition to 2018. The\n+    /// tool will switch this lint to \"warn\" and will automatically apply the\n+    /// suggested fix from the compiler (which is to add `_` to each\n+    /// parameter). This provides a completely automated way to update old\n+    /// code for a new edition. See [issue #41686] for more details.\n+    ///\n+    /// [issue #41686]: https://github.com/rust-lang/rust/issues/41686\n+    /// [`cargo fix`]: https://doc.rust-lang.org/cargo/commands/cargo-fix.html\n     pub ANONYMOUS_PARAMETERS,\n     Allow,\n     \"detects anonymous parameters\",\n@@ -765,7 +975,7 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n             continue;\n         }\n \n-        let span = sugared_span.take().unwrap_or_else(|| attr.span);\n+        let span = sugared_span.take().unwrap_or(attr.span);\n \n         if attr.is_doc_comment() || cx.sess().check_name(attr, sym::doc) {\n             cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, |lint| {\n@@ -806,12 +1016,54 @@ impl EarlyLintPass for UnusedDocComment {\n }\n \n declare_lint! {\n+    /// The `no_mangle_const_items` lint detects any `const` items with the\n+    /// [`no_mangle` attribute].\n+    ///\n+    /// [`no_mangle` attribute]: https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #[no_mangle]\n+    /// const FOO: i32 = 5;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Constants do not have their symbols exported, and therefore, this\n+    /// probably means you meant to use a [`static`], not a [`const`].\n+    ///\n+    /// [`static`]: https://doc.rust-lang.org/reference/items/static-items.html\n+    /// [`const`]: https://doc.rust-lang.org/reference/items/constant-items.html\n     NO_MANGLE_CONST_ITEMS,\n     Deny,\n     \"const items will not have their symbols exported\"\n }\n \n declare_lint! {\n+    /// The `no_mangle_generic_items` lint detects generic items that must be\n+    /// mangled.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #[no_mangle]\n+    /// fn foo<T>(t: T) {\n+    ///\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// An function with generics must have its symbol mangled to accommodate\n+    /// the generic parameter. The [`no_mangle` attribute] has no effect in\n+    /// this situation, and should be removed.\n+    ///\n+    /// [`no_mangle` attribute]: https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute\n     NO_MANGLE_GENERIC_ITEMS,\n     Warn,\n     \"generic items must be mangled\"\n@@ -882,6 +1134,27 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n }\n \n declare_lint! {\n+    /// The `mutable_transmutes` lint catches transmuting from `&T` to `&mut\n+    /// T` because it is [undefined behavior].\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// unsafe {\n+    ///     let y = std::mem::transmute::<&i32, &mut i32>(&5);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Certain assumptions are made about aliasing of data, and this transmute\n+    /// violates those assumptions. Consider using [`UnsafeCell`] instead.\n+    ///\n+    /// [`UnsafeCell`]: https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html\n     MUTABLE_TRANSMUTES,\n     Deny,\n     \"mutating transmuted &mut T from &T may cause undefined behavior\"\n@@ -931,6 +1204,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n }\n \n declare_lint! {\n+    /// The `unstable_features` is deprecated and should no longer be used.\n     UNSTABLE_FEATURES,\n     Allow,\n     \"enabling unstable features (deprecated. do not use)\"\n@@ -956,6 +1230,32 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n }\n \n declare_lint! {\n+    /// The `unreachable_pub` lint triggers for `pub` items not reachable from\n+    /// the crate root.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unreachable_pub)]\n+    /// mod foo {\n+    ///     pub mod bar {\n+    ///\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A bare `pub` visibility may be misleading if the item is not actually\n+    /// publicly exported from the crate. The `pub(crate)` visibility is\n+    /// recommended to be used instead, which more clearly expresses the intent\n+    /// that the item is only visible within its own crate.\n+    ///\n+    /// This lint is \"allow\" by default because it will trigger for a large\n+    /// amount existing Rust code, and has some false-positives. Eventually it\n+    /// is desired for this to become warn-by-default.\n     pub UNREACHABLE_PUB,\n     Allow,\n     \"`pub` items not reachable from crate root\"\n@@ -1035,6 +1335,21 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n }\n \n declare_lint! {\n+    /// The `type_alias_bounds` lint detects bounds in type aliases.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// type SendVec<T: Send> = Vec<T>;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The trait bounds in a type alias are currently ignored, and should not\n+    /// be included to avoid confusion. This was previously allowed\n+    /// unintentionally; this may become a hard error in the future.\n     TYPE_ALIAS_BOUNDS,\n     Warn,\n     \"bounds in type aliases are not enforced\"\n@@ -1172,28 +1487,55 @@ declare_lint_pass!(\n     UnusedBrokenConst => []\n );\n \n-fn check_const(cx: &LateContext<'_>, body_id: hir::BodyId) {\n-    let def_id = cx.tcx.hir().body_owner_def_id(body_id).to_def_id();\n-    // trigger the query once for all constants since that will already report the errors\n-    // FIXME: Use ensure here\n-    let _ = cx.tcx.const_eval_poly(def_id);\n-}\n-\n impl<'tcx> LateLintPass<'tcx> for UnusedBrokenConst {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Const(_, body_id) => {\n-                check_const(cx, body_id);\n+                let def_id = cx.tcx.hir().body_owner_def_id(body_id).to_def_id();\n+                // trigger the query once for all constants since that will already report the errors\n+                // FIXME: Use ensure here\n+                let _ = cx.tcx.const_eval_poly(def_id);\n             }\n             hir::ItemKind::Static(_, _, body_id) => {\n-                check_const(cx, body_id);\n+                let def_id = cx.tcx.hir().body_owner_def_id(body_id).to_def_id();\n+                // FIXME: Use ensure here\n+                let _ = cx.tcx.eval_static_initializer(def_id);\n             }\n             _ => {}\n         }\n     }\n }\n \n declare_lint! {\n+    /// The `trivial_bounds` lint detects trait bounds that don't depend on\n+    /// any type parameters.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(trivial_bounds)]\n+    /// pub struct A where i32: Copy;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Usually you would not write a trait bound that you know is always\n+    /// true, or never true. However, when using macros, the macro may not\n+    /// know whether or not the constraint would hold or not at the time when\n+    /// generating the code. Currently, the compiler does not alert you if the\n+    /// constraint is always true, and generates an error if it is never true.\n+    /// The `trivial_bounds` feature changes this to be a warning in both\n+    /// cases, giving macros more freedom and flexibility to generate code,\n+    /// while still providing a signal when writing non-macro code that\n+    /// something is amiss.\n+    ///\n+    /// See [RFC 2056] for more details. This feature is currently only\n+    /// available on the nightly channel, see [tracking issue #48214].\n+    ///\n+    /// [RFC 2056]: https://github.com/rust-lang/rfcs/blob/master/text/2056-allow-trivial-where-clause-constraints.md\n+    /// [tracking issue #48214]: https://github.com/rust-lang/rust/issues/48214\n     TRIVIAL_BOUNDS,\n     Warn,\n     \"these bounds don't depend on an type parameters\"\n@@ -1228,7 +1570,8 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     ClosureKind(..) |\n                     Subtype(..) |\n                     ConstEvaluatable(..) |\n-                    ConstEquate(..) => continue,\n+                    ConstEquate(..) |\n+                    TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {\n                     cx.struct_span_lint(TRIVIAL_BOUNDS, span, |lint| {\n@@ -1269,6 +1612,29 @@ declare_lint_pass!(\n );\n \n declare_lint! {\n+    /// The `ellipsis_inclusive_range_patterns` lint detects the [`...` range\n+    /// pattern], which is deprecated.\n+    ///\n+    /// [`...` range pattern]: https://doc.rust-lang.org/reference/patterns.html#range-patterns\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let x = 123;\n+    /// match x {\n+    ///     0...100 => {}\n+    ///     _ => {}\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The `...` range pattern syntax was changed to `..=` to avoid potential\n+    /// confusion with the [`..` range expression]. Use the new form instead.\n+    ///\n+    /// [`..` range expression]: https://doc.rust-lang.org/reference/expressions/range-expr.html\n     pub ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n     Warn,\n     \"`...` range patterns are deprecated\"\n@@ -1355,6 +1721,38 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n }\n \n declare_lint! {\n+    /// The `unnameable_test_items` lint detects [`#[test]`][test] functions\n+    /// that are not able to be run by the test harness because they are in a\n+    /// position where they are not nameable.\n+    ///\n+    /// [test]: https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,test\n+    /// fn main() {\n+    ///     #[test]\n+    ///     fn foo() {\n+    ///         // This test will not fail because it does not run.\n+    ///         assert_eq!(1, 2);\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In order for the test harness to run a test, the test function must be\n+    /// located in a position where it can be accessed from the crate root.\n+    /// This generally means it must be defined in a module, and not anywhere\n+    /// else such as inside another function. The compiler previously allowed\n+    /// this without an error, so a lint was added as an alert that a test is\n+    /// not being used. Whether or not this should be allowed has not yet been\n+    /// decided, see [RFC 2471] and [issue #36629].\n+    ///\n+    /// [RFC 2471]: https://github.com/rust-lang/rfcs/pull/2471#issuecomment-397414443\n+    /// [issue #36629]: https://github.com/rust-lang/rust/issues/36629\n     UNNAMEABLE_TEST_ITEMS,\n     Warn,\n     \"detects an item that cannot be named being marked as `#[test_case]`\",\n@@ -1400,6 +1798,41 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n }\n \n declare_lint! {\n+    /// The `keyword_idents` lint detects edition keywords being used as an\n+    /// identifier.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,edition2015,compile_fail\n+    /// #![deny(keyword_idents)]\n+    /// // edition 2015\n+    /// fn dyn() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Rust [editions] allow the language to evolve without breaking\n+    /// backwards compatibility. This lint catches code that uses new keywords\n+    /// that are added to the language that are used as identifiers (such as a\n+    /// variable name, function name, etc.). If you switch the compiler to a\n+    /// new edition without updating the code, then it will fail to compile if\n+    /// you are using a new keyword as an identifier.\n+    ///\n+    /// You can manually change the identifiers to a non-keyword, or use a\n+    /// [raw identifier], for example `r#dyn`, to transition to a new edition.\n+    ///\n+    /// This lint solves the problem automatically. It is \"allow\" by default\n+    /// because the code is perfectly valid in older editions. The [`cargo\n+    /// fix`] tool with the `--edition` flag will switch this lint to \"warn\"\n+    /// and automatically apply the suggested fix from the compiler (which is\n+    /// to use a raw identifier). This provides a completely automated way to\n+    /// update old code for a new edition.\n+    ///\n+    /// [editions]: https://doc.rust-lang.org/edition-guide/\n+    /// [raw identifier]: https://doc.rust-lang.org/reference/identifiers.html\n+    /// [`cargo fix`]: https://doc.rust-lang.org/cargo/commands/cargo-fix.html\n     pub KEYWORD_IDENTS,\n     Allow,\n     \"detects edition keywords being used as an identifier\",\n@@ -1564,9 +1997,9 @@ impl ExplicitOutlivesRequirements {\n             .filter_map(|(i, bound)| {\n                 if let hir::GenericBound::Outlives(lifetime) = bound {\n                     let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                        Some(Region::Static) if infer_static => inferred_outlives\n-                            .iter()\n-                            .any(|r| if let ty::ReStatic = r { true } else { false }),\n+                        Some(Region::Static) if infer_static => {\n+                            inferred_outlives.iter().any(|r| matches!(r, ty::ReStatic))\n+                        }\n                         Some(Region::EarlyBound(index, ..)) => inferred_outlives.iter().any(|r| {\n                             if let ty::ReEarlyBound(ebr) = r { ebr.index == index } else { false }\n                         }),\n@@ -1658,9 +2091,10 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             let mut lint_spans = Vec::new();\n \n             for param in hir_generics.params {\n-                let has_lifetime_bounds = param.bounds.iter().any(|bound| {\n-                    if let hir::GenericBound::Outlives(_) = bound { true } else { false }\n-                });\n+                let has_lifetime_bounds = param\n+                    .bounds\n+                    .iter()\n+                    .any(|bound| matches!(bound, hir::GenericBound::Outlives(_)));\n                 if !has_lifetime_bounds {\n                     continue;\n                 }\n@@ -1801,6 +2235,26 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n }\n \n declare_lint! {\n+    /// The `incomplete_features` lint detects unstable features enabled with\n+    /// the [`feature` attribute] that may function improperly in some or all\n+    /// cases.\n+    ///\n+    /// [`feature` attribute]: https://doc.rust-lang.org/nightly/unstable-book/\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(generic_associated_types)]\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Although it is encouraged for people to experiment with unstable\n+    /// features, some of them are known to be incomplete or faulty. This lint\n+    /// is a signal that the feature has not yet been finished, and you may\n+    /// experience problems with it.\n     pub INCOMPLETE_FEATURES,\n     Warn,\n     \"incomplete features that may function improperly in some or all cases\"\n@@ -1841,6 +2295,36 @@ impl EarlyLintPass for IncompleteFeatures {\n }\n \n declare_lint! {\n+    /// The `invalid_value` lint detects creating a value that is not valid,\n+    /// such as a NULL reference.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,no_run\n+    /// # #![allow(unused)]\n+    /// unsafe {\n+    ///     let x: &'static i32 = std::mem::zeroed();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In some situations the compiler can detect that the code is creating\n+    /// an invalid value, which should be avoided.\n+    ///\n+    /// In particular, this lint will check for improper use of\n+    /// [`mem::zeroed`], [`mem::uninitialized`], [`mem::transmute`], and\n+    /// [`MaybeUninit::assume_init`] that can cause [undefined behavior]. The\n+    /// lint should provide extra information to indicate what the problem is\n+    /// and a possible solution.\n+    ///\n+    /// [`mem::zeroed`]: https://doc.rust-lang.org/std/mem/fn.zeroed.html\n+    /// [`mem::uninitialized`]: https://doc.rust-lang.org/std/mem/fn.uninitialized.html\n+    /// [`mem::transmute`]: https://doc.rust-lang.org/std/mem/fn.transmute.html\n+    /// [`MaybeUninit::assume_init`]: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#method.assume_init\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     pub INVALID_VALUE,\n     Warn,\n     \"an invalid value is being created (such as a NULL reference)\"\n@@ -1879,13 +2363,6 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n \n         /// Determine if this expression is a \"dangerous initialization\".\n         fn is_dangerous_init(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<InitKind> {\n-            // `transmute` is inside an anonymous module (the `extern` block?);\n-            // `Invalid` represents the empty string and matches that.\n-            // FIXME(#66075): use diagnostic items.  Somehow, that does not seem to work\n-            // on intrinsics right now.\n-            const TRANSMUTE_PATH: &[Symbol] =\n-                &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n-\n             if let hir::ExprKind::Call(ref path_expr, ref args) = expr.kind {\n                 // Find calls to `mem::{uninitialized,zeroed}` methods.\n                 if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n@@ -1895,7 +2372,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         return Some(InitKind::Zeroed);\n                     } else if cx.tcx.is_diagnostic_item(sym::mem_uninitialized, def_id) {\n                         return Some(InitKind::Uninit);\n-                    } else if cx.match_def_path(def_id, TRANSMUTE_PATH) {\n+                    } else if cx.tcx.is_diagnostic_item(sym::transmute, def_id) {\n                         if is_zero(&args[0]) {\n                             return Some(InitKind::Zeroed);\n                         }\n@@ -2072,6 +2549,40 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n }\n \n declare_lint! {\n+    /// The `clashing_extern_declarations` lint detects when an `extern fn`\n+    /// has been declared with the same name but different types.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// mod m {\n+    ///     extern \"C\" {\n+    ///         fn foo();\n+    ///     }\n+    /// }\n+    ///\n+    /// extern \"C\" {\n+    ///     fn foo(_: u32);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Because two symbols of the same name cannot be resolved to two\n+    /// different functions at link time, and one function cannot possibly\n+    /// have two types, a clashing extern declaration is almost certainly a\n+    /// mistake. Check to make sure that the `extern` definitions are correct\n+    /// and equivalent, and possibly consider unifying them in one location.\n+    ///\n+    /// This lint does not run between crates because a project may have\n+    /// dependencies which both rely on the same extern function, but declare\n+    /// it in a different (but valid) way. For example, they may both declare\n+    /// an opaque type for one or more of the arguments (which would end up\n+    /// distinct types), or use types that are valid conversions in the\n+    /// language the `extern fn` is defined in. In these cases, the compiler\n+    /// can't say that the clashing declaration is incorrect.\n     pub CLASHING_EXTERN_DECLARATIONS,\n     Warn,\n     \"detects when an extern fn has been declared with the same name but different types\"\n@@ -2183,8 +2694,7 @@ impl ClashingExternDeclarations {\n                         if is_transparent && !is_non_null {\n                             debug_assert!(def.variants.len() == 1);\n                             let v = &def.variants[VariantIdx::new(0)];\n-                            ty = v\n-                                .transparent_newtype_field(tcx)\n+                            ty = transparent_newtype_field(tcx, v)\n                                 .expect(\n                                     \"single-variant transparent structure with zero-sized field\",\n                                 )"}, {"sha": "7a3035e5b463162f74cd17c6876ddcba8e16867a", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -720,6 +720,10 @@ impl<'tcx> LateContext<'tcx> {\n     /// Anonymous scopes such as `extern` imports are matched with `kw::Invalid`;\n     /// inherent `impl` blocks are matched with the name of the type.\n     ///\n+    /// Instead of using this method, it is often preferable to instead use\n+    /// `rustc_diagnostic_item` or a `lang_item`. This is less prone to errors\n+    /// as paths get invalidated if the target definition moves.\n+    ///\n     /// # Examples\n     ///\n     /// ```rust,ignore (no context or def id available)\n@@ -842,7 +846,7 @@ impl<'tcx> LateContext<'tcx> {\n                     return Ok(path);\n                 }\n \n-                path.push(disambiguated_data.data.as_symbol());\n+                path.push(Symbol::intern(&disambiguated_data.data.to_string()));\n                 Ok(path)\n             }\n "}, {"sha": "c2d98b8e4ad378fa5bc308a30cd39dd18bbc0d27", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -5,7 +5,9 @@ use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext}\n use rustc_ast::{Item, ItemKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n use rustc_hir::{GenericArg, HirId, MutTy, Mutability, Path, PathSegment, QPath, Ty, TyKind};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -177,11 +179,31 @@ fn lint_ty_kind_usage(cx: &LateContext<'_>, segment: &PathSegment<'_>) -> bool {\n fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, ty: &Ty<'_>) -> Option<String> {\n     if let TyKind::Path(qpath) = &ty.kind {\n         if let QPath::Resolved(_, path) = qpath {\n-            let did = path.res.opt_def_id()?;\n-            if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n-                return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n-            } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n-                return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n+            match path.res {\n+                Res::Def(_, did) => {\n+                    if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n+                        return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n+                    } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n+                        return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n+                    }\n+                }\n+                // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n+                Res::SelfTy(None, Some((did, _))) => {\n+                    if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n+                        if cx.tcx.is_diagnostic_item(sym::Ty, adt.did) {\n+                            // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n+                            // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n+                            // is not actually allowed.\n+                            //\n+                            // I(@lcnr) still kept this branch in so we don't miss this\n+                            // if we ever change it in the future.\n+                            return Some(format!(\"Ty<{}>\", substs[0]));\n+                        } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, adt.did) {\n+                            return Some(format!(\"TyCtxt<{}>\", substs[0]));\n+                        }\n+                    }\n+                }\n+                _ => (),\n             }\n         }\n     }"}, {"sha": "49e80f9d8a531741b5d8e1c19cd219a66ee4a080", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -25,8 +25,9 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![cfg_attr(test, feature(test))]\n+#![feature(array_windows)]\n #![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n@@ -52,6 +53,7 @@ mod non_ascii_idents;\n mod nonstandard_style;\n mod passes;\n mod redundant_semicolon;\n+mod traits;\n mod types;\n mod unused;\n \n@@ -74,6 +76,7 @@ use internal::*;\n use non_ascii_idents::*;\n use nonstandard_style::*;\n use redundant_semicolon::*;\n+use traits::*;\n use types::*;\n use unused::*;\n \n@@ -156,6 +159,7 @@ macro_rules! late_lint_passes {\n                 MissingDebugImplementations: MissingDebugImplementations::default(),\n                 ArrayIntoIter: ArrayIntoIter,\n                 ClashingExternDeclarations: ClashingExternDeclarations::new(),\n+                DropTraitConstraints: DropTraitConstraints,\n             ]\n         );\n     };\n@@ -304,6 +308,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     add_lint_group!(\n         \"rustdoc\",\n         BROKEN_INTRA_DOC_LINKS,\n+        PRIVATE_INTRA_DOC_LINKS,\n         INVALID_CODEBLOCK_ATTRIBUTES,\n         MISSING_DOC_CODE_EXAMPLES,\n         PRIVATE_DOC_TESTS"}, {"sha": "a1c7e47e749add17a11cfc1d52536fe937342371", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 131, "deletions": 1, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,27 +4,156 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_span::symbol::Symbol;\n \n declare_lint! {\n+    /// The `non_ascii_idents` lint detects non-ASCII identifiers.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// # #![allow(unused)]\n+    /// #![feature(non_ascii_idents)]\n+    /// #![deny(non_ascii_idents)]\n+    /// fn main() {\n+    ///     let f\u00f6\u00f6 = 1;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Currently on stable Rust, identifiers must contain ASCII characters.\n+    /// The [`non_ascii_idents`] nightly-only feature allows identifiers to\n+    /// contain non-ASCII characters. This lint allows projects that wish to\n+    /// retain the limit of only using ASCII characters to switch this lint to\n+    /// \"forbid\" (for example to ease collaboration or for security reasons).\n+    /// See [RFC 2457] for more details.\n+    ///\n+    /// [`non_ascii_idents`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/non-ascii-idents.html\n+    /// [RFC 2457]: https://github.com/rust-lang/rfcs/blob/master/text/2457-non-ascii-idents.md\n     pub NON_ASCII_IDENTS,\n     Allow,\n     \"detects non-ASCII identifiers\",\n     crate_level_only\n }\n \n declare_lint! {\n+    /// The `uncommon_codepoints` lint detects uncommon Unicode codepoints in\n+    /// identifiers.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// #![feature(non_ascii_idents)]\n+    /// const \u00b5: f64 = 0.000001;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// With the [`non_ascii_idents`] nightly-only feature enabled,\n+    /// identifiers are allowed to use non-ASCII characters. This lint warns\n+    /// about using characters which are not commonly used, and may cause\n+    /// visual confusion.\n+    ///\n+    /// This lint is triggered by identifiers that contain a codepoint that is\n+    /// not part of the set of \"Allowed\" codepoints as described by [Unicode\u00ae\n+    /// Technical Standard #39 Unicode Security Mechanisms Section 3.1 General\n+    /// Security Profile for Identifiers][TR39Allowed].\n+    ///\n+    /// Note that the set of uncommon codepoints may change over time. Beware\n+    /// that if you \"forbid\" this lint that existing code may fail in the\n+    /// future.\n+    ///\n+    /// [`non_ascii_idents`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/non-ascii-idents.html\n+    /// [TR39Allowed]: https://www.unicode.org/reports/tr39/#General_Security_Profile\n     pub UNCOMMON_CODEPOINTS,\n     Warn,\n     \"detects uncommon Unicode codepoints in identifiers\",\n     crate_level_only\n }\n \n declare_lint! {\n+    /// The `confusable_idents` lint detects visually confusable pairs between\n+    /// identifiers.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(non_ascii_idents)]\n+    ///\n+    /// // Latin Capital Letter E With Caron\n+    /// pub const \u011a: i32 = 1;\n+    /// // Latin Capital Letter E With Breve\n+    /// pub const \u0114: i32 = 2;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// With the [`non_ascii_idents`] nightly-only feature enabled,\n+    /// identifiers are allowed to use non-ASCII characters. This lint warns\n+    /// when different identifiers may appear visually similar, which can\n+    /// cause confusion.\n+    ///\n+    /// The confusable detection algorithm is based on [Unicode\u00ae Technical\n+    /// Standard #39 Unicode Security Mechanisms Section 4 Confusable\n+    /// Detection][TR39Confusable]. For every distinct identifier X execute\n+    /// the function `skeleton(X)`. If there exist two distinct identifiers X\n+    /// and Y in the same crate where `skeleton(X) = skeleton(Y)` report it.\n+    /// The compiler uses the same mechanism to check if an identifier is too\n+    /// similar to a keyword.\n+    ///\n+    /// Note that the set of confusable characters may change over time.\n+    /// Beware that if you \"forbid\" this lint that existing code may fail in\n+    /// the future.\n+    ///\n+    /// [`non_ascii_idents`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/non-ascii-idents.html\n+    /// [TR39Confusable]: https://www.unicode.org/reports/tr39/#Confusable_Detection\n     pub CONFUSABLE_IDENTS,\n     Warn,\n     \"detects visually confusable pairs between identifiers\",\n     crate_level_only\n }\n \n declare_lint! {\n+    /// The `mixed_script_confusables` lint detects visually confusable\n+    /// characters in identifiers between different [scripts].\n+    ///\n+    /// [scripts]: https://en.wikipedia.org/wiki/Script_(Unicode)\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(non_ascii_idents)]\n+    ///\n+    /// // The Japanese katakana character \u30a8 can be confused with the Han character \u5de5.\n+    /// const \u30a8: &'static str = \"\u30a2\u30a4\u30a6\";\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// With the [`non_ascii_idents`] nightly-only feature enabled,\n+    /// identifiers are allowed to use non-ASCII characters. This lint warns\n+    /// when characters between different scripts may appear visually similar,\n+    /// which can cause confusion.\n+    ///\n+    /// If the crate contains other identifiers in the same script that have\n+    /// non-confusable characters, then this lint will *not* be issued. For\n+    /// example, if the example given above has another identifier with\n+    /// katakana characters (such as `let \u30ab\u30bf\u30ab\u30ca = 123;`), then this indicates\n+    /// that you are intentionally using katakana, and it will not warn about\n+    /// it.\n+    ///\n+    /// Note that the set of confusable characters may change over time.\n+    /// Beware that if you \"forbid\" this lint that existing code may fail in\n+    /// the future.\n+    ///\n+    /// [`non_ascii_idents`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/non-ascii-idents.html\n     pub MIXED_SCRIPT_CONFUSABLES,\n     Warn,\n     \"detects Unicode scripts whose mixed script confusables codepoints are solely used\",\n@@ -212,7 +341,8 @@ impl EarlyLintPass for NonAsciiIdents {\n                         }\n                     }\n \n-                    ch_list.sort();\n+                    // We sort primitive chars here and can use unstable sort\n+                    ch_list.sort_unstable();\n                     ch_list.dedup();\n                     lint_reports.insert((sp, ch_list), augment_script_set);\n                 }"}, {"sha": "b3125f55d4d6e4b4d054cc627236d0b61557023e", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -31,6 +31,24 @@ pub fn method_context(cx: &LateContext<'_>, id: hir::HirId) -> MethodLateContext\n }\n \n declare_lint! {\n+    /// The `non_camel_case_types` lint detects types, variants, traits and\n+    /// type parameters that don't have camel case names.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// struct my_struct;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The preferred style for these identifiers is to use \"camel case\", such\n+    /// as `MyStruct`, where the first letter should not be lowercase, and\n+    /// should not use underscores between letters. Underscores are allowed at\n+    /// the beginning and end of the identifier, as well as between\n+    /// non-letters (such as `X86_64`).\n     pub NON_CAMEL_CASE_TYPES,\n     Warn,\n     \"types, variants, traits and type parameters should have camel case names\"\n@@ -52,9 +70,9 @@ fn is_camel_case(name: &str) -> bool {\n     // ones (some scripts don't have a concept of upper/lowercase)\n     !name.chars().next().unwrap().is_lowercase()\n         && !name.contains(\"__\")\n-        && !name.chars().collect::<Vec<_>>().windows(2).any(|pair| {\n+        && !name.chars().collect::<Vec<_>>().array_windows().any(|&[fst, snd]| {\n             // contains a capitalisable character followed by, or preceded by, an underscore\n-            char_has_case(pair[0]) && pair[1] == '_' || char_has_case(pair[1]) && pair[0] == '_'\n+            char_has_case(fst) && snd == '_' || char_has_case(snd) && fst == '_'\n         })\n }\n \n@@ -161,6 +179,22 @@ impl EarlyLintPass for NonCamelCaseTypes {\n }\n \n declare_lint! {\n+    /// The `non_snake_case` lint detects variables, methods, functions,\n+    /// lifetime parameters and modules that don't have snake case names.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let MY_VALUE = 5;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The preferred style for these identifiers is to use \"snake case\",\n+    /// where all the characters are in lowercase, with words separated with a\n+    /// single underscore, such as `my_value`.\n     pub NON_SNAKE_CASE,\n     Warn,\n     \"variables, methods, functions, lifetime parameters and modules should have snake case names\"\n@@ -379,6 +413,21 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n }\n \n declare_lint! {\n+    /// The `non_upper_case_globals` lint detects static items that don't have\n+    /// uppercase identifiers.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// static max_points: i32 = 5;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The preferred style is for static item names to use all uppercase\n+    /// letters such as `MAX_POINTS`.\n     pub NON_UPPER_CASE_GLOBALS,\n     Warn,\n     \"static constants should have uppercase identifiers\""}, {"sha": "a31deb87ff0d062fd37d7503a80570074642195b", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,6 +4,21 @@ use rustc_errors::Applicability;\n use rustc_span::Span;\n \n declare_lint! {\n+    /// The `redundant_semicolons` lint detects unnecessary trailing\n+    /// semicolons.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let _ = 123;;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Extra semicolons are not needed, and may be removed to avoid confusion\n+    /// and visual clutter.\n     pub REDUNDANT_SEMICOLONS,\n     Warn,\n     \"detects unnecessary trailing semicolons\""}, {"sha": "d4f79036e5a180f92d67d1529b8709041fd73061", "filename": "compiler/rustc_lint/src/traits.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,79 @@\n+use crate::LateContext;\n+use crate::LateLintPass;\n+use crate::LintContext;\n+use rustc_hir as hir;\n+use rustc_span::symbol::sym;\n+\n+declare_lint! {\n+    /// The `drop_bounds` lint checks for generics with `std::ops::Drop` as\n+    /// bounds.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn foo<T: Drop>() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// `Drop` bounds do not really accomplish anything. A type may have\n+    /// compiler-generated drop glue without implementing the `Drop` trait\n+    /// itself. The `Drop` trait also only has one method, `Drop::drop`, and\n+    /// that function is by fiat not callable in user code. So there is really\n+    /// no use case for using `Drop` in trait bounds.\n+    ///\n+    /// The most likely use case of a drop bound is to distinguish between\n+    /// types that have destructors and types that don't. Combined with\n+    /// specialization, a naive coder would write an implementation that\n+    /// assumed a type could be trivially dropped, then write a specialization\n+    /// for `T: Drop` that actually calls the destructor. Except that doing so\n+    /// is not correct; String, for example, doesn't actually implement Drop,\n+    /// but because String contains a Vec, assuming it can be trivially dropped\n+    /// will leak memory.\n+    pub DROP_BOUNDS,\n+    Warn,\n+    \"bounds of the form `T: Drop` are useless\"\n+}\n+\n+declare_lint_pass!(\n+    /// Lint for bounds of the form `T: Drop`, which usually\n+    /// indicate an attempt to emulate `std::mem::needs_drop`.\n+    DropTraitConstraints => [DROP_BOUNDS]\n+);\n+\n+impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+        use rustc_middle::ty::PredicateAtom::*;\n+\n+        let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n+        let predicates = cx.tcx.explicit_predicates_of(def_id);\n+        for &(predicate, span) in predicates.predicates {\n+            let trait_predicate = match predicate.skip_binders() {\n+                Trait(trait_predicate, _constness) => trait_predicate,\n+                _ => continue,\n+            };\n+            let def_id = trait_predicate.trait_ref.def_id;\n+            if cx.tcx.lang_items().drop_trait() == Some(def_id) {\n+                // Explicitly allow `impl Drop`, a drop-guards-as-Voldemort-type pattern.\n+                if trait_predicate.trait_ref.self_ty().is_impl_trait() {\n+                    continue;\n+                }\n+                cx.struct_span_lint(DROP_BOUNDS, span, |lint| {\n+                    let needs_drop = match cx.tcx.get_diagnostic_item(sym::needs_drop) {\n+                        Some(needs_drop) => needs_drop,\n+                        None => return,\n+                    };\n+                    let msg = format!(\n+                        \"bounds on `{}` are useless, consider instead \\\n+                         using `{}` to detect if a type has a destructor\",\n+                        predicate,\n+                        cx.tcx.def_path_str(needs_drop)\n+                    );\n+                    lint.build(&msg).emit()\n+                });\n+            }\n+        }\n+    }\n+}"}, {"sha": "9925444b869f95a8730a6c455c7db51a49ddfd50", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 130, "deletions": 6, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,5 +1,3 @@\n-#![allow(non_snake_case)]\n-\n use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n@@ -23,18 +21,82 @@ use std::cmp;\n use tracing::debug;\n \n declare_lint! {\n+    /// The `unused_comparisons` lint detects comparisons made useless by\n+    /// limits of the types involved.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn foo(x: u8) {\n+    ///     x >= 0;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A useless comparison may indicate a mistake, and should be fixed or\n+    /// removed.\n     UNUSED_COMPARISONS,\n     Warn,\n     \"comparisons made useless by limits of the types involved\"\n }\n \n declare_lint! {\n+    /// The `overflowing_literals` lint detects literal out of range for its\n+    /// type.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// let x: u8 = 1000;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is usually a mistake to use a literal that overflows the type where\n+    /// it is used. Either use a literal that is within range, or change the\n+    /// type to be within the range of the literal.\n     OVERFLOWING_LITERALS,\n     Deny,\n     \"literal out of range for its type\"\n }\n \n declare_lint! {\n+    /// The `variant_size_differences` lint detects enums with widely varying\n+    /// variant sizes.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(variant_size_differences)]\n+    /// enum En {\n+    ///     V0(u8),\n+    ///     VBig([u8; 1024]),\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It can be a mistake to add a variant to an enum that is much larger\n+    /// than the other variants, bloating the overall size required for all\n+    /// variants. This can impact performance and memory usage. This is\n+    /// triggered if one variant is more than 3 times larger than the\n+    /// second-largest variant.\n+    ///\n+    /// Consider placing the large variant's contents on the heap (for example\n+    /// via [`Box`]) to keep the overall size of the enum itself down.\n+    ///\n+    /// This lint is \"allow\" by default because it can be noisy, and may not be\n+    /// an actual problem. Decisions about this should be guided with\n+    /// profiling and benchmarking.\n+    ///\n+    /// [`Box`]: https://doc.rust-lang.org/std/boxed/index.html\n     VARIANT_SIZE_DIFFERENCES,\n     Allow,\n     \"detects enums with widely varying variant sizes\"\n@@ -495,6 +557,27 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n }\n \n declare_lint! {\n+    /// The `improper_ctypes` lint detects incorrect use of types in foreign\n+    /// modules.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// extern \"C\" {\n+    ///     static STATIC: String;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The compiler has several checks to verify that types used in `extern`\n+    /// blocks are safe and follow certain rules to ensure proper\n+    /// compatibility with the foreign interfaces. This lint is issued when it\n+    /// detects a probable mistake in a definition. The lint usually should\n+    /// provide a description of the issue, along with possibly a hint on how\n+    /// to resolve it.\n     IMPROPER_CTYPES,\n     Warn,\n     \"proper use of libc types in foreign modules\"\n@@ -503,6 +586,27 @@ declare_lint! {\n declare_lint_pass!(ImproperCTypesDeclarations => [IMPROPER_CTYPES]);\n \n declare_lint! {\n+    /// The `improper_ctypes_definitions` lint detects incorrect use of\n+    /// [`extern` function] definitions.\n+    ///\n+    /// [`extern` function]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// pub extern \"C\" fn str_type(p: &str) { }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// There are many parameter and return types that may be specified in an\n+    /// `extern` function that are not compatible with the given ABI. This\n+    /// lint is an alert that these types should not be used. The lint usually\n+    /// should provide a description of the issue, along with possibly a hint\n+    /// on how to resolve it.\n     IMPROPER_CTYPES_DEFINITIONS,\n     Warn,\n     \"proper use of libc types in foreign item definitions\"\n@@ -533,6 +637,26 @@ crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: &ty::AdtD\n         .any(|a| tcx.sess.check_name(a, sym::rustc_nonnull_optimization_guaranteed))\n }\n \n+/// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n+/// field.\n+pub fn transparent_newtype_field<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    variant: &'a ty::VariantDef,\n+) -> Option<&'a ty::FieldDef> {\n+    let param_env = tcx.param_env(variant.def_id);\n+    for field in &variant.fields {\n+        let field_ty = tcx.type_of(field.did);\n+        let is_zst =\n+            tcx.layout_of(param_env.and(field_ty)).map(|layout| layout.is_zst()).unwrap_or(false);\n+\n+        if !is_zst {\n+            return Some(field);\n+        }\n+    }\n+\n+    None\n+}\n+\n /// Is type known to be non-null?\n crate fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKind) -> bool {\n     let tcx = cx.tcx;\n@@ -548,7 +672,7 @@ crate fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: C\n             }\n \n             for variant in &def.variants {\n-                if let Some(field) = variant.transparent_newtype_field(tcx) {\n+                if let Some(field) = transparent_newtype_field(cx.tcx, variant) {\n                     if ty_is_known_nonnull(cx, field.ty(tcx, substs), mode) {\n                         return true;\n                     }\n@@ -569,7 +693,7 @@ fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n         ty::Adt(field_def, field_substs) => {\n             let inner_field_ty = {\n                 let first_non_zst_ty =\n-                    field_def.variants.iter().filter_map(|v| v.transparent_newtype_field(tcx));\n+                    field_def.variants.iter().filter_map(|v| transparent_newtype_field(cx.tcx, v));\n                 debug_assert_eq!(\n                     first_non_zst_ty.clone().count(),\n                     1,\n@@ -607,7 +731,7 @@ fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n }\n \n /// Check if this enum can be safely exported based on the \"nullable pointer optimization\". If it\n-/// can, return the the type that `ty` can be safely converted to, otherwise return `None`.\n+/// can, return the type that `ty` can be safely converted to, otherwise return `None`.\n /// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n /// FIXME: This duplicates code in codegen.\n@@ -710,7 +834,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         if def.repr.transparent() {\n             // Can assume that only one field is not a ZST, so only check\n             // that field's type for FFI-safety.\n-            if let Some(field) = variant.transparent_newtype_field(self.cx.tcx) {\n+            if let Some(field) = transparent_newtype_field(self.cx.tcx, variant) {\n                 self.check_field_type_for_ffi(cache, field, substs)\n             } else {\n                 bug!(\"malformed transparent type\");"}, {"sha": "1e8c30071e762aecb5f1c06fb1c120498d58c422", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -20,13 +20,69 @@ use rustc_span::{BytePos, Span, DUMMY_SP};\n use tracing::debug;\n \n declare_lint! {\n+    /// The `unused_must_use` lint detects unused result of a type flagged as\n+    /// `#[must_use]`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn returns_result() -> Result<(), ()> {\n+    ///     Ok(())\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     returns_result();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The `#[must_use]` attribute is an indicator that it is a mistake to\n+    /// ignore the value. See [the reference] for more details.\n+    ///\n+    /// [the reference]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n     pub UNUSED_MUST_USE,\n     Warn,\n     \"unused result of a type flagged as `#[must_use]`\",\n     report_in_external_macro\n }\n \n declare_lint! {\n+    /// The `unused_results` lint checks for the unused result of an\n+    /// expression in a statement.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unused_results)]\n+    /// fn foo<T>() -> T { panic!() }\n+    ///\n+    /// fn main() {\n+    ///     foo::<usize>();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Ignoring the return value of a function may indicate a mistake. In\n+    /// cases were it is almost certain that the result should be used, it is\n+    /// recommended to annotate the function with the [`must_use` attribute].\n+    /// Failure to use such a return value will trigger the [`unused_must_use`\n+    /// lint] which is warn-by-default. The `unused_results` lint is\n+    /// essentially the same, but triggers for *all* return values.\n+    ///\n+    /// This lint is \"allow\" by default because it can be noisy, and may not be\n+    /// an actual problem. For example, calling the `remove` method of a `Vec`\n+    /// or `HashMap` returns the previous value, which you may not care about.\n+    /// Using this lint would require explicitly ignoring or discarding such\n+    /// values.\n+    ///\n+    /// [`must_use` attribute]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    /// [`unused_must_use` lint]: warn-by-default.html#unused-must-use\n     pub UNUSED_RESULTS,\n     Allow,\n     \"unused result of an expression in a statement\"\n@@ -265,6 +321,21 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n }\n \n declare_lint! {\n+    /// The `path_statements` lint detects path statements with no effect.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let x = 42;\n+    ///\n+    /// x;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is usually a mistake to have a statement that has no effect.\n     pub PATH_STATEMENTS,\n     Warn,\n     \"path statements with no effect\"\n@@ -635,6 +706,21 @@ trait UnusedDelimLint {\n }\n \n declare_lint! {\n+    /// The `unused_parens` lint detects `if`, `match`, `while` and `return`\n+    /// with parentheses; they do not need them.\n+    ///\n+    /// ### Examples\n+    ///\n+    /// ```rust\n+    /// if(true) {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The parenthesis are not needed, and should be removed. This is the\n+    /// preferred style for writing these expressions.\n     pub(super) UNUSED_PARENS,\n     Warn,\n     \"`if`, `match`, `while` and `return` do not need parentheses\"\n@@ -808,6 +894,23 @@ impl EarlyLintPass for UnusedParens {\n }\n \n declare_lint! {\n+    /// The `unused_braces` lint detects unnecessary braces around an\n+    /// expression.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// if { true } {\n+    ///     // ...\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The braces are not needed, and should be removed. This is the\n+    /// preferred style for writing these expressions.\n     pub(super) UNUSED_BRACES,\n     Warn,\n     \"unnecessary braces around an expression\"\n@@ -929,6 +1032,30 @@ impl EarlyLintPass for UnusedBraces {\n }\n \n declare_lint! {\n+    /// The `unused_import_braces` lint catches unnecessary braces around an\n+    /// imported item.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unused_import_braces)]\n+    /// use test::{A};\n+    ///\n+    /// pub mod test {\n+    ///     pub struct A;\n+    /// }\n+    /// # fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// If there is only a single item, then remove the braces (`use test::A;`\n+    /// for example).\n+    ///\n+    /// This lint is \"allow\" by default because it is only enforcing a\n+    /// stylistic choice.\n     UNUSED_IMPORT_BRACES,\n     Allow,\n     \"unnecessary braces around an imported item\"\n@@ -978,6 +1105,25 @@ impl EarlyLintPass for UnusedImportBraces {\n }\n \n declare_lint! {\n+    /// The `unused_allocation` lint detects unnecessary allocations that can\n+    /// be eliminated.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(box_syntax)]\n+    /// fn main() {\n+    ///     let a = (box [1,2,3]).len();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// When a `box` expression is immediately coerced to a reference, then\n+    /// the allocation is unnecessary, and a reference (using `&` or `&mut`)\n+    /// should be used instead to avoid the allocation.\n     pub(super) UNUSED_ALLOCATION,\n     Warn,\n     \"detects unnecessary allocations that can be eliminated\""}, {"sha": "e29af0532891f8dee55c7c2b26790fa7904eb4ef", "filename": "compiler/rustc_llvm/Cargo.toml", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,9 +4,6 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n edition = \"2018\"\n \n-[lib]\n-path = \"lib.rs\"\n-\n [features]\n static-libstdcpp = []\n emscripten = []\n@@ -15,5 +12,5 @@ emscripten = []\n libc = \"0.2.73\"\n \n [build-dependencies]\n-build_helper = { path = \"../build_helper\" }\n-cc = \"1.0.58\"\n+build_helper = { path = \"../../src/build_helper\" }\n+cc = \"1.0.60\"", "previous_filename": "src/librustc_llvm/Cargo.toml"}, {"sha": "7f1e5cf336ac414046673967de62c72864876a05", "filename": "compiler/rustc_llvm/build.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -175,15 +175,15 @@ fn main() {\n         cfg.debug(false);\n     }\n \n-    build_helper::rerun_if_changed_anything_in_dir(Path::new(\"../rustllvm\"));\n-    cfg.file(\"../rustllvm/PassWrapper.cpp\")\n-        .file(\"../rustllvm/RustWrapper.cpp\")\n-        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n-        .file(\"../rustllvm/CoverageMappingWrapper.cpp\")\n-        .file(\"../rustllvm/Linker.cpp\")\n+    build_helper::rerun_if_changed_anything_in_dir(Path::new(\"llvm-wrapper\"));\n+    cfg.file(\"llvm-wrapper/PassWrapper.cpp\")\n+        .file(\"llvm-wrapper/RustWrapper.cpp\")\n+        .file(\"llvm-wrapper/ArchiveWrapper.cpp\")\n+        .file(\"llvm-wrapper/CoverageMappingWrapper.cpp\")\n+        .file(\"llvm-wrapper/Linker.cpp\")\n         .cpp(true)\n         .cpp_link_stdlib(None) // we handle this below\n-        .compile(\"rustllvm\");\n+        .compile(\"llvm-wrapper\");\n \n     let (llvm_kind, llvm_link_arg) = detect_llvm_link();\n \n@@ -259,7 +259,7 @@ fn main() {\n     }\n \n     // Some LLVM linker flags (-L and -l) may be needed even when linking\n-    // librustc_llvm, for example when using static libc++, we may need to\n+    // rustc_llvm, for example when using static libc++, we may need to\n     // manually specify the library search path and -ldl -lpthread as link\n     // dependencies.\n     let llvm_linker_flags = tracked_env_var_os(\"LLVM_LINKER_FLAGS\");", "previous_filename": "src/librustc_llvm/build.rs"}, {"sha": "865cd45f708fb4034a6d2d59a305d5a93a0488ae", "filename": "compiler/rustc_llvm/llvm-wrapper/.editorconfig", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2F.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2F.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2F.editorconfig?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "previous_filename": "src/rustllvm/.editorconfig"}, {"sha": "2797fe8df4a8e0460f7899aa5ba2c342ed593b64", "filename": "compiler/rustc_llvm/llvm-wrapper/ArchiveWrapper.cpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FArchiveWrapper.cpp?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,4 +1,4 @@\n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n \n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ArchiveWriter.h\"", "previous_filename": "src/rustllvm/ArchiveWrapper.cpp"}, {"sha": "2b1143a4ecff54ab6b79a737a2ddf54b269b75e2", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,4 +1,4 @@\n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n #include \"llvm/ProfileData/Coverage/CoverageMapping.h\"\n #include \"llvm/ProfileData/Coverage/CoverageMappingWriter.h\"\n #include \"llvm/ProfileData/InstrProf.h\"", "previous_filename": "src/rustllvm/CoverageMappingWrapper.cpp"}, {"sha": "57b8664d3b6058d1050790354cb0a5fc89cc16ca", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "previous_filename": "src/rustllvm/rustllvm.h"}, {"sha": "8766e96f086d2e845ae8b07a9afdb3bc40570598", "filename": "compiler/rustc_llvm/llvm-wrapper/Linker.cpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLinker.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLinker.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLinker.cpp?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,6 +1,6 @@\n #include \"llvm/Linker/Linker.h\"\n \n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n \n using namespace llvm;\n ", "previous_filename": "src/rustllvm/Linker.cpp"}, {"sha": "7b1c3f9ba2c686c2600d6e8bee08b558280744cd", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -3,7 +3,7 @@\n #include <vector>\n #include <set>\n \n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n \n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n #include \"llvm/Analysis/TargetTransformInfo.h\"", "previous_filename": "src/rustllvm/PassWrapper.cpp"}, {"sha": "e1c6dd07d2b3856a5a2050a8551474123f7a56c3", "filename": "compiler/rustc_llvm/llvm-wrapper/README", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FREADME?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "previous_filename": "src/rustllvm/README"}, {"sha": "9f8ea7f43d84bcc6ec6e9a9842bbe858a6017d46", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,4 +1,4 @@\n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n #include \"llvm/IR/DebugInfoMetadata.h\"\n #include \"llvm/IR/DiagnosticInfo.h\"\n #include \"llvm/IR/DiagnosticPrinter.h\"\n@@ -1171,6 +1171,7 @@ enum class LLVMRustDiagnosticKind {\n   OptimizationFailure,\n   PGOProfile,\n   Linker,\n+  Unsupported,\n };\n \n static LLVMRustDiagnosticKind toRust(DiagnosticKind Kind) {\n@@ -1197,6 +1198,8 @@ static LLVMRustDiagnosticKind toRust(DiagnosticKind Kind) {\n     return LLVMRustDiagnosticKind::PGOProfile;\n   case DK_Linker:\n     return LLVMRustDiagnosticKind::Linker;\n+  case DK_Unsupported:\n+    return LLVMRustDiagnosticKind::Unsupported;\n   default:\n     return (Kind >= DK_FirstRemark && Kind <= DK_LastRemark)\n                ? LLVMRustDiagnosticKind::OptimizationRemarkOther", "previous_filename": "src/rustllvm/RustWrapper.cpp"}, {"sha": "a381290d46f97362974270c4409b8685f60715e2", "filename": "compiler/rustc_llvm/src/lib.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,6 +1,6 @@\n #![feature(nll)]\n #![feature(static_nobundle)]\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n \n // NOTE: This crate only exists to allow linking on mingw targets.\n \n@@ -21,7 +21,6 @@ impl RustString {\n \n /// Appending to a Rust string -- used by RawRustStringOstream.\n #[no_mangle]\n-#[allow(improper_ctypes_definitions)]\n pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(\n     sr: &RustString,\n     ptr: *const c_char,", "previous_filename": "src/librustc_llvm/lib.rs"}, {"sha": "5c28839c9b7e4a3249d958a89aa39d7a70fe84e2", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,3 +1,4 @@\n+#![feature(proc_macro_diagnostic)]\n #![allow(rustc::default_hash_types)]\n #![recursion_limit = \"128\"]\n \n@@ -9,6 +10,7 @@ mod hash_stable;\n mod lift;\n mod query;\n mod serialize;\n+mod session_diagnostic;\n mod symbols;\n mod type_foldable;\n \n@@ -36,3 +38,14 @@ decl_derive!([MetadataDecodable] => serialize::meta_decodable_derive);\n decl_derive!([MetadataEncodable] => serialize::meta_encodable_derive);\n decl_derive!([TypeFoldable, attributes(type_foldable)] => type_foldable::type_foldable_derive);\n decl_derive!([Lift, attributes(lift)] => lift::lift_derive);\n+decl_derive!(\n+    [SessionDiagnostic, attributes(\n+        message,\n+        lint,\n+        error,\n+        label,\n+        suggestion,\n+        suggestion_short,\n+        suggestion_hidden,\n+        suggestion_verbose)] => session_diagnostic::session_diagnostic_derive\n+);"}, {"sha": "e7c054653accbd81de47e37af896a3cb0d71cd8d", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -5,11 +5,10 @@ use syn::parse::{Parse, ParseStream, Result};\n use syn::punctuated::Punctuated;\n use syn::spanned::Spanned;\n use syn::{\n-    braced, parenthesized, parse_macro_input, Attribute, Block, Error, Expr, Ident, ReturnType,\n-    Token, Type,\n+    braced, parenthesized, parse_macro_input, AttrStyle, Attribute, Block, Error, Expr, Ident,\n+    ReturnType, Token, Type,\n };\n \n-#[allow(non_camel_case_types)]\n mod kw {\n     syn::custom_keyword!(query);\n }\n@@ -128,17 +127,25 @@ impl Parse for QueryModifier {\n }\n \n /// Ensures only doc comment attributes are used\n-fn check_attributes(attrs: Vec<Attribute>) -> Result<()> {\n-    for attr in attrs {\n+fn check_attributes(attrs: Vec<Attribute>) -> Result<Vec<Attribute>> {\n+    let inner = |attr: Attribute| {\n         if !attr.path.is_ident(\"doc\") {\n-            return Err(Error::new(attr.span(), \"attributes not supported on queries\"));\n+            Err(Error::new(attr.span(), \"attributes not supported on queries\"))\n+        } else if attr.style != AttrStyle::Outer {\n+            Err(Error::new(\n+                attr.span(),\n+                \"attributes must be outer attributes (`///`), not inner attributes\",\n+            ))\n+        } else {\n+            Ok(attr)\n         }\n-    }\n-    Ok(())\n+    };\n+    attrs.into_iter().map(inner).collect()\n }\n \n /// A compiler query. `query ... { ... }`\n struct Query {\n+    doc_comments: Vec<Attribute>,\n     modifiers: List<QueryModifier>,\n     name: Ident,\n     key: IdentOrWild,\n@@ -148,7 +155,7 @@ struct Query {\n \n impl Parse for Query {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        check_attributes(input.call(Attribute::parse_outer)?)?;\n+        let doc_comments = check_attributes(input.call(Attribute::parse_outer)?)?;\n \n         // Parse the query declaration. Like `query type_of(key: DefId) -> Ty<'tcx>`\n         input.parse::<kw::query>()?;\n@@ -165,7 +172,7 @@ impl Parse for Query {\n         braced!(content in input);\n         let modifiers = content.parse()?;\n \n-        Ok(Query { modifiers, name, key, arg, result })\n+        Ok(Query { doc_comments, modifiers, name, key, arg, result })\n     }\n }\n \n@@ -476,9 +483,10 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             };\n \n             let attribute_stream = quote! {#(#attributes),*};\n-\n+            let doc_comments = query.doc_comments.iter();\n             // Add the query to the group\n             group_stream.extend(quote! {\n+                #(#doc_comments)*\n                 [#attribute_stream] fn #name: #name(#arg) #result,\n             });\n "}, {"sha": "610b9155cfc182059d58a39901bd3be03dd46585", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,666 @@\n+#![deny(unused_must_use)]\n+use proc_macro::Diagnostic;\n+use quote::{format_ident, quote};\n+use syn::spanned::Spanned;\n+\n+use std::collections::{BTreeSet, HashMap};\n+\n+/// Implements #[derive(SessionDiagnostic)], which allows for errors to be specified as a struct, independent\n+/// from the actual diagnostics emitting code.\n+/// ```ignore (pseudo-rust)\n+/// # extern crate rustc_errors;\n+/// # use rustc_errors::Applicability;\n+/// # extern crate rustc_span;\n+/// # use rustc_span::{symbol::Ident, Span};\n+/// # extern crate rust_middle;\n+/// # use rustc_middle::ty::Ty;\n+/// #[derive(SessionDiagnostic)]\n+/// #[code = \"E0505\"]\n+/// #[error = \"cannot move out of {name} because it is borrowed\"]\n+/// pub struct MoveOutOfBorrowError<'tcx> {\n+///     pub name: Ident,\n+///     pub ty: Ty<'tcx>,\n+///     #[label = \"cannot move out of borrow\"]\n+///     pub span: Span,\n+///     #[label = \"`{ty}` first borrowed here\"]\n+///     pub other_span: Span,\n+///     #[suggestion(message = \"consider cloning here\", code = \"{name}.clone()\")]\n+///     pub opt_sugg: Option<(Span, Applicability)>\n+/// }\n+/// ```\n+/// Then, later, to emit the error:\n+///\n+/// ```ignore (pseudo-rust)\n+/// sess.emit_err(MoveOutOfBorrowError {\n+///     expected,\n+///     actual,\n+///     span,\n+///     other_span,\n+///     opt_sugg: Some(suggestion, Applicability::MachineApplicable),\n+/// });\n+/// ```\n+pub fn session_diagnostic_derive(s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    // Names for the diagnostic we build and the session we build it from.\n+    let diag = format_ident!(\"diag\");\n+    let sess = format_ident!(\"sess\");\n+\n+    SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n+}\n+\n+// Checks whether the type name of `ty` matches `name`.\n+//\n+// Given some struct at a::b::c::Foo, this will return true for c::Foo, b::c::Foo, or\n+// a::b::c::Foo. This reasonably allows qualified names to be used in the macro.\n+fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n+    if let syn::Type::Path(ty) = ty {\n+        ty.path\n+            .segments\n+            .iter()\n+            .map(|s| s.ident.to_string())\n+            .rev()\n+            .zip(name.iter().rev())\n+            .all(|(x, y)| &x.as_str() == y)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// The central struct for constructing the as_error method from an annotated struct.\n+struct SessionDiagnosticDerive<'a> {\n+    structure: synstructure::Structure<'a>,\n+    builder: SessionDiagnosticDeriveBuilder<'a>,\n+}\n+\n+impl std::convert::From<syn::Error> for SessionDiagnosticDeriveError {\n+    fn from(e: syn::Error) -> Self {\n+        SessionDiagnosticDeriveError::SynError(e)\n+    }\n+}\n+\n+/// Equivalent to rustc:errors::diagnostic::DiagnosticId, except stores the quoted expression to\n+/// initialise the code with.\n+enum DiagnosticId {\n+    Error(proc_macro2::TokenStream),\n+    Lint(proc_macro2::TokenStream),\n+}\n+\n+#[derive(Debug)]\n+enum SessionDiagnosticDeriveError {\n+    SynError(syn::Error),\n+    ErrorHandled,\n+}\n+\n+impl SessionDiagnosticDeriveError {\n+    fn to_compile_error(self) -> proc_macro2::TokenStream {\n+        match self {\n+            SessionDiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n+            SessionDiagnosticDeriveError::ErrorHandled => {\n+                // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n+                // error has already been emitted to the compiler.\n+                quote! {\n+                    unreachable!()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn span_err(span: impl proc_macro::MultiSpan, msg: &str) -> proc_macro::Diagnostic {\n+    Diagnostic::spanned(span, proc_macro::Level::Error, msg)\n+}\n+\n+/// For methods that return a Result<_, SessionDiagnosticDeriveError>: emit a diagnostic on\n+/// span $span with msg $msg (and, optionally, perform additional decoration using the FnOnce\n+/// passed in `diag`). Then, return Err(ErrorHandled).\n+macro_rules! throw_span_err {\n+    ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n+    ($span:expr, $msg:expr, $f:expr) => {{\n+        return Err(_throw_span_err($span, $msg, $f));\n+    }};\n+}\n+\n+/// When possible, prefer using throw_span_err! over using this function directly. This only exists\n+/// as a function to constrain `f` to an impl FnOnce.\n+fn _throw_span_err(\n+    span: impl proc_macro::MultiSpan,\n+    msg: &str,\n+    f: impl FnOnce(proc_macro::Diagnostic) -> proc_macro::Diagnostic,\n+) -> SessionDiagnosticDeriveError {\n+    let diag = span_err(span, msg);\n+    f(diag).emit();\n+    SessionDiagnosticDeriveError::ErrorHandled\n+}\n+\n+impl<'a> SessionDiagnosticDerive<'a> {\n+    fn new(diag: syn::Ident, sess: syn::Ident, structure: synstructure::Structure<'a>) -> Self {\n+        // Build the mapping of field names to fields. This allows attributes to peek values from\n+        // other fields.\n+        let mut fields_map = HashMap::new();\n+\n+        // Convenience bindings.\n+        let ast = structure.ast();\n+\n+        if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n+            for field in fields.iter() {\n+                if let Some(ident) = &field.ident {\n+                    fields_map.insert(ident.to_string(), field);\n+                }\n+            }\n+        }\n+\n+        Self {\n+            builder: SessionDiagnosticDeriveBuilder { diag, sess, fields: fields_map, kind: None },\n+            structure,\n+        }\n+    }\n+    fn into_tokens(self) -> proc_macro2::TokenStream {\n+        let SessionDiagnosticDerive { structure, mut builder } = self;\n+\n+        let ast = structure.ast();\n+        let attrs = &ast.attrs;\n+\n+        let implementation = {\n+            if let syn::Data::Struct(..) = ast.data {\n+                let preamble = {\n+                    let preamble = attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_structure_code(attr)\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+                    quote! {\n+                        #(#preamble)*;\n+                    }\n+                };\n+\n+                let body = structure.each(|field_binding| {\n+                    let field = field_binding.ast();\n+                    let result = field.attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_field_code(\n+                                attr,\n+                                FieldInfo {\n+                                    vis: &field.vis,\n+                                    binding: field_binding,\n+                                    ty: &field.ty,\n+                                    span: &field.span(),\n+                                },\n+                            )\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+                    return quote! {\n+                        #(#result);*\n+                    };\n+                });\n+                // Finally, putting it altogether.\n+                match builder.kind {\n+                    None => {\n+                        span_err(ast.span().unwrap(), \"`code` not specified\")\n+                        .help(\"use the [code = \\\"...\\\"] attribute to set this diagnostic's error code \")\n+                        .emit();\n+                        SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+                    }\n+                    Some((kind, _)) => match kind {\n+                        DiagnosticId::Lint(_lint) => todo!(),\n+                        DiagnosticId::Error(code) => {\n+                            let (diag, sess) = (&builder.diag, &builder.sess);\n+                            quote! {\n+                                let mut #diag = #sess.struct_err_with_code(\"\", rustc_errors::DiagnosticId::Error(#code));\n+                                #preamble\n+                                match self {\n+                                    #body\n+                                }\n+                                #diag\n+                            }\n+                        }\n+                    },\n+                }\n+            } else {\n+                span_err(\n+                    ast.span().unwrap(),\n+                    \"`#[derive(SessionDiagnostic)]` can only be used on structs\",\n+                )\n+                .emit();\n+                SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+            }\n+        };\n+\n+        let sess = &builder.sess;\n+        structure.gen_impl(quote! {\n+            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess>\n+                    for @Self\n+            {\n+                fn into_diagnostic(\n+                    self,\n+                    #sess: &'__session_diagnostic_sess rustc_session::Session\n+                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess> {\n+                    #implementation\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// Field information passed to the builder. Deliberately omits attrs to discourage the generate_*\n+/// methods from walking the attributes themselves.\n+struct FieldInfo<'a> {\n+    vis: &'a syn::Visibility,\n+    binding: &'a synstructure::BindingInfo<'a>,\n+    ty: &'a syn::Type,\n+    span: &'a proc_macro2::Span,\n+}\n+\n+/// Tracks persistent information required for building up the individual calls to diagnostic\n+/// methods for the final generated method. This is a separate struct to SessionDerive only to be\n+/// able to destructure and split self.builder and the self.structure up to avoid a double mut\n+/// borrow later on.\n+struct SessionDiagnosticDeriveBuilder<'a> {\n+    /// Name of the session parameter that's passed in to the as_error method.\n+    sess: syn::Ident,\n+\n+    /// Store a map of field name to its corresponding field. This is built on construction of the\n+    /// derive builder.\n+    fields: HashMap<String, &'a syn::Field>,\n+\n+    /// The identifier to use for the generated DiagnosticBuilder instance.\n+    diag: syn::Ident,\n+\n+    /// Whether this is a lint or an error. This dictates how the diag will be initialised. Span\n+    /// stores at what Span the kind was first set at (for error reporting purposes, if the kind\n+    /// was multiply specified).\n+    kind: Option<(DiagnosticId, proc_macro2::Span)>,\n+}\n+\n+impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n+    fn generate_structure_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        Ok(match attr.parse_meta()? {\n+            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                let formatted_str = self.build_format(&s.value(), attr.span());\n+                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = name.as_str();\n+                match name {\n+                    \"message\" => {\n+                        let diag = &self.diag;\n+                        quote! {\n+                            #diag.set_primary_message(#formatted_str);\n+                        }\n+                    }\n+                    attr @ \"error\" | attr @ \"lint\" => {\n+                        self.set_kind_once(\n+                            if attr == \"error\" {\n+                                DiagnosticId::Error(formatted_str)\n+                            } else if attr == \"lint\" {\n+                                DiagnosticId::Lint(formatted_str)\n+                            } else {\n+                                unreachable!()\n+                            },\n+                            s.span(),\n+                        )?;\n+                        // This attribute is only allowed to be applied once, and the attribute\n+                        // will be set in the initialisation code.\n+                        quote! {}\n+                    }\n+                    other => throw_span_err!(\n+                        attr.span().unwrap(),\n+                        &format!(\n+                            \"`#[{} = ...]` is not a valid SessionDiagnostic struct attribute\",\n+                            other\n+                        )\n+                    ),\n+                }\n+            }\n+            _ => todo!(\"unhandled meta kind\"),\n+        })\n+    }\n+\n+    #[must_use]\n+    fn set_kind_once(\n+        &mut self,\n+        kind: DiagnosticId,\n+        span: proc_macro2::Span,\n+    ) -> Result<(), SessionDiagnosticDeriveError> {\n+        if self.kind.is_none() {\n+            self.kind = Some((kind, span));\n+            Ok(())\n+        } else {\n+            let kind_str = |kind: &DiagnosticId| match kind {\n+                DiagnosticId::Lint(..) => \"lint\",\n+                DiagnosticId::Error(..) => \"error\",\n+            };\n+\n+            let existing_kind = kind_str(&self.kind.as_ref().unwrap().0);\n+            let this_kind = kind_str(&kind);\n+\n+            let msg = if this_kind == existing_kind {\n+                format!(\"`{}` specified multiple times\", existing_kind)\n+            } else {\n+                format!(\"`{}` specified when `{}` was already specified\", this_kind, existing_kind)\n+            };\n+            throw_span_err!(span.unwrap(), &msg);\n+        }\n+    }\n+\n+    fn generate_field_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        let field_binding = &info.binding.binding;\n+\n+        let option_ty = option_inner_ty(&info.ty);\n+\n+        let generated_code = self.generate_non_option_field_code(\n+            attr,\n+            FieldInfo {\n+                vis: info.vis,\n+                binding: info.binding,\n+                ty: option_ty.unwrap_or(&info.ty),\n+                span: info.span,\n+            },\n+        )?;\n+        Ok(if option_ty.is_none() {\n+            quote! { #generated_code }\n+        } else {\n+            quote! {\n+                if let Some(#field_binding) = #field_binding {\n+                    #generated_code\n+                }\n+            }\n+        })\n+    }\n+\n+    fn generate_non_option_field_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        let diag = &self.diag;\n+        let field_binding = &info.binding.binding;\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        // At this point, we need to dispatch based on the attribute key + the\n+        // type.\n+        let meta = attr.parse_meta()?;\n+        Ok(match meta {\n+            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                let formatted_str = self.build_format(&s.value(), attr.span());\n+                match name {\n+                    \"message\" => {\n+                        if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                            quote! {\n+                                #diag.set_span(*#field_binding);\n+                                #diag.set_primary_message(#formatted_str);\n+                            }\n+                        } else {\n+                            throw_span_err!(\n+                                attr.span().unwrap(),\n+                                \"the `#[message = \\\"...\\\"]` attribute can only be applied to fields of type Span\"\n+                            );\n+                        }\n+                    }\n+                    \"label\" => {\n+                        if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                            quote! {\n+                                #diag.span_label(*#field_binding, #formatted_str);\n+                            }\n+                        } else {\n+                            throw_span_err!(\n+                                attr.span().unwrap(),\n+                                \"The `#[label = ...]` attribute can only be applied to fields of type Span\"\n+                            );\n+                        }\n+                    }\n+                    other => throw_span_err!(\n+                        attr.span().unwrap(),\n+                        &format!(\n+                            \"`#[{} = ...]` is not a valid SessionDiagnostic field attribute\",\n+                            other\n+                        )\n+                    ),\n+                }\n+            }\n+            syn::Meta::List(list) => {\n+                match list.path.segments.iter().last().unwrap().ident.to_string().as_str() {\n+                    suggestion_kind @ \"suggestion\"\n+                    | suggestion_kind @ \"suggestion_short\"\n+                    | suggestion_kind @ \"suggestion_hidden\"\n+                    | suggestion_kind @ \"suggestion_verbose\" => {\n+                        // For suggest, we need to ensure we are running on a (Span,\n+                        // Applicability) pair.\n+                        let (span, applicability) = (|| match &info.ty {\n+                            ty @ syn::Type::Path(..)\n+                                if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) =>\n+                            {\n+                                let binding = &info.binding.binding;\n+                                Ok((\n+                                    quote!(*#binding),\n+                                    quote!(rustc_errors::Applicability::Unspecified),\n+                                ))\n+                            }\n+                            syn::Type::Tuple(tup) => {\n+                                let mut span_idx = None;\n+                                let mut applicability_idx = None;\n+                                for (idx, elem) in tup.elems.iter().enumerate() {\n+                                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n+                                        if span_idx.is_none() {\n+                                            span_idx = Some(syn::Index::from(idx));\n+                                        } else {\n+                                            throw_span_err!(\n+                                                info.span.clone().unwrap(),\n+                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Span\"\n+                                            );\n+                                        }\n+                                    } else if type_matches_path(\n+                                        elem,\n+                                        &[\"rustc_errors\", \"Applicability\"],\n+                                    ) {\n+                                        if applicability_idx.is_none() {\n+                                            applicability_idx = Some(syn::Index::from(idx));\n+                                        } else {\n+                                            throw_span_err!(\n+                                                info.span.clone().unwrap(),\n+                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n+                                            );\n+                                        }\n+                                    }\n+                                }\n+                                if let Some(span_idx) = span_idx {\n+                                    let binding = &info.binding.binding;\n+                                    let span = quote!(#binding.#span_idx);\n+                                    let applicability = applicability_idx\n+                                        .map(\n+                                            |applicability_idx| quote!(#binding.#applicability_idx),\n+                                        )\n+                                        .unwrap_or(quote!(\n+                                            rustc_errors::Applicability::Unspecified\n+                                        ));\n+                                    return Ok((span, applicability));\n+                                }\n+                                throw_span_err!(\n+                                    info.span.clone().unwrap(),\n+                                    \"wrong types for suggestion\",\n+                                    |diag| {\n+                                        diag.help(\"#[suggestion(...)] on a tuple field must be applied to fields of type (Span, Applicability)\")\n+                                    }\n+                                );\n+                            }\n+                            _ => throw_span_err!(\n+                                info.span.clone().unwrap(),\n+                                \"wrong field type for suggestion\",\n+                                |diag| {\n+                                    diag.help(\"#[suggestion(...)] should be applied to fields of type Span or (Span, Applicability)\")\n+                                }\n+                            ),\n+                        })()?;\n+                        // Now read the key-value pairs.\n+                        let mut msg = None;\n+                        let mut code = None;\n+\n+                        for arg in list.nested.iter() {\n+                            if let syn::NestedMeta::Meta(syn::Meta::NameValue(arg_name_value)) = arg\n+                            {\n+                                if let syn::MetaNameValue { lit: syn::Lit::Str(s), .. } =\n+                                    arg_name_value\n+                                {\n+                                    let name = arg_name_value\n+                                        .path\n+                                        .segments\n+                                        .last()\n+                                        .unwrap()\n+                                        .ident\n+                                        .to_string();\n+                                    let name = name.as_str();\n+                                    let formatted_str = self.build_format(&s.value(), arg.span());\n+                                    match name {\n+                                        \"message\" => {\n+                                            msg = Some(formatted_str);\n+                                        }\n+                                        \"code\" => {\n+                                            code = Some(formatted_str);\n+                                        }\n+                                        other => throw_span_err!(\n+                                            arg.span().unwrap(),\n+                                            &format!(\n+                                                \"`{}` is not a valid key for `#[suggestion(...)]`\",\n+                                                other\n+                                            )\n+                                        ),\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        let msg = if let Some(msg) = msg {\n+                            quote!(#msg.as_str())\n+                        } else {\n+                            throw_span_err!(\n+                                list.span().unwrap(),\n+                                \"missing suggestion message\",\n+                                |diag| {\n+                                    diag.help(\"provide a suggestion message using #[suggestion(message = \\\"...\\\")]\")\n+                                }\n+                            );\n+                        };\n+                        let code = code.unwrap_or_else(|| quote! { String::new() });\n+                        // Now build it out:\n+                        let suggestion_method = format_ident!(\"span_{}\", suggestion_kind);\n+                        quote! {\n+                            #diag.#suggestion_method(#span, #msg, #code, #applicability);\n+                        }\n+                    }\n+                    other => throw_span_err!(\n+                        list.span().unwrap(),\n+                        &format!(\"invalid annotation list `#[{}(...)]`\", other)\n+                    ),\n+                }\n+            }\n+            _ => panic!(\"unhandled meta kind\"),\n+        })\n+    }\n+\n+    /// In the strings in the attributes supplied to this macro, we want callers to be able to\n+    /// reference fields in the format string. Take this, for example:\n+    /// ```ignore (not-usage-example)\n+    /// struct Point {\n+    ///     #[error = \"Expected a point greater than ({x}, {y})\"]\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    /// ```\n+    /// We want to automatically pick up that {x} refers `self.x` and {y} refers to `self.y`, then\n+    /// generate this call to format!:\n+    /// ```ignore (not-usage-example)\n+    /// format!(\"Expected a point greater than ({x}, {y})\", x = self.x, y = self.y)\n+    /// ```\n+    /// This function builds the entire call to format!.\n+    fn build_format(&self, input: &String, span: proc_macro2::Span) -> proc_macro2::TokenStream {\n+        // This set is used later to generate the final format string. To keep builds reproducible,\n+        // the iteration order needs to be deterministic, hence why we use a BTreeSet here instead\n+        // of a HashSet.\n+        let mut referenced_fields: BTreeSet<String> = BTreeSet::new();\n+\n+        // At this point, we can start parsing the format string.\n+        let mut it = input.chars().peekable();\n+        // Once the start of a format string has been found, process the format string and spit out\n+        // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so the\n+        // next call to `it.next()` retrieves the next character.\n+        while let Some(c) = it.next() {\n+            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n+                #[must_use]\n+                let mut eat_argument = || -> Option<String> {\n+                    let mut result = String::new();\n+                    // Format specifiers look like\n+                    // format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n+                    while let Some(c) = it.next() {\n+                        result.push(c);\n+                        let next = *it.peek().unwrap_or(&'\\0');\n+                        if next == '}' {\n+                            break;\n+                        } else if next == ':' {\n+                            // Eat the ':' character.\n+                            assert_eq!(it.next().unwrap(), ':');\n+                            break;\n+                        }\n+                    }\n+                    // Eat until (and including) the matching '}'\n+                    while it.next()? != '}' {\n+                        continue;\n+                    }\n+                    Some(result)\n+                };\n+\n+                if let Some(referenced_field) = eat_argument() {\n+                    referenced_fields.insert(referenced_field);\n+                }\n+            }\n+        }\n+        // At this point, `referenced_fields` contains a set of the unique fields that were\n+        // referenced in the format string. Generate the corresponding \"x = self.x\" format\n+        // string parameters:\n+        let args = referenced_fields.into_iter().map(|field: String| {\n+            let field_ident = format_ident!(\"{}\", field);\n+            let value = if self.fields.contains_key(&field) {\n+                quote! {\n+                    &self.#field_ident\n+                }\n+            } else {\n+                // This field doesn't exist. Emit a diagnostic.\n+                Diagnostic::spanned(\n+                    span.unwrap(),\n+                    proc_macro::Level::Error,\n+                    format!(\"`{}` doesn't refer to a field on this type\", field),\n+                )\n+                .emit();\n+                quote! {\n+                    \"{#field}\"\n+                }\n+            };\n+            quote! {\n+                #field_ident = #value\n+            }\n+        });\n+        quote! {\n+            format!(#input #(,#args)*)\n+        }\n+    }\n+}\n+\n+/// If `ty` is an Option, returns Some(inner type). Else, returns None.\n+fn option_inner_ty(ty: &syn::Type) -> Option<&syn::Type> {\n+    if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+        if let syn::Type::Path(ty_path) = ty {\n+            let path = &ty_path.path;\n+            let ty = path.segments.iter().last().unwrap();\n+            if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n+                if bracketed.args.len() == 1 {\n+                    if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n+                        return Some(ty);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    None\n+}"}, {"sha": "94d4ad78e8d90373d748e8adaa1476e1002f1453", "filename": "compiler/rustc_macros/src/symbols.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,7 +4,6 @@ use std::collections::HashSet;\n use syn::parse::{Parse, ParseStream, Result};\n use syn::{braced, parse_macro_input, Ident, LitStr, Token};\n \n-#[allow(non_camel_case_types)]\n mod kw {\n     syn::custom_keyword!(Keywords);\n     syn::custom_keyword!(Symbols);"}, {"sha": "f1975e78801ef9ba54d6b03a784fccef39405e4b", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -17,6 +17,7 @@ rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n+rustc_feature = { path = \"../rustc_feature\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "77766be7397c7468306b1beb3f5a974045a3b4f3", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,4 +1,4 @@\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(core_intrinsics)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "e76c2cb356f3f19b8dc6508f1a46e37bd3e44928", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -170,7 +170,7 @@ impl Collector<'tcx> {\n             feature_err(\n                 &self.tcx.sess.parse_sess,\n                 sym::static_nobundle,\n-                span.unwrap_or_else(|| rustc_span::DUMMY_SP),\n+                span.unwrap_or(rustc_span::DUMMY_SP),\n                 \"kind=\\\"static-nobundle\\\" is unstable\",\n             )\n             .emit();\n@@ -179,7 +179,7 @@ impl Collector<'tcx> {\n             feature_err(\n                 &self.tcx.sess.parse_sess,\n                 sym::raw_dylib,\n-                span.unwrap_or_else(|| rustc_span::DUMMY_SP),\n+                span.unwrap_or(rustc_span::DUMMY_SP),\n                 \"kind=\\\"raw-dylib\\\" is unstable\",\n             )\n             .emit();"}, {"sha": "c31e941b3ffc60677e17dbfccb94aa3730793f3d", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 58, "deletions": 18, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -11,6 +11,7 @@ use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, OnceCell};\n+use rustc_errors::ErrorReported;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n@@ -562,6 +563,12 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n     }\n }\n \n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        ty::codec::RefDecodable::decode(d)\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n         ty::codec::RefDecodable::decode(d)\n@@ -700,7 +707,11 @@ impl CrateRoot<'_> {\n \n impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n-        self.root.proc_macro_data.and_then(|data| data.decode(self).find(|x| *x == id)).is_some()\n+        self.root\n+            .proc_macro_data\n+            .as_ref()\n+            .and_then(|data| data.macros.decode(self).find(|x| *x == id))\n+            .is_some()\n     }\n \n     fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n@@ -722,7 +733,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n-        let pos = self.root.proc_macro_data.unwrap().decode(self).position(|i| i == id).unwrap();\n+        let pos = self\n+            .root\n+            .proc_macro_data\n+            .as_ref()\n+            .unwrap()\n+            .macros\n+            .decode(self)\n+            .position(|i| i == id)\n+            .unwrap();\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n@@ -759,7 +778,12 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        self.root.tables.span.get(self, index).unwrap().decode((self, sess))\n+        self.root\n+            .tables\n+            .span\n+            .get(self, index)\n+            .unwrap_or_else(|| panic!(\"Missing span for {:?}\", index))\n+            .decode((self, sess))\n     }\n \n     fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n@@ -935,7 +959,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n-            true => self.root.proc_macro_stability,\n+            true => self.root.proc_macro_data.as_ref().unwrap().stability,\n             false => self.root.tables.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n@@ -1028,24 +1052,20 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     where\n         F: FnMut(Export<hir::HirId>),\n     {\n-        if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n+        if let Some(data) = &self.root.proc_macro_data {\n             /* If we are loading as a proc macro, we want to return the view of this crate\n              * as a proc macro crate.\n              */\n             if id == CRATE_DEF_INDEX {\n-                for def_index in proc_macros_ids {\n+                let macros = data.macros.decode(self);\n+                for def_index in macros {\n                     let raw_macro = self.raw_proc_macro(def_index);\n                     let res = Res::Def(\n                         DefKind::Macro(macro_kind(raw_macro)),\n                         self.local_def_id(def_index),\n                     );\n                     let ident = self.item_ident(def_index, sess);\n-                    callback(Export {\n-                        ident,\n-                        res,\n-                        vis: ty::Visibility::Public,\n-                        span: self.get_span(def_index, sess),\n-                    });\n+                    callback(Export { ident, res, vis: ty::Visibility::Public, span: ident.span });\n                 }\n             }\n             return;\n@@ -1191,6 +1211,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n+    fn get_mir_abstract_const(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        id: DefIndex,\n+    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+        self.root\n+            .tables\n+            .mir_abstract_consts\n+            .get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n+            .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n+    }\n+\n     fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u32> {\n         self.root\n             .tables\n@@ -1539,12 +1572,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn all_def_path_hashes_and_def_ids(&self) -> Vec<(DefPathHash, DefId)> {\n         let mut def_path_hashes = self.def_path_hash_cache.lock();\n-        (0..self.num_def_ids())\n-            .map(|index| {\n-                let index = DefIndex::from_usize(index);\n-                (self.def_path_hash_unlocked(index, &mut def_path_hashes), self.local_def_id(index))\n-            })\n-            .collect()\n+        let mut def_index_to_data = |index| {\n+            (self.def_path_hash_unlocked(index, &mut def_path_hashes), self.local_def_id(index))\n+        };\n+        if let Some(data) = &self.root.proc_macro_data {\n+            std::iter::once(CRATE_DEF_INDEX)\n+                .chain(data.macros.decode(self))\n+                .map(def_index_to_data)\n+                .collect()\n+        } else {\n+            (0..self.num_def_ids())\n+                .map(|index| def_index_to_data(DefIndex::from_usize(index)))\n+                .collect()\n+        }\n     }\n \n     /// Get the `DepNodeIndex` corresponding this crate. The result of this"}, {"sha": "4102cf84a67756f8df0d0b88f9e95bf82a6f41df", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::{CrateDisambiguator, Session};\n-use rustc_span::source_map::{self, Span, Spanned};\n+use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::Symbol;\n \n use rustc_data_structures::sync::Lrc;\n@@ -112,6 +112,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n     promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n+    mir_abstract_const => { cdata.get_mir_abstract_const(tcx, def_id.index) }\n     unused_generic_params => { cdata.get_unused_generic_params(def_id.index) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n@@ -178,8 +179,11 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         })\n     }\n     proc_macro_decls_static => {\n-        cdata.root.proc_macro_decls_static.map(|index| {\n-            DefId { krate: def_id.krate, index }\n+        cdata.root.proc_macro_data.as_ref().map(|data| {\n+            DefId {\n+                krate: def_id.krate,\n+                index: data.proc_macro_decls_static,\n+            }\n         })\n     }\n     crate_disambiguator => { cdata.root.disambiguator }\n@@ -421,7 +425,11 @@ impl CStore {\n                 span,\n                 attrs: attrs.to_vec(),\n                 kind: ast::ItemKind::MacroDef(data.get_macro(id.index, sess)),\n-                vis: source_map::respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+                vis: ast::Visibility {\n+                    span: span.shrink_to_lo(),\n+                    kind: ast::VisibilityKind::Inherited,\n+                    tokens: None,\n+                },\n                 tokens: None,\n             },\n             data.root.edition,"}, {"sha": "f58a792ef585ee28a3576b3d2b99a619d8b34e8c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 135, "deletions": 41, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -40,6 +40,7 @@ use tracing::{debug, trace};\n pub(super) struct EncodeContext<'a, 'tcx> {\n     opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n+    feat: &'tcx rustc_feature::Features,\n \n     tables: TableBuilders<'tcx>,\n \n@@ -67,6 +68,17 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     hygiene_ctxt: &'a HygieneEncodeContext,\n }\n \n+/// If the current crate is a proc-macro, returns early with `Lazy:empty()`.\n+/// This is useful for skipping the encoding of things that aren't needed\n+/// for proc-macro crates.\n+macro_rules! empty_proc_macro {\n+    ($self:ident) => {\n+        if $self.is_proc_macro {\n+            return Lazy::empty();\n+        }\n+    };\n+}\n+\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n@@ -137,6 +149,15 @@ where\n     }\n }\n \n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for CrateNum {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        if *self != LOCAL_CRATE && s.is_proc_macro {\n+            panic!(\"Attempted to encode non-local CrateNum {:?} for proc-macro crate\", self);\n+        }\n+        s.emit_u32(self.as_u32())\n+    }\n+}\n+\n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefIndex {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         s.emit_u32(self.as_u32())\n@@ -162,7 +183,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        if self.is_dummy() {\n+        if *self == rustc_span::DUMMY_SP {\n             return TAG_INVALID_SPAN.encode(s);\n         }\n \n@@ -320,6 +341,12 @@ impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        (**self).encode(s)\n+    }\n+}\n+\n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         (**self).encode(s)\n@@ -411,6 +438,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let krate = self.tcx.hir().krate();\n         let vis = Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Public };\n         self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module, &krate.item.attrs, &vis);\n+\n+        // Proc-macro crates only export proc-macro items, which are looked\n+        // up using `proc_macro_data`\n+        if self.is_proc_macro {\n+            return;\n+        }\n+\n         krate.visit_all_item_likes(&mut self.as_deep_visitor());\n         for macro_def in krate.exported_macros {\n             self.visit_macro_def(macro_def);\n@@ -419,11 +453,22 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_def_path_table(&mut self) {\n         let table = self.tcx.hir().definitions().def_path_table();\n-        for (def_index, def_key, def_path_hash) in table.enumerated_keys_and_path_hashes() {\n-            let def_key = self.lazy(def_key);\n-            let def_path_hash = self.lazy(def_path_hash);\n-            self.tables.def_keys.set(def_index, def_key);\n-            self.tables.def_path_hashes.set(def_index, def_path_hash);\n+        if self.is_proc_macro {\n+            for def_index in std::iter::once(CRATE_DEF_INDEX)\n+                .chain(self.tcx.hir().krate().proc_macros.iter().map(|p| p.owner.local_def_index))\n+            {\n+                let def_key = self.lazy(table.def_key(def_index));\n+                let def_path_hash = self.lazy(table.def_path_hash(def_index));\n+                self.tables.def_keys.set(def_index, def_key);\n+                self.tables.def_path_hashes.set(def_index, def_path_hash);\n+            }\n+        } else {\n+            for (def_index, def_key, def_path_hash) in table.enumerated_keys_and_path_hashes() {\n+                let def_key = self.lazy(def_key);\n+                let def_path_hash = self.lazy(def_path_hash);\n+                self.tables.def_keys.set(def_index, def_key);\n+                self.tables.def_path_hashes.set(def_index, def_path_hash);\n+            }\n         }\n     }\n \n@@ -490,13 +535,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(adapted.iter().map(|rc| &**rc))\n     }\n \n-    fn is_proc_macro(&self) -> bool {\n-        self.tcx.sess.crate_types().contains(&CrateType::ProcMacro)\n-    }\n-\n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n-        let is_proc_macro = self.is_proc_macro();\n-\n         let mut i = self.position();\n \n         // Encode the crate deps\n@@ -568,15 +607,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.lazy(interpret_alloc_index)\n         };\n \n-        i = self.position();\n-        let tables = self.tables.encode(&mut self.opaque);\n-        let tables_bytes = self.position() - i;\n-\n-        // Encode the proc macro data\n+        // Encode the proc macro data. This affects 'tables',\n+        // so we need to do this before we encode the tables\n         i = self.position();\n         let proc_macro_data = self.encode_proc_macros();\n         let proc_macro_data_bytes = self.position() - i;\n \n+        i = self.position();\n+        let tables = self.tables.encode(&mut self.opaque);\n+        let tables_bytes = self.position() - i;\n+\n         // Encode exported symbols info. This is prefetched in `encode_metadata` so we encode\n         // this as late as possible to give the prefetching as much time as possible to complete.\n         i = self.position();\n@@ -617,18 +657,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n             has_default_lib_allocator,\n             plugin_registrar_fn: tcx.plugin_registrar_fn(LOCAL_CRATE).map(|id| id.index),\n-            proc_macro_decls_static: if is_proc_macro {\n-                let id = tcx.proc_macro_decls_static(LOCAL_CRATE).unwrap();\n-                Some(id.index)\n-            } else {\n-                None\n-            },\n             proc_macro_data,\n-            proc_macro_stability: if is_proc_macro {\n-                tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).copied()\n-            } else {\n-                None\n-            },\n             compiler_builtins: tcx.sess.contains_name(&attrs, sym::compiler_builtins),\n             needs_allocator: tcx.sess.contains_name(&attrs, sym::needs_allocator),\n             needs_panic_runtime: tcx.sess.contains_name(&attrs, sym::needs_panic_runtime),\n@@ -793,8 +822,13 @@ impl EncodeContext<'a, 'tcx> {\n         let def_id = local_def_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n-        let data = ModData {\n-            reexports: match tcx.module_exports(local_def_id) {\n+        // If we are encoding a proc-macro crates, `encode_info_for_mod` will\n+        // only ever get called for the crate root. We still want to encode\n+        // the crate root for consistency with other crates (some of the resolver\n+        // code uses it). However, we skip encoding anything relating to child\n+        // items - we encode information about proc-macros later on.\n+        let reexports = if !self.is_proc_macro {\n+            match tcx.module_exports(local_def_id) {\n                 Some(exports) => {\n                     let hir = self.tcx.hir();\n                     self.lazy(\n@@ -804,17 +838,27 @@ impl EncodeContext<'a, 'tcx> {\n                     )\n                 }\n                 _ => Lazy::empty(),\n-            },\n+            }\n+        } else {\n+            Lazy::empty()\n+        };\n+\n+        let data = ModData {\n+            reexports,\n             expansion: tcx.hir().definitions().expansion_that_defined(local_def_id),\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n         record!(self.tables.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- attrs);\n-        record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n-            tcx.hir().local_def_id(item_id.id).local_def_index\n-        }));\n+        if self.is_proc_macro {\n+            record!(self.tables.children[def_id] <- &[]);\n+        } else {\n+            record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n+                tcx.hir().local_def_id(item_id.id).local_def_index\n+            }));\n+        }\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n@@ -1108,6 +1152,11 @@ impl EncodeContext<'a, 'tcx> {\n             if !unused.is_empty() {\n                 record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n             }\n+\n+            let abstract_const = self.tcx.mir_abstract_const(def_id);\n+            if let Ok(Some(abstract_const)) = abstract_const {\n+                record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n+            }\n         }\n     }\n \n@@ -1132,15 +1181,25 @@ impl EncodeContext<'a, 'tcx> {\n \n     fn encode_stability(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_stability({:?})\", def_id);\n-        if let Some(stab) = self.tcx.lookup_stability(def_id) {\n-            record!(self.tables.stability[def_id] <- stab)\n+\n+        // The query lookup can take a measurable amount of time in crates with many items. Check if\n+        // the stability attributes are even enabled before using their queries.\n+        if self.feat.staged_api || self.tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n+            if let Some(stab) = self.tcx.lookup_stability(def_id) {\n+                record!(self.tables.stability[def_id] <- stab)\n+            }\n         }\n     }\n \n     fn encode_const_stability(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_const_stability({:?})\", def_id);\n-        if let Some(stab) = self.tcx.lookup_const_stability(def_id) {\n-            record!(self.tables.const_stability[def_id] <- stab)\n+\n+        // The query lookup can take a measurable amount of time in crates with many items. Check if\n+        // the stability attributes are even enabled before using their queries.\n+        if self.feat.staged_api || self.tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n+            if let Some(stab) = self.tcx.lookup_const_stability(def_id) {\n+                record!(self.tables.const_stability[def_id] <- stab)\n+            }\n         }\n     }\n \n@@ -1278,7 +1337,7 @@ impl EncodeContext<'a, 'tcx> {\n         });\n         record!(self.tables.visibility[def_id] <-\n             ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n-        record!(self.tables.span[def_id] <- item.span);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- item.attrs);\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n@@ -1459,11 +1518,13 @@ impl EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_native_libraries(&mut self) -> Lazy<[NativeLib]> {\n+        empty_proc_macro!(self);\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n         self.lazy(used_libraries.iter().cloned())\n     }\n \n     fn encode_foreign_modules(&mut self) -> Lazy<[ForeignModule]> {\n+        empty_proc_macro!(self);\n         let foreign_modules = self.tcx.foreign_modules(LOCAL_CRATE);\n         self.lazy(foreign_modules.iter().cloned())\n     }\n@@ -1487,17 +1548,37 @@ impl EncodeContext<'a, 'tcx> {\n         (syntax_contexts.encode(&mut self.opaque), expn_data_table.encode(&mut self.opaque))\n     }\n \n-    fn encode_proc_macros(&mut self) -> Option<Lazy<[DefIndex]>> {\n+    fn encode_proc_macros(&mut self) -> Option<ProcMacroData> {\n         let is_proc_macro = self.tcx.sess.crate_types().contains(&CrateType::ProcMacro);\n         if is_proc_macro {\n             let tcx = self.tcx;\n-            Some(self.lazy(tcx.hir().krate().proc_macros.iter().map(|p| p.owner.local_def_index)))\n+            let hir = tcx.hir();\n+\n+            let proc_macro_decls_static = tcx.proc_macro_decls_static(LOCAL_CRATE).unwrap().index;\n+            let stability = tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).copied();\n+            let macros = self.lazy(hir.krate().proc_macros.iter().map(|p| p.owner.local_def_index));\n+\n+            // Normally, this information is encoded when we walk the items\n+            // defined in this crate. However, we skip doing that for proc-macro crates,\n+            // so we manually encode just the information that we need\n+            for proc_macro in &hir.krate().proc_macros {\n+                let id = proc_macro.owner.local_def_index;\n+                let span = self.lazy(hir.span(*proc_macro));\n+                // Proc-macros may have attributes like `#[allow_internal_unstable]`,\n+                // so downstream crates need access to them.\n+                let attrs = self.lazy(hir.attrs(*proc_macro));\n+                self.tables.span.set(id, span);\n+                self.tables.attributes.set(id, attrs);\n+            }\n+\n+            Some(ProcMacroData { proc_macro_decls_static, stability, macros })\n         } else {\n             None\n         }\n     }\n \n     fn encode_crate_deps(&mut self) -> Lazy<[CrateDep]> {\n+        empty_proc_macro!(self);\n         let crates = self.tcx.crates();\n \n         let mut deps = crates\n@@ -1533,18 +1614,21 @@ impl EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_lib_features(&mut self) -> Lazy<[(Symbol, Option<Symbol>)]> {\n+        empty_proc_macro!(self);\n         let tcx = self.tcx;\n         let lib_features = tcx.lib_features();\n         self.lazy(lib_features.to_vec())\n     }\n \n     fn encode_diagnostic_items(&mut self) -> Lazy<[(Symbol, DefIndex)]> {\n+        empty_proc_macro!(self);\n         let tcx = self.tcx;\n         let diagnostic_items = tcx.diagnostic_items(LOCAL_CRATE);\n         self.lazy(diagnostic_items.iter().map(|(&name, def_id)| (name, def_id.index)))\n     }\n \n     fn encode_lang_items(&mut self) -> Lazy<[(DefIndex, usize)]> {\n+        empty_proc_macro!(self);\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n         let lang_items = lang_items.items().iter();\n@@ -1559,12 +1643,14 @@ impl EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_lang_items_missing(&mut self) -> Lazy<[lang_items::LangItem]> {\n+        empty_proc_macro!(self);\n         let tcx = self.tcx;\n         self.lazy(&tcx.lang_items().missing)\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n     fn encode_impls(&mut self) -> Lazy<[TraitImpls]> {\n+        empty_proc_macro!(self);\n         debug!(\"EncodeContext::encode_impls()\");\n         let tcx = self.tcx;\n         let mut visitor = ImplVisitor { tcx, impls: FxHashMap::default() };\n@@ -1603,6 +1689,7 @@ impl EncodeContext<'a, 'tcx> {\n         &mut self,\n         exported_symbols: &[(ExportedSymbol<'tcx>, SymbolExportLevel)],\n     ) -> Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]> {\n+        empty_proc_macro!(self);\n         // The metadata symbol name is special. It should not show up in\n         // downstream crates.\n         let metadata_symbol_name = SymbolName::new(self.tcx, &metadata_symbol_name(self.tcx));\n@@ -1619,6 +1706,7 @@ impl EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n+        empty_proc_macro!(self);\n         let formats = self.tcx.dependency_formats(LOCAL_CRATE);\n         for (ty, arr) in formats.iter() {\n             if *ty != CrateType::Dylib {\n@@ -1665,6 +1753,7 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n+        self.encode_inherent_implementations(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n@@ -1734,13 +1823,17 @@ impl EncodeContext<'a, 'tcx> {\n                         EntryKind::TypeParam,\n                         default.is_some(),\n                     );\n+                    if default.is_some() {\n+                        self.encode_stability(def_id.to_def_id());\n+                    }\n                 }\n                 GenericParamKind::Const { .. } => {\n                     self.encode_info_for_generic_param(\n                         def_id.to_def_id(),\n                         EntryKind::ConstParam,\n                         true,\n                     );\n+                    // FIXME(const_generics:defaults)\n                 }\n             }\n         }\n@@ -1979,6 +2072,7 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut ecx = EncodeContext {\n         opaque: encoder,\n         tcx,\n+        feat: tcx.features(),\n         tables: Default::default(),\n         lazy_state: LazyState::NoNode,\n         type_shorthands: Default::default(),"}, {"sha": "1a127035d4ff7f470b894c31d6bbead8cd308f64", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -172,6 +172,29 @@ macro_rules! Lazy {\n type SyntaxContextTable = Lazy<Table<u32, Lazy<SyntaxContextData>>>;\n type ExpnDataTable = Lazy<Table<u32, Lazy<ExpnData>>>;\n \n+#[derive(MetadataEncodable, MetadataDecodable)]\n+crate struct ProcMacroData {\n+    proc_macro_decls_static: DefIndex,\n+    stability: Option<attr::Stability>,\n+    macros: Lazy<[DefIndex]>,\n+}\n+\n+/// Serialized metadata for a crate.\n+/// When compiling a proc-macro crate, we encode many of\n+/// the `Lazy<[T]>` fields as `Lazy::empty()`. This serves two purposes:\n+///\n+/// 1. We avoid performing unnecessary work. Proc-macro crates can only\n+/// export proc-macros functions, which are compiled into a shared library.\n+/// As a result, a large amount of the information we normally store\n+/// (e.g. optimized MIR) is unneeded by downstream crates.\n+/// 2. We avoid serializing invalid `CrateNum`s. When we deserialize\n+/// a proc-macro crate, we don't load any of its dependencies (since we\n+/// just need to invoke a native function from the shared library).\n+/// This means that any foreign `CrateNum`s that we serialize cannot be\n+/// deserialized, since we will not know how to map them into the current\n+/// compilation session. If we were to serialize a proc-macro crate like\n+/// a normal crate, much of what we serialized would be unusable in addition\n+/// to being unused.\n #[derive(MetadataEncodable, MetadataDecodable)]\n crate struct CrateRoot<'tcx> {\n     name: Symbol,\n@@ -185,8 +208,6 @@ crate struct CrateRoot<'tcx> {\n     has_panic_handler: bool,\n     has_default_lib_allocator: bool,\n     plugin_registrar_fn: Option<DefIndex>,\n-    proc_macro_decls_static: Option<DefIndex>,\n-    proc_macro_stability: Option<attr::Stability>,\n \n     crate_deps: Lazy<[CrateDep]>,\n     dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n@@ -198,12 +219,10 @@ crate struct CrateRoot<'tcx> {\n     foreign_modules: Lazy<[ForeignModule]>,\n     impls: Lazy<[TraitImpls]>,\n     interpret_alloc_index: Lazy<[u32]>,\n+    proc_macro_data: Option<ProcMacroData>,\n \n     tables: LazyTables<'tcx>,\n \n-    /// The DefIndex's of any proc macros declared by this crate.\n-    proc_macro_data: Option<Lazy<[DefIndex]>>,\n-\n     exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n \n     syntax_contexts: SyntaxContextTable,\n@@ -284,6 +303,7 @@ define_tables! {\n     super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n+    mir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [mir::abstract_const::Node<'tcx>])>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a\n     // `DefPathTable`. This allows us to avoid deserializing an entire"}, {"sha": "e8ace361b219dfd1bf510ddbbbcaf2463fb01e80", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -26,8 +26,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-byteorder = { version = \"1.3\" }\n-chalk-ir = \"0.14.0\"\n+chalk-ir = \"0.29.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "d6869ab88751a52fbef06b1ca1cbaf68d2a5de17", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         if cfg!(debug_assertions) {\n             if hir_id.owner != self.current_dep_node_owner {\n                 let node_str = match self.definitions.opt_hir_id_to_local_def_id(hir_id) {\n-                    Some(def_id) => self.definitions.def_path(def_id).to_string_no_crate(),\n+                    Some(def_id) => self.definitions.def_path(def_id).to_string_no_crate_verbose(),\n                     None => format!(\"{:?}\", node),\n                 };\n \n@@ -254,9 +254,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_string(span),\n                     node_str,\n-                    self.definitions.def_path(self.current_dep_node_owner).to_string_no_crate(),\n+                    self.definitions\n+                        .def_path(self.current_dep_node_owner)\n+                        .to_string_no_crate_verbose(),\n                     self.current_dep_node_owner,\n-                    self.definitions.def_path(hir_id.owner).to_string_no_crate(),\n+                    self.definitions.def_path(hir_id.owner).to_string_no_crate_verbose(),\n                     hir_id.owner,\n                 )\n             }"}, {"sha": "ceb873adf5cb6fcf766f484f4d725f40d7c85373", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1002,11 +1002,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n                 let def_id = map.local_def_id(id);\n                 tcx.def_path_str(def_id.to_def_id())\n             } else if let Some(path) = map.def_path_from_hir_id(id) {\n-                path.data\n-                    .into_iter()\n-                    .map(|elem| elem.data.to_string())\n-                    .collect::<Vec<_>>()\n-                    .join(\"::\")\n+                path.data.into_iter().map(|elem| elem.to_string()).collect::<Vec<_>>().join(\"::\")\n             } else {\n                 String::from(\"<missing path>\")\n             }"}, {"sha": "4d884dde393876d5680f00b84269b1b5bc6dfebb", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,8 +4,9 @@ use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify::{\n     self, EqUnifyValue, InPlace, NoError, UnificationTable, UnifyKey, UnifyValue,\n };\n+use rustc_span::def_id::DefId;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n \n use std::cmp;\n use std::marker::PhantomData;\n@@ -124,7 +125,7 @@ pub struct ConstVariableOrigin {\n pub enum ConstVariableOriginKind {\n     MiscVariable,\n     ConstInference,\n-    ConstParameterDefinition(Symbol),\n+    ConstParameterDefinition(Symbol, DefId),\n     SubstitutionPlaceholder,\n }\n \n@@ -175,17 +176,17 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n     type Error = (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>);\n \n     fn unify_values(value1: &Self, value2: &Self) -> Result<Self, Self::Error> {\n-        let val = match (value1.val, value2.val) {\n+        let (val, span) = match (value1.val, value2.val) {\n             (ConstVariableValue::Known { .. }, ConstVariableValue::Known { .. }) => {\n                 bug!(\"equating two const variables, both of which have known values\")\n             }\n \n             // If one side is known, prefer that one.\n             (ConstVariableValue::Known { .. }, ConstVariableValue::Unknown { .. }) => {\n-                Ok(value1.val)\n+                (value1.val, value1.origin.span)\n             }\n             (ConstVariableValue::Unknown { .. }, ConstVariableValue::Known { .. }) => {\n-                Ok(value2.val)\n+                (value2.val, value2.origin.span)\n             }\n \n             // If both sides are *unknown*, it hardly matters, does it?\n@@ -199,14 +200,14 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n                 // universe is the minimum of the two universes, because that is\n                 // the one which contains the fewest names in scope.\n                 let universe = cmp::min(universe1, universe2);\n-                Ok(ConstVariableValue::Unknown { universe })\n+                (ConstVariableValue::Unknown { universe }, value1.origin.span)\n             }\n-        }?;\n+        };\n \n         Ok(ConstVarValue {\n             origin: ConstVariableOrigin {\n                 kind: ConstVariableOriginKind::ConstInference,\n-                span: DUMMY_SP,\n+                span: span,\n             },\n             val,\n         })"}, {"sha": "fa885ce2e7cdfb4ded4be2cd0090a3cc352746e7", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -22,34 +22,30 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(array_windows)]\n #![feature(backtrace)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cmp_min_max_by)]\n #![feature(const_fn)]\n #![feature(const_panic)]\n-#![feature(const_fn_transmute)]\n #![feature(core_intrinsics)]\n #![feature(discriminant_kind)]\n-#![feature(drain_filter)]\n #![feature(never_type)]\n-#![feature(exhaustive_patterns)]\n #![feature(extern_types)]\n #![feature(nll)]\n #![feature(once_cell)]\n #![feature(option_expect_none)]\n #![feature(or_patterns)]\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n-#![feature(stmt_expr_attributes)]\n #![feature(test)]\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n-#![feature(hash_raw_entry)]\n #![feature(int_error_matching)]\n #![recursion_limit = \"512\"]\n "}, {"sha": "d71cdc4e67de4885ecd0587cf2731d859785ed16", "filename": "compiler/rustc_middle/src/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -79,6 +79,9 @@ bitflags! {\n         /// #[ffi_const]: applies clang's `const` attribute to a foreign function\n         /// declaration.\n         const FFI_CONST                 = 1 << 13;\n+        /// #[cmse_nonsecure_entry]: with a TrustZone-M extension, declare a\n+        /// function as an entry function from Non-Secure code.\n+        const CMSE_NONSECURE_ENTRY      = 1 << 14;\n     }\n }\n "}, {"sha": "f3d7c8506ab6ff3338ae7cebfb4b6859d4648f3b", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -69,7 +69,7 @@ pub enum LibSource {\n \n impl LibSource {\n     pub fn is_some(&self) -> bool {\n-        if let LibSource::Some(_) = *self { true } else { false }\n+        matches!(self, LibSource::Some(_))\n     }\n \n     pub fn option(&self) -> Option<PathBuf> {"}, {"sha": "cc9706f2d867cbe6db1bd1d222363e3455ced817", "filename": "compiler/rustc_middle/src/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -17,7 +17,7 @@ use rustc_target::spec::PanicStrategy;\n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally aborts compilation.\n-    pub fn require_lang_item(&self, lang_item: LangItem, span: Option<Span>) -> DefId {\n+    pub fn require_lang_item(self, lang_item: LangItem, span: Option<Span>) -> DefId {\n         self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n             if let Some(span) = span {\n                 self.sess.span_fatal(span, &msg)\n@@ -27,7 +27,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn fn_trait_kind_from_lang_item(&self, id: DefId) -> Option<ty::ClosureKind> {\n+    pub fn fn_trait_kind_from_lang_item(self, id: DefId) -> Option<ty::ClosureKind> {\n         let items = self.lang_items();\n         match Some(id) {\n             x if x == items.fn_trait() => Some(ty::ClosureKind::Fn),\n@@ -37,7 +37,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n+    pub fn is_weak_lang_item(self, item_def_id: DefId) -> bool {\n         self.lang_items().is_weak_lang_item(item_def_id)\n     }\n }"}, {"sha": "7e2415fd544d4c9a209776aeb4559fcbf9638bea", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -392,9 +392,27 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// If the item defined by `def_id` is unstable and the corresponding `#![feature]` does not\n     /// exist, emits an error.\n     ///\n-    /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n-    /// not `None`, a deprecated lint attached to `id` will be emitted.\n+    /// This function will also check if the item is deprecated.\n+    /// If so, and `id` is not `None`, a deprecated lint attached to `id` will be emitted.\n     pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n+        self.check_optional_stability(def_id, id, span, |span, def_id| {\n+            // The API could be uncallable for other reasons, for example when a private module\n+            // was referenced.\n+            self.sess.delay_span_bug(span, &format!(\"encountered unmarked API: {:?}\", def_id));\n+        })\n+    }\n+\n+    /// Like `check_stability`, except that we permit items to have custom behaviour for\n+    /// missing stability attributes (not necessarily just emit a `bug!`). This is necessary\n+    /// for default generic parameters, which only have stability attributes if they were\n+    /// added after the type on which they're defined.\n+    pub fn check_optional_stability(\n+        self,\n+        def_id: DefId,\n+        id: Option<HirId>,\n+        span: Span,\n+        unmarked: impl FnOnce(Span, DefId) -> (),\n+    ) {\n         let soft_handler = |lint, span, msg: &_| {\n             self.struct_span_lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, |lint| {\n                 lint.build(msg).emit()\n@@ -405,11 +423,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             EvalResult::Deny { feature, reason, issue, is_soft } => {\n                 report_unstable(self.sess, feature, reason, issue, is_soft, span, soft_handler)\n             }\n-            EvalResult::Unmarked => {\n-                // The API could be uncallable for other reasons, for example when a private module\n-                // was referenced.\n-                self.sess.delay_span_bug(span, &format!(\"encountered unmarked API: {:?}\", def_id));\n-            }\n+            EvalResult::Unmarked => unmarked(span, def_id),\n         }\n     }\n "}, {"sha": "b85f1e6e5ded05aad2c176114f2a10245a3c7e13", "filename": "compiler/rustc_middle/src/mir/abstract_const.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -0,0 +1,20 @@\n+//! A subset of a mir body used for const evaluatability checking.\n+use crate::mir;\n+use crate::ty;\n+\n+rustc_index::newtype_index! {\n+    /// An index into an `AbstractConst`.\n+    pub struct NodeId {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"n{}\",\n+    }\n+}\n+\n+/// A node of an `AbstractConst`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum Node<'tcx> {\n+    Leaf(&'tcx ty::Const<'tcx>),\n+    Binop(mir::BinOp, NodeId, NodeId),\n+    UnaryOp(mir::UnOp, NodeId),\n+    FunctionCall(NodeId, &'tcx [NodeId]),\n+}"}, {"sha": "0421eabc2dc0522e2aedb223b30a57b138da4e0c", "filename": "compiler/rustc_middle/src/mir/coverage/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -14,6 +14,20 @@ rustc_index::newtype_index! {\n     }\n }\n \n+impl ExpressionOperandId {\n+    /// An expression operand for a \"zero counter\", as described in the following references:\n+    ///\n+    /// * https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#counter\n+    /// * https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#tag\n+    /// * https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#counter-expressions\n+    ///\n+    /// This operand can be used to count two or more separate code regions with a single counter,\n+    /// if they run sequentially with no branches, by injecting the `Counter` in a `BasicBlock` for\n+    /// one of the code regions, and inserting `CounterExpression`s (\"add ZERO to the counter\") in\n+    /// the coverage map for the other code regions.\n+    pub const ZERO: Self = Self::from_u32(0);\n+}\n+\n rustc_index::newtype_index! {\n     pub struct CounterValueReference {\n         derive [HashStable]\n@@ -22,6 +36,11 @@ rustc_index::newtype_index! {\n     }\n }\n \n+impl CounterValueReference {\n+    // Counters start at 1 to reserve 0 for ExpressionOperandId::ZERO.\n+    pub const START: Self = Self::from_u32(1);\n+}\n+\n rustc_index::newtype_index! {\n     pub struct InjectedExpressionIndex {\n         derive [HashStable]"}, {"sha": "ee1ea816e019253bf7b945cf647135bef533cfbb", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -345,10 +345,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// Reads a *non-ZST* scalar.\n     ///\n-    /// ZSTs can't be read for two reasons:\n-    /// * byte-order cannot work with zero-element buffers;\n-    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n-    ///   pointers being valid for ZSTs.\n+    /// ZSTs can't be read because in order to obtain a `Pointer`, we need to check\n+    /// for ZSTness anyway due to integer pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to call `InterpCx::read_scalar` instead of this method.\n@@ -397,10 +395,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// Writes a *non-ZST* scalar.\n     ///\n-    /// ZSTs can't be read for two reasons:\n-    /// * byte-order cannot work with zero-element buffers;\n-    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n-    ///   pointers being valid for ZSTs.\n+    /// ZSTs can't be read because in order to obtain a `Pointer`, we need to check\n+    /// for ZSTness anyway due to integer pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to call `InterpCx::write_scalar` instead of this method."}, {"sha": "d41e5680602194c30fc939bd7ae1c9daba845ec9", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,4 +1,4 @@\n-use super::{AllocId, Pointer, RawConst, Scalar};\n+use super::{AllocId, ConstAlloc, Pointer, Scalar};\n \n use crate::mir::interpret::ConstValue;\n use crate::ty::{layout, query::TyCtxtAt, tls, FnSig, Ty};\n@@ -23,12 +23,18 @@ pub enum ErrorHandled {\n     TooGeneric,\n }\n \n+impl From<ErrorReported> for ErrorHandled {\n+    fn from(err: ErrorReported) -> ErrorHandled {\n+        ErrorHandled::Reported(err)\n+    }\n+}\n+\n CloneTypeFoldableAndLiftImpls! {\n     ErrorHandled,\n }\n \n-pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n-pub type ConstEvalResult<'tcx> = Result<ConstValue<'tcx>, ErrorHandled>;\n+pub type EvalToAllocationRawResult<'tcx> = Result<ConstAlloc<'tcx>, ErrorHandled>;\n+pub type EvalToConstValueResult<'tcx> = Result<ConstValue<'tcx>, ErrorHandled>;\n \n pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'tcx> {\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)"}, {"sha": "20363625e42b644dc1820b503f2ba406dcf710d7", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -98,10 +98,10 @@ mod value;\n use std::convert::TryFrom;\n use std::fmt;\n use std::io;\n+use std::io::{Read, Write};\n use std::num::NonZeroU32;\n use std::sync::atomic::{AtomicU32, Ordering};\n \n-use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};\n use rustc_ast::LitKind;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{HashMapExt, Lock};\n@@ -118,12 +118,12 @@ use crate::ty::subst::GenericArgKind;\n use crate::ty::{self, Instance, Ty, TyCtxt};\n \n pub use self::error::{\n-    struct_error, CheckInAllocMsg, ConstEvalRawResult, ConstEvalResult, ErrorHandled, InterpError,\n-    InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType, ResourceExhaustionInfo,\n-    UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    struct_error, CheckInAllocMsg, ErrorHandled, EvalToAllocationRawResult, EvalToConstValueResult,\n+    InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n+    ResourceExhaustionInfo, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n };\n \n-pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUninit};\n+pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar, ScalarMaybeUninit};\n \n pub use self::allocation::{Allocation, AllocationExtra, InitMask, Relocations};\n \n@@ -447,14 +447,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n     /// an `AllocId` from a query.\n-    pub fn reserve_alloc_id(&self) -> AllocId {\n+    pub fn reserve_alloc_id(self) -> AllocId {\n         self.alloc_map.lock().reserve()\n     }\n \n     /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n     /// Should only be used for function pointers and statics, we don't want\n     /// to dedup IDs for \"real\" memory!\n-    fn reserve_and_set_dedup(&self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n+    fn reserve_and_set_dedup(self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n         let mut alloc_map = self.alloc_map.lock();\n         match alloc {\n             GlobalAlloc::Function(..) | GlobalAlloc::Static(..) => {}\n@@ -472,13 +472,13 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Generates an `AllocId` for a static or return a cached one in case this function has been\n     /// called on the same static before.\n-    pub fn create_static_alloc(&self, static_id: DefId) -> AllocId {\n+    pub fn create_static_alloc(self, static_id: DefId) -> AllocId {\n         self.reserve_and_set_dedup(GlobalAlloc::Static(static_id))\n     }\n \n     /// Generates an `AllocId` for a function.  Depending on the function type,\n     /// this might get deduplicated or assigned a new ID each time.\n-    pub fn create_fn_alloc(&self, instance: Instance<'tcx>) -> AllocId {\n+    pub fn create_fn_alloc(self, instance: Instance<'tcx>) -> AllocId {\n         // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n         // by the linker (we set the \"unnamed_addr\" attribute for LLVM) and functions can be\n         // duplicated across crates.\n@@ -507,7 +507,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n     /// their data will be deduplicated through `Allocation` interning -- but they\n     /// are different places in memory and as such need different IDs.\n-    pub fn create_memory_alloc(&self, mem: &'tcx Allocation) -> AllocId {\n+    pub fn create_memory_alloc(self, mem: &'tcx Allocation) -> AllocId {\n         let id = self.reserve_alloc_id();\n         self.set_alloc_id_memory(id, mem);\n         id\n@@ -519,7 +519,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n     #[inline]\n-    pub fn get_global_alloc(&self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n+    pub fn get_global_alloc(self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n         self.alloc_map.lock().alloc_map.get(&id).cloned()\n     }\n \n@@ -529,7 +529,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// constants (as all constants must pass interning and validation that check for dangling\n     /// ids), this function is frequently used throughout rustc, but should not be used within\n     /// the miri engine.\n-    pub fn global_alloc(&self, id: AllocId) -> GlobalAlloc<'tcx> {\n+    pub fn global_alloc(self, id: AllocId) -> GlobalAlloc<'tcx> {\n         match self.get_global_alloc(id) {\n             Some(alloc) => alloc,\n             None => bug!(\"could not find allocation for {}\", id),\n@@ -538,15 +538,15 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n-    pub fn set_alloc_id_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+    pub fn set_alloc_id_memory(self, id: AllocId, mem: &'tcx Allocation) {\n         if let Some(old) = self.alloc_map.lock().alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n             bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n-    fn set_alloc_id_same_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+    fn set_alloc_id_same_memory(self, id: AllocId, mem: &'tcx Allocation) {\n         self.alloc_map.lock().alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n     }\n }\n@@ -561,19 +561,33 @@ pub fn write_target_uint(\n     mut target: &mut [u8],\n     data: u128,\n ) -> Result<(), io::Error> {\n-    let len = target.len();\n+    // This u128 holds an \"any-size uint\" (since smaller uints can fits in it)\n+    // So we do not write all bytes of the u128, just the \"payload\".\n     match endianness {\n-        Endian::Little => target.write_uint128::<LittleEndian>(data, len),\n-        Endian::Big => target.write_uint128::<BigEndian>(data, len),\n-    }\n+        Endian::Little => target.write(&data.to_le_bytes())?,\n+        Endian::Big => target.write(&data.to_be_bytes()[16 - target.len()..])?,\n+    };\n+    debug_assert!(target.len() == 0); // We should have filled the target buffer.\n+    Ok(())\n }\n \n #[inline]\n pub fn read_target_uint(endianness: Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n-    match endianness {\n-        Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n-        Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n-    }\n+    // This u128 holds an \"any-size uint\" (since smaller uints can fits in it)\n+    let mut buf = [0u8; std::mem::size_of::<u128>()];\n+    // So we do not read exactly 16 bytes into the u128, just the \"payload\".\n+    let uint = match endianness {\n+        Endian::Little => {\n+            source.read(&mut buf)?;\n+            Ok(u128::from_le_bytes(buf))\n+        }\n+        Endian::Big => {\n+            source.read(&mut buf[16 - source.len()..])?;\n+            Ok(u128::from_be_bytes(buf))\n+        }\n+    };\n+    debug_assert!(source.len() == 0); // We should have consumed the source buffer.\n+    uint\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "f366681bc75e9d1ab47d017c47e07632812350bc", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,4 +1,4 @@\n-use super::{ConstEvalResult, ErrorHandled, GlobalId};\n+use super::{ErrorHandled, EvalToConstValueResult, GlobalId};\n \n use crate::mir;\n use crate::ty::subst::{InternalSubsts, SubstsRef};\n@@ -10,7 +10,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Evaluates a constant without providing any substitutions. This is useful to evaluate consts\n     /// that can't take any generic arguments like statics, const items or enum discriminants. If a\n     /// generic parameter is used within the constant `ErrorHandled::ToGeneric` will be returned.\n-    pub fn const_eval_poly(self, def_id: DefId) -> ConstEvalResult<'tcx> {\n+    pub fn const_eval_poly(self, def_id: DefId) -> EvalToConstValueResult<'tcx> {\n         // In some situations def_id will have substitutions within scope, but they aren't allowed\n         // to be used. So we can't use `Instance::mono`, instead we feed unresolved substitutions\n         // into `const_eval` which will return `ErrorHandled::ToGeneric` if any of them are\n@@ -38,7 +38,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         substs: SubstsRef<'tcx>,\n         promoted: Option<mir::Promoted>,\n         span: Option<Span>,\n-    ) -> ConstEvalResult<'tcx> {\n+    ) -> EvalToConstValueResult<'tcx> {\n         match ty::Instance::resolve_opt_const_arg(self, param_env, def, substs) {\n             Ok(Some(instance)) => {\n                 let cid = GlobalId { instance, promoted };\n@@ -54,7 +54,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         instance: ty::Instance<'tcx>,\n         span: Option<Span>,\n-    ) -> ConstEvalResult<'tcx> {\n+    ) -> EvalToConstValueResult<'tcx> {\n         self.const_eval_global_id(param_env, GlobalId { instance, promoted: None }, span)\n     }\n \n@@ -64,14 +64,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         cid: GlobalId<'tcx>,\n         span: Option<Span>,\n-    ) -> ConstEvalResult<'tcx> {\n+    ) -> EvalToConstValueResult<'tcx> {\n         // Const-eval shouldn't depend on lifetimes at all, so we can erase them, which should\n         // improve caching of queries.\n         let inputs = self.erase_regions(&param_env.and(cid));\n         if let Some(span) = span {\n-            self.at(span).const_eval_validated(inputs)\n+            self.at(span).eval_to_const_value_raw(inputs)\n         } else {\n-            self.const_eval_validated(inputs)\n+            self.eval_to_const_value_raw(inputs)\n         }\n     }\n \n@@ -94,7 +94,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Result<&'tcx mir::Allocation, ErrorHandled> {\n         trace!(\"eval_to_allocation: Need to compute {:?}\", gid);\n-        let raw_const = self.const_eval_raw(param_env.and(gid))?;\n+        let raw_const = self.eval_to_allocation_raw(param_env.and(gid))?;\n         Ok(self.global_alloc(raw_const.alloc_id).unwrap_memory())\n     }\n }"}, {"sha": "206f01c2498286dd1283d15af60aa365dd51a158", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -12,9 +12,9 @@ use crate::ty::{ParamEnv, Ty, TyCtxt};\n \n use super::{sign_extend, truncate, AllocId, Allocation, InterpResult, Pointer, PointerArithmetic};\n \n-/// Represents the result of a raw const operation, pre-validation.\n-#[derive(Clone, HashStable)]\n-pub struct RawConst<'tcx> {\n+/// Represents the result of const evaluation via the `eval_to_allocation` query.\n+#[derive(Clone, HashStable, TyEncodable, TyDecodable)]\n+pub struct ConstAlloc<'tcx> {\n     // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n     pub alloc_id: AllocId,\n@@ -578,6 +578,9 @@ pub enum ScalarMaybeUninit<Tag = ()> {\n     Uninit,\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(ScalarMaybeUninit, 24);\n+\n impl<Tag> From<Scalar<Tag>> for ScalarMaybeUninit<Tag> {\n     #[inline(always)]\n     fn from(s: Scalar<Tag>) -> Self {"}, {"sha": "2f306809f1fd658295824affdfd8ee46e469240e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 134, "deletions": 39, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -10,12 +10,11 @@ use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n-use crate::ty::{\n-    self, AdtDef, CanonicalUserTypeAnnotations, List, Region, Ty, TyCtxt, UserTypeAnnotationIndex,\n-};\n+use crate::ty::{self, List, Ty, TyCtxt};\n+use crate::ty::{AdtDef, InstanceDef, Region, UserTypeAnnotationIndex};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, Namespace};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::{self, GeneratorKind};\n use rustc_target::abi::VariantIdx;\n \n@@ -40,6 +39,7 @@ use std::{iter, mem, option};\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n+pub mod abstract_const;\n pub mod coverage;\n pub mod interpret;\n pub mod mono;\n@@ -111,6 +111,38 @@ impl MirPhase {\n     }\n }\n \n+/// Where a specific `mir::Body` comes from.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(HashStable, TyEncodable, TyDecodable, TypeFoldable)]\n+pub struct MirSource<'tcx> {\n+    pub instance: InstanceDef<'tcx>,\n+\n+    /// If `Some`, this is a promoted rvalue within the parent function.\n+    pub promoted: Option<Promoted>,\n+}\n+\n+impl<'tcx> MirSource<'tcx> {\n+    pub fn item(def_id: DefId) -> Self {\n+        MirSource {\n+            instance: InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n+            promoted: None,\n+        }\n+    }\n+\n+    pub fn from_instance(instance: InstanceDef<'tcx>) -> Self {\n+        MirSource { instance, promoted: None }\n+    }\n+\n+    pub fn with_opt_param(self) -> ty::WithOptConstParam<DefId> {\n+        self.instance.with_opt_param()\n+    }\n+\n+    #[inline]\n+    pub fn def_id(&self) -> DefId {\n+        self.instance.def_id()\n+    }\n+}\n+\n /// The lowered representation of a single function.\n #[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable, TypeFoldable)]\n pub struct Body<'tcx> {\n@@ -125,6 +157,8 @@ pub struct Body<'tcx> {\n     /// us to see the difference and forego optimization on the inlined promoted items.\n     pub phase: MirPhase,\n \n+    pub source: MirSource<'tcx>,\n+\n     /// A list of source scopes; these are referenced by statements\n     /// and used for debuginfo. Indexed by a `SourceScope`.\n     pub source_scopes: IndexVec<SourceScope, SourceScopeData>,\n@@ -150,7 +184,7 @@ pub struct Body<'tcx> {\n     pub local_decls: LocalDecls<'tcx>,\n \n     /// User type annotations.\n-    pub user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n+    pub user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n \n     /// The number of arguments this function takes.\n     ///\n@@ -186,15 +220,33 @@ pub struct Body<'tcx> {\n     /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n     pub ignore_interior_mut_in_const_validation: bool,\n \n+    /// Does this body use generic parameters. This is used for the `ConstEvaluatable` check.\n+    ///\n+    /// Note that this does not actually mean that this body is not computable right now.\n+    /// The repeat count in the following example is polymorphic, but can still be evaluated\n+    /// without knowing anything about the type parameter `T`.\n+    ///\n+    /// ```rust\n+    /// fn test<T>() {\n+    ///     let _ = [0; std::mem::size_of::<*mut T>()];\n+    /// }\n+    /// ```\n+    ///\n+    /// **WARNING**: Do not change this flags after the MIR was originally created, even if an optimization\n+    /// removed the last mention of all generic params. We do not want to rely on optimizations and\n+    /// potentially allow things like `[u8; std::mem::size_of::<T>() * 0]` due to this.\n+    pub is_polymorphic: bool,\n+\n     predecessor_cache: PredecessorCache,\n }\n \n impl<'tcx> Body<'tcx> {\n     pub fn new(\n+        source: MirSource<'tcx>,\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData>,\n         local_decls: LocalDecls<'tcx>,\n-        user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n+        user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n         var_debug_info: Vec<VarDebugInfo<'tcx>>,\n         span: Span,\n@@ -208,8 +260,9 @@ impl<'tcx> Body<'tcx> {\n             local_decls.len()\n         );\n \n-        Body {\n+        let mut body = Body {\n             phase: MirPhase::Build,\n+            source,\n             basic_blocks,\n             source_scopes,\n             yield_ty: None,\n@@ -224,8 +277,11 @@ impl<'tcx> Body<'tcx> {\n             span,\n             required_consts: Vec::new(),\n             ignore_interior_mut_in_const_validation: false,\n+            is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n-        }\n+        };\n+        body.is_polymorphic = body.has_param_types_or_consts();\n+        body\n     }\n \n     /// Returns a partially initialized MIR body containing only a list of basic blocks.\n@@ -234,8 +290,9 @@ impl<'tcx> Body<'tcx> {\n     /// is only useful for testing but cannot be `#[cfg(test)]` because it is used in a different\n     /// crate.\n     pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n-        Body {\n+        let mut body = Body {\n             phase: MirPhase::Build,\n+            source: MirSource::item(DefId::local(CRATE_DEF_INDEX)),\n             basic_blocks,\n             source_scopes: IndexVec::new(),\n             yield_ty: None,\n@@ -250,8 +307,11 @@ impl<'tcx> Body<'tcx> {\n             generator_kind: None,\n             var_debug_info: Vec::new(),\n             ignore_interior_mut_in_const_validation: false,\n+            is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n-        }\n+        };\n+        body.is_polymorphic = body.has_param_types_or_consts();\n+        body\n     }\n \n     #[inline]\n@@ -646,7 +706,7 @@ impl Atom for Local {\n }\n \n /// Classifies locals into categories. See `Body::local_kind`.\n-#[derive(PartialEq, Eq, Debug, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable)]\n pub enum LocalKind {\n     /// User-declared variable binding.\n     Var,\n@@ -899,6 +959,8 @@ pub enum LocalInfo<'tcx> {\n     User(ClearCrossCrate<BindingForm<'tcx>>),\n     /// A temporary created that references the static with the given `DefId`.\n     StaticRef { def_id: DefId, is_thread_local: bool },\n+    /// A temporary created that references the const with the given `DefId`\n+    ConstRef { def_id: DefId },\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n@@ -1051,6 +1113,25 @@ pub struct VarDebugInfo<'tcx> {\n // BasicBlock\n \n rustc_index::newtype_index! {\n+    /// A node in the MIR [control-flow graph][CFG].\n+    ///\n+    /// There are no branches (e.g., `if`s, function calls, etc.) within a basic block, which makes\n+    /// it easier to do [data-flow analyses] and optimizations. Instead, branches are represented\n+    /// as an edge in a graph between basic blocks.\n+    ///\n+    /// Basic blocks consist of a series of [statements][Statement], ending with a\n+    /// [terminator][Terminator]. Basic blocks can have multiple predecessors and successors,\n+    /// however there is a MIR pass ([`CriticalCallEdges`]) that removes *critical edges*, which\n+    /// are edges that go from a multi-successor node to a multi-predecessor node. This pass is\n+    /// needed because some analyses require that there are no critical edges in the CFG.\n+    ///\n+    /// Read more about basic blocks in the [rustc-dev-guide][guide-mir].\n+    ///\n+    /// [CFG]: https://rustc-dev-guide.rust-lang.org/appendix/background.html#cfg\n+    /// [data-flow analyses]:\n+    ///     https://rustc-dev-guide.rust-lang.org/appendix/background.html#what-is-a-dataflow-analysis\n+    /// [`CriticalCallEdges`]: ../../rustc_mir/transform/add_call_guards/enum.AddCallGuards.html#variant.CriticalCallEdges\n+    /// [guide-mir]: https://rustc-dev-guide.rust-lang.org/mir/\n     pub struct BasicBlock {\n         derive [HashStable]\n         DEBUG_FORMAT = \"bb{}\",\n@@ -1067,6 +1148,7 @@ impl BasicBlock {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n \n+/// See [`BasicBlock`] for documentation on what basic blocks are at a high level.\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct BasicBlockData<'tcx> {\n     /// List of statements in this block.\n@@ -1254,49 +1336,49 @@ impl<O> AssertKind<O> {\n         match self {\n             BoundsCheck { ref len, ref index } => write!(\n                 f,\n-                \"\\\"index out of bounds: the len is {{}} but the index is {{}}\\\", {:?}, {:?}\",\n+                \"\\\"index out of bounds: the length is {{}} but the index is {{}}\\\", {:?}, {:?}\",\n                 len, index\n             ),\n \n             OverflowNeg(op) => {\n-                write!(f, \"\\\"attempt to negate {{}} which would overflow\\\", {:?}\", op)\n+                write!(f, \"\\\"attempt to negate `{{}}`, which would overflow\\\", {:?}\", op)\n             }\n-            DivisionByZero(op) => write!(f, \"\\\"attempt to divide {{}} by zero\\\", {:?}\", op),\n+            DivisionByZero(op) => write!(f, \"\\\"attempt to divide `{{}}` by zero\\\", {:?}\", op),\n             RemainderByZero(op) => write!(\n                 f,\n-                \"\\\"attempt to calculate the remainder of {{}} with a divisor of zero\\\", {:?}\",\n+                \"\\\"attempt to calculate the remainder of `{{}}` with a divisor of zero\\\", {:?}\",\n                 op\n             ),\n             Overflow(BinOp::Add, l, r) => write!(\n                 f,\n-                \"\\\"attempt to compute `{{}} + {{}}` which would overflow\\\", {:?}, {:?}\",\n+                \"\\\"attempt to compute `{{}} + {{}}`, which would overflow\\\", {:?}, {:?}\",\n                 l, r\n             ),\n             Overflow(BinOp::Sub, l, r) => write!(\n                 f,\n-                \"\\\"attempt to compute `{{}} - {{}}` which would overflow\\\", {:?}, {:?}\",\n+                \"\\\"attempt to compute `{{}} - {{}}`, which would overflow\\\", {:?}, {:?}\",\n                 l, r\n             ),\n             Overflow(BinOp::Mul, l, r) => write!(\n                 f,\n-                \"\\\"attempt to compute `{{}} * {{}}` which would overflow\\\", {:?}, {:?}\",\n+                \"\\\"attempt to compute `{{}} * {{}}`, which would overflow\\\", {:?}, {:?}\",\n                 l, r\n             ),\n             Overflow(BinOp::Div, l, r) => write!(\n                 f,\n-                \"\\\"attempt to compute `{{}} / {{}}` which would overflow\\\", {:?}, {:?}\",\n+                \"\\\"attempt to compute `{{}} / {{}}`, which would overflow\\\", {:?}, {:?}\",\n                 l, r\n             ),\n             Overflow(BinOp::Rem, l, r) => write!(\n                 f,\n-                \"\\\"attempt to compute the remainder of `{{}} % {{}}` which would overflow\\\", {:?}, {:?}\",\n+                \"\\\"attempt to compute the remainder of `{{}} % {{}}`, which would overflow\\\", {:?}, {:?}\",\n                 l, r\n             ),\n             Overflow(BinOp::Shr, _, r) => {\n-                write!(f, \"\\\"attempt to shift right by {{}} which would overflow\\\", {:?}\", r)\n+                write!(f, \"\\\"attempt to shift right by `{{}}`, which would overflow\\\", {:?}\", r)\n             }\n             Overflow(BinOp::Shl, _, r) => {\n-                write!(f, \"\\\"attempt to shift left by {{}} which would overflow\\\", {:?}\", r)\n+                write!(f, \"\\\"attempt to shift left by `{{}}`, which would overflow\\\", {:?}\", r)\n             }\n             _ => write!(f, \"\\\"{}\\\"\", self.description()),\n         }\n@@ -1307,36 +1389,40 @@ impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use AssertKind::*;\n         match self {\n-            BoundsCheck { ref len, ref index } => {\n-                write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index)\n-            }\n-            OverflowNeg(op) => write!(f, \"attempt to negate {:#?} which would overflow\", op),\n-            DivisionByZero(op) => write!(f, \"attempt to divide {:#?} by zero\", op),\n-            RemainderByZero(op) => {\n-                write!(f, \"attempt to calculate the remainder of {:#?} with a divisor of zero\", op)\n-            }\n+            BoundsCheck { ref len, ref index } => write!(\n+                f,\n+                \"index out of bounds: the length is {:?} but the index is {:?}\",\n+                len, index\n+            ),\n+            OverflowNeg(op) => write!(f, \"attempt to negate `{:#?}`, which would overflow\", op),\n+            DivisionByZero(op) => write!(f, \"attempt to divide `{:#?}` by zero\", op),\n+            RemainderByZero(op) => write!(\n+                f,\n+                \"attempt to calculate the remainder of `{:#?}` with a divisor of zero\",\n+                op\n+            ),\n             Overflow(BinOp::Add, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} + {:#?}` which would overflow\", l, r)\n+                write!(f, \"attempt to compute `{:#?} + {:#?}`, which would overflow\", l, r)\n             }\n             Overflow(BinOp::Sub, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} - {:#?}` which would overflow\", l, r)\n+                write!(f, \"attempt to compute `{:#?} - {:#?}`, which would overflow\", l, r)\n             }\n             Overflow(BinOp::Mul, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} * {:#?}` which would overflow\", l, r)\n+                write!(f, \"attempt to compute `{:#?} * {:#?}`, which would overflow\", l, r)\n             }\n             Overflow(BinOp::Div, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} / {:#?}` which would overflow\", l, r)\n+                write!(f, \"attempt to compute `{:#?} / {:#?}`, which would overflow\", l, r)\n             }\n             Overflow(BinOp::Rem, l, r) => write!(\n                 f,\n-                \"attempt to compute the remainder of `{:#?} % {:#?}` which would overflow\",\n+                \"attempt to compute the remainder of `{:#?} % {:#?}`, which would overflow\",\n                 l, r\n             ),\n             Overflow(BinOp::Shr, _, r) => {\n-                write!(f, \"attempt to shift right by {:#?} which would overflow\", r)\n+                write!(f, \"attempt to shift right by `{:#?}`, which would overflow\", r)\n             }\n             Overflow(BinOp::Shl, _, r) => {\n-                write!(f, \"attempt to shift left by {:#?} which would overflow\", r)\n+                write!(f, \"attempt to shift left by `{:#?}`, which would overflow\", r)\n             }\n             _ => write!(f, \"{}\", self.description()),\n         }\n@@ -1954,6 +2040,15 @@ impl<'tcx> Operand<'tcx> {\n             Operand::Constant(_) => None,\n         }\n     }\n+\n+    /// Returns the `Constant` that is the target of this `Operand`, or `None` if this `Operand` is a\n+    /// place.\n+    pub fn constant(&self) -> Option<&Constant<'tcx>> {\n+        match self {\n+            Operand::Constant(x) => Some(&**x),\n+            Operand::Copy(_) | Operand::Move(_) => None,\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -2251,8 +2346,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// Constants\n ///\n /// Two constants are equal if they are the same constant. Note that\n-/// this does not necessarily mean that they are \"==\" in Rust -- in\n-/// particular one must be wary of `NaN`!\n+/// this does not necessarily mean that they are `==` in Rust. In\n+/// particular, one must be wary of `NaN`!\n \n #[derive(Clone, Copy, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub struct Constant<'tcx> {"}, {"sha": "a8b748833556d8e87df876add7b8bf7d4c8d39e5", "filename": "compiler/rustc_middle/src/mir/predecessors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -33,7 +33,7 @@ impl PredecessorCache {\n         self.cache = OnceCell::new();\n     }\n \n-    /// Returns the the predecessor graph for this MIR.\n+    /// Returns the predecessor graph for this MIR.\n     #[inline]\n     pub(super) fn compute(\n         &self,"}, {"sha": "8909f02270cb36c33b07dcac63887a5272b4d2fd", "filename": "compiler/rustc_middle/src/mir/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -96,6 +96,8 @@ pub enum TerminatorKind<'tcx> {\n     ///   P <- V\n     /// }\n     /// ```\n+    ///\n+    /// Note that DropAndReplace is eliminated as part of the `ElaborateDrops` pass.\n     DropAndReplace {\n         place: Place<'tcx>,\n         value: Operand<'tcx>,"}, {"sha": "ad2eae0298cec751cef75ca12f6f8c6e858e0795", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -175,7 +175,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n         use crate::mir::Rvalue::*;\n         match *self {\n             Use(ref op) => Use(op.fold_with(folder)),\n-            Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n+            Repeat(ref op, len) => Repeat(op.fold_with(folder), len.fold_with(folder)),\n             ThreadLocalRef(did) => ThreadLocalRef(did.fold_with(folder)),\n             Ref(region, bk, ref place) => {\n                 Ref(region.fold_with(folder), bk, place.fold_with(folder))"}, {"sha": "c1f8d22c2c6701d76da80a2c477bdfcd548de748", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -752,7 +752,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_coverage(&mut self,\n-                              _kind: & $($mutability)? Coverage,\n+                              _coverage: & $($mutability)? Coverage,\n                               _location: Location) {\n             }\n \n@@ -1150,8 +1150,6 @@ pub enum NonUseContext {\n     StorageDead,\n     /// User type annotation assertions for NLL.\n     AscribeUserTy,\n-    /// Coverage code region and counter metadata.\n-    Coverage,\n     /// The data of an user variable, for debug info.\n     VarDebugInfo,\n }"}, {"sha": "d5b99ea4d288dc66a65bfe4b9fc304ade09eef5a", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 75, "deletions": 49, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -42,48 +42,48 @@ rustc_queries! {\n     }\n \n     Other {\n-        // Represents crate as a whole (as distinct from the top-level crate module).\n-        // If you call `hir_crate` (e.g., indirectly by calling `tcx.hir().krate()`),\n-        // we will have to assume that any change means that you need to be recompiled.\n-        // This is because the `hir_crate` query gives you access to all other items.\n-        // To avoid this fate, do not call `tcx.hir().krate()`; instead,\n-        // prefer wrappers like `tcx.visit_all_items_in_krate()`.\n+        /// Represents crate as a whole (as distinct from the top-level crate module).\n+        /// If you call `hir_crate` (e.g., indirectly by calling `tcx.hir().krate()`),\n+        /// we will have to assume that any change means that you need to be recompiled.\n+        /// This is because the `hir_crate` query gives you access to all other items.\n+        /// To avoid this fate, do not call `tcx.hir().krate()`; instead,\n+        /// prefer wrappers like `tcx.visit_all_items_in_krate()`.\n         query hir_crate(key: CrateNum) -> &'tcx Crate<'tcx> {\n             eval_always\n             no_hash\n             desc { \"get the crate HIR\" }\n         }\n \n-        // The indexed HIR. This can be conveniently accessed by `tcx.hir()`.\n-        // Avoid calling this query directly.\n+        /// The indexed HIR. This can be conveniently accessed by `tcx.hir()`.\n+        /// Avoid calling this query directly.\n         query index_hir(_: CrateNum) -> &'tcx map::IndexedHir<'tcx> {\n             eval_always\n             no_hash\n             desc { \"index HIR\" }\n         }\n \n-        // The items in a module.\n-        //\n-        // This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n-        // Avoid calling this query directly.\n+        /// The items in a module.\n+        ///\n+        /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n+        /// Avoid calling this query directly.\n         query hir_module_items(key: LocalDefId) -> &'tcx hir::ModuleItems {\n             eval_always\n             desc { |tcx| \"HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n-        // Gives access to the HIR node for the HIR owner `key`.\n-        //\n-        // This can be conveniently accessed by methods on `tcx.hir()`.\n-        // Avoid calling this query directly.\n+        /// Gives access to the HIR node for the HIR owner `key`.\n+        ///\n+        /// This can be conveniently accessed by methods on `tcx.hir()`.\n+        /// Avoid calling this query directly.\n         query hir_owner(key: LocalDefId) -> Option<&'tcx crate::hir::Owner<'tcx>> {\n             eval_always\n             desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n-        // Gives access to the HIR nodes and bodies inside the HIR owner `key`.\n-        //\n-        // This can be conveniently accessed by methods on `tcx.hir()`.\n-        // Avoid calling this query directly.\n+        /// Gives access to the HIR nodes and bodies inside the HIR owner `key`.\n+        ///\n+        /// This can be conveniently accessed by methods on `tcx.hir()`.\n+        /// Avoid calling this query directly.\n         query hir_owner_nodes(key: LocalDefId) -> Option<&'tcx crate::hir::OwnerNodes<'tcx>> {\n             eval_always\n             desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n@@ -244,6 +244,35 @@ rustc_queries! {\n             no_hash\n         }\n \n+        /// Try to build an abstract representation of the given constant.\n+        query mir_abstract_const(\n+            key: DefId\n+        ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+            desc {\n+                |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n+            }\n+        }\n+        /// Try to build an abstract representation of the given constant.\n+        query mir_abstract_const_of_const_arg(\n+            key: (LocalDefId, DefId)\n+        ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+            desc {\n+                |tcx|\n+                \"building an abstract representation for the const argument {}\",\n+                tcx.def_path_str(key.0.to_def_id()),\n+            }\n+        }\n+\n+        query try_unify_abstract_consts(key: (\n+            (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n+            (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>)\n+        )) -> bool {\n+            desc {\n+                |tcx| \"trying to unify the generic constants {} and {}\",\n+                tcx.def_path_str(key.0.0.did), tcx.def_path_str(key.1.0.did)\n+            }\n+        }\n+\n         query mir_drops_elaborated_and_const_checked(\n             key: ty::WithOptConstParam<LocalDefId>\n         ) -> &'tcx Steal<mir::Body<'tcx>> {\n@@ -305,9 +334,9 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        // Erases regions from `ty` to yield a new type.\n-        // Normally you would just use `tcx.erase_regions(&value)`,\n-        // however, which uses this query as a kind of cache.\n+        /// Erases regions from `ty` to yield a new type.\n+        /// Normally you would just use `tcx.erase_regions(&value)`,\n+        /// however, which uses this query as a kind of cache.\n         query erase_regions_ty(ty: Ty<'tcx>) -> Ty<'tcx> {\n             // This query is not expected to have input -- as a result, it\n             // is not a good candidates for \"replay\" because it is essentially a\n@@ -428,10 +457,6 @@ rustc_queries! {\n             desc { |tcx| \"checking if item is promotable: `{}`\", tcx.def_path_str(key) }\n         }\n \n-        query const_fn_is_allowed_fn_ptr(key: DefId) -> bool {\n-            desc { |tcx| \"checking if const fn allows `fn()` types: `{}`\", tcx.def_path_str(key) }\n-        }\n-\n         /// Returns `true` if this is a foreign item (i.e., linked via `extern { ... }`).\n         query is_foreign_item(key: DefId) -> bool {\n             desc { |tcx| \"checking if `{}` is a foreign item\", tcx.def_path_str(key) }\n@@ -678,38 +703,31 @@ rustc_queries! {\n     }\n \n     Other {\n-        /// Evaluates a constant without running sanity checks.\n+        /// Evaluates a constant and returns the computed allocation.\n         ///\n-        /// **Do not use this** outside const eval. Const eval uses this to break query cycles\n-        /// during validation. Please add a comment to every use site explaining why using\n-        /// `const_eval_validated` isn't sufficient. The returned constant also isn't in a suitable\n-        /// form to be used outside of const eval.\n-        query const_eval_raw(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-            -> ConstEvalRawResult<'tcx> {\n+        /// **Do not use this** directly, use the `tcx.eval_static_initializer` wrapper.\n+        query eval_to_allocation_raw(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+            -> EvalToAllocationRawResult<'tcx> {\n             desc { |tcx|\n-                \"const-evaluating `{}`\",\n+                \"const-evaluating + checking `{}`\",\n                 key.value.display(tcx)\n             }\n+            cache_on_disk_if { true }\n         }\n \n-        /// Results of evaluating const items or constants embedded in\n-        /// other items (such as enum variant explicit discriminants).\n-        ///\n-        /// In contrast to `const_eval_raw` this performs some validation on the constant, and\n-        /// returns a proper constant that is usable by the rest of the compiler.\n+        /// Evaluates const items or anonymous constants\n+        /// (such as enum variant explicit discriminants or array lengths)\n+        /// into a representation suitable for the type system and const generics.\n         ///\n         /// **Do not use this** directly, use one of the following wrappers: `tcx.const_eval_poly`,\n         /// `tcx.const_eval_resolve`, `tcx.const_eval_instance`, or `tcx.const_eval_global_id`.\n-        query const_eval_validated(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-            -> ConstEvalResult<'tcx> {\n+        query eval_to_const_value_raw(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+            -> EvalToConstValueResult<'tcx> {\n             desc { |tcx|\n-                \"const-evaluating + checking `{}`\",\n+                \"simplifying constant for the type system `{}`\",\n                 key.value.display(tcx)\n             }\n-            cache_on_disk_if(_, opt_result) {\n-                // Only store results without errors\n-                opt_result.map_or(true, |r| r.is_ok())\n-            }\n+            cache_on_disk_if { true }\n         }\n \n         /// Destructure a constant ADT or array into its variant index and its\n@@ -720,6 +738,14 @@ rustc_queries! {\n             desc { \"destructure constant\" }\n         }\n \n+        /// Dereference a constant reference or raw pointer and turn the result into a constant\n+        /// again.\n+        query deref_const(\n+            key: ty::ParamEnvAnd<'tcx, &'tcx ty::Const<'tcx>>\n+        ) -> &'tcx ty::Const<'tcx> {\n+            desc { \"deref constant\" }\n+        }\n+\n         query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n             desc { \"get a &core::panic::Location referring to a span\" }\n         }\n@@ -1399,7 +1425,7 @@ rustc_queries! {\n         }\n \n         query evaluate_goal(\n-            goal: traits::ChalkCanonicalGoal<'tcx>\n+            goal: traits::CanonicalChalkEnvironmentAndGoal<'tcx>\n         ) -> Result<\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution\n@@ -1514,7 +1540,7 @@ rustc_queries! {\n             desc { \"looking up supported target features\" }\n         }\n \n-        // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n+        /// Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n         query instance_def_size_estimate(def: ty::InstanceDef<'tcx>)\n             -> usize {\n             desc { |tcx| \"estimating size for `{}`\", tcx.def_path_str(def.def_id()) }"}, {"sha": "d8507d08c1bc5217540df1d092537354d3e96057", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 54, "deletions": 29, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -6,14 +6,11 @@\n //! interned Chalk types.\n \n use rustc_middle::mir::interpret::ConstValue;\n-use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtDef, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n use rustc_target::spec::abi::Abi;\n \n-use smallvec::SmallVec;\n-\n use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n@@ -75,6 +72,7 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n     type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n     type InternedVariableKinds = Vec<chalk_ir::VariableKind<Self>>;\n     type InternedCanonicalVarKinds = Vec<chalk_ir::CanonicalVarKind<Self>>;\n+    type InternedConstraints = Vec<chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>>;\n     type DefId = DefId;\n     type InternedAdtId = &'tcx AdtDef;\n     type Identifier = ();\n@@ -108,8 +106,42 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         application_ty: &chalk_ir::ApplicationTy<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n-        Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n+        match application_ty.name {\n+            chalk_ir::TypeName::Ref(mutbl) => {\n+                let data = application_ty.substitution.interned();\n+                match (&**data[0].interned(), &**data[1].interned()) {\n+                    (\n+                        chalk_ir::GenericArgData::Lifetime(lifetime),\n+                        chalk_ir::GenericArgData::Ty(ty),\n+                    ) => Some(match mutbl {\n+                        chalk_ir::Mutability::Not => write!(fmt, \"(&{:?} {:?})\", lifetime, ty),\n+                        chalk_ir::Mutability::Mut => write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty),\n+                    }),\n+                    _ => unreachable!(),\n+                }\n+            }\n+            chalk_ir::TypeName::Array => {\n+                let data = application_ty.substitution.interned();\n+                match (&**data[0].interned(), &**data[1].interned()) {\n+                    (chalk_ir::GenericArgData::Ty(ty), chalk_ir::GenericArgData::Const(len)) => {\n+                        Some(write!(fmt, \"[{:?}; {:?}]\", ty, len))\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+            chalk_ir::TypeName::Slice => {\n+                let data = application_ty.substitution.interned();\n+                let ty = match &**data[0].interned() {\n+                    chalk_ir::GenericArgData::Ty(t) => t,\n+                    _ => unreachable!(),\n+                };\n+                Some(write!(fmt, \"[{:?}]\", ty))\n+            }\n+            _ => {\n+                let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n+                Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n+            }\n+        }\n     }\n \n     fn debug_substitution(\n@@ -321,37 +353,30 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n     ) -> &'a [chalk_ir::CanonicalVarKind<Self>] {\n         canonical_var_kinds\n     }\n+\n+    fn intern_constraints<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>, E>>,\n+    ) -> Result<Self::InternedConstraints, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn constraints_data<'a>(\n+        &self,\n+        constraints: &'a Self::InternedConstraints,\n+    ) -> &'a [chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>] {\n+        constraints\n+    }\n }\n \n impl<'tcx> chalk_ir::interner::HasInterner for RustInterner<'tcx> {\n     type Interner = Self;\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub enum ChalkEnvironmentClause<'tcx> {\n-    /// A normal rust `ty::Predicate` in the environment.\n-    Predicate(ty::Predicate<'tcx>),\n-    /// A special clause in the environment that gets lowered to\n-    /// `chalk_ir::FromEnv::Ty`.\n-    TypeFromEnv(Ty<'tcx>),\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ChalkEnvironmentClause<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_chalk_environment_clause_list(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-/// We have to elaborate the environment of a chalk goal *before*\n-/// canonicalization. This type wraps the predicate and the elaborated\n-/// environment.\n+/// A chalk environment and goal.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n pub struct ChalkEnvironmentAndGoal<'tcx> {\n-    pub environment: &'tcx ty::List<ChalkEnvironmentClause<'tcx>>,\n+    pub environment: &'tcx ty::List<ty::Predicate<'tcx>>,\n     pub goal: ty::Predicate<'tcx>,\n }\n "}, {"sha": "1dd6d590d908f36888dbda90131a49860c1fc5ea", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -26,14 +26,11 @@ use std::rc::Rc;\n \n pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n \n-pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx>>;\n+pub type CanonicalChalkEnvironmentAndGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx>>;\n \n-pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n \n-pub use self::chalk::{\n-    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustInterner as ChalkRustInterner,\n-};\n+pub use self::chalk::{ChalkEnvironmentAndGoal, RustInterner as ChalkRustInterner};\n \n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n@@ -350,13 +347,16 @@ pub struct MatchExpressionArmCause<'tcx> {\n     pub prior_arms: Vec<Span>,\n     pub last_ty: Ty<'tcx>,\n     pub scrut_hir_id: hir::HirId,\n+    pub opt_suggest_box_span: Option<Span>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct IfExpressionCause {\n     pub then: Span,\n+    pub else_sp: Span,\n     pub outer: Option<Span>,\n     pub semicolon: Option<Span>,\n+    pub opt_suggest_box_span: Option<Span>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n@@ -417,10 +417,10 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n ///\n ///     // Case B: ImplSource must be provided by caller. This applies when\n ///     // type is a type parameter.\n-///     param.clone();    // ImplSourceParam\n+///     param.clone();    // ImplSource::Param\n ///\n ///     // Case C: A mix of cases A and B.\n-///     mixed.clone();    // ImplSource(Impl_1, [ImplSourceParam])\n+///     mixed.clone();    // ImplSource(Impl_1, [ImplSource::Param])\n /// }\n /// ```\n ///\n@@ -430,72 +430,72 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub enum ImplSource<'tcx, N> {\n     /// ImplSource identifying a particular impl.\n-    ImplSourceUserDefined(ImplSourceUserDefinedData<'tcx, N>),\n+    UserDefined(ImplSourceUserDefinedData<'tcx, N>),\n \n     /// ImplSource for auto trait implementations.\n     /// This carries the information and nested obligations with regards\n     /// to an auto implementation for a trait `Trait`. The nested obligations\n     /// ensure the trait implementation holds for all the constituent types.\n-    ImplSourceAutoImpl(ImplSourceAutoImplData<N>),\n+    AutoImpl(ImplSourceAutoImplData<N>),\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter. The `Vec<N>` represents the\n     /// obligations incurred from normalizing the where-clause (if\n     /// any).\n-    ImplSourceParam(Vec<N>),\n+    Param(Vec<N>),\n \n     /// Virtual calls through an object.\n-    ImplSourceObject(ImplSourceObjectData<'tcx, N>),\n+    Object(ImplSourceObjectData<'tcx, N>),\n \n     /// Successful resolution for a builtin trait.\n-    ImplSourceBuiltin(ImplSourceBuiltinData<N>),\n+    Builtin(ImplSourceBuiltinData<N>),\n \n     /// ImplSource automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `ImplSourceUserDefined` in spirit, but the\n+    /// of the closure expression. This is a `ImplSource::UserDefined` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n-    ImplSourceClosure(ImplSourceClosureData<'tcx, N>),\n+    Closure(ImplSourceClosureData<'tcx, N>),\n \n     /// Same as above, but for a function pointer type with the given signature.\n-    ImplSourceFnPointer(ImplSourceFnPointerData<'tcx, N>),\n+    FnPointer(ImplSourceFnPointerData<'tcx, N>),\n \n     /// ImplSource for a builtin `DeterminantKind` trait implementation.\n-    ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData),\n+    DiscriminantKind(ImplSourceDiscriminantKindData),\n \n     /// ImplSource automatically generated for a generator.\n-    ImplSourceGenerator(ImplSourceGeneratorData<'tcx, N>),\n+    Generator(ImplSourceGeneratorData<'tcx, N>),\n \n     /// ImplSource for a trait alias.\n-    ImplSourceTraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n+    TraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n }\n \n impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {\n-            ImplSourceUserDefined(i) => i.nested,\n-            ImplSourceParam(n) => n,\n-            ImplSourceBuiltin(i) => i.nested,\n-            ImplSourceAutoImpl(d) => d.nested,\n-            ImplSourceClosure(c) => c.nested,\n-            ImplSourceGenerator(c) => c.nested,\n-            ImplSourceObject(d) => d.nested,\n-            ImplSourceFnPointer(d) => d.nested,\n-            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => Vec::new(),\n-            ImplSourceTraitAlias(d) => d.nested,\n+            ImplSource::UserDefined(i) => i.nested,\n+            ImplSource::Param(n) => n,\n+            ImplSource::Builtin(i) => i.nested,\n+            ImplSource::AutoImpl(d) => d.nested,\n+            ImplSource::Closure(c) => c.nested,\n+            ImplSource::Generator(c) => c.nested,\n+            ImplSource::Object(d) => d.nested,\n+            ImplSource::FnPointer(d) => d.nested,\n+            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => Vec::new(),\n+            ImplSource::TraitAlias(d) => d.nested,\n         }\n     }\n \n     pub fn borrow_nested_obligations(&self) -> &[N] {\n         match &self {\n-            ImplSourceUserDefined(i) => &i.nested[..],\n-            ImplSourceParam(n) => &n[..],\n-            ImplSourceBuiltin(i) => &i.nested[..],\n-            ImplSourceAutoImpl(d) => &d.nested[..],\n-            ImplSourceClosure(c) => &c.nested[..],\n-            ImplSourceGenerator(c) => &c.nested[..],\n-            ImplSourceObject(d) => &d.nested[..],\n-            ImplSourceFnPointer(d) => &d.nested[..],\n-            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => &[],\n-            ImplSourceTraitAlias(d) => &d.nested[..],\n+            ImplSource::UserDefined(i) => &i.nested[..],\n+            ImplSource::Param(n) => &n[..],\n+            ImplSource::Builtin(i) => &i.nested[..],\n+            ImplSource::AutoImpl(d) => &d.nested[..],\n+            ImplSource::Closure(c) => &c.nested[..],\n+            ImplSource::Generator(c) => &c.nested[..],\n+            ImplSource::Object(d) => &d.nested[..],\n+            ImplSource::FnPointer(d) => &d.nested[..],\n+            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => &[],\n+            ImplSource::TraitAlias(d) => &d.nested[..],\n         }\n     }\n \n@@ -504,42 +504,42 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n         F: FnMut(N) -> M,\n     {\n         match self {\n-            ImplSourceUserDefined(i) => ImplSourceUserDefined(ImplSourceUserDefinedData {\n+            ImplSource::UserDefined(i) => ImplSource::UserDefined(ImplSourceUserDefinedData {\n                 impl_def_id: i.impl_def_id,\n                 substs: i.substs,\n                 nested: i.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceParam(n) => ImplSourceParam(n.into_iter().map(f).collect()),\n-            ImplSourceBuiltin(i) => ImplSourceBuiltin(ImplSourceBuiltinData {\n+            ImplSource::Param(n) => ImplSource::Param(n.into_iter().map(f).collect()),\n+            ImplSource::Builtin(i) => ImplSource::Builtin(ImplSourceBuiltinData {\n                 nested: i.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceObject(o) => ImplSourceObject(ImplSourceObjectData {\n+            ImplSource::Object(o) => ImplSource::Object(ImplSourceObjectData {\n                 upcast_trait_ref: o.upcast_trait_ref,\n                 vtable_base: o.vtable_base,\n                 nested: o.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceAutoImpl(d) => ImplSourceAutoImpl(ImplSourceAutoImplData {\n+            ImplSource::AutoImpl(d) => ImplSource::AutoImpl(ImplSourceAutoImplData {\n                 trait_def_id: d.trait_def_id,\n                 nested: d.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceClosure(c) => ImplSourceClosure(ImplSourceClosureData {\n+            ImplSource::Closure(c) => ImplSource::Closure(ImplSourceClosureData {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceGenerator(c) => ImplSourceGenerator(ImplSourceGeneratorData {\n+            ImplSource::Generator(c) => ImplSource::Generator(ImplSourceGeneratorData {\n                 generator_def_id: c.generator_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceFnPointer(p) => ImplSourceFnPointer(ImplSourceFnPointerData {\n+            ImplSource::FnPointer(p) => ImplSource::FnPointer(ImplSourceFnPointerData {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => {\n-                ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData)\n+            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => {\n+                ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n             }\n-            ImplSourceTraitAlias(d) => ImplSourceTraitAlias(ImplSourceTraitAliasData {\n+            ImplSource::TraitAlias(d) => ImplSource::TraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n                 nested: d.nested.into_iter().map(f).collect(),"}, {"sha": "f9cadb3bb2dbc03948e2c413a13c103d5e3abe0d", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -190,74 +190,6 @@ impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n     }\n }\n \n-/// This returns true if the type `ty` is \"trivial\" for\n-/// dropck-outlives -- that is, if it doesn't require any types to\n-/// outlive. This is similar but not *quite* the same as the\n-/// `needs_drop` test in the compiler already -- that is, for every\n-/// type T for which this function return true, needs-drop would\n-/// return `false`. But the reverse does not hold: in particular,\n-/// `needs_drop` returns false for `PhantomData`, but it is not\n-/// trivial for dropck-outlives.\n-///\n-/// Note also that `needs_drop` requires a \"global\" type (i.e., one\n-/// with erased regions), but this function does not.\n-pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind() {\n-        // None of these types have a destructor and hence they do not\n-        // require anything in particular to outlive the dtor's\n-        // execution.\n-        ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Bool\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Never\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Char\n-        | ty::GeneratorWitness(..)\n-        | ty::RawPtr(_)\n-        | ty::Ref(..)\n-        | ty::Str\n-        | ty::Foreign(..)\n-        | ty::Error(_) => true,\n-\n-        // [T; N] and [T] have same properties as T.\n-        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n-\n-        // (T1..Tn) and closures have same properties as T1..Tn --\n-        // check if *any* of those are trivial.\n-        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n-        ty::Closure(_, ref substs) => {\n-            substs.as_closure().upvar_tys().all(|t| trivial_dropck_outlives(tcx, t))\n-        }\n-\n-        ty::Adt(def, _) => {\n-            if Some(def.did) == tcx.lang_items().manually_drop() {\n-                // `ManuallyDrop` never has a dtor.\n-                true\n-            } else {\n-                // Other types might. Moreover, PhantomData doesn't\n-                // have a dtor, but it is considered to own its\n-                // content, so it is non-trivial. Unions can have `impl Drop`,\n-                // and hence are non-trivial as well.\n-                false\n-            }\n-        }\n-\n-        // The following *might* require a destructor: needs deeper inspection.\n-        ty::Dynamic(..)\n-        | ty::Projection(..)\n-        | ty::Param(_)\n-        | ty::Opaque(..)\n-        | ty::Placeholder(..)\n-        | ty::Infer(_)\n-        | ty::Bound(..)\n-        | ty::Generator(..) => false,\n-    }\n-}\n-\n #[derive(Debug, HashStable)]\n pub struct CandidateStep<'tcx> {\n     pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,"}, {"sha": "b8f6675b8e2197778c53271ad1c3093ba10258a3", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -7,25 +7,25 @@ use std::fmt;\n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            super::ImplSourceUserDefined(ref v) => write!(f, \"{:?}\", v),\n+            super::ImplSource::UserDefined(ref v) => write!(f, \"{:?}\", v),\n \n-            super::ImplSourceAutoImpl(ref t) => write!(f, \"{:?}\", t),\n+            super::ImplSource::AutoImpl(ref t) => write!(f, \"{:?}\", t),\n \n-            super::ImplSourceClosure(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::Closure(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceGenerator(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::Generator(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceFnPointer(ref d) => write!(f, \"ImplSourceFnPointer({:?})\", d),\n+            super::ImplSource::FnPointer(ref d) => write!(f, \"({:?})\", d),\n \n-            super::ImplSourceDiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::DiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceObject(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::Object(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceParam(ref n) => write!(f, \"ImplSourceParam({:?})\", n),\n+            super::ImplSource::Param(ref n) => write!(f, \"ImplSourceParamData({:?})\", n),\n \n-            super::ImplSourceBuiltin(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::Builtin(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceTraitAlias(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::TraitAlias(ref d) => write!(f, \"{:?}\", d),\n         }\n     }\n }\n@@ -96,7 +96,7 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx,\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"ImplSourceTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceTraitAliasData(alias_def_id={:?}, substs={:?}, nested={:?})\",\n             self.alias_def_id, self.substs, self.nested\n         )\n     }"}, {"sha": "46ef5ff7dd8c5c97e71278b3df39e44040ef2716", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,6 +4,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_macros::HashStable;\n+use rustc_span::Span;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum PointerCast {\n@@ -113,6 +114,9 @@ pub enum Adjust<'tcx> {\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n+    /// The `Span` associated with the field access or method call\n+    /// that triggered this overloaded deref.\n+    pub span: Span,\n }\n \n impl<'tcx> OverloadedDeref<'tcx> {"}, {"sha": "8ea34f9161abcf563c06fc0ae8b5f9603ea14af8", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -357,6 +357,26 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>,\n     }\n }\n \n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::Node<'tcx>] {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()?)\n+                .map(|_| Decodable::decode(decoder))\n+                .collect::<Result<Vec<_>, _>>()?,\n+        ))\n+    }\n+}\n+\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::NodeId] {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()?)\n+                .map(|_| Decodable::decode(decoder))\n+                .collect::<Result<Vec<_>, _>>()?,\n+        ))\n+    }\n+}\n+\n impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,"}, {"sha": "22c3fd37be14d0d07620e8d19754b68a70e56258", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 15, "deletions": 39, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -66,8 +66,8 @@ use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n-/// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n-/// except through `tcx.err*()`, which are in this module.\n+/// A type that is not publicly constructable. This prevents people from making [`TyKind::Error`]s\n+/// except through the error-reporting functions on a [`tcx`][TyCtxt].\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n #[derive(TyEncodable, TyDecodable, HashStable)]\n pub struct DelaySpanBugEmitted(());\n@@ -91,8 +91,6 @@ pub struct CtxtInterners<'tcx> {\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n-\n-    chalk_environment_clause_list: InternedSet<'tcx, List<traits::ChalkEnvironmentClause<'tcx>>>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -110,7 +108,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n             projs: Default::default(),\n             place_elems: Default::default(),\n             const_: Default::default(),\n-            chalk_environment_clause_list: Default::default(),\n         }\n     }\n \n@@ -1182,7 +1179,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_const(ty::Const { val: ty::ConstKind::Error(DelaySpanBugEmitted(())), ty })\n     }\n \n-    pub fn consider_optimizing<T: Fn() -> String>(&self, msg: T) -> bool {\n+    pub fn consider_optimizing<T: Fn() -> String>(self, msg: T) -> bool {\n         let cname = self.crate_name(LOCAL_CRATE).as_str();\n         self.sess.consider_optimizing(&cname, msg)\n     }\n@@ -1275,7 +1272,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             // Don't print the whole crate disambiguator. That's just\n             // annoying in debug output.\n             &(crate_disambiguator.to_fingerprint().to_hex())[..4],\n-            self.def_path(def_id).to_string_no_crate()\n+            self.def_path(def_id).to_string_no_crate_verbose()\n         )\n     }\n \n@@ -1406,7 +1403,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     // Returns the `DefId` and the `BoundRegion` corresponding to the given region.\n-    pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n+    pub fn is_suitable_region(self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => {\n                 (free_region.scope.expect_local(), free_region.bound_region)\n@@ -1436,7 +1433,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Given a `DefId` for an `fn`, return all the `dyn` and `impl` traits in its return type.\n     pub fn return_type_impl_or_dyn_traits(\n-        &self,\n+        self,\n         scope_def_id: LocalDefId,\n     ) -> Vec<&'tcx hir::Ty<'tcx>> {\n         let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n@@ -1482,7 +1479,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         v.0\n     }\n \n-    pub fn return_type_impl_trait(&self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n+    pub fn return_type_impl_trait(self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n         let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n         match self.hir().get(hir_id) {\n@@ -1500,7 +1497,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let ret_ty = self.type_of(scope_def_id);\n         match ret_ty.kind() {\n             ty::FnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(*self);\n+                let sig = ret_ty.fn_sig(self);\n                 let output = self.erase_late_bound_regions(&sig.output());\n                 if output.is_impl_trait() {\n                     let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n@@ -1514,7 +1511,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     // Checks if the bound region is in Impl Item.\n-    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: LocalDefId) -> bool {\n+    pub fn is_bound_region_in_impl_item(self, suitable_region_binding_scope: LocalDefId) -> bool {\n         let container_id =\n             self.associated_item(suitable_region_binding_scope.to_def_id()).container.id();\n         if self.impl_trait_ref(container_id).is_some() {\n@@ -1531,21 +1528,21 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Determines whether identifiers in the assembly have strict naming rules.\n     /// Currently, only NVPTX* targets need it.\n-    pub fn has_strict_asm_symbol_naming(&self) -> bool {\n+    pub fn has_strict_asm_symbol_naming(self) -> bool {\n         self.sess.target.target.arch.contains(\"nvptx\")\n     }\n \n     /// Returns `&'static core::panic::Location<'static>`.\n-    pub fn caller_location_ty(&self) -> Ty<'tcx> {\n+    pub fn caller_location_ty(self) -> Ty<'tcx> {\n         self.mk_imm_ref(\n             self.lifetimes.re_static,\n             self.type_of(self.require_lang_item(LangItem::PanicLocation, None))\n-                .subst(*self, self.mk_substs([self.lifetimes.re_static.into()].iter())),\n+                .subst(self, self.mk_substs([self.lifetimes.re_static.into()].iter())),\n         )\n     }\n \n     /// Returns a displayable description and article for the given `def_id` (e.g. `(\"a\", \"struct\")`).\n-    pub fn article_and_description(&self, def_id: DefId) -> (&'static str, &'static str) {\n+    pub fn article_and_description(self, def_id: DefId) -> (&'static str, &'static str) {\n         match self.def_kind(def_id) {\n             DefKind::Generator => match self.generator_kind(def_id).unwrap() {\n                 rustc_hir::GeneratorKind::Async(..) => (\"an\", \"async closure\"),\n@@ -2041,7 +2038,7 @@ direct_interners! {\n }\n \n macro_rules! slice_interners {\n-    ($($field:ident: $method:ident($ty:ty)),+) => (\n+    ($($field:ident: $method:ident($ty:ty)),+ $(,)?) => (\n         $(impl<'tcx> TyCtxt<'tcx> {\n             pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n                 self.interners.$field.intern_ref(v, || {\n@@ -2060,8 +2057,6 @@ slice_interners!(\n     predicates: _intern_predicates(Predicate<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n     place_elems: _intern_place_elems(PlaceElem<'tcx>),\n-    chalk_environment_clause_list:\n-        _intern_chalk_environment_clause_list(traits::ChalkEnvironmentClause<'tcx>)\n );\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -2424,7 +2419,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         eps: &[ExistentialPredicate<'tcx>],\n     ) -> &'tcx List<ExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());\n-        assert!(eps.windows(2).all(|w| w[0].stable_cmp(self, &w[1]) != Ordering::Greater));\n+        assert!(eps.array_windows().all(|[a, b]| a.stable_cmp(self, b) != Ordering::Greater));\n         self._intern_existential_predicates(eps)\n     }\n \n@@ -2460,13 +2455,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { List::empty() } else { self._intern_canonical_var_infos(ts) }\n     }\n \n-    pub fn intern_chalk_environment_clause_list(\n-        self,\n-        ts: &[traits::ChalkEnvironmentClause<'tcx>],\n-    ) -> &'tcx List<traits::ChalkEnvironmentClause<'tcx>> {\n-        if ts.is_empty() { List::empty() } else { self._intern_chalk_environment_clause_list(ts) }\n-    }\n-\n     pub fn mk_fn_sig<I>(\n         self,\n         inputs: I,\n@@ -2524,18 +2512,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n     }\n \n-    pub fn mk_chalk_environment_clause_list<\n-        I: InternAs<\n-            [traits::ChalkEnvironmentClause<'tcx>],\n-            &'tcx List<traits::ChalkEnvironmentClause<'tcx>>,\n-        >,\n-    >(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_chalk_environment_clause_list(xs))\n-    }\n-\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {"}, {"sha": "715319747e3900adf34732b690bc1e93a05ee94c", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -202,33 +202,59 @@ pub fn suggest_constraining_type_param(\n         //    Suggestion:\n         //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n         //                                          - insert: `, T: Zar`\n+        //\n+        // Additionally, there may be no `where` clause whatsoever in the case that this was\n+        // reached because the generic parameter has a default:\n+        //\n+        //    Message:\n+        //      trait Foo<T=()> {... }\n+        //             - help: consider further restricting this type parameter with `where T: Zar`\n+        //\n+        //    Suggestion:\n+        //      trait Foo<T=()> where T: Zar {... }\n+        //                     - insert: `where T: Zar`\n \n-        let mut param_spans = Vec::new();\n+        if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n+            && generics.where_clause.predicates.len() == 0\n+        {\n+            // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n+            // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n+            err.span_suggestion_verbose(\n+                generics.where_clause.tail_span_for_suggestion(),\n+                &msg_restrict_type_further,\n+                format!(\" where {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            let mut param_spans = Vec::new();\n \n-        for predicate in generics.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                span, bounded_ty, ..\n-            }) = predicate\n-            {\n-                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                    if let Some(segment) = path.segments.first() {\n-                        if segment.ident.to_string() == param_name {\n-                            param_spans.push(span);\n+            for predicate in generics.where_clause.predicates {\n+                if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                    span,\n+                    bounded_ty,\n+                    ..\n+                }) = predicate\n+                {\n+                    if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n+                        if let Some(segment) = path.segments.first() {\n+                            if segment.ident.to_string() == param_name {\n+                                param_spans.push(span);\n+                            }\n                         }\n                     }\n                 }\n             }\n-        }\n \n-        match &param_spans[..] {\n-            &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n-            _ => {\n-                err.span_suggestion_verbose(\n-                    generics.where_clause.tail_span_for_suggestion(),\n-                    &msg_restrict_type_further,\n-                    format!(\", {}: {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n+            match &param_spans[..] {\n+                &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+                _ => {\n+                    err.span_suggestion_verbose(\n+                        generics.where_clause.tail_span_for_suggestion(),\n+                        &msg_restrict_type_further,\n+                        format!(\", {}: {}\", param_name, constraint),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n             }\n         }\n "}, {"sha": "82d698b37ab1d4a2d97fc04f8663729a4f0cd059", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -56,6 +56,7 @@ pub enum TypeError<'tcx> {\n     /// created a cycle (because it appears somewhere within that\n     /// type).\n     CyclicTy(Ty<'tcx>),\n+    CyclicConst(&'tcx ty::Const<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n     ObjectUnsafeCoercion(DefId),\n@@ -100,6 +101,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n \n         match *self {\n             CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n+            CyclicConst(_) => write!(f, \"encountered a self-referencing constant\"),\n             Mismatch => write!(f, \"types differ\"),\n             UnsafetyMismatch(values) => {\n                 write!(f, \"expected {} fn, found {} fn\", values.expected, values.found)\n@@ -195,9 +197,9 @@ impl<'tcx> TypeError<'tcx> {\n     pub fn must_include_note(&self) -> bool {\n         use self::TypeError::*;\n         match self {\n-            CyclicTy(_) | UnsafetyMismatch(_) | Mismatch | AbiMismatch(_) | FixedArraySize(_)\n-            | Sorts(_) | IntMismatch(_) | FloatMismatch(_) | VariadicMismatch(_)\n-            | TargetFeatureCast(_) => false,\n+            CyclicTy(_) | CyclicConst(_) | UnsafetyMismatch(_) | Mismatch | AbiMismatch(_)\n+            | FixedArraySize(_) | Sorts(_) | IntMismatch(_) | FloatMismatch(_)\n+            | VariadicMismatch(_) | TargetFeatureCast(_) => false,\n \n             Mutability\n             | TupleSize(_)\n@@ -230,7 +232,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 let n = tcx.lift(&n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                     _ if t.is_simple_ty() => format!(\"array `{}`\", self).into(),\n-                    Some(n) => format!(\"array of {} element{} \", n, pluralize!(n)).into(),\n+                    Some(n) => format!(\"array of {} element{}\", n, pluralize!(n)).into(),\n                     None => \"array\".into(),\n                 }\n             }\n@@ -473,6 +475,18 @@ impl<T> Trait<T> for X {\n                                  #traits-as-parameters\",\n                         );\n                     }\n+                    (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {\n+                        let generics = self.generics_of(body_owner_def_id);\n+                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n+                        if !sp.contains(p_span) {\n+                            db.span_label(p_span, \"this type parameter\");\n+                        }\n+                        db.help(&format!(\n+                            \"every closure has a distinct type and so could not always match the \\\n+                             caller-chosen type of parameter `{}`\",\n+                            p\n+                        ));\n+                    }\n                     (ty::Param(p), _) | (_, ty::Param(p)) => {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n@@ -546,22 +560,22 @@ impl<T> Trait<T> for X {\n     }\n \n     fn suggest_constraint(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         msg: &str,\n         body_owner_def_id: DefId,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> bool {\n         let assoc = self.associated_item(proj_ty.item_def_id);\n-        let trait_ref = proj_ty.trait_ref(*self);\n+        let trait_ref = proj_ty.trait_ref(self);\n         if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n             if let Some(hir_generics) = item.generics() {\n                 // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n                 // This will also work for `impl Trait`.\n                 let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind() {\n                     let generics = self.generics_of(body_owner_def_id);\n-                    generics.type_param(&param_ty, *self).def_id\n+                    generics.type_param(param_ty, self).def_id\n                 } else {\n                     return false;\n                 };\n@@ -629,7 +643,7 @@ impl<T> Trait<T> for X {\n     ///    and the `impl`, we provide a generic `help` to constrain the assoc type or call an assoc\n     ///    fn that returns the type.\n     fn expected_projection(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         values: &ExpectedFound<Ty<'tcx>>,\n@@ -734,7 +748,7 @@ fn foo(&self) -> Self::T { String::new() }\n     }\n \n     fn point_at_methods_that_satisfy_associated_type(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         assoc_container_id: DefId,\n         current_method_ident: Option<Symbol>,\n@@ -789,7 +803,7 @@ fn foo(&self) -> Self::T { String::new() }\n     }\n \n     fn point_at_associated_type(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         body_owner_def_id: DefId,\n         found: Ty<'tcx>,\n@@ -832,14 +846,11 @@ fn foo(&self) -> Self::T { String::new() }\n                 kind: hir::ItemKind::Impl { items, .. }, ..\n             })) => {\n                 for item in &items[..] {\n-                    match item.kind {\n-                        hir::AssocItemKind::Type => {\n-                            if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n-                                db.span_label(item.span, \"expected this associated type\");\n-                                return true;\n-                            }\n+                    if let hir::AssocItemKind::Type = item.kind {\n+                        if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n+                            db.span_label(item.span, \"expected this associated type\");\n+                            return true;\n                         }\n-                        _ => {}\n                     }\n                 }\n             }\n@@ -851,7 +862,7 @@ fn foo(&self) -> Self::T { String::new() }\n     /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n     /// requirement, provide a strucuted suggestion to constrain it to a given type `ty`.\n     fn constrain_generic_bound_associated_type_structured_suggestion(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n@@ -875,7 +886,7 @@ fn foo(&self) -> Self::T { String::new() }\n     /// Given a span corresponding to a bound, provide a structured suggestion to set an\n     /// associated type to a given type `ty`.\n     fn constrain_associated_type_structured_suggestion(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         assoc: &ty::AssocItem,"}, {"sha": "c9a4022330a7af2df9a7a9de3210ebc2d1b27697", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -249,6 +249,9 @@ impl FlagComputation {\n                 self.add_const(expected);\n                 self.add_const(found);\n             }\n+            ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n+                self.add_ty(ty);\n+            }\n         }\n     }\n "}, {"sha": "84134bedef0bc218564ac823ae45e97f5a1014ed", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -623,7 +623,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Replaces any late-bound regions bound in `value` with\n     /// free variants attached to `all_outlive_scope`.\n     pub fn liberate_late_bound_regions<T>(\n-        &self,\n+        self,\n         all_outlive_scope: DefId,\n         value: &ty::Binder<T>,\n     ) -> T\n@@ -644,7 +644,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// variables and equate `value` with something else, those\n     /// variables will also be equated.\n     pub fn collect_constrained_late_bound_regions<T>(\n-        &self,\n+        self,\n         value: &Binder<T>,\n     ) -> FxHashSet<ty::BoundRegion>\n     where\n@@ -655,7 +655,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns a set of all late-bound regions that appear in `value` anywhere.\n     pub fn collect_referenced_late_bound_regions<T>(\n-        &self,\n+        self,\n         value: &Binder<T>,\n     ) -> FxHashSet<ty::BoundRegion>\n     where\n@@ -665,7 +665,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     fn collect_late_bound_regions<T>(\n-        &self,\n+        self,\n         value: &Binder<T>,\n         just_constraint: bool,\n     ) -> FxHashSet<ty::BoundRegion>"}, {"sha": "9bb1c0ed7ded50dad2a0b41626bb30abff5c0704", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -22,7 +22,8 @@ pub struct Instance<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum InstanceDef<'tcx> {\n     /// A user-defined callable item.\n     ///\n@@ -62,10 +63,6 @@ pub enum InstanceDef<'tcx> {\n     /// `<fn() as FnTrait>::call_*` (generated `FnTrait` implementation for `fn()` pointers).\n     ///\n     /// `DefId` is `FnTrait::call_*`.\n-    ///\n-    /// NB: the (`fn` pointer) type must currently be monomorphic to avoid double substitution\n-    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n-    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     FnPtrShim(DefId, Ty<'tcx>),\n \n     /// Dynamic dispatch to `<dyn Trait as Trait>::fn`.\n@@ -87,10 +84,6 @@ pub enum InstanceDef<'tcx> {\n     /// The `DefId` is for `core::ptr::drop_in_place`.\n     /// The `Option<Ty<'tcx>>` is either `Some(T)`, or `None` for empty drop\n     /// glue.\n-    ///\n-    /// NB: the type must currently be monomorphic to avoid double substitution\n-    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n-    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n \n     /// Compiler-generated `<T as Clone>::clone` implementation.\n@@ -99,10 +92,6 @@ pub enum InstanceDef<'tcx> {\n     /// Additionally, arrays, tuples, and closures get a `Clone` shim even if they aren't `Copy`.\n     ///\n     /// The `DefId` is for `Clone::clone`, the `Ty` is the type `T` with the builtin `Clone` impl.\n-    ///\n-    /// NB: the type must currently be monomorphic to avoid double substitution\n-    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n-    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     CloneShim(DefId, Ty<'tcx>),\n }\n \n@@ -243,6 +232,27 @@ impl<'tcx> InstanceDef<'tcx> {\n             _ => false,\n         }\n     }\n+\n+    /// Returns `true` when the MIR body associated with this instance should be monomorphized\n+    /// by its users (e.g. codegen or miri) by substituting the `substs` from `Instance` (see\n+    /// `Instance::substs_for_mir_body`).\n+    ///\n+    /// Otherwise, returns `false` only for some kinds of shims where the construction of the MIR\n+    /// body should perform necessary substitutions.\n+    pub fn has_polymorphic_mir_body(&self) -> bool {\n+        match *self {\n+            InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrShim(..)\n+            | InstanceDef::DropGlue(_, Some(_)) => false,\n+            InstanceDef::ClosureOnceShim { .. }\n+            | InstanceDef::DropGlue(..)\n+            | InstanceDef::Item(_)\n+            | InstanceDef::Intrinsic(..)\n+            | InstanceDef::ReifyShim(..)\n+            | InstanceDef::Virtual(..)\n+            | InstanceDef::VtableShim(..) => true,\n+        }\n+    }\n }\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n@@ -440,30 +450,18 @@ impl<'tcx> Instance<'tcx> {\n         Instance { def, substs }\n     }\n \n-    /// FIXME(#69925) Depending on the kind of `InstanceDef`, the MIR body associated with an\n+    /// Depending on the kind of `InstanceDef`, the MIR body associated with an\n     /// instance is expressed in terms of the generic parameters of `self.def_id()`, and in other\n     /// cases the MIR body is expressed in terms of the types found in the substitution array.\n     /// In the former case, we want to substitute those generic types and replace them with the\n     /// values from the substs when monomorphizing the function body. But in the latter case, we\n     /// don't want to do that substitution, since it has already been done effectively.\n     ///\n-    /// This function returns `Some(substs)` in the former case and None otherwise -- i.e., if\n+    /// This function returns `Some(substs)` in the former case and `None` otherwise -- i.e., if\n     /// this function returns `None`, then the MIR body does not require substitution during\n-    /// monomorphization.\n+    /// codegen.\n     pub fn substs_for_mir_body(&self) -> Option<SubstsRef<'tcx>> {\n-        match self.def {\n-            InstanceDef::CloneShim(..)\n-            | InstanceDef::DropGlue(_, Some(_)) => None,\n-            InstanceDef::ClosureOnceShim { .. }\n-            | InstanceDef::DropGlue(..)\n-            // FIXME(#69925): `FnPtrShim` should be in the other branch.\n-            | InstanceDef::FnPtrShim(..)\n-            | InstanceDef::Item(_)\n-            | InstanceDef::Intrinsic(..)\n-            | InstanceDef::ReifyShim(..)\n-            | InstanceDef::Virtual(..)\n-            | InstanceDef::VtableShim(..) => Some(self.substs),\n-        }\n+        if self.def.has_polymorphic_mir_body() { Some(self.substs) } else { None }\n     }\n \n     /// Returns a new `Instance` where generic parameters in `instance.substs` are replaced by"}, {"sha": "b61fde32c9ce84e5646d9e5a8366733ab4120769", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 58, "deletions": 71, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -390,78 +390,60 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         // Unpack newtype ABIs and find scalar pairs.\n         if sized && size.bytes() > 0 {\n-            // All other fields must be ZSTs, and we need them to all start at 0.\n-            let mut zst_offsets = offsets.iter().enumerate().filter(|&(i, _)| fields[i].is_zst());\n-            if zst_offsets.all(|(_, o)| o.bytes() == 0) {\n-                let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n-\n-                match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n-                    // We have exactly one non-ZST field.\n-                    (Some((i, field)), None, None) => {\n-                        // Field fills the struct and it has a scalar or scalar pair ABI.\n-                        if offsets[i].bytes() == 0\n-                            && align.abi == field.align.abi\n-                            && size == field.size\n-                        {\n-                            match field.abi {\n-                                // For plain scalars, or vectors of them, we can't unpack\n-                                // newtypes for `#[repr(C)]`, as that affects C ABIs.\n-                                Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n-                                    abi = field.abi.clone();\n-                                }\n-                                // But scalar pairs are Rust-specific and get\n-                                // treated as aggregates by C ABIs anyway.\n-                                Abi::ScalarPair(..) => {\n-                                    abi = field.abi.clone();\n-                                }\n-                                _ => {}\n+            // All other fields must be ZSTs.\n+            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n+\n+            match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+                // We have exactly one non-ZST field.\n+                (Some((i, field)), None, None) => {\n+                    // Field fills the struct and it has a scalar or scalar pair ABI.\n+                    if offsets[i].bytes() == 0 && align.abi == field.align.abi && size == field.size\n+                    {\n+                        match field.abi {\n+                            // For plain scalars, or vectors of them, we can't unpack\n+                            // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                            Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n+                                abi = field.abi.clone();\n                             }\n+                            // But scalar pairs are Rust-specific and get\n+                            // treated as aggregates by C ABIs anyway.\n+                            Abi::ScalarPair(..) => {\n+                                abi = field.abi.clone();\n+                            }\n+                            _ => {}\n                         }\n                     }\n+                }\n \n-                    // Two non-ZST fields, and they're both scalars.\n-                    (\n-                        Some((\n-                            i,\n-                            &TyAndLayout {\n-                                layout: &Layout { abi: Abi::Scalar(ref a), .. }, ..\n-                            },\n-                        )),\n-                        Some((\n-                            j,\n-                            &TyAndLayout {\n-                                layout: &Layout { abi: Abi::Scalar(ref b), .. }, ..\n-                            },\n-                        )),\n-                        None,\n-                    ) => {\n-                        // Order by the memory placement, not source order.\n-                        let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n-                            ((i, a), (j, b))\n-                        } else {\n-                            ((j, b), (i, a))\n-                        };\n-                        let pair = self.scalar_pair(a.clone(), b.clone());\n-                        let pair_offsets = match pair.fields {\n-                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                                assert_eq!(memory_index, &[0, 1]);\n-                                offsets\n-                            }\n-                            _ => bug!(),\n-                        };\n-                        if offsets[i] == pair_offsets[0]\n-                            && offsets[j] == pair_offsets[1]\n-                            && align == pair.align\n-                            && size == pair.size\n-                        {\n-                            // We can use `ScalarPair` only when it matches our\n-                            // already computed layout (including `#[repr(C)]`).\n-                            abi = pair.abi;\n+                // Two non-ZST fields, and they're both scalars.\n+                (\n+                    Some((i, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(ref a), .. }, .. })),\n+                    Some((j, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(ref b), .. }, .. })),\n+                    None,\n+                ) => {\n+                    // Order by the memory placement, not source order.\n+                    let ((i, a), (j, b)) =\n+                        if offsets[i] < offsets[j] { ((i, a), (j, b)) } else { ((j, b), (i, a)) };\n+                    let pair = self.scalar_pair(a.clone(), b.clone());\n+                    let pair_offsets = match pair.fields {\n+                        FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                            assert_eq!(memory_index, &[0, 1]);\n+                            offsets\n                         }\n+                        _ => bug!(),\n+                    };\n+                    if offsets[i] == pair_offsets[0]\n+                        && offsets[j] == pair_offsets[1]\n+                        && align == pair.align\n+                        && size == pair.size\n+                    {\n+                        // We can use `ScalarPair` only when it matches our\n+                        // already computed layout (including `#[repr(C)]`).\n+                        abi = pair.abi;\n                     }\n-\n-                    _ => {}\n                 }\n+\n+                _ => {}\n             }\n         }\n \n@@ -1259,11 +1241,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 tcx.layout_raw(param_env.and(normalized))?\n             }\n \n-            ty::Bound(..) | ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Infer(_) => {\n+            ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Infer(_) => {\n                 bug!(\"Layout::compute: unexpected type `{}`\", ty)\n             }\n \n-            ty::Param(_) | ty::Error(_) => {\n+            ty::Bound(..) | ty::Param(_) | ty::Error(_) => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n         })\n@@ -2753,6 +2735,7 @@ where\n             can_unwind: fn_can_unwind(cx.tcx().sess.panic_strategy(), codegen_fn_attr_flags, conv),\n         };\n         fn_abi.adjust_for_abi(cx, sig.abi);\n+        debug!(\"FnAbi::new_internal = {:?}\", fn_abi);\n         fn_abi\n     }\n \n@@ -2766,7 +2749,7 @@ where\n             || abi == SpecAbi::RustIntrinsic\n             || abi == SpecAbi::PlatformIntrinsic\n         {\n-            let fixup = |arg: &mut ArgAbi<'tcx, Ty<'tcx>>| {\n+            let fixup = |arg: &mut ArgAbi<'tcx, Ty<'tcx>>, is_ret: bool| {\n                 if arg.is_ignore() {\n                     return;\n                 }\n@@ -2804,8 +2787,12 @@ where\n                     _ => return,\n                 }\n \n+                // Return structures up to 2 pointers in size by value, matching `ScalarPair`. LLVM\n+                // will usually return these in 2 registers, which is more efficient than by-ref.\n+                let max_by_val_size = if is_ret { Pointer.size(cx) * 2 } else { Pointer.size(cx) };\n                 let size = arg.layout.size;\n-                if arg.layout.is_unsized() || size > Pointer.size(cx) {\n+\n+                if arg.layout.is_unsized() || size > max_by_val_size {\n                     arg.make_indirect();\n                 } else {\n                     // We want to pass small aggregates as immediates, but using\n@@ -2814,9 +2801,9 @@ where\n                     arg.cast_to(Reg { kind: RegKind::Integer, size });\n                 }\n             };\n-            fixup(&mut self.ret);\n+            fixup(&mut self.ret, true);\n             for arg in &mut self.args {\n-                fixup(arg);\n+                fixup(arg, false);\n             }\n             if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n                 attrs.set(ArgAttribute::StructRet);"}, {"sha": "b7530c077ccd126e61690596214279a6dda4a989", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 35, "deletions": 52, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -682,25 +682,31 @@ pub enum BorrowKind {\n     /// implicit closure bindings. It is needed when the closure\n     /// is borrowing or mutating a mutable referent, e.g.:\n     ///\n-    ///    let x: &mut isize = ...;\n-    ///    let y = || *x += 5;\n+    /// ```\n+    /// let x: &mut isize = ...;\n+    /// let y = || *x += 5;\n+    /// ```\n     ///\n     /// If we were to try to translate this closure into a more explicit\n     /// form, we'd encounter an error with the code as written:\n     ///\n-    ///    struct Env { x: & &mut isize }\n-    ///    let x: &mut isize = ...;\n-    ///    let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n-    ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    /// struct Env { x: & &mut isize }\n+    /// let x: &mut isize = ...;\n+    /// let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n     ///\n     /// This is then illegal because you cannot mutate a `&mut` found\n     /// in an aliasable location. To solve, you'd have to translate with\n     /// an `&mut` borrow:\n     ///\n-    ///    struct Env { x: & &mut isize }\n-    ///    let x: &mut isize = ...;\n-    ///    let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n-    ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    /// struct Env { x: & &mut isize }\n+    /// let x: &mut isize = ...;\n+    /// let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n     ///\n     /// Now the assignment to `**env.x` is legal, but creating a\n     /// mutable pointer to `x` is not because `x` is not mutable. We\n@@ -1155,6 +1161,11 @@ pub enum PredicateAtom<'tcx> {\n \n     /// Constants must be equal. The first component is the const that is expected.\n     ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n+\n+    /// Represents a type found in the environment that we can use for implied bounds.\n+    ///\n+    /// Only used for Chalk.\n+    TypeWellFormedFromEnv(Ty<'tcx>),\n }\n \n impl<'tcx> PredicateAtom<'tcx> {\n@@ -1450,7 +1461,8 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateAtom::ClosureKind(..)\n             | PredicateAtom::TypeOutlives(..)\n             | PredicateAtom::ConstEvaluatable(..)\n-            | PredicateAtom::ConstEquate(..) => None,\n+            | PredicateAtom::ConstEquate(..)\n+            | PredicateAtom::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n \n@@ -1465,7 +1477,8 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateAtom::ObjectSafe(..)\n             | PredicateAtom::ClosureKind(..)\n             | PredicateAtom::ConstEvaluatable(..)\n-            | PredicateAtom::ConstEquate(..) => None,\n+            | PredicateAtom::ConstEquate(..)\n+            | PredicateAtom::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n }\n@@ -1738,11 +1751,6 @@ pub struct ParamEnv<'tcx> {\n     ///\n     /// Note: This is packed, use the reveal() method to access it.\n     packed: CopyTaggedPtr<&'tcx List<Predicate<'tcx>>, traits::Reveal, true>,\n-\n-    /// If this `ParamEnv` comes from a call to `tcx.param_env(def_id)`,\n-    /// register that `def_id` (useful for transitioning to the chalk trait\n-    /// solver).\n-    pub def_id: Option<DefId>,\n }\n \n unsafe impl rustc_data_structures::tagged_ptr::Tag for traits::Reveal {\n@@ -1767,7 +1775,6 @@ impl<'tcx> fmt::Debug for ParamEnv<'tcx> {\n         f.debug_struct(\"ParamEnv\")\n             .field(\"caller_bounds\", &self.caller_bounds())\n             .field(\"reveal\", &self.reveal())\n-            .field(\"def_id\", &self.def_id)\n             .finish()\n     }\n }\n@@ -1776,23 +1783,16 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ParamEnv<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.caller_bounds().hash_stable(hcx, hasher);\n         self.reveal().hash_stable(hcx, hasher);\n-        self.def_id.hash_stable(hcx, hasher);\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ParamEnv<'tcx> {\n     fn super_fold_with<F: ty::fold::TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        ParamEnv::new(\n-            self.caller_bounds().fold_with(folder),\n-            self.reveal().fold_with(folder),\n-            self.def_id.fold_with(folder),\n-        )\n+        ParamEnv::new(self.caller_bounds().fold_with(folder), self.reveal().fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.caller_bounds().visit_with(visitor)\n-            || self.reveal().visit_with(visitor)\n-            || self.def_id.visit_with(visitor)\n+        self.caller_bounds().visit_with(visitor) || self.reveal().visit_with(visitor)\n     }\n }\n \n@@ -1803,7 +1803,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// type-checking.\n     #[inline]\n     pub fn empty() -> Self {\n-        Self::new(List::empty(), Reveal::UserFacing, None)\n+        Self::new(List::empty(), Reveal::UserFacing)\n     }\n \n     #[inline]\n@@ -1825,17 +1825,13 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// or invoke `param_env.with_reveal_all()`.\n     #[inline]\n     pub fn reveal_all() -> Self {\n-        Self::new(List::empty(), Reveal::All, None)\n+        Self::new(List::empty(), Reveal::All)\n     }\n \n     /// Construct a trait environment with the given set of predicates.\n     #[inline]\n-    pub fn new(\n-        caller_bounds: &'tcx List<Predicate<'tcx>>,\n-        reveal: Reveal,\n-        def_id: Option<DefId>,\n-    ) -> Self {\n-        ty::ParamEnv { packed: CopyTaggedPtr::new(caller_bounds, reveal), def_id }\n+    pub fn new(caller_bounds: &'tcx List<Predicate<'tcx>>, reveal: Reveal) -> Self {\n+        ty::ParamEnv { packed: CopyTaggedPtr::new(caller_bounds, reveal) }\n     }\n \n     pub fn with_user_facing(mut self) -> Self {\n@@ -1857,12 +1853,12 @@ impl<'tcx> ParamEnv<'tcx> {\n             return self;\n         }\n \n-        ParamEnv::new(tcx.normalize_opaque_types(self.caller_bounds()), Reveal::All, self.def_id)\n+        ParamEnv::new(tcx.normalize_opaque_types(self.caller_bounds()), Reveal::All)\n     }\n \n     /// Returns this same environment but with no caller bounds.\n     pub fn without_caller_bounds(self) -> Self {\n-        Self::new(List::empty(), self.reveal(), self.def_id)\n+        Self::new(List::empty(), self.reveal())\n     }\n \n     /// Creates a suitable environment in which to perform trait\n@@ -2009,7 +2005,7 @@ pub struct VariantDef {\n     flags: VariantFlags,\n }\n \n-impl<'tcx> VariantDef {\n+impl VariantDef {\n     /// Creates a new `VariantDef`.\n     ///\n     /// `variant_did` is the `DefId` that identifies the enum variant (if this `VariantDef`\n@@ -2075,19 +2071,6 @@ impl<'tcx> VariantDef {\n     pub fn is_recovered(&self) -> bool {\n         self.flags.intersects(VariantFlags::IS_RECOVERED)\n     }\n-\n-    /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n-    /// field.\n-    pub fn transparent_newtype_field(&self, tcx: TyCtxt<'tcx>) -> Option<&FieldDef> {\n-        for field in &self.fields {\n-            let field_ty = field.ty(tcx, InternalSubsts::identity_for_item(tcx, self.def_id));\n-            if !field_ty.is_zst(tcx, self.def_id) {\n-                return Some(field);\n-            }\n-        }\n-\n-        None\n-    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n@@ -2695,7 +2678,7 @@ impl<'tcx> ClosureKind {\n         }\n     }\n \n-    /// Returns `true` if this a type that impls this closure kind\n+    /// Returns `true` if a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n         match (self, other) {"}, {"sha": "4c20141bbe691f4a4267516e6e69fa0bf853bc09", "filename": "compiler/rustc_middle/src/ty/outlives.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,6 +4,7 @@\n \n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_data_structures::sso::SsoHashSet;\n use smallvec::SmallVec;\n \n #[derive(Debug)]\n@@ -50,12 +51,18 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n     pub fn push_outlives_components(self, ty0: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n-        compute_components(self, ty0, out);\n+        let mut visited = SsoHashSet::new();\n+        compute_components(self, ty0, out, &mut visited);\n         debug!(\"components({:?}) = {:?}\", ty0, out);\n     }\n }\n \n-fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n+fn compute_components(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    out: &mut SmallVec<[Component<'tcx>; 4]>,\n+    visited: &mut SsoHashSet<GenericArg<'tcx>>,\n+) {\n     // Descend through the types, looking for the various \"base\"\n     // components and collecting them into `out`. This is not written\n     // with `collect()` because of the need to sometimes skip subtrees\n@@ -73,31 +80,31 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 for child in substs {\n                     match child.unpack() {\n                         GenericArgKind::Type(ty) => {\n-                            compute_components(tcx, ty, out);\n+                            compute_components(tcx, ty, out, visited);\n                         }\n                         GenericArgKind::Lifetime(_) => {}\n                         GenericArgKind::Const(_) => {\n-                            compute_components_recursive(tcx, child, out);\n+                            compute_components_recursive(tcx, child, out, visited);\n                         }\n                     }\n                 }\n             }\n \n             ty::Array(element, _) => {\n                 // Don't look into the len const as it doesn't affect regions\n-                compute_components(tcx, element, out);\n+                compute_components(tcx, element, out, visited);\n             }\n \n             ty::Closure(_, ref substs) => {\n                 for upvar_ty in substs.as_closure().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out);\n+                    compute_components(tcx, upvar_ty, out, visited);\n                 }\n             }\n \n             ty::Generator(_, ref substs, _) => {\n                 // Same as the closure case\n                 for upvar_ty in substs.as_generator().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out);\n+                    compute_components(tcx, upvar_ty, out, visited);\n                 }\n \n                 // We ignore regions in the generator interior as we don't\n@@ -135,7 +142,8 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                     // OutlivesProjectionComponents.  Continue walking\n                     // through and constrain Pi.\n                     let mut subcomponents = smallvec![];\n-                    compute_components_recursive(tcx, ty.into(), &mut subcomponents);\n+                    let mut subvisited = SsoHashSet::new();\n+                    compute_components_recursive(tcx, ty.into(), &mut subcomponents, &mut subvisited);\n                     out.push(Component::EscapingProjection(subcomponents.into_iter().collect()));\n                 }\n             }\n@@ -177,7 +185,7 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 // the \"bound regions list\".  In our representation, no such\n                 // list is maintained explicitly, because bound regions\n                 // themselves can be readily identified.\n-                compute_components_recursive(tcx, ty.into(), out);\n+                compute_components_recursive(tcx, ty.into(), out, visited);\n             }\n         }\n }\n@@ -186,11 +194,12 @@ fn compute_components_recursive(\n     tcx: TyCtxt<'tcx>,\n     parent: GenericArg<'tcx>,\n     out: &mut SmallVec<[Component<'tcx>; 4]>,\n+    visited: &mut SsoHashSet<GenericArg<'tcx>>,\n ) {\n-    for child in parent.walk_shallow() {\n+    for child in parent.walk_shallow(visited) {\n         match child.unpack() {\n             GenericArgKind::Type(ty) => {\n-                compute_components(tcx, ty, out);\n+                compute_components(tcx, ty, out, visited);\n             }\n             GenericArgKind::Lifetime(lt) => {\n                 // Ignore late-bound regions.\n@@ -199,7 +208,7 @@ fn compute_components_recursive(\n                 }\n             }\n             GenericArgKind::Const(_) => {\n-                compute_components_recursive(tcx, child, out);\n+                compute_components_recursive(tcx, child, out, visited);\n             }\n         }\n     }"}, {"sha": "2e00be2395b8caea43f507b10f11a89dd04163e6", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -2,6 +2,7 @@ use crate::ty::subst::{GenericArg, Subst};\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n \n@@ -263,21 +264,33 @@ pub trait Printer<'tcx>: Sized {\n /// function tries to find a \"characteristic `DefId`\" for a\n /// type. It's just a heuristic so it makes some questionable\n /// decisions and we may want to adjust it later.\n-pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n+///\n+/// Visited set is needed to avoid full iteration over\n+/// deeply nested tuples that have no DefId.\n+fn characteristic_def_id_of_type_cached<'a>(\n+    ty: Ty<'a>,\n+    visited: &mut SsoHashSet<Ty<'a>>,\n+) -> Option<DefId> {\n     match *ty.kind() {\n         ty::Adt(adt_def, _) => Some(adt_def.did),\n \n         ty::Dynamic(data, ..) => data.principal_def_id(),\n \n-        ty::Array(subty, _) | ty::Slice(subty) => characteristic_def_id_of_type(subty),\n+        ty::Array(subty, _) | ty::Slice(subty) => {\n+            characteristic_def_id_of_type_cached(subty, visited)\n+        }\n \n-        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n+        ty::RawPtr(mt) => characteristic_def_id_of_type_cached(mt.ty, visited),\n \n-        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n+        ty::Ref(_, ty, _) => characteristic_def_id_of_type_cached(ty, visited),\n \n-        ty::Tuple(ref tys) => {\n-            tys.iter().find_map(|ty| characteristic_def_id_of_type(ty.expect_ty()))\n-        }\n+        ty::Tuple(ref tys) => tys.iter().find_map(|ty| {\n+            let ty = ty.expect_ty();\n+            if visited.insert(ty) {\n+                return characteristic_def_id_of_type_cached(ty, visited);\n+            }\n+            return None;\n+        }),\n \n         ty::FnDef(def_id, _)\n         | ty::Closure(def_id, _)\n@@ -302,6 +315,9 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n         | ty::Float(_) => None,\n     }\n }\n+pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n+    characteristic_def_id_of_type_cached(ty, &mut SsoHashSet::new())\n+}\n \n impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::RegionKind {\n     type Output = P::Region;"}, {"sha": "238bce94cf50529bdd5ae2f38a144d6749c2bfbc", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 156, "deletions": 179, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdSet, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathData};\n use rustc_hir::ItemKind;\n use rustc_session::config::TrimmedDefPaths;\n use rustc_span::symbol::{kw, Ident, Symbol};\n@@ -28,6 +28,9 @@ use std::ops::{Deref, DerefMut};\n use super::*;\n \n macro_rules! p {\n+    (@$lit:literal) => {\n+        write!(scoped_cx!(), $lit)?\n+    };\n     (@write($($data:expr),+)) => {\n         write!(scoped_cx!(), $($data),+)?\n     };\n@@ -37,8 +40,8 @@ macro_rules! p {\n     (@$method:ident($($arg:expr),*)) => {\n         scoped_cx!() = scoped_cx!().$method($($arg),*)?\n     };\n-    ($($kind:ident $data:tt),+) => {{\n-        $(p!(@$kind $data);)+\n+    ($($elem:tt $(($($args:tt)*))?),+) => {{\n+        $(p!(@ $elem $(($($args)*))?);)+\n     }};\n }\n macro_rules! define_scoped_cx {\n@@ -273,10 +276,10 @@ pub trait PrettyPrinter<'tcx>:\n         }\n \n         match self.tcx().trimmed_def_paths(LOCAL_CRATE).get(&def_id) {\n-            None => return Ok((self, false)),\n+            None => Ok((self, false)),\n             Some(symbol) => {\n                 self.write_str(&symbol.as_str())?;\n-                return Ok((self, true));\n+                Ok((self, true))\n             }\n         }\n     }\n@@ -478,7 +481,7 @@ pub trait PrettyPrinter<'tcx>:\n \n             p!(print(self_ty));\n             if let Some(trait_ref) = trait_ref {\n-                p!(write(\" as \"), print(trait_ref.print_only_trait_path()));\n+                p!(\" as \", print(trait_ref.print_only_trait_path()));\n             }\n             Ok(cx)\n         })\n@@ -495,9 +498,9 @@ pub trait PrettyPrinter<'tcx>:\n         self.generic_delimiters(|mut cx| {\n             define_scoped_cx!(cx);\n \n-            p!(write(\"impl \"));\n+            p!(\"impl \");\n             if let Some(trait_ref) = trait_ref {\n-                p!(print(trait_ref.print_only_trait_path()), write(\" for \"));\n+                p!(print(trait_ref.print_only_trait_path()), \" for \");\n             }\n             p!(print(self_ty));\n \n@@ -509,8 +512,8 @@ pub trait PrettyPrinter<'tcx>:\n         define_scoped_cx!(self);\n \n         match *ty.kind() {\n-            ty::Bool => p!(write(\"bool\")),\n-            ty::Char => p!(write(\"char\")),\n+            ty::Bool => p!(\"bool\"),\n+            ty::Char => p!(\"char\"),\n             ty::Int(t) => p!(write(\"{}\", t.name_str())),\n             ty::Uint(t) => p!(write(\"{}\", t.name_str())),\n             ty::Float(t) => p!(write(\"{}\", t.name_str())),\n@@ -525,23 +528,23 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(print(tm.ty))\n             }\n             ty::Ref(r, ty, mutbl) => {\n-                p!(write(\"&\"));\n+                p!(\"&\");\n                 if self.region_should_not_be_omitted(r) {\n-                    p!(print(r), write(\" \"));\n+                    p!(print(r), \" \");\n                 }\n                 p!(print(ty::TypeAndMut { ty, mutbl }))\n             }\n-            ty::Never => p!(write(\"!\")),\n+            ty::Never => p!(\"!\"),\n             ty::Tuple(ref tys) => {\n-                p!(write(\"(\"), comma_sep(tys.iter()));\n+                p!(\"(\", comma_sep(tys.iter()));\n                 if tys.len() == 1 {\n-                    p!(write(\",\"));\n+                    p!(\",\");\n                 }\n-                p!(write(\")\"))\n+                p!(\")\")\n             }\n             ty::FnDef(def_id, substs) => {\n                 let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n-                p!(print(sig), write(\" {{\"), print_value_path(def_id, substs), write(\"}}\"));\n+                p!(print(sig), \" {{\", print_value_path(def_id, substs), \"}}\");\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n             ty::Infer(infer_ty) => {\n@@ -555,7 +558,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"{}\", infer_ty))\n                 }\n             }\n-            ty::Error(_) => p!(write(\"[type error]\")),\n+            ty::Error(_) => p!(\"[type error]\"),\n             ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n                 ty::BoundTyKind::Anon => self.pretty_print_bound_var(debruijn, bound_ty.var)?,\n@@ -567,11 +570,11 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Dynamic(data, r) => {\n                 let print_r = self.region_should_not_be_omitted(r);\n                 if print_r {\n-                    p!(write(\"(\"));\n+                    p!(\"(\");\n                 }\n-                p!(write(\"dyn \"), print(data));\n+                p!(\"dyn \", print(data));\n                 if print_r {\n-                    p!(write(\" + \"), print(r), write(\")\"));\n+                    p!(\" + \", print(r), \")\");\n                 }\n             }\n             ty::Foreign(def_id) => {\n@@ -597,7 +600,7 @@ pub trait PrettyPrinter<'tcx>:\n                         p!(write(\"{}\", name));\n                         // FIXME(eddyb) print this with `print_def_path`.\n                         if !substs.is_empty() {\n-                            p!(write(\"::\"));\n+                            p!(\"::\");\n                             p!(generic_delimiters(|cx| cx.comma_sep(substs.iter())));\n                         }\n                         return Ok(self);\n@@ -608,7 +611,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                     let mut first = true;\n                     let mut is_sized = false;\n-                    p!(write(\"impl\"));\n+                    p!(\"impl\");\n                     for predicate in bounds.predicates {\n                         // Note: We can't use `to_opt_poly_trait_ref` here as `predicate`\n                         // may contain unbound variables. We therefore do this manually.\n@@ -634,131 +637,113 @@ pub trait PrettyPrinter<'tcx>:\n                     if !is_sized {\n                         p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n                     } else if first {\n-                        p!(write(\" Sized\"));\n+                        p!(\" Sized\");\n                     }\n                     Ok(self)\n                 })?);\n             }\n-            ty::Str => p!(write(\"str\")),\n+            ty::Str => p!(\"str\"),\n             ty::Generator(did, substs, movability) => {\n+                p!(write(\"[\"));\n                 match movability {\n-                    hir::Movability::Movable => p!(write(\"[generator\")),\n-                    hir::Movability::Static => p!(write(\"[static generator\")),\n+                    hir::Movability::Movable => {}\n+                    hir::Movability::Static => p!(\"static \"),\n                 }\n \n-                // FIXME(eddyb) should use `def_span`.\n-                if let Some(did) = did.as_local() {\n-                    let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n-                    let span = self.tcx().hir().span(hir_id);\n-                    p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n-\n-                    if substs.as_generator().is_valid() {\n-                        let upvar_tys = substs.as_generator().upvar_tys();\n-                        let mut sep = \" \";\n-                        for (&var_id, upvar_ty) in self\n-                            .tcx()\n-                            .upvars_mentioned(did)\n-                            .as_ref()\n-                            .iter()\n-                            .flat_map(|v| v.keys())\n-                            .zip(upvar_tys)\n-                        {\n-                            p!(write(\"{}{}:\", sep, self.tcx().hir().name(var_id)), print(upvar_ty));\n-                            sep = \", \";\n-                        }\n+                if !self.tcx().sess.verbose() {\n+                    p!(\"generator\");\n+                    // FIXME(eddyb) should use `def_span`.\n+                    if let Some(did) = did.as_local() {\n+                        let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n+                        let span = self.tcx().hir().span(hir_id);\n+                        p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n+                    } else {\n+                        p!(write(\"@{}\", self.tcx().def_path_str(did)));\n                     }\n                 } else {\n-                    p!(write(\"@{}\", self.tcx().def_path_str(did)));\n-\n+                    p!(print_def_path(did, substs));\n                     if substs.as_generator().is_valid() {\n-                        let upvar_tys = substs.as_generator().upvar_tys();\n-                        let mut sep = \" \";\n-                        for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            p!(write(\"{}{}:\", sep, index), print(upvar_ty));\n-                            sep = \", \";\n+                        // Search for the first inference variable\n+                        p!(\" upvar_tys=(\");\n+                        let mut uninferred_ty =\n+                            substs.as_generator().upvar_tys().filter(|ty| ty.is_ty_infer());\n+                        if uninferred_ty.next().is_some() {\n+                            p!(write(\"unavailable\"));\n+                        } else {\n+                            self = self.comma_sep(substs.as_generator().upvar_tys())?;\n                         }\n+                        p!(\")\");\n                     }\n                 }\n \n                 if substs.as_generator().is_valid() {\n-                    p!(write(\" \"), print(substs.as_generator().witness()));\n+                    p!(\" \", print(substs.as_generator().witness()));\n                 }\n \n-                p!(write(\"]\"))\n+                p!(\"]\")\n             }\n             ty::GeneratorWitness(types) => {\n                 p!(in_binder(&types));\n             }\n             ty::Closure(did, substs) => {\n-                p!(write(\"[closure\"));\n-\n-                // FIXME(eddyb) should use `def_span`.\n-                if let Some(did) = did.as_local() {\n-                    let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n-                    if self.tcx().sess.opts.debugging_opts.span_free_formats {\n-                        p!(write(\"@\"), print_def_path(did.to_def_id(), substs));\n-                    } else {\n-                        let span = self.tcx().hir().span(hir_id);\n-                        p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n-                    }\n-\n-                    if substs.as_closure().is_valid() {\n-                        let upvar_tys = substs.as_closure().upvar_tys();\n-                        let mut sep = \" \";\n-                        for (&var_id, upvar_ty) in self\n-                            .tcx()\n-                            .upvars_mentioned(did)\n-                            .as_ref()\n-                            .iter()\n-                            .flat_map(|v| v.keys())\n-                            .zip(upvar_tys)\n-                        {\n-                            p!(write(\"{}{}:\", sep, self.tcx().hir().name(var_id)), print(upvar_ty));\n-                            sep = \", \";\n+                p!(write(\"[\"));\n+                if !self.tcx().sess.verbose() {\n+                    p!(write(\"closure\"));\n+                    // FIXME(eddyb) should use `def_span`.\n+                    if let Some(did) = did.as_local() {\n+                        let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n+                        if self.tcx().sess.opts.debugging_opts.span_free_formats {\n+                            p!(\"@\", print_def_path(did.to_def_id(), substs));\n+                        } else {\n+                            let span = self.tcx().hir().span(hir_id);\n+                            p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n                         }\n+                    } else {\n+                        p!(write(\"@{}\", self.tcx().def_path_str(did)));\n                     }\n                 } else {\n-                    p!(write(\"@{}\", self.tcx().def_path_str(did)));\n-\n+                    p!(print_def_path(did, substs));\n                     if substs.as_closure().is_valid() {\n-                        let upvar_tys = substs.as_closure().upvar_tys();\n-                        let mut sep = \" \";\n-                        for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            p!(write(\"{}{}:\", sep, index), print(upvar_ty));\n-                            sep = \", \";\n+                        // Search for the first inference variable\n+                        let mut uninferred_ty =\n+                            substs.as_closure().upvar_tys().filter(|ty| ty.is_ty_infer());\n+                        if uninferred_ty.next().is_some() {\n+                            // If the upvar substs contain an inference variable we haven't\n+                            // finished capture analysis.\n+                            p!(\" closure_substs=(unavailable)\");\n+                        } else {\n+                            p!(\" closure_kind_ty=\", print(substs.as_closure().kind_ty()));\n+                            p!(\n+                                \" closure_sig_as_fn_ptr_ty=\",\n+                                print(substs.as_closure().sig_as_fn_ptr_ty())\n+                            );\n+                            p!(\" upvar_tys=(\");\n+                            self = self.comma_sep(substs.as_closure().upvar_tys())?;\n+                            p!(\")\");\n                         }\n                     }\n                 }\n-\n-                if self.tcx().sess.verbose() && substs.as_closure().is_valid() {\n-                    p!(write(\" closure_kind_ty=\"), print(substs.as_closure().kind_ty()));\n-                    p!(\n-                        write(\" closure_sig_as_fn_ptr_ty=\"),\n-                        print(substs.as_closure().sig_as_fn_ptr_ty())\n-                    );\n-                }\n-\n-                p!(write(\"]\"))\n+                p!(\"]\");\n             }\n             ty::Array(ty, sz) => {\n-                p!(write(\"[\"), print(ty), write(\"; \"));\n+                p!(\"[\", print(ty), \"; \");\n                 if self.tcx().sess.verbose() {\n                     p!(write(\"{:?}\", sz));\n                 } else if let ty::ConstKind::Unevaluated(..) = sz.val {\n                     // Do not try to evaluate unevaluated constants. If we are const evaluating an\n                     // array length anon const, rustc will (with debug assertions) print the\n                     // constant's path. Which will end up here again.\n-                    p!(write(\"_\"));\n+                    p!(\"_\");\n                 } else if let Some(n) = sz.val.try_to_bits(self.tcx().data_layout.pointer_size) {\n                     p!(write(\"{}\", n));\n                 } else if let ty::ConstKind::Param(param) = sz.val {\n                     p!(write(\"{}\", param));\n                 } else {\n-                    p!(write(\"_\"));\n+                    p!(\"_\");\n                 }\n-                p!(write(\"]\"))\n+                p!(\"]\")\n             }\n-            ty::Slice(ty) => p!(write(\"[\"), print(ty), write(\"]\")),\n+            ty::Slice(ty) => p!(\"[\", print(ty), \"]\"),\n         }\n \n         Ok(self)\n@@ -865,7 +850,7 @@ pub trait PrettyPrinter<'tcx>:\n \n         for (_, def_id) in auto_traits {\n             if !first {\n-                p!(write(\" + \"));\n+                p!(\" + \");\n             }\n             first = false;\n \n@@ -883,16 +868,16 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self, Self::Error> {\n         define_scoped_cx!(self);\n \n-        p!(write(\"(\"), comma_sep(inputs.iter().copied()));\n+        p!(\"(\", comma_sep(inputs.iter().copied()));\n         if c_variadic {\n             if !inputs.is_empty() {\n-                p!(write(\", \"));\n+                p!(\", \");\n             }\n-            p!(write(\"...\"));\n+            p!(\"...\");\n         }\n-        p!(write(\")\"));\n+        p!(\")\");\n         if !output.is_unit() {\n-            p!(write(\" -> \"), print(output));\n+            p!(\" -> \", print(output));\n         }\n \n         Ok(self)\n@@ -963,7 +948,7 @@ pub trait PrettyPrinter<'tcx>:\n                 self.pretty_print_bound_var(debruijn, bound_var)?\n             }\n             ty::ConstKind::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n-            ty::ConstKind::Error(_) => p!(write(\"[const error]\")),\n+            ty::ConstKind::Error(_) => p!(\"[const error]\"),\n         };\n         Ok(self)\n     }\n@@ -1005,17 +990,17 @@ pub trait PrettyPrinter<'tcx>:\n                     {\n                         p!(pretty_print_byte_str(byte_str))\n                     } else {\n-                        p!(write(\"<too short allocation>\"))\n+                        p!(\"<too short allocation>\")\n                     }\n                 }\n                 // FIXME: for statics and functions, we could in principle print more detail.\n                 Some(GlobalAlloc::Static(def_id)) => p!(write(\"<static({:?})>\", def_id)),\n-                Some(GlobalAlloc::Function(_)) => p!(write(\"<function>\")),\n-                None => p!(write(\"<dangling pointer>\")),\n+                Some(GlobalAlloc::Function(_)) => p!(\"<function>\"),\n+                None => p!(\"<dangling pointer>\"),\n             },\n             // Bool\n-            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(write(\"false\")),\n-            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(write(\"true\")),\n+            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(\"false\"),\n+            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(\"true\"),\n             // Float\n             (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F32)) => {\n                 p!(write(\"{}f32\", Single::from_bits(data)))\n@@ -1111,13 +1096,13 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn pretty_print_byte_str(mut self, byte_str: &'tcx [u8]) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n-        p!(write(\"b\\\"\"));\n+        p!(\"b\\\"\");\n         for &c in byte_str {\n             for e in std::ascii::escape_default(c) {\n                 self.write_char(e as char)?;\n             }\n         }\n-        p!(write(\"\\\"\"));\n+        p!(\"\\\"\");\n         Ok(self)\n     }\n \n@@ -1130,7 +1115,7 @@ pub trait PrettyPrinter<'tcx>:\n         define_scoped_cx!(self);\n \n         if self.tcx().sess.verbose() {\n-            p!(write(\"ConstValue({:?}: \", ct), print(ty), write(\")\"));\n+            p!(write(\"ConstValue({:?}: \", ct), print(ty), \")\");\n             return Ok(self);\n         }\n \n@@ -1167,7 +1152,7 @@ pub trait PrettyPrinter<'tcx>:\n                 let ptr = Pointer::new(AllocId(0), offset);\n \n                 let byte_str = alloc.get_bytes(&self.tcx(), ptr, n).unwrap();\n-                p!(write(\"*\"));\n+                p!(\"*\");\n                 p!(pretty_print_byte_str(byte_str));\n                 Ok(self)\n             }\n@@ -1191,14 +1176,14 @@ pub trait PrettyPrinter<'tcx>:\n \n                 match *ty.kind() {\n                     ty::Array(..) => {\n-                        p!(write(\"[\"), comma_sep(fields), write(\"]\"));\n+                        p!(\"[\", comma_sep(fields), \"]\");\n                     }\n                     ty::Tuple(..) => {\n-                        p!(write(\"(\"), comma_sep(fields));\n+                        p!(\"(\", comma_sep(fields));\n                         if contents.fields.len() == 1 {\n-                            p!(write(\",\"));\n+                            p!(\",\");\n                         }\n-                        p!(write(\")\"));\n+                        p!(\")\");\n                     }\n                     ty::Adt(def, substs) if def.variants.is_empty() => {\n                         p!(print_value_path(def.did, substs));\n@@ -1212,19 +1197,19 @@ pub trait PrettyPrinter<'tcx>:\n                         match variant_def.ctor_kind {\n                             CtorKind::Const => {}\n                             CtorKind::Fn => {\n-                                p!(write(\"(\"), comma_sep(fields), write(\")\"));\n+                                p!(\"(\", comma_sep(fields), \")\");\n                             }\n                             CtorKind::Fictive => {\n-                                p!(write(\" {{ \"));\n+                                p!(\" {{ \");\n                                 let mut first = true;\n                                 for (field_def, field) in variant_def.fields.iter().zip(fields) {\n                                     if !first {\n-                                        p!(write(\", \"));\n+                                        p!(\", \");\n                                     }\n                                     p!(write(\"{}: \", field_def.ident), print(field));\n                                     first = false;\n                                 }\n-                                p!(write(\" }}\"));\n+                                p!(\" }}\");\n                             }\n                         }\n                     }\n@@ -1242,7 +1227,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // fallback\n                 p!(write(\"{:?}\", ct));\n                 if print_ty {\n-                    p!(write(\": \"), print(ty));\n+                    p!(\": \", print(ty));\n                 }\n                 Ok(self)\n             }\n@@ -1264,6 +1249,7 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n     used_region_names: FxHashSet<Symbol>,\n     region_index: usize,\n     binder_depth: usize,\n+    printed_type_count: usize,\n \n     pub region_highlight_mode: RegionHighlightMode,\n \n@@ -1294,6 +1280,7 @@ impl<F> FmtPrinter<'a, 'tcx, F> {\n             used_region_names: Default::default(),\n             region_index: 0,\n             binder_depth: 0,\n+            printed_type_count: 0,\n             region_highlight_mode: RegionHighlightMode::default(),\n             name_resolver: None,\n         }))\n@@ -1411,8 +1398,14 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         self.pretty_print_region(region)\n     }\n \n-    fn print_type(self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n-        self.pretty_print_type(ty)\n+    fn print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n+        if self.tcx.sess.type_length_limit().value_within_limit(self.printed_type_count) {\n+            self.printed_type_count += 1;\n+            self.pretty_print_type(ty)\n+        } else {\n+            write!(self, \"...\")?;\n+            Ok(self)\n+        }\n     }\n \n     fn print_dyn_existential(\n@@ -1490,25 +1483,21 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         // FIXME(eddyb) `name` should never be empty, but it\n         // currently is for `extern { ... }` \"foreign modules\".\n-        let name = disambiguated_data.data.as_symbol();\n-        if name != kw::Invalid {\n+        let name = disambiguated_data.data.name();\n+        if name != DefPathDataName::Named(kw::Invalid) {\n             if !self.empty_path {\n                 write!(self, \"::\")?;\n             }\n-            if Ident::with_dummy_span(name).is_raw_guess() {\n-                write!(self, \"r#\")?;\n-            }\n-            write!(self, \"{}\", name)?;\n \n-            // FIXME(eddyb) this will print e.g. `{{closure}}#3`, but it\n-            // might be nicer to use something else, e.g. `{closure#3}`.\n-            let dis = disambiguated_data.disambiguator;\n-            let print_dis = disambiguated_data.data.get_opt_name().is_none()\n-                || dis != 0 && self.tcx.sess.verbose();\n-            if print_dis {\n-                write!(self, \"#{}\", dis)?;\n+            if let DefPathDataName::Named(name) = name {\n+                if Ident::with_dummy_span(name).is_raw_guess() {\n+                    write!(self, \"r#\")?;\n+                }\n             }\n \n+            let verbose = self.tcx.sess.verbose();\n+            disambiguated_data.fmt_maybe_verbose(&mut self, verbose)?;\n+\n             self.empty_path = false;\n         }\n \n@@ -1651,7 +1640,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n             if this.print_alloc_ids {\n                 p!(write(\"{:?}\", p));\n             } else {\n-                p!(write(\"&_\"));\n+                p!(\"&_\");\n             }\n             Ok(this)\n         };\n@@ -1717,11 +1706,11 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n             ty::ReVar(_) => {}\n             ty::ReErased => {}\n             ty::ReStatic => {\n-                p!(write(\"'static\"));\n+                p!(\"'static\");\n                 return Ok(self);\n             }\n             ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n-                p!(write(\"'<empty>\"));\n+                p!(\"'<empty>\");\n                 return Ok(self);\n             }\n             ty::ReEmpty(ui) => {\n@@ -1730,7 +1719,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n             }\n         }\n \n-        p!(write(\"'_\"));\n+        p!(\"'_\");\n \n         Ok(self)\n     }\n@@ -1861,7 +1850,7 @@ where\n     type Error = P::Error;\n     fn print(&self, mut cx: P) -> Result<Self::Output, Self::Error> {\n         define_scoped_cx!(cx);\n-        p!(print(self.0), write(\": \"), print(self.1));\n+        p!(print(self.0), \": \", print(self.1));\n         Ok(cx)\n     }\n }\n@@ -1959,7 +1948,7 @@ define_print_and_forward_display! {\n     (self, cx):\n \n     &'tcx ty::List<Ty<'tcx>> {\n-        p!(write(\"{{\"), comma_sep(self.iter()), write(\"}}\"))\n+        p!(\"{{\", comma_sep(self.iter()), \"}}\")\n     }\n \n     ty::TypeAndMut<'tcx> {\n@@ -1995,7 +1984,7 @@ define_print_and_forward_display! {\n             p!(write(\"extern {} \", self.abi));\n         }\n \n-        p!(write(\"fn\"), pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n+        p!(\"fn\", pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n     }\n \n     ty::InferTy {\n@@ -2004,7 +1993,7 @@ define_print_and_forward_display! {\n             return Ok(cx);\n         }\n         match *self {\n-            ty::TyVar(_) => p!(write(\"_\")),\n+            ty::TyVar(_) => p!(\"_\"),\n             ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n             ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n             ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n@@ -2030,16 +2019,16 @@ define_print_and_forward_display! {\n     }\n \n     ty::SubtypePredicate<'tcx> {\n-        p!(print(self.a), write(\" <: \"), print(self.b))\n+        p!(print(self.a), \" <: \", print(self.b))\n     }\n \n     ty::TraitPredicate<'tcx> {\n-        p!(print(self.trait_ref.self_ty()), write(\": \"),\n+        p!(print(self.trait_ref.self_ty()), \": \",\n            print(self.trait_ref.print_only_trait_path()))\n     }\n \n     ty::ProjectionPredicate<'tcx> {\n-        p!(print(self.projection_ty), write(\" == \"), print(self.ty))\n+        p!(print(self.projection_ty), \" == \", print(self.ty))\n     }\n \n     ty::ProjectionTy<'tcx> {\n@@ -2048,9 +2037,9 @@ define_print_and_forward_display! {\n \n     ty::ClosureKind {\n         match *self {\n-            ty::ClosureKind::Fn => p!(write(\"Fn\")),\n-            ty::ClosureKind::FnMut => p!(write(\"FnMut\")),\n-            ty::ClosureKind::FnOnce => p!(write(\"FnOnce\")),\n+            ty::ClosureKind::Fn => p!(\"Fn\"),\n+            ty::ClosureKind::FnMut => p!(\"FnMut\"),\n+            ty::ClosureKind::FnOnce => p!(\"FnOnce\"),\n         }\n     }\n \n@@ -2065,36 +2054,31 @@ define_print_and_forward_display! {\n         match *self {\n             ty::PredicateAtom::Trait(ref data, constness) => {\n                 if let hir::Constness::Const = constness {\n-                    p!(write(\"const \"));\n+                    p!(\"const \");\n                 }\n                 p!(print(data))\n             }\n             ty::PredicateAtom::Subtype(predicate) => p!(print(predicate)),\n             ty::PredicateAtom::RegionOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateAtom::TypeOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateAtom::Projection(predicate) => p!(print(predicate)),\n-            ty::PredicateAtom::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n+            ty::PredicateAtom::WellFormed(arg) => p!(print(arg), \" well-formed\"),\n             ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n-                p!(write(\"the trait `\"),\n-                print_def_path(trait_def_id, &[]),\n-                write(\"` is object-safe\"))\n+                p!(\"the trait `\", print_def_path(trait_def_id, &[]), \"` is object-safe\")\n             }\n             ty::PredicateAtom::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                p!(write(\"the closure `\"),\n+                p!(\"the closure `\",\n                 print_value_path(closure_def_id, &[]),\n                 write(\"` implements the trait `{}`\", kind))\n             }\n             ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n-                p!(write(\"the constant `\"),\n-                print_value_path(def.did, substs),\n-                write(\"` can be evaluated\"))\n+                p!(\"the constant `\", print_value_path(def.did, substs), \"` can be evaluated\")\n             }\n             ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                p!(write(\"the constant `\"),\n-                print(c1),\n-                write(\"` equals `\"),\n-                print(c2),\n-                write(\"`\"))\n+                p!(\"the constant `\", print(c1), \"` equals `\", print(c2), \"`\")\n+            }\n+            ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n+                p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n         }\n     }\n@@ -2112,17 +2096,10 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n     // Iterate all local crate items no matter where they are defined.\n     let hir = tcx.hir();\n     for item in hir.krate().items.values() {\n-        if item.ident.name.as_str().is_empty() {\n+        if item.ident.name.as_str().is_empty() || matches!(item.kind, ItemKind::Use(_, _)) {\n             continue;\n         }\n \n-        match item.kind {\n-            ItemKind::Use(_, _) => {\n-                continue;\n-            }\n-            _ => {}\n-        }\n-\n         if let Some(local_def_id) = hir.definitions().opt_hir_id_to_local_def_id(item.hir_id) {\n             let def_id = local_def_id.to_def_id();\n             let ns = tcx.def_kind(def_id).ns().unwrap_or(Namespace::TypeNS);"}, {"sha": "a005990264cf11176443819ad7e8446804e15cb8", "filename": "compiler/rustc_middle/src/ty/query/keys.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -193,6 +193,22 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     }\n }\n \n+impl<'tcx> Key\n+    for (\n+        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n+        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n+    )\n+{\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        (self.0).0.did.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        (self.0).0.did.default_span(tcx)\n+    }\n+}\n+\n impl<'tcx> Key for (LocalDefId, DefId, SubstsRef<'tcx>) {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "d3a7412ef14e777c2d58da3879f38373a1b28c62", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -14,7 +14,7 @@ use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLife\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n-use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult, ConstValue};\n+use crate::mir::interpret::{ConstValue, EvalToAllocationRawResult, EvalToConstValueResult};\n use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n use crate::traits::query::{"}, {"sha": "b0c48a860ebafd328e17f0cb141805e132b2e3bd", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -760,6 +760,12 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     }\n }\n \n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         RefDecodable::decode(d)"}, {"sha": "4e8db3194bdff623109ae4e0bfa3b7902d7229cb", "filename": "compiler/rustc_middle/src/ty/query/profiling_support.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -55,18 +55,22 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n         };\n \n         let dis_buffer = &mut [0u8; 16];\n+        let crate_name;\n+        let other_name;\n         let name;\n         let dis;\n         let end_index;\n \n         match def_key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n-                name = self.tcx.original_crate_name(def_id.krate);\n+                crate_name = self.tcx.original_crate_name(def_id.krate).as_str();\n+                name = &*crate_name;\n                 dis = \"\";\n                 end_index = 3;\n             }\n             other => {\n-                name = other.as_symbol();\n+                other_name = other.to_string();\n+                name = other_name.as_str();\n                 if def_key.disambiguated_data.disambiguator == 0 {\n                     dis = \"\";\n                     end_index = 3;\n@@ -80,7 +84,6 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n             }\n         }\n \n-        let name = &*name.as_str();\n         let components = [\n             StringComponent::Ref(parent_string_id),\n             StringComponent::Value(\"::\"),"}, {"sha": "c4df0bba726cb9d0929c355b7f0021e88061c0e0", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -576,7 +576,20 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n             new_val.map(ty::ConstKind::Value)\n         }\n \n-        // FIXME(const_generics): this is wrong, as it is a projection\n+        (\n+            ty::ConstKind::Unevaluated(a_def, a_substs, None),\n+            ty::ConstKind::Unevaluated(b_def, b_substs, None),\n+        ) if tcx.features().const_evaluatable_checked => {\n+            if tcx.try_unify_abstract_consts(((a_def, a_substs), (b_def, b_substs))) {\n+                Ok(a.val)\n+            } else {\n+                Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n+            }\n+        }\n+\n+        // While this is slightly incorrect, it shouldn't matter for `min_const_generics`\n+        // and is the better alternative to waiting until `const_evaluatable_checked` can\n+        // be stabilized.\n         (\n             ty::ConstKind::Unevaluated(a_def, a_substs, a_promoted),\n             ty::ConstKind::Unevaluated(b_def, b_substs, b_promoted),"}, {"sha": "597ceac9386a049d37a9b60d428ddd35ed7a7108", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -260,6 +260,9 @@ impl fmt::Debug for ty::PredicateAtom<'tcx> {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n             ty::PredicateAtom::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n+            ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n+                write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n+            }\n         }\n     }\n }\n@@ -536,6 +539,9 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateAtom<'a> {\n             ty::PredicateAtom::ConstEquate(c1, c2) => {\n                 tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateAtom::ConstEquate(c1, c2))\n             }\n+            ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n+                tcx.lift(&ty).map(ty::PredicateAtom::TypeWellFormedFromEnv)\n+            }\n         }\n     }\n }\n@@ -551,7 +557,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     type Lifted = ty::ParamEnv<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.caller_bounds())\n-            .map(|caller_bounds| ty::ParamEnv::new(caller_bounds, self.reveal(), self.def_id))\n+            .map(|caller_bounds| ty::ParamEnv::new(caller_bounds, self.reveal()))\n     }\n }\n \n@@ -606,8 +612,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n     type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.region)\n-            .map(|region| ty::adjustment::OverloadedDeref { region, mutbl: self.mutbl })\n+        tcx.lift(&self.region).map(|region| ty::adjustment::OverloadedDeref {\n+            region,\n+            mutbl: self.mutbl,\n+            span: self.span,\n+        })\n     }\n }\n \n@@ -680,6 +689,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             Traits(x) => Traits(x),\n             VariadicMismatch(x) => VariadicMismatch(x),\n             CyclicTy(t) => return tcx.lift(&t).map(|t| CyclicTy(t)),\n+            CyclicConst(ct) => return tcx.lift(&ct).map(|ct| CyclicConst(ct)),\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),"}, {"sha": "724ec101b23b71a388f914dcdf9f7bdb0da1dd43", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1233,13 +1233,13 @@ rustc_index::newtype_index! {\n     /// particular, imagine a type like this:\n     ///\n     ///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n-    ///     ^          ^            |        |         |\n-    ///     |          |            |        |         |\n-    ///     |          +------------+ 0      |         |\n-    ///     |                                |         |\n-    ///     +--------------------------------+ 1       |\n-    ///     |                                          |\n-    ///     +------------------------------------------+ 0\n+    ///     ^          ^            |          |           |\n+    ///     |          |            |          |           |\n+    ///     |          +------------+ 0        |           |\n+    ///     |                                  |           |\n+    ///     +----------------------------------+ 1         |\n+    ///     |                                              |\n+    ///     +----------------------------------------------+ 0\n     ///\n     /// In this type, there are two binders (the outer fn and the inner\n     /// fn). We need to be able to determine, for any given region, which\n@@ -2280,6 +2280,12 @@ impl<'tcx> TyS<'tcx> {\n     ///\n     /// Returning true means the type is known to be sized. Returning\n     /// `false` means nothing -- could be sized, might not be.\n+    ///\n+    /// Note that we could never rely on the fact that a type such as `[_]` is\n+    /// trivially `!Sized` because we could be in a type environment with a\n+    /// bound such as `[_]: Copy`. A function with such a bound obviously never\n+    /// can be called, but that doesn't mean it shouldn't typecheck. This is why\n+    /// this method doesn't return `Option<bool>`.\n     pub fn is_trivially_sized(&self, tcx: TyCtxt<'tcx>) -> bool {\n         match self.kind() {\n             ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n@@ -2316,9 +2322,4 @@ impl<'tcx> TyS<'tcx> {\n             }\n         }\n     }\n-\n-    /// Is this a zero-sized type?\n-    pub fn is_zst(&'tcx self, tcx: TyCtxt<'tcx>, did: DefId) -> bool {\n-        tcx.layout_of(tcx.param_env(did).and(self)).map(|layout| layout.is_zst()).unwrap_or(false)\n-    }\n }"}, {"sha": "9d5b558234b3af16eb59ad54f74eea279b84c128", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -167,7 +167,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Returns a vector containing all impls\n+    /// Returns an iterator containing all impls\n     pub fn all_impls(self, def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {\n         let TraitImpls { blanket_impls, non_blanket_impls } = self.trait_impls_of(def_id);\n "}, {"sha": "4127b6535bca6c5a013d0bf624dd61660367757f", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -170,9 +170,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         });\n         hasher.finish()\n     }\n-}\n \n-impl<'tcx> TyCtxt<'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         if let ty::Adt(def, substs) = *ty.kind() {\n             for field in def.all_fields() {\n@@ -526,22 +524,22 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns `true` if the node pointed to by `def_id` is a `static` item.\n-    pub fn is_static(&self, def_id: DefId) -> bool {\n+    pub fn is_static(self, def_id: DefId) -> bool {\n         self.static_mutability(def_id).is_some()\n     }\n \n     /// Returns `true` if this is a `static` item with the `#[thread_local]` attribute.\n-    pub fn is_thread_local_static(&self, def_id: DefId) -> bool {\n+    pub fn is_thread_local_static(self, def_id: DefId) -> bool {\n         self.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n     }\n \n     /// Returns `true` if the node pointed to by `def_id` is a mutable `static` item.\n-    pub fn is_mutable_static(&self, def_id: DefId) -> bool {\n+    pub fn is_mutable_static(self, def_id: DefId) -> bool {\n         self.static_mutability(def_id) == Some(hir::Mutability::Mut)\n     }\n \n     /// Get the type of the pointer to the static that we use in MIR.\n-    pub fn static_ptr_ty(&self, def_id: DefId) -> Ty<'tcx> {\n+    pub fn static_ptr_ty(self, def_id: DefId) -> Ty<'tcx> {\n         // Make sure that any constants in the static's type are evaluated.\n         let static_ty = self.normalize_erasing_regions(ty::ParamEnv::empty(), self.type_of(def_id));\n "}, {"sha": "357a0dd65c414fda4bf7f000c1daf9236392495c", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -3,6 +3,7 @@\n \n use crate::ty;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_data_structures::sso::SsoHashSet;\n use smallvec::{self, SmallVec};\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n@@ -12,11 +13,20 @@ type TypeWalkerStack<'tcx> = SmallVec<[GenericArg<'tcx>; 8]>;\n pub struct TypeWalker<'tcx> {\n     stack: TypeWalkerStack<'tcx>,\n     last_subtree: usize,\n+    visited: SsoHashSet<GenericArg<'tcx>>,\n }\n \n+/// An iterator for walking the type tree.\n+///\n+/// It's very easy to produce a deeply\n+/// nested type tree with a lot of\n+/// identical subtrees. In order to work efficiently\n+/// in this situation walker only visits each type once.\n+/// It maintains a set of visited types and\n+/// skips any types that are already there.\n impl<'tcx> TypeWalker<'tcx> {\n-    pub fn new(root: GenericArg<'tcx>) -> TypeWalker<'tcx> {\n-        TypeWalker { stack: smallvec![root], last_subtree: 1 }\n+    pub fn new(root: GenericArg<'tcx>) -> Self {\n+        Self { stack: smallvec![root], last_subtree: 1, visited: SsoHashSet::new() }\n     }\n \n     /// Skips the subtree corresponding to the last type\n@@ -41,11 +51,15 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n \n     fn next(&mut self) -> Option<GenericArg<'tcx>> {\n         debug!(\"next(): stack={:?}\", self.stack);\n-        let next = self.stack.pop()?;\n-        self.last_subtree = self.stack.len();\n-        push_inner(&mut self.stack, next);\n-        debug!(\"next: stack={:?}\", self.stack);\n-        Some(next)\n+        loop {\n+            let next = self.stack.pop()?;\n+            self.last_subtree = self.stack.len();\n+            if self.visited.insert(next) {\n+                push_inner(&mut self.stack, next);\n+                debug!(\"next: stack={:?}\", self.stack);\n+                return Some(next);\n+            }\n+        }\n     }\n }\n \n@@ -67,9 +81,17 @@ impl GenericArg<'tcx> {\n     /// Iterator that walks the immediate children of `self`. Hence\n     /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n     /// (but not `i32`, like `walk`).\n-    pub fn walk_shallow(self) -> impl Iterator<Item = GenericArg<'tcx>> {\n+    ///\n+    /// Iterator only walks items once.\n+    /// It accepts visited set, updates it with all visited types\n+    /// and skips any types that are already there.\n+    pub fn walk_shallow(\n+        self,\n+        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n+    ) -> impl Iterator<Item = GenericArg<'tcx>> {\n         let mut stack = SmallVec::new();\n         push_inner(&mut stack, self);\n+        stack.retain(|a| visited.insert(*a));\n         stack.into_iter()\n     }\n }"}, {"sha": "da857b0a403b4f909e8d0d9a332a7c5714577516", "filename": "compiler/rustc_middle/src/util/common.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_middle%2Fsrc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Futil%2Fcommon.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,5 +1,3 @@\n-#![allow(non_camel_case_types)]\n-\n use rustc_data_structures::sync::Lock;\n \n use std::fmt::Debug;"}, {"sha": "487668cfa1109476ccc6449d32718a20e8e49ce1", "filename": "compiler/rustc_mir/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2FCargo.toml?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -10,10 +10,10 @@ doctest = false\n [dependencies]\n either = \"1.5.0\"\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n-itertools = \"0.8\"\n+itertools = \"0.9\"\n tracing = \"0.1\"\n-log_settings = \"0.1.1\"\n polonius-engine = \"0.12.0\"\n+regex = \"1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "689ec249a2fb4f5c708fc3ffa1e244483a3fe97c", "filename": "compiler/rustc_mir/src/borrow_check/def_use.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdef_use.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -72,8 +72,7 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n             Some(DefUse::Drop),\n \n-        // Coverage and debug info are neither def nor use.\n-        PlaceContext::NonUse(NonUseContext::Coverage) |\n+        // Debug info is neither def nor use.\n         PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n     }\n }"}, {"sha": "dca0d6d7790d495b54b936867e62ced70616768a", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -66,7 +66,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let span = use_spans.args_or_use();\n \n         let move_site_vec = self.get_moved_indexes(location, mpi);\n-        debug!(\"report_use_of_moved_or_uninitialized: move_site_vec={:?}\", move_site_vec);\n+        debug!(\n+            \"report_use_of_moved_or_uninitialized: move_site_vec={:?} use_spans={:?}\",\n+            move_site_vec, use_spans\n+        );\n         let move_out_indices: Vec<_> =\n             move_site_vec.iter().map(|move_site| move_site.moi).collect();\n \n@@ -229,6 +232,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     );\n                                 }\n                             }\n+                            // Deref::deref takes &self, which cannot cause a move\n+                            FnSelfUseKind::DerefCoercion { .. } => unreachable!(),\n                         }\n                     } else {\n                         err.span_label(\n@@ -331,10 +336,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 };\n                 if let ty::Param(param_ty) = ty.kind() {\n                     let tcx = self.infcx.tcx;\n-                    let generics = tcx.generics_of(self.mir_def_id);\n+                    let generics = tcx.generics_of(self.mir_def_id());\n                     let param = generics.type_param(&param_ty, tcx);\n-                    if let Some(generics) =\n-                        tcx.hir().get_generics(tcx.closure_base_def_id(self.mir_def_id.to_def_id()))\n+                    if let Some(generics) = tcx\n+                        .hir()\n+                        .get_generics(tcx.closure_base_def_id(self.mir_def_id().to_def_id()))\n                     {\n                         suggest_constraining_type_param(\n                             tcx,\n@@ -355,6 +361,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.note_type_does_not_implement_copy(&mut err, &note_msg, ty, span, partial_str);\n             }\n \n+            if let UseSpans::FnSelfUse {\n+                kind: FnSelfUseKind::DerefCoercion { deref_target, deref_target_ty },\n+                ..\n+            } = use_spans\n+            {\n+                err.note(&format!(\n+                    \"{} occurs due to deref coercion to `{}`\",\n+                    desired_action.as_noun(),\n+                    deref_target_ty\n+                ));\n+\n+                err.span_note(deref_target, \"deref defined here\");\n+            }\n+\n             if let Some((_, mut old_err)) =\n                 self.move_error_reported.insert(move_out_indices, (used_place, err))\n             {\n@@ -945,7 +965,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         name: &str,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrow_spans: UseSpans,\n+        borrow_spans: UseSpans<'tcx>,\n         explanation: BorrowExplanation,\n     ) -> DiagnosticBuilder<'cx> {\n         debug!(\n@@ -985,7 +1005,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            let fn_hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n+            let fn_hir_id = self.mir_hir_id();\n             err.span_label(\n                 drop_span,\n                 format!(\n@@ -1000,7 +1020,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             match &self\n                                 .infcx\n                                 .tcx\n-                                .typeck(self.mir_def_id)\n+                                .typeck(self.mir_def_id())\n                                 .node_type(fn_hir_id)\n                                 .kind()\n                             {\n@@ -1146,7 +1166,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrow_spans: UseSpans,\n+        borrow_spans: UseSpans<'tcx>,\n         proper_span: Span,\n         explanation: BorrowExplanation,\n     ) -> DiagnosticBuilder<'cx> {\n@@ -1274,7 +1294,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn report_escaping_closure_capture(\n         &mut self,\n-        use_span: UseSpans,\n+        use_span: UseSpans<'tcx>,\n         var_span: Span,\n         fr_name: &RegionName,\n         category: ConstraintCategory,\n@@ -1350,7 +1370,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> DiagnosticBuilder<'cx> {\n         let tcx = self.infcx.tcx;\n \n-        let (_, escapes_from) = tcx.article_and_description(self.mir_def_id.to_def_id());\n+        let (_, escapes_from) = tcx.article_and_description(self.mir_def_id().to_def_id());\n \n         let mut err =\n             borrowck_errors::borrowed_data_escapes_closure(tcx, escape_span, escapes_from);\n@@ -1689,15 +1709,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         // Define a fallback for when we can't match a closure.\n         let fallback = || {\n-            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id.to_def_id());\n+            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id().to_def_id());\n             if is_closure {\n                 None\n             } else {\n-                let ty = self.infcx.tcx.type_of(self.mir_def_id);\n+                let ty = self.infcx.tcx.type_of(self.mir_def_id());\n                 match ty.kind() {\n                     ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n-                        self.mir_def_id.to_def_id(),\n-                        self.infcx.tcx.fn_sig(self.mir_def_id),\n+                        self.mir_def_id().to_def_id(),\n+                        self.infcx.tcx.fn_sig(self.mir_def_id()),\n                     ),\n                     _ => None,\n                 }"}, {"sha": "eccb6168229c29f5949ef6f468ff03bd6cfb1175", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -501,7 +501,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn later_use_kind(\n         &self,\n         borrow: &BorrowData<'tcx>,\n-        use_spans: UseSpans,\n+        use_spans: UseSpans<'tcx>,\n         location: Location,\n     ) -> (LaterUseKind, Span) {\n         match use_spans {"}, {"sha": "4256f6e39d5e863234dcefda647b0994c5fc4bc2", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 103, "deletions": 77, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::{\n     PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_span::{\n     hygiene::{DesugaringKind, ForLoopLoc},\n     symbol::sym,\n@@ -150,8 +150,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Some(mut descr) => {\n                 // Surround descr with `backticks`.\n                 descr.reserve(2);\n-                descr.insert_str(0, \"`\");\n-                descr.push_str(\"`\");\n+                descr.insert(0, '`');\n+                descr.push('`');\n                 descr\n             }\n             None => \"value\".to_string(),\n@@ -222,7 +222,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             if self.upvars[var_index].by_ref {\n                                 buf.push_str(&name);\n                             } else {\n-                                buf.push_str(&format!(\"*{}\", &name));\n+                                buf.push('*');\n+                                buf.push_str(&name);\n                             }\n                         } else {\n                             if autoderef {\n@@ -234,7 +235,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     &including_downcast,\n                                 )?;\n                             } else {\n-                                buf.push_str(&\"*\");\n+                                buf.push('*');\n                                 self.append_place_to_string(\n                                     PlaceRef { local, projection: proj_base },\n                                     buf,\n@@ -272,7 +273,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 autoderef,\n                                 &including_downcast,\n                             )?;\n-                            buf.push_str(&format!(\".{}\", field_name));\n+                            buf.push('.');\n+                            buf.push_str(&field_name);\n                         }\n                     }\n                     ProjectionElem::Index(index) => {\n@@ -284,11 +286,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             autoderef,\n                             &including_downcast,\n                         )?;\n-                        buf.push_str(\"[\");\n+                        buf.push('[');\n                         if self.append_local_to_string(*index, buf).is_err() {\n-                            buf.push_str(\"_\");\n+                            buf.push('_');\n                         }\n-                        buf.push_str(\"]\");\n+                        buf.push(']');\n                     }\n                     ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n                         autoderef = true;\n@@ -301,7 +303,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             autoderef,\n                             &including_downcast,\n                         )?;\n-                        buf.push_str(&\"[..]\");\n+                        buf.push_str(\"[..]\");\n                     }\n                 };\n             }\n@@ -536,7 +538,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n /// The span(s) associated to a use of a place.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub(super) enum UseSpans {\n+pub(super) enum UseSpans<'tcx> {\n     /// The access is caused by capturing a variable for a closure.\n     ClosureUse {\n         /// This is true if the captured variable was from a generator.\n@@ -556,7 +558,7 @@ pub(super) enum UseSpans {\n         fn_call_span: Span,\n         /// The definition span of the method being called\n         fn_span: Span,\n-        kind: FnSelfUseKind,\n+        kind: FnSelfUseKind<'tcx>,\n     },\n     /// This access is caused by a `match` or `if let` pattern.\n     PatUse(Span),\n@@ -565,31 +567,44 @@ pub(super) enum UseSpans {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub(super) enum FnSelfUseKind {\n+pub(super) enum FnSelfUseKind<'tcx> {\n     /// A normal method call of the form `receiver.foo(a, b, c)`\n     Normal { self_arg: Ident, implicit_into_iter: bool },\n     /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n     FnOnceCall,\n     /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n     Operator { self_arg: Ident },\n+    DerefCoercion {\n+        /// The `Span` of the `Target` associated type\n+        /// in the `Deref` impl we are using.\n+        deref_target: Span,\n+        /// The type `T::Deref` we are dereferencing to\n+        deref_target_ty: Ty<'tcx>,\n+    },\n }\n \n-impl UseSpans {\n+impl UseSpans<'_> {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { args_span: span, .. }\n             | UseSpans::PatUse(span)\n-            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n+            UseSpans::FnSelfUse {\n+                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n+            } => fn_call_span,\n+            UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n \n     pub(super) fn var_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { var_span: span, .. }\n             | UseSpans::PatUse(span)\n-            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n+            UseSpans::FnSelfUse {\n+                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n+            } => fn_call_span,\n+            UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n \n@@ -648,7 +663,7 @@ impl UseSpans {\n                     \" in closure\".to_string()\n                 }\n             }\n-            _ => \"\".to_string(),\n+            _ => String::new(),\n         }\n     }\n \n@@ -752,7 +767,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         moved_place: PlaceRef<'tcx>, // Could also be an upvar.\n         location: Location,\n-    ) -> UseSpans {\n+    ) -> UseSpans<'tcx> {\n         use self::UseSpans::*;\n \n         let stmt = match self.body[location.block].statements.get(location.statement_index) {\n@@ -804,68 +819,79 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"move_spans: target_temp = {:?}\", target_temp);\n \n         if let Some(Terminator {\n-            kind: TerminatorKind::Call { func, args, fn_span, from_hir_call, .. },\n-            ..\n+            kind: TerminatorKind::Call { fn_span, from_hir_call, .. }, ..\n         }) = &self.body[location.block].terminator\n         {\n-            let mut method_did = None;\n-            if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n-                if let ty::FnDef(def_id, _) = *ty.kind() {\n-                    debug!(\"move_spans: fn = {:?}\", def_id);\n-                    if let Some(ty::AssocItem { fn_has_self_parameter, .. }) =\n-                        self.infcx.tcx.opt_associated_item(def_id)\n-                    {\n-                        if *fn_has_self_parameter {\n-                            method_did = Some(def_id);\n-                        }\n-                    }\n-                }\n-            }\n+            let (method_did, method_substs) = if let Some(info) =\n+                crate::util::find_self_call(self.infcx.tcx, &self.body, target_temp, location.block)\n+            {\n+                info\n+            } else {\n+                return normal_ret;\n+            };\n \n             let tcx = self.infcx.tcx;\n-            let method_did = if let Some(did) = method_did { did } else { return normal_ret };\n-\n-            if let [Operand::Move(self_place), ..] = **args {\n-                if self_place.as_local() == Some(target_temp) {\n-                    let parent = tcx.parent(method_did);\n-                    let is_fn_once = parent == tcx.lang_items().fn_once_trait();\n-                    let is_operator = !from_hir_call\n-                        && parent.map_or(false, |p| {\n-                            tcx.lang_items().group(LangItemGroup::Op).contains(&p)\n-                        });\n-                    let fn_call_span = *fn_span;\n-\n-                    let self_arg = tcx.fn_arg_names(method_did)[0];\n-\n-                    let kind = if is_fn_once {\n-                        FnSelfUseKind::FnOnceCall\n-                    } else if is_operator {\n-                        FnSelfUseKind::Operator { self_arg }\n-                    } else {\n-                        debug!(\n-                            \"move_spans: method_did={:?}, fn_call_span={:?}\",\n-                            method_did, fn_call_span\n-                        );\n-                        let implicit_into_iter = matches!(\n-                            fn_call_span.desugaring_kind(),\n-                            Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n-                        );\n-                        FnSelfUseKind::Normal { self_arg, implicit_into_iter }\n-                    };\n-\n-                    return FnSelfUse {\n-                        var_span: stmt.source_info.span,\n-                        fn_call_span,\n-                        fn_span: self\n-                            .infcx\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .guess_head_span(self.infcx.tcx.def_span(method_did)),\n-                        kind,\n-                    };\n+            let parent = tcx.parent(method_did);\n+            let is_fn_once = parent == tcx.lang_items().fn_once_trait();\n+            let is_operator = !from_hir_call\n+                && parent.map_or(false, |p| tcx.lang_items().group(LangItemGroup::Op).contains(&p));\n+            let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n+            let fn_call_span = *fn_span;\n+\n+            let self_arg = tcx.fn_arg_names(method_did)[0];\n+\n+            debug!(\n+                \"terminator = {:?} from_hir_call={:?}\",\n+                self.body[location.block].terminator, from_hir_call\n+            );\n+\n+            // Check for a 'special' use of 'self' -\n+            // an FnOnce call, an operator (e.g. `<<`), or a\n+            // deref coercion.\n+            let kind = if is_fn_once {\n+                Some(FnSelfUseKind::FnOnceCall)\n+            } else if is_operator {\n+                Some(FnSelfUseKind::Operator { self_arg })\n+            } else if is_deref {\n+                let deref_target =\n+                    tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n+                        Instance::resolve(tcx, self.param_env, deref_target, method_substs)\n+                            .transpose()\n+                    });\n+                if let Some(Ok(instance)) = deref_target {\n+                    let deref_target_ty = instance.ty(tcx, self.param_env);\n+                    Some(FnSelfUseKind::DerefCoercion {\n+                        deref_target: tcx.def_span(instance.def_id()),\n+                        deref_target_ty,\n+                    })\n+                } else {\n+                    None\n                 }\n-            }\n+            } else {\n+                None\n+            };\n+\n+            let kind = kind.unwrap_or_else(|| {\n+                // This isn't a 'special' use of `self`\n+                debug!(\"move_spans: method_did={:?}, fn_call_span={:?}\", method_did, fn_call_span);\n+                let implicit_into_iter = matches!(\n+                    fn_call_span.desugaring_kind(),\n+                    Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n+                );\n+                FnSelfUseKind::Normal { self_arg, implicit_into_iter }\n+            });\n+\n+            return FnSelfUse {\n+                var_span: stmt.source_info.span,\n+                fn_call_span,\n+                fn_span: self\n+                    .infcx\n+                    .tcx\n+                    .sess\n+                    .source_map()\n+                    .guess_head_span(self.infcx.tcx.def_span(method_did)),\n+                kind,\n+            };\n         }\n         normal_ret\n     }\n@@ -874,7 +900,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// and its usage of the local assigned at `location`.\n     /// This is done by searching in statements succeeding `location`\n     /// and originating from `maybe_closure_span`.\n-    pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans {\n+    pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans<'tcx> {\n         use self::UseSpans::*;\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n@@ -978,7 +1004,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Helper to retrieve span(s) of given borrow from the current MIR\n     /// representation\n-    pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData<'_>) -> UseSpans {\n+    pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData<'_>) -> UseSpans<'tcx> {\n         let span = self.body.source_info(borrow.reserve_location).span;\n         self.borrow_spans(span, borrow.reserve_location)\n     }"}, {"sha": "b1cebbd1f381bef796bac88a9dd35b378c6ee0e8", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -47,7 +47,7 @@ enum GroupedMoveError<'tcx> {\n     // Everything that isn't from pattern matching.\n     OtherIllegalMove {\n         original_path: Place<'tcx>,\n-        use_spans: UseSpans,\n+        use_spans: UseSpans<'tcx>,\n         kind: IllegalMoveOriginKind<'tcx>,\n     },\n }\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let (mut err, err_span) = {\n             let (span, use_spans, original_path, kind): (\n                 Span,\n-                Option<UseSpans>,\n+                Option<UseSpans<'tcx>>,\n                 Place<'tcx>,\n                 &IllegalMoveOriginKind<'_>,\n             ) = match error {\n@@ -291,7 +291,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         move_place: Place<'tcx>,\n         deref_target_place: Place<'tcx>,\n         span: Span,\n-        use_spans: Option<UseSpans>,\n+        use_spans: Option<UseSpans<'tcx>>,\n     ) -> DiagnosticBuilder<'a> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n@@ -331,7 +331,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 self.cannot_move_out_of_interior_noncopy(span, ty, None)\n             }\n             ty::Closure(def_id, closure_substs)\n-                if def_id.as_local() == Some(self.mir_def_id) && upvar_field.is_some() =>\n+                if def_id.as_local() == Some(self.mir_def_id()) && upvar_field.is_some() =>\n             {\n                 let closure_kind_ty = closure_substs.as_closure().kind_ty();\n                 let closure_kind = closure_kind_ty.to_opt_closure_kind();\n@@ -492,8 +492,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             {\n                 if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n                 {\n-                    if pat_snippet.starts_with('&') {\n-                        let pat_snippet = pat_snippet[1..].trim_start();\n+                    if let Some(stripped) = pat_snippet.strip_prefix('&') {\n+                        let pat_snippet = stripped.trim_start();\n                         let (suggestion, to_remove) = if pat_snippet.starts_with(\"mut\")\n                             && pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n                         {"}, {"sha": "9728662c98494bb8ec14c65ddb2946f4045deb40", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err.span_label(sp, format!(\"cannot {}\", act));\n \n         let hir = self.infcx.tcx.hir();\n-        let closure_id = hir.local_def_id_to_hir_id(self.mir_def_id);\n+        let closure_id = self.mir_hir_id();\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n         let item_id = hir.enclosing_body_owner(fn_call_id);\n@@ -631,9 +631,8 @@ fn suggest_ampmut<'tcx>(\n                 let lt_name = &src[1..ws_pos];\n                 let ty = &src[ws_pos..];\n                 return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n-            } else if src.starts_with('&') {\n-                let borrowed_expr = &src[1..];\n-                return (assignment_rhs_span, format!(\"&mut {}\", borrowed_expr));\n+            } else if let Some(stripped) = src.strip_prefix('&') {\n+                return (assignment_rhs_span, format!(\"&mut {}\", stripped));\n             }\n         }\n     }"}, {"sha": "7505e6e2dd11e224db3f97f0c0b91372335ac407", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -115,9 +115,10 @@ impl OutlivesSuggestionBuilder {\n             //    should just replace 'a with 'static.\n             // 3) Suggest unifying 'a with 'b if we have both 'a: 'b and 'b: 'a\n \n-            if outlived.iter().any(|(_, outlived_name)| {\n-                if let RegionNameSource::Static = outlived_name.source { true } else { false }\n-            }) {\n+            if outlived\n+                .iter()\n+                .any(|(_, outlived_name)| matches!(outlived_name.source, RegionNameSource::Static))\n+            {\n                 suggested.push(SuggestedConstraint::Static(fr_name));\n             } else {\n                 // We want to isolate out all lifetimes that should be unified and print out"}, {"sha": "b145e1d5fa33310ede6a24cc184bcbc29dd0e9f9", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -387,7 +387,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let ReturnConstraint::ClosureUpvar(upvar) = kind {\n             let def_id = match self.regioncx.universal_regions().defining_ty {\n                 DefiningTy::Closure(def_id, _) => def_id,\n-                ty @ _ => bug!(\"unexpected DefiningTy {:?}\", ty),\n+                ty => bug!(\"unexpected DefiningTy {:?}\", ty),\n             };\n \n             let upvar_def_span = self.infcx.tcx.hir().span(upvar);\n@@ -515,7 +515,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut diag =\n             self.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n \n-        let (_, mir_def_name) = self.infcx.tcx.article_and_description(self.mir_def_id.to_def_id());\n+        let (_, mir_def_name) =\n+            self.infcx.tcx.article_and_description(self.mir_def_id().to_def_id());\n \n         let fr_name = self.give_region_a_name(*fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);"}, {"sha": "2e5a231fef057d3123022230261673ca78057f31", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -147,6 +147,14 @@ impl Display for RegionName {\n }\n \n impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n+    crate fn mir_def_id(&self) -> hir::def_id::LocalDefId {\n+        self.body.source.def_id().as_local().unwrap()\n+    }\n+\n+    crate fn mir_hir_id(&self) -> hir::HirId {\n+        self.infcx.tcx.hir().local_def_id_to_hir_id(self.mir_def_id())\n+    }\n+\n     /// Generate a synthetic region named `'N`, where `N` is the next value of the counter. Then,\n     /// increment the counter.\n     ///\n@@ -266,12 +274,11 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(_, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n-                            tcx.hir().expect_expr(mir_hir_id).kind\n+                            tcx.hir().expect_expr(self.mir_hir_id()).kind\n                         {\n                             span\n                         } else {\n@@ -361,8 +368,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         &self,\n         argument_index: usize,\n     ) -> Option<&hir::Ty<'tcx>> {\n-        let mir_hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n-        let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n+        let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(self.mir_hir_id())?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n@@ -396,15 +402,15 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionNameHighlight> {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = self.infcx.extract_type_name(&ty, Some(highlight)).0;\n+        let type_name =\n+            self.infcx.extract_inference_diagnostics_data(ty.into(), Some(highlight)).name;\n \n         debug!(\n             \"highlight_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n         if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-\n             Some(RegionNameHighlight::CannotMatchHirTy(span, type_name))\n         } else {\n             None\n@@ -646,11 +652,10 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n-\n-        let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n+        let type_name =\n+            self.infcx.extract_inference_diagnostics_data(return_ty.into(), Some(highlight)).name;\n \n-        let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n+        let (return_span, mir_description) = match tcx.hir().get(self.mir_hir_id()) {\n             hir::Node::Expr(hir::Expr {\n                 kind: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n                 ..\n@@ -698,11 +703,10 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n-\n-        let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n+        let type_name =\n+            self.infcx.extract_inference_diagnostics_data(yield_ty.into(), Some(highlight)).name;\n \n-        let yield_span = match tcx.hir().get(mir_hir_id) {\n+        let yield_span = match tcx.hir().get(self.mir_hir_id()) {\n             hir::Node::Expr(hir::Expr {\n                 kind: hir::ExprKind::Closure(_, _, _, span, _), ..\n             }) => (tcx.sess.source_map().end_point(*span)),"}, {"sha": "baaf6f27ee821377069a336a1e6532723b16d209", "filename": "compiler/rustc_mir/src/borrow_check/member_constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmember_constraints.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n     /// Pushes a member constraint into the set.\n     ///\n     /// The input member constraint `m_c` is in the form produced by\n-    /// the the `rustc_middle::infer` code.\n+    /// the `rustc_middle::infer` code.\n     ///\n     /// The `to_region_vid` callback fn is used to convert the regions\n     /// within into `RegionVid` format -- it typically consults the"}, {"sha": "9b34db1de403f51b352d44ca3a77aa61a5d7adf6", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, InstanceDef, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnv, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT, UNUSED_MUT};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n \n@@ -36,7 +36,6 @@ use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathInd\n use crate::dataflow::move_paths::{InitLocation, LookupResult, MoveData, MoveError};\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::{Analysis, BorrowckFlowState as Flows, BorrowckResults};\n-use crate::transform::MirSource;\n \n use self::diagnostics::{AccessKind, RegionName};\n use self::location::LocationTable;\n@@ -112,7 +111,7 @@ fn mir_borrowck<'tcx>(\n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        do_mir_borrowck(&infcx, input_body, promoted, def)\n+        do_mir_borrowck(&infcx, input_body, promoted)\n     });\n     debug!(\"mir_borrowck done\");\n \n@@ -123,8 +122,9 @@ fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n ) -> BorrowCheckResult<'tcx> {\n+    let def = input_body.source.with_opt_param().as_local().unwrap();\n+\n     debug!(\"do_mir_borrowck(def = {:?})\", def);\n \n     let tcx = infcx.tcx;\n@@ -186,7 +186,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // will have a lifetime tied to the inference context.\n     let mut body = input_body.clone();\n     let mut promoted = input_promoted.clone();\n-    let free_regions = nll::replace_regions_in_mir(infcx, def, param_env, &mut body, &mut promoted);\n+    let free_regions = nll::replace_regions_in_mir(infcx, param_env, &mut body, &mut promoted);\n     let body = &body; // no further changes\n \n     let location_table = &LocationTable::new(&body);\n@@ -204,7 +204,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mdpe = MoveDataParamEnv { move_data, param_env };\n \n     let mut flow_inits = MaybeInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def.did.to_def_id())\n+        .into_engine(tcx, &body)\n+        .pass_name(\"borrowck\")\n         .iterate_to_fixpoint()\n         .into_results_cursor(&body);\n \n@@ -221,7 +222,6 @@ fn do_mir_borrowck<'a, 'tcx>(\n         nll_errors,\n     } = nll::compute_regions(\n         infcx,\n-        def.did,\n         free_regions,\n         body,\n         &promoted,\n@@ -235,20 +235,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n-    nll::dump_mir_results(\n-        infcx,\n-        MirSource { instance: InstanceDef::Item(def.to_global()), promoted: None },\n-        &body,\n-        &regioncx,\n-        &opt_closure_req,\n-    );\n+    nll::dump_mir_results(infcx, &body, &regioncx, &opt_closure_req);\n \n     // We also have a `#[rustc_regions]` annotation that causes us to dump\n     // information.\n     nll::dump_annotation(\n         infcx,\n         &body,\n-        def.did.to_def_id(),\n         &regioncx,\n         &opt_closure_req,\n         &opaque_type_values,\n@@ -263,13 +256,16 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let regioncx = Rc::new(regioncx);\n \n     let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), &borrow_set)\n-        .into_engine(tcx, &body, def.did.to_def_id())\n+        .into_engine(tcx, &body)\n+        .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n     let flow_uninits = MaybeUninitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def.did.to_def_id())\n+        .into_engine(tcx, &body)\n+        .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n     let flow_ever_inits = EverInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def.did.to_def_id())\n+        .into_engine(tcx, &body)\n+        .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n \n     let movable_generator = match tcx.hir().get(id) {\n@@ -287,8 +283,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n         if let Err((move_data, move_errors)) = move_data_results {\n             let mut promoted_mbcx = MirBorrowckCtxt {\n                 infcx,\n+                param_env,\n                 body: promoted_body,\n-                mir_def_id: def.did,\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n@@ -320,8 +316,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n+        param_env,\n         body,\n-        mir_def_id: def.did,\n         move_data: &mdpe.move_data,\n         location_table,\n         movable_generator,\n@@ -473,8 +469,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     body: &'cx Body<'tcx>,\n-    mir_def_id: LocalDefId,\n     move_data: &'cx MoveData<'tcx>,\n \n     /// Map from MIR `Location` to `LocationIndex`; created"}, {"sha": "aa428328fe92f7058687a1ab1a464247f5012e6d", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -2,14 +2,14 @@\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, InstanceDef, RegionKind, RegionVid};\n+use rustc_middle::ty::{self, RegionKind, RegionVid};\n use rustc_span::symbol::sym;\n use std::env;\n use std::fmt::Debug;\n@@ -24,7 +24,6 @@ use polonius_engine::{Algorithm, Output};\n use crate::dataflow::impls::MaybeInitializedPlaces;\n use crate::dataflow::move_paths::{InitKind, InitLocation, MoveData};\n use crate::dataflow::ResultsCursor;\n-use crate::transform::MirSource;\n use crate::util as mir_util;\n use crate::util::pretty;\n \n@@ -59,11 +58,12 @@ crate struct NllOutput<'tcx> {\n /// `compute_regions`.\n pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n+    let def = body.source.with_opt_param().as_local().unwrap();\n+\n     debug!(\"replace_regions_in_mir(def={:?})\", def);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n@@ -72,8 +72,7 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, body, promoted);\n \n-    let source = MirSource { instance: InstanceDef::Item(def.to_global()), promoted: None };\n-    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n+    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, body, |_, _| Ok(()));\n \n     universal_regions\n }\n@@ -158,7 +157,6 @@ fn populate_polonius_move_facts(\n /// This may result in errors being reported.\n pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    def_id: LocalDefId,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -182,7 +180,6 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n             param_env,\n             body,\n             promoted,\n-            def_id,\n             &universal_regions,\n             location_table,\n             borrow_set,\n@@ -272,10 +269,12 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     // Generate various additional constraints.\n     invalidation::generate_invalidates(infcx.tcx, &mut all_facts, location_table, body, borrow_set);\n \n+    let def_id = body.source.def_id();\n+\n     // Dump facts if requested.\n     let polonius_output = all_facts.and_then(|all_facts| {\n         if infcx.tcx.sess.opts.debugging_opts.nll_facts {\n-            let def_path = infcx.tcx.def_path(def_id.to_def_id());\n+            let def_path = infcx.tcx.def_path(def_id);\n             let dir_path =\n                 PathBuf::from(\"nll-facts\").join(def_path.to_filename_friendly_no_crate());\n             all_facts.write_to_dir(dir_path, location_table).unwrap();\n@@ -295,7 +294,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let (closure_region_requirements, nll_errors) =\n-        regioncx.solve(infcx, &body, def_id.to_def_id(), polonius_output.clone());\n+        regioncx.solve(infcx, &body, polonius_output.clone());\n \n     if !nll_errors.is_empty() {\n         // Suppress unhelpful extra errors in `infer_opaque_types`.\n@@ -315,16 +314,15 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n pub(super) fn dump_mir_results<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n-    source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n ) {\n-    if !mir_util::dump_enabled(infcx.tcx, \"nll\", source.def_id()) {\n+    if !mir_util::dump_enabled(infcx.tcx, \"nll\", body.source.def_id()) {\n         return;\n     }\n \n-    mir_util::dump_mir(infcx.tcx, None, \"nll\", &0, source, body, |pass_where, out| {\n+    mir_util::dump_mir(infcx.tcx, None, \"nll\", &0, body, |pass_where, out| {\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n             PassWhere::BeforeCFG => {\n@@ -352,29 +350,28 @@ pub(super) fn dump_mir_results<'a, 'tcx>(\n     // Also dump the inference graph constraints as a graphviz file.\n     let _: io::Result<()> = try {\n         let mut file =\n-            pretty::create_dump_file(infcx.tcx, \"regioncx.all.dot\", None, \"nll\", &0, source)?;\n+            pretty::create_dump_file(infcx.tcx, \"regioncx.all.dot\", None, \"nll\", &0, body.source)?;\n         regioncx.dump_graphviz_raw_constraints(&mut file)?;\n     };\n \n     // Also dump the inference graph constraints as a graphviz file.\n     let _: io::Result<()> = try {\n         let mut file =\n-            pretty::create_dump_file(infcx.tcx, \"regioncx.scc.dot\", None, \"nll\", &0, source)?;\n+            pretty::create_dump_file(infcx.tcx, \"regioncx.scc.dot\", None, \"nll\", &0, body.source)?;\n         regioncx.dump_graphviz_scc_constraints(&mut file)?;\n     };\n }\n \n pub(super) fn dump_annotation<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     body: &Body<'tcx>,\n-    mir_def_id: DefId,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n     opaque_type_values: &FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n     errors_buffer: &mut Vec<Diagnostic>,\n ) {\n     let tcx = infcx.tcx;\n-    let base_def_id = tcx.closure_base_def_id(mir_def_id);\n+    let base_def_id = tcx.closure_base_def_id(body.source.def_id());\n     if !tcx.has_attr(base_def_id, sym::rustc_regions) {\n         return;\n     }"}, {"sha": "6c5d42296f72bdb7dcf6b00170fd14bab0f99b5e", "filename": "compiler/rustc_mir/src/borrow_check/prefixes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -33,7 +33,6 @@ pub(super) struct Prefixes<'cx, 'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[allow(dead_code)]\n pub(super) enum PrefixSet {\n     /// Doesn't stop until it returns the base case (a Local or\n     /// Static prefix)."}, {"sha": "5492e328535ef11ce0309cc5f8432b979fdf663e", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -548,10 +548,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n-        mir_def_id: DefId,\n         polonius_output: Option<Rc<PoloniusOutput>>,\n     ) -> (Option<ClosureRegionRequirements<'tcx>>, RegionErrors<'tcx>) {\n-        self.propagate_constraints(body);\n+        let mir_def_id = body.source.def_id();\n+        self.propagate_constraints(body, infcx.tcx);\n \n         let mut errors_buffer = RegionErrors::new();\n \n@@ -599,7 +599,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, _body: &Body<'tcx>) {\n+    fn propagate_constraints(&mut self, _body: &Body<'tcx>, tcx: TyCtxt<'tcx>) {\n         debug!(\"propagate_constraints()\");\n \n         debug!(\"propagate_constraints: constraints={:#?}\", {\n@@ -617,7 +617,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // own.\n         let constraint_sccs = self.constraint_sccs.clone();\n         for scc in constraint_sccs.all_sccs() {\n-            self.compute_value_for_scc(scc);\n+            self.compute_value_for_scc(scc, tcx);\n         }\n \n         // Sort the applied member constraints so we can binary search\n@@ -629,7 +629,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// computed, by unioning the values of its successors.\n     /// Assumes that all successors have been computed already\n     /// (which is assured by iterating over SCCs in dependency order).\n-    fn compute_value_for_scc(&mut self, scc_a: ConstraintSccIndex) {\n+    fn compute_value_for_scc(&mut self, scc_a: ConstraintSccIndex, tcx: TyCtxt<'tcx>) {\n         let constraint_sccs = self.constraint_sccs.clone();\n \n         // Walk each SCC `B` such that `A: B`...\n@@ -652,7 +652,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Now take member constraints into account.\n         let member_constraints = self.member_constraints.clone();\n         for m_c_i in member_constraints.indices(scc_a) {\n-            self.apply_member_constraint(scc_a, m_c_i, member_constraints.choice_regions(m_c_i));\n+            self.apply_member_constraint(\n+                tcx,\n+                scc_a,\n+                m_c_i,\n+                member_constraints.choice_regions(m_c_i),\n+            );\n         }\n \n         debug!(\n@@ -675,6 +680,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// If we make any changes, returns true, else false.\n     fn apply_member_constraint(\n         &mut self,\n+        tcx: TyCtxt<'tcx>,\n         scc: ConstraintSccIndex,\n         member_constraint_index: NllMemberConstraintIndex,\n         choice_regions: &[ty::RegionVid],\n@@ -688,12 +694,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // `impl_trait_in_bindings`, I believe, and we are just\n             // opting not to handle it for now. See #61773 for\n             // details.\n-            bug!(\n-                \"member constraint for `{:?}` has an option region `{:?}` \\\n-                 that is not a universal region\",\n-                self.member_constraints[member_constraint_index].opaque_type_def_id,\n-                uh_oh,\n+            tcx.sess.delay_span_bug(\n+                self.member_constraints[member_constraint_index].definition_span,\n+                &format!(\n+                    \"member constraint for `{:?}` has an option region `{:?}` \\\n+                     that is not a universal region\",\n+                    self.member_constraints[member_constraint_index].opaque_type_def_id, uh_oh,\n+                ),\n             );\n+            return false;\n         }\n \n         // Create a mutable vector of the options. We'll try to winnow"}, {"sha": "f247d07e1f05e66bad3fbd20bcc1c209751583af", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -417,7 +417,7 @@ crate fn location_set_str(\n \n fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String {\n     let mut result = String::new();\n-    result.push_str(\"{\");\n+    result.push('{');\n \n     // Set to Some(l1, l2) when we have observed all the locations\n     // from l1..=l2 (inclusive) but not yet printed them. This\n@@ -478,7 +478,7 @@ fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String\n         push_location_range(&mut result, location1, location2);\n     }\n \n-    result.push_str(\"}\");\n+    result.push('}');\n \n     return result;\n "}, {"sha": "8513e5e531bd7e88b7cfe607fc6c43800a908a2c", "filename": "compiler/rustc_mir/src/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -62,8 +62,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         // `self.constraints`, but we also want to be mutating\n         // `self.member_constraints`. For now, just swap out the value\n         // we want and replace at the end.\n-        let mut tmp =\n-            std::mem::replace(&mut self.constraints.member_constraints, Default::default());\n+        let mut tmp = std::mem::take(&mut self.constraints.member_constraints);\n         for member_constraint in member_constraints {\n             tmp.push_constraint(member_constraint, |r| self.to_region_vid(r));\n         }"}, {"sha": "3c8cbeeca3836553d39c11f4d5d284201d07a98e", "filename": "compiler/rustc_mir/src/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -28,42 +28,43 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let (&normalized_output_ty, normalized_input_tys) =\n             normalized_inputs_and_output.split_last().unwrap();\n \n+        let mir_def_id = body.source.def_id().expect_local();\n+\n         // If the user explicitly annotated the input types, extract\n         // those.\n         //\n         // e.g., `|x: FxHashMap<_, &'static u32>| ...`\n         let user_provided_sig;\n-        if !self.tcx().is_closure(self.mir_def_id.to_def_id()) {\n+        if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n             user_provided_sig = None;\n         } else {\n-            let typeck_results = self.tcx().typeck(self.mir_def_id);\n-            user_provided_sig =\n-                match typeck_results.user_provided_sigs.get(&self.mir_def_id.to_def_id()) {\n-                    None => None,\n-                    Some(user_provided_poly_sig) => {\n-                        // Instantiate the canonicalized variables from\n-                        // user-provided signature (e.g., the `_` in the code\n-                        // above) with fresh variables.\n-                        let (poly_sig, _) =\n-                            self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+            let typeck_results = self.tcx().typeck(mir_def_id);\n+            user_provided_sig = match typeck_results.user_provided_sigs.get(&mir_def_id.to_def_id())\n+            {\n+                None => None,\n+                Some(user_provided_poly_sig) => {\n+                    // Instantiate the canonicalized variables from\n+                    // user-provided signature (e.g., the `_` in the code\n+                    // above) with fresh variables.\n+                    let (poly_sig, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+                        body.span,\n+                        &user_provided_poly_sig,\n+                    );\n+\n+                    // Replace the bound items in the fn sig with fresh\n+                    // variables, so that they represent the view from\n+                    // \"inside\" the closure.\n+                    Some(\n+                        self.infcx\n+                            .replace_bound_vars_with_fresh_vars(\n                                 body.span,\n-                                &user_provided_poly_sig,\n-                            );\n-\n-                        // Replace the bound items in the fn sig with fresh\n-                        // variables, so that they represent the view from\n-                        // \"inside\" the closure.\n-                        Some(\n-                            self.infcx\n-                                .replace_bound_vars_with_fresh_vars(\n-                                    body.span,\n-                                    LateBoundRegionConversionTime::FnCall,\n-                                    &poly_sig,\n-                                )\n-                                .0,\n-                        )\n-                    }\n+                                LateBoundRegionConversionTime::FnCall,\n+                                &poly_sig,\n+                            )\n+                            .0,\n+                    )\n                 }\n+            }\n         };\n \n         debug!(\n@@ -122,7 +123,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if let Err(terr) = self.eq_opaque_type_and_type(\n             mir_output_ty,\n             normalized_output_ty,\n-            self.mir_def_id,\n+            mir_def_id,\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {\n@@ -145,7 +146,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             if let Err(err) = self.eq_opaque_type_and_type(\n                 mir_output_ty,\n                 user_provided_output_ty,\n-                self.mir_def_id,\n+                mir_def_id,\n                 Locations::All(output_span),\n                 ConstraintCategory::BoringNoLocation,\n             ) {"}, {"sha": "f8a8801595a412342618ca595ba6d284b7c0f830", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -73,7 +73,7 @@ macro_rules! span_mirbug {\n             $context.last_span,\n             &format!(\n                 \"broken MIR in {:?} ({:?}): {}\",\n-                $context.mir_def_id,\n+                $context.body.source.def_id(),\n                 $elem,\n                 format_args!($($message)*),\n             ),\n@@ -113,7 +113,6 @@ mod relate_tys;\n /// - `param_env` -- parameter environment to use for trait solving\n /// - `body` -- MIR body to type-check\n /// - `promoted` -- map of promoted constants within `body`\n-/// - `mir_def_id` -- `LocalDefId` from which the MIR is derived\n /// - `universal_regions` -- the universal regions from `body`s function signature\n /// - `location_table` -- MIR location map of `body`\n /// - `borrow_set` -- information about borrows occurring in `body`\n@@ -126,7 +125,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n-    mir_def_id: LocalDefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n@@ -170,7 +168,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n     let opaque_type_values = type_check_internal(\n         infcx,\n-        mir_def_id,\n         param_env,\n         body,\n         promoted,\n@@ -192,7 +189,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n fn type_check_internal<'a, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    mir_def_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &'a Body<'tcx>,\n     promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n@@ -205,7 +201,6 @@ fn type_check_internal<'a, 'tcx, R>(\n     let mut checker = TypeChecker::new(\n         infcx,\n         body,\n-        mir_def_id,\n         param_env,\n         region_bound_pairs,\n         implicit_region_bound,\n@@ -272,7 +267,6 @@ struct TypeVerifier<'a, 'b, 'tcx> {\n     body: &'b Body<'tcx>,\n     promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     last_span: Span,\n-    mir_def_id: LocalDefId,\n     errors_reported: bool,\n }\n \n@@ -460,14 +454,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         body: &'b Body<'tcx>,\n         promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     ) -> Self {\n-        TypeVerifier {\n-            body,\n-            promoted,\n-            mir_def_id: cx.mir_def_id,\n-            cx,\n-            last_span: body.span,\n-            errors_reported: false,\n-        }\n+        TypeVerifier { body, promoted, cx, last_span: body.span, errors_reported: false }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -816,7 +803,6 @@ struct TypeChecker<'a, 'tcx> {\n     /// User type annotations are shared between the main MIR and the MIR of\n     /// all of the promoted items.\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n-    mir_def_id: LocalDefId,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n@@ -965,7 +951,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn new(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         body: &'a Body<'tcx>,\n-        mir_def_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: ty::Region<'tcx>,\n@@ -975,7 +960,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let mut checker = Self {\n             infcx,\n             last_span: DUMMY_SP,\n-            mir_def_id,\n             body,\n             user_type_annotations: &body.user_type_annotations,\n             param_env,\n@@ -1145,7 +1129,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // the resulting inferend values are stored with the\n                 // def-id of the base function.\n                 let parent_def_id =\n-                    self.tcx().closure_base_def_id(self.mir_def_id.to_def_id()).expect_local();\n+                    self.tcx().closure_base_def_id(self.body.source.def_id()).expect_local();\n                 return self.eq_opaque_type_and_type(sub, sup, parent_def_id, locations, category);\n             } else {\n                 return Err(terr);\n@@ -1242,7 +1226,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let concrete_opaque_types = &tcx.typeck(anon_owner_def_id).concrete_opaque_types;\n         let mut opaque_type_values = Vec::new();\n \n-        debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n+        debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", body.source.def_id());\n         let opaque_type_map = self.fully_perform_op(\n             locations,\n             category,\n@@ -2001,12 +1985,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let span = body.source_info(location).span;\n                         let ty = operand.ty(body, tcx);\n                         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n-                            let ccx = ConstCx::new_with_param_env(\n-                                tcx,\n-                                self.mir_def_id,\n-                                body,\n-                                self.param_env,\n-                            );\n+                            let ccx = ConstCx::new_with_param_env(tcx, body, self.param_env);\n                             // To determine if `const_in_array_repeat_expressions` feature gate should\n                             // be mentioned, need to check if the rvalue is promotable.\n                             let should_suggest =\n@@ -2015,11 +1994,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 );\n                             debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n \n+                            let def_id = body.source.def_id().expect_local();\n                             self.infcx.report_selection_error(\n                                 &traits::Obligation::new(\n                                     ObligationCause::new(\n                                         span,\n-                                        self.tcx().hir().local_def_id_to_hir_id(self.mir_def_id),\n+                                        self.tcx().hir().local_def_id_to_hir_id(def_id),\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,"}, {"sha": "57aa216850aabc3181e064ff1c0111eccf84aee5", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 76, "deletions": 67, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,8 +1,8 @@\n use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, Immediate, InternKind,\n-    InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar,\n+    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, GlobalId, Immediate,\n+    InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking, Scalar,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n \n@@ -14,7 +14,7 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, subst::Subst, TyCtxt};\n use rustc_span::source_map::Span;\n use rustc_target::abi::{Abi, LayoutOf};\n-use std::convert::TryInto;\n+use std::convert::{TryFrom, TryInto};\n \n pub fn note_on_undefined_behavior_error() -> &'static str {\n     \"The rules on what exactly is undefined behavior aren't clear, \\\n@@ -104,6 +104,8 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n     )\n }\n \n+/// This function converts an interpreter value into a constant that is meant for use in the\n+/// type system.\n pub(super) fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: OpTy<'tcx>,\n@@ -146,10 +148,10 @@ pub(super) fn op_to_const<'tcx>(\n         Scalar::Raw { data, .. } => {\n             assert!(mplace.layout.is_zst());\n             assert_eq!(\n-                data,\n-                mplace.layout.align.abi.bytes().into(),\n-                \"this MPlaceTy must come from `try_as_mplace` being used on a zst, so we know what\n-                 value this integer address must have\",\n+                u64::try_from(data).unwrap() % mplace.layout.align.abi.bytes(),\n+                0,\n+                \"this MPlaceTy must come from a validated constant, thus we can assume the \\\n+                alignment is correct\",\n             );\n             ConstValue::Scalar(Scalar::zst())\n         }\n@@ -182,63 +184,37 @@ pub(super) fn op_to_const<'tcx>(\n     }\n }\n \n-fn validate_and_turn_into_const<'tcx>(\n+fn turn_into_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    constant: RawConst<'tcx>,\n+    constant: ConstAlloc<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc_middle::mir::interpret::ConstEvalResult<'tcx> {\n+) -> ConstValue<'tcx> {\n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();\n     let is_static = tcx.is_static(def_id);\n     let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n-    let val = (|| {\n-        let mplace = ecx.raw_const_to_mplace(constant)?;\n \n-        // FIXME do not validate promoteds until a decision on\n-        // https://github.com/rust-lang/rust/issues/67465 is made\n-        if cid.promoted.is_none() {\n-            let mut ref_tracking = RefTracking::new(mplace);\n-            while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-                ecx.const_validate_operand(\n-                    mplace.into(),\n-                    path,\n-                    &mut ref_tracking,\n-                    /*may_ref_to_static*/ ecx.memory.extra.can_access_statics,\n-                )?;\n-            }\n-        }\n-        // Now that we validated, turn this into a proper constant.\n-        // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n-        // whether they become immediates.\n-        if is_static || cid.promoted.is_some() {\n-            let ptr = mplace.ptr.assert_ptr();\n-            Ok(ConstValue::ByRef {\n-                alloc: ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(),\n-                offset: ptr.offset,\n-            })\n-        } else {\n-            Ok(op_to_const(&ecx, mplace.into()))\n-        }\n-    })();\n-\n-    val.map_err(|error| {\n-        let err = ConstEvalErr::new(&ecx, error, None);\n-        err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n-            diag.note(note_on_undefined_behavior_error());\n-            diag.emit();\n-        })\n-    })\n+    let mplace = ecx.raw_const_to_mplace(constant).expect(\n+        \"can only fail if layout computation failed, \\\n+        which should have given a good error before ever invoking this function\",\n+    );\n+    assert!(\n+        !is_static || cid.promoted.is_some(),\n+        \"the `eval_to_const_value_raw` query should not be used for statics, use `eval_to_allocation` instead\"\n+    );\n+    // Turn this into a proper constant.\n+    op_to_const(&ecx, mplace.into())\n }\n \n-pub fn const_eval_validated_provider<'tcx>(\n+pub fn eval_to_const_value_raw_provider<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc_middle::mir::interpret::ConstEvalResult<'tcx> {\n+) -> ::rustc_middle::mir::interpret::EvalToConstValueResult<'tcx> {\n     // see comment in const_eval_raw_provider for what we're doing here\n     if key.param_env.reveal() == Reveal::All {\n         let mut key = key;\n         key.param_env = key.param_env.with_user_facing();\n-        match tcx.const_eval_validated(key) {\n+        match tcx.eval_to_const_value_raw(key) {\n             // try again with reveal all as requested\n             Err(ErrorHandled::TooGeneric) => {}\n             // deduplicate calls\n@@ -261,13 +237,13 @@ pub fn const_eval_validated_provider<'tcx>(\n         });\n     }\n \n-    tcx.const_eval_raw(key).and_then(|val| validate_and_turn_into_const(tcx, val, key))\n+    tcx.eval_to_allocation_raw(key).map(|val| turn_into_const_value(tcx, val, key))\n }\n \n-pub fn const_eval_raw_provider<'tcx>(\n+pub fn eval_to_allocation_raw_provider<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc_middle::mir::interpret::ConstEvalRawResult<'tcx> {\n+) -> ::rustc_middle::mir::interpret::EvalToAllocationRawResult<'tcx> {\n     // Because the constant is computed twice (once per value of `Reveal`), we are at risk of\n     // reporting the same error twice here. To resolve this, we check whether we can evaluate the\n     // constant in the more restrictive `Reveal::UserFacing`, which most likely already was\n@@ -279,7 +255,7 @@ pub fn const_eval_raw_provider<'tcx>(\n     if key.param_env.reveal() == Reveal::All {\n         let mut key = key;\n         key.param_env = key.param_env.with_user_facing();\n-        match tcx.const_eval_raw(key) {\n+        match tcx.eval_to_allocation_raw(key) {\n             // try again with reveal all as requested\n             Err(ErrorHandled::TooGeneric) => {}\n             // deduplicate calls\n@@ -318,9 +294,8 @@ pub fn const_eval_raw_provider<'tcx>(\n     );\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n-    res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body))\n-        .map(|place| RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n-        .map_err(|error| {\n+    match res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body)) {\n+        Err(error) => {\n             let err = ConstEvalErr::new(&ecx, error, None);\n             // errors in statics are always emitted as fatal errors\n             if is_static {\n@@ -342,7 +317,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                     );\n                 }\n \n-                v\n+                Err(v)\n             } else if let Some(def) = def.as_local() {\n                 // constant defined in this crate, we can figure out a lint level!\n                 match tcx.def_kind(def.did.to_def_id()) {\n@@ -356,12 +331,12 @@ pub fn const_eval_raw_provider<'tcx>(\n                     // compatibility hazard\n                     DefKind::Const | DefKind::AssocConst => {\n                         let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-                        err.report_as_lint(\n+                        Err(err.report_as_lint(\n                             tcx.at(tcx.def_span(def.did)),\n                             \"any use of this value will cause an error\",\n                             hir_id,\n                             Some(err.span),\n-                        )\n+                        ))\n                     }\n                     // promoting runtime code is only allowed to error if it references broken\n                     // constants any other kind of error will be reported to the user as a\n@@ -370,31 +345,65 @@ pub fn const_eval_raw_provider<'tcx>(\n                         if let Some(p) = cid.promoted {\n                             let span = tcx.promoted_mir_of_opt_const_arg(def.to_global())[p].span;\n                             if let err_inval!(ReferencedConstant) = err.error {\n-                                err.report_as_error(\n+                                Err(err.report_as_error(\n                                     tcx.at(span),\n                                     \"evaluation of constant expression failed\",\n-                                )\n+                                ))\n                             } else {\n-                                err.report_as_lint(\n+                                Err(err.report_as_lint(\n                                     tcx.at(span),\n                                     \"reaching this expression at runtime will panic or abort\",\n                                     tcx.hir().local_def_id_to_hir_id(def.did),\n                                     Some(err.span),\n-                                )\n+                                ))\n                             }\n                         // anything else (array lengths, enum initializers, constant patterns) are\n                         // reported as hard errors\n                         } else {\n-                            err.report_as_error(\n+                            Err(err.report_as_error(\n                                 ecx.tcx.at(ecx.cur_span()),\n                                 \"evaluation of constant value failed\",\n-                            )\n+                            ))\n                         }\n                     }\n                 }\n             } else {\n                 // use of broken constant from other crate\n-                err.report_as_error(ecx.tcx.at(ecx.cur_span()), \"could not evaluate constant\")\n+                Err(err.report_as_error(ecx.tcx.at(ecx.cur_span()), \"could not evaluate constant\"))\n             }\n-        })\n+        }\n+        Ok(mplace) => {\n+            // Since evaluation had no errors, valiate the resulting constant:\n+            let validation = try {\n+                // FIXME do not validate promoteds until a decision on\n+                // https://github.com/rust-lang/rust/issues/67465 is made\n+                if cid.promoted.is_none() {\n+                    let mut ref_tracking = RefTracking::new(mplace);\n+                    while let Some((mplace, path)) = ref_tracking.todo.pop() {\n+                        ecx.const_validate_operand(\n+                            mplace.into(),\n+                            path,\n+                            &mut ref_tracking,\n+                            /*may_ref_to_static*/ ecx.memory.extra.can_access_statics,\n+                        )?;\n+                    }\n+                }\n+            };\n+            if let Err(error) = validation {\n+                // Validation failed, report an error\n+                let err = ConstEvalErr::new(&ecx, error, None);\n+                Err(err.struct_error(\n+                    ecx.tcx,\n+                    \"it is undefined behavior to use this value\",\n+                    |mut diag| {\n+                        diag.note(note_on_undefined_behavior_error());\n+                        diag.emit();\n+                    },\n+                ))\n+            } else {\n+                // Convert to raw constant\n+                Ok(ConstAlloc { alloc_id: mplace.ptr.assert_ptr().alloc_id, ty: mplace.layout.ty })\n+            }\n+        }\n+    }\n }"}, {"sha": "aca822a05bde93c90148ebfa47a0bab489e5602b", "filename": "compiler/rustc_mir/src/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -50,7 +50,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             None => {\n                 if let Some(stab) = tcx.lookup_stability(def_id) {\n                     if stab.level.is_stable() {\n-                        tcx.sess.span_err(\n+                        tcx.sess.delay_span_bug(\n                             tcx.def_span(def_id),\n                             \"stable const functions must have either `rustc_const_stable` or \\\n                              `rustc_const_unstable` attribute\",\n@@ -151,17 +151,11 @@ fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         }\n }\n \n-fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    is_const_fn(tcx, def_id)\n-        && tcx.lookup_const_stability(def_id).map(|stab| stab.allow_const_fn_ptr).unwrap_or(false)\n-}\n-\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         is_const_fn_raw,\n         is_const_impl_raw: |tcx, def_id| is_const_impl_raw(tcx, def_id.expect_local()),\n         is_promotable_const_fn,\n-        const_fn_is_allowed_fn_ptr,\n         ..*providers\n     };\n }"}, {"sha": "73ca7e0d471ca21dadabef1a32b06eec0c8415f4", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::Mutability;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::AssertMessage;\n use rustc_session::Limit;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{sym, Symbol};\n \n use crate::interpret::{\n     self, compile_time_machine, AllocId, Allocation, Frame, GlobalId, ImmTy, InterpCx,\n@@ -51,7 +51,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n \n         let gid = GlobalId { instance, promoted: None };\n \n-        let place = self.const_eval_raw(gid)?;\n+        let place = self.eval_to_allocation(gid)?;\n \n         self.copy_op(place.into(), dest)?;\n \n@@ -176,6 +176,38 @@ impl interpret::MayLeak for ! {\n     }\n }\n \n+impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n+    fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> bool {\n+        match (a, b) {\n+            // Comparisons between integers are always known.\n+            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a == b,\n+            // Equality with integers can never be known for sure.\n+            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            // FIXME: return `true` for when both sides are the same pointer, *except* that\n+            // some things (like functions and vtables) do not have stable addresses\n+            // so we need to be careful around them (see e.g. #73722).\n+            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+        }\n+    }\n+\n+    fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> bool {\n+        match (a, b) {\n+            // Comparisons between integers are always known.\n+            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a != b,\n+            // Comparisons of abstract pointers with null pointers are known if the pointer\n+            // is in bounds, because if they are in bounds, the pointer can't be null.\n+            (Scalar::Raw { data: 0, .. }, Scalar::Ptr(ptr))\n+            | (Scalar::Ptr(ptr), Scalar::Raw { data: 0, .. }) => !self.memory.ptr_may_be_null(ptr),\n+            // Inequality with integers other than null can never be known for sure.\n+            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            // FIXME: return `true` for at least some comparisons where we can reliably\n+            // determine the result of runtime inequality tests at compile-time.\n+            // Examples include comparison of addresses in different static items.\n+            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+        }\n+    }\n+}\n+\n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n     compile_time_machine!(<'mir, 'tcx>);\n \n@@ -234,12 +266,45 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n+        // Shared intrinsics.\n         if ecx.emulate_intrinsic(instance, args, ret)? {\n             return Ok(());\n         }\n-        // An intrinsic that we do not support\n         let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n-        Err(ConstEvalErrKind::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n+\n+        // CTFE-specific intrinsics.\n+        let (dest, ret) = match ret {\n+            None => {\n+                return Err(ConstEvalErrKind::NeedsRfc(format!(\n+                    \"calling intrinsic `{}`\",\n+                    intrinsic_name\n+                ))\n+                .into());\n+            }\n+            Some(p) => p,\n+        };\n+        match intrinsic_name {\n+            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+                let a = ecx.read_immediate(args[0])?.to_scalar()?;\n+                let b = ecx.read_immediate(args[1])?.to_scalar()?;\n+                let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n+                    ecx.guaranteed_eq(a, b)\n+                } else {\n+                    ecx.guaranteed_ne(a, b)\n+                };\n+                ecx.write_scalar(Scalar::from_bool(cmp), dest)?;\n+            }\n+            _ => {\n+                return Err(ConstEvalErrKind::NeedsRfc(format!(\n+                    \"calling intrinsic `{}`\",\n+                    intrinsic_name\n+                ))\n+                .into());\n+            }\n+        }\n+\n+        ecx.go_to_block(ret);\n+        Ok(())\n     }\n \n     fn assert_panic("}, {"sha": "978d2fe000468bc81535b66543a42eb1a3b50da2", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -2,11 +2,14 @@\n \n use std::convert::TryFrom;\n \n+use rustc_hir::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n \n-use crate::interpret::{intern_const_alloc_recursive, ConstValue, InternKind, InterpCx};\n+use crate::interpret::{\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, MemPlaceMeta, Scalar,\n+};\n \n mod error;\n mod eval_queries;\n@@ -67,3 +70,39 @@ pub(crate) fn destructure_const<'tcx>(\n \n     mir::DestructuredConst { variant, fields }\n }\n+\n+pub(crate) fn deref_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    val: &'tcx ty::Const<'tcx>,\n+) -> &'tcx ty::Const<'tcx> {\n+    trace!(\"deref_const: {:?}\", val);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n+    let op = ecx.const_to_op(val, None).unwrap();\n+    let mplace = ecx.deref_operand(op).unwrap();\n+    if let Scalar::Ptr(ptr) = mplace.ptr {\n+        assert_eq!(\n+            ecx.memory.get_raw(ptr.alloc_id).unwrap().mutability,\n+            Mutability::Not,\n+            \"deref_const cannot be used with mutable allocations as \\\n+            that could allow pattern matching to observe mutable statics\",\n+        );\n+    }\n+\n+    let ty = match mplace.meta {\n+        MemPlaceMeta::None => mplace.layout.ty,\n+        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n+        // In case of unsized types, figure out the real type behind.\n+        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n+            ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n+            ty::Slice(elem_ty) => tcx.mk_array(elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n+            _ => bug!(\n+                \"type {} should not have metadata, but had {:?}\",\n+                mplace.layout.ty,\n+                mplace.meta\n+            ),\n+        },\n+    };\n+\n+    tcx.mk_const(ty::Const { val: ty::ConstKind::Value(op_to_const(&ecx, mplace.into())), ty })\n+}"}, {"sha": "4942bed656cc6b251e756e71e1871cd1686db926", "filename": "compiler/rustc_mir/src/dataflow/framework/cursor.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -4,6 +4,7 @@ use std::borrow::Borrow;\n use std::cmp::Ordering;\n \n use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, BasicBlock, Location};\n \n use super::{Analysis, Direction, Effect, EffectIndex, Results};\n@@ -26,7 +27,7 @@ where\n {\n     body: &'mir mir::Body<'tcx>,\n     results: R,\n-    state: BitSet<A::Idx>,\n+    state: A::Domain,\n \n     pos: CursorPosition,\n \n@@ -46,17 +47,16 @@ where\n {\n     /// Returns a new cursor that can inspect `results`.\n     pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n-        let bits_per_block = results.borrow().entry_set_for_block(mir::START_BLOCK).domain_size();\n-\n+        let bottom_value = results.borrow().analysis.bottom_value(body);\n         ResultsCursor {\n             body,\n             results,\n \n-            // Initialize to an empty `BitSet` and set `state_needs_reset` to tell the cursor that\n+            // Initialize to the `bottom_value` and set `state_needs_reset` to tell the cursor that\n             // it needs to reset to block entry before the first seek. The cursor position is\n             // immaterial.\n             state_needs_reset: true,\n-            state: BitSet::new_empty(bits_per_block),\n+            state: bottom_value,\n             pos: CursorPosition::block_entry(mir::START_BLOCK),\n \n             #[cfg(debug_assertions)]\n@@ -68,23 +68,21 @@ where\n         self.body\n     }\n \n-    /// Returns the `Analysis` used to generate the underlying results.\n+    /// Returns the underlying `Results`.\n+    pub fn results(&self) -> &Results<'tcx, A> {\n+        &self.results.borrow()\n+    }\n+\n+    /// Returns the `Analysis` used to generate the underlying `Results`.\n     pub fn analysis(&self) -> &A {\n         &self.results.borrow().analysis\n     }\n \n     /// Returns the dataflow state at the current location.\n-    pub fn get(&self) -> &BitSet<A::Idx> {\n+    pub fn get(&self) -> &A::Domain {\n         &self.state\n     }\n \n-    /// Returns `true` if the dataflow state at the current location contains the given element.\n-    ///\n-    /// Shorthand for `self.get().contains(elem)`\n-    pub fn contains(&self, elem: A::Idx) -> bool {\n-        self.state.contains(elem)\n-    }\n-\n     /// Resets the cursor to hold the entry set for the given basic block.\n     ///\n     /// For forward dataflow analyses, this is the dataflow state prior to the first statement.\n@@ -94,7 +92,7 @@ where\n         #[cfg(debug_assertions)]\n         assert!(self.reachable_blocks.contains(block));\n \n-        self.state.overwrite(&self.results.borrow().entry_set_for_block(block));\n+        self.state.clone_from(&self.results.borrow().entry_set_for_block(block));\n         self.pos = CursorPosition::block_entry(block);\n         self.state_needs_reset = false;\n     }\n@@ -202,12 +200,23 @@ where\n     ///\n     /// This can be used, e.g., to apply the call return effect directly to the cursor without\n     /// creating an extra copy of the dataflow state.\n-    pub fn apply_custom_effect(&mut self, f: impl FnOnce(&A, &mut BitSet<A::Idx>)) {\n+    pub fn apply_custom_effect(&mut self, f: impl FnOnce(&A, &mut A::Domain)) {\n         f(&self.results.borrow().analysis, &mut self.state);\n         self.state_needs_reset = true;\n     }\n }\n \n+impl<'mir, 'tcx, A, R, T> ResultsCursor<'mir, 'tcx, A, R>\n+where\n+    A: Analysis<'tcx, Domain = BitSet<T>>,\n+    T: Idx,\n+    R: Borrow<Results<'tcx, A>>,\n+{\n+    pub fn contains(&self, elem: T) -> bool {\n+        self.get().contains(elem)\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug)]\n struct CursorPosition {\n     block: BasicBlock,"}, {"sha": "ca2bb6e0bf7e91582c7157ee81c295ead9098779", "filename": "compiler/rustc_mir/src/dataflow/framework/direction.rs", "status": "modified", "additions": 80, "deletions": 90, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f", "patch": "@@ -1,10 +1,10 @@\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Location};\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use std::ops::RangeInclusive;\n \n use super::visitor::{ResultsVisitable, ResultsVisitor};\n-use super::{Analysis, Effect, EffectIndex, GenKillAnalysis, GenKillSet};\n+use super::{Analysis, Effect, EffectIndex, GenKillAnalysis, GenKillSet, SwitchIntTarget};\n \n pub trait Direction {\n     fn is_forward() -> bool;\n@@ -18,7 +18,7 @@ pub trait Direction {\n     /// `effects.start()` must precede or equal `effects.end()` in this direction.\n     fn apply_effects_in_range<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n         effects: RangeInclusive<EffectIndex>,\n@@ -27,7 +27,7 @@ pub trait Direction {\n \n     fn apply_effects_in_block<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n     ) where\n@@ -55,9 +55,9 @@ pub trait Direction {\n         tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n-        exit_state: &mut BitSet<A::Idx>,\n+        exit_state: &mut A::Domain,\n         block: (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n-        propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+        propagate: impl FnMut(BasicBlock, &A::Domain),\n     ) where\n         A: Analysis<'tcx>;\n }\n@@ -72,7 +72,7 @@ impl Direction for Backward {\n \n     fn apply_effects_in_block<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n     ) where\n@@ -112,7 +112,7 @@ impl Direction for Backward {\n \n     fn apply_effects_in_range<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n         effects: RangeInclusive<EffectIndex>,\n@@ -224,9 +224,9 @@ impl Direction for Backward {\n         _tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n-        exit_state: &mut BitSet<A::Idx>,\n+        exit_state: &mut A::Domain,\n         (bb, _bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n-        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+        mut propagate: impl FnMut(BasicBlock, &A::Domain),\n     ) where\n         A: Analysis<'tcx>,\n     {\n@@ -281,7 +281,7 @@ impl Direction for Forward {\n \n     fn apply_effects_in_block<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n     ) where\n@@ -321,7 +321,7 @@ impl Direction for Forward {\n \n     fn apply_effects_in_range<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n         effects: RangeInclusive<EffectIndex>,\n@@ -425,12 +425,12 @@ impl Direction for Forward {\n \n     fn join_state_into_successors_of<A>(\n         analysis: &A,\n-        tcx: TyCtxt<'tcx>,\n-        body: &mir::Body<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n+        _body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n-        exit_state: &mut BitSet<A::Idx>,\n+        exit_state: &mut A::Domain,\n         (bb, bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n-        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+        mut propagate: impl FnMut(BasicBlock, &A::Domain),\n     ) where\n         A: Analysis<'tcx>,\n     {\n@@ -489,88 +489,78 @@ impl Direction for Forward {\n             }\n \n             SwitchInt { ref targets, ref values, ref discr, switch_ty: _ } => {\n-                let enum_ = discr\n-                    .place()\n-                    .and_then(|discr| switch_on_enum_discriminant(tcx, &body, bb_data, discr));\n-                match enum_ {\n-                    // If this is a switch on an enum discriminant, a custom effect may be applied\n-                    // along each outgoing edge.\n-                    Some((enum_place, enum_def)) => {\n-                        // MIR building adds discriminants to the `values` array in the same order as they\n-                        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n-                        // discriminant in `values` to its corresponding variant in linear time.\n-                        let mut tmp = BitSet::new_empty(exit_state.domain_size());\n-                        let mut discriminants = enum_def.discriminants(tcx);\n-                        for (value, target) in values.iter().zip(targets.iter().copied()) {\n-                            let (variant_idx, _) =\n-                                discriminants.find(|&(_, discr)| discr.val == *value).expect(\n-                                    \"Order of `AdtDef::discriminants` differed \\\n-                                         from that of `SwitchInt::values`\",\n-                                );\n-\n-                            tmp.overwrite(exit_state);\n-                            analysis.apply_discriminant_switch_effect(\n-                                &mut tmp,\n-                                bb,\n-                                enum_place,\n-                                enum_def,\n-                                variant_idx,\n-                            );\n-                            propagate(target, &tmp);\n-                        }\n-\n-                        // Move out of `tmp` so we don't accidentally use it below.\n-                        std::mem::drop(tmp);\n-\n-                        // Propagate dataflow state along the \"otherwise\" edge.\n-                        let otherwise = targets.last().copied().unwrap();\n-                        propagate(otherwise, exit_state)\n-                    }\n-\n-                    // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n-                    // exit state.\n-                    None => {\n-                        for target in targets.iter().copied() {\n-                            propagate(target, exit_state);\n-                        }\n+                let mut applier = SwitchIntEdgeEffectApplier {\n+                    exit_state,\n+                    targets: targets.as_ref(),\n+                    values: values.as_ref(),\n+                    propagate,\n+                    effects_applied: false,\n+                };\n+\n+                analysis.apply_switch_int_edge_effects(bb, discr, &mut applier);\n+\n+                let SwitchIntEdgeEffectApplier {\n+                    exit_state, mut propagate, effects_applied, ..\n+                } = applier;\n+\n+                if !effects_applied {\n+                    for &target in targets.iter() {\n+                        propagate(target, exit_state);\n                     }\n                 }\n             }\n         }\n     }\n }\n \n-/// Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is\n-/// an enum discriminant.\n-///\n-/// We expect such blocks to have a call to `discriminant` as their last statement like so:\n-///   _42 = discriminant(_1)\n-///   SwitchInt(_42, ..)\n-///\n-/// If the basic block matches this pattern, this function returns the place corresponding to the\n-/// enum (`_1` in the example above) as well as the `AdtDef` of that enum.\n-fn switch_on_enum_discriminant(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'mir mir::Body<'tcx>,\n-    block: &'mir mir::BasicBlockData<'tcx>,\n-    switch_on: mir::Place<'tcx>,\n-) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n-    match block.statements.last().map(|stmt| &stmt.kind) {\n-        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n-            if *lhs == switch_on =>\n-        {\n-            match &discriminated.ty(body, tcx).ty.kind() {\n-                ty::Adt(def, _) => Some((*discriminated, def)),\n-\n-                // `Rvalue::Discriminant` is also used to get the active yield point for a\n-                // generator, but we do not need edge-specific effects in that case. This may\n-                // change in the future.\n-                ty::Generator(..) => None,\n-\n-                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n-            }\n+struct SwitchIntEdgeEffectApplier<'a, D, F> {\n+    exit_state: &'a mut D,\n+    values: &'a [u128],\n+    targets: &'a [BasicBlock],\n+    propagate: F,\n+\n+    effects_applied: bool,\n+}\n+\n+impl<D, F> super::SwitchIntEdgeEffects<D> for SwitchIntEdgeEffectApplier<'_, D, F>\n+where\n+    D: Clone,\n+    F: FnMut(BasicBlock, &D),\n+{\n+    fn apply(&mut self, mut apply_edge_effect: impl FnMut(&mut D, SwitchIntTarget)) {\n+        assert!(!self.effects_applied);\n+\n+        let mut tmp = None;\n+        for (&value, &target) in self.values.iter().zip(self.targets.iter()) {\n+            let tmp = opt_clone_from_or_clone(&mut tmp, self.exit_state);\n+            apply_edge_effect(tmp, SwitchIntTarget { value: Some(value), target });\n+            (self.propagate)(target, tmp);\n         }\n \n-        _ => None,\n+        // Once we get to the final, \"otherwise\" branch, there is no need to preserve `exit_state`,\n+        // so pass it directly to `apply_edge_effect` to save a clone of the dataflow state.\n+        let otherwise = self.targets.last().copied().unwrap();\n+        apply_edge_effect(self.exit_state, SwitchIntTarget { value: None, target: otherwise });\n+        (self.propagate)(otherwise, self.exit_state);\n+\n+        self.effects_applied = true;\n+    }\n+}\n+\n+/// An analogue of `Option::get_or_insert_with` that stores a clone of `val` into `opt`, but uses\n+/// the more efficient `clone_from` if `opt` was `Some`.\n+///\n+/// Returns a mutable reference to the new clone that resides in `opt`.\n+//\n+// FIXME: Figure out how to express this using `Option::clone_from`, or maybe lift it into the\n+// standard library?\n+fn opt_clone_from_or_clone<T: Clone>(opt: &'a mut Option<T>, val: &T) -> &'a mut T {\n+    if opt.is_some() {\n+        let ret = opt.as_mut().unwrap();\n+        ret.clone_from(val);\n+        ret\n+    } else {\n+        *opt = Some(val.clone());\n+        opt.as_mut().unwrap()\n     }\n }"}, {"sha": "b836e85c3a7e09a1518cba1837a0acf911965234", "filename": "compiler/rustc_mir/src/dataflow/framework/engine.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "0140a750544334f0053b097dfc193db55d1f65c8", "filename": "compiler/rustc_mir/src/dataflow/framework/fmt.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ffmt.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "4e54257a1cb2d96128db3314699f36cd11513a96", "filename": "compiler/rustc_mir/src/dataflow/framework/graphviz.rs", "status": "modified", "additions": 237, "deletions": 333, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "e7ef9267db5e5ed9e74a12f5ad849f86ae239a76", "filename": "compiler/rustc_mir/src/dataflow/framework/lattice.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "524ad0af1a7b45d4c85de9b6404deeca35bc6730", "filename": "compiler/rustc_mir/src/dataflow/framework/mod.rs", "status": "modified", "additions": 105, "deletions": 114, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "a5989121679c4fa8fb2014cd9910581e30520a48", "filename": "compiler/rustc_mir/src/dataflow/framework/tests.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ftests.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "82eb734ed0699a2ae00f18635b59c9414cf552a3", "filename": "compiler/rustc_mir/src/dataflow/framework/visitor.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fvisitor.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "65e04ed6831cc4499d32a04d535200ca78183bd0", "filename": "compiler/rustc_mir/src/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "0be13b6ba81daf48116dd366af6a7480c1614800", "filename": "compiler/rustc_mir/src/dataflow/impls/borrows.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "bb7292cd0337aae3c3f590dc3b9abf5f288d6907", "filename": "compiler/rustc_mir/src/dataflow/impls/init_locals.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Finit_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Finit_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Finit_locals.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "b0da28156d1a49e3e1fe4a53f18d37eb1c15dc10", "filename": "compiler/rustc_mir/src/dataflow/impls/liveness.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fliveness.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "185f0edfeb6bcbeaf6aab1f17c8fb43104510b2d", "filename": "compiler/rustc_mir/src/dataflow/impls/mod.rs", "status": "modified", "additions": 154, "deletions": 84, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "9250cd408479aec0c0891fd16fc9125a1cecab7d", "filename": "compiler/rustc_mir/src/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "5575a97982fc4e34bebb5d9db48e1754b7f208bd", "filename": "compiler/rustc_mir/src/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "ab7fadac91e39f892fa5abbd15dd9ae8e784ec3a", "filename": "compiler/rustc_mir/src/dataflow/move_paths/builder.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "7c630259186032e245999763c8184d41b68214ce", "filename": "compiler/rustc_mir/src/dataflow/move_paths/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "93da6e3d38a93c71df5a1491dda6cf2eae02b893", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 62, "deletions": 60, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "d3b6d706337edb90e445a67486b06fdef60f2453", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 42, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "554ada1ab254cfe0969fe763650f2b6975ee4aa6", "filename": "compiler/rustc_mir/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "f3e373813ca537c3e40bcccb63b2410f254bcea1", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "735f890a33bdc495eadff14f607780900b216877", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "72551b23370dd3f2124a32a08426b825110d4c07", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "9f200ca62b8c606c6ae2d62980c8b41ffe985506", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "2b83e1c8134efe75508140c3e04fa7f4e4002c13", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}, {"sha": "c00c6860903c8d73e01224a3677c9b4cef809915", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af74f6ddf9102b358f271b371697c4b4e6dd2f/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=44af74f6ddf9102b358f271b371697c4b4e6dd2f"}]}