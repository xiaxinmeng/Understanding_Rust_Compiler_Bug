{"sha": "37ebd47ddb1398c7b0f19aeb888417fbcf2d5992", "node_id": "C_kwDOAAsO6NoAKDM3ZWJkNDdkZGIxMzk4YzdiMGYxOWFlYjg4ODQxN2ZiY2YyZDU5OTI", "commit": {"author": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2022-03-26T01:11:49Z"}, "committer": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2022-03-26T12:01:51Z"}, "message": "Address review comments\n\n* Add lazily computed `switch_sources` data structure\n* Don't assume a target has only one associated value", "tree": {"sha": "1f53942b70d5523b4dc8c9c4b2225989c9601e90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f53942b70d5523b4dc8c9c4b2225989c9601e90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992", "html_url": "https://github.com/rust-lang/rust/commit/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee7413b94cd0f953518ad73f37cac28feb6e8d52", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7413b94cd0f953518ad73f37cac28feb6e8d52", "html_url": "https://github.com/rust-lang/rust/commit/ee7413b94cd0f953518ad73f37cac28feb6e8d52"}], "stats": {"total": 113, "additions": 106, "deletions": 7}, "files": [{"sha": "455387901b61db60f27301a6e97a03a64950c760", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=37ebd47ddb1398c7b0f19aeb888417fbcf2d5992", "patch": "@@ -45,6 +45,7 @@ use std::{iter, mem, option};\n use self::graph_cyclic_cache::GraphIsCyclicCache;\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n+use self::switch_sources::{SwitchSourceCache, SwitchSources};\n \n pub mod coverage;\n mod generic_graph;\n@@ -58,6 +59,7 @@ mod predecessors;\n pub mod pretty;\n mod query;\n pub mod spanview;\n+mod switch_sources;\n pub mod tcx;\n pub mod terminator;\n pub use terminator::*;\n@@ -284,6 +286,7 @@ pub struct Body<'tcx> {\n     pub is_polymorphic: bool,\n \n     predecessor_cache: PredecessorCache,\n+    switch_source_cache: SwitchSourceCache,\n     is_cyclic: GraphIsCyclicCache,\n \n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n@@ -332,6 +335,7 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n+            switch_source_cache: SwitchSourceCache::new(),\n             is_cyclic: GraphIsCyclicCache::new(),\n             tainted_by_errors,\n         };\n@@ -360,6 +364,7 @@ impl<'tcx> Body<'tcx> {\n             var_debug_info: Vec::new(),\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n+            switch_source_cache: SwitchSourceCache::new(),\n             is_cyclic: GraphIsCyclicCache::new(),\n             tainted_by_errors: None,\n         };\n@@ -380,6 +385,7 @@ impl<'tcx> Body<'tcx> {\n         // FIXME: Use a finer-grained API for this, so only transformations that alter terminators\n         // invalidate the caches.\n         self.predecessor_cache.invalidate();\n+        self.switch_source_cache.invalidate();\n         self.is_cyclic.invalidate();\n         &mut self.basic_blocks\n     }\n@@ -389,6 +395,7 @@ impl<'tcx> Body<'tcx> {\n         &mut self,\n     ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n         self.predecessor_cache.invalidate();\n+        self.switch_source_cache.invalidate();\n         self.is_cyclic.invalidate();\n         (&mut self.basic_blocks, &mut self.local_decls)\n     }\n@@ -402,6 +409,7 @@ impl<'tcx> Body<'tcx> {\n         &mut Vec<VarDebugInfo<'tcx>>,\n     ) {\n         self.predecessor_cache.invalidate();\n+        self.switch_source_cache.invalidate();\n         self.is_cyclic.invalidate();\n         (&mut self.basic_blocks, &mut self.local_decls, &mut self.var_debug_info)\n     }\n@@ -529,6 +537,11 @@ impl<'tcx> Body<'tcx> {\n         self.predecessor_cache.compute(&self.basic_blocks)\n     }\n \n+    #[inline]\n+    pub fn switch_sources(&self) -> &SwitchSources {\n+        self.switch_source_cache.compute(&self.basic_blocks)\n+    }\n+\n     #[inline]\n     pub fn dominators(&self) -> Dominators<BasicBlock> {\n         dominators(self)"}, {"sha": "7f62b4d0dbab947efe98704f35f870ba18f96feb", "filename": "compiler/rustc_middle/src/mir/switch_sources.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs?ref=37ebd47ddb1398c7b0f19aeb888417fbcf2d5992", "patch": "@@ -0,0 +1,82 @@\n+//! Lazily compute the inverse of each `SwitchInt`'s switch targets. Modeled after\n+//! `Predecessors`/`PredecessorCache`.\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::OnceCell;\n+use rustc_index::vec::IndexVec;\n+use rustc_serialize as serialize;\n+use smallvec::SmallVec;\n+\n+use crate::mir::{BasicBlock, BasicBlockData, Terminator, TerminatorKind};\n+\n+pub type SwitchSources = IndexVec<BasicBlock, IndexVec<BasicBlock, SmallVec<[Option<u128>; 1]>>>;\n+\n+#[derive(Clone, Debug)]\n+pub(super) struct SwitchSourceCache {\n+    cache: OnceCell<SwitchSources>,\n+}\n+\n+impl SwitchSourceCache {\n+    #[inline]\n+    pub(super) fn new() -> Self {\n+        SwitchSourceCache { cache: OnceCell::new() }\n+    }\n+\n+    /// Invalidates the switch source cache.\n+    #[inline]\n+    pub(super) fn invalidate(&mut self) {\n+        self.cache = OnceCell::new();\n+    }\n+\n+    /// Returns the switch sources for this MIR.\n+    #[inline]\n+    pub(super) fn compute(\n+        &self,\n+        basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n+    ) -> &SwitchSources {\n+        self.cache.get_or_init(|| {\n+            let mut switch_sources = IndexVec::from_elem(\n+                IndexVec::from_elem(SmallVec::new(), basic_blocks),\n+                basic_blocks,\n+            );\n+            for (bb, data) in basic_blocks.iter_enumerated() {\n+                if let Some(Terminator {\n+                    kind: TerminatorKind::SwitchInt { targets, .. }, ..\n+                }) = &data.terminator\n+                {\n+                    for (value, target) in targets.iter() {\n+                        switch_sources[target][bb].push(Some(value));\n+                    }\n+                    switch_sources[targets.otherwise()][bb].push(None);\n+                }\n+            }\n+\n+            switch_sources\n+        })\n+    }\n+}\n+\n+impl<S: serialize::Encoder> serialize::Encodable<S> for SwitchSourceCache {\n+    #[inline]\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_unit()\n+    }\n+}\n+\n+impl<D: serialize::Decoder> serialize::Decodable<D> for SwitchSourceCache {\n+    #[inline]\n+    fn decode(_: &mut D) -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for SwitchSourceCache {\n+    #[inline]\n+    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n+        // do nothing\n+    }\n+}\n+\n+TrivialTypeFoldableAndLiftImpls! {\n+    SwitchSourceCache,\n+}"}, {"sha": "d7f531f7de7dd11a160c5d36adfdd3b9459dfc7a", "filename": "compiler/rustc_mir_dataflow/src/framework/direction.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ebd47ddb1398c7b0f19aeb888417fbcf2d5992/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs?ref=37ebd47ddb1398c7b0f19aeb888417fbcf2d5992", "patch": "@@ -267,11 +267,11 @@ impl Direction for Backward {\n                     propagate(pred, &tmp);\n                 }\n \n-                mir::TerminatorKind::SwitchInt { ref targets, ref discr, switch_ty: _ } => {\n+                mir::TerminatorKind::SwitchInt { targets: _, ref discr, switch_ty: _ } => {\n                     let mut applier = BackwardSwitchIntEdgeEffectsApplier {\n                         pred,\n                         exit_state,\n-                        targets,\n+                        values: &body.switch_sources()[bb][pred],\n                         bb,\n                         propagate: &mut propagate,\n                         effects_applied: false,\n@@ -309,7 +309,7 @@ impl Direction for Backward {\n struct BackwardSwitchIntEdgeEffectsApplier<'a, D, F> {\n     pred: BasicBlock,\n     exit_state: &'a mut D,\n-    targets: &'a SwitchTargets,\n+    values: &'a [Option<u128>],\n     bb: BasicBlock,\n     propagate: &'a mut F,\n \n@@ -324,10 +324,14 @@ where\n     fn apply(&mut self, mut apply_edge_effect: impl FnMut(&mut D, SwitchIntTarget)) {\n         assert!(!self.effects_applied);\n \n-        let value =\n-            self.targets.iter().find_map(|(value, target)| (target == self.bb).then_some(value));\n-        apply_edge_effect(self.exit_state, SwitchIntTarget { value, target: self.bb });\n-        (self.propagate)(self.pred, self.exit_state);\n+        let targets = self.values.iter().map(|&value| SwitchIntTarget { value, target: self.bb });\n+\n+        let mut tmp = None;\n+        for target in targets {\n+            let tmp = opt_clone_from_or_clone(&mut tmp, self.exit_state);\n+            apply_edge_effect(tmp, target);\n+            (self.propagate)(self.pred, tmp);\n+        }\n \n         self.effects_applied = true;\n     }"}]}