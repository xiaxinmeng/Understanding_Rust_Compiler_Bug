{"sha": "73bca2b9fa9399751e432734f7f12bd6a37fc167", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYmNhMmI5ZmE5Mzk5NzUxZTQzMjczNGY3ZjEyYmQ2YTM3ZmMxNjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-28T20:40:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-28T20:40:51Z"}, "message": "Auto merge of #46094 - dtolnay:is_null, r=alexcrichton\n\nRemove `T: Sized` on `ptr::is_null()`\n\nOriginally from #44932 -- this is purely a revert of the last commit of that PR, which was removing some changes from the previous commits in the PR. So a revert of a revert means this is code written by @cuviper!\n\n@mikeyhew makes a compelling case in https://github.com/rust-lang/rfcs/issues/433#issuecomment-345495505 for why this is the right way to implement `is_null` for trait objects. And the behavior for slices makes sense to me as well.\n\n```diff\n  impl<T: ?Sized> *const T {\n-     pub fn is_null(self) -> bool where T: Sized;\n+     pub fn is_null(self) -> bool;\n  }\n\n  impl<T: ?Sized> *mut T {\n-     pub fn is_null(self) -> bool where T: Sized;\n+     pub fn is_null(self) -> bool;\n  }", "tree": {"sha": "6629bc4f07a160bf15548781b88a4971c28b1bf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6629bc4f07a160bf15548781b88a4971c28b1bf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73bca2b9fa9399751e432734f7f12bd6a37fc167", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73bca2b9fa9399751e432734f7f12bd6a37fc167", "html_url": "https://github.com/rust-lang/rust/commit/73bca2b9fa9399751e432734f7f12bd6a37fc167", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73bca2b9fa9399751e432734f7f12bd6a37fc167/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71340ca4e181b824bcefa887f1be60dd0b7352ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/71340ca4e181b824bcefa887f1be60dd0b7352ce", "html_url": "https://github.com/rust-lang/rust/commit/71340ca4e181b824bcefa887f1be60dd0b7352ce"}, {"sha": "e0f58c6a11c7990a302b47c488dc2f13fab7b9a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f58c6a11c7990a302b47c488dc2f13fab7b9a1", "html_url": "https://github.com/rust-lang/rust/commit/e0f58c6a11c7990a302b47c488dc2f13fab7b9a1"}], "stats": {"total": 70, "additions": 55, "deletions": 15}, "files": [{"sha": "ec277b4ae99c7241792911251bee22bf846b237b", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73bca2b9fa9399751e432734f7f12bd6a37fc167/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73bca2b9fa9399751e432734f7f12bd6a37fc167/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=73bca2b9fa9399751e432734f7f12bd6a37fc167", "patch": "@@ -28,8 +28,7 @@ macro_rules! impl_zeroable_for_pointer_types {\n             unsafe impl<T: ?Sized> Zeroable for $Ptr {\n                 #[inline]\n                 fn is_zero(&self) -> bool {\n-                    // Cast because `is_null` is only available on thin pointers\n-                    (*self as *mut u8).is_null()\n+                    (*self).is_null()\n                 }\n             }\n         )+"}, {"sha": "19553d0c37b83d1d9ac93005fc03fb82558ef94d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/73bca2b9fa9399751e432734f7f12bd6a37fc167/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73bca2b9fa9399751e432734f7f12bd6a37fc167/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=73bca2b9fa9399751e432734f7f12bd6a37fc167", "patch": "@@ -474,6 +474,11 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n impl<T: ?Sized> *const T {\n     /// Returns `true` if the pointer is null.\n     ///\n+    /// Note that unsized types have many possible null pointers, as only the\n+    /// raw data pointer is considered, not their length, vtable, etc.\n+    /// Therefore, two pointers that are null may still not compare equal to\n+    /// each other.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -485,8 +490,10 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_null(self) -> bool where T: Sized {\n-        self == null()\n+    pub fn is_null(self) -> bool {\n+        // Compare via a cast to a thin pointer, so fat pointers are only\n+        // considering their \"data\" part for null-ness.\n+        (self as *const u8) == null()\n     }\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -518,9 +525,7 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        // Check for null via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        if (self as *const u8).is_null() {\n+        if self.is_null() {\n             None\n         } else {\n             Some(&*self)\n@@ -1107,6 +1112,11 @@ impl<T: ?Sized> *const T {\n impl<T: ?Sized> *mut T {\n     /// Returns `true` if the pointer is null.\n     ///\n+    /// Note that unsized types have many possible null pointers, as only the\n+    /// raw data pointer is considered, not their length, vtable, etc.\n+    /// Therefore, two pointers that are null may still not compare equal to\n+    /// each other.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1118,8 +1128,10 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_null(self) -> bool where T: Sized {\n-        self == null_mut()\n+    pub fn is_null(self) -> bool {\n+        // Compare via a cast to a thin pointer, so fat pointers are only\n+        // considering their \"data\" part for null-ness.\n+        (self as *mut u8) == null_mut()\n     }\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -1151,9 +1163,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        // Check for null via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        if (self as *const u8).is_null() {\n+        if self.is_null() {\n             None\n         } else {\n             Some(&*self)\n@@ -1277,9 +1287,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n-        // Check for null via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        if (self as *mut u8).is_null() {\n+        if self.is_null() {\n             None\n         } else {\n             Some(&mut *self)"}, {"sha": "98436f0e1d1cd968d613e70acfe8995c8b8a5257", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/73bca2b9fa9399751e432734f7f12bd6a37fc167/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73bca2b9fa9399751e432734f7f12bd6a37fc167/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=73bca2b9fa9399751e432734f7f12bd6a37fc167", "patch": "@@ -62,6 +62,39 @@ fn test_is_null() {\n \n     let mq = unsafe { mp.offset(1) };\n     assert!(!mq.is_null());\n+\n+    // Pointers to unsized types -- slices\n+    let s: &mut [u8] = &mut [1, 2, 3];\n+    let cs: *const [u8] = s;\n+    assert!(!cs.is_null());\n+\n+    let ms: *mut [u8] = s;\n+    assert!(!ms.is_null());\n+\n+    let cz: *const [u8] = &[];\n+    assert!(!cz.is_null());\n+\n+    let mz: *mut [u8] = &mut [];\n+    assert!(!mz.is_null());\n+\n+    let ncs: *const [u8] = null::<[u8; 3]>();\n+    assert!(ncs.is_null());\n+\n+    let nms: *mut [u8] = null_mut::<[u8; 3]>();\n+    assert!(nms.is_null());\n+\n+    // Pointers to unsized types -- trait objects\n+    let ci: *const ToString = &3;\n+    assert!(!ci.is_null());\n+\n+    let mi: *mut ToString = &mut 3;\n+    assert!(!mi.is_null());\n+\n+    let nci: *const ToString = null::<isize>();\n+    assert!(nci.is_null());\n+\n+    let nmi: *mut ToString = null_mut::<isize>();\n+    assert!(nmi.is_null());\n }\n \n #[test]"}]}