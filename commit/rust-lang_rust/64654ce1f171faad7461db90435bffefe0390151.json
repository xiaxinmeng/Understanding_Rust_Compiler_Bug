{"sha": "64654ce1f171faad7461db90435bffefe0390151", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NjU0Y2UxZjE3MWZhYWQ3NDYxZGI5MDQzNWJmZmVmZTAzOTAxNTE=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-11-21T15:50:52Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-12-02T13:42:24Z"}, "message": "Fix type errors created during rebasing", "tree": {"sha": "5dfde746d1b0388b22c97c187507a015ef495ffc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dfde746d1b0388b22c97c187507a015ef495ffc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64654ce1f171faad7461db90435bffefe0390151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64654ce1f171faad7461db90435bffefe0390151", "html_url": "https://github.com/rust-lang/rust/commit/64654ce1f171faad7461db90435bffefe0390151", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64654ce1f171faad7461db90435bffefe0390151/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "598797c6e76c041b449a838d09f1c829b0adc437", "url": "https://api.github.com/repos/rust-lang/rust/commits/598797c6e76c041b449a838d09f1c829b0adc437", "html_url": "https://github.com/rust-lang/rust/commit/598797c6e76c041b449a838d09f1c829b0adc437"}], "stats": {"total": 137, "additions": 67, "deletions": 70}, "files": [{"sha": "f61b7e74d340b010ad604d507e73aff1386023e4", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=64654ce1f171faad7461db90435bffefe0390151", "patch": "@@ -114,7 +114,7 @@ impl Cache {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, TypeFoldable)]\n pub struct BodyCache<'tcx> {\n     cache: Cache,\n     body: Body<'tcx>,\n@@ -302,10 +302,3 @@ impl_stable_hash_for!(struct BodyCache<'tcx> {\n     cache,\n     body,\n });\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for BodyCache<'tcx> {\n-        cache,\n-        body\n-    }\n-}"}, {"sha": "3fcc6e9e176b98e7375a2e77b3d2191903305834", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=64654ce1f171faad7461db90435bffefe0390151", "patch": "@@ -220,7 +220,7 @@ fn type_check_internal<'a, 'tcx, R>(\n \n     if !errors_reported {\n         // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(&body);\n+        checker.typeck_mir(body);\n     }\n \n     extra(&mut checker)\n@@ -588,7 +588,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         if !self.errors_reported {\n             // if verifier failed, don't do further checks to avoid ICEs\n-            self.cx.typeck_mir(&promoted_body);\n+            self.cx.typeck_mir(promoted_body);\n         }\n \n         self.body = parent_body;\n@@ -1374,7 +1374,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n+    fn check_stmt(&mut self, body: ReadOnlyBodyCache<'_, 'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n@@ -1406,9 +1406,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(body, tcx).ty;\n+                let place_ty = place.ty(body.body(), tcx).ty;\n                 let place_ty = self.normalize(place_ty, location);\n-                let rv_ty = rv.ty(body, tcx);\n+                let rv_ty = rv.ty(body.body(), tcx);\n                 let rv_ty = self.normalize(rv_ty, location);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1460,7 +1460,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 ref place,\n                 variant_index,\n             } => {\n-                let place_type = place.ty(body, tcx).ty;\n+                let place_type = place.ty(body.body(), tcx).ty;\n                 let adt = match place_type.kind {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1482,7 +1482,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(box(ref place, ref projection), variance) => {\n-                let place_ty = place.ty(body, tcx).ty;\n+                let place_ty = place.ty(body.body(), tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -1985,20 +1985,20 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn check_rvalue(&mut self, body: &Body<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+    fn check_rvalue(&mut self, body: ReadOnlyBodyCache<'_, 'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         let tcx = self.tcx();\n \n         match rvalue {\n             Rvalue::Aggregate(ak, ops) => {\n-                self.check_aggregate_rvalue(body, rvalue, ak, ops, location)\n+                self.check_aggregate_rvalue(&body, rvalue, ak, ops, location)\n             }\n \n             Rvalue::Repeat(operand, len) => if *len > 1 {\n                 if let Operand::Move(_) = operand {\n                     // While this is located in `nll::typeck` this error is not an NLL error, it's\n                     // a required check to make sure that repeated elements implement `Copy`.\n                     let span = body.source_info(location).span;\n-                    let ty = operand.ty(body, tcx);\n+                    let ty = operand.ty(body.body(), tcx);\n                     if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                         // To determine if `const_in_array_repeat_expressions` feature gate should\n                         // be mentioned, need to check if the rvalue is promotable.\n@@ -2052,7 +2052,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::Cast(cast_kind, op, ty) => {\n                 match cast_kind {\n                     CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(body.body(), tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2081,7 +2081,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(body, tcx).kind {\n+                        let sig = match op.ty(body.body(), tcx).kind {\n                             ty::Closure(def_id, substs) => {\n                                 substs.as_closure().sig_ty(def_id, tcx).fn_sig(tcx)\n                             }\n@@ -2107,7 +2107,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::UnsafeFnPointer) => {\n-                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(body.body(), tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2139,7 +2139,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let &ty = ty;\n                         let trait_ref = ty::TraitRef {\n                             def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(op.ty(body, tcx), &[ty.into()]),\n+                            substs: tcx.mk_substs_trait(op.ty(body.body(), tcx), &[ty.into()]),\n                         };\n \n                         self.prove_trait_ref(\n@@ -2150,7 +2150,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(body, tcx).kind {\n+                        let ty_from = match op.ty(body.body(), tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::Mutability::Mutable,\n@@ -2198,7 +2198,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ArrayToPointer)  => {\n-                        let ty_from = op.ty(body, tcx);\n+                        let ty_from = op.ty(body.body(), tcx);\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(\n@@ -2260,7 +2260,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Misc => {\n-                        let ty_from = op.ty(body, tcx);\n+                        let ty_from = op.ty(body.body(), tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n@@ -2318,7 +2318,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n-                self.add_reborrow_constraint(body, location, region, borrowed_place);\n+                self.add_reborrow_constraint(&body, location, region, borrowed_place);\n             }\n \n             Rvalue::BinaryOp(BinOp::Eq, left, right)\n@@ -2327,9 +2327,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | Rvalue::BinaryOp(BinOp::Le, left, right)\n             | Rvalue::BinaryOp(BinOp::Gt, left, right)\n             | Rvalue::BinaryOp(BinOp::Ge, left, right) => {\n-                let ty_left = left.ty(body, tcx);\n+                let ty_left = left.ty(body.body(), tcx);\n                 if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.kind {\n-                    let ty_right = right.ty(body, tcx);\n+                    let ty_right = right.ty(body.body(), tcx);\n                     let common_ty = self.infcx.next_ty_var(\n                         TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::MiscVariable,\n@@ -2754,12 +2754,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self, body: &Body<'tcx>) {\n+    fn typeck_mir(&mut self, body: ReadOnlyBodyCache<'_, 'tcx>) {\n         self.last_span = body.span;\n         debug!(\"run_on_mir: {:?}\", body.span);\n \n         for (local, local_decl) in body.local_decls.iter_enumerated() {\n-            self.check_local(body, local, local_decl);\n+            self.check_local(&body, local, local_decl);\n         }\n \n         for (block, block_data) in body.basic_blocks().iter_enumerated() {\n@@ -2775,8 +2775,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 location.statement_index += 1;\n             }\n \n-            self.check_terminator(body, block_data.terminator(), location);\n-            self.check_iscleanup(body, block_data);\n+            self.check_terminator(&body, block_data.terminator(), location);\n+            self.check_iscleanup(&body, block_data);\n         }\n     }\n "}, {"sha": "7095b3fa0aa83d88e7e78704ceaced6b29e86d04", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=64654ce1f171faad7461db90435bffefe0390151", "patch": "@@ -20,7 +20,7 @@ pub mod validation;\n /// Information about the item currently being const-checked, as well as a reference to the global\n /// context.\n pub struct Item<'mir, 'tcx> {\n-    pub body: &'mir mir::Body<'tcx>,\n+    pub body: mir::ReadOnlyBodyCache<'mir, 'tcx>,\n     pub tcx: TyCtxt<'tcx>,\n     pub def_id: DefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -31,7 +31,7 @@ impl Item<'mir, 'tcx> {\n     pub fn new(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        body: &'mir mir::Body<'tcx>,\n+        body: mir::ReadOnlyBodyCache<'mir, 'tcx>,\n     ) -> Self {\n         let param_env = tcx.param_env(def_id);\n         let const_kind = ConstKind::for_item(tcx, def_id);"}, {"sha": "718988b26d8a55dfcd79ebbbf7f9f498408b57f9", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=64654ce1f171faad7461db90435bffefe0390151", "patch": "@@ -51,7 +51,7 @@ pub trait Qualif {\n             });\n             let qualif = base_qualif && Self::in_any_value_of_ty(\n                 cx,\n-                Place::ty_from(place.base, proj_base, cx.body, cx.tcx)\n+                Place::ty_from(place.base, proj_base, cx.body.body(), cx.tcx)\n                     .projection_ty(cx.tcx, elem)\n                     .ty,\n             );\n@@ -155,7 +155,7 @@ pub trait Qualif {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n                     if ProjectionElem::Deref == elem {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body.body(), cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, per_local, PlaceRef {\n                                 base: &place.base,\n@@ -221,7 +221,7 @@ impl Qualif for HasMutInterior {\n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(cx.body, cx.tcx);\n+                        let ty = rvalue.ty(cx.body.body(), cx.tcx);\n                         assert_eq!(Self::in_any_value_of_ty(cx, ty), true);\n                         return true;\n                     }"}, {"sha": "7db649e6ba0acff9877600fac31bb34c8ace34d9", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=64654ce1f171faad7461db90435bffefe0390151", "patch": "@@ -77,7 +77,7 @@ where\n         args: &[mir::Operand<'tcx>],\n         return_place: &mir::Place<'tcx>,\n     ) {\n-        let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n+        let return_ty = return_place.ty(self.item.body.body(), self.item.tcx).ty;\n         let qualif = Q::in_call(\n             self.item,\n             &|l| self.qualifs_per_local.contains(l),"}, {"sha": "63b100dc86dc1745a6a63683a08125986c9e62bf", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=64654ce1f171faad7461db90435bffefe0390151", "patch": "@@ -39,9 +39,9 @@ impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n     ) -> Self {\n         let analysis = FlowSensitiveAnalysis::new(q, item);\n         let results =\n-            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n+            dataflow::Engine::new(item.tcx, &item.body, item.def_id, dead_unwinds, analysis)\n                 .iterate_to_fixpoint();\n-        let cursor = dataflow::ResultsCursor::new(item.body, results);\n+        let cursor = dataflow::ResultsCursor::new(item.body.body(), results);\n \n         let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n         for (local, decl) in item.body.local_decls.iter_enumerated() {\n@@ -172,17 +172,17 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         let indirectly_mutable = old_dataflow::do_dataflow(\n             item.tcx,\n-            item.body,\n+            item.body.body(),\n             item.def_id,\n             &item.tcx.get_attrs(item.def_id),\n             &dead_unwinds,\n-            old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n+            old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body.body(), item.param_env),\n             |_, local| old_dataflow::DebugFormatted::new(&local),\n         );\n \n         let indirectly_mutable = old_dataflow::DataflowResultsCursor::new(\n             indirectly_mutable,\n-            item.body,\n+            item.body.body(),\n         );\n \n         let qualifs = Qualifs {\n@@ -208,7 +208,7 @@ impl Validator<'a, 'mir, 'tcx> {\n         if use_min_const_fn_checks {\n             // Enforce `min_const_fn` for stable `const fn`s.\n             use crate::transform::qualify_min_const_fn::is_min_const_fn;\n-            if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n+            if let Err((span, err)) = is_min_const_fn(tcx, def_id, &body) {\n                 error_min_const_fn_violation(tcx, span, err);\n                 return;\n             }\n@@ -230,7 +230,7 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         if should_check_for_sync {\n             let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-            check_return_ty_is_sync(tcx, body, hir_id);\n+            check_return_ty_is_sync(tcx, &body, hir_id);\n         }\n     }\n \n@@ -304,7 +304,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         // Special-case reborrows to be more like a copy of a reference.\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body, place) {\n+            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body.body(), place) {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -390,7 +390,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n+                let operand_ty = operand.ty(self.body.body(), self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n \n@@ -401,7 +401,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body.body(), self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -475,7 +475,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, self.body.body(), self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n                         if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n@@ -499,7 +499,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             ProjectionElem::Subslice {..} |\n             ProjectionElem::Field(..) |\n             ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, self.body.body(), self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -548,7 +548,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match kind {\n             TerminatorKind::Call { func, .. } => {\n-                let fn_ty = func.ty(self.body, self.tcx);\n+                let fn_ty = func.ty(self.body.body(), self.tcx);\n \n                 let def_id = match fn_ty.kind {\n                     ty::FnDef(def_id, _) => def_id,\n@@ -609,7 +609,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // Check to see if the type of this place can ever have a drop impl. If not, this\n                 // `Drop` terminator is frivolous.\n                 let ty_needs_drop = dropped_place\n-                    .ty(self.body, self.tcx)\n+                    .ty(self.body.body(), self.tcx)\n                     .ty\n                     .needs_drop(self.tcx, self.param_env);\n "}, {"sha": "3273588ec1a5fd9fb2081c7ac282752d04d32896", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=64654ce1f171faad7461db90435bffefe0390151", "patch": "@@ -205,7 +205,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n     }\n \n     let item = check_consts::Item {\n-        body,\n+        body: body.unwrap_read_only(),\n         tcx,\n         def_id,\n         const_kind,"}, {"sha": "1a2eeb9025b9429a98edc2d8baa3df1df6e7f405", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64654ce1f171faad7461db90435bffefe0390151/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=64654ce1f171faad7461db90435bffefe0390151", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n         let mut rpo = traversal::reverse_postorder(body);\n         let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n \n-        let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n+        let promotable_candidates = validate_candidates(tcx, read_only, def_id, &temps, &all_candidates);\n \n         let promoted = promote_candidates(def_id, body, tcx, temps, promotable_candidates);\n         self.promoted_fragments.set(promoted);\n@@ -346,10 +346,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             while let [proj_base @ .., elem] = place_projection {\n                                 // FIXME(eddyb) this is probably excessive, with\n                                 // the exception of `union` member accesses.\n-                                let ty =\n-                                    Place::ty_from(&place.base, proj_base, self.body, self.tcx)\n-                                        .projection_ty(self.tcx, elem)\n-                                        .ty;\n+                                let ty = Place::ty_from(\n+                                        &place.base,\n+                                        proj_base,\n+                                        self.body.body(),\n+                                        self.tcx\n+                                    )\n+                                    .projection_ty(self.tcx, elem)\n+                                    .ty;\n                                 if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n                                     has_mut_interior = false;\n                                     break;\n@@ -368,7 +372,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         }\n \n                         if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(self.body, self.tcx).ty;\n+                            let ty = place.ty(self.body.body(), self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n@@ -517,7 +521,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.base, proj_base, self.body, self.tcx).ty;\n+                                Place::ty_from(place.base, proj_base, self.body.body(), self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -566,7 +570,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n+                let operand_ty = operand.ty(self.body.body(), self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -580,7 +584,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body.body(), self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -615,7 +619,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             Rvalue::Ref(_, kind, place) => {\n                 if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(self.body, self.tcx).ty;\n+                    let ty = place.ty(self.body.body(), self.tcx).ty;\n \n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -642,7 +646,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n                     let base_ty =\n-                        Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+                        Place::ty_from(&place.base, proj_base, self.body.body(), self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         place = PlaceRef {\n                             base: &place.base,\n@@ -668,7 +672,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.base, proj_base, self.body, self.tcx)\n+                        let ty = Place::ty_from(place.base, proj_base, self.body.body(), self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -701,7 +705,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n     ) -> Result<(), Unpromotable> {\n-        let fn_ty = callee.ty(self.body, self.tcx);\n+        let fn_ty = callee.ty(self.body.body(), self.tcx);\n \n         if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n@@ -737,7 +741,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n // FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n     tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     def_id: DefId,\n     temps: &IndexVec<Local, TempState>,\n     candidates: &[Candidate],\n@@ -1146,11 +1150,11 @@ pub fn promote_candidates<'tcx>(\n crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mir_def_id: DefId,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> bool {\n-    let mut rpo = traversal::reverse_postorder(body);\n-    let (temps, _) = collect_temps_and_candidates(tcx, body, &mut rpo);\n+    let mut rpo = traversal::reverse_postorder(&body);\n+    let (temps, _) = collect_temps_and_candidates(tcx, &body, &mut rpo);\n     let validator = Validator {\n         item: Item::new(tcx, mir_def_id, body),\n         temps: &temps,"}]}