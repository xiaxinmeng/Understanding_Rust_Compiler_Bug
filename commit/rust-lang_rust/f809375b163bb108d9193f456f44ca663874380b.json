{"sha": "f809375b163bb108d9193f456f44ca663874380b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MDkzNzViMTYzYmIxMDhkOTE5M2Y0NTZmNDRjYTY2Mzg3NDM4MGI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-25T00:55:45Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-25T00:56:01Z"}, "message": "Sketch out type-directed structural drop and copy, including vector types.", "tree": {"sha": "a69731ced25908781c280ef893c073d534edea9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a69731ced25908781c280ef893c073d534edea9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f809375b163bb108d9193f456f44ca663874380b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f809375b163bb108d9193f456f44ca663874380b", "html_url": "https://github.com/rust-lang/rust/commit/f809375b163bb108d9193f456f44ca663874380b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f809375b163bb108d9193f456f44ca663874380b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96540ef0bb649f4bd5c90ff2b524e763b3b5db85", "url": "https://api.github.com/repos/rust-lang/rust/commits/96540ef0bb649f4bd5c90ff2b524e763b3b5db85", "html_url": "https://github.com/rust-lang/rust/commit/96540ef0bb649f4bd5c90ff2b524e763b3b5db85"}], "stats": {"total": 265, "additions": 237, "deletions": 28}, "files": [{"sha": "0db40e89e81166ff989cf0bf39ff37fb6493cec6", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f809375b163bb108d9193f456f44ca663874380b/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f809375b163bb108d9193f456f44ca663874380b/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=f809375b163bb108d9193f456f44ca663874380b", "patch": "@@ -1019,6 +1019,16 @@ obj builder(BuilderRef B) {\n         ret phi;\n     }\n \n+    fn AddIncomingToPhi(ValueRef phi,\n+                        vec[ValueRef] vals,\n+                        vec[BasicBlockRef] bbs) {\n+        check (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n+        llvm.LLVMAddIncoming(phi,\n+                             _vec.buf[ValueRef](vals),\n+                             _vec.buf[BasicBlockRef](bbs),\n+                             _vec.len[ValueRef](vals));\n+    }\n+\n     fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n         ret llvm.LLVMBuildCall(B, Fn,\n                                _vec.buf[ValueRef](Args),"}, {"sha": "6f0e6a63242abfb372e325880eaa52f3cd07da78", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 196, "deletions": 28, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/f809375b163bb108d9193f456f44ca663874380b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f809375b163bb108d9193f456f44ca663874380b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f809375b163bb108d9193f456f44ca663874380b", "patch": "@@ -479,38 +479,202 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n     ret res(next_cx, phi);\n }\n \n-fn type_is_scalar(@ast.ty t) -> bool {\n-    alt (t.node) {\n-        case (ast.ty_nil) { ret true; }\n-        case (ast.ty_bool) { ret true; }\n-        case (ast.ty_int) { ret true; }\n-        case (ast.ty_uint) { ret true; }\n-        case (ast.ty_machine(_)) { ret true; }\n-        case (ast.ty_char) { ret true; }\n+type val_and_ty_fn =\n+    fn(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result;\n+\n+// Iterates through the elements of a tup, rec or tag.\n+fn iter_structural_ty(@block_ctxt cx,\n+                      ValueRef v,\n+                      @typeck.ty t,\n+                      val_and_ty_fn f)\n+    -> result {\n+    let result r = res(cx, C_nil());\n+    alt (t.struct) {\n+        case (typeck.ty_tup(?args)) {\n+            let int i = 0;\n+            for (tup(bool, @typeck.ty) arg in args) {\n+                auto elt = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n+                r = f(r.bcx, elt, arg._1);\n+                i += 1;\n+            }\n+        }\n+        // FIXME: handle records and tags when we support them.\n     }\n-    ret false;\n+    ret r;\n }\n \n-fn trans_copy_ty(@block_ctxt cx,\n-                 bool is_init,\n-                 ValueRef dst,\n-                 ValueRef src,\n-                 @ast.ty t) -> result {\n-    if (type_is_scalar(t)) {\n-        ret res(cx, cx.build.Store(src, dst));\n+// Iterates through the elements of a vec or str.\n+fn iter_sequence(@block_ctxt cx,\n+                 ValueRef v,\n+                 @typeck.ty ty,\n+                 val_and_ty_fn f) -> result {\n+\n+    fn iter_sequence_body(@block_ctxt cx,\n+                          ValueRef v,\n+                          @typeck.ty elt_ty,\n+                          val_and_ty_fn f,\n+                          bool trailing_null) -> result {\n+\n+        auto p0 = cx.build.GEP(v, vec(C_int(0),\n+                                      C_int(abi.vec_elt_data)));\n+        auto lenptr = cx.build.GEP(v, vec(C_int(0),\n+                                          C_int(abi.vec_elt_fill)));\n+        auto len = cx.build.Load(lenptr);\n+        if (trailing_null) {\n+            len = cx.build.Sub(len, C_int(1));\n+        }\n+\n+        auto r = res(cx, C_nil());\n+\n+        auto cond_cx = new_sub_block_ctxt(cx, \"sequence-iter cond\");\n+        auto body_cx = new_sub_block_ctxt(cx, \"sequence-iter body\");\n+        auto next_cx = new_sub_block_ctxt(cx, \"next\");\n+\n+        auto ix = cond_cx.build.Phi(T_int(), vec(C_int(0)), vec(cx.llbb));\n+        auto end_test = cond_cx.build.ICmp(lib.llvm.LLVMIntEQ, ix, len);\n+        cond_cx.build.CondBr(end_test, body_cx.llbb, next_cx.llbb);\n+\n+        auto elt = body_cx.build.GEP(p0, vec(ix));\n+        auto body_res = f(body_cx, elt, elt_ty);\n+        auto next_ix = body_res.bcx.build.Add(ix, C_int(1));\n+        cond_cx.build.AddIncomingToPhi(ix, vec(next_ix),\n+                                       vec(body_res.bcx.llbb));\n+\n+        body_res.bcx.build.Br(cond_cx.llbb);\n+        ret res(next_cx, C_nil());\n+    }\n+\n+    alt (ty.struct) {\n+        case (typeck.ty_vec(?et)) {\n+            ret iter_sequence_body(cx, v, et, f, false);\n+        }\n+        case (typeck.ty_str) {\n+            auto et = typeck.plain_ty(typeck.ty_machine(common.ty_u8));\n+            ret iter_sequence_body(cx, v, et, f, false);\n+        }\n     }\n+    cx.fcx.ccx.sess.bug(\"bad type in trans.iter_sequence\");\n+    fail;\n+}\n+\n+fn incr_all_refcnts(@block_ctxt cx,\n+                    ValueRef v,\n+                    @typeck.ty t) -> result {\n \n-    alt (t.node) {\n-        case (ast.ty_str) {\n-            let result r = res(cx, C_nil());\n-            if (is_init) {\n-                r = trans_drop_str(cx, dst);\n+    if (typeck.type_is_boxed(t)) {\n+        ret incr_refcnt(cx, v);\n+\n+    } else if (typeck.type_is_binding(t)) {\n+        cx.fcx.ccx.sess.unimpl(\"binding type in trans.incr_all_refcnts\");\n+\n+    } else if (typeck.type_is_structural(t)) {\n+        ret iter_structural_ty(cx, v, t,\n+                               bind incr_all_refcnts(_, _, _));\n+    }\n+}\n+\n+fn drop_ty(@block_ctxt cx,\n+           ValueRef v,\n+           @typeck.ty t) -> result {\n+\n+    alt (t.struct) {\n+        case (typeck.ty_str) {\n+            ret decr_refcnt_and_if_zero(cx, v,\n+                                        bind trans_non_gc_free(_, v),\n+                                        \"free string\",\n+                                        T_int(), C_int(0));\n+        }\n+\n+        case (typeck.ty_vec(_)) {\n+            fn hit_zero(@block_ctxt cx, ValueRef v,\n+                        @typeck.ty t) -> result {\n+                auto res = iter_sequence(cx, v, t, bind drop_ty(_,_,_));\n+                // FIXME: switch gc/non-gc on stratum of the type.\n+                ret trans_non_gc_free(res.bcx, v);\n+            }\n+            ret decr_refcnt_and_if_zero(cx, v,\n+                                        bind hit_zero(_, v, t),\n+                                        \"free vector\",\n+                                        T_int(), C_int(0));\n+        }\n+\n+        case (typeck.ty_box(_)) {\n+            fn hit_zero(@block_ctxt cx, ValueRef v,\n+                        @typeck.ty elt_ty) -> result {\n+                auto res = drop_ty(cx,\n+                                   cx.build.GEP(v, vec(C_int(0))),\n+                                   elt_ty);\n+                // FIXME: switch gc/non-gc on stratum of the type.\n+                ret trans_non_gc_free(res.bcx, v);\n+            }\n+            ret incr_refcnt(cx, v);\n+        }\n+\n+        case (_) {\n+            if (typeck.type_is_structural(t)) {\n+                ret iter_structural_ty(cx, v, t,\n+                                       bind drop_ty(_, _, _));\n+\n+            } else if (typeck.type_is_binding(t)) {\n+                cx.fcx.ccx.sess.unimpl(\"binding type in trans.drop_ty\");\n+\n+            } else if (typeck.type_is_scalar(t) ||\n+                       typeck.type_is_nil(t)) {\n+                ret res(cx, C_nil());\n             }\n-            r = incr_refcnt(r.bcx, src);\n-            ret res(r.bcx, r.bcx.build.Store(src, dst));\n         }\n     }\n-    cx.fcx.ccx.sess.unimpl(\"ty variant in trans_copy_ty\");\n+    cx.fcx.ccx.sess.bug(\"bad type in trans.drop_ty\");\n+    fail;\n+}\n+\n+fn build_memcpy(@block_ctxt cx,\n+                ValueRef dst,\n+                ValueRef src,\n+                TypeRef llty) -> result {\n+    auto memcpy = cx.fcx.ccx.fn_names.get(\"llvm.memcpy\");\n+    auto src_ptr = cx.build.PointerCast(src, T_ptr(T_i8()));\n+    auto dst_ptr = cx.build.PointerCast(dst, T_ptr(T_i8()));\n+    auto size = lib.llvm.llvm.LLVMSizeOf(llty);\n+    auto align = lib.llvm.llvm.LLVMAlignOf(llty);\n+    auto volatile = C_integral(0, T_i1());\n+    ret res(cx, cx.build.Call(memcpy,\n+                              vec(dst_ptr, src_ptr,\n+                                  size, align, volatile)));\n+}\n+\n+fn copy_ty(@block_ctxt cx,\n+           bool is_init,\n+           ValueRef dst,\n+           ValueRef src,\n+           @typeck.ty t) -> result {\n+    if (typeck.type_is_scalar(t)) {\n+        ret res(cx, cx.build.Store(src, dst));\n+\n+    } else if (typeck.type_is_nil(t)) {\n+        ret res(cx, C_nil());\n+\n+    } else if (typeck.type_is_binding(t)) {\n+        cx.fcx.ccx.sess.unimpl(\"binding type in trans.copy_ty\");\n+\n+    } else if (typeck.type_is_boxed(t)) {\n+        auto r = incr_refcnt(cx, src);\n+        if (! is_init) {\n+            r = drop_ty(r.bcx, dst, t);\n+        }\n+        ret res(r.bcx, r.bcx.build.Store(src, dst));\n+\n+    } else if (typeck.type_is_structural(t)) {\n+        auto r = incr_all_refcnts(cx, src, t);\n+        if (! is_init) {\n+            r = drop_ty(r.bcx, dst, t);\n+        }\n+        auto llty = type_of(cx.fcx.ccx, t);\n+        r = build_memcpy(r.bcx, dst, src, llty);\n+    }\n+\n+    cx.fcx.ccx.sess.bug(\"unexpected type in trans.copy_ty: \" +\n+                        typeck.ty_to_str(t));\n     fail;\n }\n \n@@ -1023,13 +1187,12 @@ impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n             }\n         }\n \n-        case (ast.expr_assign(?dst, ?src, _)) {\n+        case (ast.expr_assign(?dst, ?src, ?ann)) {\n             auto lhs_res = trans_lval(cx, *dst);\n             check (lhs_res._1);\n             auto rhs_res = trans_expr(lhs_res._0.bcx, *src);\n-            // FIXME: call trans_copy_ty once we have a ty here.\n-            ret res(rhs_res.bcx,\n-                    rhs_res.bcx.build.Store(rhs_res.val, lhs_res._0.val));\n+            auto t = node_ann_type(cx.fcx.ccx, ann);\n+            ret copy_ty(rhs_res.bcx, true, lhs_res._0.val, rhs_res.val, t);\n         }\n \n         case (ast.expr_call(?f, ?args, _)) {\n@@ -1451,7 +1614,12 @@ fn trans_main_fn(@crate_ctxt cx, ValueRef llcrate) {\n \n fn declare_intrinsics(ModuleRef llmod) {\n     let vec[TypeRef] T_trap_args = vec();\n+    // FIXME: switch this to 64-bit memcpy when targeting a 64-bit system.\n+    let vec[TypeRef] T_memcpy_args = vec(T_ptr(T_i8()),\n+                                         T_ptr(T_i8()),\n+                                         T_i32(), T_i32(), T_i1());\n     decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args, T_void()));\n+    decl_cdecl_fn(llmod, \"llvm.memcpy\", T_fn(T_memcpy_args, T_void()));\n }\n \n fn trans_crate(session.session sess, @ast.crate crate, str output) {"}, {"sha": "530bdc0617ff830dd10de849dfeaa83b34e8bd25", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f809375b163bb108d9193f456f44ca663874380b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f809375b163bb108d9193f456f44ca663874380b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f809375b163bb108d9193f456f44ca663874380b", "patch": "@@ -412,6 +412,37 @@ fn mode_is_alias(ast.mode m) -> bool {\n     }\n }\n \n+fn type_is_nil(@ty t) -> bool {\n+    alt (t.struct) {\n+        case (ty_nil) { ret true; }\n+    }\n+    ret false;\n+}\n+\n+fn type_is_structural(@ty t) -> bool {\n+    alt (t.struct) {\n+        // FIXME: cover rec and tag when we support them.\n+        case (ty_tup(_)) { ret true; }\n+    }\n+    ret false;\n+}\n+\n+fn type_is_binding(@ty t) -> bool {\n+    alt (t.struct) {\n+        // FIXME: cover obj when we support it.\n+        case (ty_fn(_,_)) { ret true; }\n+    }\n+    ret false;\n+}\n+\n+fn type_is_boxed(@ty t) -> bool {\n+    alt (t.struct) {\n+        case (ty_str) { ret true; }\n+        case (ty_vec(_)) { ret true; }\n+    }\n+    ret false;\n+}\n+\n fn type_is_scalar(@ty t) -> bool {\n     alt (t.struct) {\n         case (ty_bool) { ret true; }"}]}