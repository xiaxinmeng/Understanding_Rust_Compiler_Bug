{"sha": "08f9f134fd9d790c99ffab590fee264bd062f599", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZjlmMTM0ZmQ5ZDc5MGM5OWZmYWI1OTBmZWUyNjRiZDA2MmY1OTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-17T20:37:18Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:31Z"}, "message": "rustc: hide details in Layout in favor of Abi or FieldPlacement.", "tree": {"sha": "bcb18d472f2f48fd772e6edfb3daa3199f6583b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcb18d472f2f48fd772e6edfb3daa3199f6583b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08f9f134fd9d790c99ffab590fee264bd062f599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08f9f134fd9d790c99ffab590fee264bd062f599", "html_url": "https://github.com/rust-lang/rust/commit/08f9f134fd9d790c99ffab590fee264bd062f599", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08f9f134fd9d790c99ffab590fee264bd062f599/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed788a62f62db010f3e92ec4756728151af368a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed788a62f62db010f3e92ec4756728151af368a2", "html_url": "https://github.com/rust-lang/rust/commit/ed788a62f62db010f3e92ec4756728151af368a2"}], "stats": {"total": 837, "additions": 353, "deletions": 484}, "files": [{"sha": "13d3ec68a31b37f3e5a3c54fe30aaed14fe32403", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 273, "deletions": 345, "changes": 618, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -627,27 +627,27 @@ impl<'a, 'tcx> Primitive {\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct Struct {\n     /// Maximum alignment of fields and repr alignment.\n-    pub align: Align,\n+    align: Align,\n \n     /// Primitive alignment of fields without repr alignment.\n-    pub primitive_align: Align,\n+    primitive_align: Align,\n \n     /// If true, no alignment padding is used.\n-    pub packed: bool,\n+    packed: bool,\n \n     /// If true, the size is exact, otherwise it's only a lower bound.\n-    pub sized: bool,\n+    sized: bool,\n \n     /// Offsets for the first byte of each field, ordered to match the source definition order.\n     /// This vector does not go in increasing order.\n     /// FIXME(eddyb) use small vector optimization for the common case.\n-    pub offsets: Vec<Size>,\n+    offsets: Vec<Size>,\n \n     /// Maps source order field indices to memory order indices, depending how fields were permuted.\n     /// FIXME (camlorn) also consider small vector  optimization here.\n     pub memory_index: Vec<u32>,\n \n-    pub min_size: Size,\n+    min_size: Size,\n }\n \n /// Info required to optimize struct layout.\n@@ -799,7 +799,7 @@ impl<'a, 'tcx> Struct {\n     }\n \n     /// Get the size with trailing alignment padding.\n-    pub fn stride(&self) -> Size {\n+    fn stride(&self) -> Size {\n         self.min_size.abi_align(self.align)\n     }\n \n@@ -837,30 +837,30 @@ impl<'a, 'tcx> Struct {\n                               layout: FullLayout<'tcx>)\n                               -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>> {\n         let cx = (tcx, param_env);\n-        match (layout.layout, &layout.ty.sty) {\n-            (&Scalar(Pointer), _) if !layout.ty.is_unsafe_ptr() => {\n+        match (layout.layout, layout.abi, &layout.ty.sty) {\n+            (&Scalar, Abi::Scalar(Pointer), _) if !layout.ty.is_unsafe_ptr() => {\n                 Ok(Some((Size::from_bytes(0), Pointer)))\n             }\n-            (&General { discr, .. }, &ty::TyAdt(def, _)) => {\n+            (&General { discr, .. }, _, &ty::TyAdt(def, _)) => {\n                 if def.discriminants(tcx).all(|d| d.to_u128_unchecked() != 0) {\n                     Ok(Some((layout.fields.offset(0), discr)))\n                 } else {\n                     Ok(None)\n                 }\n             }\n \n-            (&FatPointer(_), _) if !layout.ty.is_unsafe_ptr() => {\n+            (&FatPointer, _, _) if !layout.ty.is_unsafe_ptr() => {\n                 Ok(Some((layout.fields.offset(FAT_PTR_ADDR), Pointer)))\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n-            (_, &ty::TyAdt(def, _)) if Some(def.did) == tcx.lang_items().non_zero() => {\n+            (_, _, &ty::TyAdt(def, _)) if Some(def.did) == tcx.lang_items().non_zero() => {\n                 let field = layout.field(cx, 0)?;\n-                match *field.layout {\n-                    Scalar(value) => {\n+                match (field.layout, field.abi) {\n+                    (&Scalar, Abi::Scalar(value)) => {\n                         Ok(Some((layout.fields.offset(0), value)))\n                     }\n-                    FatPointer(_) => {\n+                    (&FatPointer, _) => {\n                         Ok(Some((layout.fields.offset(0) +\n                                  field.fields.offset(FAT_PTR_ADDR),\n                                  Pointer)))\n@@ -870,7 +870,7 @@ impl<'a, 'tcx> Struct {\n             }\n \n             // Perhaps one of the fields is non-zero, let's recurse and find out.\n-            (&Univariant(ref variant), _) => {\n+            (&Univariant(ref variant), _, _) => {\n                 variant.non_zero_field(\n                     tcx,\n                     param_env,\n@@ -879,7 +879,7 @@ impl<'a, 'tcx> Struct {\n \n             // Is this a fixed-size array of something non-zero\n             // with at least one element?\n-            (_, &ty::TyArray(ety, mut count)) => {\n+            (_, _, &ty::TyArray(ety, mut count)) => {\n                 if count.has_projections() {\n                     count = tcx.normalize_associated_type_in_env(&count, param_env);\n                     if count.has_projections() {\n@@ -893,7 +893,7 @@ impl<'a, 'tcx> Struct {\n                 }\n             }\n \n-            (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n+            (_, _, &ty::TyProjection(_)) | (_, _, &ty::TyAnon(..)) => {\n                 bug!(\"Struct::non_zero_field_in_type: {:?} not normalized\", layout);\n             }\n \n@@ -920,79 +920,6 @@ impl<'a, 'tcx> Struct {\n     }\n }\n \n-/// An untagged union.\n-#[derive(PartialEq, Eq, Hash, Debug)]\n-pub struct Union {\n-    pub align: Align,\n-    pub primitive_align: Align,\n-\n-    pub min_size: Size,\n-\n-    /// If true, no alignment padding is used.\n-    pub packed: bool,\n-}\n-\n-impl<'a, 'tcx> Union {\n-    fn new(dl: &TargetDataLayout, repr: &ReprOptions) -> Union {\n-        if repr.packed() && repr.align > 0 {\n-            bug!(\"Union cannot be packed and aligned\");\n-        }\n-\n-        let primitive_align = if repr.packed() {\n-            dl.i8_align\n-        } else {\n-            dl.aggregate_align\n-        };\n-\n-        let align = if repr.align > 0 {\n-            let repr_align = repr.align as u64;\n-            debug!(\"Union::new repr_align: {:?}\", repr_align);\n-            primitive_align.max(Align::from_bytes(repr_align, repr_align).unwrap())\n-        } else {\n-            primitive_align\n-        };\n-\n-        Union {\n-            align,\n-            primitive_align,\n-            min_size: Size::from_bytes(0),\n-            packed: repr.packed(),\n-        }\n-    }\n-\n-    /// Extend the Union with more fields.\n-    fn extend<I>(&mut self, dl: &TargetDataLayout,\n-                 fields: I,\n-                 scapegoat: Ty<'tcx>)\n-                 -> Result<(), LayoutError<'tcx>>\n-    where I: Iterator<Item=Result<FullLayout<'a>, LayoutError<'tcx>>> {\n-        for (index, field) in fields.enumerate() {\n-            let field = field?;\n-            if field.is_unsized() {\n-                bug!(\"Union::extend: field #{} of `{}` is unsized\",\n-                     index, scapegoat);\n-            }\n-\n-            debug!(\"Union::extend field: {:?} {:?}\", field, field.size(dl));\n-\n-            if !self.packed {\n-                self.align = self.align.max(field.align(dl));\n-                self.primitive_align = self.primitive_align.max(field.primitive_align(dl));\n-            }\n-            self.min_size = cmp::max(self.min_size, field.size(dl));\n-        }\n-\n-        debug!(\"Union::extend min-size: {:?}\", self.min_size);\n-\n-        Ok(())\n-    }\n-\n-    /// Get the size with trailing alignment padding.\n-    pub fn stride(&self) -> Size {\n-        self.min_size.abi_align(self.align)\n-    }\n-}\n-\n /// The first half of a fat pointer.\n /// - For a trait object, this is the address of the box.\n /// - For a slice, this is the base address.\n@@ -1068,6 +995,7 @@ pub enum Abi {\n     Aggregate {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n+        packed: bool,\n         align: Align,\n         primitive_align: Align,\n         size: Size\n@@ -1078,11 +1006,19 @@ impl Abi {\n     /// Returns true if the layout corresponds to an unsized type.\n     pub fn is_unsized(&self) -> bool {\n         match *self {\n-            Abi::Scalar(_) | Abi::Vector {..} => false,\n+            Abi::Scalar(_) | Abi::Vector { .. } => false,\n             Abi::Aggregate { sized, .. } => !sized\n         }\n     }\n \n+    /// Returns true if the fields of the layout are packed.\n+    pub fn is_packed(&self) -> bool {\n+        match *self {\n+            Abi::Scalar(_) | Abi::Vector { .. } => false,\n+            Abi::Aggregate { packed, .. } => packed\n+        }\n+    }\n+\n     pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n         let dl = cx.data_layout();\n \n@@ -1144,34 +1080,24 @@ impl Abi {\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum Layout<'a> {\n     /// TyBool, TyChar, TyInt, TyUint, TyFloat, TyRawPtr, TyRef or TyFnPtr.\n-    Scalar(Primitive),\n+    Scalar,\n \n     /// SIMD vectors, from structs marked with #[repr(simd)].\n-    Vector {\n-        element: Primitive,\n-        count: u64\n-    },\n+    Vector,\n \n     /// TyArray, TySlice or TyStr.\n-    Array {\n-        /// If true, the size is exact, otherwise it's only a lower bound.\n-        sized: bool,\n-        align: Align,\n-        primitive_align: Align,\n-        element_size: Size,\n-        count: u64\n-    },\n+    Array,\n \n     /// TyRawPtr or TyRef with a !Sized pointee. The primitive is the metadata.\n-    FatPointer(Primitive),\n+    FatPointer,\n \n     // Remaining variants are all ADTs such as structs, enums or tuples.\n \n     /// Single-case enums, and structs/tuples.\n     Univariant(Struct),\n \n     /// Untagged unions.\n-    UntaggedUnion(Union),\n+    UntaggedUnion,\n \n     /// General-case enums: for each case there is a struct, and they all have\n     /// all space reserved for the discriminant, and their first field starts\n@@ -1185,9 +1111,6 @@ pub enum Layout<'a> {\n         // taking everything else as the (shortest) discriminant range.\n         discr_range: RangeInclusive<u64>,\n         variants: Vec<CachedLayout<'a>>,\n-        size: Size,\n-        align: Align,\n-        primitive_align: Align,\n     },\n \n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n@@ -1203,9 +1126,6 @@ pub enum Layout<'a> {\n         discr: Primitive,\n         discr_offset: Size,\n         variants: Vec<CachedLayout<'a>>,\n-        size: Size,\n-        align: Align,\n-        primitive_align: Align,\n     }\n }\n \n@@ -1269,159 +1189,98 @@ impl<'a, 'tcx> Layout<'tcx> {\n                         -> Result<CachedLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = (tcx, param_env);\n         let dl = cx.data_layout();\n-        let success = |layout| {\n-            let layout = tcx.intern_layout(layout);\n+        let scalar = |value| {\n+            CachedLayout {\n+                layout: &Layout::Scalar,\n+                fields: FieldPlacement::union(0),\n+                abi: Abi::Scalar(value)\n+            }\n+        };\n+        let univariant = |st| {\n+            let layout = tcx.intern_layout(Layout::Univariant(st));\n             let fields = match *layout {\n-                Scalar(_) => {\n-                    FieldPlacement::union(0)\n-                }\n-\n-                Vector { element, count } => {\n-                    FieldPlacement::Linear {\n-                        stride: element.size(tcx),\n-                        count\n-                    }\n-                }\n-\n-                Array { element_size, count, .. } => {\n-                    FieldPlacement::Linear {\n-                        stride: element_size,\n-                        count\n-                    }\n-                }\n-\n-                FatPointer { .. } => {\n-                    FieldPlacement::Linear {\n-                        stride: Pointer.size(tcx),\n-                        count: 2\n-                    }\n-                }\n-\n                 Univariant(ref variant) => {\n                     FieldPlacement::Arbitrary {\n                         offsets: &variant.offsets\n                     }\n                 }\n-\n-                UntaggedUnion(_) => {\n-                    // Handle unions through the type rather than Layout.\n-                    let def = ty.ty_adt_def().unwrap();\n-                    FieldPlacement::union(def.struct_variant().fields.len())\n-                }\n-\n-                General { .. } => FieldPlacement::union(1),\n-\n-                NullablePointer { ref discr_offset, .. } => {\n-                    FieldPlacement::Arbitrary {\n-                        offsets: ref_slice(discr_offset)\n-                    }\n-                }\n+                _ => bug!()\n             };\n             let abi = match *layout {\n-                Scalar(value) => Abi::Scalar(value),\n-                Vector { element, count } => Abi::Vector { element, count },\n-\n-                Array { sized, align, primitive_align, element_size, count, .. } => {\n-                    let size = match element_size.checked_mul(count, dl) {\n-                        Some(size) => size,\n-                        None => return Err(LayoutError::SizeOverflow(ty))\n-                    };\n-                    Abi::Aggregate {\n-                        sized,\n-                        align,\n-                        primitive_align,\n-                        size\n-                    }\n-                }\n-\n-                FatPointer(metadata) => {\n-                    // Effectively a (ptr, meta) tuple.\n-                    let align = Pointer.align(dl).max(metadata.align(dl));\n-                    Abi::Aggregate {\n-                        sized: true,\n-                        align,\n-                        primitive_align: align,\n-                        size: (Pointer.size(dl).abi_align(metadata.align(dl)) +\n-                               metadata.size(dl))\n-                            .abi_align(align)\n-                    }\n-                }\n-\n                 Univariant(ref st) => {\n                     Abi::Aggregate {\n                         sized: st.sized,\n+                        packed: st.packed,\n                         align: st.align,\n                         primitive_align: st.primitive_align,\n                         size: st.stride()\n                     }\n                 }\n-\n-                UntaggedUnion(ref un ) => {\n-                    Abi::Aggregate {\n-                        sized: true,\n-                        align: un.align,\n-                        primitive_align: un.primitive_align,\n-                        size: un.stride()\n-                    }\n-                }\n-\n-                General { discr, align, primitive_align, size, .. } |\n-                NullablePointer { discr, align, primitive_align, size, .. } => {\n-                    if fields.offset(0).bytes() == 0 && discr.size(cx) == size {\n-                        Abi::Scalar(discr)\n-                    } else {\n-                        Abi::Aggregate {\n-                            sized: true,\n-                            align,\n-                            primitive_align,\n-                            size\n-                        }\n-                    }\n-                }\n+                _ => bug!()\n             };\n-            Ok(CachedLayout {\n+            CachedLayout {\n                 layout,\n                 fields,\n                 abi\n-            })\n+            }\n         };\n         assert!(!ty.has_infer_types());\n \n         let ptr_layout = |pointee: Ty<'tcx>| {\n             let pointee = tcx.normalize_associated_type_in_env(&pointee, param_env);\n             if pointee.is_sized(tcx, param_env, DUMMY_SP) {\n-                Ok(Scalar(Pointer))\n-            } else {\n-                let unsized_part = tcx.struct_tail(pointee);\n-                let metadata = match unsized_part.sty {\n-                    ty::TyForeign(..) => return Ok(Scalar(Pointer)),\n-                    ty::TySlice(_) | ty::TyStr => {\n-                        Int(dl.ptr_sized_integer(), false)\n-                    }\n-                    ty::TyDynamic(..) => Pointer,\n-                    _ => return Err(LayoutError::Unknown(unsized_part))\n-                };\n-                Ok(FatPointer(metadata))\n+                return Ok(scalar(Pointer));\n             }\n+\n+            let unsized_part = tcx.struct_tail(pointee);\n+            let metadata = match unsized_part.sty {\n+                ty::TyForeign(..) => return Ok(scalar(Pointer)),\n+                ty::TySlice(_) | ty::TyStr => {\n+                    Int(dl.ptr_sized_integer(), false)\n+                }\n+                ty::TyDynamic(..) => Pointer,\n+                _ => return Err(LayoutError::Unknown(unsized_part))\n+            };\n+\n+            // Effectively a (ptr, meta) tuple.\n+            let align = Pointer.align(dl).max(metadata.align(dl));\n+            let fields = FieldPlacement::Linear {\n+                stride: Pointer.size(dl),\n+                count: 2\n+            };\n+            let meta_offset = fields.offset(1);\n+            assert_eq!(meta_offset, meta_offset.abi_align(metadata.align(dl)));\n+            Ok(CachedLayout {\n+                layout: tcx.intern_layout(Layout::FatPointer),\n+                fields,\n+                abi:\n+                Abi::Aggregate {\n+                    sized: true,\n+                    packed: false,\n+                    align,\n+                    primitive_align: align,\n+                    size: (meta_offset + metadata.size(dl)).abi_align(align)\n+                }\n+            })\n         };\n \n-        let layout = match ty.sty {\n+        Ok(match ty.sty {\n             // Basic scalars.\n-            ty::TyBool => Scalar(Int(I1, false)),\n-            ty::TyChar => Scalar(Int(I32, false)),\n+            ty::TyBool => scalar(Int(I1, false)),\n+            ty::TyChar => scalar(Int(I32, false)),\n             ty::TyInt(ity) => {\n-                Scalar(Int(Integer::from_attr(dl, attr::SignedInt(ity)), true))\n+                scalar(Int(Integer::from_attr(dl, attr::SignedInt(ity)), true))\n             }\n             ty::TyUint(ity) => {\n-                Scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity)), false))\n+                scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity)), false))\n             }\n-            ty::TyFloat(FloatTy::F32) => Scalar(F32),\n-            ty::TyFloat(FloatTy::F64) => Scalar(F64),\n-            ty::TyFnPtr(_) => Scalar(Pointer),\n+            ty::TyFloat(FloatTy::F32) => scalar(F32),\n+            ty::TyFloat(FloatTy::F64) => scalar(F64),\n+            ty::TyFnPtr(_) => scalar(Pointer),\n \n             // The never type.\n             ty::TyNever => {\n-                Univariant(Struct::new(dl, &[], &ReprOptions::default(),\n+                univariant(Struct::new(dl, &[], &ReprOptions::default(),\n                                        StructKind::AlwaysSizedUnivariant, ty)?)\n             }\n \n@@ -1446,50 +1305,74 @@ impl<'a, 'tcx> Layout<'tcx> {\n                 let element = cx.layout_of(element)?;\n                 let element_size = element.size(dl);\n                 let count = count.val.to_const_int().unwrap().to_u64().unwrap();\n-                Array {\n-                    sized: true,\n-                    align: element.align(dl),\n-                    primitive_align: element.primitive_align(dl),\n-                    element_size,\n-                    count,\n+                let size = element_size.checked_mul(count, dl)\n+                    .ok_or(LayoutError::SizeOverflow(ty))?;\n+\n+                CachedLayout {\n+                    layout: &Layout::Array,\n+                    fields: FieldPlacement::Linear {\n+                        stride: element_size,\n+                        count\n+                    },\n+                    abi: Abi::Aggregate {\n+                        sized: true,\n+                        packed: false,\n+                        align: element.align(dl),\n+                        primitive_align: element.primitive_align(dl),\n+                        size\n+                    }\n                 }\n             }\n             ty::TySlice(element) => {\n                 let element = cx.layout_of(element)?;\n-                Array {\n-                    sized: false,\n-                    align: element.align(dl),\n-                    primitive_align: element.primitive_align(dl),\n-                    element_size: element.size(dl),\n-                    count: 0\n+                CachedLayout {\n+                    layout: &Layout::Array,\n+                    fields: FieldPlacement::Linear {\n+                        stride: element.size(dl),\n+                        count: 0\n+                    },\n+                    abi: Abi::Aggregate {\n+                        sized: false,\n+                        packed: false,\n+                        align: element.align(dl),\n+                        primitive_align: element.primitive_align(dl),\n+                        size: Size::from_bytes(0)\n+                    }\n                 }\n             }\n             ty::TyStr => {\n-                Array {\n-                    sized: false,\n-                    align: dl.i8_align,\n-                    primitive_align: dl.i8_align,\n-                    element_size: Size::from_bytes(1),\n-                    count: 0\n+                CachedLayout {\n+                    layout: &Layout::Array,\n+                    fields: FieldPlacement::Linear {\n+                        stride: Size::from_bytes(1),\n+                        count: 0\n+                    },\n+                    abi: Abi::Aggregate {\n+                        sized: false,\n+                        packed: false,\n+                        align: dl.i8_align,\n+                        primitive_align: dl.i8_align,\n+                        size: Size::from_bytes(0)\n+                    }\n                 }\n             }\n \n             // Odd unit types.\n             ty::TyFnDef(..) => {\n-                Univariant(Struct::new(dl, &[], &ReprOptions::default(),\n+                univariant(Struct::new(dl, &[], &ReprOptions::default(),\n                                        StructKind::AlwaysSizedUnivariant, ty)?)\n             }\n             ty::TyDynamic(..) | ty::TyForeign(..) => {\n                 let mut unit = Struct::new(dl, &[], &ReprOptions::default(),\n                   StructKind::AlwaysSizedUnivariant, ty)?;\n                 unit.sized = false;\n-                Univariant(unit)\n+                univariant(unit)\n             }\n \n             // Tuples, generators and closures.\n             ty::TyGenerator(def_id, ref substs, _) => {\n                 let tys = substs.field_tys(def_id, tcx);\n-                Univariant(Struct::new(dl,\n+                univariant(Struct::new(dl,\n                     &tys.map(|ty| cx.layout_of(ty))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n@@ -1498,7 +1381,7 @@ impl<'a, 'tcx> Layout<'tcx> {\n \n             ty::TyClosure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n-                Univariant(Struct::new(dl,\n+                univariant(Struct::new(dl,\n                     &tys.map(|ty| cx.layout_of(ty))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n@@ -1512,27 +1395,31 @@ impl<'a, 'tcx> Layout<'tcx> {\n                     StructKind::MaybeUnsizedUnivariant\n                 };\n \n-                Univariant(Struct::new(dl,\n+                univariant(Struct::new(dl,\n                     &tys.iter().map(|ty| cx.layout_of(ty))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(), kind, ty)?)\n             }\n \n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n+                let count = ty.simd_size(tcx) as u64;\n                 let element = ty.simd_type(tcx);\n-                match cx.layout_of(element)?.abi {\n-                    Abi::Scalar(value) => {\n-                        return success(Vector {\n-                            element: value,\n-                            count: ty.simd_size(tcx) as u64\n-                        });\n-                    }\n+                let element = match cx.layout_of(element)?.abi {\n+                    Abi::Scalar(value) => value,\n                     _ => {\n                         tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n                                                 a non-machine element type `{}`\",\n                                                 ty, element));\n                     }\n+                };\n+                CachedLayout {\n+                    layout: &Layout::Vector,\n+                    fields: FieldPlacement::Linear {\n+                        stride: element.size(tcx),\n+                        count\n+                    },\n+                    abi: Abi::Vector { element, count }\n                 }\n             }\n \n@@ -1549,10 +1436,54 @@ impl<'a, 'tcx> Layout<'tcx> {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n-                    return success(Univariant(Struct::new(dl, &[],\n+                    return Ok(univariant(Struct::new(dl, &[],\n                           &def.repr, StructKind::AlwaysSizedUnivariant, ty)?));\n                 }\n \n+                if def.is_union() {\n+                    let packed = def.repr.packed();\n+                    if packed && def.repr.align > 0 {\n+                        bug!(\"Union cannot be packed and aligned\");\n+                    }\n+\n+                    let mut primitive_align = if def.repr.packed() {\n+                        dl.i8_align\n+                    } else {\n+                        dl.aggregate_align\n+                    };\n+\n+                    let mut align = if def.repr.align > 0 {\n+                        let repr_align = def.repr.align as u64;\n+                        primitive_align.max(\n+                            Align::from_bytes(repr_align, repr_align).unwrap())\n+                    } else {\n+                        primitive_align\n+                    };\n+\n+                    let mut size = Size::from_bytes(0);\n+                    for field in &variants[0] {\n+                        assert!(!field.is_unsized());\n+\n+                        if !packed {\n+                            align = align.max(field.align(dl));\n+                            primitive_align = primitive_align.max(field.primitive_align(dl));\n+                        }\n+                        size = cmp::max(size, field.size(dl));\n+                    }\n+\n+                    return Ok(CachedLayout {\n+                        layout: &Layout::UntaggedUnion,\n+                        fields: FieldPlacement::union(variants[0].len()),\n+                        abi: Abi::Aggregate {\n+                            sized: true,\n+                            packed,\n+                            align,\n+                            primitive_align,\n+                            size: size.abi_align(align)\n+                        }\n+                    });\n+                }\n+\n                 if !def.is_enum() || (variants.len() == 1 &&\n                                       !def.repr.inhibit_enum_layout_opt() &&\n                                       !variants[0].is_empty()) {\n@@ -1570,14 +1501,7 @@ impl<'a, 'tcx> Layout<'tcx> {\n                         else { StructKind::AlwaysSizedUnivariant }\n                     };\n \n-                    let layout = if def.is_union() {\n-                        let mut un = Union::new(dl, &def.repr);\n-                        un.extend(dl, variants[0].iter().map(|&f| Ok(f)), ty)?;\n-                        UntaggedUnion(un)\n-                    } else {\n-                        Univariant(Struct::new(dl, &variants[0], &def.repr, kind, ty)?)\n-                    };\n-                    return success(layout);\n+                    return Ok(univariant(Struct::new(dl, &variants[0], &def.repr, kind, ty)?));\n                 }\n \n                 let no_explicit_discriminants = def.variants.iter().enumerate()\n@@ -1608,25 +1532,49 @@ impl<'a, 'tcx> Layout<'tcx> {\n                         }\n                     }\n \n-                    if let Some((discr, offset, primitive)) = choice {\n-                        let mut discr_align = primitive.align(dl);\n-                        if offset.abi_align(discr_align) != offset {\n-                            st[discr].packed = true;\n-                            discr_align = dl.i8_align;\n+                    if let Some((nndiscr, offset, discr)) = choice {\n+                        let variants: Vec<_> = st.into_iter().map(&univariant).collect();\n+                        let mut abi = variants[nndiscr].abi;\n+\n+                        let mut discr_align = discr.align(dl);\n+                        match abi {\n+                            Abi::Aggregate {\n+                                ref mut align,\n+                                ref mut primitive_align,\n+                                ref mut packed,\n+                                ..\n+                            } => {\n+                                if offset.abi_align(discr_align) != offset {\n+                                    *packed = true;\n+                                    discr_align = dl.i8_align;\n+                                }\n+                                *align = align.max(discr_align);\n+                                *primitive_align = primitive_align.max(discr_align);\n+                            }\n+                            _ => {}\n                         }\n-                        let align = st[discr].align.max(discr_align);\n-                        let primitive_align = st[discr].primitive_align.max(discr_align);\n \n-                        return success(NullablePointer {\n-                            nndiscr: discr as u64,\n-                            discr: primitive,\n+                        let layout = tcx.intern_layout(Layout::NullablePointer {\n+                            nndiscr: nndiscr as u64,\n+                            discr,\n                             discr_offset: offset,\n-                            size: st[discr].stride(),\n-                            align,\n-                            primitive_align,\n-                            variants: st.into_iter().map(|variant| {\n-                                success(Univariant(variant))\n-                            }).collect::<Result<Vec<_>, _>>()?,\n+                            variants,\n+                        });\n+                        return Ok(CachedLayout {\n+                            layout,\n+                            fields: match *layout {\n+                                Layout::NullablePointer { ref discr_offset, .. } => {\n+                                    FieldPlacement::Arbitrary {\n+                                        offsets: ref_slice(discr_offset)\n+                                    }\n+                                }\n+                                _ => bug!()\n+                            },\n+                            abi: if offset.bytes() == 0 && discr.size(dl) == abi.size(dl) {\n+                                Abi::Scalar(discr)\n+                            } else {\n+                                abi\n+                            }\n                         });\n                     }\n                 }\n@@ -1727,17 +1675,27 @@ impl<'a, 'tcx> Layout<'tcx> {\n                     }\n                 }\n \n-                General {\n-                    discr: Int(ity, signed),\n-\n-                    // FIXME: should be u128?\n-                    discr_range: (min as u64)..=(max as u64),\n-                    variants: variants.into_iter().map(|variant| {\n-                        success(Univariant(variant))\n-                    }).collect::<Result<Vec<_>, _>>()?,\n-                    size,\n-                    align,\n-                    primitive_align,\n+                let discr = Int(ity, signed);\n+                CachedLayout {\n+                    layout: tcx.intern_layout(Layout::General {\n+                        discr,\n+\n+                        // FIXME: should be u128?\n+                        discr_range: (min as u64)..=(max as u64),\n+                        variants: variants.into_iter().map(&univariant).collect(),\n+                    }),\n+                    fields: FieldPlacement::union(1),\n+                    abi: if discr.size(dl) == size {\n+                        Abi::Scalar(discr)\n+                    } else {\n+                        Abi::Aggregate {\n+                            sized: true,\n+                            packed: false,\n+                            align,\n+                            primitive_align,\n+                            size\n+                        }\n+                    }\n                 }\n             }\n \n@@ -1748,21 +1706,19 @@ impl<'a, 'tcx> Layout<'tcx> {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n                 let layout = cx.layout_of(normalized)?;\n-                return Ok(CachedLayout {\n+                CachedLayout {\n                     layout: layout.layout,\n                     fields: layout.fields,\n                     abi: layout.abi\n-                });\n+                }\n             }\n             ty::TyParam(_) => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n             ty::TyInfer(_) | ty::TyError => {\n                 bug!(\"Layout::compute: unexpected type `{}`\", ty)\n             }\n-        };\n-\n-        success(layout)\n+        })\n     }\n \n     /// This is invoked by the `layout_raw` query to record the final\n@@ -1916,18 +1872,18 @@ impl<'a, 'tcx> Layout<'tcx> {\n                 }, variant_infos);\n             }\n \n-            Layout::UntaggedUnion(ref un) => {\n-                debug!(\"print-type-size t: `{:?}` adt union {:?}\", ty, un);\n+            Layout::UntaggedUnion => {\n+                debug!(\"print-type-size t: `{:?}` adt union\", ty);\n                 // layout does not currently store info about each\n                 // variant...\n                 record(adt_kind.into(), None, Vec::new());\n             }\n \n             // other cases provide little interesting (i.e. adjustable\n             // via representation tweaks) size info beyond total size.\n-            Layout::Scalar(_) |\n-            Layout::Vector { .. } |\n-            Layout::Array { .. } |\n+            Layout::Scalar |\n+            Layout::Vector |\n+            Layout::Array |\n             Layout::FatPointer { .. } => {\n                 debug!(\"print-type-size t: `{:?}` adt other\", ty);\n                 record(adt_kind.into(), None, Vec::new())\n@@ -2333,6 +2289,11 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n         self.abi.is_unsized()\n     }\n \n+    /// Returns true if the fields of the layout are packed.\n+    pub fn is_packed(&self) -> bool {\n+        self.abi.is_packed()\n+    }\n+\n     pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n         self.abi.size(cx)\n     }\n@@ -2359,61 +2320,34 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout<'gcx> {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            Scalar(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Vector { element, count } => {\n-                element.hash_stable(hcx, hasher);\n-                count.hash_stable(hcx, hasher);\n-            }\n-            Array { sized, align, primitive_align, element_size, count } => {\n-                sized.hash_stable(hcx, hasher);\n-                align.hash_stable(hcx, hasher);\n-                primitive_align.hash_stable(hcx, hasher);\n-                element_size.hash_stable(hcx, hasher);\n-                count.hash_stable(hcx, hasher);\n-            }\n-            FatPointer(ref metadata) => {\n-                metadata.hash_stable(hcx, hasher);\n-            }\n+            Scalar => {}\n+            Vector => {}\n+            Array => {}\n+            FatPointer => {}\n             Univariant(ref variant) => {\n                 variant.hash_stable(hcx, hasher);\n             }\n-            UntaggedUnion(ref un) => {\n-                un.hash_stable(hcx, hasher);\n-            }\n+            UntaggedUnion => {}\n             General {\n                 discr,\n                 discr_range: RangeInclusive { start, end },\n                 ref variants,\n-                size,\n-                align,\n-                primitive_align\n             } => {\n                 discr.hash_stable(hcx, hasher);\n                 start.hash_stable(hcx, hasher);\n                 end.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n-                size.hash_stable(hcx, hasher);\n-                align.hash_stable(hcx, hasher);\n-                primitive_align.hash_stable(hcx, hasher);\n             }\n             NullablePointer {\n                 nndiscr,\n                 ref variants,\n                 ref discr,\n                 discr_offset,\n-                size,\n-                align,\n-                primitive_align\n             } => {\n                 nndiscr.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n                 discr.hash_stable(hcx, hasher);\n                 discr_offset.hash_stable(hcx, hasher);\n-                size.hash_stable(hcx, hasher);\n-                align.hash_stable(hcx, hasher);\n-                primitive_align.hash_stable(hcx, hasher);\n             }\n         }\n     }\n@@ -2453,7 +2387,8 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n                 element.hash_stable(hcx, hasher);\n                 count.hash_stable(hcx, hasher);\n             }\n-            Aggregate { sized, size, align, primitive_align } => {\n+            Aggregate { packed, sized, size, align, primitive_align } => {\n+                packed.hash_stable(hcx, hasher);\n                 sized.hash_stable(hcx, hasher);\n                 size.hash_stable(hcx, hasher);\n                 align.hash_stable(hcx, hasher);\n@@ -2518,10 +2453,3 @@ impl_stable_hash_for!(struct ::ty::layout::Struct {\n     memory_index,\n     min_size\n });\n-\n-impl_stable_hash_for!(struct ::ty::layout::Union {\n-    align,\n-    primitive_align,\n-    min_size,\n-    packed\n-});"}, {"sha": "dd5e97544c82c97b228e4d3b817a95d16712f333", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -753,11 +753,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     bug!(\"failed to get layout for `{}`: {}\", t, e)\n                 });\n \n-                if let Layout::General { ref variants, size, discr, .. } = *layout.layout {\n+                if let Layout::General { ref variants, discr, .. } = *layout.layout {\n                     let discr_size = discr.size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n-                      t, size.bytes(), layout);\n+                      t, layout.size(cx.tcx).bytes(), layout);\n \n                     let (largest, slargest, largest_index) = enum_definition.variants\n                         .iter()"}, {"sha": "b727629e233539832b40b895af4a8b59ea9e04b9", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -307,8 +307,8 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n             }\n \n             layout::Abi::Aggregate { .. } => {\n-                if let Layout::Array { count, .. } = *self.layout {\n-                    if count > 0 {\n+                if let Layout::Array { .. } = *self.layout {\n+                    if self.fields.count() > 0 {\n                         return self.field(ccx, 0).homogeneous_aggregate(ccx);\n                     }\n                 }"}, {"sha": "cd68d042473948532eb2371a16f702f4e2f40614", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 47, "deletions": 65, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -42,7 +42,7 @@\n //!   taken to it, implementing them for Rust seems difficult.\n \n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, HasDataLayout, LayoutOf, Size, FullLayout};\n+use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size, FullLayout};\n \n use context::CrateContext;\n use type_::Type;\n@@ -72,11 +72,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return;\n     }\n     match *l.layout {\n-        layout::NullablePointer { .. } |\n-        layout::General { .. } |\n-        layout::UntaggedUnion { .. } => { }\n-\n-        layout::Univariant(ref variant) => {\n+        layout::Univariant(_) => {\n             let is_enum = if let ty::TyAdt(def, _) = t.sty {\n                 def.is_enum()\n             } else {\n@@ -87,9 +83,11 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } else {\n                 l\n             };\n-            llty.set_struct_body(&struct_llfields(cx, variant_layout), variant.packed)\n-        },\n-        _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n+            llty.set_struct_body(&struct_llfields(cx, variant_layout),\n+                                 variant_layout.is_packed())\n+        }\n+\n+        _ => {}\n     }\n }\n \n@@ -102,81 +100,65 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return cx.llvm_type_of(value.to_ty(cx.tcx()));\n     }\n     match *l.layout {\n-        layout::Univariant(ref variant) => {\n+        layout::Univariant(_) => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, l), variant.packed)\n+                    Type::struct_(cx, &struct_llfields(cx, l), l.is_packed())\n                 }\n                 Some(name) => {\n                     Type::named_struct(cx, name)\n                 }\n             }\n         }\n-        layout::UntaggedUnion(ref un) => {\n-            // Use alignment-sized ints to fill all the union storage.\n-            let fill = union_fill(cx, un.stride(), un.align);\n-            match name {\n-                None => {\n-                    Type::struct_(cx, &[fill], un.packed)\n-                }\n-                Some(name) => {\n-                    let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&[fill], un.packed);\n-                    llty\n-                }\n-            }\n-        }\n-        layout::NullablePointer { size, align, .. } |\n-        layout::General { size, align, .. } => {\n-            let fill = union_fill(cx, size, align);\n+        _ => {\n+            let align = l.align(cx);\n+            let abi_align = align.abi();\n+            let elem_ty = if let Some(ity) = layout::Integer::for_abi_align(cx, align) {\n+                Type::from_integer(cx, ity)\n+            } else {\n+                let vec_align = cx.data_layout().vector_align(Size::from_bytes(abi_align));\n+                assert_eq!(vec_align.abi(), abi_align);\n+                Type::vector(&Type::i32(cx), abi_align / 4)\n+            };\n+\n+            let size = l.size(cx).bytes();\n+            assert_eq!(size % abi_align, 0);\n+            let fill = Type::array(&elem_ty, size / abi_align);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &[fill], false)\n+                    Type::struct_(cx, &[fill], l.is_packed())\n                 }\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&[fill], false);\n+                    llty.set_struct_body(&[fill], l.is_packed());\n                     llty\n                 }\n             }\n         }\n-        _ => bug!(\"Unsupported type {} represented as {:#?}\", t, l)\n     }\n }\n \n-fn union_fill(cx: &CrateContext, size: Size, align: Align) -> Type {\n-    let abi_align = align.abi();\n-    let elem_ty = if let Some(ity) = layout::Integer::for_abi_align(cx, align) {\n-        Type::from_integer(cx, ity)\n-    } else {\n-        let vec_align = cx.data_layout().vector_align(Size::from_bytes(abi_align));\n-        assert_eq!(vec_align.abi(), abi_align);\n-        Type::vector(&Type::i32(cx), abi_align / 4)\n-    };\n-\n-    let size = size.bytes();\n-    assert_eq!(size % abi_align, 0);\n-    Type::array(&elem_ty, size / abi_align)\n-}\n-\n /// Double an index and add 1 to account for padding.\n pub fn memory_index_to_gep(index: u64) -> u64 {\n     1 + index * 2\n }\n \n pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  layout: FullLayout<'tcx>) -> Vec<Type> {\n-    let variant = match *layout.layout {\n-        layout::Univariant(ref variant) => variant,\n-        _ => bug!(\"unexpected {:#?}\", layout)\n-    };\n+    debug!(\"struct_llfields: {:#?}\", layout);\n+    let align = layout.align(cx);\n+    let size = layout.size(cx);\n     let field_count = layout.fields.count();\n-    debug!(\"struct_llfields: variant: {:?}\", variant);\n+\n     let mut offset = Size::from_bytes(0);\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n-    for i in variant.field_index_by_increasing_offset() {\n+    let field_index_by_increasing_offset = match *layout.layout {\n+        layout::Univariant(ref variant) => variant.field_index_by_increasing_offset(),\n+        _ => bug!(\"unexpected {:#?}\", layout)\n+    };\n+    for i in field_index_by_increasing_offset {\n         let field = layout.field(cx, i);\n-        let target_offset = variant.offsets[i as usize];\n+        let target_offset = layout.fields.offset(i as usize);\n         debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\",\n             i, field, offset, target_offset);\n         assert!(target_offset >= offset);\n@@ -187,30 +169,30 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let llty = cx.llvm_type_of(field.ty);\n         result.push(llty);\n \n-        if variant.packed {\n+        if layout.is_packed() {\n             assert_eq!(padding.bytes(), 0);\n         } else {\n             let field_align = field.align(cx);\n-            assert!(field_align.abi() <= variant.align.abi(),\n+            assert!(field_align.abi() <= align.abi(),\n                     \"non-packed type has field with larger align ({}): {:#?}\",\n-                    field_align.abi(), variant);\n+                    field_align.abi(), layout);\n         }\n \n         offset = target_offset + field.size(cx);\n     }\n-    if variant.sized && field_count > 0 {\n-        if offset > variant.stride() {\n-            bug!(\"variant: {:?} stride: {:?} offset: {:?}\",\n-                variant, variant.stride(), offset);\n+    if !layout.is_unsized() && field_count > 0 {\n+        if offset > size {\n+            bug!(\"layout: {:#?} stride: {:?} offset: {:?}\",\n+                 layout, size, offset);\n         }\n-        let padding = variant.stride() - offset;\n-        debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} min_size: {:?} stride: {:?}\",\n-            padding, offset, variant.min_size, variant.stride());\n+        let padding = size - offset;\n+        debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n+               padding, offset, size);\n         result.push(Type::array(&Type::i8(cx), padding.bytes()));\n         assert!(result.len() == 1 + field_count * 2);\n     } else {\n-        debug!(\"struct_llfields: offset: {:?} min_size: {:?} stride: {:?}\",\n-               offset, variant.min_size, variant.stride());\n+        debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n+               offset, size);\n     }\n \n     result"}, {"sha": "82a4095aa01187e441d0dd4f69643e519ee29c9a", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -65,9 +65,9 @@ pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n     let layout = ccx.layout_of(ty);\n     match *layout.layout {\n         Layout::FatPointer { .. } => true,\n-        Layout::Univariant(ref variant) => {\n+        Layout::Univariant(_) => {\n             // There must be only 2 fields.\n-            if variant.offsets.len() != 2 {\n+            if layout.fields.count() != 2 {\n                 return false;\n             }\n "}, {"sha": "b9ff46166a8d80fb50193f205c85576daec34bbf", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -939,20 +939,6 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n-\n-        let tmp;\n-        let offsets = match *layout.layout {\n-            layout::Univariant(ref variant) => &variant.offsets,\n-            layout::Vector { element, count } => {\n-                let element_size = element.size(cx).bytes();\n-                tmp = (0..count).\n-                  map(|i| layout::Size::from_bytes(i*element_size))\n-                  .collect::<Vec<layout::Size>>();\n-                &tmp\n-            }\n-            _ => bug!(\"{} is not a struct\", self.ty)\n-        };\n-\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let name = if self.variant.ctor_kind == CtorKind::Fn {\n                 format!(\"__{}\", i)\n@@ -964,7 +950,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n             MemberDescription {\n                 name,\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n-                offset: offsets[i],\n+                offset: layout.fields.offset(i),\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,\n@@ -1022,18 +1008,12 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n-        let offsets = if let layout::Univariant(ref variant) = *layout.layout {\n-            &variant.offsets\n-        } else {\n-            bug!(\"{} is not a tuple\", self.ty);\n-        };\n-\n         self.component_types.iter().enumerate().map(|(i, &component_type)| {\n             let (size, align) = cx.size_and_align_of(component_type);\n             MemberDescription {\n                 name: format!(\"__{}\", i),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n-                offset: offsets[i],\n+                offset: layout.fields.offset(i),\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,"}, {"sha": "f374ed90c342d24a72e3ffcb9432cfab170f2934", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -58,23 +58,17 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let layout = ccx.layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n-            let (sized_size, sized_align) = match *layout.layout {\n-                ty::layout::Layout::Univariant(ref variant) => {\n-                    (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align.abi())\n-                }\n-                _ => {\n-                    bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n-                         t, layout);\n-                }\n-            };\n+            let i = layout.fields.count() - 1;\n+            let sized_size = layout.fields.offset(i).bytes();\n+            let sized_align = layout.align(ccx).abi();\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n             let sized_size = C_usize(ccx, sized_size);\n             let sized_align = C_usize(ccx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let field_ty = layout.field(ccx, layout.fields.count() - 1).ty;\n+            let field_ty = layout.field(ccx, i).ty;\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding"}, {"sha": "d6e2257ab2422738ce9d55f606db174b64962773", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -1108,14 +1108,14 @@ fn trans_const_adt<'a, 'tcx>(\n                 build_const_struct(ccx, l.for_variant(variant_index), vals, Some(discr))\n             }\n         }\n-        layout::UntaggedUnion(ref un) => {\n+        layout::UntaggedUnion => {\n             assert_eq!(variant_index, 0);\n             let contents = [\n                 vals[0].llval,\n-                padding(ccx, un.stride() - ccx.size_of(vals[0].ty))\n+                padding(ccx, l.size(ccx) - ccx.size_of(vals[0].ty))\n             ];\n \n-            Const::new(C_struct(ccx, &contents, un.packed), t)\n+            Const::new(C_struct(ccx, &contents, l.is_packed()), t)\n         }\n         layout::Univariant(_) => {\n             assert_eq!(variant_index, 0);\n@@ -1162,11 +1162,11 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         offset = ccx.size_of(discr.ty);\n     }\n \n-    let st = match *layout.layout {\n-        layout::Univariant(ref variant) => variant,\n+    let field_index_by_increasing_offset = match *layout.layout {\n+        layout::Univariant(ref variant) => variant.field_index_by_increasing_offset(),\n         _ => bug!(\"unexpected {:#?}\", layout)\n     };\n-    let parts = st.field_index_by_increasing_offset().map(|i| {\n+    let parts = field_index_by_increasing_offset.map(|i| {\n         (vals[i], layout.fields.offset(i))\n     });\n     for (val, target_offset) in parts {\n@@ -1178,7 +1178,7 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Pad to the size of the whole type, not e.g. the variant.\n     cfields.push(padding(ccx, ccx.size_of(layout.ty) - offset));\n \n-    Const::new(C_struct(ccx, &cfields, st.packed), layout.ty)\n+    Const::new(C_struct(ccx, &cfields, layout.is_packed()), layout.ty)\n }\n \n fn padding(ccx: &CrateContext, size: Size) -> ValueRef {"}, {"sha": "b21e4ffc2c3ad729ae5d0948886ffc8ad8a26026", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, Layout, LayoutOf};\n+use rustc::ty::layout::{self, Align, FullLayout, Layout, LayoutOf};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -55,14 +55,9 @@ impl ops::BitOr for Alignment {\n     }\n }\n \n-impl<'a> From<&'a Layout<'a>> for Alignment {\n-    fn from(layout: &Layout) -> Self {\n-        let (packed, align) = match *layout {\n-            Layout::UntaggedUnion(ref un) => (un.packed, un.align),\n-            Layout::Univariant(ref variant) => (variant.packed, variant.align),\n-            _ => return Alignment::AbiAligned\n-        };\n-        if packed {\n+impl<'a> From<FullLayout<'a>> for Alignment {\n+    fn from(layout: FullLayout) -> Self {\n+        if let layout::Abi::Aggregate { packed: true, align, .. } = layout.abi {\n             Alignment::Packed(align)\n         } else {\n             Alignment::AbiAligned\n@@ -208,7 +203,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let field = l.field(ccx, ix);\n         let offset = l.fields.offset(ix).bytes();\n \n-        let alignment = self.alignment | Alignment::from(l.layout);\n+        let alignment = self.alignment | Alignment::from(l);\n \n         // Unions and newtypes only use an offset of 0.\n         match *l.layout {\n@@ -267,16 +262,10 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             }\n         };\n \n-        // Check whether the variant being used is packed, if applicable.\n-        let is_packed = match *l.layout {\n-            layout::Univariant(ref variant) => variant.packed,\n-            _ => return simple()\n-        };\n-\n         // Simple case - we can just GEP the field\n         //   * Packed struct - There is no alignment padding\n         //   * Field is sized - pointer is properly aligned already\n-        if is_packed || !field.is_unsized() {\n+        if l.is_packed() || !field.is_unsized() {\n             return simple();\n         }\n \n@@ -466,12 +455,13 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n             // If this is an enum, cast to the appropriate variant struct type.\n             let layout = bcx.ccx.layout_of(ty);\n-            let variant_layout = layout.for_variant(variant_index);\n-            match (layout.layout, variant_layout.layout) {\n-                (&layout::NullablePointer { .. }, &layout::Univariant(ref st)) |\n-                (&layout::General { .. }, &layout::Univariant(ref st)) => {\n+            match *layout.layout {\n+                layout::NullablePointer { .. } |\n+                layout::General { .. } => {\n+                    let variant_layout = layout.for_variant(variant_index);\n                     let variant_ty = Type::struct_(bcx.ccx,\n-                        &adt::struct_llfields(bcx.ccx, variant_layout), st.packed);\n+                        &adt::struct_llfields(bcx.ccx, variant_layout),\n+                        variant_layout.is_packed());\n                     downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n                 }\n                 _ => {}"}, {"sha": "a1e89013bdbdcd4d0620536a4ded3ad4bb0dd84f", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f9f134fd9d790c99ffab590fee264bd062f599/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=08f9f134fd9d790c99ffab590fee264bd062f599", "patch": "@@ -12,7 +12,7 @@ use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutOf};\n+use rustc::ty::layout::LayoutOf;\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n use rustc::infer::TransNormalize;\n@@ -576,13 +576,8 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             };\n \n             let layout = bcx.ccx.layout_of(closure_ty);\n-            let offsets = match *layout.layout {\n-                layout::Univariant(ref variant) => &variant.offsets[..],\n-                _ => bug!(\"Closures are only supposed to be Univariant\")\n-            };\n-\n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n-                let byte_offset_of_var_in_env = offsets[i].bytes();\n+                let byte_offset_of_var_in_env = layout.fields.offset(i).bytes();\n \n                 let ops = unsafe {\n                     [llvm::LLVMRustDIBuilderCreateOpDeref(),"}]}