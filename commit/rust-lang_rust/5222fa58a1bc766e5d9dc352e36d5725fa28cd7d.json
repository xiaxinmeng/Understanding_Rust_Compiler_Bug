{"sha": "5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMjJmYTU4YTFiYzc2NmU1ZDlkYzM1MmUzNmQ1NzI1ZmEyOGNkN2Q=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-18T05:32:50Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-26T21:25:04Z"}, "message": "rustc: use accessors for Substs::{types,regions}.", "tree": {"sha": "9b52e56c0b0f31a47e233363140c2f4aaaf20b12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b52e56c0b0f31a47e233363140c2f4aaaf20b12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "html_url": "https://github.com/rust-lang/rust/commit/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaf71f8d1034f16140791f566cab3f3c9a0bf96a", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf71f8d1034f16140791f566cab3f3c9a0bf96a", "html_url": "https://github.com/rust-lang/rust/commit/eaf71f8d1034f16140791f566cab3f3c9a0bf96a"}], "stats": {"total": 479, "additions": 250, "deletions": 229}, "files": [{"sha": "37366f38974a4bbc8c77a2e7bf93bacadd09468b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n                 if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n-                    match substs.substs.types[0].sty {\n+                    match substs.substs.type_at(0).sty {\n                         TyEnum(tyid, _) | TyStruct(tyid, _) => {\n                             self.check_def_id(tyid.did)\n                         }"}, {"sha": "10112e5084557c38f9098d15fa7cef8d0bce5f70", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -232,8 +232,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n                     self_match_impls.push(def_id);\n \n-                    if trait_ref.substs.types[1..].iter()\n-                        .zip(&impl_trait_ref.substs.types[1..])\n+                    if trait_ref.substs.types().skip(1)\n+                        .zip(impl_trait_ref.substs.types().skip(1))\n                         .all(|(u,v)| self.fuzzy_match_tys(u, v))\n                     {\n                         fuzzy_match_impls.push(def_id);\n@@ -738,8 +738,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::Predicate::Trait(ref data) => {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n-                let all_types = &trait_ref.substs().types;\n-                if all_types.references_error() {\n+                if predicate.references_error() {\n                 } else {\n                     // Typically, this ambiguity should only happen if\n                     // there are unresolved type inference variables"}, {"sha": "76477d3df93608a29a9793f1d465d6fde1f5a2f6", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n         // Auto trait obligations on `impl Trait`.\n         if tcx.trait_has_default_impl(predicate.def_id()) {\n             let substs = predicate.skip_binder().trait_ref.substs;\n-            if substs.types.len() == 1 && substs.regions.is_empty() {\n+            if substs.types().count() == 1 && substs.regions().next().is_none() {\n                 if let ty::TyAnon(..) = predicate.skip_binder().self_ty().sty {\n                     return true;\n                 }\n@@ -440,7 +440,6 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n-     .iter()\n      .map(|t| selcx.infcx().resolve_type_vars_if_possible(t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())"}, {"sha": "219d5200467622f8df1f708531206ce12b33a815", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.0.trait_ref.input_types()[1..].iter().any(|t| t.has_self_ty())\n+                        data.skip_binder().input_types().skip(1).any(|t| t.has_self_ty())\n                     }\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::WellFormed(..) |"}, {"sha": "f2ea14f17961f5adc865fd9eff4a4be104de6229", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -644,8 +644,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // This suffices to allow chains like `FnMut` implemented in\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n-        let input_types = stack.fresh_trait_ref.0.input_types();\n-        let unbound_input_types = input_types.iter().any(|ty| ty.is_fresh());\n+        let unbound_input_types = stack.fresh_trait_ref.input_types().any(|ty| ty.is_fresh());\n         if unbound_input_types && self.intercrate {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                    stack.fresh_trait_ref);\n@@ -1064,9 +1063,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         match *candidate {\n             Ok(Some(_)) | Err(_) => true,\n-            Ok(None) => {\n-                cache_fresh_trait_pred.0.trait_ref.substs.types.has_infer_types()\n-            }\n+            Ok(None) => cache_fresh_trait_pred.has_infer_types()\n         }\n     }\n \n@@ -1603,7 +1600,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 return;\n             }\n         };\n-        let target = obligation.predicate.skip_binder().input_types()[1];\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n \n         debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\",\n                source, target);\n@@ -1936,7 +1933,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // for `PhantomData<T>`, we pass `T`\n             ty::TyStruct(def, substs) if def.is_phantom_data() => {\n-                substs.types.to_vec()\n+                substs.types().cloned().collect()\n             }\n \n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n@@ -2180,12 +2177,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::TyTrait(ref data) => {\n                 // OK to skip the binder, it is reintroduced below\n-                let input_types = data.principal.skip_binder().input_types();\n+                let input_types = data.principal.input_types();\n                 let assoc_types = data.projection_bounds.iter()\n                                       .map(|pb| pb.skip_binder().ty);\n-                let all_types: Vec<_> = input_types.iter().cloned()\n-                                                          .chain(assoc_types)\n-                                                          .collect();\n+                let all_types: Vec<_> = input_types.cloned()\n+                                                   .chain(assoc_types)\n+                                                   .collect();\n \n                 // reintroduce the two binding levels we skipped, then flatten into one\n                 let all_types = ty::Binder(ty::Binder(all_types));\n@@ -2476,7 +2473,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // regions here. See the comment there for more details.\n         let source = self.infcx.shallow_resolve(\n             tcx.no_late_bound_regions(&obligation.self_ty()).unwrap());\n-        let target = obligation.predicate.skip_binder().input_types()[1];\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n         let target = self.infcx.shallow_resolve(target);\n \n         debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\",\n@@ -2585,7 +2582,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = BitVector::new(substs_a.types.len());\n+                let mut ty_params = BitVector::new(substs_a.types().count());\n                 let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::TyParam(p) = ty.sty {\n@@ -2601,14 +2598,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // TyError and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n-                let types = substs_a.types.iter().enumerate().map(|(i, ty)| {\n+                let types = substs_a.types().enumerate().map(|(i, ty)| {\n                     if ty_params.contains(i) {\n                         tcx.types.err\n                     } else {\n                         ty\n                     }\n                 }).collect();\n-                let substs = Substs::new(tcx, types, substs_a.regions.clone());\n+                let substs = Substs::new(tcx, types, substs_a.regions().cloned().collect());\n                 for &ty in fields.split_last().unwrap().1 {\n                     if ty.subst(tcx, substs).references_error() {\n                         return Err(Unimplemented);\n@@ -2621,14 +2618,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source structure with the target's\n                 // type parameters is a subtype of the target.\n-                let types = substs_a.types.iter().enumerate().map(|(i, ty)| {\n+                let types = substs_a.types().enumerate().map(|(i, ty)| {\n                     if ty_params.contains(i) {\n-                        substs_b.types[i]\n+                        substs_b.type_at(i)\n                     } else {\n                         ty\n                     }\n                 }).collect();\n-                let substs = Substs::new(tcx, types, substs_a.regions.clone());\n+                let substs = Substs::new(tcx, types, substs_a.regions().cloned().collect());\n                 let new_struct = tcx.mk_struct(def, substs);\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n@@ -2753,7 +2750,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n \n-        obligation.predicate.0.input_types().iter()\n+        obligation.predicate.skip_binder().input_types()\n             .zip(impl_trait_ref.input_types())\n             .any(|(&obligation_ty, &impl_ty)| {\n                 let simplified_obligation_ty ="}, {"sha": "2cae19d95ccbba4706c1dd7d423d44ca58117510", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -1152,7 +1152,7 @@ fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n impl_interners!('tcx,\n     type_list: mk_type_list(Vec<Ty<'tcx>>, keep_local) -> [Ty<'tcx>],\n     substs: mk_substs(Substs<'tcx>, |substs: &Substs| {\n-        keep_local(&substs.types) || keep_local(&substs.regions)\n+        substs.types().any(keep_local) || substs.regions().any(keep_local)\n     }) -> Substs<'tcx>,\n     bare_fn: mk_bare_fn(BareFnTy<'tcx>, |fty: &BareFnTy| {\n         keep_local(&fty.sig)"}, {"sha": "c7300946eade8763c8bb274067821d142ae04d16", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -208,8 +208,11 @@ impl FlagComputation {\n     }\n \n     fn add_substs(&mut self, substs: &Substs) {\n-        self.add_tys(&substs.types);\n-        for &r in &substs.regions {\n+        for &ty in substs.types() {\n+            self.add_ty(ty);\n+        }\n+\n+        for &r in substs.regions() {\n             self.add_region(r);\n         }\n     }"}, {"sha": "62bd30e2555921b029f69df921ac07254320ff24", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::TyStruct(adt_def, substs) |\n             ty::TyEnum(adt_def, substs) => {\n-                if substs.types.is_empty() { // ignore regions\n+                if substs.types().next().is_none() { // ignore regions\n                     self.push_item_path(buffer, adt_def.did);\n                 } else {\n                     buffer.push(&format!(\"<{}>\", self_ty));"}, {"sha": "571ad3ca8b9aa8f22c632829a1523509bdc9d6f1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -951,7 +951,6 @@ impl<'tcx> TraitPredicate<'tcx> {\n         // leads to more recompilation.\n         let def_ids: Vec<_> =\n             self.input_types()\n-                .iter()\n                 .flat_map(|t| t.walk())\n                 .filter_map(|t| match t.sty {\n                     ty::TyStruct(adt_def, _) |\n@@ -964,8 +963,8 @@ impl<'tcx> TraitPredicate<'tcx> {\n         DepNode::TraitSelect(self.def_id(), def_ids)\n     }\n \n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n-        &self.trait_ref.substs.types\n+    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>> {\n+        self.trait_ref.input_types()\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1107,7 +1106,7 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn walk_tys(&self) -> IntoIter<Ty<'tcx>> {\n         let vec: Vec<_> = match *self {\n             ty::Predicate::Trait(ref data) => {\n-                data.0.trait_ref.input_types().to_vec()\n+                data.skip_binder().input_types().cloned().collect()\n             }\n             ty::Predicate::Rfc1592(ref data) => {\n                 return data.walk_tys()\n@@ -1123,8 +1122,7 @@ impl<'tcx> Predicate<'tcx> {\n             }\n             ty::Predicate::Projection(ref data) => {\n                 let trait_inputs = data.0.projection_ty.trait_ref.input_types();\n-                trait_inputs.iter()\n-                            .cloned()\n+                trait_inputs.cloned()\n                             .chain(Some(data.0.ty))\n                             .collect()\n             }\n@@ -1206,15 +1204,15 @@ impl<'tcx> TraitRef<'tcx> {\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.substs.types[0]\n+        self.substs.type_at(0)\n     }\n \n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>> {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n-        &self.substs.types\n+        self.substs.types()\n     }\n }\n "}, {"sha": "481e8c97974ac741778fed547666c95186a3d24f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -147,14 +147,12 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n {\n     let tcx = relation.tcx();\n \n-    let types = a_subst.types.iter().enumerate().map(|(i, a_ty)| {\n-        let b_ty = &b_subst.types[i];\n+    let types = a_subst.types().zip(b_subst.types()).enumerate().map(|(i, (a_ty, b_ty))| {\n         let variance = variances.map_or(ty::Invariant, |v| v.types[i]);\n         relation.relate_with_variance(variance, a_ty, b_ty)\n     }).collect::<Result<_, _>>()?;\n \n-    let regions = a_subst.regions.iter().enumerate().map(|(i, a_r)| {\n-        let b_r = &b_subst.regions[i];\n+    let regions = a_subst.regions().zip(b_subst.regions()).enumerate().map(|(i, (a_r, b_r))| {\n         let variance = variances.map_or(ty::Invariant, |v| v.regions[i]);\n         relation.relate_with_variance(variance, a_r, b_r)\n     }).collect::<Result<_, _>>()?;"}, {"sha": "9ccf817a536246b78298806d6b84c748c03a4fd5", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use infer::type_variable;\n-use ty::subst::Substs;\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n@@ -692,22 +691,6 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let types = self.types.fold_with(folder);\n-        let regions = self.regions.fold_with(folder);\n-        Substs::new(folder.tcx(), types, regions)\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_substs(self)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.types.visit_with(visitor) || self.regions.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ClosureSubsts {"}, {"sha": "3f8d55b4634e028a092dd4539aa492a52808f7f2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -19,8 +19,9 @@ use util::common::ErrorReported;\n \n use collections::enum_set::{self, EnumSet, CLike};\n use std::fmt;\n-use std::ops;\n use std::mem;\n+use std::ops;\n+use std::slice;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::parse::token::keywords;\n@@ -335,7 +336,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n         self.0.substs\n     }\n \n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>> {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.input_types()\n     }\n@@ -360,12 +361,12 @@ pub struct ExistentialTraitRef<'tcx> {\n }\n \n impl<'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>>{\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n-        &self.substs.types\n+        self.substs.types()\n     }\n }\n \n@@ -376,7 +377,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n         self.0.def_id\n     }\n \n-    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>> {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.input_types()\n     }\n@@ -1213,19 +1214,19 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             }\n             TyTrait(ref obj) => {\n                 let mut v = vec![obj.region_bound];\n-                v.extend_from_slice(&obj.principal.skip_binder().substs.regions);\n+                v.extend(obj.principal.skip_binder().substs.regions());\n                 v\n             }\n             TyEnum(_, substs) |\n             TyStruct(_, substs) |\n             TyAnon(_, substs) => {\n-                substs.regions.to_vec()\n+                substs.regions().cloned().collect()\n             }\n             TyClosure(_, ref substs) => {\n-                substs.func_substs.regions.to_vec()\n+                substs.func_substs.regions().cloned().collect()\n             }\n             TyProjection(ref data) => {\n-                data.trait_ref.substs.regions.to_vec()\n+                data.trait_ref.substs.regions().cloned().collect()\n             }\n             TyFnDef(..) |\n             TyFnPtr(_) |"}, {"sha": "96f4bda361b6342d6ff9a0b214612f1612dedba7", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -13,18 +13,20 @@\n use middle::cstore;\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n \n+use std::slice;\n+\n ///////////////////////////////////////////////////////////////////////////\n \n /// A substitution mapping type/region parameters to new values.\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs<'tcx> {\n-    pub types: Vec<Ty<'tcx>>,\n-    pub regions: Vec<ty::Region>,\n+    types: Vec<Ty<'tcx>>,\n+    regions: Vec<ty::Region>,\n }\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n@@ -104,12 +106,34 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         self.regions.is_empty() && self.types.is_empty()\n     }\n \n+    #[inline]\n+    pub fn types(&self) -> slice::Iter<Ty<'tcx>> {\n+        self.types.iter()\n+    }\n+\n+    #[inline]\n+    pub fn regions(&self) -> slice::Iter<ty::Region> {\n+        self.regions.iter()\n+    }\n+\n+    #[inline]\n+    pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n+        self.types[i]\n+    }\n+\n+    #[inline]\n+    pub fn region_at(&self, i: usize) -> ty::Region {\n+        self.regions[i]\n+    }\n+\n+    #[inline]\n     pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        self.types[ty_param_def.index as usize]\n+        self.type_at(ty_param_def.index as usize)\n     }\n \n+    #[inline]\n     pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> ty::Region {\n-        self.regions[def.index as usize]\n+        self.region_at(def.index as usize)\n     }\n \n     /// Transform from substitutions for a child of `source_ancestor`\n@@ -130,6 +154,22 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let types = self.types.fold_with(folder);\n+        let regions = self.regions.fold_with(folder);\n+        Substs::new(folder.tcx(), types, regions)\n+    }\n+\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_substs(self)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.types.visit_with(visitor) || self.regions.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> Encodable for &'tcx Substs<'tcx> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         cstore::tls::with_encoding_context(s, |ecx, rbml_w| {"}, {"sha": "641dfa67c5b9ea999cf17eb7f8b703c68b9facb9", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -693,10 +693,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         return false;\n                     }\n \n-                    let types_a = &substs_a.types;\n-                    let types_b = &substs_b.types;\n-\n-                    types_a.iter().zip(types_b).all(|(&a, &b)| same_type(a, b))\n+                    substs_a.types().zip(substs_b.types()).all(|(&a, &b)| same_type(a, b))\n                 }\n                 _ => {\n                     a == b"}, {"sha": "5a94ba3cf6cd278f410b3ab39e9037ffd42f9f5f", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -79,7 +79,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             stack.push(mt.ty);\n         }\n         ty::TyProjection(ref data) => {\n-            push_reversed(stack, &data.trait_ref.substs.types);\n+            push_reversed(stack, data.trait_ref.substs.types());\n         }\n         ty::TyTrait(ref obj) => {\n             push_reversed(stack, obj.principal.input_types());\n@@ -90,17 +90,17 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n         ty::TyEnum(_, ref substs) |\n         ty::TyStruct(_, ref substs) |\n         ty::TyAnon(_, ref substs) => {\n-            push_reversed(stack, &substs.types);\n+            push_reversed(stack, substs.types());\n         }\n         ty::TyClosure(_, ref substs) => {\n-            push_reversed(stack, &substs.func_substs.types);\n-            push_reversed(stack, &substs.upvar_tys);\n+            push_reversed(stack, substs.func_substs.types());\n+            push_reversed(stack, substs.upvar_tys);\n         }\n-        ty::TyTuple(ref ts) => {\n+        ty::TyTuple(ts) => {\n             push_reversed(stack, ts);\n         }\n         ty::TyFnDef(_, substs, ref ft) => {\n-            push_reversed(stack, &substs.types);\n+            push_reversed(stack, substs.types());\n             push_sig_subtypes(stack, &ft.sig);\n         }\n         ty::TyFnPtr(ref ft) => {\n@@ -114,14 +114,17 @@ fn push_sig_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, sig: &ty::PolyFnSig<'tcx>)\n     push_reversed(stack, &sig.0.inputs);\n }\n \n-fn push_reversed<'tcx>(stack: &mut Vec<Ty<'tcx>>, tys: &[Ty<'tcx>]) {\n+fn push_reversed<'a, 'tcx: 'a, I>(stack: &mut Vec<Ty<'tcx>>, tys: I)\n+    where I: IntoIterator<Item=&'a Ty<'tcx>>,\n+          I::IntoIter: DoubleEndedIterator\n+{\n     // We push slices on the stack in reverse order so as to\n     // maintain a pre-order traversal. As of the time of this\n     // writing, the fact that the traversal is pre-order is not\n     // known to be significant to any code, but it seems like the\n     // natural order one would expect (basically, the order of the\n     // types as they are written).\n-    for &ty in tys.iter().rev() {\n+    for &ty in tys.into_iter().rev() {\n         stack.push(ty);\n     }\n }"}, {"sha": "e1a39e6957a49e3d35ff0f241cb890abaf6eb761", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -260,8 +260,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n         let cause = self.cause(traits::MiscObligation);\n         self.out.extend(\n-            trait_ref.substs.types\n-                            .iter()\n+            trait_ref.substs.types()\n                             .filter(|ty| !ty.has_escaping_regions())\n                             .map(|ty| traits::Obligation::new(cause.clone(),\n                                                               ty::Predicate::WellFormed(ty))));"}, {"sha": "c75fbf9579f5c07d0c58682a92a68b7bc6c67559", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -22,6 +22,8 @@ use ty::fold::{TypeFolder, TypeVisitor};\n \n use std::cell::Cell;\n use std::fmt;\n+use std::usize;\n+\n use syntax::abi::Abi;\n use syntax::parse::token;\n use syntax::ast::CRATE_NODE_ID;\n@@ -80,15 +82,17 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         verbose = tcx.sess.verbose();\n         has_self = generics.has_self;\n \n+        let mut child_types = 0;\n         if let Some(def_id) = generics.parent {\n             // Methods.\n             assert_eq!(ns, Ns::Value);\n+            child_types = generics.types.len();\n             generics = tcx.lookup_generics(def_id);\n             num_regions = generics.regions.len();\n             num_types = generics.types.len();\n \n             if has_self {\n-                write!(f, \"<{} as \", substs.types[0])?;\n+                write!(f, \"<{} as \", substs.type_at(0))?;\n             }\n \n             item_name = Some(tcx.item_name(did));\n@@ -107,8 +111,8 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         if !verbose {\n             if generics.types.last().map_or(false, |def| def.default.is_some()) {\n                 if let Some(substs) = tcx.lift(&substs) {\n-                    let tps = &substs.types[..num_types];\n-                    for (def, actual) in generics.types.iter().zip(tps).rev() {\n+                    let tps = substs.types().rev().skip(child_types);\n+                    for (def, actual) in generics.types.iter().rev().zip(tps) {\n                         if def.default.subst(tcx, substs) != Some(actual) {\n                             break;\n                         }\n@@ -124,7 +128,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n \n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args) = substs.types[1].sty {\n+        if let TyTuple(ref args) = substs.type_at(1).sty {\n             return fn_sig(f, args, false, projection_ty);\n         }\n     }\n@@ -139,13 +143,15 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         }\n     };\n \n-    let print_regions = |f: &mut fmt::Formatter, start: &str, regions: &[ty::Region]| {\n+    let print_regions = |f: &mut fmt::Formatter, start: &str, regions| {\n         // Don't print any regions if they're all erased.\n-        if regions.iter().all(|r| *r == ty::ReErased) {\n+        if Iterator::all(&mut Clone::clone(&regions),\n+                         |r: &ty::Region| *r == ty::ReErased) {\n             return Ok(());\n         }\n \n         for region in regions {\n+            let region: &ty::Region = region;\n             start_or_continue(f, start, \", \")?;\n             if verbose {\n                 write!(f, \"{:?}\", region)?;\n@@ -167,11 +173,12 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         Ok(())\n     };\n \n-    print_regions(f, \"<\", &substs.regions[..num_regions])?;\n+    print_regions(f, \"<\", substs.regions().take(num_regions).skip(0))?;\n \n-    let tps = &substs.types[..num_types];\n+    let tps = substs.types().take(num_types - num_supplied_defaults)\n+                            .skip(has_self as usize);\n \n-    for &ty in &tps[has_self as usize..tps.len() - num_supplied_defaults] {\n+    for &ty in tps {\n         start_or_continue(f, \"<\", \", \")?;\n         write!(f, \"{}\", ty)?;\n     }\n@@ -197,10 +204,10 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             write!(f, \"::{}\", item_name)?;\n         }\n \n-        print_regions(f, \"::<\", &substs.regions[num_regions..])?;\n+        print_regions(f, \"::<\", substs.regions().take(usize::MAX).skip(num_regions))?;\n \n         // FIXME: consider being smart with defaults here too\n-        for ty in &substs.types[num_types..] {\n+        for ty in substs.types().skip(num_types) {\n             start_or_continue(f, \"::<\", \", \")?;\n             write!(f, \"{}\", ty)?;\n         }\n@@ -368,13 +375,6 @@ impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for Substs<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Substs[types={:?}, regions={:?}]\",\n-               self.types, self.regions)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::ItemSubsts<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ItemSubsts({:?})\", self.substs)"}, {"sha": "10f503f4e3699a68861c0f4ec89ab7c70e2f79ed", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -251,11 +251,11 @@ fn enc_opt<T, F>(w: &mut Cursor<Vec<u8>>, t: Option<T>, enc_f: F) where\n pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                             substs: &Substs<'tcx>) {\n     write!(w, \"[\");\n-    for &r in &substs.regions {\n+    for &r in substs.regions() {\n         enc_region(w, cx, r);\n     }\n     write!(w, \"|\");\n-    for &ty in &substs.types {\n+    for &ty in substs.types() {\n         enc_ty(w, cx, ty);\n     }\n     write!(w, \"]\");"}, {"sha": "32c78ca4a5ad186e898adcbdbfa93318f6a357f8", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -543,7 +543,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n                 if let Literal::Item { def_id, substs } = constant.literal {\n                     // Don't peek inside generic (associated) constants.\n-                    if !substs.types.is_empty() {\n+                    if substs.types().next().is_some() {\n                         self.add_type(constant.ty);\n                     } else {\n                         let qualif = qualify_const_item_cached(self.tcx,"}, {"sha": "9b02cbe6721f34e6dd3118250373c1345240fa02", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -104,8 +104,9 @@ use util::sha2::{Digest, Sha256};\n use rustc::middle::{cstore, weak_lang_items};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n+use rustc::ty::subst::Substs;\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n \n use syntax::attr;\n@@ -126,14 +127,14 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                              // parameters substituted; this is\n                              // included in the hash as a kind of\n                              // safeguard.\n-                             item_type: ty::Ty<'tcx>,\n+                             item_type: Ty<'tcx>,\n \n                              // values for generic type parameters,\n                              // if any.\n-                             parameters: &[ty::Ty<'tcx>])\n+                             substs: Option<&Substs<'tcx>>)\n                              -> String {\n     debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n-           def_path, parameters);\n+           def_path, substs);\n \n     let tcx = scx.tcx();\n \n@@ -154,11 +155,13 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     hash_state.input(&encoded_item_type[..]);\n \n     // also include any type parameters (for generic items)\n-    for t in parameters {\n-       assert!(!t.has_erasable_regions());\n-       assert!(!t.needs_subst());\n-       let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n-       hash_state.input(&encoded_type[..]);\n+    if let Some(substs) = substs {\n+        for t in substs.types() {\n+            assert!(!t.has_erasable_regions());\n+            assert!(!t.needs_subst());\n+            let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n+            hash_state.input(&encoded_type[..]);\n+        }\n     }\n \n     return format!(\"h{}\", truncated_hash_result(&mut *hash_state));\n@@ -252,7 +255,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         // and should not matter anyhow.\n         let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n \n-        let hash = get_symbol_hash(scx, &def_path, instance_ty, &substs.types);\n+        let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n \n         let mut buffer = SymbolPathBuffer {\n             names: Vec::with_capacity(def_path.data.len())\n@@ -282,22 +285,22 @@ impl ItemPathBuffer for SymbolPathBuffer {\n }\n \n pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                                    t: ty::Ty<'tcx>,\n+                                                    t: Ty<'tcx>,\n                                                     prefix: &str)\n                                                     -> String {\n     let empty_def_path = DefPath {\n         data: vec![],\n         krate: cstore::LOCAL_CRATE,\n     };\n-    let hash = get_symbol_hash(scx, &empty_def_path, t, &[]);\n+    let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n     let path = [token::intern_and_get_ident(prefix)];\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n \n /// Only symbols that are invisible outside their compilation unit should use a\n /// name generated by this function.\n pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                    t: ty::Ty<'tcx>,\n+                                                    t: Ty<'tcx>,\n                                                     suffix: &str)\n                                                     -> String {\n     let path = [token::intern(&t.to_string()).as_str(),\n@@ -306,7 +309,7 @@ pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>\n         data: vec![],\n         krate: cstore::LOCAL_CRATE,\n     };\n-    let hash = get_symbol_hash(ccx.shared(), &def_path, t, &[]);\n+    let hash = get_symbol_hash(ccx.shared(), &def_path, t, None);\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n "}, {"sha": "a30f8f291a6775c676dc1527984b2b922c4e1314", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -400,9 +400,9 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"get_fn(def_id={:?}, substs={:?})\", def_id, substs);\n \n-    assert!(!substs.types.needs_infer());\n-    assert!(!substs.types.has_escaping_regions());\n-    assert!(!substs.types.has_param_types());\n+    assert!(!substs.needs_infer());\n+    assert!(!substs.has_escaping_regions());\n+    assert!(!substs.has_param_types());\n \n     let substs = tcx.normalize_associated_type(&substs);\n     let instance = Instance::new(def_id, substs);"}, {"sha": "5055ed86a038662de131f7215739becf79ab406e", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -265,7 +265,7 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n }\n \n pub fn validate_substs(substs: &Substs) {\n-    assert!(!substs.types.needs_infer());\n+    assert!(!substs.needs_infer());\n }\n \n // Function context.  Every LLVM function we create will have one of"}, {"sha": "49aa19557309fd9ef575e81021ee3a4a432d4f3f", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -342,11 +342,10 @@ impl<'tcx> TypeMap<'tcx> {\n             // Add the def-index as the second part\n             output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n \n-            let tps = &substs.types;\n-            if !tps.is_empty() {\n+            if substs.types().next().is_some() {\n                 output.push('<');\n \n-                for &type_parameter in tps {\n+                for &type_parameter in substs.types() {\n                     let param_type_id =\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id ="}, {"sha": "72a91f50be35e00554c85cb0d71f9c8ad5e68615", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -344,36 +344,34 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          generics: &ty::Generics<'tcx>,\n-                                         param_substs: &Substs<'tcx>,\n+                                         substs: &Substs<'tcx>,\n                                          file_metadata: DIFile,\n                                          name_to_append_suffix_to: &mut String)\n                                          -> DIArray\n     {\n-        let actual_types = &param_substs.types;\n-\n-        if actual_types.is_empty() {\n+        if substs.types().next().is_none() {\n             return create_DIArray(DIB(cx), &[]);\n         }\n \n         name_to_append_suffix_to.push('<');\n-        for (i, &actual_type) in actual_types.iter().enumerate() {\n+        for (i, &actual_type) in substs.types().enumerate() {\n+            if i != 0 {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n             let actual_type = cx.tcx().normalize_associated_type(&actual_type);\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n             name_to_append_suffix_to.push_str(&actual_type_name[..]);\n-\n-            if i != actual_types.len() - 1 {\n-                name_to_append_suffix_to.push_str(\",\");\n-            }\n         }\n         name_to_append_suffix_to.push('>');\n \n         // Again, only create type information if full debuginfo is enabled\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n             let names = get_type_parameter_names(cx, generics);\n-            actual_types.iter().zip(names).map(|(ty, name)| {\n+            substs.types().zip(names).map(|(ty, name)| {\n                 let actual_type = cx.tcx().normalize_associated_type(ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                 let name = CString::new(name.as_str().as_bytes()).unwrap();"}, {"sha": "9337f7e58ffcc7b8c34918d1cef53931ec5acbb4", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -175,13 +175,13 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   substs: &Substs<'tcx>,\n                                   output: &mut String) {\n-        if substs.types.is_empty() {\n+        if substs.types().next().is_none() {\n             return;\n         }\n \n         output.push('<');\n \n-        for &type_parameter in &substs.types {\n+        for &type_parameter in substs.types() {\n             push_debuginfo_type_name(cx, type_parameter, true, output);\n             output.push_str(\", \");\n         }"}, {"sha": "8bef7584db9e22639be49f5fd6ae451e1f96f468", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -146,12 +146,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             Call(bcx, llfn, &[], call_debug_location)\n         }\n         (_, \"size_of\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n         (_, \"size_of_val\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             if !type_is_sized(tcx, tp_ty) {\n                 let (llsize, _) =\n                     glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n@@ -162,11 +162,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n         (_, \"min_align_of\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             C_uint(ccx, type_of::align_of(ccx, tp_ty))\n         }\n         (_, \"min_align_of_val\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             if !type_is_sized(tcx, tp_ty) {\n                 let (_, llalign) =\n                     glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n@@ -176,12 +176,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n         (_, \"pref_align_of\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n         }\n         (_, \"drop_in_place\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let is_sized = type_is_sized(tcx, tp_ty);\n             let ptr = if is_sized {\n                 llargs[0]\n@@ -199,15 +199,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         }\n         (_, \"type_name\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let ty_name = token::intern_and_get_ident(&tp_ty.to_string());\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n-            C_u64(ccx, ccx.tcx().type_id_hash(substs.types[0]))\n+            C_u64(ccx, ccx.tcx().type_id_hash(substs.type_at(0)))\n         }\n         (_, \"init\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             if !type_is_zero_size(ccx, tp_ty) {\n                 // Just zero out the stack slot. (See comment on base::memzero for explanation)\n                 init_zero_mem(bcx, llresult, tp_ty);\n@@ -219,7 +219,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         }\n         (_, \"needs_drop\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n \n             C_bool(ccx, bcx.fcx.type_needs_drop(tp_ty))\n         }\n@@ -238,7 +238,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            false,\n                            false,\n-                           substs.types[0],\n+                           substs.type_at(0),\n                            llargs[1],\n                            llargs[0],\n                            llargs[2],\n@@ -248,7 +248,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            true,\n                            false,\n-                           substs.types[0],\n+                           substs.type_at(0),\n                            llargs[1],\n                            llargs[0],\n                            llargs[2],\n@@ -257,7 +257,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"write_bytes\") => {\n             memset_intrinsic(bcx,\n                              false,\n-                             substs.types[0],\n+                             substs.type_at(0),\n                              llargs[0],\n                              llargs[1],\n                              llargs[2],\n@@ -268,7 +268,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            false,\n                            true,\n-                           substs.types[0],\n+                           substs.type_at(0),\n                            llargs[0],\n                            llargs[1],\n                            llargs[2],\n@@ -278,7 +278,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            true,\n                            true,\n-                           substs.types[0],\n+                           substs.type_at(0),\n                            llargs[0],\n                            llargs[1],\n                            llargs[2],\n@@ -287,14 +287,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"volatile_set_memory\") => {\n             memset_intrinsic(bcx,\n                              true,\n-                             substs.types[0],\n+                             substs.type_at(0),\n                              llargs[0],\n                              llargs[1],\n                              llargs[2],\n                              call_debug_location)\n         }\n         (_, \"volatile_load\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             let mut ptr = llargs[0];\n             if let Some(ty) = fn_ty.ret.cast {\n                 ptr = PointerCast(bcx, ptr, ty.ptr_to());\n@@ -306,7 +306,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             to_immediate(bcx, load, tp_ty)\n         },\n         (_, \"volatile_store\") => {\n-            let tp_ty = substs.types[0];\n+            let tp_ty = substs.type_at(0);\n             if type_is_fat_ptr(bcx.tcx(), tp_ty) {\n                 VolatileStore(bcx, llargs[1], get_dataptr(bcx, llargs[0]));\n                 VolatileStore(bcx, llargs[2], get_meta(bcx, llargs[0]));\n@@ -406,7 +406,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         },\n \n         (_, \"discriminant_value\") => {\n-            let val_ty = substs.types[0];\n+            let val_ty = substs.type_at(0);\n             match val_ty.sty {\n                 ty::TyEnum(..) => {\n                     let repr = adt::represent_type(ccx, val_ty);\n@@ -458,7 +458,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n-                    let sty = &substs.types[0].sty;\n+                    let sty = &substs.type_at(0).sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n                         let val = AtomicCmpXchg(bcx, llargs[0], llargs[1], llargs[2],\n@@ -477,7 +477,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"load\" => {\n-                    let sty = &substs.types[0].sty;\n+                    let sty = &substs.type_at(0).sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicLoad(bcx, llargs[0], order)\n                     } else {\n@@ -490,7 +490,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"store\" => {\n-                    let sty = &substs.types[0].sty;\n+                    let sty = &substs.type_at(0).sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicStore(bcx, llargs[1], llargs[0], order);\n                     } else {\n@@ -529,7 +529,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let sty = &substs.types[0].sty;\n+                    let sty = &substs.type_at(0).sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n                     } else {"}, {"sha": "103afd827de934bd51651870b4f6533aad5f1026", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -307,7 +307,7 @@ pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  name: Name)\n                                  -> ImplMethod<'tcx>\n {\n-    assert!(!substs.types.needs_infer());\n+    assert!(!substs.needs_infer());\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);"}, {"sha": "0ffb83067f91c57389070d4097a190ac12307f10", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n impl<'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n                -> Instance<'tcx> {\n-        assert!(substs.regions.iter().all(|&r| r == ty::ReErased));\n+        assert!(substs.regions().all(|&r| r == ty::ReErased));\n         Instance { def: def_id, substs: substs }\n     }\n     pub fn mono<'a>(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {"}, {"sha": "7341e8db41de5bf4e83b3c1ea29924a94836cd8a", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -342,7 +342,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         TransItem::DropGlue(..) => unreachable!(),\n                         // Is there any benefit to using ExternalLinkage?:\n                         TransItem::Fn(ref instance) => {\n-                            if instance.substs.types.is_empty() {\n+                            if instance.substs.types().next().is_none() {\n                                 // This is a non-generic functions, we always\n                                 // make it visible externally on the chance that\n                                 // it might be used in another codegen unit.\n@@ -487,7 +487,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // DefId, we use the location of the impl after all.\n \n             if tcx.trait_of_item(instance.def).is_some() {\n-                let self_ty = instance.substs.types[0];\n+                let self_ty = instance.substs.type_at(0);\n                 // This is an implementation of a trait method.\n                 return characteristic_def_id_of_type(self_ty).or(Some(instance.def));\n             }"}, {"sha": "93302ab3b3be193db1fd388b09709591e9cefb00", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -171,8 +171,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                     instance: Instance<'tcx>,\n                     linkage: llvm::Linkage,\n                     symbol_name: &str) {\n-        assert!(!instance.substs.types.needs_infer() &&\n-                !instance.substs.types.has_param_types());\n+        assert!(!instance.substs.needs_infer() &&\n+                !instance.substs.has_param_types());\n \n         let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n         let item_ty = ccx.tcx().erase_regions(&item_ty);\n@@ -244,7 +244,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         match *self {\n             TransItem::Fn(ref instance) => {\n-                !instance.substs.types.is_empty() || {\n+                instance.substs.types().next().is_some() || {\n                     let attributes = tcx.get_attrs(instance.def);\n                     attr::requests_inline(&attributes[..])\n                 }\n@@ -264,16 +264,19 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn is_instantiated_only_on_demand(&self) -> bool {\n         match *self {\n-            TransItem::Fn(ref instance) => !instance.def.is_local() ||\n-                                           !instance.substs.types.is_empty(),\n+            TransItem::Fn(ref instance) => {\n+                !instance.def.is_local() || instance.substs.types().next().is_some()\n+            }\n             TransItem::DropGlue(..) => true,\n             TransItem::Static(..)   => false,\n         }\n     }\n \n     pub fn is_generic_fn(&self) -> bool {\n         match *self {\n-            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n+            TransItem::Fn(ref instance) => {\n+                instance.substs.types().next().is_some()\n+            }\n             TransItem::DropGlue(..) |\n             TransItem::Static(..)   => false,\n         }\n@@ -374,7 +377,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       t: ty::Ty<'tcx>,\n+                                       t: Ty<'tcx>,\n                                        output: &mut String) {\n     match t.sty {\n         ty::TyBool              => output.push_str(\"bool\"),\n@@ -396,7 +399,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyStruct(adt_def, substs) |\n         ty::TyEnum(adt_def, substs) => {\n             push_item_name(tcx, adt_def.did, output);\n-            push_type_params(tcx, &substs.types, &[], output);\n+            push_type_params(tcx, substs, &[], output);\n         },\n         ty::TyTuple(component_types) => {\n             output.push('(');\n@@ -446,7 +449,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyTrait(ref trait_data) => {\n             push_item_name(tcx, trait_data.principal.def_id(), output);\n             push_type_params(tcx,\n-                             &trait_data.principal.skip_binder().substs.types,\n+                             trait_data.principal.skip_binder().substs,\n                              &trait_data.projection_bounds,\n                              output);\n         },\n@@ -494,7 +497,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             output.push_str(\"{\");\n             output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n             output.push_str(\"}\");\n-            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n+            push_type_params(tcx, closure_substs.func_substs, &[], output);\n         }\n         ty::TyError |\n         ty::TyInfer(_) |\n@@ -529,16 +532,16 @@ fn push_item_name(tcx: TyCtxt,\n }\n \n fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              types: &[Ty<'tcx>],\n+                              substs: &Substs<'tcx>,\n                               projections: &[ty::PolyExistentialProjection<'tcx>],\n                               output: &mut String) {\n-    if types.is_empty() && projections.is_empty() {\n+    if substs.types().next().is_none() && projections.is_empty() {\n         return;\n     }\n \n     output.push('<');\n \n-    for &type_parameter in types {\n+    for &type_parameter in substs.types() {\n         push_unique_type_name(tcx, type_parameter, output);\n         output.push_str(\", \");\n     }\n@@ -562,7 +565,7 @@ fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      instance: Instance<'tcx>,\n                                      output: &mut String) {\n     push_item_name(tcx, instance.def, output);\n-    push_type_params(tcx, &instance.substs.types, &[], output);\n+    push_type_params(tcx, instance.substs, &[], output);\n }\n \n pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n@@ -572,7 +575,7 @@ pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n }\n \n pub fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                ty: ty::Ty<'tcx>)\n+                                ty: Ty<'tcx>)\n                                 -> String {\n     let mut output = String::new();\n     push_unique_type_name(tcx, ty, &mut output);"}, {"sha": "b47d2cd0f204b8d37ad9327f6bd18916b5b8d140", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -17,6 +17,7 @@ use common::*;\n use machine;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::subst::Substs;\n \n use type_::Type;\n \n@@ -256,7 +257,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n           let repr = adt::represent_type(cx, t);\n-          let name = llvm_type_name(cx, def.did, &substs.types);\n+          let name = llvm_type_name(cx, def.did, substs);\n           adt::incomplete_type_of(cx, &repr, &name[..])\n       }\n       ty::TyClosure(..) => {\n@@ -330,7 +331,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n-              let name = llvm_type_name(cx, def.did, &substs.types);\n+              let name = llvm_type_name(cx, def.did, substs);\n               adt::incomplete_type_of(cx, &repr, &name[..])\n           }\n       }\n@@ -367,10 +368,10 @@ pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n \n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             did: DefId,\n-                            tps: &[Ty<'tcx>])\n+                            substs: &Substs<'tcx>)\n                             -> String {\n     let base = cx.tcx().item_path_str(did);\n-    let strings: Vec<String> = tps.iter().map(|t| t.to_string()).collect();\n+    let strings: Vec<String> = substs.types().map(|t| t.to_string()).collect();\n     let tstr = if strings.is_empty() {\n         base\n     } else {"}, {"sha": "72f81c7d48da88d5d59b4d93dfe4cdb25e19be35", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -937,8 +937,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // FIXME(#12938): This is a hack until we have full support for DST.\n         if Some(did) == self.tcx().lang_items.owned_box() {\n-            assert_eq!(substs.types.len(), 1);\n-            return self.tcx().mk_box(substs.types[0]);\n+            assert_eq!(substs.types().count(), 1);\n+            return self.tcx().mk_box(substs.type_at(0));\n         }\n \n         decl_ty.subst(self.tcx(), substs)"}, {"sha": "46e8c27f6d33bbb38e77cc13d249af197c11c99e", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        let arg_param_ty = trait_ref.substs().types[1];\n+        let arg_param_ty = trait_ref.substs().type_at(1);\n         let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n         debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n "}, {"sha": "4e48838f85cfb97925c43c16268dfebf13b63c79", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -438,7 +438,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n \n         ty::TyStruct(def, substs) if def.is_phantom_data() => {\n             // PhantomData<T> - behaves identically to T\n-            let ity = substs.types[0];\n+            let ity = substs.type_at(0);\n             iterate_over_potentially_unsafe_regions_in_type(\n                 cx, context, ity, depth+1)\n         }"}, {"sha": "8b757309f488726422058bd5f750e6e150247c87", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -328,18 +328,20 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         //\n         // FIXME -- permit users to manually specify lifetimes\n         Substs::for_item(self.tcx, method.def_id, |def, _| {\n-            if let Some(&r) = substs.regions.get(def.index as usize) {\n-                r\n+            let i = def.index as usize;\n+            if i < substs.regions().count() {\n+                substs.region_at(i)\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n         }, |def, cur_substs| {\n-            if let Some(&ty) = substs.types.get(def.index as usize) {\n-                ty\n+            let i = def.index as usize;\n+            if i < substs.types().count() {\n+                substs.type_at(i)\n             } else if supplied_method_types.is_empty() {\n                 self.type_var_for_def(self.span, def, cur_substs)\n             } else {\n-                supplied_method_types[def.index as usize - substs.types.len()]\n+                supplied_method_types[i - substs.types().count()]\n             }\n         })\n     }"}, {"sha": "d8ff9b4057f34f8b48f7b9a4786e0f1ab8414e8f", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -519,17 +519,17 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                        trait_ref.substs,\n                        m);\n                 assert_eq!(m.generics.parent_types as usize,\n-                           trait_ref.substs.types.len());\n+                           trait_ref.substs.types().count());\n                 assert_eq!(m.generics.parent_regions as usize,\n-                           trait_ref.substs.regions.len());\n+                           trait_ref.substs.regions().count());\n             }\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n             // artifacts. This means it is safe to put into the\n             // `WhereClauseCandidate` and (eventually) into the\n             // `WhereClausePick`.\n-            assert!(!trait_ref.substs.types.needs_infer());\n+            assert!(!trait_ref.substs.needs_infer());\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -1220,8 +1220,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        assert_eq!(substs.types.len(), method.generics.parent_types as usize);\n-        assert_eq!(substs.regions.len(), method.generics.parent_regions as usize);\n+        assert_eq!(substs.types().count(), method.generics.parent_types as usize);\n+        assert_eq!(substs.regions().count(), method.generics.parent_regions as usize);\n \n         if self.mode == Mode::Path {\n             return impl_ty;\n@@ -1236,16 +1236,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             xform_self_ty.subst(self.tcx, substs)\n         } else {\n             let substs = Substs::for_item(self.tcx, method.def_id, |def, _| {\n-                if let Some(&r) = substs.regions.get(def.index as usize) {\n-                    r\n+                let i = def.index as usize;\n+                if i < substs.regions().count() {\n+                    substs.region_at(i)\n                 } else {\n                     // In general, during probe we erase regions. See\n                     // `impl_self_ty()` for an explanation.\n                     ty::ReErased\n                 }\n             }, |def, cur_substs| {\n-                if let Some(&ty) = substs.types.get(def.index as usize) {\n-                    ty\n+                let i = def.index as usize;\n+                if i < substs.types().count() {\n+                    substs.type_at(i)\n                 } else {\n                     self.type_var_for_def(self.span, def, cur_substs)\n                 }\n@@ -1324,7 +1326,7 @@ impl<'tcx> Candidate<'tcx> {\n                     // inference variables or other artifacts. This\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n-                    assert!(!trait_ref.substs().types.needs_infer());\n+                    assert!(!trait_ref.substs().needs_infer());\n \n                     WhereClausePick(trait_ref.clone())\n                 }"}, {"sha": "f2ed3e37c1a287d111b4cf85e88b91cda29e3708", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -1899,7 +1899,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Registers obligations that all types appearing in `substs` are well-formed.\n     pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr)\n     {\n-        for &ty in &substs.types {\n+        for &ty in substs.types() {\n             self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n         }\n     }"}, {"sha": "a596b3cdcbb81d22c622b5e994d1ae7bb6dcbc25", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -1445,11 +1445,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let origin = infer::ParameterInScope(origin, expr_span);\n \n-        for &region in &substs.regions {\n+        for &region in substs.regions() {\n             self.sub_regions(origin.clone(), expr_region, region);\n         }\n \n-        for &ty in &substs.types {\n+        for &ty in substs.types() {\n             let ty = self.resolve_type(ty);\n             self.type_must_outlive(origin.clone(), ty, expr_region);\n         }\n@@ -1575,11 +1575,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         if env_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n-            for &component_ty in &projection_ty.trait_ref.substs.types {\n+            for &component_ty in projection_ty.trait_ref.substs.types() {\n                 self.type_must_outlive(origin.clone(), component_ty, region);\n             }\n \n-            for &r in &projection_ty.trait_ref.substs.regions {\n+            for &r in projection_ty.trait_ref.substs.regions() {\n                 self.sub_regions(origin.clone(), region, r);\n             }\n \n@@ -1597,10 +1597,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n             let unique_bound = env_bounds[0];\n             debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n-            if projection_ty.trait_ref.substs.regions\n-                                             .iter()\n-                                             .any(|r| env_bounds.contains(r))\n-            {\n+            if projection_ty.trait_ref.substs.regions().any(|r| env_bounds.contains(r)) {\n                 debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n                 self.sub_regions(origin.clone(), region, unique_bound);\n                 return;"}, {"sha": "ecec4913fb7dc6c32c4247968e8b0b1305fc26bc", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -597,7 +597,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Trait impl: take implied bounds from all types that\n                 // appear in the trait reference.\n                 let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n-                trait_ref.substs.types.to_vec()\n+                trait_ref.substs.types().cloned().collect()\n             }\n \n             None => {"}, {"sha": "3e5623404ed3599401470e21eb63f5e4bc46c62d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -103,7 +103,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n \n         let free_substs = fcx.parameter_environment.free_substs;\n-        for (i, r) in free_substs.regions.iter().enumerate() {\n+        for (i, r) in free_substs.regions().enumerate() {\n             match *r {\n                 ty::ReFree(ty::FreeRegion {\n                     bound_region: ty::BoundRegion::BrNamed(def_id, name, _), .."}, {"sha": "4362e040d2661e1a889437d958ef684593f6b8db", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n             let source = tcx.lookup_item_type(impl_did).ty;\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n-            let target = trait_ref.substs.types[1];\n+            let target = trait_ref.substs.type_at(1);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n                    source, target);\n "}, {"sha": "2a989105c9cb49b258c80d1f76e5fd0dd8c8dd21", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -172,7 +172,7 @@ fn write_substs_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                node_id,\n                item_substs);\n \n-        assert!(!item_substs.substs.types.needs_infer());\n+        assert!(!item_substs.substs.needs_infer());\n \n         ccx.tcx.tables.borrow_mut().item_substs.insert(node_id, item_substs);\n     }"}, {"sha": "51a697dad2fd66d6c52313b9fb6fa47bb63f5945", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "patch": "@@ -642,8 +642,8 @@ impl Clean<TyParamBound> for hir::TyParamBound {\n \n fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n                         bindings: Vec<TypeBinding>, substs: &Substs) -> PathParameters {\n-    let lifetimes = substs.regions.iter().filter_map(|v| v.clean(cx)).collect();\n-    let types = substs.types[has_self as usize..].to_vec();\n+    let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n+    let types = substs.types().skip(has_self as usize).cloned().collect::<Vec<_>>();\n \n     match (trait_did, cx.tcx_opt()) {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n@@ -737,12 +737,11 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         let path = external_path(cx, &tcx.item_name(self.def_id).as_str(),\n                                  Some(self.def_id), true, vec![], self.substs);\n \n-        debug!(\"ty::TraitRef\\n  substs.types: {:?}\\n\",\n-               &self.input_types()[1..]);\n+        debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", self.substs);\n \n         // collect any late bound regions\n         let mut late_bounds = vec![];\n-        for &ty_s in &self.input_types()[1..] {\n+        for &ty_s in self.input_types().skip(1) {\n             if let ty::TyTuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n                     if let ty::TyRef(ref reg, _) = ty_s.sty {\n@@ -775,9 +774,9 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n impl<'tcx> Clean<Option<Vec<TyParamBound>>> for Substs<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n-        v.extend(self.regions.iter().filter_map(|r| r.clean(cx))\n+        v.extend(self.regions().filter_map(|r| r.clean(cx))\n                      .map(RegionBound));\n-        v.extend(self.types.iter().map(|t| TraitBound(PolyTrait {\n+        v.extend(self.types().map(|t| TraitBound(PolyTrait {\n             trait_: t.clean(cx),\n             lifetimes: vec![]\n         }, hir::TraitBoundModifier::None)));"}]}