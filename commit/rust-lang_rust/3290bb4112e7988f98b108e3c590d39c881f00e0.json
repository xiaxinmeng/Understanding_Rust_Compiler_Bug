{"sha": "3290bb4112e7988f98b108e3c590d39c881f00e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOTBiYjQxMTJlNzk4OGY5OGIxMDhlM2M1OTBkMzljODgxZjAwZTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-10-02T18:52:48Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-10-02T18:52:48Z"}, "message": "Simplify ast_transform", "tree": {"sha": "4e8effd1f7c43cfd29d0a8ec3b951fe0e26c6c01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e8effd1f7c43cfd29d0a8ec3b951fe0e26c6c01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3290bb4112e7988f98b108e3c590d39c881f00e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3290bb4112e7988f98b108e3c590d39c881f00e0", "html_url": "https://github.com/rust-lang/rust/commit/3290bb4112e7988f98b108e3c590d39c881f00e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3290bb4112e7988f98b108e3c590d39c881f00e0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "673e1ddb9ae12c565f966549ba7ea8c306cfba87", "url": "https://api.github.com/repos/rust-lang/rust/commits/673e1ddb9ae12c565f966549ba7ea8c306cfba87", "html_url": "https://github.com/rust-lang/rust/commit/673e1ddb9ae12c565f966549ba7ea8c306cfba87"}], "stats": {"total": 74, "additions": 34, "deletions": 40}, "files": [{"sha": "4307e019188509d24643dfe04ada94ca1227e97e", "filename": "crates/assists/src/ast_transform.rs", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3290bb4112e7988f98b108e3c590d39c881f00e0/crates%2Fassists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3290bb4112e7988f98b108e3c590d39c881f00e0/crates%2Fassists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fast_transform.rs?ref=3290bb4112e7988f98b108e3c590d39c881f00e0", "patch": "@@ -5,12 +5,13 @@ use hir::{HirDisplay, PathResolution, SemanticsScope};\n use syntax::{\n     algo::SyntaxRewriter,\n     ast::{self, AstNode},\n+    SyntaxNode,\n };\n \n pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n     SyntaxRewriter::from_fn(|element| match element {\n         syntax::SyntaxElement::Node(n) => {\n-            let replacement = transformer.get_substitution(&n)?;\n+            let replacement = transformer.get_substitution(&n, transformer)?;\n             Some(replacement.into())\n         }\n         _ => None,\n@@ -47,32 +48,35 @@ pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n /// We'd want to somehow express this concept simpler, but so far nobody got to\n /// simplifying this!\n pub trait AstTransform<'a> {\n-    fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode>;\n+    fn get_substitution(\n+        &self,\n+        node: &SyntaxNode,\n+        recur: &dyn AstTransform<'a>,\n+    ) -> Option<SyntaxNode>;\n \n-    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a>;\n     fn or<T: AstTransform<'a> + 'a>(self, other: T) -> Box<dyn AstTransform<'a> + 'a>\n     where\n         Self: Sized + 'a,\n     {\n-        self.chain_before(Box::new(other))\n+        Box::new(Or(Box::new(self), Box::new(other)))\n     }\n }\n \n-struct NullTransformer;\n+struct Or<'a>(Box<dyn AstTransform<'a> + 'a>, Box<dyn AstTransform<'a> + 'a>);\n \n-impl<'a> AstTransform<'a> for NullTransformer {\n-    fn get_substitution(&self, _node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n-        None\n-    }\n-    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n-        other\n+impl<'a> AstTransform<'a> for Or<'a> {\n+    fn get_substitution(\n+        &self,\n+        node: &SyntaxNode,\n+        recur: &dyn AstTransform<'a>,\n+    ) -> Option<SyntaxNode> {\n+        self.0.get_substitution(node, recur).or_else(|| self.1.get_substitution(node, recur))\n     }\n }\n \n pub struct SubstituteTypeParams<'a> {\n     source_scope: &'a SemanticsScope<'a>,\n     substs: FxHashMap<hir::TypeParam, ast::Type>,\n-    previous: Box<dyn AstTransform<'a> + 'a>,\n }\n \n impl<'a> SubstituteTypeParams<'a> {\n@@ -111,11 +115,7 @@ impl<'a> SubstituteTypeParams<'a> {\n                 }\n             })\n             .collect();\n-        return SubstituteTypeParams {\n-            source_scope,\n-            substs: substs_by_param,\n-            previous: Box::new(NullTransformer),\n-        };\n+        return SubstituteTypeParams { source_scope, substs: substs_by_param };\n \n         // FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n         // trait ref, and then go from the types in the substs back to the syntax).\n@@ -140,7 +140,14 @@ impl<'a> SubstituteTypeParams<'a> {\n             Some(result)\n         }\n     }\n-    fn get_substitution_inner(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n+}\n+\n+impl<'a> AstTransform<'a> for SubstituteTypeParams<'a> {\n+    fn get_substitution(\n+        &self,\n+        node: &SyntaxNode,\n+        _recur: &dyn AstTransform<'a>,\n+    ) -> Option<SyntaxNode> {\n         let type_ref = ast::Type::cast(node.clone())?;\n         let path = match &type_ref {\n             ast::Type::PathType(path_type) => path_type.path()?,\n@@ -154,27 +161,23 @@ impl<'a> SubstituteTypeParams<'a> {\n     }\n }\n \n-impl<'a> AstTransform<'a> for SubstituteTypeParams<'a> {\n-    fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n-        self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n-    }\n-    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n-        Box::new(SubstituteTypeParams { previous: other, ..self })\n-    }\n-}\n-\n pub struct QualifyPaths<'a> {\n     target_scope: &'a SemanticsScope<'a>,\n     source_scope: &'a SemanticsScope<'a>,\n-    previous: Box<dyn AstTransform<'a> + 'a>,\n }\n \n impl<'a> QualifyPaths<'a> {\n     pub fn new(target_scope: &'a SemanticsScope<'a>, source_scope: &'a SemanticsScope<'a>) -> Self {\n-        Self { target_scope, source_scope, previous: Box::new(NullTransformer) }\n+        Self { target_scope, source_scope }\n     }\n+}\n \n-    fn get_substitution_inner(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n+impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n+    fn get_substitution(\n+        &self,\n+        node: &SyntaxNode,\n+        recur: &dyn AstTransform<'a>,\n+    ) -> Option<SyntaxNode> {\n         // FIXME handle value ns?\n         let from = self.target_scope.module()?;\n         let p = ast::Path::cast(node.clone())?;\n@@ -191,7 +194,7 @@ impl<'a> QualifyPaths<'a> {\n                 let type_args = p\n                     .segment()\n                     .and_then(|s| s.generic_arg_list())\n-                    .map(|arg_list| apply(self, arg_list));\n+                    .map(|arg_list| apply(recur, arg_list));\n                 if let Some(type_args) = type_args {\n                     let last_segment = path.segment().unwrap();\n                     path = path.with_segment(last_segment.with_generic_args(type_args))\n@@ -208,15 +211,6 @@ impl<'a> QualifyPaths<'a> {\n     }\n }\n \n-impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n-    fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n-        self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n-    }\n-    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n-        Box::new(QualifyPaths { previous: other, ..self })\n-    }\n-}\n-\n pub(crate) fn path_to_ast(path: hir::ModPath) -> ast::Path {\n     let parse = ast::SourceFile::parse(&path.to_string());\n     parse"}]}