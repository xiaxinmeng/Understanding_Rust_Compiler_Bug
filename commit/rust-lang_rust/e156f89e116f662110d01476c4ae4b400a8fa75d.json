{"sha": "e156f89e116f662110d01476c4ae4b400a8fa75d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNTZmODllMTE2ZjY2MjExMGQwMTQ3NmM0YWU0YjQwMGE4ZmE3NWQ=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-11-01T15:46:17Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-11-08T17:47:39Z"}, "message": "Add reftest that checks the layout of repr(int) on non-c-like enums\n\nThis verifies the layout specified in rfc #2195", "tree": {"sha": "9fb3c857cedc6fbccccca8e801a0924782b73cd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb3c857cedc6fbccccca8e801a0924782b73cd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e156f89e116f662110d01476c4ae4b400a8fa75d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e156f89e116f662110d01476c4ae4b400a8fa75d", "html_url": "https://github.com/rust-lang/rust/commit/e156f89e116f662110d01476c4ae4b400a8fa75d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e156f89e116f662110d01476c4ae4b400a8fa75d/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f581cf9d692781847bede5d966b098a5d09b5e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f581cf9d692781847bede5d966b098a5d09b5e4", "html_url": "https://github.com/rust-lang/rust/commit/2f581cf9d692781847bede5d966b098a5d09b5e4"}], "stats": {"total": 173, "additions": 173, "deletions": 0}, "files": [{"sha": "6e147b00ef9afecf0d26080a8d112c4b12151257", "filename": "src/test/run-pass/enum-non-c-like-repr-int.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/e156f89e116f662110d01476c4ae4b400a8fa75d/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e156f89e116f662110d01476c4ae4b400a8fa75d/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-int.rs?ref=e156f89e116f662110d01476c4ae4b400a8fa75d", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test deserializes an enum in-place by transmuting to a union that\n+// should have the same layout, and manipulating the tag and payloads\n+// independently. This verifies that `repr(some_int)` has a stable representation,\n+// and that we don't miscompile these kinds of manipulations.\n+\n+use std::time::Duration;\n+use std::mem;\n+\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+enum MyEnum {\n+    A(u32),                 // Single primitive value\n+    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n+    C,                      // Empty\n+    D(Option<u32>),         // Contains an enum\n+    E(Duration),            // Contains a struct\n+}\n+\n+#[allow(non_snake_case)]\n+#[repr(C)]\n+union MyEnumRepr {\n+    A: MyEnumVariantA,\n+    B: MyEnumVariantB,\n+    C: MyEnumVariantC,\n+    D: MyEnumVariantD,\n+    E: MyEnumVariantE,\n+}\n+\n+#[repr(u8)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(MyEnumTag, u32);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB { tag: MyEnumTag, x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantC(MyEnumTag);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(MyEnumTag, Option<u32>);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(MyEnumTag, Duration);\n+\n+fn main() {\n+    let result: Vec<Result<MyEnum, ()>> = vec![\n+        Ok(MyEnum::A(17)),\n+        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::C),\n+        Err(()),\n+        Ok(MyEnum::D(Some(407))),\n+        Ok(MyEnum::D(None)),\n+        Ok(MyEnum::E(Duration::from_secs(100))),\n+        Err(()),\n+    ];\n+\n+    // Binary serialized version of the above (little-endian)\n+    let input: Vec<u8> = vec![\n+        0,  17, 0, 0, 0,\n+        1,  206,  121, 4,\n+        2,\n+        8,  /* invalid tag value */\n+        3,  0,  151, 1, 0, 0,\n+        3,  1,\n+        4,  100, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,\n+        0,  /* incomplete value */\n+    ];\n+\n+    let mut output = vec![];\n+    let mut buf = &input[..];\n+\n+    unsafe {\n+        // This should be safe, because we don't match on it unless it's fully formed,\n+        // and it doesn't have a destructor.\n+        let mut dest: MyEnum = mem::uninitialized();\n+        while buf.len() > 0 {\n+            match parse_my_enum(&mut dest, &mut buf) {\n+                Ok(()) => output.push(Ok(dest)),\n+                Err(()) => output.push(Err(())),\n+            }\n+        }\n+    }\n+\n+    assert_eq!(output, result);\n+}\n+\n+fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n+    unsafe {\n+        // Should be correct to do this transmute.\n+        let dest: &'a mut MyEnumRepr = mem::transmute(dest);\n+        let tag = read_u8(buf)?;\n+\n+        dest.A.0 = match tag {\n+            0 => MyEnumTag::A,\n+            1 => MyEnumTag::B,\n+            2 => MyEnumTag::C,\n+            3 => MyEnumTag::D,\n+            4 => MyEnumTag::E,\n+            _ => return Err(()),\n+        };\n+\n+        match dest.B.tag {\n+            MyEnumTag::A => {\n+                dest.A.1 = read_u32_le(buf)?;\n+            }\n+            MyEnumTag::B => {\n+                dest.B.x = read_u8(buf)?;\n+                dest.B.y = read_u16_le(buf)? as i16;\n+            }\n+            MyEnumTag::C => {\n+                /* do nothing */\n+            }\n+            MyEnumTag::D => {\n+                let is_some = read_u8(buf)? == 0;\n+                if is_some {\n+                    dest.D.1 = Some(read_u32_le(buf)?);\n+                } else {\n+                    dest.D.1 = None;\n+                }\n+            }\n+            MyEnumTag::E => {\n+                let secs = read_u64_le(buf)?;\n+                let nanos = read_u32_le(buf)?;\n+                dest.E.1 = Duration::new(secs, nanos);\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+\n+\n+// reader helpers\n+\n+fn read_u64_le(buf: &mut &[u8]) -> Result<u64, ()> {\n+    if buf.len() < 8 { return Err(()) }\n+    let val = (buf[0] as u64) << 0\n+            | (buf[1] as u64) << 8\n+            | (buf[2] as u64) << 16\n+            | (buf[3] as u64) << 24\n+            | (buf[4] as u64) << 32\n+            | (buf[5] as u64) << 40\n+            | (buf[6] as u64) << 48\n+            | (buf[7] as u64) << 56;\n+    *buf = &buf[8..];\n+    Ok(val)\n+}\n+\n+fn read_u32_le(buf: &mut &[u8]) -> Result<u32, ()> {\n+    if buf.len() < 4 { return Err(()) }\n+    let val = (buf[0] as u32) << 0\n+            | (buf[1] as u32) << 8\n+            | (buf[2] as u32) << 16\n+            | (buf[3] as u32) << 24;\n+    *buf = &buf[4..];\n+    Ok(val)\n+}\n+\n+fn read_u16_le(buf: &mut &[u8]) -> Result<u16, ()> {\n+    if buf.len() < 2 { return Err(()) }\n+    let val = (buf[0] as u16) << 0\n+            | (buf[1] as u16) << 8;\n+    *buf = &buf[2..];\n+    Ok(val)\n+}\n+\n+fn read_u8(buf: &mut &[u8]) -> Result<u8, ()> {\n+    if buf.len() < 1 { return Err(()) }\n+    let val = buf[0];\n+    *buf = &buf[1..];\n+    Ok(val)\n+}"}]}