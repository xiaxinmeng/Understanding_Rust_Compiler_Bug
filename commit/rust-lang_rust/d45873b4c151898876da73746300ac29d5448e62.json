{"sha": "d45873b4c151898876da73746300ac29d5448e62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NTg3M2I0YzE1MTg5ODg3NmRhNzM3NDYzMDBhYzI5ZDU0NDhlNjI=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-16T16:06:41Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-16T16:27:21Z"}, "message": "Remove SmallVec", "tree": {"sha": "2af6e22ec52aee51f48347922f48f6c0fe4c9b86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2af6e22ec52aee51f48347922f48f6c0fe4c9b86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d45873b4c151898876da73746300ac29d5448e62", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmBQ3HEACgkQ2lnoZDo37QZXxAD+LNQMflBnmhE1CGBTDDXBkqjf\nZJoSLiKpmw0zM4vTgOEBAMZdFobcJV7wAWyPCr8v9DqaQUEm2l2yyLRJqlZkGYAF\n=yc9c\n-----END PGP SIGNATURE-----", "payload": "tree 2af6e22ec52aee51f48347922f48f6c0fe4c9b86\nparent a7fa2a6fa88477ab2542bb15347e3085d9547f95\nauthor Jason Newcomb <jsnewcomb@pm.me> 1615910801 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1615912041 -0400\n\nRemove SmallVec\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d45873b4c151898876da73746300ac29d5448e62", "html_url": "https://github.com/rust-lang/rust/commit/d45873b4c151898876da73746300ac29d5448e62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d45873b4c151898876da73746300ac29d5448e62/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7fa2a6fa88477ab2542bb15347e3085d9547f95", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7fa2a6fa88477ab2542bb15347e3085d9547f95", "html_url": "https://github.com/rust-lang/rust/commit/a7fa2a6fa88477ab2542bb15347e3085d9547f95"}], "stats": {"total": 42, "additions": 24, "deletions": 18}, "files": [{"sha": "12a47a6b7036d9a3e1e707b05066f7200f360979", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d45873b4c151898876da73746300ac29d5448e62/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45873b4c151898876da73746300ac29d5448e62/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=d45873b4c151898876da73746300ac29d5448e62", "patch": "@@ -14,7 +14,6 @@ use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{sym, BytePos, Span, DUMMY_SP};\n-use smallvec::SmallVec;\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -359,8 +358,8 @@ fn newline_span(fmtstr: &StrLit) -> Span {\n /// empty format string.\n #[derive(Default)]\n struct SimpleFormatArgs {\n-    unnamed: Vec<SmallVec<[Span; 1]>>,\n-    named: Vec<(Symbol, SmallVec<[Span; 1]>)>,\n+    unnamed: Vec<Vec<Span>>,\n+    named: Vec<(Symbol, Vec<Span>)>,\n }\n impl SimpleFormatArgs {\n     fn get_unnamed(&self) -> impl Iterator<Item = &[Span]> {\n@@ -396,11 +395,11 @@ impl SimpleFormatArgs {\n             ArgumentIs(n) | ArgumentImplicitlyIs(n) => {\n                 if self.unnamed.len() <= n {\n                     // Use a dummy span to mark all unseen arguments.\n-                    self.unnamed.resize_with(n, || SmallVec::from([DUMMY_SP]));\n+                    self.unnamed.resize_with(n, || vec![DUMMY_SP]);\n                     if arg.format == SIMPLE {\n-                        self.unnamed.push(SmallVec::from([span]));\n+                        self.unnamed.push(vec![span]);\n                     } else {\n-                        self.unnamed.push(SmallVec::new());\n+                        self.unnamed.push(Vec::new());\n                     }\n                 } else {\n                     let args = &mut self.unnamed[n];\n@@ -410,7 +409,7 @@ impl SimpleFormatArgs {\n                         // Replace the dummy span, if it exists.\n                         ([dummy @ DUMMY_SP], true) => *dummy = span,\n                         ([_, ..], true) => args.push(span),\n-                        ([_, ..], false) => *args = SmallVec::new(),\n+                        ([_, ..], false) => *args = Vec::new(),\n                     }\n                 }\n             },\n@@ -420,12 +419,12 @@ impl SimpleFormatArgs {\n                         // A non-empty format string has been seen already.\n                         [] => (),\n                         [_, ..] if arg.format == SIMPLE => x.1.push(span),\n-                        [_, ..] => x.1 = SmallVec::new(),\n+                        [_, ..] => x.1 = Vec::new(),\n                     }\n                 } else if arg.format == SIMPLE {\n-                    self.named.push((n, SmallVec::from([span])));\n+                    self.named.push((n, vec![span]));\n                 } else {\n-                    self.named.push((n, SmallVec::new()));\n+                    self.named.push((n, Vec::new()));\n                 }\n             },\n         };\n@@ -436,24 +435,27 @@ impl Write {\n     /// Parses a format string into a collection of spans for each argument. This only keeps track\n     /// of empty format arguments. Will also lint usages of debug format strings outside of debug\n     /// impls.\n-    fn parse_fmt_string(&self, cx: &EarlyContext<'_>, str: &StrLit) -> Option<SimpleFormatArgs> {\n+    fn parse_fmt_string(&self, cx: &EarlyContext<'_>, str_lit: &StrLit) -> Option<SimpleFormatArgs> {\n         use rustc_parse_format::{ParseMode, Parser, Piece};\n \n-        let str_sym = str.symbol_unescaped.as_str();\n-        let style = match str.style {\n+        let str_sym = str_lit.symbol_unescaped.as_str();\n+        let style = match str_lit.style {\n             StrStyle::Cooked => None,\n             StrStyle::Raw(n) => Some(n as usize),\n         };\n \n-        let mut parser = Parser::new(&str_sym, style, snippet_opt(cx, str.span), false, ParseMode::Format);\n+        let mut parser = Parser::new(&str_sym, style, snippet_opt(cx, str_lit.span), false, ParseMode::Format);\n         let mut args = SimpleFormatArgs::default();\n \n         while let Some(arg) = parser.next() {\n             let arg = match arg {\n                 Piece::String(_) => continue,\n                 Piece::NextArgument(arg) => arg,\n             };\n-            let span = parser.arg_places.last().map_or(DUMMY_SP, |&x| str.span.from_inner(x));\n+            let span = parser\n+                .arg_places\n+                .last()\n+                .map_or(DUMMY_SP, |&x| str_lit.span.from_inner(x));\n \n             if !self.in_debug_impl && arg.format.ty == \"?\" {\n                 // FIXME: modify rustc's fmt string parser to give us the current span\n@@ -489,7 +491,11 @@ impl Write {\n     fn check_tts<'a>(&self, cx: &EarlyContext<'a>, tts: TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n         let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, false, None);\n         let expr = if is_write {\n-            match parser.parse_expr().map(|e| e.into_inner()).map_err(|mut e| e.cancel()) {\n+            match parser\n+                .parse_expr()\n+                .map(rustc_ast::ptr::P::into_inner)\n+                .map_err(|mut e| e.cancel())\n+            {\n                 // write!(e, ...)\n                 Ok(p) if parser.eat(&token::Comma) => Some(p),\n                 // write!(e) or error\n@@ -543,14 +549,14 @@ impl Write {\n                     lit.token.symbol.as_str().replace(\"{\", \"{{\").replace(\"}\", \"}}\")\n                 },\n                 LitKind::StrRaw(_) | LitKind::Str | LitKind::ByteStrRaw(_) | LitKind::ByteStr => continue,\n-                LitKind::Byte | LitKind::Char => match lit.token.symbol.as_str().deref() {\n+                LitKind::Byte | LitKind::Char => match &*lit.token.symbol.as_str() {\n                     \"\\\"\" if matches!(fmtstr.style, StrStyle::Cooked) => \"\\\\\\\"\",\n                     \"\\\"\" if matches!(fmtstr.style, StrStyle::Raw(0)) => continue,\n                     \"\\\\\\\\\" if matches!(fmtstr.style, StrStyle::Raw(_)) => \"\\\\\",\n                     \"\\\\'\" => \"'\",\n                     \"{\" => \"{{\",\n                     \"}\" => \"}}\",\n-                    x if matches!(fmtstr.style, StrStyle::Raw(_)) && x.starts_with(\"\\\\\") => continue,\n+                    x if matches!(fmtstr.style, StrStyle::Raw(_)) && x.starts_with('\\\\') => continue,\n                     x => x,\n                 }\n                 .into(),"}]}