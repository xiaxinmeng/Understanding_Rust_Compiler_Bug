{"sha": "7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZWU4YjlmZmI2YTJkYWM3ZTJmNzI5OTg4YzIzMjRlMmY4YWMxMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-03T02:21:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-03T02:21:28Z"}, "message": "Auto merge of #31824 - jseyfried:privacy_in_resolve, r=nikomatsakis\n\nThis PR privacy checks paths as they are resolved instead of in `librustc_privacy` (fixes #12334 and fixes #31779). This removes the need for the `LastPrivate` system introduced in PR #9735, the limitations of which cause #31779.\n\nThis PR also reports privacy violations in paths to intra- and inter-crate items the same way -- it always reports the first inaccessible segment of the path.\n\nSince it fixes #31779, this is a [breaking-change]. For example, the following code would break:\n```rust\nmod foo {\n    pub use foo::bar::S;\n    mod bar { // `bar` should be private to `foo`\n        pub struct S;\n    }\n}\n\nimpl foo::S {\n    fn f() {}\n}\n\nfn main() {\n    foo::bar::S::f(); // This is now a privacy error\n}\n```\n\nr? @alexcrichton", "tree": {"sha": "0854aec9954b6d1692ff43d9e879abecc3942100", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0854aec9954b6d1692ff43d9e879abecc3942100"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "html_url": "https://github.com/rust-lang/rust/commit/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b0b80ae21a195a5dba91d557f94a96136c27eaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0b80ae21a195a5dba91d557f94a96136c27eaf", "html_url": "https://github.com/rust-lang/rust/commit/7b0b80ae21a195a5dba91d557f94a96136c27eaf"}, {"sha": "e67590b0821c8985a02b699471d85be6d2137bff", "url": "https://api.github.com/repos/rust-lang/rust/commits/e67590b0821c8985a02b699471d85be6d2137bff", "html_url": "https://github.com/rust-lang/rust/commit/e67590b0821c8985a02b699471d85be6d2137bff"}], "stats": {"total": 813, "additions": 307, "deletions": 506}, "files": [{"sha": "44f588c2e9ca0e9d379d3f47f7f561cf901bd188", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -495,6 +495,30 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n+    /// module parent is in this map.\n+    fn get_module_parent(&self, id: NodeId) -> NodeId {\n+        match self.walk_parent_nodes(id, |node| match *node {\n+            NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n+            _ => false,\n+        }) {\n+            Ok(id) => id,\n+            Err(id) => id,\n+        }\n+    }\n+\n+    pub fn private_item_is_visible_from(&self, item: NodeId, block: NodeId) -> bool {\n+        // A private item is visible from everything in its nearest module parent.\n+        let visibility = self.get_module_parent(item);\n+        let mut block_ancestor = self.get_module_parent(block);\n+        loop {\n+            if block_ancestor == visibility { return true }\n+            let block_ancestor_parent = self.get_module_parent(block_ancestor);\n+            if block_ancestor_parent == block_ancestor { return false }\n+            block_ancestor = block_ancestor_parent;\n+        }\n+    }\n+\n     /// Returns the nearest enclosing scope. A scope is an item or block.\n     /// FIXME it is not clear to me that all items qualify as scopes - statics\n     /// and associated types probably shouldn't, for example. Behaviour in this"}, {"sha": "6d4799749b93af6c5da3bf76319fa0b3092f15b8", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::def_id::DefId;\n-use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n use util::nodemap::NodeMap;\n use syntax::ast;\n@@ -65,7 +64,6 @@ pub enum Def {\n #[derive(Copy, Clone, Debug)]\n pub struct PathResolution {\n     pub base_def: Def,\n-    pub last_private: LastPrivate,\n     pub depth: usize\n }\n \n@@ -84,12 +82,10 @@ impl PathResolution {\n     }\n \n     pub fn new(base_def: Def,\n-               last_private: LastPrivate,\n                depth: usize)\n                -> PathResolution {\n         PathResolution {\n             base_def: base_def,\n-            last_private: last_private,\n             depth: depth,\n         }\n     }\n@@ -152,4 +148,29 @@ impl Def {\n             _ => None\n         }\n     }\n+\n+    pub fn kind_name(&self) -> &'static str {\n+        match *self {\n+            Def::Fn(..) => \"function\",\n+            Def::Mod(..) => \"module\",\n+            Def::ForeignMod(..) => \"foreign module\",\n+            Def::Static(..) => \"static\",\n+            Def::Variant(..) => \"variant\",\n+            Def::Enum(..) => \"enum\",\n+            Def::TyAlias(..) => \"type\",\n+            Def::AssociatedTy(..) => \"associated type\",\n+            Def::Struct(..) => \"struct\",\n+            Def::Trait(..) => \"trait\",\n+            Def::Method(..) => \"method\",\n+            Def::Const(..) => \"const\",\n+            Def::AssociatedConst(..) => \"associated const\",\n+            Def::TyParam(..) => \"type parameter\",\n+            Def::PrimTy(..) => \"builtin type\",\n+            Def::Local(..) => \"local variable\",\n+            Def::Upvar(..) => \"closure capture\",\n+            Def::Label(..) => \"label\",\n+            Def::SelfTy(..) => \"self type\",\n+            Def::Err => \"unresolved item\",\n+        }\n+    }\n }"}, {"sha": "c1dc727449ac0ca681a240a02f0071d2ed5f80d0", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -12,11 +12,6 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-pub use self::PrivateDep::*;\n-pub use self::ImportUse::*;\n-pub use self::LastPrivate::*;\n-\n-use middle::def_id::DefId;\n use util::nodemap::{DefIdSet, FnvHashMap};\n \n use std::hash::Hash;\n@@ -64,39 +59,3 @@ impl<Id: Hash + Eq> Default for AccessLevels<Id> {\n /// A set containing all exported definitions from external crates.\n /// The set does not contain any entries from local crates.\n pub type ExternalExports = DefIdSet;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum LastPrivate {\n-    LastMod(PrivateDep),\n-    // `use` directives (imports) can refer to two separate definitions in the\n-    // type and value namespaces. We record here the last private node for each\n-    // and whether the import is in fact used for each.\n-    // If the Option<PrivateDep> fields are None, it means there is no definition\n-    // in that namespace.\n-    LastImport{value_priv: Option<PrivateDep>,\n-               value_used: ImportUse,\n-               type_priv: Option<PrivateDep>,\n-               type_used: ImportUse},\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum PrivateDep {\n-    AllPublic,\n-    DependsOn(DefId),\n-}\n-\n-// How an import is used.\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum ImportUse {\n-    Unused,       // The import is not used.\n-    Used,         // The import is used.\n-}\n-\n-impl LastPrivate {\n-    pub fn or(self, other: LastPrivate) -> LastPrivate {\n-        match (self, other) {\n-            (me, LastMod(AllPublic)) => me,\n-            (_, other) => other,\n-        }\n-    }\n-}"}, {"sha": "105e0bb7b158984c0ec661b410f1be812523fd8b", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -173,6 +173,14 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n         }\n     }\n \n+    pub fn def(&self) -> Def {\n+        match *self {\n+            ConstTraitItem(ref associated_const) => Def::AssociatedConst(associated_const.def_id),\n+            MethodTraitItem(ref method) => Def::Method(method.def_id),\n+            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.container.id(), ty.def_id),\n+        }\n+    }\n+\n     pub fn def_id(&self) -> DefId {\n         match *self {\n             ConstTraitItem(ref associated_const) => associated_const.def_id,"}, {"sha": "ff14652477eaa8e9d8f57a80775b1ef52626f10e", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -32,7 +32,6 @@ use middle::ty::cast;\n use middle::const_qualif::ConstQualif;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n-use middle::privacy::{AllPublic, LastMod};\n use middle::region;\n use middle::subst;\n use middle::ty::{self, Ty};\n@@ -254,7 +253,7 @@ trait def_id_encoder_helpers {\n }\n \n impl<S:serialize::Encoder> def_id_encoder_helpers for S\n-    where <S as serialize::serialize::Encoder>::Error: Debug\n+    where <S as serialize::Encoder>::Error: Debug\n {\n     fn emit_def_id(&mut self, did: DefId) {\n         did.encode(self).unwrap()\n@@ -268,7 +267,7 @@ trait def_id_decoder_helpers {\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D\n-    where <D as serialize::serialize::Decoder>::Error: Debug\n+    where <D as serialize::Decoder>::Error: Debug\n {\n     fn read_def_id(&mut self, dcx: &DecodeContext) -> DefId {\n         let did: DefId = Decodable::decode(self).unwrap();\n@@ -1161,8 +1160,6 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let def = decode_def(dcx, val_dsr);\n                         dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n                             base_def: def,\n-                            // This doesn't matter cross-crate.\n-                            last_private: LastMod(AllPublic),\n                             depth: 0\n                         });\n                     }"}, {"sha": "098c77a1bde2f87bcac7414a43408c0d0deaabaf", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 159, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -41,9 +41,6 @@ use rustc::lint;\n use rustc::middle::def::{self, Def};\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc::middle::privacy::ImportUse::*;\n-use rustc::middle::privacy::LastPrivate::*;\n-use rustc::middle::privacy::PrivateDep::*;\n use rustc::middle::privacy::ExternalExports;\n use rustc::middle::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet};\n@@ -692,32 +689,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     /// whether the node is accessible by the current module that iteration is\n     /// inside.\n     fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        let parent = *self.parents.get(&id).unwrap();\n-        debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n-\n-        // After finding `did`'s closest private member, we roll ourselves back\n-        // to see if this private member's parent is anywhere in our ancestry.\n-        // By the privacy rules, we can access all of our ancestor's private\n-        // members, so that's why we test the parent, and not the did itself.\n-        let mut cur = self.curitem;\n-        loop {\n-            debug!(\"privacy - questioning {}, {}\", self.nodestr(cur), cur);\n-            match cur {\n-                // If the relevant parent is in our history, then we're allowed\n-                // to look inside any of our ancestor's immediate private items,\n-                // so this access is valid.\n-                x if x == parent => return true,\n-\n-                // If we've reached the root, then we couldn't access this item\n-                // in the first place\n-                ast::DUMMY_NODE_ID => return false,\n-\n-                // Keep going up\n-                _ => {}\n-            }\n-\n-            cur = *self.parents.get(&cur).unwrap();\n-        }\n+        self.tcx.map.private_item_is_visible_from(id, self.curitem)\n     }\n \n     fn report_error(&self, result: CheckResult) -> bool {\n@@ -743,7 +715,6 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                      source_did: Option<DefId>,\n                      msg: &str)\n                      -> CheckResult {\n-        use rustc_front::hir::Item_::ItemExternCrate;\n         debug!(\"ensure_public(span={:?}, to_check={:?}, source_did={:?}, msg={:?})\",\n                span, to_check, source_did, msg);\n         let def_privacy = self.def_privacy(to_check);\n@@ -765,20 +736,6 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         let def_id = source_did.unwrap_or(to_check);\n         let node_id = self.tcx.map.as_local_node_id(def_id);\n \n-        // Warn when using a inaccessible extern crate.\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(to_check) {\n-            match self.tcx.map.get(node_id) {\n-                ast_map::Node::NodeItem(&hir::Item { node: ItemExternCrate(_), name, .. }) => {\n-                    self.tcx.sess.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE,\n-                                           node_id,\n-                                           span,\n-                                           format!(\"extern crate `{}` is private\", name));\n-                    return None;\n-                }\n-                _ => {}\n-            }\n-        }\n-\n         let (err_span, err_msg) = if Some(id) == node_id {\n             return Some((span, format!(\"{} is private\", msg), None));\n         } else {\n@@ -835,7 +792,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             }\n             UnnamedField(idx) => &v.fields[idx]\n         };\n-        if field.vis == hir::Public || self.local_private_accessible(field.did) {\n+        if field.vis == hir::Public || self.local_private_accessible(def.did) {\n             return;\n         }\n \n@@ -867,100 +824,6 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                                      name)));\n     }\n \n-    // Checks that a path is in scope.\n-    fn check_path(&mut self, span: Span, path_id: ast::NodeId, last: ast::Name) {\n-        debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let path_res = *self.tcx.def_map.borrow().get(&path_id).unwrap();\n-        let ck = |tyname: &str| {\n-            let ck_public = |def: DefId| {\n-                debug!(\"privacy - ck_public {:?}\", def);\n-                let origdid = path_res.def_id();\n-                self.ensure_public(span,\n-                                   def,\n-                                   Some(origdid),\n-                                   &format!(\"{} `{}`\", tyname, last))\n-            };\n-\n-            match path_res.last_private {\n-                LastMod(AllPublic) => {},\n-                LastMod(DependsOn(def)) => {\n-                    self.report_error(ck_public(def));\n-                },\n-                LastImport { value_priv,\n-                             value_used: check_value,\n-                             type_priv,\n-                             type_used: check_type } => {\n-                    // This dance with found_error is because we don't want to\n-                    // report a privacy error twice for the same directive.\n-                    let found_error = match (type_priv, check_type) {\n-                        (Some(DependsOn(def)), Used) => {\n-                            !self.report_error(ck_public(def))\n-                        },\n-                        _ => false,\n-                    };\n-                    if !found_error {\n-                        match (value_priv, check_value) {\n-                            (Some(DependsOn(def)), Used) => {\n-                                self.report_error(ck_public(def));\n-                            },\n-                            _ => {},\n-                        }\n-                    }\n-                    // If an import is not used in either namespace, we still\n-                    // want to check that it could be legal. Therefore we check\n-                    // in both namespaces and only report an error if both would\n-                    // be illegal. We only report one error, even if it is\n-                    // illegal to import from both namespaces.\n-                    match (value_priv, check_value, type_priv, check_type) {\n-                        (Some(p), Unused, None, _) |\n-                        (None, _, Some(p), Unused) => {\n-                            let p = match p {\n-                                AllPublic => None,\n-                                DependsOn(def) => ck_public(def),\n-                            };\n-                            if p.is_some() {\n-                                self.report_error(p);\n-                            }\n-                        },\n-                        (Some(v), Unused, Some(t), Unused) => {\n-                            let v = match v {\n-                                AllPublic => None,\n-                                DependsOn(def) => ck_public(def),\n-                            };\n-                            let t = match t {\n-                                AllPublic => None,\n-                                DependsOn(def) => ck_public(def),\n-                            };\n-                            if let (Some(_), Some(t)) = (v, t) {\n-                                self.report_error(Some(t));\n-                            }\n-                        },\n-                        _ => {},\n-                    }\n-                },\n-            }\n-        };\n-        // FIXME(#12334) Imports can refer to definitions in both the type and\n-        // value namespaces. The privacy information is aware of this, but the\n-        // def map is not. Therefore the names we work out below will not always\n-        // be accurate and we can get slightly wonky error messages (but type\n-        // checking is always correct).\n-        match path_res.full_def() {\n-            Def::Fn(..) => ck(\"function\"),\n-            Def::Static(..) => ck(\"static\"),\n-            Def::Const(..) => ck(\"const\"),\n-            Def::AssociatedConst(..) => ck(\"associated const\"),\n-            Def::Variant(..) => ck(\"variant\"),\n-            Def::TyAlias(..) => ck(\"type\"),\n-            Def::Enum(..) => ck(\"enum\"),\n-            Def::Trait(..) => ck(\"trait\"),\n-            Def::Struct(..) => ck(\"struct\"),\n-            Def::Method(..) => ck(\"method\"),\n-            Def::Mod(..) => ck(\"module\"),\n-            _ => {}\n-        }\n-    }\n-\n     // Checks that a method is in scope.\n     fn check_method(&mut self, span: Span, method_def_id: DefId,\n                     name: ast::Name) {\n@@ -1036,7 +899,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != hir::Public && !self.local_private_accessible(f.did)\n+                        f.vis != hir::Public && !self.local_private_accessible(def.did)\n                     });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,\n@@ -1102,25 +965,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_foreign_item(self, fi);\n         self.in_foreign = false;\n     }\n-\n-    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n-        if !path.segments.is_empty() {\n-            self.check_path(path.span, id, path.segments.last().unwrap().identifier.name);\n-            intravisit::walk_path(self, path);\n-        }\n-    }\n-\n-    fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n-        let name = if let hir::PathListIdent { name, .. } = item.node {\n-            name\n-        } else if !prefix.segments.is_empty() {\n-            prefix.segments.last().unwrap().identifier.name\n-        } else {\n-            self.tcx.sess.bug(\"`self` import in an import list with empty prefix\");\n-        };\n-        self.check_path(item.span, item.node.id(), name);\n-        intravisit::walk_path_list_item(self, prefix, item);\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "dbbaf0e23c7e8952936c48c6340ddc252c7b0a56", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -291,10 +291,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(parent, name);\n                     let def = Def::Mod(def_id);\n-                    let local_def_id = self.ast_map.local_def_id(item.id);\n-                    let external_module =\n-                        self.new_extern_crate_module(parent_link, def, is_public, local_def_id);\n-                    self.define(parent, name, TypeNS, (external_module, sp));\n+                    let module = self.new_extern_crate_module(parent_link, def, is_public, item.id);\n+                    self.define(parent, name, TypeNS, (module, sp));\n \n                     if is_public {\n                         let export = Export { name: name, def_id: def_id };\n@@ -304,7 +302,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         }\n                     }\n \n-                    self.build_reduced_graph_for_external_crate(external_module);\n+                    self.build_reduced_graph_for_external_crate(module);\n                 }\n                 parent\n             }\n@@ -494,7 +492,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         debug!(\"(building reduced graph for external crate) building external def {}, priv {:?}\",\n                final_ident,\n                vis);\n-        let is_public = vis == hir::Public;\n+        let is_public = vis == hir::Public || new_parent.is_trait();\n \n         let mut modifiers = DefModifiers::empty();\n         if is_public {"}, {"sha": "ea197109cabc4a08807b0926faf05f9823942b98", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -23,7 +23,6 @@ use Resolver;\n use Namespace::{TypeNS, ValueNS};\n \n use rustc::lint;\n-use rustc::middle::privacy::{DependsOn, LastImport, Used, Unused};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -69,45 +68,6 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                                   span,\n                                   \"unused import\".to_string());\n         }\n-\n-        let mut def_map = self.def_map.borrow_mut();\n-        let path_res = if let Some(r) = def_map.get_mut(&id) {\n-            r\n-        } else {\n-            return;\n-        };\n-        let (v_priv, t_priv) = match path_res.last_private {\n-            LastImport { value_priv, type_priv, .. } => (value_priv, type_priv),\n-            _ => {\n-                panic!(\"we should only have LastImport for `use` directives\")\n-            }\n-        };\n-\n-        let mut v_used = if self.used_imports.contains(&(id, ValueNS)) {\n-            Used\n-        } else {\n-            Unused\n-        };\n-        let t_used = if self.used_imports.contains(&(id, TypeNS)) {\n-            Used\n-        } else {\n-            Unused\n-        };\n-\n-        match (v_priv, t_priv) {\n-            // Since some items may be both in the value _and_ type namespaces (e.g., structs)\n-            // we might have two LastPrivates pointing at the same thing. There is no point\n-            // checking both, so lets not check the value one.\n-            (Some(DependsOn(def_v)), Some(DependsOn(def_t))) if def_v == def_t => v_used = Unused,\n-            _ => {}\n-        }\n-\n-        path_res.last_private = LastImport {\n-            value_priv: v_priv,\n-            value_used: v_used,\n-            type_priv: t_priv,\n-            type_used: t_used,\n-        };\n     }\n }\n "}, {"sha": "a160e1384d12ed0d8b913c3840033a23f389e9d2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 95, "deletions": 109, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -54,7 +54,7 @@ use rustc::middle::cstore::{CrateStore, DefLike, DlDef};\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n use rustc::middle::pat_util::pat_bindings;\n-use rustc::middle::privacy::*;\n+use rustc::middle::privacy::ExternalExports;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n@@ -757,8 +757,8 @@ enum AssocItemResolveResult {\n \n #[derive(Copy, Clone)]\n enum BareIdentifierPatternResolution {\n-    FoundStructOrEnumVariant(Def, LastPrivate),\n-    FoundConst(Def, LastPrivate, Name),\n+    FoundStructOrEnumVariant(Def),\n+    FoundConst(Def, Name),\n     BareIdentifierPatternUnresolved,\n }\n \n@@ -807,9 +807,9 @@ pub struct ModuleS<'a> {\n     def: Option<Def>,\n     is_public: bool,\n \n-    // If the module is an extern crate, `def` is root of the external crate and `extern_crate_did`\n-    // is the DefId of the local `extern crate` item (otherwise, `extern_crate_did` is None).\n-    extern_crate_did: Option<DefId>,\n+    // If the module is an extern crate, `def` is root of the external crate and `extern_crate_id`\n+    // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n+    extern_crate_id: Option<NodeId>,\n \n     resolutions: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n     unresolved_imports: RefCell<Vec<ImportDirective>>,\n@@ -856,7 +856,7 @@ impl<'a> ModuleS<'a> {\n             parent_link: parent_link,\n             def: def,\n             is_public: is_public,\n-            extern_crate_did: None,\n+            extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n             module_children: RefCell::new(NodeMap()),\n@@ -920,16 +920,6 @@ impl<'a> ModuleS<'a> {\n         self.def.as_ref().map(Def::def_id)\n     }\n \n-    // This returns the DefId of the crate local item that controls this module's visibility.\n-    // It is only used to compute `LastPrivate` data, and it differs from `def_id` only for extern\n-    // crates, whose `def_id` is the external crate's root, not the local `extern crate` item.\n-    fn local_def_id(&self) -> Option<DefId> {\n-        match self.extern_crate_did {\n-            Some(def_id) => Some(def_id),\n-            None => self.def_id(),\n-        }\n-    }\n-\n     fn is_normal(&self) -> bool {\n         match self.def {\n             Some(Def::Mod(_)) | Some(Def::ForeignMod(_)) => true,\n@@ -944,6 +934,15 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n+    fn is_ancestor_of(&self, module: Module<'a>) -> bool {\n+        if self.def_id() == module.def_id() { return true }\n+        match module.parent_link {\n+            ParentLink::BlockParentLink(parent, _) |\n+            ParentLink::ModuleParentLink(parent, _) => self.is_ancestor_of(parent),\n+            _ => false,\n+        }\n+    }\n+\n     pub fn inc_glob_count(&self) {\n         self.glob_count.set(self.glob_count.get() + 1);\n     }\n@@ -1010,9 +1009,14 @@ enum NameBindingKind<'a> {\n     Import {\n         binding: &'a NameBinding<'a>,\n         id: NodeId,\n+        // Some(error) if using this imported name causes the import to be a privacy error\n+        privacy_error: Option<Box<PrivacyError<'a>>>,\n     },\n }\n \n+#[derive(Clone, Debug)]\n+struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n+\n impl<'a> NameBinding<'a> {\n     fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n         let modifiers = if module.is_public {\n@@ -1040,14 +1044,6 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn local_def_id(&self) -> Option<DefId> {\n-        match self.kind {\n-            NameBindingKind::Def(def) => Some(def.def_id()),\n-            NameBindingKind::Module(ref module) => module.local_def_id(),\n-            NameBindingKind::Import { binding, .. } => binding.local_def_id(),\n-        }\n-    }\n-\n     fn defined_with(&self, modifiers: DefModifiers) -> bool {\n         self.modifiers.contains(modifiers)\n     }\n@@ -1056,15 +1052,8 @@ impl<'a> NameBinding<'a> {\n         self.defined_with(DefModifiers::PUBLIC)\n     }\n \n-    fn def_and_lp(&self) -> (Def, LastPrivate) {\n-        let def = self.def().unwrap();\n-        if let Def::Err = def { return (def, LastMod(AllPublic)) }\n-        let lp = if self.is_public() { AllPublic } else { DependsOn(self.local_def_id().unwrap()) };\n-        (def, LastMod(lp))\n-    }\n-\n     fn is_extern_crate(&self) -> bool {\n-        self.module().and_then(|module| module.extern_crate_did).is_some()\n+        self.module().and_then(|module| module.extern_crate_id).is_some()\n     }\n \n     fn is_import(&self) -> bool {\n@@ -1170,6 +1159,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     // The intention is that the callback modifies this flag.\n     // Once set, the resolver falls out of the walk, preserving the ribs.\n     resolved: bool,\n+    privacy_errors: Vec<PrivacyError<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n }\n@@ -1234,6 +1224,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             callback: None,\n             resolved: false,\n+            privacy_errors: Vec::new(),\n \n             arenas: arenas,\n         }\n@@ -1262,10 +1253,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                parent_link: ParentLink<'a>,\n                                def: Def,\n                                is_public: bool,\n-                               local_def: DefId)\n+                               local_node_id: NodeId)\n                                -> Module<'a> {\n         let mut module = ModuleS::new(parent_link, Some(def), false, is_public);\n-        module.extern_crate_did = Some(local_def);\n+        module.extern_crate_id = Some(local_node_id);\n         self.arenas.modules.alloc(module)\n     }\n \n@@ -1280,12 +1271,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             self.used_crates.insert(krate);\n         }\n \n-        let import_id = match binding.kind {\n-            NameBindingKind::Import { id, .. } => id,\n+        let (import_id, privacy_error) = match binding.kind {\n+            NameBindingKind::Import { id, ref privacy_error, .. } => (id, privacy_error),\n             _ => return,\n         };\n \n         self.used_imports.insert((import_id, ns));\n+        if let Some(error) = privacy_error.as_ref() {\n+            self.privacy_errors.push((**error).clone());\n+        }\n \n         if !self.make_glob_map {\n             return;\n@@ -1313,9 +1307,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      module_: Module<'a>,\n                                      module_path: &[Name],\n                                      index: usize,\n-                                     span: Span,\n-                                     lp: LastPrivate)\n-                                     -> ResolveResult<(Module<'a>, LastPrivate)> {\n+                                     span: Span)\n+                                     -> ResolveResult<Module<'a>> {\n         fn search_parent_externals(needle: Name, module: Module) -> Option<Module> {\n             match module.resolve_name(needle, TypeNS, false) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n@@ -1331,7 +1324,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = module_path.len();\n-        let mut closest_private = lp;\n \n         // Resolve the module part of the path. This does not involve looking\n         // upward though scope chains; we simply resolve names directly in\n@@ -1379,15 +1371,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n                     if let Some(module_def) = binding.module() {\n+                        self.check_privacy(search_module, name, binding, span);\n                         search_module = module_def;\n-\n-                        // Keep track of the closest private module used\n-                        // when resolving this import chain.\n-                        if !binding.is_public() {\n-                            if let Some(did) = search_module.local_def_id() {\n-                                closest_private = LastMod(DependsOn(did));\n-                            }\n-                        }\n                     } else {\n                         let msg = format!(\"Not a module `{}`\", name);\n                         return Failed(Some((span, msg)));\n@@ -1398,7 +1383,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             index += 1;\n         }\n \n-        return Success((search_module, closest_private));\n+        return Success(search_module);\n     }\n \n     /// Attempts to resolve the module part of an import directive or path\n@@ -1411,9 +1396,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span)\n-                           -> ResolveResult<(Module<'a>, LastPrivate)> {\n+                           -> ResolveResult<Module<'a>> {\n         if module_path.len() == 0 {\n-            return Success((self.graph_root, LastMod(AllPublic))) // Use the crate root\n+            return Success(self.graph_root) // Use the crate root\n         }\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n@@ -1425,7 +1410,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let search_module;\n         let start_index;\n-        let last_private;\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = names_to_string(module_path);\n@@ -1459,7 +1443,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // resolution process at index zero.\n                         search_module = self.graph_root;\n                         start_index = 0;\n-                        last_private = LastMod(AllPublic);\n                     }\n                     UseLexicalScope => {\n                         // This is not a crate-relative path. We resolve the\n@@ -1478,7 +1461,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 Some(containing_module) => {\n                                     search_module = containing_module;\n                                     start_index = 1;\n-                                    last_private = LastMod(AllPublic);\n                                 }\n                                 None => return Failed(None),\n                             }\n@@ -1489,16 +1471,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success(PrefixFound(ref containing_module, index)) => {\n                 search_module = containing_module;\n                 start_index = index;\n-                last_private = LastMod(DependsOn(containing_module.local_def_id()\n-                                                                  .unwrap()));\n             }\n         }\n \n         self.resolve_module_path_from_root(search_module,\n                                            module_path,\n                                            start_index,\n-                                           span,\n-                                           last_private)\n+                                           span)\n     }\n \n     /// Invariant: This must only be called during main resolution, not during\n@@ -1851,8 +1830,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             match self.resolve_crate_relative_path(prefix.span,\n                                                                    &prefix.segments,\n                                                                    TypeNS) {\n-                                Some((def, lp)) =>\n-                                    self.record_def(item.id, PathResolution::new(def, lp, 0)),\n+                                Some(def) =>\n+                                    self.record_def(item.id, PathResolution::new(def, 0)),\n                                 None => {\n                                     resolve_error(self,\n                                                   prefix.span,\n@@ -2406,7 +2385,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     match self.resolve_bare_identifier_pattern(ident.unhygienic_name,\n                                                                pattern.span) {\n-                        FoundStructOrEnumVariant(def, lp) if const_ok => {\n+                        FoundStructOrEnumVariant(def) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to struct or enum variant\",\n                                    renamed);\n \n@@ -2416,7 +2395,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.record_def(pattern.id,\n                                             PathResolution {\n                                                 base_def: def,\n-                                                last_private: lp,\n                                                 depth: 0,\n                                             });\n                         }\n@@ -2429,18 +2407,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             );\n                             self.record_def(pattern.id, err_path_resolution());\n                         }\n-                        FoundConst(def, lp, _) if const_ok => {\n+                        FoundConst(def, _) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to constant\", renamed);\n \n                             self.enforce_default_binding_mode(pattern, binding_mode, \"a constant\");\n                             self.record_def(pattern.id,\n                                             PathResolution {\n                                                 base_def: def,\n-                                                last_private: lp,\n                                                 depth: 0,\n                                             });\n                         }\n-                        FoundConst(def, _, name) => {\n+                        FoundConst(def, name) => {\n                             resolve_error(\n                                 self,\n                                 pattern.span,\n@@ -2462,7 +2439,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.record_def(pattern.id,\n                                             PathResolution {\n                                                 base_def: def,\n-                                                last_private: LastMod(AllPublic),\n                                                 depth: 0,\n                                             });\n \n@@ -2680,10 +2656,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // considered as not having a private component because\n                     // the lookup happened only within the current module.\n                     Some(def @ Def::Variant(..)) | Some(def @ Def::Struct(..)) => {\n-                        return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n+                        return FoundStructOrEnumVariant(def);\n                     }\n                     Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n-                        return FoundConst(def, LastMod(AllPublic), name);\n+                        return FoundConst(def, name);\n                     }\n                     Some(Def::Static(..)) => {\n                         resolve_error(self, span, ResolutionError::StaticVariableReference);\n@@ -2764,7 +2740,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n \n-        let mk_res = |(def, lp)| PathResolution::new(def, lp, path_depth);\n+        let mk_res = |def| PathResolution::new(def, path_depth);\n \n         if path.global {\n             let def = self.resolve_crate_relative_path(span, segments, namespace);\n@@ -2777,14 +2753,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             let unqualified_def = self.resolve_identifier(last_ident, namespace, check_ribs, true);\n             return unqualified_def.and_then(|def| self.adjust_local_def(def, span))\n                                   .map(|def| {\n-                                      PathResolution::new(def, LastMod(AllPublic), path_depth)\n+                                      PathResolution::new(def, path_depth)\n                                   });\n         }\n \n         let unqualified_def = self.resolve_identifier(last_ident, namespace, check_ribs, false);\n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n-            (Some((ref d, _)), Some(ref ud)) if *d == ud.def => {\n+            (Some(d), Some(ref ud)) if d == ud.def => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2931,7 +2907,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     span: Span,\n                                     segments: &[hir::PathSegment],\n                                     namespace: Namespace)\n-                                    -> Option<(Def, LastPrivate)> {\n+                                    -> Option<Def> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2940,7 +2916,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   .collect::<Vec<_>>();\n \n         let containing_module;\n-        let last_private;\n         let current_module = self.current_module;\n         match self.resolve_module_path(current_module, &module_path, UseLexicalScope, span) {\n             Failed(err) => {\n@@ -2957,22 +2932,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 return None;\n             }\n             Indeterminate => return None,\n-            Success((resulting_module, resulting_last_private)) => {\n+            Success(resulting_module) => {\n                 containing_module = resulting_module;\n-                last_private = resulting_last_private;\n             }\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n-        let def = match result {\n-            Success(binding) => {\n-                let (def, lp) = binding.def_and_lp();\n-                (def, last_private.or(lp))\n-            }\n-            _ => return None,\n-        };\n-        return Some(def);\n+        result.success().map(|binding| {\n+            self.check_privacy(containing_module, name, binding, span);\n+            binding.def().unwrap()\n+        })\n     }\n \n     /// Invariant: This must be called only during main resolution, not during\n@@ -2981,7 +2951,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    span: Span,\n                                    segments: &[hir::PathSegment],\n                                    namespace: Namespace)\n-                                   -> Option<(Def, LastPrivate)> {\n+                                   -> Option<Def> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2992,12 +2962,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let root_module = self.graph_root;\n \n         let containing_module;\n-        let last_private;\n         match self.resolve_module_path_from_root(root_module,\n                                                  &module_path,\n                                                  0,\n-                                                 span,\n-                                                 LastMod(AllPublic)) {\n+                                                 span) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -3014,20 +2982,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             Indeterminate => return None,\n \n-            Success((resulting_module, resulting_last_private)) => {\n+            Success(resulting_module) => {\n                 containing_module = resulting_module;\n-                last_private = resulting_last_private;\n             }\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        match self.resolve_name_in_module(containing_module, name, namespace, false, true) {\n-            Success(binding) => {\n-                let (def, lp) = binding.def_and_lp();\n-                Some((def, last_private.or(lp)))\n-            }\n-            _ => None,\n-        }\n+        let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n+        result.success().map(|binding| {\n+            self.check_privacy(containing_module, name, binding, span);\n+            binding.def().unwrap()\n+        })\n     }\n \n     fn resolve_identifier_in_local_ribs(&mut self,\n@@ -3116,10 +3081,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                .and_then(NameBinding::module)\n                 }\n             } else {\n-                match this.resolve_module_path(root, &name_path, UseLexicalScope, span) {\n-                    Success((module, _)) => Some(module),\n-                    _ => None,\n-                }\n+                this.resolve_module_path(root, &name_path, UseLexicalScope, span).success()\n             }\n         }\n \n@@ -3431,7 +3393,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.record_def(expr.id,\n                                         PathResolution {\n                                             base_def: def,\n-                                            last_private: LastMod(AllPublic),\n                                             depth: 0,\n                                         })\n                     }\n@@ -3624,12 +3585,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n         debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n-        assert!(match resolution.last_private {\n-                    LastImport{..} => false,\n-                    _ => true,\n-                },\n-                \"Import should only be used for `use` directives\");\n-\n         if let Some(prev_res) = self.def_map.borrow_mut().insert(node_id, resolution) {\n             let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n             self.session.span_bug(span,\n@@ -3652,6 +3607,37 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn is_visible(&self, binding: &'a NameBinding<'a>, parent: Module<'a>) -> bool {\n+        binding.is_public() || parent.is_ancestor_of(self.current_module)\n+    }\n+\n+    fn check_privacy(&mut self,\n+                     module: Module<'a>,\n+                     name: Name,\n+                     binding: &'a NameBinding<'a>,\n+                     span: Span) {\n+        if !self.is_visible(binding, module) {\n+            self.privacy_errors.push(PrivacyError(span, name, binding));\n+        }\n+    }\n+\n+    fn report_privacy_errors(&self) {\n+        if self.privacy_errors.len() == 0 { return }\n+        let mut reported_spans = HashSet::new();\n+        for &PrivacyError(span, name, binding) in &self.privacy_errors {\n+            if !reported_spans.insert(span) { continue }\n+            if binding.is_extern_crate() {\n+                // Warn when using an inaccessible extern crate.\n+                let node_id = binding.module().unwrap().extern_crate_id.unwrap();\n+                let msg = format!(\"extern crate `{}` is private\", name);\n+                self.session.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE, node_id, span, msg);\n+            } else {\n+                let def = binding.def().unwrap();\n+                self.session.span_err(span, &format!(\"{} `{}` is private\", def.kind_name(), name));\n+            }\n+        }\n+    }\n }\n \n \n@@ -3767,7 +3753,6 @@ fn module_to_string(module: Module) -> String {\n fn err_path_resolution() -> PathResolution {\n     PathResolution {\n         base_def: Def::Err,\n-        last_private: LastMod(AllPublic),\n         depth: 0,\n     }\n }\n@@ -3809,6 +3794,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     resolver.resolve_crate(krate);\n \n     check_unused::check_crate(&mut resolver, krate);\n+    resolver.report_privacy_errors();\n \n     CrateMap {\n         def_map: resolver.def_map,"}, {"sha": "f6d23c8caa2c7f757d4fb376b8b67fd0883b985c", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -13,7 +13,7 @@ use self::ImportDirectiveSubclass::*;\n use DefModifiers;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n-use {NameBinding, NameBindingKind};\n+use {NameBinding, NameBindingKind, PrivacyError};\n use ResolveResult;\n use ResolveResult::*;\n use Resolver;\n@@ -25,7 +25,6 @@ use build_reduced_graph;\n \n use rustc::lint;\n use rustc::middle::def::*;\n-use rustc::middle::privacy::*;\n \n use syntax::ast::{NodeId, Name};\n use syntax::attr::AttrMetaMethods;\n@@ -79,7 +78,9 @@ impl ImportDirective {\n \n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import<'a>(&self, binding: &'a NameBinding<'a>) -> NameBinding<'a> {\n+    fn import<'a>(&self,\n+                  binding: &'a NameBinding<'a>,\n+                  privacy_error: Option<Box<PrivacyError<'a>>>) -> NameBinding<'a> {\n         let mut modifiers = match self.is_public {\n             true => DefModifiers::PUBLIC | DefModifiers::IMPORTABLE,\n             false => DefModifiers::empty(),\n@@ -92,7 +93,11 @@ impl ImportDirective {\n         }\n \n         NameBinding {\n-            kind: NameBindingKind::Import { binding: binding, id: self.id },\n+            kind: NameBindingKind::Import {\n+                binding: binding,\n+                id: self.id,\n+                privacy_error: privacy_error,\n+            },\n             span: Some(self.span),\n             modifiers: modifiers,\n         }\n@@ -220,7 +225,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 span: None,\n             });\n             let dummy_binding =\n-                self.resolver.new_name_binding(e.import_directive.import(dummy_binding));\n+                self.resolver.new_name_binding(e.import_directive.import(dummy_binding, None));\n \n             let _ = e.source_module.try_define_child(target, ValueNS, dummy_binding);\n             let _ = e.source_module.try_define_child(target, TypeNS, dummy_binding);\n@@ -296,18 +301,17 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                  &import_directive.module_path,\n                                  UseLexicalScopeFlag::DontUseLexicalScope,\n                                  import_directive.span)\n-            .and_then(|(containing_module, lp)| {\n+            .and_then(|containing_module| {\n                 // We found the module that the target is contained\n                 // within. Attempt to resolve the import within it.\n                 if let SingleImport(target, source) = import_directive.subclass {\n                     self.resolve_single_import(module_,\n                                                containing_module,\n                                                target,\n                                                source,\n-                                               import_directive,\n-                                               lp)\n+                                               import_directive)\n                 } else {\n-                    self.resolve_glob_import(module_, containing_module, import_directive, lp)\n+                    self.resolve_glob_import(module_, containing_module, import_directive)\n                 }\n             })\n             .and_then(|()| {\n@@ -333,26 +337,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                              target_module: Module<'b>,\n                              target: Name,\n                              source: Name,\n-                             directive: &ImportDirective,\n-                             lp: LastPrivate)\n+                             directive: &ImportDirective)\n                              -> ResolveResult<()> {\n-        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from `{}` id {}, last \\\n-                private {:?}\",\n+        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from `{}` id {}\",\n                target,\n                module_to_string(&target_module),\n                source,\n                module_to_string(module_),\n-               directive.id,\n-               lp);\n-\n-        let lp = match lp {\n-            LastMod(lp) => lp,\n-            LastImport {..} => {\n-                self.resolver\n-                    .session\n-                    .span_bug(directive.span, \"not expecting Import here, must be LastMod\")\n-            }\n-        };\n+               directive.id);\n \n         // If this is a circular import, we temporarily count it as determined so that\n         // it fails (as opposed to being indeterminate) when nothing else can define it.\n@@ -433,45 +425,43 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => {}\n         }\n \n+        let mut privacy_error = None;\n+        let mut report_privacy_error = true;\n         for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n             if let Success(binding) = *result {\n                 if !binding.defined_with(DefModifiers::IMPORTABLE) {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                 }\n \n-                self.define(module_, target, ns, directive.import(binding));\n+                privacy_error = if !self.resolver.is_visible(binding, target_module) {\n+                    Some(Box::new(PrivacyError(directive.span, source, binding)))\n+                } else {\n+                    report_privacy_error = false;\n+                    None\n+                };\n+\n+                self.define(module_, target, ns, directive.import(binding, privacy_error.clone()));\n             }\n         }\n \n+        if report_privacy_error { // then all successful namespaces are privacy errors\n+            // We report here so there is an error even if the imported name is not used\n+            self.resolver.privacy_errors.push(*privacy_error.unwrap());\n+        }\n+\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n         module_.decrement_outstanding_references_for(target, ValueNS);\n         module_.decrement_outstanding_references_for(target, TypeNS);\n \n-        let def_and_priv = |binding: &NameBinding| {\n-            let last_private =\n-                if binding.is_public() { lp } else { DependsOn(binding.local_def_id().unwrap()) };\n-            (binding.def().unwrap(), last_private)\n-        };\n-        let value_def_and_priv = value_result.success().map(&def_and_priv);\n-        let type_def_and_priv = type_result.success().map(&def_and_priv);\n-\n-        let import_lp = LastImport {\n-            value_priv: value_def_and_priv.map(|(_, p)| p),\n-            value_used: Used,\n-            type_priv: type_def_and_priv.map(|(_, p)| p),\n-            type_used: Used,\n-        };\n-\n-        let write_path_resolution = |(def, _)| {\n-            let path_resolution =\n-                PathResolution { base_def: def, last_private: import_lp, depth: 0 };\n-            self.resolver.def_map.borrow_mut().insert(directive.id, path_resolution);\n+        let def = match type_result.success().and_then(NameBinding::def) {\n+            Some(def) => def,\n+            None => value_result.success().and_then(NameBinding::def).unwrap(),\n         };\n-        value_def_and_priv.map(&write_path_resolution);\n-        type_def_and_priv.map(&write_path_resolution);\n+        let path_resolution = PathResolution { base_def: def, depth: 0 };\n+        self.resolver.def_map.borrow_mut().insert(directive.id, path_resolution);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -484,8 +474,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn resolve_glob_import(&mut self,\n                            module_: Module<'b>,\n                            target_module: Module<'b>,\n-                           directive: &ImportDirective,\n-                           lp: LastPrivate)\n+                           directive: &ImportDirective)\n                            -> ResolveResult<()> {\n         // We must bail out if the node has unresolved imports of any kind (including globs).\n         if target_module.pub_count.get() > 0 {\n@@ -503,7 +492,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n         target_module.for_each_child(|name, ns, binding| {\n             if !binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) { return }\n-            self.define(module_, name, ns, directive.import(binding));\n+            self.define(module_, name, ns, directive.import(binding, None));\n \n             if ns == TypeNS && directive.is_public &&\n                binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n@@ -521,7 +510,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             self.resolver.def_map.borrow_mut().insert(directive.id,\n                                                       PathResolution {\n                                                           base_def: Def::Mod(did),\n-                                                          last_private: lp,\n                                                           depth: 0,\n                                                       });\n         }"}, {"sha": "8db04c2da20a26c884d863f73137eec761032614", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -54,7 +54,6 @@ use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n use middle::resolve_lifetime as rl;\n-use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n use middle::traits;\n use middle::ty::{self, Ty, ToPredicate, TypeFoldable};\n@@ -1650,7 +1649,6 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n                     base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n-                    last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n             } else {\n@@ -1674,7 +1672,6 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 // Write back the new resolution.\n                 tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution {\n                     base_def: def,\n-                    last_private: path_res.last_private,\n                     depth: 0\n                 });\n             }"}, {"sha": "f837d354acd2aaf31a1603e2cff6b11a82a18763", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -12,7 +12,6 @@ use middle::def::{self, Def};\n use middle::infer::{self, TypeOrigin};\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n-use middle::privacy::{AllPublic, LastMod};\n use middle::subst::Substs;\n use middle::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n@@ -219,7 +218,6 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 let sentinel = fcx.tcx().map.local_def_id(ast::CRATE_NODE_ID);\n                 def::PathResolution {\n                     base_def: Def::Mod(sentinel),\n-                    last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n             } else {"}, {"sha": "31e23344734886c940e650cb22f8774d5a4e5bcf", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -14,7 +14,6 @@ use astconv::AstConv;\n use check::FnCtxt;\n use middle::def::Def;\n use middle::def_id::DefId;\n-use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n use middle::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n@@ -334,28 +333,21 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               method_name: ast::Name,\n                               self_ty: ty::Ty<'tcx>,\n                               expr_id: ast::NodeId)\n-                              -> Result<(Def, LastPrivate), MethodError<'tcx>>\n+                              -> Result<Def, MethodError<'tcx>>\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n-    let def_id = pick.item.def_id();\n-    let mut lp = LastMod(AllPublic);\n+    let def = pick.item.def();\n+\n     if let probe::InherentImplPick = pick.kind {\n-        if pick.item.vis() != hir::Public {\n-            lp = LastMod(DependsOn(def_id));\n+        if pick.item.vis() != hir::Public && !fcx.private_item_is_visible(def.def_id()) {\n+            let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n+            fcx.tcx().sess.span_err(span, &msg);\n         }\n     }\n-    let def_result = match pick.item {\n-        ty::ImplOrTraitItem::MethodTraitItem(..) => Def::Method(def_id),\n-        ty::ImplOrTraitItem::ConstTraitItem(..) => Def::AssociatedConst(def_id),\n-        ty::ImplOrTraitItem::TypeTraitItem(..) => {\n-            fcx.tcx().sess.span_bug(span, \"resolve_ufcs: probe picked associated type\");\n-        }\n-    };\n-    Ok((def_result, lp))\n+    Ok(def)\n }\n \n-\n /// Find item with name `item_name` defined in `trait_def_id`\n /// and return it, or `None`, if no such item.\n fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "46145b2a0a45ed00e04f2d142476d0e9affcfb70", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -91,7 +91,6 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::infer::{TypeOrigin, type_variable};\n use middle::pat_util::{self, pat_id_map};\n-use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{GenericPredicates, TypeScheme};\n@@ -2013,6 +2012,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n     }\n+\n+    fn private_item_is_visible(&self, def_id: DefId) -> bool {\n+        match self.tcx().map.as_local_node_id(def_id) {\n+            Some(node_id) => self.tcx().map.private_item_is_visible_from(node_id, self.body_id),\n+            None => false, // Private items from other crates are never visible\n+        }\n+    }\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n@@ -3348,7 +3354,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n                     base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n-                    last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n             } else {\n@@ -3787,12 +3792,11 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n         let item_segment = path.segments.last().unwrap();\n         let item_name = item_segment.identifier.name;\n         match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n-            Ok((def, lp)) => {\n+            Ok(def) => {\n                 // Write back the new resolution.\n                 fcx.ccx.tcx.def_map.borrow_mut()\n                        .insert(node_id, def::PathResolution {\n                    base_def: def,\n-                   last_private: path_res.last_private.or(lp),\n                    depth: 0\n                 });\n                 Some((Some(ty), slice::ref_slice(item_segment), def))"}, {"sha": "4ba0ccdba9bf744ceb064b22c2240bdabf7efeac", "filename": "src/test/auxiliary/ambig_impl_2_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fauxiliary%2Fambig_impl_2_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fauxiliary%2Fambig_impl_2_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fambig_impl_2_lib.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait me {\n+pub trait me {\n     fn me(&self) -> usize;\n }\n impl me for usize { fn me(&self) -> usize { *self } }"}, {"sha": "5fea97da03ee38f5cdf2107610c6d979d8f31338", "filename": "src/test/auxiliary/struct_field_privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fauxiliary%2Fstruct_field_privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fauxiliary%2Fstruct_field_privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct_field_privacy.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct A {\n+pub struct A {\n     a: isize,\n     pub b: isize,\n }"}, {"sha": "930f769771d58275ad0be5a47fd3ad3d5ebb1fe5", "filename": "src/test/compile-fail/blind-item-block-middle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-mod foo { struct bar; }\n+mod foo { pub struct bar; }\n \n fn main() {\n     let bar = 5;"}, {"sha": "bc395af9622c5e6bc74e79896f00310fddcb8c5b", "filename": "src/test/compile-fail/const-pattern-irrefutable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n mod foo {\n-    const b: u8 = 2; //~ NOTE constant defined here\n-    const d: u8 = 2; //~ NOTE constant defined here\n+    pub const b: u8 = 2; //~ NOTE constant defined here\n+    pub const d: u8 = 2; //~ NOTE constant defined here\n }\n \n use foo::b as c; //~ NOTE constant imported here"}, {"sha": "7b915647884f2ac169a6e45f43b1b1f0083c8c2d", "filename": "src/test/compile-fail/double-import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fdouble-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fdouble-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdouble-import.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -14,11 +14,11 @@\n // when reporting the error.\n \n mod sub1 {\n-    fn foo() {} // implementation 1\n+    pub fn foo() {} // implementation 1\n }\n \n mod sub2 {\n-    fn foo() {} // implementation 2\n+    pub fn foo() {} // implementation 2\n }\n \n use sub1::foo; //~ NOTE previous import of `foo` here"}, {"sha": "b6e8cf71ddd6c0550849e04ed982fb711102f06d", "filename": "src/test/compile-fail/export-tag-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -14,4 +14,4 @@ mod foo {\n     enum y { y1, }\n }\n \n-fn main() { let z = foo::y::y1; } //~ ERROR: is inaccessible\n+fn main() { let z = foo::y::y1; } //~ ERROR: enum `y` is private"}, {"sha": "7dccd7811066e3843393d6354f16dc8adc5620f0", "filename": "src/test/compile-fail/issue-11680.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-11680.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-11680.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11680.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -14,8 +14,8 @@ extern crate issue_11680 as other;\n \n fn main() {\n     let _b = other::Foo::Bar(1);\n-    //~^ ERROR: variant `Bar` is private\n+    //~^ ERROR: enum `Foo` is private\n \n     let _b = other::test::Foo::Bar(1);\n-    //~^ ERROR: variant `Bar` is private\n+    //~^ ERROR: enum `Foo` is private\n }"}, {"sha": "afb2e867f45c6057e60336534eefb316e4148cc7", "filename": "src/test/compile-fail/issue-13407.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-13407.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-13407.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13407.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -16,4 +16,5 @@ fn main() {\n     A::C = 1;\n     //~^ ERROR: invalid left-hand side expression\n     //~| ERROR: mismatched types\n+    //~| ERROR: struct `C` is private\n }"}, {"sha": "3b690e08f6143042e6cc05cfeca424a036f4330c", "filename": "src/test/compile-fail/issue-13641.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-13641.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-13641.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13641.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -17,9 +17,7 @@ mod a {\n \n fn main() {\n     a::Foo::new();\n-    //~^ ERROR: method `new` is inaccessible\n-    //~^^ NOTE: struct `Foo` is private\n+    //~^ ERROR: struct `Foo` is private\n     a::Bar::new();\n-    //~^ ERROR: method `new` is inaccessible\n-    //~^^ NOTE: enum `Bar` is private\n+    //~^ ERROR: enum `Bar` is private\n }"}, {"sha": "205d3251cc2df939521aeb858f4b28334c3fe01d", "filename": "src/test/compile-fail/issue-16538.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n mod Y {\n-    type X = usize;\n+    pub type X = usize;\n     extern {\n-        static x: *const usize;\n+        pub static x: *const usize;\n     }\n-    fn foo(value: *const X) -> *const X {\n+    pub fn foo(value: *const X) -> *const X {\n         value\n     }\n }"}, {"sha": "8c2c27694d903b97af06e9c8a191a0ed0c9bf8b4", "filename": "src/test/compile-fail/issue-21221-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-21221-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-21221-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21221-2.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -13,7 +13,7 @@ pub mod foo {\n         // note: trait T is not public, but being in the current\n         // crate, it's fine to show it, since the programmer can\n         // decide to make it public based on the suggestion ...\n-        trait T {}\n+        pub trait T {}\n     }\n     // imports should be ignored:\n     use self::bar::T;"}, {"sha": "ec77e6ebd7cf38af1b9861b2ca53cc074671d6c9", "filename": "src/test/compile-fail/issue-25396.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-25396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-25396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25396.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -32,6 +32,6 @@ mod foo {\n mod bar {\n     pub mod baz {}\n     pub type Quux = i32;\n-    struct blah { x: i8 }\n+    pub struct blah { x: i8 }\n     pub const WOMP: i8 = -5;\n }"}, {"sha": "f7453c45be645d7bd0d3bcbb97ab1eba65f35cef", "filename": "src/test/compile-fail/issue-29161.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -13,7 +13,6 @@ mod a {\n \n     impl Default for A {\n         pub fn default() -> A {\n-            //~^ ERROR E0449\n             A;\n         }\n     }\n@@ -22,5 +21,5 @@ mod a {\n \n fn main() {\n     a::A::default();\n-    //~^ ERROR method `default` is inaccessible\n+    //~^ ERROR struct `A` is private\n  }"}, {"sha": "0a8689ea6d61254e4c273a7710ab4acda6617136", "filename": "src/test/compile-fail/privacy-in-paths.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy-in-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy-in-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-in-paths.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    pub use self::bar::S;\n+    mod bar {\n+        pub struct S;\n+        pub use baz;\n+    }\n+\n+    trait T {\n+        type Assoc;\n+    }\n+    impl T for () {\n+        type Assoc = S;\n+    }\n+}\n+\n+impl foo::S {\n+    fn f() {}\n+}\n+\n+pub mod baz {\n+    fn f() {}\n+\n+    fn g() {\n+        ::foo::bar::baz::f(); //~ERROR module `bar` is private\n+        ::foo::bar::S::f(); //~ERROR module `bar` is private\n+        <() as ::foo::T>::Assoc::f(); //~ERROR trait `T` is private\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bf296220d2a2b601d2cb38bce3f6e5dba8621526", "filename": "src/test/compile-fail/privacy-ns2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -25,14 +25,13 @@ pub mod foo1 {\n }\n \n fn test_single1() {\n-    // In an ideal world, these would be private instead of inaccessible.\n-    use foo1::Bar;  //~ ERROR `Bar` is inaccessible\n+    use foo1::Bar;  //~ ERROR function `Bar` is private\n \n     Bar();\n }\n \n fn test_list1() {\n-    use foo1::{Bar,Baz};  //~ ERROR `Bar` is inaccessible\n+    use foo1::{Bar,Baz};  //~ ERROR `Bar` is private\n \n     Bar();\n }\n@@ -47,7 +46,7 @@ pub mod foo2 {\n }\n \n fn test_single2() {\n-    use foo2::Bar;  //~ ERROR `Bar` is private\n+    use foo2::Bar;  //~ ERROR trait `Bar` is private\n \n     let _x : Box<Bar>;\n }"}, {"sha": "28c1a003e39f0b731f43a1e97fae218c51cbac46", "filename": "src/test/compile-fail/privacy-ufcs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy-ufcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy-ufcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ufcs.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -19,6 +19,5 @@ mod foo {\n }\n \n fn main() {\n-    <i32 as ::foo::Bar>::baz(); //~ERROR method `baz` is inaccessible\n-                                //~^NOTE: trait `Bar` is private\n+    <i32 as ::foo::Bar>::baz(); //~ERROR trait `Bar` is private\n }"}, {"sha": "9b11eafaa63c36cee1dd2582c9ee0e2b85eed632", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -72,7 +72,6 @@ mod bar {\n         self::baz::A::foo();\n         self::baz::A::bar(); //~ ERROR: method `bar` is private\n         self::baz::A.foo2();\n-        self::baz::A.bar2(); //~ ERROR: method `bar2` is private\n \n         // this used to cause an ICE in privacy traversal.\n         super::gpub();\n@@ -91,27 +90,21 @@ fn lol() {\n     bar::A::foo();\n     bar::A::bar(); //~ ERROR: method `bar` is private\n     bar::A.foo2();\n-    bar::A.bar2(); //~ ERROR: method `bar2` is private\n }\n \n mod foo {\n     fn test() {\n         ::bar::A::foo();\n         ::bar::A::bar();        //~ ERROR: method `bar` is private\n         ::bar::A.foo2();\n-        ::bar::A.bar2();        //~ ERROR: method `bar2` is private\n-        ::bar::baz::A::foo();   //~ ERROR: method `foo` is inaccessible\n-                                //~^ NOTE: module `baz` is private\n-        ::bar::baz::A::bar();   //~ ERROR: method `bar` is private\n-        ::bar::baz::A.foo2();   //~ ERROR: struct `A` is inaccessible\n-                                //~^ NOTE: module `baz` is private\n-        ::bar::baz::A.bar2();   //~ ERROR: struct `A` is inaccessible\n-                                //~^ ERROR: method `bar2` is private\n-                                //~^^ NOTE: module `baz` is private\n+        ::bar::baz::A::foo();   //~ ERROR: module `baz` is private\n+        ::bar::baz::A::bar();   //~ ERROR: module `baz` is private\n+                                //~^ ERROR: method `bar` is private\n+        ::bar::baz::A.foo2();   //~ ERROR: module `baz` is private\n+        ::bar::baz::A.bar2();   //~ ERROR: module `baz` is private\n \n         let _: isize =\n-        ::bar::B::foo();        //~ ERROR: method `foo` is inaccessible\n-                                //~^ NOTE: trait `B` is private\n+        ::bar::B::foo();        //~ ERROR: trait `B` is private\n         ::lol();\n \n         ::bar::Enum::Pub;\n@@ -126,19 +119,14 @@ mod foo {\n \n         ::bar::gpub();\n \n-        ::bar::baz::foo(); //~ ERROR: function `foo` is inaccessible\n-                           //~^ NOTE: module `baz` is private\n-        ::bar::baz::bar(); //~ ERROR: function `bar` is inaccessible\n-                           //~^ NOTE: module `baz` is private\n+        ::bar::baz::foo(); //~ ERROR: module `baz` is private\n+        ::bar::baz::bar(); //~ ERROR: module `baz` is private\n     }\n \n     fn test2() {\n         use bar::baz::{foo, bar};\n-        //~^ ERROR: function `foo` is inaccessible\n-        //~| NOTE: module `baz` is private\n-        //~| ERROR: function `bar` is inaccessible\n-        //~| NOTE: module `baz` is private\n-\n+        //~^ ERROR: module `baz` is private\n+        //~| ERROR: module `baz` is private\n \n         foo();\n         bar();\n@@ -169,8 +157,7 @@ pub mod mytest {\n     // Even though the inner `A` struct is a publicly exported item (usable from\n     // external crates through `foo::foo`, it should not be accessible through\n     // its definition path (which has the private `i` module).\n-    use self::foo::i::A; //~ ERROR: struct `A` is inaccessible\n-                         //~^ NOTE: module `i` is private\n+    use self::foo::i::A; //~ ERROR: module `i` is private\n \n     pub mod foo {\n         pub use self::i::A as foo;"}, {"sha": "abf702204d16baef221f412b22dd0e3ecc0b8004", "filename": "src/test/compile-fail/privacy2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -16,7 +16,7 @@\n mod bar {\n     pub use self::glob::*;\n \n-    mod glob {\n+    pub mod glob {\n         use foo;\n     }\n }"}, {"sha": "d9f767442845cd7fc95ee8c2d65531d27b008e8a", "filename": "src/test/compile-fail/privacy4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -28,7 +28,7 @@ mod bar {\n pub fn foo() {}\n \n fn test2() {\n-    use bar::glob::gpriv; //~ ERROR: function `gpriv` is private\n+    use bar::glob::gpriv; //~ ERROR: module `glob` is private\n     gpriv();\n }\n "}, {"sha": "e04380f12acafd7b0f6d577b8ad868db8c2a55a7", "filename": "src/test/compile-fail/private-impl-method.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -18,7 +18,14 @@ mod a {\n     }\n }\n \n+fn f() {\n+    impl a::Foo {\n+        fn bar(&self) {} // This should be visible outside `f`\n+    }\n+}\n+\n fn main() {\n     let s = a::Foo { x: 1 };\n+    s.bar();\n     s.foo();    //~ ERROR method `foo` is private\n }"}, {"sha": "1dd8ec0136ef5bf34d432de7b84055911878c886", "filename": "src/test/compile-fail/struct-field-privacy.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -17,7 +17,7 @@ struct A {\n }\n \n mod inner {\n-    struct A {\n+    pub struct A {\n         a: isize,\n         pub b: isize,\n     }\n@@ -28,9 +28,6 @@ mod inner {\n }\n \n fn test(a: A, b: inner::A, c: inner::B, d: xc::A, e: xc::B) {\n-    //~^ ERROR: struct `A` is private\n-    //~^^ ERROR: struct `A` is private\n-\n     a.a;\n     b.a; //~ ERROR: field `a` of struct `inner::A` is private\n     b.b;"}, {"sha": "8507acd26cebec14456e6ff1ca1b81e4a115e961", "filename": "src/test/compile-fail/struct-variant-privacy-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fstruct-variant-privacy-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fstruct-variant-privacy-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-variant-privacy-xc.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -13,7 +13,7 @@ extern crate struct_variant_privacy;\n \n fn f(b: struct_variant_privacy::Bar) { //~ ERROR enum `Bar` is private\n     match b {\n-        struct_variant_privacy::Bar::Baz { a: _a } => {} //~ ERROR variant `Baz` is private\n+        struct_variant_privacy::Bar::Baz { a: _a } => {} //~ ERROR enum `Bar` is private\n     }\n }\n "}, {"sha": "7de4ca62555a24ad6e66b702ac27789fc193ebef", "filename": "src/test/compile-fail/struct-variant-privacy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fstruct-variant-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fstruct-variant-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-variant-privacy.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -15,8 +15,7 @@ mod foo {\n \n fn f(b: foo::Bar) { //~ ERROR enum `Bar` is private\n     match b {\n-        foo::Bar::Baz { a: _a } => {} //~ ERROR variant `Baz` is inaccessible\n-        // ^~ ERROR enum `Bar` is private\n+        foo::Bar::Baz { a: _a } => {} //~ ERROR enum `Bar` is private\n     }\n }\n "}, {"sha": "65801a5704b97fe20dbef9bc058025766e9dfad0", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -10,7 +10,7 @@\n \n // ensure that the ThreadRng isn't/doesn't become accidentally sendable.\n \n-use std::rand;\n+use std::rand; //~ ERROR: module `rand` is private\n \n fn test_send<S: Send>() {}\n "}, {"sha": "cce500800caca0f842c8354f923482fa9a87d076", "filename": "src/test/compile-fail/use-mod-3.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fuse-mod-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fuse-mod-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-mod-3.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -12,8 +12,7 @@ use foo::bar::{\n     self //~ ERROR module `bar` is private\n };\n use foo::bar::{\n-    Bar //~ ERROR type `Bar` is inaccessible\n-    //~^ NOTE module `bar` is private\n+    Bar //~ ERROR module `bar` is private\n };\n \n mod foo {"}, {"sha": "3bd4c780625a42db1cb9096385b5d36b4cf04121", "filename": "src/test/compile-fail/xcrate-private-by-default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs?ref=7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f", "patch": "@@ -43,13 +43,13 @@ fn main() {\n \n     // public items in a private mod should be inaccessible\n     static_priv_by_default::foo::a;\n-    //~^ ERROR: static `a` is private\n+    //~^ ERROR: module `foo` is private\n     static_priv_by_default::foo::b;\n-    //~^ ERROR: function `b` is private\n+    //~^ ERROR: module `foo` is private\n     static_priv_by_default::foo::c;\n-    //~^ ERROR: struct `c` is private\n+    //~^ ERROR: module `foo` is private\n     foo::<static_priv_by_default::foo::d>();\n-    //~^ ERROR: enum `d` is private\n+    //~^ ERROR: module `foo` is private\n     foo::<static_priv_by_default::foo::e>();\n-    //~^ ERROR: type `e` is private\n+    //~^ ERROR: module `foo` is private\n }"}]}