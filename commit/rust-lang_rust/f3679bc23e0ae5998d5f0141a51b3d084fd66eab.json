{"sha": "f3679bc23e0ae5998d5f0141a51b3d084fd66eab", "node_id": "C_kwDOAAsO6NoAKGYzNjc5YmMyM2UwYWU1OTk4ZDVmMDE0MWE1MWIzZDA4NGZkNjZlYWI", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2021-10-29T03:16:28Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2021-10-29T03:16:28Z"}, "message": "move the processing part of `base_expr` into `check_expr_struct_fields`", "tree": {"sha": "6d380a20b4fc03f04e65c65ab02189ca929df75f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d380a20b4fc03f04e65c65ab02189ca929df75f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3679bc23e0ae5998d5f0141a51b3d084fd66eab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3679bc23e0ae5998d5f0141a51b3d084fd66eab", "html_url": "https://github.com/rust-lang/rust/commit/f3679bc23e0ae5998d5f0141a51b3d084fd66eab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3679bc23e0ae5998d5f0141a51b3d084fd66eab/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bde18a0f3dc52754eb52d09da0bc259b1a0e757", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bde18a0f3dc52754eb52d09da0bc259b1a0e757", "html_url": "https://github.com/rust-lang/rust/commit/7bde18a0f3dc52754eb52d09da0bc259b1a0e757"}], "stats": {"total": 196, "additions": 92, "deletions": 104}, "files": [{"sha": "4c7c9ed766deb747b5c5fa40a416330a072a7638", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 90, "deletions": 102, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f3679bc23e0ae5998d5f0141a51b3d084fd66eab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3679bc23e0ae5998d5f0141a51b3d084fd66eab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=f3679bc23e0ae5998d5f0141a51b3d084fd66eab", "patch": "@@ -23,7 +23,7 @@ use crate::type_error_struct;\n \n use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use rustc_ast as ast;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, DiagnosticId};\n@@ -1264,109 +1264,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .emit_err(StructExprNonExhaustive { span: expr.span, what: adt.variant_descr() });\n         }\n \n-        let (error_happened, mut remaining_fields) = self.check_expr_struct_fields(\n+        self.check_expr_struct_fields(\n             adt_ty,\n             expected,\n             expr.hir_id,\n             qpath.span(),\n             variant,\n             fields,\n-            base_expr.is_none(),\n+            base_expr,\n             expr.span,\n         );\n-        if let Some(base_expr) = base_expr {\n-            // If check_expr_struct_fields hit an error, do not attempt to populate\n-            // the fields with the base_expr. This could cause us to hit errors later\n-            // when certain fields are assumed to exist that in fact do not.\n-            if !error_happened {\n-                // FIXME: We are currently creating two branches here in order to maintain\n-                // consistency. But they should be merged as much as possible.\n-                if self.tcx.features().type_changing_struct_update {\n-                    let base_ty = self.check_expr(base_expr);\n-                    match (adt_ty.kind(), base_ty.kind()) {\n-                        (ty::Adt(adt, substs), ty::Adt(base_adt, base_subs)) if adt == base_adt => {\n-                            if !adt.is_struct() {\n-                                self.tcx.sess.emit_err(FunctionalRecordUpdateOnNonStruct {\n-                                    span: base_expr.span,\n-                                });\n-                            };\n-                            let fru_field_types = variant\n-                                .fields\n-                                .iter()\n-                                .map(|f| {\n-                                    let fru_ty = self.normalize_associated_types_in(\n-                                        expr.span,\n-                                        self.field_ty(base_expr.span, f, base_subs),\n-                                    );\n-                                    let ident = self.tcx.adjust_ident(f.ident, variant.def_id);\n-                                    if remaining_fields.remove(&ident) {\n-                                        let target_ty = self.field_ty(base_expr.span, f, substs);\n-                                        let cause = self.misc(base_expr.span);\n-                                        match self.at(&cause, self.param_env).sup(target_ty, fru_ty)\n-                                        {\n-                                            Ok(InferOk { obligations, value: () }) => {\n-                                                self.register_predicates(obligations)\n-                                            }\n-                                            // FIXME: Needs better diagnostics here\n-                                            Err(_) => self\n-                                                .report_mismatched_types(\n-                                                    &cause,\n-                                                    target_ty,\n-                                                    fru_ty,\n-                                                    FieldMisMatch(variant.ident.name, ident.name),\n-                                                )\n-                                                .emit(),\n-                                        }\n-                                    }\n-                                    fru_ty\n-                                })\n-                                .collect();\n-\n-                            self.typeck_results\n-                                .borrow_mut()\n-                                .fru_field_types_mut()\n-                                .insert(expr.hir_id, fru_field_types);\n-                        }\n-                        _ => {\n-                            self.report_mismatched_types(\n-                                &self.misc(base_expr.span),\n-                                adt_ty,\n-                                base_ty,\n-                                Mismatch,\n-                            )\n-                            .emit();\n-                        }\n-                    }\n-                } else {\n-                    self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {});\n-                    match adt_ty.kind() {\n-                        ty::Adt(adt, substs) if adt.is_struct() => {\n-                            let fru_field_types = adt\n-                                .non_enum_variant()\n-                                .fields\n-                                .iter()\n-                                .map(|f| {\n-                                    self.normalize_associated_types_in(\n-                                        expr.span,\n-                                        f.ty(self.tcx, substs),\n-                                    )\n-                                })\n-                                .collect();\n-\n-                            self.typeck_results\n-                                .borrow_mut()\n-                                .fru_field_types_mut()\n-                                .insert(expr.hir_id, fru_field_types);\n-                        }\n-                        _ => {\n-                            self.tcx.sess.emit_err(FunctionalRecordUpdateOnNonStruct {\n-                                span: base_expr.span,\n-                            });\n-                        }\n-                    }\n-                };\n-            }\n-        }\n+\n         self.require_type_is_sized(adt_ty, expr.span, traits::StructInitializerSized);\n         adt_ty\n     }\n@@ -1379,9 +1287,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n         ast_fields: &'tcx [hir::ExprField<'tcx>],\n-        check_completeness: bool,\n+        base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n         expr_span: Span,\n-    ) -> (bool, FxHashSet<Ident>) {\n+    ) {\n         let tcx = self.tcx;\n \n         let adt_ty_hint = self\n@@ -1456,19 +1364,99 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 )\n                 .emit();\n             }\n-        } else if check_completeness && !error_happened && !remaining_fields.is_empty() {\n+        }\n+\n+        // If check_expr_struct_fields hit an error, do not attempt to populate\n+        // the fields with the base_expr. This could cause us to hit errors later\n+        // when certain fields are assumed to exist that in fact do not.\n+        if error_happened {\n+            return;\n+        }\n+\n+        if let Some(base_expr) = base_expr {\n+            // FIXME: We are currently creating two branches here in order to maintain\n+            // consistency. But they should be merged as much as possible.\n+            let fru_tys = if self.tcx.features().type_changing_struct_update {\n+                let base_ty = self.check_expr(base_expr);\n+                match (adt_ty.kind(), base_ty.kind()) {\n+                    (ty::Adt(adt, substs), ty::Adt(base_adt, base_subs)) if adt == base_adt => {\n+                        if !adt.is_struct() {\n+                            self.tcx.sess.emit_err(FunctionalRecordUpdateOnNonStruct {\n+                                span: base_expr.span,\n+                            });\n+                        };\n+                        variant\n+                            .fields\n+                            .iter()\n+                            .map(|f| {\n+                                let fru_ty = self.normalize_associated_types_in(\n+                                    expr_span,\n+                                    self.field_ty(base_expr.span, f, base_subs),\n+                                );\n+                                let ident = self.tcx.adjust_ident(f.ident, variant.def_id);\n+                                if let Some(_) = remaining_fields.remove(&ident) {\n+                                    let target_ty = self.field_ty(base_expr.span, f, substs);\n+                                    let cause = self.misc(base_expr.span);\n+                                    match self.at(&cause, self.param_env).sup(target_ty, fru_ty) {\n+                                        Ok(InferOk { obligations, value: () }) => {\n+                                            self.register_predicates(obligations)\n+                                        }\n+                                        // FIXME: Need better diagnostics for `FieldMisMatch` error\n+                                        Err(_) => self\n+                                            .report_mismatched_types(\n+                                                &cause,\n+                                                target_ty,\n+                                                fru_ty,\n+                                                FieldMisMatch(variant.ident.name, ident.name),\n+                                            )\n+                                            .emit(),\n+                                    }\n+                                }\n+                                fru_ty\n+                            })\n+                            .collect()\n+                    }\n+                    _ => {\n+                        return self\n+                            .report_mismatched_types(\n+                                &self.misc(base_expr.span),\n+                                adt_ty,\n+                                base_ty,\n+                                Mismatch,\n+                            )\n+                            .emit();\n+                    }\n+                }\n+            } else {\n+                self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {});\n+                match adt_ty.kind() {\n+                    ty::Adt(adt, substs) if adt.is_struct() => variant\n+                        .fields\n+                        .iter()\n+                        .map(|f| {\n+                            self.normalize_associated_types_in(expr_span, f.ty(self.tcx, substs))\n+                        })\n+                        .collect(),\n+                    _ => {\n+                        return self\n+                            .tcx\n+                            .sess\n+                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n+                    }\n+                }\n+            };\n+            self.typeck_results.borrow_mut().fru_field_types_mut().insert(expr_id, fru_tys);\n+        } else if kind_name != \"union\" && !remaining_fields.is_empty() {\n             let inaccessible_remaining_fields = remaining_fields.iter().any(|(_, (_, field))| {\n                 !field.vis.is_accessible_from(tcx.parent_module(expr_id).to_def_id(), tcx)\n             });\n \n             if inaccessible_remaining_fields {\n                 self.report_inaccessible_fields(adt_ty, span);\n             } else {\n-                self.report_missing_fields(adt_ty, span, remaining_fields.clone());\n+                self.report_missing_fields(adt_ty, span, remaining_fields);\n             }\n         }\n-\n-        (error_happened, remaining_fields.iter().map(|(ident, _)| ident.clone()).collect())\n     }\n \n     fn check_struct_fields_on_error("}, {"sha": "81888ee1d4fdc6339cf54310d72b7a3cd165ed7b", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/feature-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3679bc23e0ae5998d5f0141a51b3d084fd66eab/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3679bc23e0ae5998d5f0141a51b3d084fd66eab/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.rs?ref=f3679bc23e0ae5998d5f0141a51b3d084fd66eab", "patch": "@@ -17,11 +17,11 @@ fn update_to_state2() {\n         common_field1: \"hello\",\n         common_field2: 2,\n     };\n+    // FIXME: this should trigger feature gate\n     let m2: Machine<State2> = Machine {\n         state: State2,\n         ..m1 //~ ERROR mismatched types\n     };\n-    // FIXME: this should trigger feature gate\n     assert_eq!(State2, m2.state);\n }\n "}, {"sha": "19059593844d6db67c3225821417dfc8c657c4ec", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/feature-gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3679bc23e0ae5998d5f0141a51b3d084fd66eab/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3679bc23e0ae5998d5f0141a51b3d084fd66eab/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.stderr?ref=f3679bc23e0ae5998d5f0141a51b3d084fd66eab", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/feature-gate.rs:22:11\n+  --> $DIR/feature-gate.rs:23:11\n    |\n LL |         ..m1\n    |           ^^ expected struct `State2`, found struct `State1`"}]}