{"sha": "4e3b196670364df6370ea9010b58c19e578fee1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlM2IxOTY2NzAzNjRkZjYzNzBlYTkwMTBiNThjMTllNTc4ZmVlMWE=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2013-06-20T05:44:34Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-20T14:43:03Z"}, "message": "libextra: cleanup warnings", "tree": {"sha": "d84028465d4517c641360e371db4b7e329a6e365", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d84028465d4517c641360e371db4b7e329a6e365"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e3b196670364df6370ea9010b58c19e578fee1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3b196670364df6370ea9010b58c19e578fee1a", "html_url": "https://github.com/rust-lang/rust/commit/4e3b196670364df6370ea9010b58c19e578fee1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e3b196670364df6370ea9010b58c19e578fee1a/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b6ecf60d894cb54a7f59e768ec7859186dc9479b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ecf60d894cb54a7f59e768ec7859186dc9479b", "html_url": "https://github.com/rust-lang/rust/commit/b6ecf60d894cb54a7f59e768ec7859186dc9479b"}], "stats": {"total": 281, "additions": 134, "deletions": 147}, "files": [{"sha": "661224b0a803722fd224e10060575b65d02c1523", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4e3b196670364df6370ea9010b58c19e578fee1a/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3b196670364df6370ea9010b58c19e578fee1a/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=4e3b196670364df6370ea9010b58c19e578fee1a", "patch": "@@ -200,15 +200,13 @@ impl<T:Owned> MutexARC<T> {\n      */\n     #[inline]\n     pub unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            // Borrowck would complain about this if the function were\n-            // not already unsafe. See borrow_rwlock, far below.\n-            do (&(*state).lock).lock {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail(&mut (*state).failed);\n-                blk(&mut (*state).data)\n-            }\n+        let state = self.x.get();\n+        // Borrowck would complain about this if the function were\n+        // not already unsafe. See borrow_rwlock, far below.\n+        do (&(*state).lock).lock {\n+            check_poison(true, (*state).failed);\n+            let _z = PoisonOnFail(&mut (*state).failed);\n+            blk(&mut (*state).data)\n         }\n     }\n "}, {"sha": "9a8ee39593646b32ed0c8be5f496d2291ac6e58e", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e3b196670364df6370ea9010b58c19e578fee1a/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3b196670364df6370ea9010b58c19e578fee1a/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=4e3b196670364df6370ea9010b58c19e578fee1a", "patch": "@@ -516,7 +516,6 @@ pub mod bytepipes {\n     use core::comm::{Port, Chan};\n     use core::comm;\n     use core::io::{Writer, Reader, ReaderUtil};\n-    use core::vec;\n \n     pub struct ReaderBytePort<R> {\n         reader: R"}, {"sha": "51d744955b81a8fb99fc7d7e73279fa86b5cf6f8", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 127, "deletions": 137, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/4e3b196670364df6370ea9010b58c19e578fee1a/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3b196670364df6370ea9010b58c19e578fee1a/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=4e3b196670364df6370ea9010b58c19e578fee1a", "patch": "@@ -181,90 +181,88 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n         debug!(\"stream_handle_ptr outside interact %?\",\n                         stream_handle_ptr);\n         do iotask::interact(iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"in interact cb for tcp client connect..\");\n-                debug!(\"stream_handle_ptr in interact %?\",\n-                                stream_handle_ptr);\n-                match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n-                    0i32 => {\n-                        debug!(\"tcp_init successful\");\n-                        debug!(\"dealing w/ ipv4 connection..\");\n-                        let connect_req_ptr: *uv::ll::uv_connect_t =\n-                            &(*socket_data_ptr).connect_req;\n-                        let addr_str = ip::format_addr(&input_ip);\n-                        let connect_result = match input_ip {\n-                            ip::Ipv4(ref addr) => {\n-                                // have to \"recreate\" the\n-                                // sockaddr_in/6 since the ip_addr\n-                                // discards the port info.. should\n-                                // probably add an additional rust\n-                                // type that actually is closer to\n-                                // what the libuv API expects (ip str\n-                                // + port num)\n-                                debug!(\"addr: %?\", addr);\n-                                let in_addr = uv::ll::ip4_addr(addr_str,\n-                                                               port as int);\n-                                uv::ll::tcp_connect(\n-                                    connect_req_ptr,\n-                                    stream_handle_ptr,\n-                                    &in_addr,\n-                                    tcp_connect_on_connect_cb)\n-                            }\n-                            ip::Ipv6(ref addr) => {\n-                                debug!(\"addr: %?\", addr);\n-                                let in_addr = uv::ll::ip6_addr(addr_str,\n-                                                               port as int);\n-                                uv::ll::tcp_connect6(\n-                                    connect_req_ptr,\n-                                    stream_handle_ptr,\n-                                    &in_addr,\n-                                    tcp_connect_on_connect_cb)\n-                            }\n-                        };\n-                        match connect_result {\n-                            0i32 => {\n-                                debug!(\"tcp_connect successful: \\\n-                                        stream %x,\n-                                        socket data %x\",\n-                                       stream_handle_ptr as uint,\n-                                       socket_data_ptr as uint);\n-                                // reusable data that we'll have for the\n-                                // duration..\n-                                uv::ll::set_data_for_uv_handle(\n-                                    stream_handle_ptr,\n-                                    socket_data_ptr as\n-                                    *libc::c_void);\n-                                // just so the connect_cb can send the\n-                                // outcome..\n-                                uv::ll::set_data_for_req(connect_req_ptr,\n-                                                         conn_data_ptr);\n-                                debug!(\"leaving tcp_connect interact cb...\");\n-                                // let tcp_connect_on_connect_cb send on\n-                                // the result_ch, now..\n-                            }\n-                            _ => {\n-                                // immediate connect\n-                                // failure.. probably a garbage ip or\n-                                // somesuch\n-                                let err_data =\n-                                    uv::ll::get_last_err_data(loop_ptr);\n-                                let result_ch = (*conn_data_ptr)\n-                                    .result_ch.clone();\n-                                result_ch.send(ConnFailure(err_data));\n-                                uv::ll::set_data_for_uv_handle(\n-                                    stream_handle_ptr,\n-                                    conn_data_ptr);\n-                                uv::ll::close(stream_handle_ptr,\n-                                              stream_error_close_cb);\n-                            }\n+            debug!(\"in interact cb for tcp client connect..\");\n+            debug!(\"stream_handle_ptr in interact %?\",\n+                            stream_handle_ptr);\n+            match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n+                0i32 => {\n+                    debug!(\"tcp_init successful\");\n+                    debug!(\"dealing w/ ipv4 connection..\");\n+                    let connect_req_ptr: *uv::ll::uv_connect_t =\n+                        &(*socket_data_ptr).connect_req;\n+                    let addr_str = ip::format_addr(&input_ip);\n+                    let connect_result = match input_ip {\n+                        ip::Ipv4(ref addr) => {\n+                            // have to \"recreate\" the\n+                            // sockaddr_in/6 since the ip_addr\n+                            // discards the port info.. should\n+                            // probably add an additional rust\n+                            // type that actually is closer to\n+                            // what the libuv API expects (ip str\n+                            // + port num)\n+                            debug!(\"addr: %?\", addr);\n+                            let in_addr = uv::ll::ip4_addr(addr_str,\n+                                                           port as int);\n+                            uv::ll::tcp_connect(\n+                                connect_req_ptr,\n+                                stream_handle_ptr,\n+                                &in_addr,\n+                                tcp_connect_on_connect_cb)\n+                        }\n+                        ip::Ipv6(ref addr) => {\n+                            debug!(\"addr: %?\", addr);\n+                            let in_addr = uv::ll::ip6_addr(addr_str,\n+                                                           port as int);\n+                            uv::ll::tcp_connect6(\n+                                connect_req_ptr,\n+                                stream_handle_ptr,\n+                                &in_addr,\n+                                tcp_connect_on_connect_cb)\n+                        }\n+                    };\n+                    match connect_result {\n+                        0i32 => {\n+                            debug!(\"tcp_connect successful: \\\n+                                    stream %x,\n+                                    socket data %x\",\n+                                   stream_handle_ptr as uint,\n+                                   socket_data_ptr as uint);\n+                            // reusable data that we'll have for the\n+                            // duration..\n+                            uv::ll::set_data_for_uv_handle(\n+                                stream_handle_ptr,\n+                                socket_data_ptr as\n+                                *libc::c_void);\n+                            // just so the connect_cb can send the\n+                            // outcome..\n+                            uv::ll::set_data_for_req(connect_req_ptr,\n+                                                     conn_data_ptr);\n+                            debug!(\"leaving tcp_connect interact cb...\");\n+                            // let tcp_connect_on_connect_cb send on\n+                            // the result_ch, now..\n+                        }\n+                        _ => {\n+                            // immediate connect\n+                            // failure.. probably a garbage ip or\n+                            // somesuch\n+                            let err_data =\n+                                uv::ll::get_last_err_data(loop_ptr);\n+                            let result_ch = (*conn_data_ptr)\n+                                .result_ch.clone();\n+                            result_ch.send(ConnFailure(err_data));\n+                            uv::ll::set_data_for_uv_handle(\n+                                stream_handle_ptr,\n+                                conn_data_ptr);\n+                            uv::ll::close(stream_handle_ptr,\n+                                          stream_error_close_cb);\n                         }\n                     }\n-                    _ => {\n-                        // failure to create a tcp handle\n-                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        let result_ch = (*conn_data_ptr).result_ch.clone();\n-                        result_ch.send(ConnFailure(err_data));\n-                    }\n+                }\n+                _ => {\n+                    // failure to create a tcp handle\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    let result_ch = (*conn_data_ptr).result_ch.clone();\n+                    result_ch.send(ConnFailure(err_data));\n                 }\n             }\n         }\n@@ -1015,14 +1013,12 @@ fn tear_down_socket_data(socket_data: @TcpSocketData) {\n         let close_data_ptr: *TcpSocketCloseData = &close_data;\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\n-                    \"interact dtor for tcp_socket stream %? loop %?\",\n-                         stream_handle_ptr, loop_ptr);\n-                uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                               close_data_ptr);\n-                uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n-            }\n+            debug!(\n+                \"interact dtor for tcp_socket stream %? loop %?\",\n+                     stream_handle_ptr, loop_ptr);\n+            uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                           close_data_ptr);\n+            uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n         };\n         closed_po.recv();\n         //the line below will most likely crash\n@@ -1082,19 +1078,17 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n         let (stop_po, stop_ch) = stream::<Option<TcpErrData>>();\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"in interact cb for tcp::read_stop\");\n-                match uv::ll::read_stop(stream_handle_ptr\n-                                        as *uv::ll::uv_stream_t) {\n-                    0i32 => {\n-                        debug!(\"successfully called uv_read_stop\");\n-                        stop_ch.send(None);\n-                    }\n-                    _ => {\n-                        debug!(\"failure in calling uv_read_stop\");\n-                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        stop_ch.send(Some(err_data.to_tcp_err()));\n-                    }\n+            debug!(\"in interact cb for tcp::read_stop\");\n+            match uv::ll::read_stop(stream_handle_ptr\n+                                    as *uv::ll::uv_stream_t) {\n+                0i32 => {\n+                    debug!(\"successfully called uv_read_stop\");\n+                    stop_ch.send(None);\n+                }\n+                _ => {\n+                    debug!(\"failure in calling uv_read_stop\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    stop_ch.send(Some(err_data.to_tcp_err()));\n                 }\n             }\n         }\n@@ -1114,22 +1108,20 @@ fn read_start_common_impl(socket_data: *TcpSocketData)\n         let (start_po, start_ch) = stream::<Option<uv::ll::uv_err_data>>();\n         debug!(\"in tcp::read_start before interact loop\");\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"in tcp::read_start interact cb %?\",\n-                                loop_ptr);\n-                match uv::ll::read_start(stream_handle_ptr\n-                                         as *uv::ll::uv_stream_t,\n-                                         on_alloc_cb,\n-                                         on_tcp_read_cb) {\n-                    0i32 => {\n-                        debug!(\"success doing uv_read_start\");\n-                        start_ch.send(None);\n-                    }\n-                    _ => {\n-                        debug!(\"error attempting uv_read_start\");\n-                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        start_ch.send(Some(err_data));\n-                    }\n+            debug!(\"in tcp::read_start interact cb %?\",\n+                            loop_ptr);\n+            match uv::ll::read_start(stream_handle_ptr\n+                                     as *uv::ll::uv_stream_t,\n+                                     on_alloc_cb,\n+                                     on_tcp_read_cb) {\n+                0i32 => {\n+                    debug!(\"success doing uv_read_start\");\n+                    start_ch.send(None);\n+                }\n+                _ => {\n+                    debug!(\"error attempting uv_read_start\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    start_ch.send(Some(err_data));\n                 }\n             }\n         }\n@@ -1166,24 +1158,22 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n         };\n         let write_data_ptr: *WriteReqData = &write_data;\n         do iotask::interact(&(*socket_data_ptr).iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"in interact cb for tcp::write %?\",\n-                                loop_ptr);\n-                match uv::ll::write(write_req_ptr,\n-                                    stream_handle_ptr,\n-                                    write_buf_vec_ptr,\n-                                    tcp_write_complete_cb) {\n-                    0i32 => {\n-                        debug!(\"uv_write() invoked successfully\");\n-                        uv::ll::set_data_for_req(write_req_ptr,\n-                                                 write_data_ptr);\n-                    }\n-                    _ => {\n-                        debug!(\"error invoking uv_write()\");\n-                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        let result_ch = (*write_data_ptr).result_ch.clone();\n-                        result_ch.send(TcpWriteError(err_data.to_tcp_err()));\n-                    }\n+            debug!(\"in interact cb for tcp::write %?\",\n+                            loop_ptr);\n+            match uv::ll::write(write_req_ptr,\n+                                stream_handle_ptr,\n+                                write_buf_vec_ptr,\n+                                tcp_write_complete_cb) {\n+                0i32 => {\n+                    debug!(\"uv_write() invoked successfully\");\n+                    uv::ll::set_data_for_req(write_req_ptr,\n+                                             write_data_ptr);\n+                }\n+                _ => {\n+                    debug!(\"error invoking uv_write()\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    let result_ch = (*write_data_ptr).result_ch.clone();\n+                    result_ch.send(TcpWriteError(err_data.to_tcp_err()));\n                 }\n             }\n         }"}]}