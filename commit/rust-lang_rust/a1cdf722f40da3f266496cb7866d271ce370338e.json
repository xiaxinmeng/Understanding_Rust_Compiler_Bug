{"sha": "a1cdf722f40da3f266496cb7866d271ce370338e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExY2RmNzIyZjQwZGEzZjI2NjQ5NmNiNzg2NmQyNzFjZTM3MDMzOGU=", "commit": {"author": {"name": "oli", "email": "github35764891676564198441@oli-obk.de", "date": "2020-11-15T13:04:30Z"}, "committer": {"name": "oli", "email": "github35764891676564198441@oli-obk.de", "date": "2020-11-17T09:07:23Z"}, "message": "Fix exhaustiveness in case a byte string literal is used at slice type", "tree": {"sha": "312b4f3e1a924b3bcd27b2c274193370b06e14e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/312b4f3e1a924b3bcd27b2c274193370b06e14e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1cdf722f40da3f266496cb7866d271ce370338e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1cdf722f40da3f266496cb7866d271ce370338e", "html_url": "https://github.com/rust-lang/rust/commit/a1cdf722f40da3f266496cb7866d271ce370338e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1cdf722f40da3f266496cb7866d271ce370338e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30e49a9ead550551e879af64ba91a0316da1c422", "url": "https://api.github.com/repos/rust-lang/rust/commits/30e49a9ead550551e879af64ba91a0316da1c422", "html_url": "https://github.com/rust-lang/rust/commit/30e49a9ead550551e879af64ba91a0316da1c422"}], "stats": {"total": 125, "additions": 113, "deletions": 12}, "files": [{"sha": "fdbfafd61427dd527a7cfe59cd47eccb72b1a1f5", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1cdf722f40da3f266496cb7866d271ce370338e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1cdf722f40da3f266496cb7866d271ce370338e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=a1cdf722f40da3f266496cb7866d271ce370338e", "patch": "@@ -418,6 +418,12 @@ pub struct TypeckResults<'tcx> {\n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n+\n+    /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n+    /// as `&[u8]`, depending on the pattern  in which they are used.\n+    /// This hashset records all instances where we behave\n+    /// like this to allow `const_to_pat` to reliably handle this situation.\n+    pub treat_byte_string_as_slice: ItemLocalSet,\n }\n \n impl<'tcx> TypeckResults<'tcx> {\n@@ -443,6 +449,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             concrete_opaque_types: Default::default(),\n             closure_captures: Default::default(),\n             generator_interior_types: Default::default(),\n+            treat_byte_string_as_slice: Default::default(),\n         }\n     }\n \n@@ -677,6 +684,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             ref concrete_opaque_types,\n             ref closure_captures,\n             ref generator_interior_types,\n+            ref treat_byte_string_as_slice,\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n@@ -710,6 +718,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             concrete_opaque_types.hash_stable(hcx, hasher);\n             closure_captures.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);\n+            treat_byte_string_as_slice.hash_stable(hcx, hasher);\n         })\n     }\n }"}, {"sha": "32fc0f008e972f706893c79007b6f8227e04c113", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a1cdf722f40da3f266496cb7866d271ce370338e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1cdf722f40da3f266496cb7866d271ce370338e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=a1cdf722f40da3f266496cb7866d271ce370338e", "patch": "@@ -18,22 +18,20 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Converts an evaluated constant to a pattern (if possible).\n     /// This means aggregate values (like structs and enums) are converted\n     /// to a pattern that matches the value (as if you'd compared via structural equality).\n+    #[instrument(skip(self))]\n     pub(super) fn const_to_pat(\n         &self,\n         cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n         mir_structural_match_violation: bool,\n     ) -> Pat<'tcx> {\n-        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n-        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n-\n         let pat = self.tcx.infer_ctxt().enter(|infcx| {\n             let mut convert = ConstToPat::new(self, id, span, infcx);\n             convert.to_pat(cv, mir_structural_match_violation)\n         });\n \n-        debug!(\"const_to_pat: pat={:?}\", pat);\n+        debug!(?pat);\n         pat\n     }\n }\n@@ -61,6 +59,8 @@ struct ConstToPat<'a, 'tcx> {\n     infcx: InferCtxt<'a, 'tcx>,\n \n     include_lint_checks: bool,\n+\n+    treat_byte_string_as_slice: bool,\n }\n \n mod fallback_to_const_ref {\n@@ -88,6 +88,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         span: Span,\n         infcx: InferCtxt<'a, 'tcx>,\n     ) -> Self {\n+        trace!(?pat_ctxt.typeck_results.hir_owner);\n         ConstToPat {\n             id,\n             span,\n@@ -97,6 +98,10 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             saw_const_match_error: Cell::new(false),\n             saw_const_match_lint: Cell::new(false),\n             behind_reference: Cell::new(false),\n+            treat_byte_string_as_slice: pat_ctxt\n+                .typeck_results\n+                .treat_byte_string_as_slice\n+                .contains(&id.local_id),\n         }\n     }\n \n@@ -153,6 +158,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         cv: &'tcx ty::Const<'tcx>,\n         mir_structural_match_violation: bool,\n     ) -> Pat<'tcx> {\n+        trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n         // invoked except by this method.\n@@ -384,7 +390,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     }\n                     PatKind::Wild\n                 }\n-                // `&str` and `&[u8]` are represented as `ConstValue::Slice`, let's keep using this\n+                // `&str` is represented as `ConstValue::Slice`, let's keep using this\n                 // optimization for now.\n                 ty::Str => PatKind::Constant { value: cv },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n@@ -393,11 +399,33 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n                 // has no negative effects on pattern matching, even if we're actually matching on\n                 // arrays.\n-                ty::Array(..) |\n+                ty::Array(..) if !self.treat_byte_string_as_slice => {\n+                    let old = self.behind_reference.replace(true);\n+                    let array = tcx.deref_const(self.param_env.and(cv));\n+                    let val = PatKind::Deref {\n+                        subpattern: Pat {\n+                            kind: Box::new(PatKind::Array {\n+                                prefix: tcx\n+                                    .destructure_const(param_env.and(array))\n+                                    .fields\n+                                    .iter()\n+                                    .map(|val| self.recur(val, false))\n+                                    .collect::<Result<_, _>>()?,\n+                                slice: None,\n+                                suffix: vec![],\n+                            }),\n+                            span,\n+                            ty: pointee_ty,\n+                        },\n+                    };\n+                    self.behind_reference.set(old);\n+                    val\n+                }\n+                ty::Array(elem_ty, _) |\n                 // Cannot merge this with the catch all branch below, because the `const_deref`\n                 // changes the type from slice to array, we need to keep the original type in the\n                 // pattern.\n-                ty::Slice(..) => {\n+                ty::Slice(elem_ty) => {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_const(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n@@ -413,7 +441,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                                 suffix: vec![],\n                             }),\n                             span,\n-                            ty: pointee_ty,\n+                            ty: tcx.mk_slice(elem_ty),\n                         },\n                     };\n                     self.behind_reference.set(old);"}, {"sha": "fa7898f03e39a2eacef37bc180eac1a58239cb97", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1cdf722f40da3f266496cb7866d271ce370338e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1cdf722f40da3f266496cb7866d271ce370338e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=a1cdf722f40da3f266496cb7866d271ce370338e", "patch": "@@ -149,15 +149,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// Outside of this module, `check_pat_top` should always be used.\n     /// Conversely, inside this module, `check_pat_top` should never be used.\n+    #[instrument(skip(self, ti))]\n     fn check_pat(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         ti: TopInfo<'tcx>,\n     ) {\n-        debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n-\n         let path_res = match &pat.kind {\n             PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n             _ => None,\n@@ -398,6 +397,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let ty::Ref(_, inner_ty, _) = expected.kind() {\n                 if matches!(inner_ty.kind(), ty::Slice(_)) {\n                     let tcx = self.tcx;\n+                    trace!(?lt.hir_id.local_id, \"polymorphic byte string lit\");\n+                    self.typeck_results\n+                        .borrow_mut()\n+                        .treat_byte_string_as_slice\n+                        .insert(lt.hir_id.local_id);\n                     pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n                 }\n             }"}, {"sha": "9c22459e272c094b6a8c442efb2a8527be575392", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1cdf722f40da3f266496cb7866d271ce370338e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1cdf722f40da3f266496cb7866d271ce370338e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=a1cdf722f40da3f266496cb7866d271ce370338e", "patch": "@@ -70,6 +70,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n         wbcx.typeck_results.used_trait_imports = used_trait_imports;\n \n+        wbcx.typeck_results.treat_byte_string_as_slice =\n+            mem::take(&mut self.typeck_results.borrow_mut().treat_byte_string_as_slice);\n+\n         wbcx.typeck_results.closure_captures =\n             mem::take(&mut self.typeck_results.borrow_mut().closure_captures);\n "}, {"sha": "cb44c1da76ba5e22f58ddace30ac630c624deae8", "filename": "src/test/ui/match/type_polymorphic_byte_str_literals.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a1cdf722f40da3f266496cb7866d271ce370338e/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1cdf722f40da3f266496cb7866d271ce370338e/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.rs?ref=a1cdf722f40da3f266496cb7866d271ce370338e", "patch": "@@ -0,0 +1,36 @@\n+#[deny(unreachable_patterns)]\n+\n+fn parse_data1(data: &[u8]) -> u32 {\n+    match data {\n+        b\"\" => 1,\n+        _ => 2,\n+    }\n+}\n+\n+fn parse_data2(data: &[u8]) -> u32 {\n+    match data { //~ ERROR non-exhaustive patterns: `&[_, ..]` not covered\n+        b\"\" => 1,\n+    }\n+}\n+\n+fn parse_data3(data: &[u8; 0]) -> u8 {\n+    match data {\n+        b\"\" => 1,\n+    }\n+}\n+\n+fn parse_data4(data: &[u8]) -> u8 {\n+    match data { //~ ERROR non-exhaustive patterns\n+        b\"aaa\" => 0,\n+        [_, _, _] => 1,\n+    }\n+}\n+\n+fn parse_data5(data: &[u8; 3]) -> u8 {\n+    match data {\n+        b\"aaa\" => 0,\n+        [_, _, _] => 1,\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6ce53a4f21ea21ed1402d490fdb54b34fef3ab8a", "filename": "src/test/ui/match/type_polymorphic_byte_str_literals.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a1cdf722f40da3f266496cb7866d271ce370338e/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1cdf722f40da3f266496cb7866d271ce370338e/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.stderr?ref=a1cdf722f40da3f266496cb7866d271ce370338e", "patch": "@@ -0,0 +1,21 @@\n+error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n+  --> $DIR/type_polymorphic_byte_str_literals.rs:11:11\n+   |\n+LL |     match data {\n+   |           ^^^^ pattern `&[_, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[u8]`\n+\n+error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n+  --> $DIR/type_polymorphic_byte_str_literals.rs:23:11\n+   |\n+LL |     match data {\n+   |           ^^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[u8]`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "ffc8433403fd59d96de8e2caa10fe9750c066106", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1cdf722f40da3f266496cb7866d271ce370338e/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1cdf722f40da3f266496cb7866d271ce370338e/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=a1cdf722f40da3f266496cb7866d271ce370338e", "patch": "@@ -7,11 +7,11 @@ LL |     match buf {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8; 4]`\n \n-error[E0004]: non-exhaustive patterns: `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n   --> $DIR/match-byte-array-patterns-2.rs:10:11\n    |\n LL |     match buf {\n-   |           ^^^ patterns `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n+   |           ^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8]`"}]}