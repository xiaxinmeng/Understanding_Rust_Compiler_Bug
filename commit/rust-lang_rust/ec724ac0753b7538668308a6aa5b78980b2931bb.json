{"sha": "ec724ac0753b7538668308a6aa5b78980b2931bb", "node_id": "C_kwDOAAsO6NoAKGVjNzI0YWMwNzUzYjc1Mzg2NjgzMDhhNmFhNWI3ODk4MGIyOTMxYmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-18T23:02:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-18T23:02:53Z"}, "message": "Auto merge of #89229 - oli-obk:i_love_inferctxt, r=jackh726\n\nRemove redundant member-constraint check\n\nimpl trait will, for each lifetime in the hidden type, register a \"member constraint\" that says the lifetime must be equal or outlive one of the lifetimes of the impl trait. These member constraints will be solved by borrowck\n\nBut, as you can see in the big red block of removed code, there was an ad-hoc check for member constraints happening at the site where they get registered. This check had some minor effects on diagnostics, but will fall down on its feet with my big type alias impl trait refactor. So we removed it and I pulled the removal out into a (hopefully) reviewable PR that works on master directly.", "tree": {"sha": "6663310841a39d05992544c6178dcdfb6c3bad0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6663310841a39d05992544c6178dcdfb6c3bad0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec724ac0753b7538668308a6aa5b78980b2931bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec724ac0753b7538668308a6aa5b78980b2931bb", "html_url": "https://github.com/rust-lang/rust/commit/ec724ac0753b7538668308a6aa5b78980b2931bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec724ac0753b7538668308a6aa5b78980b2931bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd41e09da334697c0f993b36685cb599061d9faa", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd41e09da334697c0f993b36685cb599061d9faa", "html_url": "https://github.com/rust-lang/rust/commit/bd41e09da334697c0f993b36685cb599061d9faa"}, {"sha": "4413f8c709b0ef71033c2c5e6c8921610ba61577", "url": "https://api.github.com/repos/rust-lang/rust/commits/4413f8c709b0ef71033c2c5e6c8921610ba61577", "html_url": "https://github.com/rust-lang/rust/commit/4413f8c709b0ef71033c2c5e6c8921610ba61577"}], "stats": {"total": 973, "additions": 271, "deletions": 702}, "files": [{"sha": "22bb3a29425ee1b49d5b44a3bc228030af3d0ac7", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -689,6 +689,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // them down.\n         let mut choice_regions: Vec<ty::RegionVid> = choice_regions.to_vec();\n \n+        // Convert to the SCC representative: sometimes we have inference\n+        // variables in the member constraint that wind up equated with\n+        // universal regions. The scc representative is the minimal numbered\n+        // one from the corresponding scc so it will be the universal region\n+        // if one exists.\n+        for c_r in &mut choice_regions {\n+            let scc = self.constraint_sccs.scc(*c_r);\n+            *c_r = self.scc_representatives[scc];\n+        }\n+\n         // The 'member region' in a member constraint is part of the\n         // hidden type, which must be in the root universe. Therefore,\n         // it cannot have any placeholders in its value."}, {"sha": "f71cf09ecf6304941c6fb6d2a04497185ed0ad58", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,20 +1,18 @@\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n-use rustc_infer::infer::free_regions::FreeRegionRelations;\n use rustc_infer::infer::outlives;\n use rustc_infer::infer::region_constraints::GenericKind;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::query::OutlivesBound;\n-use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt};\n+use rustc_middle::ty::{self, RegionVid, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOp};\n use std::rc::Rc;\n use type_op::TypeOpOutput;\n \n use crate::{\n-    nll::ToRegionVid,\n     type_check::constraint_conversion,\n     type_check::{Locations, MirTypeckRegionConstraints},\n     universal_regions::UniversalRegions,\n@@ -383,21 +381,3 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n         }\n     }\n }\n-\n-/// This trait is used by the `impl-trait` constraint code to abstract\n-/// over the `FreeRegionMap` from lexical regions and\n-/// `UniversalRegions` (from NLL)`.\n-impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegionRelations<'tcx> {\n-    fn sub_free_regions(\n-        &self,\n-        _tcx: TyCtxt<'tcx>,\n-        shorter: ty::Region<'tcx>,\n-        longer: ty::Region<'tcx>,\n-    ) -> bool {\n-        let shorter = shorter.to_region_vid();\n-        assert!(self.universal_regions.is_universal_region(shorter));\n-        let longer = longer.to_region_vid();\n-        assert!(self.universal_regions.is_universal_region(longer));\n-        self.outlives(longer, shorter)\n-    }\n-}"}, {"sha": "7e69e710d68681ffed9ff5265bf22527661a1fdc", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -36,7 +36,7 @@ use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::opaque_types::{GenerateMemberConstraints, InferCtxtExt};\n+use rustc_trait_selection::opaque_types::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n@@ -185,7 +185,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         &region_bound_pairs,\n         implicit_region_bound,\n         &mut borrowck_context,\n-        &universal_region_relations,\n         |mut cx| {\n             cx.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n             liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n@@ -253,15 +252,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n }\n \n #[instrument(\n-    skip(\n-        infcx,\n-        body,\n-        promoted,\n-        region_bound_pairs,\n-        borrowck_context,\n-        universal_region_relations,\n-        extra\n-    ),\n+    skip(infcx, body, promoted, region_bound_pairs, borrowck_context, extra),\n     level = \"debug\"\n )]\n fn type_check_internal<'a, 'tcx, R>(\n@@ -272,7 +263,6 @@ fn type_check_internal<'a, 'tcx, R>(\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n-    universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n     extra: impl FnOnce(TypeChecker<'a, 'tcx>) -> R,\n ) -> R {\n     let mut checker = TypeChecker::new(\n@@ -282,7 +272,6 @@ fn type_check_internal<'a, 'tcx, R>(\n         region_bound_pairs,\n         implicit_region_bound,\n         borrowck_context,\n-        universal_region_relations,\n     );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n@@ -901,7 +890,6 @@ struct TypeChecker<'a, 'tcx> {\n     implicit_region_bound: ty::Region<'tcx>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n-    universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n }\n \n struct BorrowCheckContext<'a, 'tcx> {\n@@ -1050,7 +1038,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: ty::Region<'tcx>,\n         borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n-        universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n     ) -> Self {\n         let mut checker = Self {\n             infcx,\n@@ -1062,7 +1049,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             implicit_region_bound,\n             borrowck_context,\n             reported_errors: Default::default(),\n-            universal_region_relations,\n         };\n         checker.check_user_type_annotations();\n         checker\n@@ -1322,8 +1308,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             ),\n         )?;\n \n-        let universal_region_relations = self.universal_region_relations;\n-\n         // Finally, if we instantiated the anon types successfully, we\n         // have to solve any bounds (e.g., `-> impl Iterator` needs to\n         // prove that `T: Iterator` where `T` is the type we\n@@ -1335,12 +1319,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 ConstraintCategory::OpaqueType,\n                 CustomTypeOp::new(\n                     |infcx| {\n-                        infcx.constrain_opaque_type(\n-                            opaque_type_key,\n-                            &opaque_decl,\n-                            GenerateMemberConstraints::IfNoStaticBound,\n-                            universal_region_relations,\n-                        );\n+                        infcx.constrain_opaque_type(opaque_type_key, &opaque_decl);\n                         Ok(InferOk { value: (), obligations: vec![] })\n                     },\n                     || \"opaque_type_map\".to_string(),"}, {"sha": "ad363816e1890dada37f084ab48f9ae1a9e5a0ef", "filename": "compiler/rustc_error_codes/src/error_codes/E0482.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0482.md", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0482.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0482.md?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,8 +1,10 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n A lifetime of a returned value does not outlive the function call.\n \n Erroneous code example:\n \n-```compile_fail,E0482\n+```compile_fail,E0700\n fn prefix<'a>(\n     words: impl Iterator<Item = &'a str>\n ) -> impl Iterator<Item = String> { // error!\n@@ -41,7 +43,7 @@ fn prefix(\n \n A similar lifetime problem might arise when returning closures:\n \n-```compile_fail,E0482\n+```compile_fail,E0700\n fn foo(\n     x: &mut Vec<i32>\n ) -> impl FnMut(&mut Vec<i32>) -> &[i32] { // error!"}, {"sha": "2173ff1f9ab035823c013e08abc3d757ea9602d3", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -386,21 +386,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                         self.report_placeholder_failure(sup_origin, sub_r, sup_r).emit();\n                     }\n-\n-                    RegionResolutionError::MemberConstraintFailure {\n-                        hidden_ty,\n-                        member_region,\n-                        span,\n-                    } => {\n-                        let hidden_ty = self.resolve_vars_if_possible(hidden_ty);\n-                        unexpected_hidden_region_diagnostic(\n-                            self.tcx,\n-                            span,\n-                            hidden_ty,\n-                            member_region,\n-                        )\n-                        .emit();\n-                    }\n                 }\n             }\n         }\n@@ -438,8 +423,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n             RegionResolutionError::ConcreteFailure(..)\n             | RegionResolutionError::SubSupConflict(..)\n-            | RegionResolutionError::UpperBoundUniverseConflict(..)\n-            | RegionResolutionError::MemberConstraintFailure { .. } => false,\n+            | RegionResolutionError::UpperBoundUniverseConflict(..) => false,\n         };\n \n         let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n@@ -454,7 +438,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n             RegionResolutionError::UpperBoundUniverseConflict(_, ref rvo, _, _, _) => rvo.span(),\n-            RegionResolutionError::MemberConstraintFailure { span, .. } => span,\n         });\n         errors\n     }"}, {"sha": "167a8893a11c88aded07e7fac752865577cd5816", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -53,9 +53,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::RelateObjectBound(span) => {\n                 label_or_note(span, \"...so that it can be closed over into an object\");\n             }\n-            infer::CallReturn(span) => {\n-                label_or_note(span, \"...so that return value is valid for the call\");\n-            }\n             infer::DataBorrowed(ty, span) => {\n                 label_or_note(\n                     span,\n@@ -281,23 +278,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 err\n             }\n-            infer::CallReturn(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0482,\n-                    \"lifetime of return value does not outlive the function call\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"the return value is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n             infer::DataBorrowed(ty, span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "4814b65e320abaaadcad162517586d594dc87b47", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -66,8 +66,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     /// follows. If we know that `r_b: 'static`, then this function\n     /// will return true, even though we don't know anything that\n     /// directly relates `r_a` and `r_b`.\n-    ///\n-    /// Also available through the `FreeRegionRelations` trait below.\n     pub fn sub_free_regions(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -131,27 +129,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     }\n }\n \n-/// The NLL region handling code represents free region relations in a\n-/// slightly different way; this trait allows functions to be abstract\n-/// over which version is in use.\n-pub trait FreeRegionRelations<'tcx> {\n-    /// Tests whether `r_a <= r_b`. Both must be free regions or\n-    /// `'static`.\n-    fn sub_free_regions(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        shorter: ty::Region<'tcx>,\n-        longer: ty::Region<'tcx>,\n-    ) -> bool;\n-}\n-\n-impl<'tcx> FreeRegionRelations<'tcx> for FreeRegionMap<'tcx> {\n-    fn sub_free_regions(&self, tcx: TyCtxt<'tcx>, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n-        // invoke the \"inherent method\"\n-        self.sub_free_regions(tcx, r_a, r_b)\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<FreeRegionMap<'tcx>> {"}, {"sha": "4c9dcab26b14f073e0a7ecf578b5d4b5c13d3ec1", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 8, "deletions": 148, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -2,7 +2,6 @@\n \n use crate::infer::region_constraints::Constraint;\n use crate::infer::region_constraints::GenericKind;\n-use crate::infer::region_constraints::MemberConstraint;\n use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n@@ -20,21 +19,20 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n use rustc_middle::ty::{ReLateBound, RePlaceholder, ReVar};\n use rustc_middle::ty::{Region, RegionVid};\n-use rustc_span::Span;\n use std::fmt;\n \n /// This function performs lexical region resolution given a complete\n /// set of constraints and variable origins. It performs a fixed-point\n /// iteration to find region values which satisfy all constraints,\n /// assuming such values can be found. It returns the final values of\n /// all the variables as well as a set of errors that must be reported.\n+#[instrument(level = \"debug\", skip(region_rels, var_infos, data))]\n pub fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n     mode: RegionckMode,\n ) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n-    debug!(\"RegionConstraintData: resolve_regions()\");\n     let mut errors = vec![];\n     let mut resolver = LexicalResolver { region_rels, var_infos, data };\n     match mode {\n@@ -109,11 +107,6 @@ pub enum RegionResolutionError<'tcx> {\n         SubregionOrigin<'tcx>, // cause of the constraint\n         Region<'tcx>,          // the placeholder `'b`\n     ),\n-\n-    /// Indicates a failure of a `MemberConstraint`. These arise during\n-    /// impl trait processing explicitly -- basically, the impl trait's hidden type\n-    /// included some region that it was not supposed to.\n-    MemberConstraintFailure { span: Span, hidden_ty: Ty<'tcx>, member_region: Region<'tcx> },\n }\n \n struct RegionAndOrigin<'tcx> {\n@@ -150,12 +143,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n-        loop {\n-            self.expansion(&mut var_data);\n-            if !self.enforce_member_constraints(&graph, &mut var_data) {\n-                break;\n-            }\n-        }\n+        self.expansion(&mut var_data);\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n         var_data\n@@ -233,120 +221,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    /// Enforce all member constraints and return true if anything\n-    /// changed. See `enforce_member_constraint` for more details.\n-    fn enforce_member_constraints(\n-        &self,\n-        graph: &RegionGraph<'tcx>,\n-        var_values: &mut LexicalRegionResolutions<'tcx>,\n-    ) -> bool {\n-        // Note: we don't use the `any` combinator because we don't\n-        // want to stop at the first constraint that makes a change.\n-        let mut any_changed = false;\n-        for member_constraint in &self.data.member_constraints {\n-            any_changed |= self.enforce_member_constraint(graph, member_constraint, var_values);\n-        }\n-        any_changed\n-    }\n-\n-    /// Enforce a constraint like\n-    ///\n-    /// ```\n-    /// 'r member of ['c...]\n-    /// ```\n-    ///\n-    /// We look for all choice regions from the list `'c...` that:\n-    ///\n-    /// (a) are greater than the current value of `'r` (which is a lower bound)\n-    ///\n-    /// and\n-    ///\n-    /// (b) are compatible with the upper bounds of `'r` that we can\n-    /// find by traversing the graph.\n-    ///\n-    /// From that list, we look for a *minimal* option `'c_min`. If we\n-    /// find one, then we can enforce that `'r: 'c_min`.\n-    fn enforce_member_constraint(\n-        &self,\n-        graph: &RegionGraph<'tcx>,\n-        member_constraint: &MemberConstraint<'tcx>,\n-        var_values: &mut LexicalRegionResolutions<'tcx>,\n-    ) -> bool {\n-        debug!(\"enforce_member_constraint(member_constraint={:#?})\", member_constraint);\n-\n-        // The constraint is some inference variable (`vid`) which\n-        // must be equal to one of the options.\n-        let member_vid = match member_constraint.member_region {\n-            ty::ReVar(vid) => *vid,\n-            _ => return false,\n-        };\n-\n-        // The current value of `vid` is a lower bound LB -- i.e., we\n-        // know that `LB <= vid` must be true.\n-        let member_lower_bound: ty::Region<'tcx> = match var_values.value(member_vid) {\n-            VarValue::ErrorValue => return false,\n-            VarValue::Value(r) => r,\n-        };\n-\n-        // Find all the \"upper bounds\" -- that is, each region `b` such that\n-        // `r0 <= b` must hold.\n-        let (member_upper_bounds, ..) =\n-            self.collect_bounding_regions(graph, member_vid, OUTGOING, None);\n-\n-        // Get an iterator over the *available choice* -- that is,\n-        // each choice region `c` where `lb <= c` and `c <= ub` for all the\n-        // upper bounds `ub`.\n-        debug!(\"enforce_member_constraint: upper_bounds={:#?}\", member_upper_bounds);\n-        let mut options = member_constraint.choice_regions.iter().filter(|option| {\n-            self.sub_concrete_regions(member_lower_bound, option)\n-                && member_upper_bounds\n-                    .iter()\n-                    .all(|upper_bound| self.sub_concrete_regions(option, upper_bound.region))\n-        });\n-\n-        // If there is more than one option, we only make a choice if\n-        // there is a single *least* choice -- i.e., some available\n-        // region that is `<=` all the others.\n-        let mut least_choice: ty::Region<'tcx> = match options.next() {\n-            Some(&r) => r,\n-            None => return false,\n-        };\n-        debug!(\"enforce_member_constraint: least_choice={:?}\", least_choice);\n-        for &option in options {\n-            debug!(\"enforce_member_constraint: option={:?}\", option);\n-            if !self.sub_concrete_regions(least_choice, option) {\n-                if self.sub_concrete_regions(option, least_choice) {\n-                    debug!(\"enforce_member_constraint: new least choice\");\n-                    least_choice = option;\n-                } else {\n-                    debug!(\"enforce_member_constraint: no least choice\");\n-                    return false;\n-                }\n-            }\n-        }\n-\n-        // (#72087) Different `ty::Regions` can be known to be equal, for\n-        // example, we know that `'a` and `'static` are equal in a function\n-        // with a parameter of type `&'static &'a ()`.\n-        //\n-        // When we have two equal regions like this `expansion` will use\n-        // `lub_concrete_regions` to pick a canonical representative. The same\n-        // choice is needed here so that we don't end up in a cycle of\n-        // `expansion` changing the region one way and the code here changing\n-        // it back.\n-        let lub = self.lub_concrete_regions(least_choice, member_lower_bound);\n-        debug!(\n-            \"enforce_member_constraint: final least choice = {:?}\\nlub = {:?}\",\n-            least_choice, lub\n-        );\n-        if lub != member_lower_bound {\n-            *var_values.value_mut(member_vid) = VarValue::Value(least_choice);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n         let mut constraints = IndexVec::from_elem_n(Vec::new(), var_values.values.len());\n         let mut changes = Vec::new();\n@@ -461,6 +335,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     /// True if `a <= b`, but not defined over inference variables.\n+    #[instrument(level = \"trace\", skip(self))]\n     fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n         let tcx = self.tcx();\n         let sub_free_regions = |r1, r2| self.region_rels.free_regions.sub_free_regions(tcx, r1, r2);\n@@ -492,6 +367,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ///\n     /// Neither `a` nor `b` may be an inference variable (hence the\n     /// term \"concrete regions\").\n+    #[instrument(level = \"trace\", skip(self))]\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let r = match (a, b) {\n             (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n@@ -562,13 +438,14 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     /// After expansion is complete, go and check upper bounds (i.e.,\n     /// cases where the region cannot grow larger than a fixed point)\n     /// and check that they are satisfied.\n+    #[instrument(skip(self, var_data, errors))]\n     fn collect_errors(\n         &self,\n         var_data: &mut LexicalRegionResolutions<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n         for (constraint, origin) in &self.data.constraints {\n-            debug!(\"collect_errors: constraint={:?} origin={:?}\", constraint, origin);\n+            debug!(?constraint, ?origin);\n             match *constraint {\n                 Constraint::RegSubVar(..) | Constraint::VarSubVar(..) => {\n                     // Expansion will ensure that these constraints hold. Ignore.\n@@ -580,7 +457,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     }\n \n                     debug!(\n-                        \"collect_errors: region error at {:?}: \\\n+                        \"region error at {:?}: \\\n                          cannot verify that {:?} <= {:?}\",\n                         origin, sub, sup\n                     );\n@@ -606,7 +483,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     // collect them later.\n                     if !self.sub_concrete_regions(a_region, b_region) {\n                         debug!(\n-                            \"collect_errors: region error at {:?}: \\\n+                            \"region error at {:?}: \\\n                             cannot verify that {:?}={:?} <= {:?}\",\n                             origin, a_vid, a_region, b_region\n                         );\n@@ -616,23 +493,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n-        // Check that all member constraints are satisfied.\n-        for member_constraint in &self.data.member_constraints {\n-            let member_region = var_data.normalize(self.tcx(), member_constraint.member_region);\n-            let choice_regions = member_constraint\n-                .choice_regions\n-                .iter()\n-                .map(|&choice_region| var_data.normalize(self.tcx(), choice_region));\n-            if !choice_regions.clone().any(|choice_region| member_region == choice_region) {\n-                let span = self.tcx().def_span(member_constraint.opaque_type_def_id);\n-                errors.push(RegionResolutionError::MemberConstraintFailure {\n-                    span,\n-                    hidden_ty: member_constraint.hidden_ty,\n-                    member_region,\n-                });\n-            }\n-        }\n-\n         for verify in &self.data.verifys {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = var_data.normalize(self.tcx(), verify.region);"}, {"sha": "6b905f67e683f900b53ed0e9ca99dba49342161a", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -417,9 +417,6 @@ pub enum SubregionOrigin<'tcx> {\n     /// (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n-    /// Region in return type of invoked fn must enclose call\n-    CallReturn(Span),\n-\n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n     CompareImplMethodObligation {\n@@ -1803,7 +1800,6 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             ReborrowUpvar(a, _) => a,\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n-            CallReturn(a) => a,\n             CompareImplMethodObligation { span, .. } => span,\n             CompareImplTypeObligation { span, .. } => span,\n         }"}, {"sha": "6c5e6b1cfc385fbc0b5e2e9daa8d55ce649726da", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 15, "deletions": 142, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -4,30 +4,16 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n-use rustc_infer::infer::free_regions::FreeRegionRelations;\n use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{self, InferCtxt, InferOk};\n+use rustc_infer::infer::{InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::Span;\n \n use std::ops::ControlFlow;\n \n-/// Whether member constraints should be generated for all opaque types\n-#[derive(Debug)]\n-pub enum GenerateMemberConstraints {\n-    /// The default, used by typeck\n-    WhenRequired,\n-    /// The borrow checker needs member constraints in any case where we don't\n-    /// have a `'static` bound. This is because the borrow checker has more\n-    /// flexibility in the values of regions. For example, given `f<'a, 'b>`\n-    /// the borrow checker can have an inference variable outlive `'a` and `'b`,\n-    /// but not be equal to `'static`.\n-    IfNoStaticBound,\n-}\n-\n pub trait InferCtxtExt<'tcx> {\n     fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n@@ -37,14 +23,12 @@ pub trait InferCtxtExt<'tcx> {\n         value_span: Span,\n     ) -> InferOk<'tcx, T>;\n \n-    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(&self, free_region_relations: &FRR);\n+    fn constrain_opaque_types(&self);\n \n-    fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n+    fn constrain_opaque_type(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n-        mode: GenerateMemberConstraints,\n-        free_region_relations: &FRR,\n     );\n \n     /*private*/\n@@ -270,26 +254,19 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n     /// - `free_region_relations` -- something that can be used to relate\n     ///   the free regions (`'a`) that appear in the impl trait.\n-    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(&self, free_region_relations: &FRR) {\n+    fn constrain_opaque_types(&self) {\n         let opaque_types = self.inner.borrow().opaque_types.clone();\n         for (opaque_type_key, opaque_defn) in opaque_types {\n-            self.constrain_opaque_type(\n-                opaque_type_key,\n-                &opaque_defn,\n-                GenerateMemberConstraints::WhenRequired,\n-                free_region_relations,\n-            );\n+            self.constrain_opaque_type(opaque_type_key, &opaque_defn);\n         }\n     }\n \n     /// See `constrain_opaque_types` for documentation.\n-    #[instrument(level = \"debug\", skip(self, free_region_relations))]\n-    fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn constrain_opaque_type(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n-        mode: GenerateMemberConstraints,\n-        free_region_relations: &FRR,\n     ) {\n         let def_id = opaque_type_key.def_id;\n \n@@ -318,118 +295,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             hir::OpaqueTyOrigin::TyAlias => 0,\n         };\n \n-        let span = tcx.def_span(def_id);\n-\n-        // Check if the `impl Trait` bounds include region bounds.\n-        // For example, this would be true for:\n-        //\n-        //     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n-        //\n-        // but false for:\n-        //\n-        //     fn foo<'c>() -> impl Trait<'c>\n-        //\n-        // unless `Trait` was declared like:\n-        //\n-        //     trait Trait<'c>: 'c\n-        //\n-        // in which case it would be true.\n-        //\n-        // This is used during regionck to decide whether we need to\n-        // impose any additional constraints to ensure that region\n-        // variables in `concrete_ty` wind up being constrained to\n-        // something from `substs` (or, at minimum, things that outlive\n-        // the fn body). (Ultimately, writeback is responsible for this\n-        // check.)\n-        let bounds = tcx.explicit_item_bounds(def_id);\n-        debug!(\"{:#?}\", bounds);\n-        let bounds = bounds.iter().map(|(bound, _)| bound.subst(tcx, opaque_type_key.substs));\n-        debug!(\"{:#?}\", bounds);\n-        let opaque_type = tcx.mk_opaque(def_id, opaque_type_key.substs);\n-\n-        let required_region_bounds = required_region_bounds(tcx, opaque_type, bounds);\n-        if !required_region_bounds.is_empty() {\n-            for required_region in required_region_bounds {\n-                concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n-                    tcx,\n-                    op: |r| self.sub_regions(infer::CallReturn(span), required_region, r),\n-                });\n-            }\n-            if let GenerateMemberConstraints::IfNoStaticBound = mode {\n-                self.generate_member_constraint(\n-                    concrete_ty,\n-                    opaque_defn,\n-                    opaque_type_key,\n-                    first_own_region,\n-                );\n-            }\n-            return;\n-        }\n-\n-        // There were no `required_region_bounds`,\n-        // so we have to search for a `least_region`.\n-        // Go through all the regions used as arguments to the\n-        // opaque type. These are the parameters to the opaque\n-        // type; so in our example above, `substs` would contain\n-        // `['a]` for the first impl trait and `'b` for the\n-        // second.\n-        let mut least_region = None;\n-\n-        for subst_arg in &opaque_type_key.substs[first_own_region..] {\n-            let subst_region = match subst_arg.unpack() {\n-                GenericArgKind::Lifetime(r) => r,\n-                GenericArgKind::Type(_) | GenericArgKind::Const(_) => continue,\n-            };\n-\n-            // Compute the least upper bound of it with the other regions.\n-            debug!(?least_region);\n-            debug!(?subst_region);\n-            match least_region {\n-                None => least_region = Some(subst_region),\n-                Some(lr) => {\n-                    if free_region_relations.sub_free_regions(self.tcx, lr, subst_region) {\n-                        // keep the current least region\n-                    } else if free_region_relations.sub_free_regions(self.tcx, subst_region, lr) {\n-                        // switch to `subst_region`\n-                        least_region = Some(subst_region);\n-                    } else {\n-                        // There are two regions (`lr` and\n-                        // `subst_region`) which are not relatable. We\n-                        // can't find a best choice. Therefore,\n-                        // instead of creating a single bound like\n-                        // `'r: 'a` (which is our preferred choice),\n-                        // we will create a \"in bound\" like `'r in\n-                        // ['a, 'b, 'c]`, where `'a..'c` are the\n-                        // regions that appear in the impl trait.\n-\n-                        return self.generate_member_constraint(\n-                            concrete_ty,\n-                            opaque_defn,\n-                            opaque_type_key,\n-                            first_own_region,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        let least_region = least_region.unwrap_or(tcx.lifetimes.re_static);\n-        debug!(?least_region);\n-\n-        if let GenerateMemberConstraints::IfNoStaticBound = mode {\n-            if least_region != tcx.lifetimes.re_static {\n-                self.generate_member_constraint(\n-                    concrete_ty,\n-                    opaque_defn,\n-                    opaque_type_key,\n-                    first_own_region,\n-                );\n-            }\n-        }\n-        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n-            tcx,\n-            op: |r| self.sub_regions(infer::CallReturn(span), least_region, r),\n-        });\n+        // The regions that appear in the hidden type must be equal to\n+        // one of the regions in scope for the opaque type.\n+        self.generate_member_constraint(\n+            concrete_ty,\n+            opaque_defn,\n+            opaque_type_key,\n+            first_own_region,\n+        );\n     }\n \n     /// As a fallback, we sometimes generate an \"in constraint\". For"}, {"sha": "f945a2e506301c5fd337dde43d6d49a927584933", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n \n-        self.constrain_opaque_types(self.outlives_environment.free_region_map());\n+        self.constrain_opaque_types();\n     }\n \n     fn visit_region_obligations(&mut self, hir_id: hir::HirId) {"}, {"sha": "9b0018d8904ac10ad464492cabbf98c81471de8e", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.nll.stderr", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,13 +1,31 @@\n error: lifetime may not live long enough\n-  --> $DIR/ret-impl-trait-one.rs:10:65\n+  --> $DIR/ret-impl-trait-one.rs:10:85\n+   |\n+LL |   async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n+   |  ________________________________--__--_______________________________________________^\n+   | |                                |   |\n+   | |                                |   lifetime `'b` defined here\n+   | |                                lifetime `'a` defined here\n+LL | |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ret-impl-trait-one.rs:16:65\n    |\n LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |                                --  --                           ^^^^^^^^^^^^^^ opaque type requires that `'b` must outlive `'a`\n-   |                                |   |\n-   |                                |   lifetime `'b` defined here\n-   |                                lifetime `'a` defined here\n+   |                                    --                           ^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+   |\n+help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n    |\n-   = help: consider adding the following bound: `'b: 'a`\n+LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n+   |                                                                                ++++\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "4f32489014d53715c66e648b890026ce5a4d5aad", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -6,9 +6,15 @@\n trait Trait<'a> { }\n impl<T> Trait<'_> for T { }\n \n+// Fails to recognize that both 'a and 'b are mentioned and should thus be accepted\n+async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n+    //~^ ERROR lifetime mismatch\n+    (a, b)\n+}\n+\n // Only `'a` permitted in return type, not `'b`.\n async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-    //~^ ERROR lifetime mismatch\n+    //~^ ERROR captures lifetime that does not appear in bounds\n     (a, b)\n }\n "}, {"sha": "bcd96367e2fae41dd78fb7e0f4146fc8949bbbcd", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,13 +1,27 @@\n error[E0623]: lifetime mismatch\n   --> $DIR/ret-impl-trait-one.rs:10:65\n    |\n+LL | async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n+   |                                                      ------     ^^^^^^^^^^^^^^^^^^^\n+   |                                                      |          |\n+   |                                                      |          ...but data from `a` is held across an await point here\n+   |                                                      |          this `async fn` implicitly returns an `impl Future<Output = impl Trait<'a> + 'b>`\n+   |                                                      this parameter and the returned future are declared with different lifetimes...\n+\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ret-impl-trait-one.rs:16:65\n+   |\n LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |                                           ------                ^^^^^^^^^^^^^^\n-   |                                           |                     |\n-   |                                           |                     ...but data from `b` is held across an await point here\n-   |                                           |                     this `async fn` implicitly returns an `impl Future<Output = impl Trait<'a>>`\n-   |                                           this parameter and the returned future are declared with different lifetimes...\n+   |                                    --                           ^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+   |\n+help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n+   |\n+LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n+   |                                                                                ++++\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0623`.\n+Some errors have detailed explanations: E0623, E0700.\n+For more information about an error, try `rustc --explain E0623`."}, {"sha": "bfe656c7e2b491ae5f380e880b95f2562d532a95", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.nll.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,16 +0,0 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unrelated.rs:16:74\n-   |\n-LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-   |                     --                                                   ^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n-   |\n-help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n-   |\n-LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e> + 'b\n-   |                                                                                             ++++\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "bfe656c7e2b491ae5f380e880b95f2562d532a95", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -2,13 +2,14 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n   --> $DIR/ordinary-bounds-unrelated.rs:16:74\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-   |                                                                          ^^^^^^^^^^^^^^^^^^\n+   |                     --                                                   ^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n    |\n-note: hidden type `Ordinary<'_>` captures lifetime smaller than the function body\n-  --> $DIR/ordinary-bounds-unrelated.rs:16:74\n+help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n    |\n-LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-   |                                                                          ^^^^^^^^^^^^^^^^^^\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e> + 'b\n+   |                                                                                             ++++\n \n error: aborting due to previous error\n "}, {"sha": "75c2dd8e9d39edea0a964b8582c13032e588b45b", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.nll.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,16 +0,0 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unsuited.rs:18:62\n-   |\n-LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-   |                     --                                       ^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n-   |\n-help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n-   |\n-LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> + 'b\n-   |                                                                                 ++++\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "75c2dd8e9d39edea0a964b8582c13032e588b45b", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -2,13 +2,14 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n   --> $DIR/ordinary-bounds-unsuited.rs:18:62\n    |\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-   |                                                              ^^^^^^^^^^^^^^^^^^\n+   |                     --                                       ^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n    |\n-note: hidden type `Ordinary<'_>` captures lifetime smaller than the function body\n-  --> $DIR/ordinary-bounds-unsuited.rs:18:62\n+help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n    |\n-LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-   |                                                              ^^^^^^^^^^^^^^^^^^\n+LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> + 'b\n+   |                                                                                 ++++\n \n error: aborting due to previous error\n "}, {"sha": "eaf341248a180039bfa806f597de7f692c598a22", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,31 +1,31 @@\n-error: lifetime may not live long enough\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              -        ^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n+   |              ----     ^^^^^^^^^\n    |              |\n-   |              let's call the lifetime of this reference `'1`\n+   |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n+help: to declare that the `impl Trait` captures '_, you can add an explicit `'_` lifetime bound\n    |\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n-error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:5:32\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             --                 ^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n+   |             --                 ^^^^^^^^^\n    |             |\n-   |             lifetime `'a` defined here\n+   |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a bound\n+help: to declare that the `impl Trait` captures 'a, you can add an explicit `'a` lifetime bound\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                          ++++\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:7:46\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n    |\n LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    |               -                              ^ returning this value requires that `'1` must outlive `'static`\n@@ -35,49 +35,52 @@ LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    = help: consider replacing `'1` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:9:55\n+  --> $DIR/must_outlive_least_region_or_bound.rs:11:55\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    |              -- lifetime `'a` defined here            ^ returning this value requires that `'a` must outlive `'static`\n    |\n    = help: consider replacing `'a` with `'static`\n \n error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/must_outlive_least_region_or_bound.rs:11:41\n+  --> $DIR/must_outlive_least_region_or_bound.rs:13:41\n    |\n LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n    |               ----                      ^ lifetime `'a` required\n    |               |\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:24\n+  --> $DIR/must_outlive_least_region_or_bound.rs:24:55\n    |\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n-   |               -        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n+   |               -                                       ^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n    |               |\n    |               let's call the lifetime of this reference `'1`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:28:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:29:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n    |\n    = help: consider replacing `'a` with `'static`\n \n-error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:32:61\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                          --  -- lifetime `'b` defined here  ^^^^^^^^^^^^^^^^ opaque type requires that `'b` must outlive `'a`\n-   |                          |\n-   |                          lifetime `'a` defined here\n+   |                              --                             ^^^^^^^^^^^^^^^^\n+   |                              |\n+   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n+   |\n+help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n    |\n-   = help: consider adding the following bound: `'b: 'a`\n+LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n+   |                                                                              ++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:37:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                                   ^^^^^^^^^^^^^^^^^^^^\n@@ -86,5 +89,5 @@ LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n \n error: aborting due to 9 previous errors\n \n-Some errors have detailed explanations: E0310, E0621.\n+Some errors have detailed explanations: E0310, E0621, E0700.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "69d2843ff3f01b0f5184ee1c15209d638ad71a53", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,8 +1,10 @@\n use std::fmt::Debug;\n \n-fn elided(x: &i32) -> impl Copy { x } //~ ERROR E0759\n+fn elided(x: &i32) -> impl Copy { x }\n+//~^ ERROR: captures lifetime that does not appear in bounds\n \n-fn explicit<'a>(x: &'a i32) -> impl Copy { x } //~ ERROR E0759\n+fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n+//~^ ERROR: captures lifetime that does not appear in bounds\n \n fn elided2(x: &i32) -> impl Copy + 'static { x } //~ ERROR E0759\n \n@@ -20,7 +22,6 @@ fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) } //~ ERROR E0759\n fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) } //~ ERROR E0759\n \n fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) } //~ ERROR E0759\n-//~^ ERROR E0759\n \n trait LifetimeTrait<'a> {}\n impl<'a> LifetimeTrait<'a> for &'a i32 {}\n@@ -30,7 +31,7 @@ fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x } //~ ERRO\n // Tests that a closure type containing 'b cannot be returned from a type where\n // only 'a was expected.\n fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-    //~^ ERROR lifetime mismatch\n+    //~^ ERROR: captures lifetime that does not appear in bounds\n     move |_| println!(\"{}\", y)\n }\n "}, {"sha": "d65dea7adc90b40f5f4501382f67d2820162eb52", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 36, "deletions": 62, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,49 +1,39 @@\n-error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----                 ^ ...is captured here...\n+   |              ----     ^^^^^^^^^\n    |              |\n-   |              this data with an anonymous lifetime `'_`...\n-   |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+   |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n-LL | fn elided(x: &i32) -> impl Copy { x }\n-   |                       ^^^^^^^^^\n-help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+help: to declare that the `impl Trait` captures '_, you can add an explicit `'_` lifetime bound\n    |\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n-error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:5:44\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |                    -------                 ^ ...is captured here...\n-   |                    |\n-   |                    this data with lifetime `'a`...\n+   |             --                 ^^^^^^^^^\n+   |             |\n+   |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:5:32\n-   |\n-LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |                                ^^^^^^^^^\n-help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'a` lifetime bound\n+help: to declare that the `impl Trait` captures 'a, you can add an explicit `'a` lifetime bound\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                          ++++\n \n error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:7:46\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n    |\n LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    |               ----                           ^ ...is captured here...\n    |               |\n    |               this data with an anonymous lifetime `'_`...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:7:24\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:24\n    |\n LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    |                        ^^^^^^^^^^^^^^^^^^^\n@@ -57,15 +47,15 @@ LL | fn elided2(x: &'static i32) -> impl Copy + 'static { x }\n    |               ~~~~~~~~~~~~\n \n error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:9:55\n+  --> $DIR/must_outlive_least_region_or_bound.rs:11:55\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    |                     -------                           ^ ...is captured here...\n    |                     |\n    |                     this data with lifetime `'a`...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:9:33\n+  --> $DIR/must_outlive_least_region_or_bound.rs:11:33\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    |                                 ^^^^^^^^^^^^^^^^^^^\n@@ -79,15 +69,15 @@ LL | fn explicit2<'a>(x: &'static i32) -> impl Copy + 'static { x }\n    |                     ~~~~~~~~~~~~\n \n error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/must_outlive_least_region_or_bound.rs:11:24\n+  --> $DIR/must_outlive_least_region_or_bound.rs:13:24\n    |\n LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n    |               ----     ^^^^^^^^^^^^^^ lifetime `'a` required\n    |               |\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:65\n+  --> $DIR/must_outlive_least_region_or_bound.rs:24:65\n    |\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n    |               ---- this data with an anonymous lifetime `'_`... ^ ...is captured here, requiring it to live as long as `'static`\n@@ -101,34 +91,14 @@ help: to declare that the `impl Trait` captures data from argument `x`, you can\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n    |                                                    ++++\n \n-error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:69\n-   |\n-LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n-   |               ---- this data with an anonymous lifetime `'_`...     ^ ...is captured here...\n-   |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:41\n-   |\n-LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n-   |                                         ^^^^^^^^^^\n-help: to declare that the trait object captures data from argument `x`, you can add an explicit `'_` lifetime bound\n-   |\n-LL | fn elided5(x: &i32) -> (Box<dyn Debug + '_>, impl Debug) { (Box::new(x), x) }\n-   |                                       ++++\n-help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n-   |\n-LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n-   |                                                    ++++\n-\n error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:28:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:29:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                      ------- this data with lifetime `'a`...        ^ ...is captured here...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:28:34\n+  --> $DIR/must_outlive_least_region_or_bound.rs:29:34\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -141,25 +111,29 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                      ~~~~~~~~~~~~\n \n-error[E0623]: lifetime mismatch\n-  --> $DIR/must_outlive_least_region_or_bound.rs:32:61\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                                                 -------     ^^^^^^^^^^^^^^^^\n-   |                                                 |           |\n-   |                                                 |           ...but data from `y` is returned here\n-   |                                                 this parameter and the return type are declared with different lifetimes...\n+   |                              --                             ^^^^^^^^^^^^^^^^\n+   |                              |\n+   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n+   |\n+help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n+   |\n+LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n+   |                                                                              ++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:37:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |                                 |\n    |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n \n error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:14:50\n+  --> $DIR/must_outlive_least_region_or_bound.rs:16:50\n    |\n LL | fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n    |               ----                               ^ ...is captured here, requiring it to live as long as `'static`\n@@ -172,7 +146,7 @@ LL | fn elided3(x: &i32) -> Box<dyn Debug + '_> { Box::new(x) }\n    |                                      ++++\n \n error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:16:59\n+  --> $DIR/must_outlive_least_region_or_bound.rs:18:59\n    |\n LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) }\n    |                     -------                               ^ ...is captured here, requiring it to live as long as `'static`\n@@ -185,7 +159,7 @@ LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug + 'a> { Box::new(x) }\n    |                                               ++++\n \n error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:18:60\n+  --> $DIR/must_outlive_least_region_or_bound.rs:20:60\n    |\n LL | fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |               ----                                         ^ ...is captured here, requiring it to live as long as `'static`\n@@ -202,7 +176,7 @@ LL | fn elided4(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |               ~~~~~~~~~~~~\n \n error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/must_outlive_least_region_or_bound.rs:20:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:22:69\n    |\n LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |                     ------- this data with lifetime `'a`...         ^ ...is captured here, requiring it to live as long as `'static`\n@@ -216,7 +190,7 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn explicit4<'a>(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |                     ~~~~~~~~~~~~\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 13 previous errors\n \n-Some errors have detailed explanations: E0310, E0621, E0623, E0759.\n+Some errors have detailed explanations: E0310, E0621, E0700, E0759.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "a3aeff50eee4cb8cbd7a5dd28352b9436f3a0d15", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.nll.stderr", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,28 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/static-return-lifetime-infered.rs:6:35\n-   |\n-LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         -         ^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n-   |                         |\n-   |                         let's call the lifetime of this reference `'1`\n-   |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n-   |\n-LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n-   |                                                           ++++\n-\n-error: lifetime may not live long enough\n-  --> $DIR/static-return-lifetime-infered.rs:9:37\n-   |\n-LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n-   |                    |\n-   |                    lifetime `'a` defined here\n-   |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a bound\n-   |\n-LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n-   |                                                             ++++\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "d792c6eafb32f27ea889552ea03bea1b7fbfa288", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -4,10 +4,14 @@ struct A {\n \n impl A {\n     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-        self.x.iter().map(|a| a.0) //~ ERROR E0759\n+        //~^ ERROR: captures lifetime that does not appear in bounds\n+        //~| ERROR: captures lifetime that does not appear in bounds\n+        self.x.iter().map(|a| a.0)\n     }\n     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-        self.x.iter().map(|a| a.0) //~ ERROR E0759\n+        //~^ ERROR: captures lifetime that does not appear in bounds\n+        //~| ERROR: captures lifetime that does not appear in bounds\n+        self.x.iter().map(|a| a.0)\n     }\n }\n "}, {"sha": "0d68f8c825f70ee87c5b1f7f0b12db64b919ae4e", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,43 +1,55 @@\n-error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/static-return-lifetime-infered.rs:7:16\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/static-return-lifetime-infered.rs:6:35\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         ----- this data with an anonymous lifetime `'_`...\n-LL |         self.x.iter().map(|a| a.0)\n-   |         ------ ^^^^\n-   |         |\n-   |         ...is captured here...\n+   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                         |\n+   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n+   |\n+help: to declare that the `impl Trait` captures '_, you can add an explicit `'_` lifetime bound\n    |\n-note: ...and is required to live as long as `'static` here\n+LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n+   |                                                           ++++\n+\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/static-return-lifetime-infered.rs:6:35\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^\n-help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                         |\n+   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n+   |\n+help: to declare that the `impl Trait` captures '_, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n-error[E0759]: `self` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/static-return-lifetime-infered.rs:10:16\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/static-return-lifetime-infered.rs:11:37\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                        -------- this data with lifetime `'a`...\n-LL |         self.x.iter().map(|a| a.0)\n-   |         ------ ^^^^\n-   |         |\n-   |         ...is captured here...\n+   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n    |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/static-return-lifetime-infered.rs:9:37\n+help: to declare that the `impl Trait` captures 'a, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n+   |                                                             ++++\n+\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/static-return-lifetime-infered.rs:11:37\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^^^\n-help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n+   |\n+help: to declare that the `impl Trait` captures 'a, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ++++\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0759`.\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "e29ba09b3694dbabcc901566b2d72813a67f55c0", "filename": "src/test/ui/nll/issue-73159-rpit-static.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -6,7 +6,8 @@\n struct Foo<'a>(&'a [u8]);\n \n impl<'a> Foo<'a> {\n-    fn make_it(&self) -> impl Iterator<Item = u8> { //~ ERROR lifetime may not live\n+    fn make_it(&self) -> impl Iterator<Item = u8> {\n+        //~^ ERROR: captures lifetime that does not appear in bounds\n         self.0.iter().copied()\n     }\n }"}, {"sha": "6c7cd0c8254938c8b1f49c5abe5dd03cca59eb1c", "filename": "src/test/ui/nll/issue-73159-rpit-static.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,10 +1,11 @@\n-error: lifetime may not live long enough\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/issue-73159-rpit-static.rs:9:26\n    |\n LL | impl<'a> Foo<'a> {\n-   |      -- lifetime `'a` defined here\n+   |      -- hidden type `Copied<std::slice::Iter<'a, u8>>` captures the lifetime `'a` as defined here\n LL |     fn make_it(&self) -> impl Iterator<Item = u8> {\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "8af23aad7261b80a3bdba5c104be56bcb8abb76f", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -8,7 +8,7 @@ trait Foo<'a> {\n impl<'a, T> Foo<'a> for T { }\n \n fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n-//~^ ERROR explicit lifetime required in the type of `x` [E0621]\n+//~^ ERROR captures lifetime that does not appear in bounds\n     x\n }\n "}, {"sha": "21d1eea54e6c517dcb41a16ca1d51d80b50b9832", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,14 +1,16 @@\n-error[E0621]: explicit lifetime required in the type of `x`\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/impl-trait-captures.rs:10:25\n    |\n LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n-   |                         ^^^^^^^^^^^^ lifetime `ReEarlyBound(0, 'a)` required\n+   |                  --     ^^^^^^^^^^^^\n+   |                  |\n+   |                  hidden type `&ReFree(DefId(0:8 ~ impl_trait_captures[e9f4]::foo), BrAnon(0)) T` captures the anonymous lifetime defined here\n    |\n-help: add explicit lifetime `ReEarlyBound(0, 'a)` to the type of `x`\n+help: to declare that the `impl Trait` captures ReFree(DefId(0:8 ~ impl_trait_captures[e9f4]::foo), BrAnon(0)), you can add an explicit `ReFree(DefId(0:8 ~ impl_trait_captures[e9f4]::foo), BrAnon(0))` lifetime bound\n    |\n-LL | fn foo<'a, T>(x: &ReEarlyBound(0, 'a) T) -> impl Foo<'a> {\n-   |                  ~~~~~~~~~~~~~~~~~~~~~~\n+LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> + ReFree(DefId(0:8 ~ impl_trait_captures[e9f4]::foo), BrAnon(0)) {\n+   |                                      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0621`.\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "5d0b2c2ebdf68b1cc37a33cf474b9ec838e6b2f9", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.nll.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.nll.stderr?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,15 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:37\n-   |\n-LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          -          ^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n-   |                          |\n-   |                          let's call the lifetime of this reference `'1`\n-   |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n-   |\n-LL |     async fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n-   |                                                ++++\n-\n-error: aborting due to previous error\n-"}, {"sha": "a1e7f4aa875eeb749821b7101543863b576081a9", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -6,7 +6,7 @@ struct Foo;\n \n impl Foo {\n     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-    //~^ ERROR E0759\n+    //~^ ERROR: captures lifetime that does not appear in bounds\n }\n \n fn main() {"}, {"sha": "953d7cd6a07692630c827bdf67d6e05670579ddc", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,17 +1,16 @@\n-error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:16\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:37\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                ^^^^  ----------     ---------- ...and is required to live as long as `'static` here\n-   |                |     |\n-   |                |     this data with an anonymous lifetime `'_`...\n-   |                ...is captured here...\n+   |                          -          ^^^^^^^^^^\n+   |                          |\n+   |                          hidden type `Pin<&Foo>` captures the lifetime `'_` as defined here\n    |\n-help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+help: to declare that the `impl Trait` captures '_, you can add an explicit `'_` lifetime bound\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n    |                                                ++++\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0759`.\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "4301d8f767a51a366ab0b449c2d154411ad174b4", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.nll.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.nll.stderr?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,15 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:31\n-   |\n-LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                    -          ^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n-   |                    |\n-   |                    let's call the lifetime of this reference `'1`\n-   |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n-   |\n-LL |     fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n-   |                                          ++++\n-\n-error: aborting due to previous error\n-"}, {"sha": "4db2fa7dcb81eef2cf602f6c17a0640bca33cfd0", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -3,7 +3,8 @@ use std::pin::Pin;\n struct Foo;\n \n impl Foo {\n-    fn f(self: Pin<&Self>) -> impl Clone { self } //~ ERROR E0759\n+    fn f(self: Pin<&Self>) -> impl Clone { self }\n+    //~^ ERROR: captures lifetime that does not appear in bounds\n }\n \n fn main() {"}, {"sha": "faa1233ffde634335590e0f5730a39c3bd668112", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,21 +1,16 @@\n-error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n-   |\n-LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                ----------                  ^^^^ ...is captured here...\n-   |                |\n-   |                this data with an anonymous lifetime `'_`...\n-   |\n-note: ...and is required to live as long as `'static` here\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:31\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                               ^^^^^^^^^^\n-help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |                    -----      ^^^^^^^^^^\n+   |                    |\n+   |                    hidden type `Pin<&Foo>` captures the anonymous lifetime defined here\n+   |\n+help: to declare that the `impl Trait` captures '_, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n    |                                          ++++\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0759`.\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "2dc300ac76f278d4de4b0dbf29e4fa434441f5a5", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.nll.stderr", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.nll.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,17 +1,8 @@\n-error[E0597]: `val` does not live long enough\n+error[E0515]: cannot return reference to function parameter `val`\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:21:9\n    |\n-LL |     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> {\n-   |               -- lifetime `'a` defined here                  ------------------- opaque type requires that `val` is borrowed for `'a`\n LL |         val.use_self()\n-   |         ^^^^^^^^^^^^^^ borrowed value does not live long enough\n-LL |     }\n-   |     - `val` dropped here while still borrowed\n-   |\n-help: you can add a bound to the opaque type to make it last less than `'static` and match `'a`\n-   |\n-LL |     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> + 'a {\n-   |                                                                                  ++++\n+   |         ^^^^^^^^^^^^^^ returns a reference to data owned by the current function\n \n error[E0515]: cannot return reference to function parameter `val`\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:43:9\n@@ -27,5 +18,4 @@ LL |         val.use_self()\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0515, E0597.\n-For more information about an error, try `rustc --explain E0515`.\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "0045d3fcf1c7b5f02cf9f3296d05dce23968dde3", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -18,7 +18,7 @@ mod bav {\n     impl Bar for i32 {}\n \n     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> {\n-        val.use_self() //~ ERROR E0597\n+        val.use_self() //~ ERROR cannot return reference to function parameter\n     }\n }\n "}, {"sha": "2961d8d7eacc99a9a0e59b6c3dc0d115dc2092d8", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.stderr", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,17 +1,8 @@\n-error[E0597]: `val` does not live long enough\n+error[E0515]: cannot return reference to function parameter `val`\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:21:9\n    |\n-LL |     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> {\n-   |               -- lifetime `'a` defined here                  ------------------- opaque type requires that `val` is borrowed for `'a`\n LL |         val.use_self()\n-   |         ^^^^^^^^^^^^^^ borrowed value does not live long enough\n-LL |     }\n-   |     - `val` dropped here while still borrowed\n-   |\n-help: you can add a bound to the opaque type to make it last less than `'static` and match `'a`\n-   |\n-LL |     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> + 'a {\n-   |                                                                                  ++++\n+   |         ^^^^^^^^^^^^^^ returns a reference to data owned by the current function\n \n error[E0515]: cannot return reference to function parameter `val`\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:43:9\n@@ -47,5 +38,4 @@ LL |     impl MyTrait for Box<dyn ObjectTrait<Assoc = i32> + '_> {\n \n error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0515, E0597.\n-For more information about an error, try `rustc --explain E0515`.\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "3ed3827b97da3b0b38c2c78a45d214e95ce1fd46", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.nll.stderr", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec724ac0753b7538668308a6aa5b78980b2931bb/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr?ref=ec724ac0753b7538668308a6aa5b78980b2931bb", "patch": "@@ -1,10 +1,13 @@\n error: lifetime may not live long enough\n-  --> $DIR/trait-object-nested-in-impl-trait.rs:27:23\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:28:9\n    |\n-LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n-   |             -         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n-   |             |\n-   |             let's call the lifetime of this reference `'1`\n+LL |       fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |               - let's call the lifetime of this reference `'1`\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________^ returning this value requires that `'1` must outlive `'static`\n    |\n help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n    |\n@@ -34,12 +37,15 @@ LL | |         }\n    | |_________^ returning this value requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/trait-object-nested-in-impl-trait.rs:60:30\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:61:9\n    |\n-LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n-   |             --               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n-   |             |\n-   |             lifetime `'a` defined here\n+LL |       fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |               -- lifetime `'a` defined here\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________^ returning this value requires that `'a` must outlive `'static`\n    |\n help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a bound\n    |"}]}