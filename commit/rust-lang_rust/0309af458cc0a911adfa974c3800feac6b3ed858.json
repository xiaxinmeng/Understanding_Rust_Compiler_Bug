{"sha": "0309af458cc0a911adfa974c3800feac6b3ed858", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMDlhZjQ1OGNjMGE5MTFhZGZhOTc0YzM4MDBmZWFjNmIzZWQ4NTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-20T23:02:21Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-22T07:01:17Z"}, "message": "Put unique allocs in managed heap when they might contain managed boxes.", "tree": {"sha": "f46c26b42ac62fc06a14f97759a61e4fc20c0357", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f46c26b42ac62fc06a14f97759a61e4fc20c0357"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0309af458cc0a911adfa974c3800feac6b3ed858", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0309af458cc0a911adfa974c3800feac6b3ed858", "html_url": "https://github.com/rust-lang/rust/commit/0309af458cc0a911adfa974c3800feac6b3ed858", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0309af458cc0a911adfa974c3800feac6b3ed858/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cec1f38c309b743b29a386ce71db1b1035ccd89d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cec1f38c309b743b29a386ce71db1b1035ccd89d", "html_url": "https://github.com/rust-lang/rust/commit/cec1f38c309b743b29a386ce71db1b1035ccd89d"}], "stats": {"total": 246, "additions": 186, "deletions": 60}, "files": [{"sha": "567d6da23a68ccdfcc0bdbc21651f71c4560595e", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 81, "deletions": 24, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -111,45 +111,102 @@ struct Task {\n  * This runs at task death to free all boxes.\n  */\n \n+struct AnnihilateStats {\n+    n_total_boxes: uint,\n+    n_unique_boxes: uint,\n+    n_bytes_freed: uint\n+}\n+\n+unsafe fn each_live_alloc(f: fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n+    use managed;\n+\n+    let task: *Task = transmute(rustrt::rust_get_task());\n+    let box = (*task).boxed_region.live_allocs;\n+    let mut box: *mut BoxRepr = transmute(copy box);\n+    while box != mut_null() {\n+        let next = transmute(copy (*box).header.next);\n+        let uniq =\n+            (*box).header.ref_count == managed::raw::RC_MANAGED_UNIQUE;\n+\n+        if ! f(box, uniq) {\n+            break\n+        }\n+\n+        box = next\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn debug_mem() -> bool {\n+    use os;\n+    use libc;\n+    do os::as_c_charp(\"RUST_DEBUG_MEM\") |p| {\n+        unsafe { libc::getenv(p) != null() }\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn debug_mem() -> bool {\n+    false\n+}\n+\n /// Destroys all managed memory (i.e. @ boxes) held by the current task.\n #[cfg(notest)]\n #[lang=\"annihilate\"]\n pub unsafe fn annihilate() {\n     use rt::rt_free;\n     use io::WriterUtil;\n+    use io;\n+    use libc;\n+    use sys;\n+    use managed;\n \n-    let task: *Task = transmute(rustrt::rust_get_task());\n+    let mut stats = AnnihilateStats {\n+        n_total_boxes: 0,\n+        n_unique_boxes: 0,\n+        n_bytes_freed: 0\n+    };\n \n     // Pass 1: Make all boxes immortal.\n-    let box = (*task).boxed_region.live_allocs;\n-    let mut box: *mut BoxRepr = transmute(copy box);\n-    while box != mut_null() {\n-        debug!(\"making box immortal: %x\", box as uint);\n-        (*box).header.ref_count = 0x77777777;\n-        box = transmute(copy (*box).header.next);\n+    for each_live_alloc |box, uniq| {\n+        stats.n_total_boxes += 1;\n+        if uniq {\n+            stats.n_unique_boxes += 1;\n+        } else {\n+            (*box).header.ref_count = managed::raw::RC_IMMORTAL;\n+        }\n     }\n \n     // Pass 2: Drop all boxes.\n-    let box = (*task).boxed_region.live_allocs;\n-    let mut box: *mut BoxRepr = transmute(copy box);\n-    while box != mut_null() {\n-        debug!(\"calling drop glue for box: %x\", box as uint);\n-        let tydesc: *TypeDesc = transmute(copy (*box).header.type_desc);\n-        let drop_glue: DropGlue = transmute(((*tydesc).drop_glue, 0));\n-        drop_glue(to_unsafe_ptr(&tydesc), transmute(&(*box).data));\n-\n-        box = transmute(copy (*box).header.next);\n+    for each_live_alloc |box, uniq| {\n+        if !uniq {\n+            let tydesc: *TypeDesc = transmute(copy (*box).header.type_desc);\n+            let drop_glue: DropGlue = transmute(((*tydesc).drop_glue, 0));\n+            drop_glue(to_unsafe_ptr(&tydesc), transmute(&(*box).data));\n+        }\n     }\n \n     // Pass 3: Free all boxes.\n-    loop {\n-        let box = (*task).boxed_region.live_allocs;\n-        if box == null() { break; }\n-        let mut box: *mut BoxRepr = transmute(copy box);\n-        assert (*box).header.prev == null();\n-\n-        debug!(\"freeing box: %x\", box as uint);\n-        rt_free(transmute(box));\n+    for each_live_alloc |box, uniq| {\n+        if !uniq {\n+            stats.n_bytes_freed +=\n+                (*((*box).header.type_desc)).size\n+                + sys::size_of::<BoxRepr>();\n+            rt_free(transmute(box));\n+        }\n+    }\n+\n+    if debug_mem() {\n+        // We do logging here w/o allocation.\n+        let dbg = libc::STDERR_FILENO as io::fd_t;\n+        dbg.write_str(\"annihilator stats:\");\n+        dbg.write_str(\"\\n  total_boxes: \");\n+        dbg.write_uint(stats.n_total_boxes);\n+        dbg.write_str(\"\\n  unique_boxes: \");\n+        dbg.write_uint(stats.n_unique_boxes);\n+        dbg.write_str(\"\\n  bytes_freed: \");\n+        dbg.write_uint(stats.n_bytes_freed);\n+        dbg.write_str(\"\\n\");\n     }\n }\n "}, {"sha": "bed50cfbc256e04c42860fbee233ac609ae02fb1", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -16,7 +16,13 @@ use managed::raw::BoxRepr;\n use prelude::*;\n use ptr;\n \n+\n pub mod raw {\n+\n+    pub const RC_EXCHANGE_UNIQUE : uint = (-1) as uint;\n+    pub const RC_MANAGED_UNIQUE : uint = (-2) as uint;\n+    pub const RC_IMMORTAL : uint = 0x77777777;\n+\n     use intrinsic::TyDesc;\n \n     pub struct BoxHeaderRepr {"}, {"sha": "31c837e7e8a3a9e93857a41d1c9a802f623a0384", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -31,9 +31,14 @@ use vec;\n \n #[abi = \"cdecl\"]\n pub extern mod rustrt {\n+    // These names are terrible. reserve_shared applies\n+    // to ~[] and reserve_shared_actual applies to @[].\n     unsafe fn vec_reserve_shared(++t: *sys::TypeDesc,\n                                  ++v: **raw::VecRepr,\n                                  ++n: libc::size_t);\n+    unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n+                                        ++v: **raw::VecRepr,\n+                                        ++n: libc::size_t);\n }\n \n /// Returns true if a vector contains no elements\n@@ -59,11 +64,17 @@ pub pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n  */\n pub fn reserve<T>(v: &mut ~[T], n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n+    use managed;\n     if capacity(v) < n {\n         unsafe {\n             let ptr: **raw::VecRepr = cast::transmute(v);\n-            rustrt::vec_reserve_shared(sys::get_type_desc::<T>(),\n-                                       ptr, n as size_t);\n+            let td = sys::get_type_desc::<T>();\n+            if ((**ptr).box_header.ref_count ==\n+                managed::raw::RC_MANAGED_UNIQUE) {\n+                rustrt::vec_reserve_shared_actual(td, ptr, n as size_t);\n+            } else {\n+                rustrt::vec_reserve_shared(td, ptr, n as size_t);\n+            }\n         }\n     }\n }"}, {"sha": "9e3be94294acab2d50e924c1c07fd0c02dc7f509", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -286,7 +286,7 @@ pub fn malloc_raw_dyn(bcx: block,\n     let ccx = bcx.ccx();\n \n     let (mk_fn, langcall) = match heap {\n-        heap_shared => {\n+        heap_managed | heap_managed_unique => {\n             (ty::mk_imm_box, bcx.tcx().lang_items.malloc_fn())\n         }\n         heap_exchange => {\n@@ -310,7 +310,9 @@ pub fn malloc_raw_dyn(bcx: block,\n         langcall,\n         ~[tydesc, size],\n         expr::SaveIn(rval));\n-    return rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty));\n+    let r = rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty));\n+    maybe_set_managed_unique_rc(r.bcx, r.val, heap);\n+    r\n }\n \n /**\n@@ -364,11 +366,31 @@ pub fn malloc_general(bcx: block, t: ty::t, heap: heap)\n }\n pub fn malloc_boxed(bcx: block, t: ty::t)\n     -> MallocResult {\n-    malloc_general(bcx, t, heap_shared)\n+    malloc_general(bcx, t, heap_managed)\n }\n+\n+pub fn heap_for_unique(bcx: block, t: ty::t) -> heap {\n+    if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+        heap_managed_unique\n+    } else {\n+        heap_exchange\n+    }\n+}\n+\n+pub fn maybe_set_managed_unique_rc(bcx: block, bx: ValueRef, heap: heap) {\n+    if heap == heap_managed_unique {\n+        // In cases where we are looking at a unique-typed allocation in the\n+        // managed heap (thus have refcount 1 from the managed allocator),\n+        // such as a ~(@foo) or such. These need to have their refcount forced\n+        // to -2 so the annihilator ignores them.\n+        let rc = GEPi(bcx, bx, [0u, abi::box_field_refcnt]);\n+        Store(bcx, C_int(bcx.ccx(), -2), rc);\n+    }\n+}\n+\n pub fn malloc_unique(bcx: block, t: ty::t)\n     -> MallocResult {\n-    malloc_general(bcx, t, heap_exchange)\n+    malloc_general(bcx, t, heap_for_unique(bcx, t))\n }\n \n // Type descriptor and type glue stuff"}, {"sha": "dc68eff9c7f64e29c9132b42360aaa8f27b23d62", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -178,10 +178,10 @@ pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n     // Allocate and initialize the box:\n     match sigil {\n         ast::ManagedSigil => {\n-            malloc_raw(bcx, cdata_ty, heap_shared)\n+            malloc_raw(bcx, cdata_ty, heap_managed)\n         }\n         ast::OwnedSigil => {\n-            malloc_raw(bcx, cdata_ty, heap_exchange)\n+            malloc_raw(bcx, cdata_ty, heap_for_unique(bcx, cdata_ty))\n         }\n         ast::BorrowedSigil => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n@@ -574,7 +574,7 @@ pub fn make_opaque_cbox_free_glue(\n         // Free the ty descr (if necc) and the box itself\n         match sigil {\n             ast::ManagedSigil => glue::trans_free(bcx, cbox),\n-            ast::OwnedSigil => glue::trans_unique_free(bcx, cbox),\n+            ast::OwnedSigil => glue::trans_exchange_free(bcx, cbox),\n             ast::BorrowedSigil => {\n                 bcx.sess().bug(~\"impossible\")\n             }"}, {"sha": "b58e374320ae6369523a497aad1a5c005c8d15d8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -332,8 +332,10 @@ pub fn warn_not_to_commit(ccx: @CrateContext, msg: ~str) {\n }\n \n // Heap selectors. Indicate which heap something should go on.\n+#[deriving_eq]\n pub enum heap {\n-    heap_shared,\n+    heap_managed,\n+    heap_managed_unique,\n     heap_exchange,\n }\n \n@@ -458,12 +460,12 @@ pub fn add_clean_frozen_root(bcx: block, val: ValueRef, t: ty::t) {\n }\n pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n-      heap_shared => {\n+      heap_managed | heap_managed_unique => {\n         let f: @fn(block) -> block = |a| glue::trans_free(a, ptr);\n         f\n       }\n       heap_exchange => {\n-        let f: @fn(block) -> block = |a| glue::trans_unique_free(a, ptr);\n+        let f: @fn(block) -> block = |a| glue::trans_exchange_free(a, ptr);\n         f\n       }\n     };"}, {"sha": "83265975b50652dd2c55dd987cce1ab655034b72", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -414,11 +414,12 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     match expr.node {\n         ast::expr_vstore(contents, ast::expr_vstore_box) |\n         ast::expr_vstore(contents, ast::expr_vstore_mut_box) => {\n-            return tvec::trans_uniq_or_managed_vstore(bcx, heap_shared,\n+            return tvec::trans_uniq_or_managed_vstore(bcx, heap_managed,\n                                                       expr, contents);\n         }\n         ast::expr_vstore(contents, ast::expr_vstore_uniq) => {\n-            return tvec::trans_uniq_or_managed_vstore(bcx, heap_exchange,\n+            let heap = heap_for_unique(bcx, expr_ty(bcx, contents));\n+            return tvec::trans_uniq_or_managed_vstore(bcx, heap,\n                                                       expr, contents);\n         }\n         ast::expr_lit(lit) => {\n@@ -1272,10 +1273,12 @@ fn trans_unary_datum(bcx: block,\n             immediate_rvalue_bcx(bcx, llneg, un_ty)\n         }\n         ast::box(_) => {\n-            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_shared)\n+            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty,\n+                             heap_managed)\n         }\n         ast::uniq(_) => {\n-            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_exchange)\n+            let heap  = heap_for_unique(bcx, un_ty);\n+            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap)\n         }\n         ast::deref => {\n             bcx.sess().bug(~\"deref expressions should have been \\"}, {"sha": "cd3a14b69e71d72a70725459519b9558192f1520", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -37,8 +37,8 @@ pub fn trans_free(cx: block, v: ValueRef) -> block {\n         expr::Ignore)\n }\n \n-pub fn trans_unique_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(\"trans_unique_free\");\n+pub fn trans_exchange_free(cx: block, v: ValueRef) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_exchange_free\");\n     callee::trans_rtcall_or_lang_call(\n         cx,\n         cx.tcx().lang_items.exchange_free_fn(),"}, {"sha": "02ea29f915d69e7c8331657f93c20ceaa7cdba54", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -878,7 +878,7 @@ pub fn trans_trait_cast(bcx: block,\n                 let MallocResult {bcx: new_bcx, box: llbox, body: body} =\n                     malloc_boxed(bcx, v_ty);\n                 bcx = new_bcx;\n-                add_clean_free(bcx, llbox, heap_shared);\n+                add_clean_free(bcx, llbox, heap_managed);\n                 bcx = expr::trans_into(bcx, val, SaveIn(body));\n                 revoke_clean(bcx, llbox);\n "}, {"sha": "345a20aa5fc69ea01b50cdff3d3a865319fd3652", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -85,11 +85,13 @@ pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n         base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n     Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n     Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n+    base::maybe_set_managed_unique_rc(bcx, bx, heap);\n     return rslt(bcx, bx);\n }\n+\n pub fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n                       fill: ValueRef, alloc: ValueRef) -> Result {\n-    alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange)\n+    alloc_raw(bcx, unit_ty, fill, alloc, heap_for_unique(bcx, unit_ty))\n }\n \n pub fn alloc_vec(bcx: block,\n@@ -317,13 +319,14 @@ pub fn trans_uniq_or_managed_vstore(bcx: block,\n                 _ => {}\n             }\n         }\n-        heap_shared => {}\n+        heap_managed | heap_managed_unique => {}\n     }\n \n     let vt = vec_types_from_expr(bcx, vstore_expr);\n     let count = elements_required(bcx, content_expr);\n \n     let Result {bcx, val} = alloc_vec(bcx, vt.unit_ty, count, heap);\n+\n     add_clean_free(bcx, val, heap);\n     let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n "}, {"sha": "aa02cc4bf5d53ec9996ba8cddb73620cf9988c8b", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -30,7 +30,11 @@ pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n         let body_datum = box_datum.box_body(bcx);\n         let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n                                 body_datum.ty);\n-        glue::trans_unique_free(bcx, box_datum.val)\n+        if ty::type_contents(bcx.tcx(), box_ty).contains_managed() {\n+            glue::trans_free(bcx, box_datum.val)\n+        } else {\n+            glue::trans_exchange_free(bcx, box_datum.val)\n+        }\n     }\n }\n "}, {"sha": "fdcbf2d995714ff6a104c16868e93479444c9357", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -1571,10 +1571,11 @@ pub pure fn type_is_vec(ty: t) -> bool {\n \n pub pure fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_uniq(_) => return true,\n-      ty_evec(_, vstore_uniq) => true,\n-      ty_estr(vstore_uniq) => true,\n-      _ => return false\n+        ty_uniq(_) |\n+        ty_evec(_, vstore_uniq) |\n+        ty_estr(vstore_uniq) |\n+        ty_opaque_closure_ptr(ast::OwnedSigil) => true,\n+        _ => return false\n     }\n }\n \n@@ -1799,6 +1800,10 @@ pub impl TypeContents {\n         TC_MANAGED + TC_BORROWED_POINTER\n     }\n \n+    fn contains_managed(&self) -> bool {\n+        self.intersects(TC_MANAGED)\n+    }\n+\n     fn is_const(&self, cx: ctxt) -> bool {\n         !self.intersects(TypeContents::nonconst(cx))\n     }\n@@ -2083,11 +2088,19 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC_ALL\n             }\n \n-            ty_trait(_, _, vstore_fixed(_)) |\n-            ty_type |\n-            ty_opaque_closure_ptr(_) |\n-            ty_opaque_box |\n-            ty_unboxed_vec(_) |\n+            ty_opaque_box => TC_MANAGED,\n+            ty_unboxed_vec(mt) => tc_mt(cx, mt, cache),\n+            ty_opaque_closure_ptr(sigil) => {\n+                match sigil {\n+                    ast::BorrowedSigil => TC_BORROWED_POINTER,\n+                    ast::ManagedSigil => TC_MANAGED,\n+                    ast::OwnedSigil => TC_OWNED_CLOSURE\n+                }\n+            }\n+\n+            ty_type => TC_NONE,\n+            ty_trait(_, _, vstore_fixed(_)) => TC_NONE,\n+\n             ty_err => {\n                 cx.sess.bug(~\"Asked to compute contents of fictitious type\");\n             }\n@@ -2229,8 +2242,11 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n           ty_infer(_) => {\n             cx.sess.bug(~\"Asked to compute kind of a type variable\");\n           }\n-          ty_type | ty_opaque_closure_ptr(_)\n-          | ty_opaque_box | ty_unboxed_vec(_) | ty_err => {\n+          ty_type => 1,\n+          ty_opaque_closure_ptr(_) => 1,\n+          ty_opaque_box => 1,\n+          ty_unboxed_vec(_) => 10,\n+          ty_err => {\n             cx.sess.bug(~\"Asked to compute kind of fictitious type\");\n           }\n         }"}, {"sha": "d159df03dc3c0c3fc2ccd97c0d20adfcca6bc80b", "filename": "src/rt/boxed_region.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Frt%2Fboxed_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0309af458cc0a911adfa974c3800feac6b3ed858/src%2Frt%2Fboxed_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.cpp?ref=0309af458cc0a911adfa974c3800feac6b3ed858", "patch": "@@ -38,7 +38,10 @@ rust_opaque_box *boxed_region::malloc(type_desc *td, size_t body_size) {\n \n rust_opaque_box *boxed_region::realloc(rust_opaque_box *box,\n                                        size_t new_size) {\n-    assert(box->ref_count == 1);\n+\n+    // We also get called on the unique-vec-in-managed-heap path.\n+    assert(box->ref_count == 1 ||\n+           box->ref_count == (size_t)(-2));\n \n     size_t total_size = new_size + sizeof(rust_opaque_box);\n     rust_opaque_box *new_box =\n@@ -47,7 +50,6 @@ rust_opaque_box *boxed_region::realloc(rust_opaque_box *box,\n     if (new_box->next) new_box->next->prev = new_box;\n     if (live_allocs == box) live_allocs = new_box;\n \n-\n     LOG(rust_get_current_task(), box,\n         \"@realloc()=%p with orig=%p, size %lu==%lu+%lu\",\n         new_box, box, total_size, sizeof(rust_opaque_box), new_size);"}]}