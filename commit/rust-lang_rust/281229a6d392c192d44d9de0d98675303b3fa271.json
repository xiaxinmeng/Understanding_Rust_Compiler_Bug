{"sha": "281229a6d392c192d44d9de0d98675303b3fa271", "node_id": "C_kwDOAAsO6NoAKDI4MTIyOWE2ZDM5MmMxOTJkNDRkOWRlMGQ5ODY3NTMwM2IzZmEyNzE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-01T07:17:05Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-05T22:47:49Z"}, "message": "Handle stalling within `ObligationForest`.\n\nIt is simpler if `ObligationForest` does this itself, rather than the\ncaller having to manage it.", "tree": {"sha": "e30259ca0f2164cd78d6ea7b5ef6eb39b9e6481c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e30259ca0f2164cd78d6ea7b5ef6eb39b9e6481c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/281229a6d392c192d44d9de0d98675303b3fa271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/281229a6d392c192d44d9de0d98675303b3fa271", "html_url": "https://github.com/rust-lang/rust/commit/281229a6d392c192d44d9de0d98675303b3fa271", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/281229a6d392c192d44d9de0d98675303b3fa271/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdb446fec39b9359ffcf04e1c4ba7c2eae800809", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb446fec39b9359ffcf04e1c4ba7c2eae800809", "html_url": "https://github.com/rust-lang/rust/commit/cdb446fec39b9359ffcf04e1c4ba7c2eae800809"}], "stats": {"total": 173, "additions": 70, "deletions": 103}, "files": [{"sha": "60f8f37b226ec06b925b3ed925cb72d59df97930", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 61, "deletions": 74, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/281229a6d392c192d44d9de0d98675303b3fa271/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/281229a6d392c192d44d9de0d98675303b3fa271/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=281229a6d392c192d44d9de0d98675303b3fa271", "patch": "@@ -42,7 +42,7 @@\n //!   now considered to be in error.\n //!\n //! When the call to `process_obligations` completes, you get back an `Outcome`,\n-//! which includes three bits of information:\n+//! which includes two bits of information:\n //!\n //! - `completed`: a list of obligations where processing was fully\n //!   completed without error (meaning that all transitive subobligations\n@@ -53,13 +53,10 @@\n //!   all the obligations in `C` have been found completed.\n //! - `errors`: a list of errors that occurred and associated backtraces\n //!   at the time of error, which can be used to give context to the user.\n-//! - `stalled`: if true, then none of the existing obligations were\n-//!   *shallowly successful* (that is, no callback returned `Changed(_)`).\n-//!   This implies that all obligations were either errors or returned an\n-//!   ambiguous result, which means that any further calls to\n-//!   `process_obligations` would simply yield back further ambiguous\n-//!   results. This is used by the `FulfillmentContext` to decide when it\n-//!   has reached a steady state.\n+//!\n+//! Upon completion, none of the existing obligations were *shallowly\n+//! successful* (that is, no callback returned `Changed(_)`). This implies that\n+//! all obligations were either errors or returned an ambiguous result.\n //!\n //! ### Implementation details\n //!\n@@ -260,8 +257,6 @@ pub trait OutcomeTrait {\n     type Obligation;\n \n     fn new() -> Self;\n-    fn mark_not_stalled(&mut self);\n-    fn is_stalled(&self) -> bool;\n     fn record_completed(&mut self, outcome: &Self::Obligation);\n     fn record_error(&mut self, error: Self::Error);\n }\n@@ -270,30 +265,14 @@ pub trait OutcomeTrait {\n pub struct Outcome<O, E> {\n     /// Backtrace of obligations that were found to be in error.\n     pub errors: Vec<Error<O, E>>,\n-\n-    /// If true, then we saw no successful obligations, which means\n-    /// there is no point in further iteration. This is based on the\n-    /// assumption that when trait matching returns `Error` or\n-    /// `Unchanged`, those results do not affect environmental\n-    /// inference state. (Note that if we invoke `process_obligations`\n-    /// with no pending obligations, stalled will be true.)\n-    pub stalled: bool,\n }\n \n impl<O, E> OutcomeTrait for Outcome<O, E> {\n     type Error = Error<O, E>;\n     type Obligation = O;\n \n     fn new() -> Self {\n-        Self { stalled: true, errors: vec![] }\n-    }\n-\n-    fn mark_not_stalled(&mut self) {\n-        self.stalled = false;\n-    }\n-\n-    fn is_stalled(&self) -> bool {\n-        self.stalled\n+        Self { errors: vec![] }\n     }\n \n     fn record_completed(&mut self, _outcome: &Self::Obligation) {\n@@ -415,10 +394,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .insert(node.obligation.as_cache_key());\n     }\n \n-    /// Performs a pass through the obligation list. This must\n-    /// be called in a loop until `outcome.stalled` is false.\n-    ///\n-    /// This _cannot_ be unrolled (presently, at least).\n+    /// Performs a fixpoint computation over the obligation list.\n     #[inline(never)]\n     pub fn process_obligations<P, OUT>(&mut self, processor: &mut P) -> OUT\n     where\n@@ -427,55 +403,66 @@ impl<O: ForestObligation> ObligationForest<O> {\n     {\n         let mut outcome = OUT::new();\n \n-        // Note that the loop body can append new nodes, and those new nodes\n-        // will then be processed by subsequent iterations of the loop.\n-        //\n-        // We can't use an iterator for the loop because `self.nodes` is\n-        // appended to and the borrow checker would complain. We also can't use\n-        // `for index in 0..self.nodes.len() { ... }` because the range would\n-        // be computed with the initial length, and we would miss the appended\n-        // nodes. Therefore we use a `while` loop.\n-        let mut index = 0;\n-        while let Some(node) = self.nodes.get_mut(index) {\n-            // `processor.process_obligation` can modify the predicate within\n-            // `node.obligation`, and that predicate is the key used for\n-            // `self.active_cache`. This means that `self.active_cache` can get\n-            // out of sync with `nodes`. It's not very common, but it does\n-            // happen, and code in `compress` has to allow for it.\n-            if node.state.get() != NodeState::Pending {\n-                index += 1;\n-                continue;\n-            }\n-\n-            match processor.process_obligation(&mut node.obligation) {\n-                ProcessResult::Unchanged => {\n-                    // No change in state.\n+        // Fixpoint computation: we repeat until the inner loop stalls.\n+        loop {\n+            let mut has_changed = false;\n+\n+            // Note that the loop body can append new nodes, and those new nodes\n+            // will then be processed by subsequent iterations of the loop.\n+            //\n+            // We can't use an iterator for the loop because `self.nodes` is\n+            // appended to and the borrow checker would complain. We also can't use\n+            // `for index in 0..self.nodes.len() { ... }` because the range would\n+            // be computed with the initial length, and we would miss the appended\n+            // nodes. Therefore we use a `while` loop.\n+            let mut index = 0;\n+            while let Some(node) = self.nodes.get_mut(index) {\n+                // `processor.process_obligation` can modify the predicate within\n+                // `node.obligation`, and that predicate is the key used for\n+                // `self.active_cache`. This means that `self.active_cache` can get\n+                // out of sync with `nodes`. It's not very common, but it does\n+                // happen, and code in `compress` has to allow for it.\n+                if node.state.get() != NodeState::Pending {\n+                    index += 1;\n+                    continue;\n                 }\n-                ProcessResult::Changed(children) => {\n-                    // We are not (yet) stalled.\n-                    outcome.mark_not_stalled();\n-                    node.state.set(NodeState::Success);\n-\n-                    for child in children {\n-                        let st = self.register_obligation_at(child, Some(index));\n-                        if let Err(()) = st {\n-                            // Error already reported - propagate it\n-                            // to our node.\n-                            self.error_at(index);\n+\n+                match processor.process_obligation(&mut node.obligation) {\n+                    ProcessResult::Unchanged => {\n+                        // No change in state.\n+                    }\n+                    ProcessResult::Changed(children) => {\n+                        // We are not (yet) stalled.\n+                        has_changed = true;\n+                        node.state.set(NodeState::Success);\n+\n+                        for child in children {\n+                            let st = self.register_obligation_at(child, Some(index));\n+                            if let Err(()) = st {\n+                                // Error already reported - propagate it\n+                                // to our node.\n+                                self.error_at(index);\n+                            }\n                         }\n                     }\n+                    ProcessResult::Error(err) => {\n+                        has_changed = true;\n+                        outcome.record_error(Error { error: err, backtrace: self.error_at(index) });\n+                    }\n                 }\n-                ProcessResult::Error(err) => {\n-                    outcome.mark_not_stalled();\n-                    outcome.record_error(Error { error: err, backtrace: self.error_at(index) });\n-                }\n+                index += 1;\n+            }\n+\n+            // If unchanged, then we saw no successful obligations, which means\n+            // there is no point in further iteration. This is based on the\n+            // assumption that when trait matching returns `Error` or\n+            // `Unchanged`, those results do not affect environmental inference\n+            // state. (Note that this will occur if we invoke\n+            // `process_obligations` with no pending obligations.)\n+            if !has_changed {\n+                break;\n             }\n-            index += 1;\n-        }\n \n-        // There's no need to perform marking, cycle processing and compression when nothing\n-        // changed.\n-        if !outcome.is_stalled() {\n             self.mark_successes();\n             self.process_cycles(processor);\n             self.compress(|obl| outcome.record_completed(obl));"}, {"sha": "5ecc75736a3100141a0ec857e5bc85c4ed8b295b", "filename": "compiler/rustc_data_structures/src/obligation_forest/tests.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/281229a6d392c192d44d9de0d98675303b3fa271/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/281229a6d392c192d44d9de0d98675303b3fa271/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs?ref=281229a6d392c192d44d9de0d98675303b3fa271", "patch": "@@ -20,7 +20,6 @@ struct ClosureObligationProcessor<OF, BF, O, E> {\n struct TestOutcome<O, E> {\n     pub completed: Vec<O>,\n     pub errors: Vec<Error<O, E>>,\n-    pub stalled: bool,\n }\n \n impl<O, E> OutcomeTrait for TestOutcome<O, E>\n@@ -31,15 +30,7 @@ where\n     type Obligation = O;\n \n     fn new() -> Self {\n-        Self { errors: vec![], stalled: false, completed: vec![] }\n-    }\n-\n-    fn mark_not_stalled(&mut self) {\n-        self.stalled = false;\n-    }\n-\n-    fn is_stalled(&self) -> bool {\n-        self.stalled\n+        Self { errors: vec![], completed: vec![] }\n     }\n \n     fn record_completed(&mut self, outcome: &Self::Obligation) {"}, {"sha": "3ec0d320f856285c1dc95e9621a982d2f5812e3e", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/281229a6d392c192d44d9de0d98675303b3fa271/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/281229a6d392c192d44d9de0d98675303b3fa271/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=281229a6d392c192d44d9de0d98675303b3fa271", "patch": "@@ -133,27 +133,16 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n \n         let mut errors = Vec::new();\n \n-        loop {\n-            debug!(\"select: starting another iteration\");\n+        // Process pending obligations.\n+        let outcome: Outcome<_, _> = self.predicates.process_obligations(&mut FulfillProcessor {\n+            selcx,\n+            register_region_obligations: self.register_region_obligations,\n+        });\n \n-            // Process pending obligations.\n-            let outcome: Outcome<_, _> =\n-                self.predicates.process_obligations(&mut FulfillProcessor {\n-                    selcx,\n-                    register_region_obligations: self.register_region_obligations,\n-                });\n-            debug!(\"select: outcome={:#?}\", outcome);\n+        // FIXME: if we kept the original cache key, we could mark projection\n+        // obligations as complete for the projection cache here.\n \n-            // FIXME: if we kept the original cache key, we could mark projection\n-            // obligations as complete for the projection cache here.\n-\n-            errors.extend(outcome.errors.into_iter().map(to_fulfillment_error));\n-\n-            // If nothing new was added, no need to keep looping.\n-            if outcome.stalled {\n-                break;\n-            }\n-        }\n+        errors.extend(outcome.errors.into_iter().map(to_fulfillment_error));\n \n         debug!(\n             \"select({} predicates remaining, {} errors) done\","}]}