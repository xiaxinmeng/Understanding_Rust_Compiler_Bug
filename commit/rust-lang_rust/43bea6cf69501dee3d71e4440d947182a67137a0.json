{"sha": "43bea6cf69501dee3d71e4440d947182a67137a0", "node_id": "C_kwDOAAsO6NoAKDQzYmVhNmNmNjk1MDFkZWUzZDcxZTQ0NDBkOTQ3MTgyYTY3MTM3YTA", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-11-05T12:54:45Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-11-05T13:55:20Z"}, "message": "resolve: Fill effective visibilities for import def ids in a separate pass\n\nThis should result in less update calls than doing it repeatedly during the fix point iteration.", "tree": {"sha": "482cf0de03411f65220f4e522cb39cc0f9d54fe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/482cf0de03411f65220f4e522cb39cc0f9d54fe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43bea6cf69501dee3d71e4440d947182a67137a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43bea6cf69501dee3d71e4440d947182a67137a0", "html_url": "https://github.com/rust-lang/rust/commit/43bea6cf69501dee3d71e4440d947182a67137a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43bea6cf69501dee3d71e4440d947182a67137a0/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "448261a78a35026b3f5e855b705f35c916ecb19b", "url": "https://api.github.com/repos/rust-lang/rust/commits/448261a78a35026b3f5e855b705f35c916ecb19b", "html_url": "https://github.com/rust-lang/rust/commit/448261a78a35026b3f5e855b705f35c916ecb19b"}], "stats": {"total": 95, "additions": 61, "deletions": 34}, "files": [{"sha": "3a91522d362298400438eb5ee0446c2f10522d7c", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/43bea6cf69501dee3d71e4440d947182a67137a0/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bea6cf69501dee3d71e4440d947182a67137a0/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=43bea6cf69501dee3d71e4440d947182a67137a0", "patch": "@@ -113,8 +113,30 @@ impl EffectiveVisibilities {\n         })\n     }\n \n-    pub fn iter(&self) -> impl Iterator<Item = (&LocalDefId, &EffectiveVisibility)> {\n-        self.map.iter()\n+    // FIXME: Share code with `fn update`.\n+    pub fn update_eff_vis(\n+        &mut self,\n+        def_id: LocalDefId,\n+        eff_vis: &EffectiveVisibility,\n+        tree: impl DefIdTree,\n+    ) {\n+        use std::collections::hash_map::Entry;\n+        match self.map.entry(def_id) {\n+            Entry::Occupied(mut occupied) => {\n+                let old_eff_vis = occupied.get_mut();\n+                for l in Level::all_levels() {\n+                    let vis_at_level = eff_vis.at_level(l);\n+                    let old_vis_at_level = old_eff_vis.at_level_mut(l);\n+                    if vis_at_level != old_vis_at_level\n+                        && vis_at_level.is_at_least(*old_vis_at_level, tree)\n+                    {\n+                        *old_vis_at_level = *vis_at_level\n+                    }\n+                }\n+                old_eff_vis\n+            }\n+            Entry::Vacant(vacant) => vacant.insert(*eff_vis),\n+        };\n     }\n \n     pub fn set_public_at_level(\n@@ -185,6 +207,10 @@ impl EffectiveVisibilities {\n }\n \n impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n+    pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n+        self.map.iter()\n+    }\n+\n     pub fn effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n         self.map.get(&id)\n     }"}, {"sha": "fa6d34be0cc37c00a794031984ab513bb54d67f0", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/43bea6cf69501dee3d71e4440d947182a67137a0/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bea6cf69501dee3d71e4440d947182a67137a0/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=43bea6cf69501dee3d71e4440d947182a67137a0", "patch": "@@ -55,6 +55,38 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n             visit::walk_crate(&mut visitor, krate);\n         }\n \n+        // Update visibilities for import def ids. These are not used during the\n+        // `EffectiveVisibilitiesVisitor` pass, because we have more detailed binding-based\n+        // information, but are used by later passes. Effective visibility of an import def id\n+        // is the maximum value among visibilities of bindings corresponding to that def id.\n+        for (binding, eff_vis) in visitor.import_effective_visibilities.iter() {\n+            let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n+            if let Some(node_id) = import.id() {\n+                let mut update = |node_id| {\n+                    r.effective_visibilities.update_eff_vis(\n+                        r.local_def_id(node_id),\n+                        eff_vis,\n+                        ResolverTree(&r.definitions, &r.crate_loader),\n+                    )\n+                };\n+                update(node_id);\n+                if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n+                    // In theory all the single import IDs have individual visibilities and\n+                    // effective visibilities, but in practice these IDs go straigth to HIR\n+                    // where all their few uses assume that their (effective) visibility\n+                    // applies to the whole syntactic `use` item. So they all get the same\n+                    // value which is the maximum of all bindings. Maybe HIR for imports\n+                    // shouldn't use three IDs at all.\n+                    if id1 != ast::DUMMY_NODE_ID {\n+                        update(id1);\n+                    }\n+                    if id2 != ast::DUMMY_NODE_ID {\n+                        update(id2);\n+                    }\n+                }\n+            }\n+        }\n+\n         info!(\"resolve::effective_visibilities: {:#?}\", r.effective_visibilities);\n     }\n \n@@ -75,41 +107,10 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                 // sets the rest of the `use` chain to `Level::Reexported` until\n                 // we hit the actual exported item.\n                 let mut parent_id = ParentId::Def(module_id);\n-                while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n-                    binding.kind\n-                {\n+                while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind {\n                     let binding_id = ImportId::new_unchecked(binding);\n                     self.update_import(binding_id, parent_id);\n \n-                    // Update visibilities for import ids. These are not used during this pass,\n-                    // because we have more detailed binding-based information, but are used by\n-                    // later passes. Effective visibility of an import def id is the maximum value\n-                    // among visibilities of bindings corresponding to that def id.\n-                    if let Some(node_id) = import.id() {\n-                        let mut update = |node_id| {\n-                            self.update_def(\n-                                self.r.local_def_id(node_id),\n-                                binding.vis.expect_local(),\n-                                parent_id,\n-                            )\n-                        };\n-                        update(node_id);\n-                        if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n-                            // In theory all the single import IDs have individual visibilities and\n-                            // effective visibilities, but in practice these IDs go straigth to HIR\n-                            // where all their few uses assume that their (effective) visibility\n-                            // applies to the whole syntactic `use` item. So they all get the same\n-                            // value which is the maximum of all bindings. Maybe HIR for imports\n-                            // shouldn't use three IDs at all.\n-                            if id1 != ast::DUMMY_NODE_ID {\n-                                update(id1);\n-                            }\n-                            if id2 != ast::DUMMY_NODE_ID {\n-                                update(id2);\n-                            }\n-                        }\n-                    }\n-\n                     parent_id = ParentId::Import(binding_id);\n                     binding = nested_binding;\n                 }"}]}