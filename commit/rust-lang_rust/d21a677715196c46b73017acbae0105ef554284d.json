{"sha": "d21a677715196c46b73017acbae0105ef554284d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMWE2Nzc3MTUxOTZjNDZiNzMwMTdhY2JhZTAxMDVlZjU1NDI4NGQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-02T07:50:09Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-02T07:50:09Z"}, "message": "Merge #1085\n\n1085: add ast::tokens r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "318d41ba567cf7ce1c5b4ead1857da64aa24242f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/318d41ba567cf7ce1c5b4ead1857da64aa24242f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d21a677715196c46b73017acbae0105ef554284d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d21a677715196c46b73017acbae0105ef554284d", "html_url": "https://github.com/rust-lang/rust/commit/d21a677715196c46b73017acbae0105ef554284d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d21a677715196c46b73017acbae0105ef554284d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "c2912892effbcf24d94da235b9ac0d2a7fccea5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2912892effbcf24d94da235b9ac0d2a7fccea5d", "html_url": "https://github.com/rust-lang/rust/commit/c2912892effbcf24d94da235b9ac0d2a7fccea5d"}, {"sha": "3f3ff2f0f4c188c606a96506325d96726c842239", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f3ff2f0f4c188c606a96506325d96726c842239", "html_url": "https://github.com/rust-lang/rust/commit/3f3ff2f0f4c188c606a96506325d96726c842239"}], "stats": {"total": 568, "additions": 292, "deletions": 276}, "files": [{"sha": "19a2d05bcbd347f1c8d24d9fc24f6a59865de7e7", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -5,7 +5,7 @@ use crate::{Assist, AssistId, AssistCtx};\n use hir::Resolver;\n use hir::db::HirDatabase;\n use ra_syntax::{SmolStr, SyntaxKind, TextRange, TextUnit, TreeArc};\n-use ra_syntax::ast::{self, AstNode, FnDef, ImplItem, ImplItemKind, NameOwner};\n+use ra_syntax::ast::{self, AstNode, AstToken, FnDef, ImplItem, ImplItemKind, NameOwner};\n use ra_db::FilePosition;\n use ra_fmt::{leading_indent, reindent};\n "}, {"sha": "950c2910b80f300ee3842f1e53af1fadb65c698d", "filename": "crates/ra_assists/src/inline_local_variable.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -1,14 +1,9 @@\n use hir::{\n     db::HirDatabase,\n-    source_binder::function_from_child_node\n+    source_binder::function_from_child_node,\n };\n use ra_syntax::{\n-    ast::{\n-        self,\n-        AstNode,\n-        PatKind,\n-        ExprKind\n-    },\n+    ast::{self, AstNode, AstToken, PatKind, ExprKind},\n     TextRange,\n };\n "}, {"sha": "85b7ce2503fa741dcf4e62aa5f302688c92532a2", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -2,9 +2,8 @@\n //!\n use itertools::Itertools;\n use ra_syntax::{\n-    AstNode,\n     SyntaxNode, SyntaxKind::*, SyntaxToken, SyntaxKind,\n-    ast,\n+    ast::{self, AstNode, AstToken},\n     algo::generate,\n };\n "}, {"sha": "daccd9fba0c0972b56034c18e672a68e25a59e15", "filename": "crates/ra_ide_api/src/completion/snapshots/completion_item__enum_variant_with_details.snap", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__enum_variant_with_details.snap", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__enum_variant_with_details.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__enum_variant_with_details.snap?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -1,6 +1,6 @@\n ---\n-created: \"2019-02-18T09:22:24.062138085Z\"\n-creator: insta@0.6.2\n+created: \"2019-04-02T07:43:12.954637543Z\"\n+creator: insta@0.7.4\n source: crates/ra_ide_api/src/completion/completion_item.rs\n expression: kind_completions\n ---\n@@ -33,6 +33,9 @@ expression: kind_completions\n         delete: [180; 180),\n         insert: \"S\",\n         kind: EnumVariant,\n-        detail: \"(S)\"\n+        detail: \"(S)\",\n+        documentation: Documentation(\n+            \"\"\n+        )\n     }\n ]"}, {"sha": "7293ba3590c3f90ad41e8c6535f6df425f186a49", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -1,9 +1,9 @@\n use ra_db::SourceDatabase;\n use ra_syntax::{\n-    Direction, SyntaxNode, TextRange, TextUnit, AstNode, SyntaxElement,\n+    Direction, SyntaxNode, TextRange, TextUnit, SyntaxElement,\n     algo::{find_covering_element, find_token_at_offset, TokenAtOffset},\n     SyntaxKind::*, SyntaxToken,\n-    ast::Comment,\n+    ast::{self, AstNode, AstToken},\n };\n \n use crate::{FileRange, db::RootDatabase};\n@@ -55,7 +55,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n             if token.range() != range {\n                 return Some(token.range());\n             }\n-            if let Some(comment) = Comment::cast(token) {\n+            if let Some(comment) = ast::Comment::cast(token) {\n                 if let Some(range) = extend_comments(comment) {\n                     return Some(range);\n                 }\n@@ -176,7 +176,7 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n     None\n }\n \n-fn extend_comments(comment: Comment) -> Option<TextRange> {\n+fn extend_comments(comment: ast::Comment) -> Option<TextRange> {\n     let prev = adj_comments(comment, Direction::Prev);\n     let next = adj_comments(comment, Direction::Next);\n     if prev != next {\n@@ -186,14 +186,14 @@ fn extend_comments(comment: Comment) -> Option<TextRange> {\n     }\n }\n \n-fn adj_comments(comment: Comment, dir: Direction) -> Comment {\n+fn adj_comments(comment: ast::Comment, dir: Direction) -> ast::Comment {\n     let mut res = comment;\n     for element in comment.syntax().siblings_with_tokens(dir) {\n         let token = match element.as_token() {\n             None => break,\n             Some(token) => token,\n         };\n-        if let Some(c) = Comment::cast(token) {\n+        if let Some(c) = ast::Comment::cast(token) {\n             res = c\n         } else if token.kind() != WHITESPACE || token.text().contains(\"\\n\\n\") {\n             break;"}, {"sha": "eada0b7ded5466434abb26f3e6bbd1ac344438c0", "filename": "crates/ra_ide_api/src/folding_ranges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -1,9 +1,9 @@\n use rustc_hash::FxHashSet;\n \n use ra_syntax::{\n-    AstNode, SourceFile, SyntaxNode, TextRange, Direction, SyntaxElement,\n+    SourceFile, SyntaxNode, TextRange, Direction, SyntaxElement,\n     SyntaxKind::{self, *},\n-    ast::{self, VisibilityOwner, Comment},\n+    ast::{self, AstNode, AstToken, VisibilityOwner},\n };\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -139,8 +139,8 @@ fn contiguous_range_for_group_unless<'a>(\n }\n \n fn contiguous_range_for_comment<'a>(\n-    first: Comment<'a>,\n-    visited: &mut FxHashSet<Comment<'a>>,\n+    first: ast::Comment<'a>,\n+    visited: &mut FxHashSet<ast::Comment<'a>>,\n ) -> Option<TextRange> {\n     visited.insert(first);\n \n@@ -157,7 +157,7 @@ fn contiguous_range_for_comment<'a>(\n                         continue;\n                     }\n                 }\n-                if let Some(c) = Comment::cast(token) {\n+                if let Some(c) = ast::Comment::cast(token) {\n                     if c.flavor() == group_flavor {\n                         visited.insert(c);\n                         last = c;"}, {"sha": "59871731198a9977e90c0da9d717962246cf3d72", "filename": "crates/ra_ide_api/src/join_lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -1,9 +1,9 @@\n use itertools::Itertools;\n use ra_syntax::{\n-    SourceFile, TextRange, TextUnit, AstNode, SyntaxNode, SyntaxElement, SyntaxToken,\n+    SourceFile, TextRange, TextUnit, SyntaxNode, SyntaxElement, SyntaxToken,\n     SyntaxKind::{self, WHITESPACE, COMMA, R_CURLY, R_PAREN, R_BRACK},\n     algo::{find_covering_element, non_trivia_sibling},\n-    ast,\n+    ast::{self, AstNode, AstToken},\n     Direction,\n };\n use ra_fmt::{"}, {"sha": "aeeeea082122dd9183af4dbe8c3c068df9a884bb", "filename": "crates/ra_ide_api/src/typing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -2,7 +2,7 @@ use ra_syntax::{\n     AstNode, SourceFile, SyntaxKind::*,\n     TextUnit, TextRange, SyntaxToken,\n     algo::{find_node_at_offset, find_token_at_offset, TokenAtOffset},\n-    ast::{self},\n+    ast::{self, AstToken},\n };\n use ra_fmt::leading_indent;\n use ra_text_edit::{TextEdit, TextEditBuilder};"}, {"sha": "beef2c6e2c2638b854e1c6a1a40d6c5ad7b0fe3f", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 26, "deletions": 249, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -1,17 +1,24 @@\n //! Abstract Syntax Tree, layered on top of untyped `SyntaxNode`s\n mod generated;\n+mod traits;\n+mod tokens;\n \n use std::marker::PhantomData;\n \n use itertools::Itertools;\n \n-pub use self::generated::*;\n use crate::{\n-    syntax_node::{SyntaxNode, SyntaxNodeChildren, TreeArc, RaTypes, SyntaxToken, SyntaxElement, SyntaxElementChildren},\n+    syntax_node::{SyntaxNode, SyntaxNodeChildren, TreeArc, RaTypes, SyntaxToken, SyntaxElement},\n     SmolStr,\n     SyntaxKind::*,\n };\n \n+pub use self::{\n+    generated::*,\n+    traits::*,\n+    tokens::*,\n+};\n+\n /// The main trait to go from untyped `SyntaxNode`  to a typed ast. The\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n@@ -25,134 +32,32 @@ pub trait AstNode:\n     fn syntax(&self) -> &SyntaxNode;\n }\n \n-pub trait TypeAscriptionOwner: AstNode {\n-    fn ascribed_type(&self) -> Option<&TypeRef> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait NameOwner: AstNode {\n-    fn name(&self) -> Option<&Name> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait VisibilityOwner: AstNode {\n-    fn visibility(&self) -> Option<&Visibility> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait LoopBodyOwner: AstNode {\n-    fn loop_body(&self) -> Option<&Block> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait ArgListOwner: AstNode {\n-    fn arg_list(&self) -> Option<&ArgList> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait FnDefOwner: AstNode {\n-    fn functions(&self) -> AstChildren<FnDef> {\n-        children(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ItemOrMacro<'a> {\n-    Item(&'a ModuleItem),\n-    Macro(&'a MacroCall),\n-}\n-\n-pub trait ModuleItemOwner: AstNode {\n-    fn items(&self) -> AstChildren<ModuleItem> {\n-        children(self)\n-    }\n-    fn items_with_macros(&self) -> ItemOrMacroIter {\n-        ItemOrMacroIter(self.syntax().children())\n-    }\n-}\n-\n #[derive(Debug)]\n-pub struct ItemOrMacroIter<'a>(SyntaxNodeChildren<'a>);\n-\n-impl<'a> Iterator for ItemOrMacroIter<'a> {\n-    type Item = ItemOrMacro<'a>;\n-    fn next(&mut self) -> Option<ItemOrMacro<'a>> {\n-        loop {\n-            let n = self.0.next()?;\n-            if let Some(item) = ModuleItem::cast(n) {\n-                return Some(ItemOrMacro::Item(item));\n-            }\n-            if let Some(call) = MacroCall::cast(n) {\n-                return Some(ItemOrMacro::Macro(call));\n-            }\n-        }\n-    }\n-}\n-\n-pub trait TypeParamsOwner: AstNode {\n-    fn type_param_list(&self) -> Option<&TypeParamList> {\n-        child_opt(self)\n-    }\n-\n-    fn where_clause(&self) -> Option<&WhereClause> {\n-        child_opt(self)\n-    }\n+pub struct AstChildren<'a, N> {\n+    inner: SyntaxNodeChildren<'a>,\n+    ph: PhantomData<N>,\n }\n \n-pub trait TypeBoundsOwner: AstNode {\n-    fn type_bound_list(&self) -> Option<&TypeBoundList> {\n-        child_opt(self)\n+impl<'a, N> AstChildren<'a, N> {\n+    fn new(parent: &'a SyntaxNode) -> Self {\n+        AstChildren { inner: parent.children(), ph: PhantomData }\n     }\n }\n \n-pub trait AttrsOwner: AstNode {\n-    fn attrs(&self) -> AstChildren<Attr> {\n-        children(self)\n-    }\n-    fn has_atom_attr(&self, atom: &str) -> bool {\n-        self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n+impl<'a, N: AstNode + 'a> Iterator for AstChildren<'a, N> {\n+    type Item = &'a N;\n+    fn next(&mut self) -> Option<&'a N> {\n+        self.inner.by_ref().find_map(N::cast)\n     }\n }\n \n-pub trait DocCommentsOwner: AstNode {\n-    fn doc_comments(&self) -> CommentIter {\n-        CommentIter { iter: self.syntax().children_with_tokens() }\n-    }\n-\n-    /// Returns the textual content of a doc comment block as a single string.\n-    /// That is, strips leading `///` (+ optional 1 character of whitespace)\n-    /// and joins lines.\n-    fn doc_comment_text(&self) -> Option<std::string::String> {\n-        let docs = self\n-            .doc_comments()\n-            .filter(|comment| comment.is_doc_comment())\n-            .map(|comment| {\n-                let prefix_len = comment.prefix().len();\n-\n-                let line = comment.text().as_str();\n-\n-                // Determine if the prefix or prefix + 1 char is stripped\n-                let pos =\n-                    if line.chars().nth(prefix_len).map(|c| c.is_whitespace()).unwrap_or(false) {\n-                        prefix_len + 1\n-                    } else {\n-                        prefix_len\n-                    };\n-\n-                line[pos..].to_owned()\n-            })\n-            .join(\"\\n\");\n-\n-        if docs.is_empty() {\n-            None\n-        } else {\n-            Some(docs)\n-        }\n+pub trait AstToken<'a> {\n+    fn cast(token: SyntaxToken<'a>) -> Option<Self>\n+    where\n+        Self: Sized;\n+    fn syntax(&self) -> SyntaxToken<'a>;\n+    fn text(&self) -> &'a SmolStr {\n+        self.syntax().text()\n     }\n }\n \n@@ -203,111 +108,6 @@ impl Attr {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Comment<'a>(SyntaxToken<'a>);\n-\n-impl<'a> Comment<'a> {\n-    pub fn cast(token: SyntaxToken<'a>) -> Option<Self> {\n-        if token.kind() == COMMENT {\n-            Some(Comment(token))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn syntax(&self) -> SyntaxToken<'a> {\n-        self.0\n-    }\n-\n-    pub fn text(&self) -> &'a SmolStr {\n-        self.0.text()\n-    }\n-\n-    pub fn flavor(&self) -> CommentFlavor {\n-        let text = self.text();\n-        if text.starts_with(\"///\") {\n-            CommentFlavor::Doc\n-        } else if text.starts_with(\"//!\") {\n-            CommentFlavor::ModuleDoc\n-        } else if text.starts_with(\"//\") {\n-            CommentFlavor::Line\n-        } else {\n-            CommentFlavor::Multiline\n-        }\n-    }\n-\n-    pub fn is_doc_comment(&self) -> bool {\n-        self.flavor().is_doc_comment()\n-    }\n-\n-    pub fn prefix(&self) -> &'static str {\n-        self.flavor().prefix()\n-    }\n-}\n-\n-pub struct CommentIter<'a> {\n-    iter: SyntaxElementChildren<'a>,\n-}\n-\n-impl<'a> Iterator for CommentIter<'a> {\n-    type Item = Comment<'a>;\n-    fn next(&mut self) -> Option<Comment<'a>> {\n-        self.iter.by_ref().find_map(|el| el.as_token().and_then(Comment::cast))\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub enum CommentFlavor {\n-    Line,\n-    Doc,\n-    ModuleDoc,\n-    Multiline,\n-}\n-\n-impl CommentFlavor {\n-    pub fn prefix(&self) -> &'static str {\n-        use self::CommentFlavor::*;\n-        match *self {\n-            Line => \"//\",\n-            Doc => \"///\",\n-            ModuleDoc => \"//!\",\n-            Multiline => \"/*\",\n-        }\n-    }\n-\n-    pub fn is_doc_comment(&self) -> bool {\n-        match self {\n-            CommentFlavor::Doc | CommentFlavor::ModuleDoc => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-pub struct Whitespace<'a>(SyntaxToken<'a>);\n-\n-impl<'a> Whitespace<'a> {\n-    pub fn cast(token: SyntaxToken<'a>) -> Option<Self> {\n-        if token.kind() == WHITESPACE {\n-            Some(Whitespace(token))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn syntax(&self) -> SyntaxToken<'a> {\n-        self.0\n-    }\n-\n-    pub fn text(&self) -> &'a SmolStr {\n-        self.0.text()\n-    }\n-\n-    pub fn spans_multiple_lines(&self) -> bool {\n-        let text = self.text();\n-        text.find('\\n').map_or(false, |idx| text[idx + 1..].contains('\\n'))\n-    }\n-}\n-\n impl Name {\n     pub fn text(&self) -> &SmolStr {\n         let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n@@ -468,29 +268,6 @@ fn children<P: AstNode, C: AstNode>(parent: &P) -> AstChildren<C> {\n     AstChildren::new(parent.syntax())\n }\n \n-#[derive(Debug)]\n-pub struct AstChildren<'a, N> {\n-    inner: SyntaxNodeChildren<'a>,\n-    ph: PhantomData<N>,\n-}\n-\n-impl<'a, N> AstChildren<'a, N> {\n-    fn new(parent: &'a SyntaxNode) -> Self {\n-        AstChildren { inner: parent.children(), ph: PhantomData }\n-    }\n-}\n-\n-impl<'a, N: AstNode + 'a> Iterator for AstChildren<'a, N> {\n-    type Item = &'a N;\n-    fn next(&mut self) -> Option<&'a N> {\n-        loop {\n-            if let Some(n) = N::cast(self.inner.next()?) {\n-                return Some(n);\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum StructFlavor<'a> {\n     Tuple(&'a PosFieldDefList),"}, {"sha": "76a12cd6453bdb0713a2c95040d47c80a07a1374", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -0,0 +1,92 @@\n+use crate::{\n+    SyntaxToken,\n+    SyntaxKind::{COMMENT, WHITESPACE},\n+    ast::AstToken,\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Comment<'a>(SyntaxToken<'a>);\n+\n+impl<'a> AstToken<'a> for Comment<'a> {\n+    fn cast(token: SyntaxToken<'a>) -> Option<Self> {\n+        if token.kind() == COMMENT {\n+            Some(Comment(token))\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> SyntaxToken<'a> {\n+        self.0\n+    }\n+}\n+\n+impl<'a> Comment<'a> {\n+    pub fn flavor(&self) -> CommentFlavor {\n+        let text = self.text();\n+        if text.starts_with(\"///\") {\n+            CommentFlavor::OuterDoc\n+        } else if text.starts_with(\"//!\") {\n+            CommentFlavor::InnerDoc\n+        } else if text.starts_with(\"//\") {\n+            CommentFlavor::Line\n+        } else {\n+            CommentFlavor::Multiline\n+        }\n+    }\n+\n+    pub fn is_doc_comment(&self) -> bool {\n+        self.flavor().is_doc_comment()\n+    }\n+\n+    pub fn prefix(&self) -> &'static str {\n+        self.flavor().prefix()\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum CommentFlavor {\n+    Line,\n+    OuterDoc,\n+    InnerDoc,\n+    Multiline,\n+}\n+\n+impl CommentFlavor {\n+    pub fn prefix(&self) -> &'static str {\n+        match *self {\n+            CommentFlavor::Line => \"//\",\n+            CommentFlavor::OuterDoc => \"///\",\n+            CommentFlavor::InnerDoc => \"//!\",\n+            CommentFlavor::Multiline => \"/*\",\n+        }\n+    }\n+\n+    pub fn is_doc_comment(&self) -> bool {\n+        match self {\n+            CommentFlavor::OuterDoc | CommentFlavor::InnerDoc => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+pub struct Whitespace<'a>(SyntaxToken<'a>);\n+\n+impl<'a> AstToken<'a> for Whitespace<'a> {\n+    fn cast(token: SyntaxToken<'a>) -> Option<Self> {\n+        if token.kind() == WHITESPACE {\n+            Some(Whitespace(token))\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> SyntaxToken<'a> {\n+        self.0\n+    }\n+}\n+\n+impl<'a> Whitespace<'a> {\n+    pub fn spans_multiple_lines(&self) -> bool {\n+        let text = self.text();\n+        text.find('\\n').map_or(false, |idx| text[idx + 1..].contains('\\n'))\n+    }\n+}"}, {"sha": "43d1509fab3a0250e246c6ae71836a925ed9209a", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21a677715196c46b73017acbae0105ef554284d/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=d21a677715196c46b73017acbae0105ef554284d", "patch": "@@ -0,0 +1,150 @@\n+use itertools::Itertools;\n+\n+use crate::{\n+    syntax_node::{SyntaxNodeChildren, SyntaxElementChildren},\n+    ast::{self, child_opt, children, AstNode, AstToken, AstChildren},\n+};\n+\n+pub trait TypeAscriptionOwner: AstNode {\n+    fn ascribed_type(&self) -> Option<&ast::TypeRef> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait NameOwner: AstNode {\n+    fn name(&self) -> Option<&ast::Name> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait VisibilityOwner: AstNode {\n+    fn visibility(&self) -> Option<&ast::Visibility> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait LoopBodyOwner: AstNode {\n+    fn loop_body(&self) -> Option<&ast::Block> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait ArgListOwner: AstNode {\n+    fn arg_list(&self) -> Option<&ast::ArgList> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait FnDefOwner: AstNode {\n+    fn functions(&self) -> AstChildren<ast::FnDef> {\n+        children(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ItemOrMacro<'a> {\n+    Item(&'a ast::ModuleItem),\n+    Macro(&'a ast::MacroCall),\n+}\n+\n+pub trait ModuleItemOwner: AstNode {\n+    fn items(&self) -> AstChildren<ast::ModuleItem> {\n+        children(self)\n+    }\n+    fn items_with_macros(&self) -> ItemOrMacroIter {\n+        ItemOrMacroIter(self.syntax().children())\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ItemOrMacroIter<'a>(SyntaxNodeChildren<'a>);\n+\n+impl<'a> Iterator for ItemOrMacroIter<'a> {\n+    type Item = ItemOrMacro<'a>;\n+    fn next(&mut self) -> Option<ItemOrMacro<'a>> {\n+        loop {\n+            let n = self.0.next()?;\n+            if let Some(item) = ast::ModuleItem::cast(n) {\n+                return Some(ItemOrMacro::Item(item));\n+            }\n+            if let Some(call) = ast::MacroCall::cast(n) {\n+                return Some(ItemOrMacro::Macro(call));\n+            }\n+        }\n+    }\n+}\n+\n+pub trait TypeParamsOwner: AstNode {\n+    fn type_param_list(&self) -> Option<&ast::TypeParamList> {\n+        child_opt(self)\n+    }\n+\n+    fn where_clause(&self) -> Option<&ast::WhereClause> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait TypeBoundsOwner: AstNode {\n+    fn type_bound_list(&self) -> Option<&ast::TypeBoundList> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait AttrsOwner: AstNode {\n+    fn attrs(&self) -> AstChildren<ast::Attr> {\n+        children(self)\n+    }\n+    fn has_atom_attr(&self, atom: &str) -> bool {\n+        self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n+    }\n+}\n+\n+pub trait DocCommentsOwner: AstNode {\n+    fn doc_comments(&self) -> CommentIter {\n+        CommentIter { iter: self.syntax().children_with_tokens() }\n+    }\n+\n+    /// Returns the textual content of a doc comment block as a single string.\n+    /// That is, strips leading `///` (+ optional 1 character of whitespace)\n+    /// and joins lines.\n+    fn doc_comment_text(&self) -> Option<String> {\n+        let mut has_comments = false;\n+        let docs = self\n+            .doc_comments()\n+            .filter(|comment| comment.is_doc_comment())\n+            .map(|comment| {\n+                has_comments = true;\n+                let prefix_len = comment.prefix().len();\n+\n+                let line = comment.text().as_str();\n+\n+                // Determine if the prefix or prefix + 1 char is stripped\n+                let pos =\n+                    if line.chars().nth(prefix_len).map(|c| c.is_whitespace()).unwrap_or(false) {\n+                        prefix_len + 1\n+                    } else {\n+                        prefix_len\n+                    };\n+\n+                line[pos..].to_owned()\n+            })\n+            .join(\"\\n\");\n+\n+        if has_comments {\n+            Some(docs)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+pub struct CommentIter<'a> {\n+    iter: SyntaxElementChildren<'a>,\n+}\n+\n+impl<'a> Iterator for CommentIter<'a> {\n+    type Item = ast::Comment<'a>;\n+    fn next(&mut self) -> Option<ast::Comment<'a>> {\n+        self.iter.by_ref().find_map(|el| el.as_token().and_then(ast::Comment::cast))\n+    }\n+}"}]}