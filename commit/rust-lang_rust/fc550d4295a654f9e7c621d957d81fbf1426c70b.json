{"sha": "fc550d4295a654f9e7c621d957d81fbf1426c70b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNTUwZDQyOTVhNjU0ZjllN2M2MjFkOTU3ZDgxZmJmMTQyNmM3MGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-14T12:37:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-14T12:37:28Z"}, "message": "Auto merge of #61421 - vorner:string-in-rc-into-raw-docs, r=RalfJung\n\ndocs: Use String in Rc::into_raw examples\n\nIt is unclear if accessing an integer after `drop_in_place` has been\ncalled on it is undefined behaviour or not, as demonstrated by the\ndiscussion in\nhttps://github.com/rust-lang/rust/pull/60766#pullrequestreview-243414222.\n\nAvoid these uncertainties by using String which frees memory in its\n`drop_in_place` to make sure this is undefined behaviour. The message in\nthe docs should be to watch out and not access the data after that, not\ndiscussing when one maybe could get away with it O:-).", "tree": {"sha": "1644e6d39d4471a7bf5c98a09a77dde021a2f587", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1644e6d39d4471a7bf5c98a09a77dde021a2f587"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc550d4295a654f9e7c621d957d81fbf1426c70b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc550d4295a654f9e7c621d957d81fbf1426c70b", "html_url": "https://github.com/rust-lang/rust/commit/fc550d4295a654f9e7c621d957d81fbf1426c70b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc550d4295a654f9e7c621d957d81fbf1426c70b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e699ea096fcc2fc9ce8e8bcf884e11496a31cc9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e699ea096fcc2fc9ce8e8bcf884e11496a31cc9f", "html_url": "https://github.com/rust-lang/rust/commit/e699ea096fcc2fc9ce8e8bcf884e11496a31cc9f"}, {"sha": "79e58399920d6a0a7c4050bfb26c64fbc10562ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/79e58399920d6a0a7c4050bfb26c64fbc10562ec", "html_url": "https://github.com/rust-lang/rust/commit/79e58399920d6a0a7c4050bfb26c64fbc10562ec"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "7cbb496330173a56ec23d04050ce0b9690b79ee0", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fc550d4295a654f9e7c621d957d81fbf1426c70b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc550d4295a654f9e7c621d957d81fbf1426c70b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=fc550d4295a654f9e7c621d957d81fbf1426c70b", "patch": "@@ -375,9 +375,9 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let x = Rc::new(10);\n+    /// let x = Rc::new(\"hello\".to_owned());\n     /// let x_ptr = Rc::into_raw(x);\n-    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n@@ -401,13 +401,13 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let x = Rc::new(10);\n+    /// let x = Rc::new(\"hello\".to_owned());\n     /// let x_ptr = Rc::into_raw(x);\n     ///\n     /// unsafe {\n     ///     // Convert back to an `Rc` to prevent leak.\n     ///     let x = Rc::from_raw(x_ptr);\n-    ///     assert_eq!(*x, 10);\n+    ///     assert_eq!(&*x, \"hello\");\n     ///\n     ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n     /// }\n@@ -437,10 +437,10 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// use std::rc::Rc;\n     ///\n-    /// let x = Rc::new(10);\n+    /// let x = Rc::new(\"hello\".to_owned());\n     /// let ptr = Rc::into_raw_non_null(x);\n-    /// let deref = unsafe { *ptr.as_ref() };\n-    /// assert_eq!(deref, 10);\n+    /// let deref = unsafe { ptr.as_ref() };\n+    /// assert_eq!(deref, \"hello\");\n     /// ```\n     #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n     #[inline]\n@@ -1294,17 +1294,17 @@ impl<T> Weak<T> {\n     /// use std::rc::{Rc, Weak};\n     /// use std::ptr;\n     ///\n-    /// let strong = Rc::new(42);\n+    /// let strong = Rc::new(\"hello\".to_owned());\n     /// let weak = Rc::downgrade(&strong);\n     /// // Both point to the same object\n     /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// assert_eq!(\"hello\", unsafe { &*Weak::as_raw(&weak) });\n     ///\n     /// drop(strong);\n     /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// // assert_eq!(\"hello\", unsafe { &*Weak::as_raw(&weak) });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n@@ -1339,12 +1339,12 @@ impl<T> Weak<T> {\n     ///\n     /// use std::rc::{Rc, Weak};\n     ///\n-    /// let strong = Rc::new(42);\n+    /// let strong = Rc::new(\"hello\".to_owned());\n     /// let weak = Rc::downgrade(&strong);\n     /// let raw = Weak::into_raw(weak);\n     ///\n     /// assert_eq!(1, Rc::weak_count(&strong));\n-    /// assert_eq!(42, unsafe { *raw });\n+    /// assert_eq!(\"hello\", unsafe { &*raw });\n     ///\n     /// drop(unsafe { Weak::from_raw(raw) });\n     /// assert_eq!(0, Rc::weak_count(&strong));\n@@ -1380,14 +1380,14 @@ impl<T> Weak<T> {\n     ///\n     /// use std::rc::{Rc, Weak};\n     ///\n-    /// let strong = Rc::new(42);\n+    /// let strong = Rc::new(\"hello\".to_owned());\n     ///\n     /// let raw_1 = Weak::into_raw(Rc::downgrade(&strong));\n     /// let raw_2 = Weak::into_raw(Rc::downgrade(&strong));\n     ///\n     /// assert_eq!(2, Rc::weak_count(&strong));\n     ///\n-    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(\"hello\", &*Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n     /// assert_eq!(1, Rc::weak_count(&strong));\n     ///\n     /// drop(strong);"}, {"sha": "2503f696bf32906654a6dcc1b62f0876e00052ed", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fc550d4295a654f9e7c621d957d81fbf1426c70b/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc550d4295a654f9e7c621d957d81fbf1426c70b/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=fc550d4295a654f9e7c621d957d81fbf1426c70b", "patch": "@@ -356,9 +356,9 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let x = Arc::new(10);\n+    /// let x = Arc::new(\"hello\".to_owned());\n     /// let x_ptr = Arc::into_raw(x);\n-    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n@@ -382,13 +382,13 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let x = Arc::new(10);\n+    /// let x = Arc::new(\"hello\".to_owned());\n     /// let x_ptr = Arc::into_raw(x);\n     ///\n     /// unsafe {\n     ///     // Convert back to an `Arc` to prevent leak.\n     ///     let x = Arc::from_raw(x_ptr);\n-    ///     assert_eq!(*x, 10);\n+    ///     assert_eq!(&*x, \"hello\");\n     ///\n     ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n     /// }\n@@ -418,10 +418,10 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// use std::sync::Arc;\n     ///\n-    /// let x = Arc::new(10);\n+    /// let x = Arc::new(\"hello\".to_owned());\n     /// let ptr = Arc::into_raw_non_null(x);\n-    /// let deref = unsafe { *ptr.as_ref() };\n-    /// assert_eq!(deref, 10);\n+    /// let deref = unsafe { ptr.as_ref() };\n+    /// assert_eq!(deref, \"hello\");\n     /// ```\n     #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n     #[inline]\n@@ -1083,17 +1083,17 @@ impl<T> Weak<T> {\n     /// use std::sync::{Arc, Weak};\n     /// use std::ptr;\n     ///\n-    /// let strong = Arc::new(42);\n+    /// let strong = Arc::new(\"hello\".to_owned());\n     /// let weak = Arc::downgrade(&strong);\n     /// // Both point to the same object\n     /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// assert_eq!(\"hello\", unsafe { &*Weak::as_raw(&weak) });\n     ///\n     /// drop(strong);\n     /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// // assert_eq!(\"hello\", unsafe { &*Weak::as_raw(&weak) });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n@@ -1128,12 +1128,12 @@ impl<T> Weak<T> {\n     ///\n     /// use std::sync::{Arc, Weak};\n     ///\n-    /// let strong = Arc::new(42);\n+    /// let strong = Arc::new(\"hello\".to_owned());\n     /// let weak = Arc::downgrade(&strong);\n     /// let raw = Weak::into_raw(weak);\n     ///\n     /// assert_eq!(1, Arc::weak_count(&strong));\n-    /// assert_eq!(42, unsafe { *raw });\n+    /// assert_eq!(\"hello\", unsafe { &*raw });\n     ///\n     /// drop(unsafe { Weak::from_raw(raw) });\n     /// assert_eq!(0, Arc::weak_count(&strong));\n@@ -1170,14 +1170,14 @@ impl<T> Weak<T> {\n     ///\n     /// use std::sync::{Arc, Weak};\n     ///\n-    /// let strong = Arc::new(42);\n+    /// let strong = Arc::new(\"hello\".to_owned());\n     ///\n     /// let raw_1 = Weak::into_raw(Arc::downgrade(&strong));\n     /// let raw_2 = Weak::into_raw(Arc::downgrade(&strong));\n     ///\n     /// assert_eq!(2, Arc::weak_count(&strong));\n     ///\n-    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(\"hello\", &*Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n     /// assert_eq!(1, Arc::weak_count(&strong));\n     ///\n     /// drop(strong);"}]}