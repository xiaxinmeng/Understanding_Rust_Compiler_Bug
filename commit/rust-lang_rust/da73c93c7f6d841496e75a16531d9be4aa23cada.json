{"sha": "da73c93c7f6d841496e75a16531d9be4aa23cada", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNzNjOTNjN2Y2ZDg0MTQ5NmU3NWExNjUzMWQ5YmU0YWEyM2NhZGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-08T17:27:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-08T17:37:20Z"}, "message": "Don't punish every crate with serde-json", "tree": {"sha": "360aae1dc872b22a71014f253e3a98f21a3502a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/360aae1dc872b22a71014f253e3a98f21a3502a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da73c93c7f6d841496e75a16531d9be4aa23cada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da73c93c7f6d841496e75a16531d9be4aa23cada", "html_url": "https://github.com/rust-lang/rust/commit/da73c93c7f6d841496e75a16531d9be4aa23cada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da73c93c7f6d841496e75a16531d9be4aa23cada/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d57c9f79801762aa23adc21adbb638678268e96b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d57c9f79801762aa23adc21adbb638678268e96b", "html_url": "https://github.com/rust-lang/rust/commit/d57c9f79801762aa23adc21adbb638678268e96b"}], "stats": {"total": 195, "additions": 96, "deletions": 99}, "files": [{"sha": "15ed1da8e9d91c9632e8833aa61a56811b7f0071", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da73c93c7f6d841496e75a16531d9be4aa23cada/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/da73c93c7f6d841496e75a16531d9be4aa23cada/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=da73c93c7f6d841496e75a16531d9be4aa23cada", "patch": "@@ -1612,7 +1612,6 @@ dependencies = [\n  \"dissimilar\",\n  \"profile\",\n  \"rustc-hash\",\n- \"serde_json\",\n  \"stdx\",\n  \"text-size\",\n ]"}, {"sha": "cd0c914817e644978cfdb873abe8b831d71f336a", "filename": "crates/rust-analyzer/tests/rust-analyzer/support.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/da73c93c7f6d841496e75a16531d9be4aa23cada/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da73c93c7f6d841496e75a16531d9be4aa23cada/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs?ref=da73c93c7f6d841496e75a16531d9be4aa23cada", "patch": "@@ -13,7 +13,7 @@ use project_model::ProjectManifest;\n use rust_analyzer::{config::Config, lsp_ext, main_loop};\n use serde::Serialize;\n use serde_json::{json, to_string_pretty, Value};\n-use test_utils::{find_mismatch, Fixture};\n+use test_utils::Fixture;\n use vfs::AbsPathBuf;\n \n use crate::testdir::TestDir;\n@@ -279,3 +279,98 @@ fn recv_timeout(receiver: &Receiver<Message>) -> Result<Option<Message>, Timeout\n         recv(after(timeout)) -> _ => Err(Timeout),\n     }\n }\n+\n+// Comparison functionality borrowed from cargo:\n+\n+/// Compares JSON object for approximate equality.\n+/// You can use `[..]` wildcard in strings (useful for OS dependent things such\n+/// as paths). You can use a `\"{...}\"` string literal as a wildcard for\n+/// arbitrary nested JSON. Arrays are sorted before comparison.\n+fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a Value, &'a Value)> {\n+    match (expected, actual) {\n+        (Value::Number(l), Value::Number(r)) if l == r => None,\n+        (Value::Bool(l), Value::Bool(r)) if l == r => None,\n+        (Value::String(l), Value::String(r)) if lines_match(l, r) => None,\n+        (Value::Array(l), Value::Array(r)) => {\n+            if l.len() != r.len() {\n+                return Some((expected, actual));\n+            }\n+\n+            let mut l = l.iter().collect::<Vec<_>>();\n+            let mut r = r.iter().collect::<Vec<_>>();\n+\n+            l.retain(|l| match r.iter().position(|r| find_mismatch(l, r).is_none()) {\n+                Some(i) => {\n+                    r.remove(i);\n+                    false\n+                }\n+                None => true,\n+            });\n+\n+            if !l.is_empty() {\n+                assert!(!r.is_empty());\n+                Some((&l[0], &r[0]))\n+            } else {\n+                assert_eq!(r.len(), 0);\n+                None\n+            }\n+        }\n+        (Value::Object(l), Value::Object(r)) => {\n+            fn sorted_values(obj: &serde_json::Map<String, Value>) -> Vec<&Value> {\n+                let mut entries = obj.iter().collect::<Vec<_>>();\n+                entries.sort_by_key(|it| it.0);\n+                entries.into_iter().map(|(_k, v)| v).collect::<Vec<_>>()\n+            }\n+\n+            let same_keys = l.len() == r.len() && l.keys().all(|k| r.contains_key(k));\n+            if !same_keys {\n+                return Some((expected, actual));\n+            }\n+\n+            let l = sorted_values(l);\n+            let r = sorted_values(r);\n+\n+            l.into_iter().zip(r).filter_map(|(l, r)| find_mismatch(l, r)).next()\n+        }\n+        (Value::Null, Value::Null) => None,\n+        // magic string literal \"{...}\" acts as wildcard for any sub-JSON\n+        (Value::String(l), _) if l == \"{...}\" => None,\n+        _ => Some((expected, actual)),\n+    }\n+}\n+\n+/// Compare a line with an expected pattern.\n+/// - Use `[..]` as a wildcard to match 0 or more characters on the same line\n+///   (similar to `.*` in a regex).\n+fn lines_match(expected: &str, actual: &str) -> bool {\n+    // Let's not deal with / vs \\ (windows...)\n+    // First replace backslash-escaped backslashes with forward slashes\n+    // which can occur in, for example, JSON output\n+    let expected = expected.replace(r\"\\\\\", \"/\").replace(r\"\\\", \"/\");\n+    let mut actual: &str = &actual.replace(r\"\\\\\", \"/\").replace(r\"\\\", \"/\");\n+    for (i, part) in expected.split(\"[..]\").enumerate() {\n+        match actual.find(part) {\n+            Some(j) => {\n+                if i == 0 && j != 0 {\n+                    return false;\n+                }\n+                actual = &actual[j + part.len()..];\n+            }\n+            None => return false,\n+        }\n+    }\n+    actual.is_empty() || expected.ends_with(\"[..]\")\n+}\n+\n+#[test]\n+fn lines_match_works() {\n+    assert!(lines_match(\"a b\", \"a b\"));\n+    assert!(lines_match(\"a[..]b\", \"a b\"));\n+    assert!(lines_match(\"a[..]\", \"a b\"));\n+    assert!(lines_match(\"[..]\", \"a b\"));\n+    assert!(lines_match(\"[..]b\", \"a b\"));\n+\n+    assert!(!lines_match(\"[..]b\", \"c\"));\n+    assert!(!lines_match(\"b\", \"c\"));\n+    assert!(!lines_match(\"b\", \"cb\"));\n+}"}, {"sha": "87bab7a08620e2f48824ae170d471cfa883abe0b", "filename": "crates/test_utils/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da73c93c7f6d841496e75a16531d9be4aa23cada/crates%2Ftest_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/da73c93c7f6d841496e75a16531d9be4aa23cada/crates%2Ftest_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2FCargo.toml?ref=da73c93c7f6d841496e75a16531d9be4aa23cada", "patch": "@@ -13,7 +13,6 @@ doctest = false\n # Avoid adding deps here, this crate is widely used in tests it should compile fast!\n dissimilar = \"1.0.2\"\n text-size = \"1.0.0\"\n-serde_json = \"1.0.48\"\n rustc-hash = \"1.1.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "27b05e34b0c7f89bcac42c652867abfba37b2ae3", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/da73c93c7f6d841496e75a16531d9be4aa23cada/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da73c93c7f6d841496e75a16531d9be4aa23cada/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=da73c93c7f6d841496e75a16531d9be4aa23cada", "patch": "@@ -18,7 +18,6 @@ use std::{\n };\n \n use profile::StopWatch;\n-use serde_json::Value;\n use stdx::lines_with_ends;\n use text_size::{TextRange, TextSize};\n \n@@ -281,101 +280,6 @@ fn main() {\n     );\n }\n \n-// Comparison functionality borrowed from cargo:\n-\n-/// Compare a line with an expected pattern.\n-/// - Use `[..]` as a wildcard to match 0 or more characters on the same line\n-///   (similar to `.*` in a regex).\n-pub fn lines_match(expected: &str, actual: &str) -> bool {\n-    // Let's not deal with / vs \\ (windows...)\n-    // First replace backslash-escaped backslashes with forward slashes\n-    // which can occur in, for example, JSON output\n-    let expected = expected.replace(r\"\\\\\", \"/\").replace(r\"\\\", \"/\");\n-    let mut actual: &str = &actual.replace(r\"\\\\\", \"/\").replace(r\"\\\", \"/\");\n-    for (i, part) in expected.split(\"[..]\").enumerate() {\n-        match actual.find(part) {\n-            Some(j) => {\n-                if i == 0 && j != 0 {\n-                    return false;\n-                }\n-                actual = &actual[j + part.len()..];\n-            }\n-            None => return false,\n-        }\n-    }\n-    actual.is_empty() || expected.ends_with(\"[..]\")\n-}\n-\n-#[test]\n-fn lines_match_works() {\n-    assert!(lines_match(\"a b\", \"a b\"));\n-    assert!(lines_match(\"a[..]b\", \"a b\"));\n-    assert!(lines_match(\"a[..]\", \"a b\"));\n-    assert!(lines_match(\"[..]\", \"a b\"));\n-    assert!(lines_match(\"[..]b\", \"a b\"));\n-\n-    assert!(!lines_match(\"[..]b\", \"c\"));\n-    assert!(!lines_match(\"b\", \"c\"));\n-    assert!(!lines_match(\"b\", \"cb\"));\n-}\n-\n-/// Compares JSON object for approximate equality.\n-/// You can use `[..]` wildcard in strings (useful for OS dependent things such\n-/// as paths). You can use a `\"{...}\"` string literal as a wildcard for\n-/// arbitrary nested JSON. Arrays are sorted before comparison.\n-pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a Value, &'a Value)> {\n-    match (expected, actual) {\n-        (Value::Number(l), Value::Number(r)) if l == r => None,\n-        (Value::Bool(l), Value::Bool(r)) if l == r => None,\n-        (Value::String(l), Value::String(r)) if lines_match(l, r) => None,\n-        (Value::Array(l), Value::Array(r)) => {\n-            if l.len() != r.len() {\n-                return Some((expected, actual));\n-            }\n-\n-            let mut l = l.iter().collect::<Vec<_>>();\n-            let mut r = r.iter().collect::<Vec<_>>();\n-\n-            l.retain(|l| match r.iter().position(|r| find_mismatch(l, r).is_none()) {\n-                Some(i) => {\n-                    r.remove(i);\n-                    false\n-                }\n-                None => true,\n-            });\n-\n-            if !l.is_empty() {\n-                assert!(!r.is_empty());\n-                Some((&l[0], &r[0]))\n-            } else {\n-                assert_eq!(r.len(), 0);\n-                None\n-            }\n-        }\n-        (Value::Object(l), Value::Object(r)) => {\n-            fn sorted_values(obj: &serde_json::Map<String, Value>) -> Vec<&Value> {\n-                let mut entries = obj.iter().collect::<Vec<_>>();\n-                entries.sort_by_key(|it| it.0);\n-                entries.into_iter().map(|(_k, v)| v).collect::<Vec<_>>()\n-            }\n-\n-            let same_keys = l.len() == r.len() && l.keys().all(|k| r.contains_key(k));\n-            if !same_keys {\n-                return Some((expected, actual));\n-            }\n-\n-            let l = sorted_values(l);\n-            let r = sorted_values(r);\n-\n-            l.into_iter().zip(r).filter_map(|(l, r)| find_mismatch(l, r)).next()\n-        }\n-        (Value::Null, Value::Null) => None,\n-        // magic string literal \"{...}\" acts as wildcard for any sub-JSON\n-        (Value::String(l), _) if l == \"{...}\" => None,\n-        _ => Some((expected, actual)),\n-    }\n-}\n-\n /// Returns `false` if slow tests should not run, otherwise returns `true` and\n /// also creates a file at `./target/.slow_tests_cookie` which serves as a flag\n /// that slow tests did run."}]}