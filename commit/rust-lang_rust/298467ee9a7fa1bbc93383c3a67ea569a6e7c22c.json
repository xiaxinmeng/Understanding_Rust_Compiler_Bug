{"sha": "298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ODQ2N2VlOWE3ZmExYmJjOTMzODNjM2E2N2VhNTY5YTZlN2MyMmM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-11T11:15:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-11T11:15:53Z"}, "message": "Rollup merge of #72380 - lcnr:const_context, r=estebank\n\nFix `is_const_context`, update `check_for_cast`\n\nA better version of #71477\n\nAdds `fn enclosing_body_owner` and uses it in `is_const_context`.\n`is_const_context` now uses the same mechanism as `mir_const_qualif` as it was previously incorrect.\nRenames `is_const_context` to `is_inside_const_context`.\n\nI also updated `check_for_cast` in the second commit, so r? @estebank\n\n(I removed one lvl of indentation, so it might be easier to review by hiding whitespace changes)", "tree": {"sha": "a8dc5451a4b50b0a62d05c8b03d3a8d5480e7b74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8dc5451a4b50b0a62d05c8b03d3a8d5480e7b74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe4hJpCRBK7hj4Ov3rIwAAdHIIAIY6NeE9WnmiCDQ3VXBu6sHd\n3bpDpVqDEuEYDuvmc/R98DZee3mpf6FlMDLi5BiFS75Yoxf0ZUlWvCssNpEJNur0\nMN1AUAB9oeJbvfeVHAspJH2L+lsy365ky0O9KJxJx8aLUe96/6BnDHVG/LpUXFoa\nobSs3bnbIcDiunIZ0/gZVwtUNvO7WO7XGmxzk00s4wfq4LPDGkcdzKLRATeFBhAy\nKliK1AoauxesOIFz6K8wZDxHELaSBRYzyayNc0O89/kJaY+HU/59dCrwcgocm3u/\ntQhhCFRVcrW3jv9xVitrS4BxMvS/jkwRIaucjSz/Oe17cLfVp2Vduo/P1WBIZkY=\n=B8x9\n-----END PGP SIGNATURE-----\n", "payload": "tree a8dc5451a4b50b0a62d05c8b03d3a8d5480e7b74\nparent 3ddf48053e83f4949d00dcaf6eb8d9e28fc6bb95\nparent 6da17d244b08e5f14edd1645fbd07d1f042d00b7\nauthor Dylan DPC <dylan.dpc@gmail.com> 1591874153 +0200\ncommitter GitHub <noreply@github.com> 1591874153 +0200\n\nRollup merge of #72380 - lcnr:const_context, r=estebank\n\nFix `is_const_context`, update `check_for_cast`\n\nA better version of #71477\n\nAdds `fn enclosing_body_owner` and uses it in `is_const_context`.\n`is_const_context` now uses the same mechanism as `mir_const_qualif` as it was previously incorrect.\nRenames `is_const_context` to `is_inside_const_context`.\n\nI also updated `check_for_cast` in the second commit, so r? @estebank\n\n(I removed one lvl of indentation, so it might be easier to review by hiding whitespace changes)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "html_url": "https://github.com/rust-lang/rust/commit/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ddf48053e83f4949d00dcaf6eb8d9e28fc6bb95", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ddf48053e83f4949d00dcaf6eb8d9e28fc6bb95", "html_url": "https://github.com/rust-lang/rust/commit/3ddf48053e83f4949d00dcaf6eb8d9e28fc6bb95"}, {"sha": "6da17d244b08e5f14edd1645fbd07d1f042d00b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6da17d244b08e5f14edd1645fbd07d1f042d00b7", "html_url": "https://github.com/rust-lang/rust/commit/6da17d244b08e5f14edd1645fbd07d1f042d00b7"}], "stats": {"total": 473, "additions": 228, "deletions": 245}, "files": [{"sha": "b1dafb3c885858dff5adfca40e4c63d65aebbdf4", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "patch": "@@ -335,6 +335,16 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    pub fn enclosing_body_owner(&self, hir_id: HirId) -> HirId {\n+        for (parent, _) in self.parent_iter(hir_id) {\n+            if let Some(body) = self.maybe_body_owned_by(parent) {\n+                return self.body_owner(body);\n+            }\n+        }\n+\n+        bug!(\"no `enclosing_body_owner` for hir_id `{}`\", hir_id);\n+    }\n+\n     /// Returns the `HirId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n@@ -537,18 +547,8 @@ impl<'hir> Map<'hir> {\n \n     /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n     /// Used exclusively for diagnostics, to avoid suggestion function calls.\n-    pub fn is_const_context(&self, hir_id: HirId) -> bool {\n-        let parent_id = self.get_parent_item(hir_id);\n-        match self.get(parent_id) {\n-            Node::Item(&Item { kind: ItemKind::Const(..) | ItemKind::Static(..), .. })\n-            | Node::TraitItem(&TraitItem { kind: TraitItemKind::Const(..), .. })\n-            | Node::ImplItem(&ImplItem { kind: ImplItemKind::Const(..), .. })\n-            | Node::AnonConst(_) => true,\n-            Node::Item(&Item { kind: ItemKind::Fn(ref sig, ..), .. }) => {\n-                sig.header.constness == Constness::Const\n-            }\n-            _ => false,\n-        }\n+    pub fn is_inside_const_context(&self, hir_id: HirId) -> bool {\n+        self.body_const_context(self.local_def_id(self.enclosing_body_owner(hir_id))).is_some()\n     }\n \n     /// Whether `hir_id` corresponds to a `mod` or a crate."}, {"sha": "4d4b6fb9386db306c018cbc87e544ff000447a2e", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let closure_id = hir.as_local_hir_id(self.mir_def_id);\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n-        let item_id = hir.get_parent_item(fn_call_id);\n+        let item_id = hir.enclosing_body_owner(fn_call_id);\n         let mut look_at_return = true;\n         // If we can detect the expression to be an `fn` call where the closure was an argument,\n         // we point at the `fn` definition argument..."}, {"sha": "7ac886989853f3e84c12e3818d2ba9c6fb3a5b24", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 189, "deletions": 207, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "patch": "@@ -15,6 +15,8 @@ use rustc_span::Span;\n \n use super::method::probe;\n \n+use std::fmt;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n         &self,\n@@ -670,16 +672,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n-            // Shouldn't suggest `.into()` on `const`s.\n-            // FIXME(estebank): modify once we decide to suggest `as` casts\n-            return false;\n-        }\n         if self.tcx.sess.source_map().is_imported(expr.span) {\n             // Ignore if span is from within a macro.\n             return false;\n         }\n \n+        let src = if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+            src\n+        } else {\n+            return false;\n+        };\n+\n         // If casting this expression to a given numeric type would be appropriate in case of a type\n         // mismatch.\n         //\n@@ -708,6 +711,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             String::new()\n         };\n+\n         if let hir::ExprKind::Call(path, args) = &expr.kind {\n             if let (hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)), 1) =\n                 (&path.kind, args.len())\n@@ -749,222 +753,200 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             checked_ty, expected_ty,\n         );\n \n-        let needs_paren = expr.precedence().order() < (PREC_POSTFIX as i8);\n-\n-        if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n-            let cast_suggestion = format!(\n-                \"{}{}{}{} as {}\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-                expected_ty,\n-            );\n-            let try_into_suggestion = format!(\n-                \"{}{}{}{}.try_into().unwrap()\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let into_suggestion = format!(\n-                \"{}{}{}{}.into()\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let suffix_suggestion = format!(\n-                \"{}{}{}{}\",\n-                if needs_paren { \"(\" } else { \"\" },\n-                if let (ty::Int(_) | ty::Uint(_), ty::Float(_)) =\n-                    (&expected_ty.kind, &checked_ty.kind,)\n-                {\n-                    // Remove fractional part from literal, for example `42.0f32` into `42`\n-                    let src = src.trim_end_matches(&checked_ty.to_string());\n-                    src.split('.').next().unwrap()\n+        let with_opt_paren: fn(&dyn fmt::Display) -> String =\n+            if expr.precedence().order() < PREC_POSTFIX {\n+                |s| format!(\"({})\", s)\n+            } else {\n+                |s| s.to_string()\n+            };\n+\n+        let cast_suggestion = format!(\"{}{} as {}\", prefix, with_opt_paren(&src), expected_ty);\n+        let try_into_suggestion = format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n+        let into_suggestion = format!(\"{}{}.into()\", prefix, with_opt_paren(&src));\n+        let suffix_suggestion = with_opt_paren(&format_args!(\n+            \"{}{}\",\n+            if matches!(\n+                (&expected_ty.kind, &checked_ty.kind),\n+                (ty::Int(_) | ty::Uint(_), ty::Float(_))\n+            ) {\n+                // Remove fractional part from literal, for example `42.0f32` into `42`\n+                let src = src.trim_end_matches(&checked_ty.to_string());\n+                src.split('.').next().unwrap()\n+            } else {\n+                src.trim_end_matches(&checked_ty.to_string())\n+            },\n+            expected_ty,\n+        ));\n+        let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n+            if let hir::ExprKind::Lit(lit) = &expr.kind { lit.node.is_suffixed() } else { false }\n+        };\n+\n+        let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);\n+        let suggest_to_change_suffix_or_into =\n+            |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+                let msg = if literal_is_ty_suffixed(expr) {\n+                    &lit_msg\n+                } else if in_const_context {\n+                    // Do not recommend `into` or `try_into` in const contexts.\n+                    return;\n+                } else if is_fallible {\n+                    &try_msg\n                 } else {\n-                    src.trim_end_matches(&checked_ty.to_string())\n-                },\n-                expected_ty,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n-                if let hir::ExprKind::Lit(lit) = &expr.kind {\n-                    lit.node.is_suffixed()\n+                    &msg\n+                };\n+                let suggestion = if literal_is_ty_suffixed(expr) {\n+                    suffix_suggestion.clone()\n+                } else if is_fallible {\n+                    try_into_suggestion\n                 } else {\n-                    false\n-                }\n+                    into_suggestion.clone()\n+                };\n+                err.span_suggestion(expr.span, msg, suggestion, Applicability::MachineApplicable);\n             };\n \n-            let suggest_to_change_suffix_or_into =\n-                |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+        match (&expected_ty.kind, &checked_ty.kind) {\n+            (&ty::Int(ref exp), &ty::Int(ref found)) => {\n+                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n+                    (Some(exp), Some(found)) if exp < found => true,\n+                    (None, Some(8 | 16)) => false,\n+                    (None, _) | (_, None) => true,\n+                    _ => false,\n+                };\n+                suggest_to_change_suffix_or_into(err, is_fallible);\n+                true\n+            }\n+            (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n+                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n+                    (Some(exp), Some(found)) if exp < found => true,\n+                    (None, Some(8 | 16)) => false,\n+                    (None, _) | (_, None) => true,\n+                    _ => false,\n+                };\n+                suggest_to_change_suffix_or_into(err, is_fallible);\n+                true\n+            }\n+            (&ty::Int(exp), &ty::Uint(found)) => {\n+                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n+                    (Some(exp), Some(found)) if found < exp => false,\n+                    (None, Some(8)) => false,\n+                    _ => true,\n+                };\n+                suggest_to_change_suffix_or_into(err, is_fallible);\n+                true\n+            }\n+            (&ty::Uint(_), &ty::Int(_)) => {\n+                suggest_to_change_suffix_or_into(err, true);\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Float(ref found)) => {\n+                if found.bit_width() < exp.bit_width() {\n+                    suggest_to_change_suffix_or_into(err, false);\n+                } else if literal_is_ty_suffixed(expr) {\n                     err.span_suggestion(\n                         expr.span,\n-                        if literal_is_ty_suffixed(expr) {\n-                            &lit_msg\n-                        } else if is_fallible {\n-                            &try_msg\n-                        } else {\n-                            &msg\n-                        },\n-                        if literal_is_ty_suffixed(expr) {\n-                            suffix_suggestion.clone()\n-                        } else if is_fallible {\n-                            try_into_suggestion\n-                        } else {\n-                            into_suggestion.clone()\n-                        },\n+                        &lit_msg,\n+                        suffix_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n-                };\n-\n-            match (&expected_ty.kind, &checked_ty.kind) {\n-                (&ty::Int(ref exp), &ty::Int(ref found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if exp < found => true,\n-                        (None, Some(8 | 16)) => false,\n-                        (None, _) | (_, None) => true,\n-                        _ => false,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if exp < found => true,\n-                        (None, Some(8 | 16)) => false,\n-                        (None, _) | (_, None) => true,\n-                        _ => false,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Int(exp), &ty::Uint(found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if found < exp => false,\n-                        (None, Some(8)) => false,\n-                        _ => true,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Uint(_), &ty::Int(_)) => {\n-                    suggest_to_change_suffix_or_into(err, true);\n-                    true\n-                }\n-                (&ty::Float(ref exp), &ty::Float(ref found)) => {\n-                    if found.bit_width() < exp.bit_width() {\n-                        suggest_to_change_suffix_or_into(err, false);\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if can_cast {\n-                        // Missing try_into implementation for `f64` to `f32`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"{}, producing the closest possible value\", cast_msg),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                } else if can_cast {\n+                    // Missing try_into implementation for `f64` to `f32`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"{}, producing the closest possible value\", cast_msg),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Uint(_) | &ty::Int(_), &ty::Float(_)) => {\n-                    if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if can_cast {\n-                        // Missing try_into implementation for `{float}` to `{integer}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"{}, rounding the float towards zero\", msg),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                true\n+            }\n+            (&ty::Uint(_) | &ty::Int(_), &ty::Float(_)) => {\n+                if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if can_cast {\n+                    // Missing try_into implementation for `{float}` to `{integer}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"{}, rounding the float towards zero\", msg),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n-                    // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n-                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer\",\n-                                msg,\n-                            ),\n-                            into_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        // Missing try_into implementation for `{integer}` to `{float}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer,\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n+                // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n+                if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer\",\n+                            msg,\n+                        ),\n+                        into_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    // Missing try_into implementation for `{integer}` to `{float}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer,\n                                  rounded if necessary\",\n-                                cast_msg,\n-                            ),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                            cast_msg,\n+                        ),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Float(ref exp), &ty::Int(ref found)) => {\n-                    // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n-                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer\",\n-                                &msg,\n-                            ),\n-                            into_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        // Missing try_into implementation for `{integer}` to `{float}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer, \\\n-                                 rounded if necessary\",\n-                                &msg,\n-                            ),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Int(ref found)) => {\n+                // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n+                if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer\",\n+                            &msg,\n+                        ),\n+                        into_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    // Missing try_into implementation for `{integer}` to `{float}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer, \\\n+                                rounded if necessary\",\n+                            &msg,\n+                        ),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                _ => false,\n+                true\n             }\n-        } else {\n-            false\n+            _ => false,\n         }\n     }\n }"}, {"sha": "18846813c458fcf2deb97cc9f9c50f6e444e9b75", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "patch": "@@ -5091,7 +5091,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n             // Do not suggest `Box::new` in const context.\n             return;\n         }\n@@ -5128,7 +5128,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> bool {\n         // Handle #68197.\n \n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n             // Do not suggest `Box::new` in const context.\n             return false;\n         }"}, {"sha": "9834a99b79a0e019527cbe34c9aab39a3abeb477", "filename": "src/test/ui/consts/enum-discr-type-err.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr?ref=298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "patch": "@@ -11,10 +11,6 @@ LL | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n-   |\n-LL |             $( $v = $s::V.try_into().unwrap(), )*\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/enum-discr-type-err.rs:18:21\n@@ -29,10 +25,6 @@ LL | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n-   |\n-LL |             $( $v = $s::V.try_into().unwrap(), )*\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2603c944207d0ce6f83221725b85a6e9ca08d790", "filename": "src/test/ui/issues/issue-31910.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Fissues%2Fissue-31910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Fissues%2Fissue-31910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31910.stderr?ref=298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "patch": "@@ -3,11 +3,6 @@ error[E0308]: mismatched types\n    |\n LL |     X = Trait::Number,\n    |         ^^^^^^^^^^^^^ expected `isize`, found `i32`\n-   |\n-help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n-   |\n-LL |     X = Trait::Number.try_into().unwrap(),\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d7f18e19b41bd417282ab314dadbc43a7a29fa0a", "filename": "src/test/ui/numeric/const-scope.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr?ref=298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "patch": "@@ -3,6 +3,11 @@ error[E0308]: mismatched types\n    |\n LL | const C: i32 = 1i8;\n    |                ^^^ expected `i32`, found `i8`\n+   |\n+help: change the type of the numeric literal from `i8` to `i32`\n+   |\n+LL | const C: i32 = 1i32;\n+   |                ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/const-scope.rs:2:15\n@@ -17,6 +22,11 @@ LL |     let c: i32 = 1i8;\n    |            ---   ^^^ expected `i32`, found `i8`\n    |            |\n    |            expected due to this\n+   |\n+help: change the type of the numeric literal from `i8` to `i32`\n+   |\n+LL |     let c: i32 = 1i32;\n+   |                  ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/const-scope.rs:6:17"}, {"sha": "7e30491f0bdbcdddc62a1b8b0e33f995df3ca32e", "filename": "src/test/ui/repeat_count.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.rs?ref=298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "patch": "@@ -22,6 +22,9 @@ fn main() {\n     let f = [0_usize; -1_isize];\n     //~^ ERROR mismatched types\n     //~| expected `usize`, found `isize`\n+    let f = [0; 4u8];\n+    //~^ ERROR mismatched types\n+    //~| expected `usize`, found `u8`\n     struct G {\n         g: (),\n     }"}, {"sha": "6a081e23d9d375f6dfe51cbada2b04e0275f1398", "filename": "src/test/ui/repeat_count.stderr", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Frepeat_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298467ee9a7fa1bbc93383c3a67ea569a6e7c22c/src%2Ftest%2Fui%2Frepeat_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.stderr?ref=298467ee9a7fa1bbc93383c3a67ea569a6e7c22c", "patch": "@@ -29,7 +29,7 @@ LL |     let e = [0; \"foo\"];\n    |                 ^^^^^ expected `usize`, found `&str`\n \n error[E0308]: mismatched types\n-  --> $DIR/repeat_count.rs:28:17\n+  --> $DIR/repeat_count.rs:31:17\n    |\n LL |     let g = [0; G { g: () }];\n    |                 ^^^^^^^^^^^ expected `usize`, found struct `main::G`\n@@ -39,24 +39,25 @@ error[E0308]: mismatched types\n    |\n LL |     let f = [0; -4_isize];\n    |                 ^^^^^^^^ expected `usize`, found `isize`\n-   |\n-help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n-   |\n-LL |     let f = [0; (-4_isize).try_into().unwrap()];\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/repeat_count.rs:22:23\n    |\n LL |     let f = [0_usize; -1_isize];\n    |                       ^^^^^^^^ expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/repeat_count.rs:25:17\n+   |\n+LL |     let f = [0; 4u8];\n+   |                 ^^^ expected `usize`, found `u8`\n    |\n-help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n+help: change the type of the numeric literal from `u8` to `usize`\n    |\n-LL |     let f = [0_usize; (-1_isize).try_into().unwrap()];\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let f = [0; 4usize];\n+   |                 ^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0308, E0435.\n For more information about an error, try `rustc --explain E0308`."}]}