{"sha": "c07955c6b6a8901fc59d9c22004127b30a965407", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNzk1NWM2YjZhODkwMWZjNTlkOWMyMjAwNDEyN2IzMGE5NjU0MDc=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2021-03-17T23:02:07Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2021-03-17T23:02:07Z"}, "message": "Fix overflowing length in Vec<ZST> to VecDeque\n\n`Vec` can hold up to `usize::MAX` ZST items, but `VecDeque` has a lower\nlimit to keep its raw capacity as a power of two, so we should check\nthat in `From<Vec<T>> for VecDeque<T>`. We can also simplify the\ncapacity check for the remaining non-ZST case.\n\nBefore this fix, the new test would fail on the length:\n\n```\nthread 'collections::vec_deque::tests::test_from_vec_zst_overflow' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `9223372036854775808`', library/alloc/src/collections/vec_deque/tests.rs:474:5\nnote: panic did not contain expected string\n      panic message: `\"assertion failed: `(left == right)`\\n  left: `0`,\\n right: `9223372036854775808`\"`,\n expected substring: `\"capacity overflow\"`\n```\n\nThat was a result of `len()` using a mask `& (size - 1)` with the\nimproper length. Now we do get a \"capacity overflow\" panic as soon as\nthat `VecDeque::from(vec)` is attempted.", "tree": {"sha": "12e13596da3f43fe7839b9209e4a1eb5baecd3ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12e13596da3f43fe7839b9209e4a1eb5baecd3ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c07955c6b6a8901fc59d9c22004127b30a965407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c07955c6b6a8901fc59d9c22004127b30a965407", "html_url": "https://github.com/rust-lang/rust/commit/c07955c6b6a8901fc59d9c22004127b30a965407", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c07955c6b6a8901fc59d9c22004127b30a965407/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04ae50179a802d1d18bb780baa85f55864f56616", "url": "https://api.github.com/repos/rust-lang/rust/commits/04ae50179a802d1d18bb780baa85f55864f56616", "html_url": "https://github.com/rust-lang/rust/commit/04ae50179a802d1d18bb780baa85f55864f56616"}], "stats": {"total": 52, "additions": 33, "deletions": 19}, "files": [{"sha": "7a0de74eb239d8b4261a9bca23647a208da507f7", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c07955c6b6a8901fc59d9c22004127b30a965407/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07955c6b6a8901fc59d9c22004127b30a965407/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=c07955c6b6a8901fc59d9c22004127b30a965407", "patch": "@@ -2783,27 +2783,26 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n     /// This avoids reallocating where possible, but the conditions for that are\n     /// strict, and subject to change, and so shouldn't be relied upon unless the\n     /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n-    fn from(other: Vec<T>) -> Self {\n-        unsafe {\n-            let mut other = ManuallyDrop::new(other);\n-            let other_buf = other.as_mut_ptr();\n-            let mut buf = RawVec::from_raw_parts(other_buf, other.capacity());\n-            let len = other.len();\n-\n-            // We need to extend the buf if it's not a power of two, too small\n-            // or doesn't have at least one free space.\n-            // We check if `T` is a ZST in the first condition,\n-            // because `usize::MAX` (the capacity returned by `capacity()` for ZST)\n-            // is not a power of two and thus it'll always try\n-            // to reserve more memory which will panic for ZST (rust-lang/rust#78532)\n-            if (!buf.capacity().is_power_of_two() && mem::size_of::<T>() != 0)\n-                || (buf.capacity() < (MINIMUM_CAPACITY + 1))\n-                || (buf.capacity() == len)\n-            {\n-                let cap = cmp::max(buf.capacity() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n-                buf.reserve_exact(len, cap - len);\n+    fn from(mut other: Vec<T>) -> Self {\n+        let len = other.len();\n+        if mem::size_of::<T>() == 0 {\n+            // There's no actual allocation for ZSTs to worry about capacity,\n+            // but `VecDeque` can't handle as much length as `Vec`.\n+            assert!(len < MAXIMUM_ZST_CAPACITY, \"capacity overflow\");\n+        } else {\n+            // We need to resize if the capacity is not a power of two, too small or\n+            // doesn't have at least one free space. We do this while it's still in\n+            // the `Vec` so the items will drop on panic.\n+            let min_cap = cmp::max(MINIMUM_CAPACITY, len) + 1;\n+            let cap = cmp::max(min_cap, other.capacity()).next_power_of_two();\n+            if other.capacity() != cap {\n+                other.reserve_exact(cap - len);\n             }\n+        }\n \n+        unsafe {\n+            let (other_buf, len, capacity) = other.into_raw_parts();\n+            let buf = RawVec::from_raw_parts(other_buf, capacity);\n             VecDeque { tail: 0, head: len, buf }\n         }\n     }"}, {"sha": "6116cfe1d0110bdd33e0087e712a100ce5a066e7", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c07955c6b6a8901fc59d9c22004127b30a965407/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07955c6b6a8901fc59d9c22004127b30a965407/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=c07955c6b6a8901fc59d9c22004127b30a965407", "patch": "@@ -457,6 +457,21 @@ fn test_from_vec() {\n             assert!(vd.into_iter().eq(vec));\n         }\n     }\n+\n+    let vec = Vec::from([(); MAXIMUM_ZST_CAPACITY - 1]);\n+    let vd = VecDeque::from(vec.clone());\n+    assert!(vd.cap().is_power_of_two());\n+    assert_eq!(vd.len(), vec.len());\n+}\n+\n+#[test]\n+#[should_panic = \"capacity overflow\"]\n+fn test_from_vec_zst_overflow() {\n+    use crate::vec::Vec;\n+    let vec = Vec::from([(); MAXIMUM_ZST_CAPACITY]);\n+    let vd = VecDeque::from(vec.clone()); // no room for +1\n+    assert!(vd.cap().is_power_of_two());\n+    assert_eq!(vd.len(), vec.len());\n }\n \n #[test]"}]}