{"sha": "b8ef5cf1310a7b1e31d0993885d867a6804597ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZWY1Y2YxMzEwYTdiMWUzMWQwOTkzODg1ZDg2N2E2ODA0NTk3YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T19:56:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T19:56:39Z"}, "message": "auto merge of #15225 : Ryman/rust/liburl_minor, r=alexcrichton\n\nSee commits for info, a number of these are 'breaking', although liburl is marked experimental so I'm not sure that matters so much.\r\n\r\nFirst two commits will be impacted if #15138 is adopted, but it's a simple rename.", "tree": {"sha": "2762f2692a75a4f1f40a30eedb9df3aa2de63241", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2762f2692a75a4f1f40a30eedb9df3aa2de63241"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8ef5cf1310a7b1e31d0993885d867a6804597ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8ef5cf1310a7b1e31d0993885d867a6804597ad", "html_url": "https://github.com/rust-lang/rust/commit/b8ef5cf1310a7b1e31d0993885d867a6804597ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8ef5cf1310a7b1e31d0993885d867a6804597ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8b2a3167b068f7ea30eebcfa7ad13d4c7ea3026", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8b2a3167b068f7ea30eebcfa7ad13d4c7ea3026", "html_url": "https://github.com/rust-lang/rust/commit/c8b2a3167b068f7ea30eebcfa7ad13d4c7ea3026"}, {"sha": "4703bb4eaa157ede1885bbfdb8839d749d2d8108", "url": "https://api.github.com/repos/rust-lang/rust/commits/4703bb4eaa157ede1885bbfdb8839d749d2d8108", "html_url": "https://github.com/rust-lang/rust/commit/4703bb4eaa157ede1885bbfdb8839d749d2d8108"}], "stats": {"total": 1315, "additions": 622, "deletions": 693}, "files": [{"sha": "c1adc5d84e6966d30b1acaeaf256254494533dfa", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 622, "deletions": 693, "changes": 1315, "blob_url": "https://github.com/rust-lang/rust/blob/b8ef5cf1310a7b1e31d0993885d867a6804597ad/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8ef5cf1310a7b1e31d0993885d867a6804597ad/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=b8ef5cf1310a7b1e31d0993885d867a6804597ad", "patch": "@@ -25,9 +25,8 @@ use std::collections::HashMap;\n use std::fmt;\n use std::from_str::FromStr;\n use std::hash;\n-use std::io::BufReader;\n-use std::string::String;\n use std::uint;\n+use std::path::BytesContainer;\n \n /// A Uniform Resource Locator (URL).  A URL is a form of URI (Uniform Resource\n /// Identifier) that includes network location information, such as hostname or\n@@ -36,16 +35,13 @@ use std::uint;\n /// # Example\n ///\n /// ```rust\n-/// use url::{Url, UserInfo};\n+/// use url::Url;\n ///\n-/// let url = Url { scheme: \"https\".to_string(),\n-///                 user: Some(UserInfo { user: \"username\".to_string(), pass: None }),\n-///                 host: \"example.com\".to_string(),\n-///                 port: Some(\"8080\".to_string()),\n-///                 path: \"/foo/bar\".to_string(),\n-///                 query: vec!((\"baz\".to_string(), \"qux\".to_string())),\n-///                 fragment: Some(\"quz\".to_string()) };\n-/// // https://username@example.com:8080/foo/bar?baz=qux#quz\n+/// let raw = \"https://username@example.com:8080/foo/bar?baz=qux#quz\";\n+/// match Url::parse(raw) {\n+///     Ok(u) => println!(\"Parsed '{}'\", u),\n+///     Err(e) => println!(\"Couldn't parse '{}': {}\", raw, e),\n+/// }\n /// ```\n #[deriving(Clone, PartialEq, Eq)]\n pub struct Url {\n@@ -56,26 +52,20 @@ pub struct Url {\n     /// A domain name or IP address.  For example, `example.com`.\n     pub host: String,\n     /// A TCP port number, for example `8080`.\n-    pub port: Option<String>,\n-    /// The path component of a URL, for example `/foo/bar`.\n-    pub path: String,\n-    /// The query component of a URL.\n-    /// `vec!((\"baz\".to_string(), \"qux\".to_string()))` represents the fragment\n-    /// `baz=qux` in the above example.\n-    pub query: Query,\n-    /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n-    pub fragment: Option<String>\n+    pub port: Option<u16>,\n+    /// The path component of a URL, for example `/foo/bar?baz=qux#quz`.\n+    pub path: Path,\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Eq)]\n pub struct Path {\n     /// The path component of a URL, for example `/foo/bar`.\n     pub path: String,\n     /// The query component of a URL.\n-    /// `vec!((\"baz\".to_string(), \"qux\".to_string()))` represents the fragment\n+    /// `vec![(\"baz\".to_string(), \"qux\".to_string())]` represents the fragment\n     /// `baz=qux` in the above example.\n     pub query: Query,\n-    /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n+    /// The fragment component, such as `quz`. Not including the leading `#` character.\n     pub fragment: Option<String>\n }\n \n@@ -95,7 +85,7 @@ impl Url {\n     pub fn new(scheme: String,\n                user: Option<UserInfo>,\n                host: String,\n-               port: Option<String>,\n+               port: Option<u16>,\n                path: String,\n                query: Query,\n                fragment: Option<String>)\n@@ -105,11 +95,48 @@ impl Url {\n             user: user,\n             host: host,\n             port: port,\n-            path: path,\n-            query: query,\n-            fragment: fragment,\n+            path: Path::new(path, query, fragment)\n         }\n     }\n+\n+    /// Parses a URL, converting it from a string to a `Url` representation.\n+    ///\n+    /// # Arguments\n+    /// * rawurl - a string representing the full URL, including scheme.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Err(e)` if the string did not represent a valid URL, where `e` is a\n+    /// `String` error message. Otherwise, `Ok(u)` where `u` is a `Url` struct\n+    /// representing the URL.\n+    pub fn parse(rawurl: &str) -> DecodeResult<Url> {\n+        // scheme\n+        let (scheme, rest) = try!(get_scheme(rawurl));\n+\n+        // authority\n+        let (userinfo, host, port, rest) = try!(get_authority(rest));\n+\n+        // path\n+        let has_authority = host.len() > 0;\n+        let (path, rest) = try!(get_path(rest, has_authority));\n+\n+        // query and fragment\n+        let (query, fragment) = try!(get_query_fragment(rest));\n+\n+        let url = Url::new(scheme.to_string(),\n+                            userinfo,\n+                            host.to_string(),\n+                            port,\n+                            path,\n+                            query,\n+                            fragment);\n+        Ok(url)\n+    }\n+}\n+\n+#[deprecated=\"use `Url::parse`\"]\n+pub fn from_str(s: &str) -> Result<Url, String> {\n+    Url::parse(s)\n }\n \n impl Path {\n@@ -123,6 +150,30 @@ impl Path {\n             fragment: fragment,\n         }\n     }\n+\n+    /// Parses a URL path, converting it from a string to a `Path` representation.\n+    ///\n+    /// # Arguments\n+    /// * rawpath - a string representing the path component of a URL.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Err(e)` if the string did not represent a valid URL path, where `e` is a\n+    /// `String` error message. Otherwise, `Ok(p)` where `p` is a `Path` struct\n+    /// representing the URL path.\n+    pub fn parse(rawpath: &str) -> DecodeResult<Path> {\n+        let (path, rest) = try!(get_path(rawpath, false));\n+\n+        // query and fragment\n+        let (query, fragment) = try!(get_query_fragment(rest.as_slice()));\n+\n+        Ok(Path{ path: path, query: query, fragment: fragment })\n+    }\n+}\n+\n+#[deprecated=\"use `Path::parse`\"]\n+pub fn path_from_str(s: &str) -> Result<Path, String> {\n+    Path::parse(s)\n }\n \n impl UserInfo {\n@@ -132,294 +183,221 @@ impl UserInfo {\n     }\n }\n \n-fn encode_inner(s: &str, full_url: bool) -> String {\n-    let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = String::new();\n-\n-    loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Err(..) => break,\n-            Ok(..) => buf[0] as char,\n+fn encode_inner<T: BytesContainer>(c: T, full_url: bool) -> String {\n+    c.container_as_bytes().iter().fold(String::new(), |mut out, &b| {\n+        match b as char {\n+            // unreserved:\n+            'A' .. 'Z'\n+            | 'a' .. 'z'\n+            | '0' .. '9'\n+            | '-' | '.' | '_' | '~' => out.push_char(b as char),\n+\n+            // gen-delims:\n+            ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+            // sub-delims:\n+            '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+            '+' | ',' | ';' | '='\n+                if full_url => out.push_char(b as char),\n+\n+            ch => out.push_str(format!(\"%{:02X}\", ch as uint).as_slice()),\n         };\n \n-        match ch {\n-          // unreserved:\n-          'A' .. 'Z' |\n-          'a' .. 'z' |\n-          '0' .. '9' |\n-          '-' | '.' | '_' | '~' => {\n-            out.push_char(ch);\n-          }\n-          _ => {\n-              if full_url {\n-                match ch {\n-                  // gen-delims:\n-                  ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                  // sub-delims:\n-                  '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                  '+' | ',' | ';' | '=' => {\n-                    out.push_char(ch);\n-                  }\n-\n-                  _ => out.push_str(format!(\"%{:02X}\", ch as uint).as_slice())\n-                }\n-            } else {\n-                out.push_str(format!(\"%{:02X}\", ch as uint).as_slice());\n-            }\n-          }\n-        }\n-    }\n-\n-    out\n+        out\n+    })\n }\n \n-/**\n- * Encodes a URI by replacing reserved characters with percent-encoded\n- * character sequences.\n- *\n- * This function is compliant with RFC 3986.\n- *\n- * # Example\n- *\n- * ```rust\n- * use url::encode;\n- *\n- * let url = encode(\"https://example.com/Rust (programming language)\");\n- * println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n- * ```\n- */\n-pub fn encode(s: &str) -> String {\n-    encode_inner(s, true)\n+/// Encodes a URI by replacing reserved characters with percent-encoded\n+/// character sequences.\n+///\n+/// This function is compliant with RFC 3986.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use url::encode;\n+///\n+/// let url = encode(\"https://example.com/Rust (programming language)\");\n+/// println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n+/// ```\n+pub fn encode<T: BytesContainer>(container: T) -> String {\n+    encode_inner(container, true)\n }\n \n-/**\n- * Encodes a URI component by replacing reserved characters with percent-\n- * encoded character sequences.\n- *\n- * This function is compliant with RFC 3986.\n- */\n \n-pub fn encode_component(s: &str) -> String {\n-    encode_inner(s, false)\n+/// Encodes a URI component by replacing reserved characters with percent-\n+/// encoded character sequences.\n+///\n+/// This function is compliant with RFC 3986.\n+pub fn encode_component<T: BytesContainer>(container: T) -> String {\n+    encode_inner(container, false)\n }\n \n-fn decode_inner(s: &str, full_url: bool) -> String {\n-    let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = String::new();\n+pub type DecodeResult<T> = Result<T, String>;\n \n-    loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Err(..) => break,\n-            Ok(..) => buf[0] as char\n-        };\n-        match ch {\n-          '%' => {\n-            let mut bytes = [0, 0];\n-            match rdr.read(bytes) {\n-                Ok(2) => {}\n-                _ => fail!() // FIXME: malformed url?\n-            }\n-            let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n-\n-            if full_url {\n-                // Only decode some characters:\n-                match ch {\n-                  // gen-delims:\n-                  ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                  // sub-delims:\n-                  '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                  '+' | ',' | ';' | '=' => {\n-                    out.push_char('%');\n-                    out.push_char(bytes[0u] as char);\n-                    out.push_char(bytes[1u] as char);\n-                  }\n-\n-                  ch => out.push_char(ch)\n-                }\n-            } else {\n-                  out.push_char(ch);\n-            }\n-          }\n-          ch => out.push_char(ch)\n-        }\n-    }\n-\n-    out\n-}\n-\n-/**\n- * Decodes a percent-encoded string representing a URI.\n- *\n- * This will only decode escape sequences generated by `encode`.\n- *\n- * # Example\n- *\n- * ```rust\n- * use url::decode;\n- *\n- * let url = decode(\"https://example.com/Rust%20(programming%20language)\");\n- * println!(\"{}\", url); // https://example.com/Rust (programming language)\n- * ```\n- */\n-pub fn decode(s: &str) -> String {\n-    decode_inner(s, true)\n+/// Decodes a percent-encoded string representing a URI.\n+///\n+/// This will only decode escape sequences generated by `encode`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use url::decode;\n+///\n+/// let url = decode(\"https://example.com/Rust%20(programming%20language)\");\n+/// println!(\"{}\", url); // https://example.com/Rust (programming language)\n+/// ```\n+pub fn decode<T: BytesContainer>(container: T) -> DecodeResult<String> {\n+    decode_inner(container, true)\n }\n \n-/**\n- * Decode a string encoded with percent encoding.\n- */\n-pub fn decode_component(s: &str) -> String {\n-    decode_inner(s, false)\n+/// Decode a string encoded with percent encoding.\n+pub fn decode_component<T: BytesContainer>(container: T) -> DecodeResult<String> {\n+    decode_inner(container, false)\n }\n \n-fn encode_plus(s: &str) -> String {\n-    let mut rdr = BufReader::new(s.as_bytes());\n+fn decode_inner<T: BytesContainer>(c: T, full_url: bool) -> DecodeResult<String> {\n     let mut out = String::new();\n+    let mut iter = c.container_as_bytes().iter().map(|&b| b);\n \n     loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Ok(..) => buf[0] as char,\n-            Err(..) => break,\n-        };\n-        match ch {\n-          'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n-            out.push_char(ch);\n-          }\n-          ' ' => out.push_char('+'),\n-          _ => out.push_str(format!(\"%{:X}\", ch as uint).as_slice())\n+        match iter.next() {\n+            Some(b) => match b as char {\n+                '%' => {\n+                    let bytes = match (iter.next(), iter.next()) {\n+                        (Some(one), Some(two)) => [one as u8, two as u8],\n+                        _ => return Err(format!(\"Malformed input: found '%' \\\n+                                                without two trailing bytes\")),\n+                    };\n+\n+                    // Only decode some characters if full_url:\n+                    match uint::parse_bytes(bytes, 16u).unwrap() as u8 as char {\n+                        // gen-delims:\n+                        ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                        // sub-delims:\n+                        '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                        '+' | ',' | ';' | '='\n+                            if full_url => {\n+                            out.push_char('%');\n+                            out.push_char(bytes[0u] as char);\n+                            out.push_char(bytes[1u] as char);\n+                        }\n+\n+                        ch => out.push_char(ch)\n+                    }\n+                }\n+                ch => out.push_char(ch)\n+            },\n+            None => return Ok(out),\n         }\n     }\n-\n-    out\n }\n \n-/**\n- * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n- */\n+/// Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n pub fn encode_form_urlencoded(m: &HashMap<String, Vec<String>>) -> String {\n-    let mut out = String::new();\n-    let mut first = true;\n+    fn encode_plus<T: Str>(s: &T) -> String {\n+        s.as_slice().bytes().fold(String::new(), |mut out, b| {\n+            match b as char {\n+              'A' .. 'Z'\n+              | 'a' .. 'z'\n+              | '0' .. '9'\n+              | '_' | '.' | '-' => out.push_char(b as char),\n+              ' ' => out.push_char('+'),\n+              ch => out.push_str(format!(\"%{:X}\", ch as uint).as_slice())\n+            }\n+\n+            out\n+        })\n+    }\n \n-    for (key, values) in m.iter() {\n-        let key = encode_plus(key.as_slice());\n+    let mut first = true;\n+    m.iter().fold(String::new(), |mut out, (key, values)| {\n+        let key = encode_plus(key);\n \n         for value in values.iter() {\n             if first {\n                 first = false;\n             } else {\n                 out.push_char('&');\n-                first = false;\n             }\n \n-            out.push_str(format!(\"{}={}\",\n-                                 key,\n-                                 encode_plus(value.as_slice())).as_slice());\n+            out.push_str(key.as_slice());\n+            out.push_char('=');\n+            out.push_str(encode_plus(value).as_slice());\n         }\n-    }\n \n-    out\n+        out\n+    })\n }\n \n-/**\n- * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n- * type into a hashmap.\n- */\n-#[allow(experimental)]\n-pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<String, Vec<String>> {\n-    let mut rdr = BufReader::new(s);\n-    let mut m: HashMap<String,Vec<String>> = HashMap::new();\n+/// Decode a string encoded with the 'application/x-www-form-urlencoded' media\n+/// type into a hashmap.\n+pub fn decode_form_urlencoded(s: &[u8])\n+                            -> DecodeResult<HashMap<String, Vec<String>>> {\n+    fn maybe_push_value(map: &mut HashMap<String, Vec<String>>,\n+                        key: String,\n+                        value: String) {\n+        if key.len() > 0 && value.len() > 0 {\n+            let values = map.find_or_insert_with(key, |_| vec!());\n+            values.push(value);\n+        }\n+    }\n+\n+    let mut out = HashMap::new();\n+    let mut iter = s.iter().map(|&x| x);\n+\n     let mut key = String::new();\n     let mut value = String::new();\n     let mut parsing_key = true;\n \n     loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Ok(..) => buf[0] as char,\n-            Err(..) => break,\n-        };\n-        match ch {\n-            '&' | ';' => {\n-                if key.len() > 0 && value.len() > 0 {\n-                    let mut values = match m.pop_equiv(&key.as_slice()) {\n-                        Some(values) => values,\n-                        None => vec!(),\n-                    };\n-\n-                    values.push(value);\n-                    m.insert(key, values);\n+        match iter.next() {\n+            Some(b) => match b as char {\n+                '&' | ';' => {\n+                    maybe_push_value(&mut out, key, value);\n+\n+                    parsing_key = true;\n+                    key = String::new();\n+                    value = String::new();\n                 }\n-\n-                parsing_key = true;\n-                key = String::new();\n-                value = String::new();\n-            }\n-            '=' => parsing_key = false,\n-            ch => {\n-                let ch = match ch {\n-                    '%' => {\n-                        let mut bytes = [0, 0];\n-                        match rdr.read(bytes) {\n-                            Ok(2) => {}\n-                            _ => fail!() // FIXME: malformed?\n+                '=' => parsing_key = false,\n+                ch => {\n+                    let ch = match ch {\n+                        '%' => {\n+                            let bytes = match (iter.next(), iter.next()) {\n+                                (Some(one), Some(two)) => [one as u8, two as u8],\n+                                _ => return Err(format!(\"Malformed input: found \\\n+                                                '%' without two trailing bytes\"))\n+                            };\n+\n+                            uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n                         }\n-                        uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n-                    }\n-                    '+' => ' ',\n-                    ch => ch\n-                };\n+                        '+' => ' ',\n+                        ch => ch\n+                    };\n \n-                if parsing_key {\n-                    key.push_char(ch)\n-                } else {\n-                    value.push_char(ch)\n+                    if parsing_key {\n+                        key.push_char(ch)\n+                    } else {\n+                        value.push_char(ch)\n+                    }\n                 }\n+            },\n+            None => {\n+                maybe_push_value(&mut out, key, value);\n+                return Ok(out)\n             }\n         }\n     }\n-\n-    if key.len() > 0 && value.len() > 0 {\n-        let mut values = match m.pop_equiv(&key.as_slice()) {\n-            Some(values) => values,\n-            None => vec!(),\n-        };\n-\n-        values.push(value);\n-        m.insert(key, values);\n-    }\n-\n-    m\n }\n \n+fn split_char_first<'a>(s: &'a str, c: char) -> (&'a str, &'a str) {\n+    let mut iter = s.splitn(c, 1);\n \n-fn split_char_first(s: &str, c: char) -> (String, String) {\n-    let len = s.len();\n-    let mut index = len;\n-    let mut mat = 0;\n-    let mut rdr = BufReader::new(s.as_bytes());\n-    loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Ok(..) => buf[0] as char,\n-            Err(..) => break,\n-        };\n-        if ch == c {\n-            // found a match, adjust markers\n-            index = (rdr.tell().unwrap() as uint) - 1;\n-            mat = 1;\n-            break;\n-        }\n-    }\n-    if index+mat == len {\n-        return (s.slice(0, index).to_string(), \"\".to_string());\n-    } else {\n-        return (s.slice(0, index).to_string(),\n-                s.slice(index + mat, s.len()).to_string());\n+    match (iter.next(), iter.next()) {\n+        (Some(a), Some(b)) => (a, b),\n+        (Some(a), None) => (a, \"\"),\n+        (None, _) => unreachable!(),\n     }\n }\n \n@@ -432,103 +410,86 @@ impl fmt::Show for UserInfo {\n     }\n }\n \n-fn query_from_str(rawquery: &str) -> Query {\n+fn query_from_str(rawquery: &str) -> DecodeResult<Query> {\n     let mut query: Query = vec!();\n     if !rawquery.is_empty() {\n         for p in rawquery.split('&') {\n             let (k, v) = split_char_first(p, '=');\n-            query.push((decode_component(k.as_slice()),\n-                        decode_component(v.as_slice())));\n-        };\n+            query.push((try!(decode_component(k)),\n+                        try!(decode_component(v))));\n+        }\n     }\n-    return query;\n+\n+    Ok(query)\n }\n \n-/**\n- * Converts an instance of a URI `Query` type to a string.\n- *\n- * # Example\n- *\n- * ```rust\n- * let query = vec!((\"title\".to_string(), \"The Village\".to_string()),\n- *                  (\"north\".to_string(), \"52.91\".to_string()),\n- *                  (\"west\".to_string(), \"4.10\".to_string()));\n- * println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n- * ```\n- */\n-#[allow(unused_must_use)]\n+/// Converts an instance of a URI `Query` type to a string.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// let query = vec![(\"title\".to_string(), \"The Village\".to_string()),\n+///                  (\"north\".to_string(), \"52.91\".to_string()),\n+///                  (\"west\".to_string(), \"4.10\".to_string())];\n+/// println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n+/// ```\n pub fn query_to_str(query: &Query) -> String {\n-    use std::io::MemWriter;\n-    use std::str;\n-\n-    let mut writer = MemWriter::new();\n-    for (i, &(ref k, ref v)) in query.iter().enumerate() {\n-        if i != 0 { write!(&mut writer, \"&\"); }\n-        write!(&mut writer, \"{}={}\", encode_component(k.as_slice()),\n-               encode_component(v.as_slice()));\n-    }\n-    str::from_utf8_lossy(writer.unwrap().as_slice()).to_string()\n+    query.iter().enumerate().fold(String::new(), |mut out, (i, &(ref k, ref v))| {\n+        if i != 0 {\n+            out.push_char('&');\n+        }\n+\n+        out.push_str(encode_component(k.as_slice()).as_slice());\n+        out.push_char('=');\n+        out.push_str(encode_component(v.as_slice()).as_slice());\n+        out\n+    })\n }\n \n-/**\n- * Returns a tuple of the URI scheme and the rest of the URI, or a parsing error.\n- *\n- * Does not include the separating `:` character.\n- *\n- * # Example\n- *\n- * ```rust\n- * use url::get_scheme;\n- *\n- * let scheme = match get_scheme(\"https://example.com/\") {\n- *     Ok((sch, _)) => sch,\n- *     Err(_) => \"(None)\".to_string(),\n- * };\n- * println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n- * ```\n- */\n-pub fn get_scheme(rawurl: &str) -> Result<(String, String), String> {\n+/// Returns a tuple of the URI scheme and the rest of the URI, or a parsing error.\n+///\n+/// Does not include the separating `:` character.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use url::get_scheme;\n+///\n+/// let scheme = match get_scheme(\"https://example.com/\") {\n+///     Ok((sch, _)) => sch,\n+///     Err(_) => \"(None)\",\n+/// };\n+/// println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n+/// ```\n+pub fn get_scheme<'a>(rawurl: &'a str) -> DecodeResult<(&'a str, &'a str)> {\n     for (i,c) in rawurl.chars().enumerate() {\n-        match c {\n-          'A' .. 'Z' | 'a' .. 'z' => continue,\n-          '0' .. '9' | '+' | '-' | '.' => {\n-            if i == 0 {\n-                return Err(\"url: Scheme must begin with a \\\n-                            letter.\".to_string());\n+        let result = match c {\n+            'A' .. 'Z'\n+            | 'a' .. 'z' => continue,\n+            '0' .. '9' | '+' | '-' | '.' => {\n+                if i != 0 { continue }\n+\n+                Err(\"url: Scheme must begin with a letter.\".to_string())\n             }\n-            continue;\n-          }\n-          ':' => {\n-            if i == 0 {\n-                return Err(\"url: Scheme cannot be empty.\".to_string());\n-            } else {\n-                return Ok((rawurl.slice(0,i).to_string(),\n-                           rawurl.slice(i+1,rawurl.len()).to_string()));\n+            ':' => {\n+                if i == 0 {\n+                    Err(\"url: Scheme cannot be empty.\".to_string())\n+                } else {\n+                    Ok((rawurl.slice(0,i), rawurl.slice(i+1,rawurl.len())))\n+                }\n             }\n-          }\n-          _ => {\n-            return Err(\"url: Invalid character in scheme.\".to_string());\n-          }\n-        }\n-    };\n-    return Err(\"url: Scheme must be terminated with a colon.\".to_string());\n-}\n+            _ => Err(\"url: Invalid character in scheme.\".to_string()),\n+        };\n \n-#[deriving(Clone, PartialEq)]\n-enum Input {\n-    Digit, // all digits\n-    Hex, // digits and letters a-f\n-    Unreserved // all other legal characters\n+        return result;\n+    }\n+\n+    Err(\"url: Scheme must be terminated with a colon.\".to_string())\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n-fn get_authority(rawurl: &str) ->\n-    Result<(Option<UserInfo>, String, Option<String>, String), String> {\n-    if !rawurl.starts_with(\"//\") {\n-        // there is no authority.\n-        return Ok((None, \"\".to_string(), None, rawurl.to_str()));\n-    }\n-\n+fn get_authority<'a>(rawurl: &'a str) ->\n+    DecodeResult<(Option<UserInfo>, &'a str, Option<u16>, &'a str)> {\n     enum State {\n         Start, // starting state\n         PassHostPort, // could be in user or port\n@@ -538,40 +499,52 @@ fn get_authority(rawurl: &str) ->\n         InPort // are in port\n     }\n \n+    #[deriving(Clone, PartialEq)]\n+    enum Input {\n+        Digit, // all digits\n+        Hex, // digits and letters a-f\n+        Unreserved // all other legal characters\n+    }\n+\n+    if !rawurl.starts_with(\"//\") {\n+        // there is no authority.\n+        return Ok((None, \"\", None, rawurl));\n+    }\n+\n     let len = rawurl.len();\n     let mut st = Start;\n     let mut input = Digit; // most restricted, start here.\n \n     let mut userinfo = None;\n-    let mut host = \"\".to_string();\n+    let mut host = \"\";\n     let mut port = None;\n \n     let mut colon_count = 0u;\n     let mut pos = 0;\n     let mut begin = 2;\n     let mut end = len;\n \n-    for (i,c) in rawurl.chars().enumerate() {\n-        if i < 2 { continue; } // ignore the leading //\n-\n+    for (i,c) in rawurl.chars().enumerate()\n+                               // ignore the leading '//' handled by early return\n+                               .skip(2) {\n         // deal with input class first\n         match c {\n-          '0' .. '9' => (),\n-          'A' .. 'F' | 'a' .. 'f' => {\n-            if input == Digit {\n-                input = Hex;\n+            '0' .. '9' => (),\n+            'A' .. 'F'\n+            | 'a' .. 'f' => {\n+                if input == Digit {\n+                    input = Hex;\n+                }\n             }\n-          }\n-          'G' .. 'Z' | 'g' .. 'z' | '-' | '.' | '_' | '~' | '%' |\n-          '&' |'\\'' | '(' | ')' | '+' | '!' | '*' | ',' | ';' | '=' => {\n-            input = Unreserved;\n-          }\n-          ':' | '@' | '?' | '#' | '/' => {\n-            // separators, don't change anything\n-          }\n-          _ => {\n-            return Err(\"Illegal character in authority\".to_string());\n-          }\n+            'G' .. 'Z'\n+            | 'g' .. 'z'\n+            | '-' | '.' | '_' | '~' | '%'\n+            | '&' |'\\'' | '(' | ')' | '+'\n+            | '!' | '*' | ',' | ';' | '=' => input = Unreserved,\n+            ':' | '@' | '?' | '#' | '/' => {\n+                // separators, don't change anything\n+            }\n+            _ => return Err(\"Illegal character in authority\".to_string()),\n         }\n \n         // now process states\n@@ -595,7 +568,7 @@ fn get_authority(rawurl: &str) ->\n                 pos = i;\n                 if input == Unreserved {\n                     // must be port\n-                    host = rawurl.slice(begin, i).to_string();\n+                    host = rawurl.slice(begin, i);\n                     st = InPort;\n                 } else {\n                     // can't be sure whether this is an ipv6 address or a port\n@@ -604,21 +577,18 @@ fn get_authority(rawurl: &str) ->\n               }\n               Ip6Port => {\n                 if input == Unreserved {\n-                    return Err(\"Illegal characters in \\\n-                                authority.\".to_string());\n+                    return Err(\"Illegal characters in authority.\".to_string());\n                 }\n                 st = Ip6Host;\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = rawurl.slice(begin, i).to_string();\n+                    host = rawurl.slice(begin, i);\n                     pos = i;\n                     st = InPort;\n                 }\n               }\n-              _ => {\n-                return Err(\"Invalid ':' in authority.\".to_string());\n-              }\n+              _ => return Err(\"Invalid ':' in authority.\".to_string()),\n             }\n             input = Digit; // reset input class\n           }\n@@ -638,9 +608,7 @@ fn get_authority(rawurl: &str) ->\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n-              _ => {\n-                return Err(\"Invalid '@' in authority.\".to_string());\n-              }\n+              _ => return Err(\"Invalid '@' in authority.\".to_string()),\n             }\n             begin = i+1;\n           }\n@@ -655,44 +623,53 @@ fn get_authority(rawurl: &str) ->\n \n     // finish up\n     match st {\n-      Start => {\n-        host = rawurl.slice(begin, end).to_string();\n-      }\n-      PassHostPort | Ip6Port => {\n+      Start => host = rawurl.slice(begin, end),\n+      PassHostPort\n+      | Ip6Port => {\n         if input != Digit {\n             return Err(\"Non-digit characters in port.\".to_string());\n         }\n-        host = rawurl.slice(begin, pos).to_string();\n-        port = Some(rawurl.slice(pos+1, end).to_string());\n-      }\n-      Ip6Host | InHost => {\n-        host = rawurl.slice(begin, end).to_string();\n+        host = rawurl.slice(begin, pos);\n+        port = Some(rawurl.slice(pos+1, end));\n       }\n+      Ip6Host\n+      | InHost => host = rawurl.slice(begin, end),\n       InPort => {\n         if input != Digit {\n             return Err(\"Non-digit characters in port.\".to_string());\n         }\n-        port = Some(rawurl.slice(pos+1, end).to_string());\n+        port = Some(rawurl.slice(pos+1, end));\n       }\n     }\n \n-    let rest = rawurl.slice(end, len).to_string();\n-    return Ok((userinfo, host, port, rest));\n+    let rest = rawurl.slice(end, len);\n+    // If we have a port string, ensure it parses to u16.\n+    let port = match port {\n+        None => None,\n+        opt => match opt.and_then(|p| FromStr::from_str(p)) {\n+            None => return Err(format!(\"Failed to parse port: {}\", port)),\n+            opt => opt\n+        }\n+    };\n+\n+    Ok((userinfo, host, port, rest))\n }\n \n \n // returns the path and unparsed part of url, or an error\n-fn get_path(rawurl: &str, authority: bool) ->\n-    Result<(String, String), String> {\n+fn get_path<'a>(rawurl: &'a str, is_authority: bool)\n+                                            -> DecodeResult<(String, &'a str)> {\n     let len = rawurl.len();\n     let mut end = len;\n     for (i,c) in rawurl.chars().enumerate() {\n         match c {\n-          'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '&' |'\\'' | '(' | ')' | '.'\n-          | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '='\n-          | '_' | '-' | '~' => {\n-            continue;\n-          }\n+          'A' .. 'Z'\n+          | 'a' .. 'z'\n+          | '0' .. '9'\n+          | '&' |'\\'' | '(' | ')' | '.'\n+          | '@' | ':' | '%' | '/' | '+'\n+          | '!' | '*' | ',' | ';' | '='\n+          | '_' | '-' | '~' => continue,\n           '?' | '#' => {\n             end = i;\n             break;\n@@ -701,127 +678,53 @@ fn get_path(rawurl: &str, authority: bool) ->\n         }\n     }\n \n-    if authority {\n-        if end != 0 && !rawurl.starts_with(\"/\") {\n-            return Err(\"Non-empty path must begin with\\\n-                              '/' in presence of authority.\".to_string());\n-        }\n+    if is_authority && end != 0 && !rawurl.starts_with(\"/\") {\n+        Err(\"Non-empty path must begin with \\\n+            '/' in presence of authority.\".to_string())\n+    } else {\n+        Ok((try!(decode_component(rawurl.slice(0, end))),\n+            rawurl.slice(end, len)))\n     }\n-\n-    return Ok((decode_component(rawurl.slice(0, end)),\n-                    rawurl.slice(end, len).to_string()));\n }\n \n // returns the parsed query and the fragment, if present\n-fn get_query_fragment(rawurl: &str) ->\n-    Result<(Query, Option<String>), String> {\n-    if !rawurl.starts_with(\"?\") {\n-        if rawurl.starts_with(\"#\") {\n-            let f = decode_component(rawurl.slice(\n-                                                1,\n-                                                rawurl.len()));\n-            return Ok((vec!(), Some(f)));\n-        } else {\n-            return Ok((vec!(), None));\n-        }\n-    }\n-    let (q, r) = split_char_first(rawurl.slice(1, rawurl.len()), '#');\n-    let f = if r.len() != 0 {\n-        Some(decode_component(r.as_slice()))\n-    } else {\n-        None\n-    };\n-    return Ok((query_from_str(q.as_slice()), f));\n-}\n-\n-/**\n- * Parses a URL, converting it from a string to `Url` representation.\n- *\n- * # Arguments\n- *\n- * `rawurl` - a string representing the full URL, including scheme.\n- *\n- * # Returns\n- *\n- * A `Url` struct type representing the URL.\n- */\n-pub fn from_str(rawurl: &str) -> Result<Url, String> {\n-    // scheme\n-    let (scheme, rest) = match get_scheme(rawurl) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n-    };\n-\n-    // authority\n-    let (userinfo, host, port, rest) = match get_authority(rest.as_slice()) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n-    };\n-\n-    // path\n-    let has_authority = host.len() > 0;\n-    let (path, rest) = match get_path(rest.as_slice(), has_authority) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n-    };\n-\n-    // query and fragment\n-    let (query, fragment) = match get_query_fragment(rest.as_slice()) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n-    };\n-\n-    Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n-}\n-\n-pub fn path_from_str(rawpath: &str) -> Result<Path, String> {\n-    let (path, rest) = match get_path(rawpath, false) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e)\n-    };\n+fn get_query_fragment(rawurl: &str) -> DecodeResult<(Query, Option<String>)> {\n+    let (before_fragment, raw_fragment) = split_char_first(rawurl, '#');\n \n-    // query and fragment\n-    let (query, fragment) = match get_query_fragment(rest.as_slice()) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n+    // Parse the fragment if available\n+    let fragment = match raw_fragment {\n+        \"\" => None,\n+        raw => Some(try!(decode_component(raw)))\n     };\n \n-    Ok(Path{ path: path, query: query, fragment: fragment })\n+    match before_fragment.slice_shift_char() {\n+        (Some('?'), rest) => Ok((try!(query_from_str(rest)), fragment)),\n+        (None, \"\") => Ok((vec!(), fragment)),\n+        _ => Err(format!(\"Query didn't start with '?': '{}..'\", before_fragment)),\n+    }\n }\n \n impl FromStr for Url {\n     fn from_str(s: &str) -> Option<Url> {\n-        match from_str(s) {\n-            Ok(url) => Some(url),\n-            Err(_) => None\n-        }\n+        Url::parse(s).ok()\n     }\n }\n \n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {\n-        match path_from_str(s) {\n-            Ok(path) => Some(path),\n-            Err(_) => None\n-        }\n+        Path::parse(s).ok()\n     }\n }\n \n impl fmt::Show for Url {\n-    /**\n-     * Converts a URL from `Url` to string representation.\n-     *\n-     * # Arguments\n-     *\n-     * `url` - a URL.\n-     *\n-     * # Returns\n-     *\n-     * A string that contains the formatted URL. Note that this will usually\n-     * be an inverse of `from_str` but might strip out unneeded separators;\n-     * for example, \"http://somehost.com?\", when parsed and formatted, will\n-     * result in just \"http://somehost.com\".\n-     */\n+    /// Converts a URL from `Url` to string representation.\n+    ///\n+    /// # Returns\n+    ///\n+    /// A string that contains the formatted URL. Note that this will usually\n+    /// be an inverse of `from_str` but might strip out unneeded separators;\n+    /// for example, \"http://somehost.com?\", when parsed and formatted, will\n+    /// result in just \"http://somehost.com\".\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{}:\", self.scheme));\n \n@@ -838,26 +741,15 @@ impl fmt::Show for Url {\n             }\n         }\n \n-        try!(write!(f, \"{}\", self.path));\n-\n-        if !self.query.is_empty() {\n-            try!(write!(f, \"?{}\", query_to_str(&self.query)));\n-        }\n-\n-        match self.fragment {\n-            Some(ref fragment) => {\n-                write!(f, \"#{}\", encode_component(fragment.as_slice()))\n-            }\n-            None => Ok(()),\n-        }\n+        write!(f, \"{}\", self.path)\n     }\n }\n \n impl fmt::Show for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{}\", self.path));\n         if !self.query.is_empty() {\n-            try!(write!(f, \"?{}\", self.query))\n+            try!(write!(f, \"?{}\", query_to_str(&self.query)))\n         }\n \n         match self.fragment {\n@@ -887,53 +779,52 @@ impl<S: hash::Writer> hash::Hash<S> for Path {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(\"hello, sweet world\", ',');\n-    assert_eq!(u, \"hello\".to_string());\n-    assert_eq!(v, \" sweet world\".to_string());\n+    assert_eq!(u, \"hello\");\n+    assert_eq!(v, \" sweet world\");\n \n     let (u,v) = split_char_first(\"hello sweet world\", ',');\n-    assert_eq!(u, \"hello sweet world\".to_string());\n-    assert_eq!(v, \"\".to_string());\n+    assert_eq!(u, \"hello sweet world\");\n+    assert_eq!(v, \"\");\n }\n \n #[test]\n fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n     assert_eq!(u, Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n-    assert_eq!(h, \"rust-lang.org\".to_string());\n+    assert_eq!(h, \"rust-lang.org\");\n     assert!(p.is_none());\n-    assert_eq!(r, \"/something\".to_string());\n+    assert_eq!(r, \"/something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_string());\n-    assert_eq!(p, Some(\"8000\".to_string()));\n-    assert_eq!(r, \"?something\".to_string());\n+    assert_eq!(h, \"rust-lang.org\");\n+    assert_eq!(p, Some(8000));\n+    assert_eq!(r, \"?something\");\n \n-    let (u, h, p, r) = get_authority(\n-        \"//rust-lang.org#blah\").unwrap();\n+    let (u, h, p, r) = get_authority(\"//rust-lang.org#blah\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_string());\n+    assert_eq!(h, \"rust-lang.org\");\n     assert!(p.is_none());\n-    assert_eq!(r, \"#blah\".to_string());\n+    assert_eq!(r, \"#blah\");\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_string());\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_string());\n-    assert_eq!(p, Some(\"8000\".to_string()));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(p, Some(8000));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n     assert_eq!(u, Some(UserInfo::new(\"us\".to_string(), Some(\"p\".to_string()))));\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_string());\n-    assert_eq!(p, Some(\"8000\".to_string()));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(p, Some(8000));\n \n     // invalid authorities;\n     assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n@@ -942,122 +833,123 @@ fn test_get_authority() {\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err());\n     assert!(get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n+    // outside u16 range\n+    assert!(get_authority(\"//user:pass@rust-lang:65536\").is_err());\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n-    assert_eq!(h, \"\".to_string());\n+    assert_eq!(h, \"\");\n     let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n-    assert_eq!(h, \"\".to_string());\n+    assert_eq!(h, \"\");\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n     assert_eq!(p, \"/something+ orother\".to_string());\n-    assert_eq!(r, \"\".to_string());\n+    assert_eq!(r, \"\");\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n     assert_eq!(p, \"test@email.com\".to_string());\n-    assert_eq!(r, \"#fragment\".to_string());\n+    assert_eq!(r, \"#fragment\");\n     let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n     assert_eq!(p, \"/gen/:addr=\".to_string());\n-    assert_eq!(r, \"?q=v\".to_string());\n+    assert_eq!(r, \"?q=v\");\n \n     //failure cases\n     assert!(get_path(\"something?q\", true).is_err());\n }\n \n #[cfg(test)]\n mod tests {\n-    use {encode_form_urlencoded, decode_form_urlencoded,\n-         decode, encode, from_str, encode_component, decode_component,\n-         path_from_str, UserInfo, get_scheme};\n+    use {encode_form_urlencoded, decode_form_urlencoded, decode, encode,\n+        encode_component, decode_component, UserInfo, get_scheme, Url, Path};\n \n     use std::collections::HashMap;\n+    use std::path::BytesContainer;\n \n     #[test]\n     fn test_url_parse() {\n         let url = \"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\";\n-\n-        let up = from_str(url);\n-        let u = up.unwrap();\n-        assert_eq!(&u.scheme, &\"http\".to_string());\n-        assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n-        assert_eq!(&u.host, &\"rust-lang.org\".to_string());\n-        assert_eq!(&u.port, &Some(\"8080\".to_string()));\n-        assert_eq!(&u.path, &\"/doc/~u\".to_string());\n-        assert_eq!(&u.query, &vec!((\"s\".to_string(), \"v\".to_string())));\n-        assert_eq!(&u.fragment, &Some(\"something\".to_string()));\n+        let u = from_str::<Url>(url).unwrap();\n+\n+        assert_eq!(u.scheme, \"http\".to_string());\n+        assert_eq!(u.user, Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n+        assert_eq!(u.host, \"rust-lang.org\".to_string());\n+        assert_eq!(u.port, Some(8080));\n+        assert_eq!(u.path.path, \"/doc/~u\".to_string());\n+        assert_eq!(u.path.query, vec!((\"s\".to_string(), \"v\".to_string())));\n+        assert_eq!(u.path.fragment, Some(\"something\".to_string()));\n     }\n \n     #[test]\n     fn test_path_parse() {\n         let path = \"/doc/~u?s=v#something\";\n+        let u = from_str::<Path>(path).unwrap();\n \n-        let up = path_from_str(path);\n-        let u = up.unwrap();\n-        assert_eq!(&u.path, &\"/doc/~u\".to_string());\n-        assert_eq!(&u.query, &vec!((\"s\".to_string(), \"v\".to_string())));\n-        assert_eq!(&u.fragment, &Some(\"something\".to_string()));\n+        assert_eq!(u.path, \"/doc/~u\".to_string());\n+        assert_eq!(u.query, vec!((\"s\".to_string(), \"v\".to_string())));\n+        assert_eq!(u.fragment, Some(\"something\".to_string()));\n     }\n \n     #[test]\n     fn test_url_parse_host_slash() {\n         let urlstr = \"http://0.42.42.42/\";\n-        let url = from_str(urlstr).unwrap();\n-        assert!(url.host == \"0.42.42.42\".to_string());\n-        assert!(url.path == \"/\".to_string());\n+        let url = from_str::<Url>(urlstr).unwrap();\n+        assert_eq!(url.host, \"0.42.42.42\".to_string());\n+        assert_eq!(url.path.path, \"/\".to_string());\n     }\n \n     #[test]\n     fn test_path_parse_host_slash() {\n         let pathstr = \"/\";\n-        let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/\".to_string());\n+        let path = from_str::<Path>(pathstr).unwrap();\n+        assert_eq!(path.path, \"/\".to_string());\n     }\n \n     #[test]\n     fn test_url_host_with_port() {\n         let urlstr = \"scheme://host:1234\";\n-        let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &\"scheme\".to_string());\n-        assert_eq!(&url.host, &\"host\".to_string());\n-        assert_eq!(&url.port, &Some(\"1234\".to_string()));\n+        let url = from_str::<Url>(urlstr).unwrap();\n+        assert_eq!(url.scheme, \"scheme\".to_string());\n+        assert_eq!(url.host, \"host\".to_string());\n+        assert_eq!(url.port, Some(1234));\n         // is empty path really correct? Other tests think so\n-        assert_eq!(&url.path, &\"\".to_string());\n+        assert_eq!(url.path.path, \"\".to_string());\n+\n         let urlstr = \"scheme://host:1234/\";\n-        let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &\"scheme\".to_string());\n-        assert_eq!(&url.host, &\"host\".to_string());\n-        assert_eq!(&url.port, &Some(\"1234\".to_string()));\n-        assert_eq!(&url.path, &\"/\".to_string());\n+        let url = from_str::<Url>(urlstr).unwrap();\n+        assert_eq!(url.scheme, \"scheme\".to_string());\n+        assert_eq!(url.host, \"host\".to_string());\n+        assert_eq!(url.port, Some(1234));\n+        assert_eq!(url.path.path, \"/\".to_string());\n     }\n \n     #[test]\n     fn test_url_with_underscores() {\n         let urlstr = \"http://dotcom.com/file_name.html\";\n-        let url = from_str(urlstr).unwrap();\n-        assert!(url.path == \"/file_name.html\".to_string());\n+        let url = from_str::<Url>(urlstr).unwrap();\n+        assert_eq!(url.path.path, \"/file_name.html\".to_string());\n     }\n \n     #[test]\n     fn test_path_with_underscores() {\n         let pathstr = \"/file_name.html\";\n-        let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/file_name.html\".to_string());\n+        let path = from_str::<Path>(pathstr).unwrap();\n+        assert_eq!(path.path, \"/file_name.html\".to_string());\n     }\n \n     #[test]\n     fn test_url_with_dashes() {\n         let urlstr = \"http://dotcom.com/file-name.html\";\n-        let url = from_str(urlstr).unwrap();\n-        assert!(url.path == \"/file-name.html\".to_string());\n+        let url = from_str::<Url>(urlstr).unwrap();\n+        assert_eq!(url.path.path, \"/file-name.html\".to_string());\n     }\n \n     #[test]\n     fn test_path_with_dashes() {\n         let pathstr = \"/file-name.html\";\n-        let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/file-name.html\".to_string());\n+        let path = from_str::<Path>(pathstr).unwrap();\n+        assert_eq!(path.path, \"/file-name.html\".to_string());\n     }\n \n     #[test]\n@@ -1067,208 +959,245 @@ mod tests {\n \n     #[test]\n     fn test_invalid_scheme_errors() {\n-        assert!(from_str(\"99://something\").is_err());\n-        assert!(from_str(\"://something\").is_err());\n+        assert!(Url::parse(\"99://something\").is_err());\n+        assert!(Url::parse(\"://something\").is_err());\n     }\n \n     #[test]\n     fn test_full_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_userless_url_parse_and_format() {\n         let url = \"http://rust-lang.org/doc?s=v#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_queryless_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org/doc#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_empty_query_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = \"http://user:pass@rust-lang.org/doc#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), should_be);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), should_be);\n     }\n \n     #[test]\n     fn test_fragmentless_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org/doc?q=v\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_minimal_url_parse_and_format() {\n         let url = \"http://rust-lang.org/doc\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_url_with_port_parse_and_format() {\n         let url = \"http://rust-lang.org:80/doc\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_only_url_parse_and_format() {\n         let url = \"http://rust-lang.org\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_pathless_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org?q=v#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = \"http://rust-lang.org#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_url_component_encoding() {\n         let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n-        let u = from_str(url).unwrap();\n-        assert!(u.path == \"/doc uments\".to_string());\n-        assert!(u.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n+        let u = from_str::<Url>(url).unwrap();\n+        assert!(u.path.path == \"/doc uments\".to_string());\n+        assert!(u.path.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n     }\n \n     #[test]\n     fn test_path_component_encoding() {\n         let path = \"/doc%20uments?ba%25d%20=%23%26%2B\";\n-        let p = path_from_str(path).unwrap();\n+        let p = from_str::<Path>(path).unwrap();\n         assert!(p.path == \"/doc uments\".to_string());\n         assert!(p.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n     }\n \n     #[test]\n     fn test_url_without_authority() {\n         let url = \"mailto:test@email.com\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        let u = from_str::<Url>(url).unwrap();\n+        assert_eq!(format!(\"{}\", u).as_slice(), url);\n     }\n \n     #[test]\n     fn test_encode() {\n-        assert_eq!(encode(\"\"), \"\".to_string());\n-        assert_eq!(encode(\"http://example.com\"), \"http://example.com\".to_string());\n-        assert_eq!(encode(\"foo bar% baz\"), \"foo%20bar%25%20baz\".to_string());\n-        assert_eq!(encode(\" \"), \"%20\".to_string());\n-        assert_eq!(encode(\"!\"), \"!\".to_string());\n-        assert_eq!(encode(\"\\\"\"), \"\\\"\".to_string());\n-        assert_eq!(encode(\"#\"), \"#\".to_string());\n-        assert_eq!(encode(\"$\"), \"$\".to_string());\n-        assert_eq!(encode(\"%\"), \"%25\".to_string());\n-        assert_eq!(encode(\"&\"), \"&\".to_string());\n-        assert_eq!(encode(\"'\"), \"%27\".to_string());\n-        assert_eq!(encode(\"(\"), \"(\".to_string());\n-        assert_eq!(encode(\")\"), \")\".to_string());\n-        assert_eq!(encode(\"*\"), \"*\".to_string());\n-        assert_eq!(encode(\"+\"), \"+\".to_string());\n-        assert_eq!(encode(\",\"), \",\".to_string());\n-        assert_eq!(encode(\"/\"), \"/\".to_string());\n-        assert_eq!(encode(\":\"), \":\".to_string());\n-        assert_eq!(encode(\";\"), \";\".to_string());\n-        assert_eq!(encode(\"=\"), \"=\".to_string());\n-        assert_eq!(encode(\"?\"), \"?\".to_string());\n-        assert_eq!(encode(\"@\"), \"@\".to_string());\n-        assert_eq!(encode(\"[\"), \"[\".to_string());\n-        assert_eq!(encode(\"]\"), \"]\".to_string());\n-        assert_eq!(encode(\"\\0\"), \"%00\".to_string());\n-        assert_eq!(encode(\"\\n\"), \"%0A\".to_string());\n+        fn t<T: BytesContainer>(input: T, expected: &str) {\n+            assert_eq!(encode(input), expected.to_string())\n+        }\n+\n+        t(\"\", \"\");\n+        t(\"http://example.com\", \"http://example.com\");\n+        t(\"foo bar% baz\", \"foo%20bar%25%20baz\");\n+        t(\" \", \"%20\");\n+        t(\"!\", \"!\");\n+        t(\"\\\"\", \"\\\"\");\n+        t(\"#\", \"#\");\n+        t(\"$\", \"$\");\n+        t(\"%\", \"%25\");\n+        t(\"&\", \"&\");\n+        t(\"'\", \"%27\");\n+        t(\"(\", \"(\");\n+        t(\")\", \")\");\n+        t(\"*\", \"*\");\n+        t(\"+\", \"+\");\n+        t(\",\", \",\");\n+        t(\"/\", \"/\");\n+        t(\":\", \":\");\n+        t(\";\", \";\");\n+        t(\"=\", \"=\");\n+        t(\"?\", \"?\");\n+        t(\"@\", \"@\");\n+        t(\"[\", \"[\");\n+        t(\"]\", \"]\");\n+        t(\"\\0\", \"%00\");\n+        t(\"\\n\", \"%0A\");\n+\n+        t(&[0u8, 10, 37], \"%00%0A%25\");\n     }\n \n     #[test]\n     fn test_encode_component() {\n-        assert_eq!(encode_component(\"\"), \"\".to_string());\n-        assert!(encode_component(\"http://example.com\") ==\n-            \"http%3A%2F%2Fexample.com\".to_string());\n-        assert!(encode_component(\"foo bar% baz\") ==\n-            \"foo%20bar%25%20baz\".to_string());\n-        assert_eq!(encode_component(\" \"), \"%20\".to_string());\n-        assert_eq!(encode_component(\"!\"), \"%21\".to_string());\n-        assert_eq!(encode_component(\"#\"), \"%23\".to_string());\n-        assert_eq!(encode_component(\"$\"), \"%24\".to_string());\n-        assert_eq!(encode_component(\"%\"), \"%25\".to_string());\n-        assert_eq!(encode_component(\"&\"), \"%26\".to_string());\n-        assert_eq!(encode_component(\"'\"), \"%27\".to_string());\n-        assert_eq!(encode_component(\"(\"), \"%28\".to_string());\n-        assert_eq!(encode_component(\")\"), \"%29\".to_string());\n-        assert_eq!(encode_component(\"*\"), \"%2A\".to_string());\n-        assert_eq!(encode_component(\"+\"), \"%2B\".to_string());\n-        assert_eq!(encode_component(\",\"), \"%2C\".to_string());\n-        assert_eq!(encode_component(\"/\"), \"%2F\".to_string());\n-        assert_eq!(encode_component(\":\"), \"%3A\".to_string());\n-        assert_eq!(encode_component(\";\"), \"%3B\".to_string());\n-        assert_eq!(encode_component(\"=\"), \"%3D\".to_string());\n-        assert_eq!(encode_component(\"?\"), \"%3F\".to_string());\n-        assert_eq!(encode_component(\"@\"), \"%40\".to_string());\n-        assert_eq!(encode_component(\"[\"), \"%5B\".to_string());\n-        assert_eq!(encode_component(\"]\"), \"%5D\".to_string());\n-        assert_eq!(encode_component(\"\\0\"), \"%00\".to_string());\n-        assert_eq!(encode_component(\"\\n\"), \"%0A\".to_string());\n+        fn t<T: BytesContainer>(input: T, expected: &str) {\n+            assert_eq!(encode_component(input), expected.to_string())\n+        }\n+\n+        t(\"\", \"\");\n+        t(\"http://example.com\", \"http%3A%2F%2Fexample.com\");\n+        t(\"foo bar% baz\", \"foo%20bar%25%20baz\");\n+        t(\" \", \"%20\");\n+        t(\"!\", \"%21\");\n+        t(\"#\", \"%23\");\n+        t(\"$\", \"%24\");\n+        t(\"%\", \"%25\");\n+        t(\"&\", \"%26\");\n+        t(\"'\", \"%27\");\n+        t(\"(\", \"%28\");\n+        t(\")\", \"%29\");\n+        t(\"*\", \"%2A\");\n+        t(\"+\", \"%2B\");\n+        t(\",\", \"%2C\");\n+        t(\"/\", \"%2F\");\n+        t(\":\", \"%3A\");\n+        t(\";\", \"%3B\");\n+        t(\"=\", \"%3D\");\n+        t(\"?\", \"%3F\");\n+        t(\"@\", \"%40\");\n+        t(\"[\", \"%5B\");\n+        t(\"]\", \"%5D\");\n+        t(\"\\0\", \"%00\");\n+        t(\"\\n\", \"%0A\");\n+\n+        t(&[0u8, 10, 37], \"%00%0A%25\");\n     }\n \n     #[test]\n     fn test_decode() {\n-        assert_eq!(decode(\"\"), \"\".to_string());\n-        assert_eq!(decode(\"abc/def 123\"), \"abc/def 123\".to_string());\n-        assert_eq!(decode(\"abc%2Fdef%20123\"), \"abc%2Fdef 123\".to_string());\n-        assert_eq!(decode(\"%20\"), \" \".to_string());\n-        assert_eq!(decode(\"%21\"), \"%21\".to_string());\n-        assert_eq!(decode(\"%22\"), \"%22\".to_string());\n-        assert_eq!(decode(\"%23\"), \"%23\".to_string());\n-        assert_eq!(decode(\"%24\"), \"%24\".to_string());\n-        assert_eq!(decode(\"%25\"), \"%\".to_string());\n-        assert_eq!(decode(\"%26\"), \"%26\".to_string());\n-        assert_eq!(decode(\"%27\"), \"'\".to_string());\n-        assert_eq!(decode(\"%28\"), \"%28\".to_string());\n-        assert_eq!(decode(\"%29\"), \"%29\".to_string());\n-        assert_eq!(decode(\"%2A\"), \"%2A\".to_string());\n-        assert_eq!(decode(\"%2B\"), \"%2B\".to_string());\n-        assert_eq!(decode(\"%2C\"), \"%2C\".to_string());\n-        assert_eq!(decode(\"%2F\"), \"%2F\".to_string());\n-        assert_eq!(decode(\"%3A\"), \"%3A\".to_string());\n-        assert_eq!(decode(\"%3B\"), \"%3B\".to_string());\n-        assert_eq!(decode(\"%3D\"), \"%3D\".to_string());\n-        assert_eq!(decode(\"%3F\"), \"%3F\".to_string());\n-        assert_eq!(decode(\"%40\"), \"%40\".to_string());\n-        assert_eq!(decode(\"%5B\"), \"%5B\".to_string());\n-        assert_eq!(decode(\"%5D\"), \"%5D\".to_string());\n+        fn t<T: BytesContainer>(input: T, expected: &str) {\n+            assert_eq!(decode(input), Ok(expected.to_string()))\n+        }\n+\n+        assert!(decode(\"sadsadsda%\").is_err());\n+        assert!(decode(\"waeasd%4\").is_err());\n+        t(\"\", \"\");\n+        t(\"abc/def 123\", \"abc/def 123\");\n+        t(\"abc%2Fdef%20123\", \"abc%2Fdef 123\");\n+        t(\"%20\", \" \");\n+        t(\"%21\", \"%21\");\n+        t(\"%22\", \"%22\");\n+        t(\"%23\", \"%23\");\n+        t(\"%24\", \"%24\");\n+        t(\"%25\", \"%\");\n+        t(\"%26\", \"%26\");\n+        t(\"%27\", \"'\");\n+        t(\"%28\", \"%28\");\n+        t(\"%29\", \"%29\");\n+        t(\"%2A\", \"%2A\");\n+        t(\"%2B\", \"%2B\");\n+        t(\"%2C\", \"%2C\");\n+        t(\"%2F\", \"%2F\");\n+        t(\"%3A\", \"%3A\");\n+        t(\"%3B\", \"%3B\");\n+        t(\"%3D\", \"%3D\");\n+        t(\"%3F\", \"%3F\");\n+        t(\"%40\", \"%40\");\n+        t(\"%5B\", \"%5B\");\n+        t(\"%5D\", \"%5D\");\n+\n+        t(\"%00%0A%25\".as_bytes(), \"\\0\\n%\");\n     }\n \n     #[test]\n     fn test_decode_component() {\n-        assert_eq!(decode_component(\"\"), \"\".to_string());\n-        assert_eq!(decode_component(\"abc/def 123\"), \"abc/def 123\".to_string());\n-        assert_eq!(decode_component(\"abc%2Fdef%20123\"), \"abc/def 123\".to_string());\n-        assert_eq!(decode_component(\"%20\"), \" \".to_string());\n-        assert_eq!(decode_component(\"%21\"), \"!\".to_string());\n-        assert_eq!(decode_component(\"%22\"), \"\\\"\".to_string());\n-        assert_eq!(decode_component(\"%23\"), \"#\".to_string());\n-        assert_eq!(decode_component(\"%24\"), \"$\".to_string());\n-        assert_eq!(decode_component(\"%25\"), \"%\".to_string());\n-        assert_eq!(decode_component(\"%26\"), \"&\".to_string());\n-        assert_eq!(decode_component(\"%27\"), \"'\".to_string());\n-        assert_eq!(decode_component(\"%28\"), \"(\".to_string());\n-        assert_eq!(decode_component(\"%29\"), \")\".to_string());\n-        assert_eq!(decode_component(\"%2A\"), \"*\".to_string());\n-        assert_eq!(decode_component(\"%2B\"), \"+\".to_string());\n-        assert_eq!(decode_component(\"%2C\"), \",\".to_string());\n-        assert_eq!(decode_component(\"%2F\"), \"/\".to_string());\n-        assert_eq!(decode_component(\"%3A\"), \":\".to_string());\n-        assert_eq!(decode_component(\"%3B\"), \";\".to_string());\n-        assert_eq!(decode_component(\"%3D\"), \"=\".to_string());\n-        assert_eq!(decode_component(\"%3F\"), \"?\".to_string());\n-        assert_eq!(decode_component(\"%40\"), \"@\".to_string());\n-        assert_eq!(decode_component(\"%5B\"), \"[\".to_string());\n-        assert_eq!(decode_component(\"%5D\"), \"]\".to_string());\n+        fn t<T: BytesContainer>(input: T, expected: &str) {\n+            assert_eq!(decode_component(input), Ok(expected.to_string()))\n+        }\n+\n+        assert!(decode_component(\"asacsa%\").is_err());\n+        assert!(decode_component(\"acsas%4\").is_err());\n+        t(\"\", \"\");\n+        t(\"abc/def 123\", \"abc/def 123\");\n+        t(\"abc%2Fdef%20123\", \"abc/def 123\");\n+        t(\"%20\", \" \");\n+        t(\"%21\", \"!\");\n+        t(\"%22\", \"\\\"\");\n+        t(\"%23\", \"#\");\n+        t(\"%24\", \"$\");\n+        t(\"%25\", \"%\");\n+        t(\"%26\", \"&\");\n+        t(\"%27\", \"'\");\n+        t(\"%28\", \"(\");\n+        t(\"%29\", \")\");\n+        t(\"%2A\", \"*\");\n+        t(\"%2B\", \"+\");\n+        t(\"%2C\", \",\");\n+        t(\"%2F\", \"/\");\n+        t(\"%3A\", \":\");\n+        t(\"%3B\", \";\");\n+        t(\"%3D\", \"=\");\n+        t(\"%3F\", \"?\");\n+        t(\"%40\", \"@\");\n+        t(\"%5B\", \"[\");\n+        t(\"%5D\", \"]\");\n+\n+        t(\"%00%0A%25\".as_bytes(), \"\\0\\n%\");\n     }\n \n     #[test]\n@@ -1286,16 +1215,16 @@ mod tests {\n \n         let mut m = HashMap::new();\n         m.insert(\"foo bar\".to_string(), vec!(\"abc\".to_string(), \"12 = 34\".to_string()));\n-        assert!(encode_form_urlencoded(&m) ==\n-            \"foo+bar=abc&foo+bar=12+%3D+34\".to_string());\n+        assert_eq!(encode_form_urlencoded(&m),\n+                    \"foo+bar=abc&foo+bar=12+%3D+34\".to_string());\n     }\n \n     #[test]\n     fn test_decode_form_urlencoded() {\n-        assert_eq!(decode_form_urlencoded([]).len(), 0);\n+        assert_eq!(decode_form_urlencoded([]).unwrap().len(), 0);\n \n         let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n-        let form = decode_form_urlencoded(s);\n+        let form = decode_form_urlencoded(s).unwrap();\n         assert_eq!(form.len(), 2);\n         assert_eq!(form.get(&\"a\".to_string()), &vec!(\"1\".to_string()));\n         assert_eq!(form.get(&\"foo bar\".to_string()),"}]}