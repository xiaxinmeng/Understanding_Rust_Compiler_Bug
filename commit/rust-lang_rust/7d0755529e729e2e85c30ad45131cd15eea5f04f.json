{"sha": "7d0755529e729e2e85c30ad45131cd15eea5f04f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMDc1NTUyOWU3MjllMmU4NWMzMGFkNDUxMzFjZDE1ZWVhNWYwNGY=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-01T21:56:33Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-02T18:19:27Z"}, "message": "Add ty_var_integral (WIP on issue #1425).", "tree": {"sha": "1d4dfc0f1cbc7c5c0820a69962c065251ccb18a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d4dfc0f1cbc7c5c0820a69962c065251ccb18a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d0755529e729e2e85c30ad45131cd15eea5f04f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d0755529e729e2e85c30ad45131cd15eea5f04f", "html_url": "https://github.com/rust-lang/rust/commit/7d0755529e729e2e85c30ad45131cd15eea5f04f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d0755529e729e2e85c30ad45131cd15eea5f04f/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77c470d183472b357737b6d3e6c7cafc26174c91", "url": "https://api.github.com/repos/rust-lang/rust/commits/77c470d183472b357737b6d3e6c7cafc26174c91", "html_url": "https://github.com/rust-lang/rust/commit/77c470d183472b357737b6d3e6c7cafc26174c91"}], "stats": {"total": 115, "additions": 81, "deletions": 34}, "files": [{"sha": "4893275f9531d6d4646e106e08bd472ffa40e696", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=7d0755529e729e2e85c30ad45131cd15eea5f04f", "patch": "@@ -276,6 +276,12 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_char('X');\n         w.write_uint(id.to_uint());\n       }\n+      ty::ty_var_integral(id) {\n+        // TODO: should we have a different character for these? (Issue #1425)\n+        w.write_char('X');\n+        w.write_uint(id.to_uint());\n+        w.write_str(\"(integral)\");\n+      }\n       ty::ty_param(id, did) {\n         w.write_char('p');\n         w.write_str(cx.ds(did));"}, {"sha": "303b8995244d1dd499fd070c2d18734fe16cb3cf", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=7d0755529e729e2e85c30ad45131cd15eea5f04f", "patch": "@@ -395,7 +395,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n       ty::ty_fn({proto: ast::proto_bare, _}) { [shape_bare_fn] }\n       ty::ty_opaque_closure_ptr(_) { [shape_opaque_closure_ptr] }\n       ty::ty_constr(inner_t, _) { shape_of(ccx, inner_t) }\n-      ty::ty_var(_) | ty::ty_self {\n+      ty::ty_var(_) | ty::ty_var_integral(_) | ty::ty_self {\n         ccx.sess.bug(\"shape_of: unexpected type struct found\");\n       }\n     }"}, {"sha": "7ce9b5885b4b09eec1886c7786c6535205289576", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=7d0755529e729e2e85c30ad45131cd15eea5f04f", "patch": "@@ -161,6 +161,9 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           }\n           ty::ty_self { cx.tcx.sess.unimpl(\"type_of: ty_self\"); }\n           ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n+          ty::ty_var_integral(_) {\n+            cx.tcx.sess.bug(\"type_of shouldn't see a ty_var_integral\");\n+          }\n         }\n     };\n     cx.lltypes.insert(t, llty);"}, {"sha": "c608a83319c415e7daeb5f4139e84b2879aa76fe", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=7d0755529e729e2e85c30ad45131cd15eea5f04f", "patch": "@@ -102,6 +102,7 @@ export ty_type, mk_type;\n export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n export ty_var, mk_var, type_is_var;\n+export ty_var_integral, mk_var_integral, type_is_var_integral;\n export ty_self, mk_self, type_has_self;\n export region, bound_region, encl_region;\n export get, type_has_params, type_needs_infer, type_has_regions;\n@@ -299,6 +300,11 @@ enum closure_kind {\n     ck_uniq,\n }\n \n+enum ty_var_kind {\n+    tvk_regular,\n+    tvk_integral,\n+}\n+\n type fn_ty = {purity: ast::purity,\n               proto: ast::proto,\n               inputs: [arg],\n@@ -365,6 +371,8 @@ enum sty {\n     ty_tup([t]),\n \n     ty_var(ty_vid), // type variable during typechecking\n+    ty_var_integral(ty_vid), // type variable during typechecking, for\n+                             // integral types only\n     ty_param(uint, def_id), // type parameter\n     ty_self, // special, implicit `self` type parameter\n \n@@ -555,7 +563,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_str | ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n       ty_opaque_box {}\n       ty_param(_, _) { flags |= has_params as uint; }\n-      ty_var(_) { flags |= needs_infer as uint; }\n+      ty_var(_) | ty_var_integral(_) { flags |= needs_infer as uint; }\n       ty_self { flags |= has_self as uint; }\n       ty_enum(_, substs) | ty_class(_, substs) | ty_iface(_, substs) {\n         flags |= sflags(substs);\n@@ -680,6 +688,8 @@ fn mk_res(cx: ctxt, did: ast::def_id,\n \n fn mk_var(cx: ctxt, v: ty_vid) -> t { mk_t(cx, ty_var(v)) }\n \n+fn mk_var_integral(cx: ctxt, v: ty_vid) -> t { mk_t(cx, ty_var_integral(v)) }\n+\n fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n \n fn mk_param(cx: ctxt, n: uint, k: def_id) -> t { mk_t(cx, ty_param(n, k)) }\n@@ -729,7 +739,8 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     alt get(ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n-      ty_opaque_closure_ptr(_) | ty_var(_) | ty_param(_, _) {\n+      ty_opaque_closure_ptr(_) | ty_var(_) | ty_var_integral(_) |\n+      ty_param(_, _) {\n       }\n       ty_box(tm) | ty_vec(tm) | ty_evec(tm, _) |\n       ty_ptr(tm) | ty_rptr(_, tm) {\n@@ -824,7 +835,7 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n-      ty_opaque_box | ty_var(_) | ty_param(*) | ty_self {\n+      ty_opaque_box | ty_var(_) | ty_var_integral(_) | ty_param(*) | ty_self {\n         sty\n       }\n     }\n@@ -1038,6 +1049,13 @@ fn type_is_var(ty: t) -> bool {\n     }\n }\n \n+fn type_is_var_integral(ty: t) -> bool {\n+    alt get(ty).struct {\n+      ty_var_integral(_) { true }\n+      _ { false }\n+    }\n+}\n+\n fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n \n fn type_is_structural(ty: t) -> bool {\n@@ -1553,8 +1571,9 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       ty_constr(t, _) { type_kind(cx, t) }\n       // FIXME: is self ever const?\n       ty_self { kind_noncopyable() }\n-\n-      ty_var(_) { cx.sess.bug(\"Asked to compute kind of a type variable\"); }\n+      ty_var(_) | ty_var_integral(_) {\n+        cx.sess.bug(\"Asked to compute kind of a type variable\");\n+      }\n       ty_type | ty_opaque_closure_ptr(_) | ty_opaque_box {\n         cx.sess.bug(\"Asked to compute kind of fictitious type\");\n       }\n@@ -1602,6 +1621,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_estr(_) |\n           ty_fn(_) |\n           ty_var(_) |\n+          ty_var_integral(_) |\n           ty_param(_, _) |\n           ty_self |\n           ty_type |\n@@ -1878,12 +1898,25 @@ fn type_param(ty: t) -> option<uint> {\n     ret none;\n }\n \n-// Returns a vec of all the type variables\n-// occurring in t. It may contain duplicates.\n-fn vars_in_type(ty: t) -> [ty_vid] {\n+// Returns a vec of all the type variables of kind `tvk` occurring in `ty`. It\n+// may contain duplicates.\n+fn vars_in_type(ty: t, tvk: ty_var_kind) -> [ty_vid] {\n     let mut rslt = [];\n     walk_ty(ty) {|ty|\n-        alt get(ty).struct { ty_var(v) { rslt += [v]; } _ { } }\n+        alt get(ty).struct {\n+          ty_var(v) {\n+            alt tvk {\n+              tvk_regular { rslt += [v]; }\n+              _ { }\n+            }\n+          }\n+          ty_var_integral(v) {\n+            alt tvk {\n+              tvk_integral { rslt += [v]; }\n+              _ { }\n+            }\n+          }\n+          _ { } }\n     }\n     rslt\n }\n@@ -2037,7 +2070,8 @@ fn hash_type_structure(st: sty) -> uint {\n         for f.inputs.each {|a| h = hash_subty(h, a.ty); }\n         hash_subty(h, f.output)\n       }\n-      ty_var(v) { hash_uint(30u, v.to_uint()) }\n+      ty_var(v) { hash_uint(29u, v.to_uint()) }\n+      ty_var_integral(v) { hash_uint(30u, v.to_uint()) }\n       ty_param(pid, did) { hash_def(hash_uint(31u, pid), did) }\n       ty_self { 28u }\n       ty_type { 32u }\n@@ -2184,7 +2218,7 @@ fn is_pred_ty(fty: t) -> bool {\n \n fn ty_var_id(typ: t) -> ty_vid {\n     alt get(typ).struct {\n-      ty_var(vid) { ret vid; }\n+      ty_var(vid) | ty_var_integral(vid) { ret vid; }\n       _ { #error(\"ty_var_id called on non-var ty\"); fail; }\n     }\n }\n@@ -2276,7 +2310,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: ty_vid, rt: t) {\n     if !type_needs_infer(rt) { ret; }\n \n     // Occurs check!\n-    if vec::contains(vars_in_type(rt), vid) {\n+    if vec::contains(vars_in_type(rt, tvk_regular), vid) {\n             // Maybe this should be span_err -- however, there's an\n             // assertion later on that the type doesn't contain\n             // variables, so in this case we have to be sure to die.\n@@ -2381,6 +2415,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> str {\n       ty_res(id, _, _) { #fmt[\"resource %s\", item_path_str(cx, id)] }\n       ty_tup(_) { \"tuple\" }\n       ty_var(_) { \"variable\" }\n+      ty_var_integral(_) { \"integral variable\" }\n       ty_param(_, _) { \"type parameter\" }\n       ty_self { \"self\" }\n       ty_constr(t, _) { ty_sort_str(cx, t) }"}, {"sha": "45726bff966153589b3d9dd8215f13bd943fcbf2", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=7d0755529e729e2e85c30ad45131cd15eea5f04f", "patch": "@@ -198,8 +198,9 @@ type vals_and_bindings<V:copy, T:copy> = {\n \n enum infer_ctxt = @{\n     tcx: ty::ctxt,\n-    vb: vals_and_bindings<ty::ty_vid, ty::t>,\n-    rb: vals_and_bindings<ty::region_vid, ty::region>,\n+    tvb: vals_and_bindings<ty::ty_vid, ty::t>, // for type variables\n+    tvib: vals_and_bindings<ty::ty_vid, ty::t>, // for integral type variables\n+    rb: vals_and_bindings<ty::region_vid, ty::region>, // for region variables\n \n     // For keeping track of existing type/region variables.\n     ty_var_counter: @mut uint,\n@@ -227,7 +228,8 @@ type fres<T> = result::result<T, fixup_err>;\n \n fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n     infer_ctxt(@{tcx: tcx,\n-                 vb: {vals: smallintmap::mk(), mut bindings: []},\n+                 tvb: {vals: smallintmap::mk(), mut bindings: []},\n+                 tvib: {vals: smallintmap::mk(), mut bindings: []},\n                  rb: {vals: smallintmap::mk(), mut bindings: []},\n                  ty_var_counter: @mut 0u,\n                  region_var_counter: @mut 0u})}\n@@ -423,14 +425,14 @@ impl transaction_methods for infer_ctxt {\n     #[doc = \"Execute `f` and commit the bindings if successful\"]\n     fn commit<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n-        assert self.vb.bindings.len() == 0u;\n+        assert self.tvb.bindings.len() == 0u;\n         assert self.rb.bindings.len() == 0u;\n \n         let r <- self.try(f);\n \n         // TODO---could use a vec::clear() that ran destructors but kept\n         // the vec at its currently allocated length\n-        self.vb.bindings = [];\n+        self.tvb.bindings = [];\n         self.rb.bindings = [];\n \n         ret r;\n@@ -439,15 +441,15 @@ impl transaction_methods for infer_ctxt {\n     #[doc = \"Execute `f`, unroll bindings on failure\"]\n     fn try<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n-        let vbl = self.vb.bindings.len();\n+        let tvbl = self.tvb.bindings.len();\n         let rbl = self.rb.bindings.len();\n-        #debug[\"try(vbl=%u, rbl=%u)\", vbl, rbl];\n+        #debug[\"try(tvbl=%u, rbl=%u)\", tvbl, rbl];\n         let r <- f();\n         alt r {\n           result::ok(_) { #debug[\"try--ok\"]; }\n           result::err(_) {\n             #debug[\"try--rollback\"];\n-            rollback_to(self.vb, vbl);\n+            rollback_to(self.tvb, tvbl);\n             rollback_to(self.rb, rbl);\n           }\n         }\n@@ -456,10 +458,10 @@ impl transaction_methods for infer_ctxt {\n \n     #[doc = \"Execute `f` then unroll any bindings it creates\"]\n     fn probe<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n-        assert self.vb.bindings.len() == 0u;\n+        assert self.tvb.bindings.len() == 0u;\n         assert self.rb.bindings.len() == 0u;\n         let r <- f();\n-        rollback_to(self.vb, 0u);\n+        rollback_to(self.tvb, 0u);\n         rollback_to(self.rb, 0u);\n         ret r;\n     }\n@@ -932,7 +934,7 @@ impl methods for resolve_state {\n             // tend to carry more restrictions or higher\n             // perf. penalties, so it pays to know more.\n \n-            let {root:_, bounds} = self.infcx.get(self.infcx.vb, vid);\n+            let {root:_, bounds} = self.infcx.get(self.infcx.tvb, vid);\n             let t1 = alt bounds {\n               { ub:_, lb:some(t) } if !type_is_bot(t) { self.resolve1(t) }\n               { ub:some(t), lb:_ } { self.resolve1(t) }\n@@ -1025,21 +1027,21 @@ impl assignment for infer_ctxt {\n           }\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-            let {root:_, bounds: a_bounds} = self.get(self.vb, a_id);\n-            let {root:_, bounds: b_bounds} = self.get(self.vb, b_id);\n+            let {root:_, bounds: a_bounds} = self.get(self.tvb, a_id);\n+            let {root:_, bounds: b_bounds} = self.get(self.tvb, b_id);\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n             self.assign_tys_or_sub(anmnt, a, b, a_bnd, b_bnd)\n           }\n \n           (ty::ty_var(a_id), _) {\n-            let {root:_, bounds:a_bounds} = self.get(self.vb, a_id);\n+            let {root:_, bounds:a_bounds} = self.get(self.tvb, a_id);\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             self.assign_tys_or_sub(anmnt, a, b, a_bnd, some(b))\n           }\n \n           (_, ty::ty_var(b_id)) {\n-            let {root:_, bounds: b_bounds} = self.get(self.vb, b_id);\n+            let {root:_, bounds: b_bounds} = self.get(self.tvb, b_id);\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n             self.assign_tys_or_sub(anmnt, a, b, some(a), b_bnd)\n           }\n@@ -1632,13 +1634,13 @@ impl of combine for sub {\n                 ok(a)\n               }\n               (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-                self.infcx().vars(self.vb, a_id, b_id).then {|| ok(a) }\n+                self.infcx().vars(self.tvb, a_id, b_id).then {|| ok(a) }\n               }\n               (ty::ty_var(a_id), _) {\n-                self.infcx().vart(self.vb, a_id, b).then {|| ok(a) }\n+                self.infcx().vart(self.tvb, a_id, b).then {|| ok(a) }\n               }\n               (_, ty::ty_var(b_id)) {\n-                self.infcx().tvar(self.vb, a, b_id).then {|| ok(a) }\n+                self.infcx().tvar(self.tvb, a, b_id).then {|| ok(a) }\n               }\n               (_, ty::ty_bot) {\n                 err(ty::terr_sorts(b, a))\n@@ -2148,18 +2150,18 @@ fn lattice_tys<L:lattice_ops combine>(\n           (_, ty::ty_bot) { self.ty_bot(a) }\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-            lattice_vars(self, self.infcx().vb,\n+            lattice_vars(self, self.infcx().tvb,\n                          a, a_id, b_id,\n                          {|x, y| self.tys(x, y) })\n           }\n \n           (ty::ty_var(a_id), _) {\n-            lattice_var_t(self, self.infcx().vb, a_id, b,\n+            lattice_var_t(self, self.infcx().tvb, a_id, b,\n                           {|x, y| self.tys(x, y) })\n           }\n \n           (_, ty::ty_var(b_id)) {\n-            lattice_var_t(self, self.infcx().vb, b_id, a,\n+            lattice_var_t(self, self.infcx().tvb, b_id, a,\n                           {|x, y| self.tys(x, y) })\n           }\n "}, {"sha": "60f4ea8dabffa3a3f1e9d38b2592144d0ced239f", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0755529e729e2e85c30ad45131cd15eea5f04f/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=7d0755529e729e2e85c30ad45131cd15eea5f04f", "patch": "@@ -194,6 +194,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n                   f.output, f.ret_style, f.constraints)\n       }\n       ty_var(v) { v.to_str() }\n+      ty_var_integral(v) { v.to_str() }\n       ty_param(id, _) {\n         \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }"}]}