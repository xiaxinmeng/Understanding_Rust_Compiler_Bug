{"sha": "ce4b75f25662cb9facafc4bef368410a2979b936", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNGI3NWYyNTY2MmNiOWZhY2FmYzRiZWYzNjg0MTBhMjk3OWI5MzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-12T18:25:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-12T18:25:08Z"}, "message": "Auto merge of #30726 - GuillaumeGomez:compile-fail, r=brson\n\nr? @brson\ncc @alexcrichton\n\nI still need to add error code explanation test with this, but I can't figure out a way to generate the `.md` files in order to test example source codes.\n\nWill fix #27328.", "tree": {"sha": "bb9b8f3108be17873705c39eadaadf43e7416c9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb9b8f3108be17873705c39eadaadf43e7416c9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce4b75f25662cb9facafc4bef368410a2979b936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4b75f25662cb9facafc4bef368410a2979b936", "html_url": "https://github.com/rust-lang/rust/commit/ce4b75f25662cb9facafc4bef368410a2979b936", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce4b75f25662cb9facafc4bef368410a2979b936/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c4d81f9bc9bb39963ded050b821347ae214d734", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c4d81f9bc9bb39963ded050b821347ae214d734", "html_url": "https://github.com/rust-lang/rust/commit/0c4d81f9bc9bb39963ded050b821347ae214d734"}, {"sha": "eb7664b445d4c2a44e31b6557931dda88e7dd071", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb7664b445d4c2a44e31b6557931dda88e7dd071", "html_url": "https://github.com/rust-lang/rust/commit/eb7664b445d4c2a44e31b6557931dda88e7dd071"}], "stats": {"total": 1632, "additions": 1072, "deletions": 560}, "files": [{"sha": "7f73b99863f093fe349962a1b67a72fc159d6f94", "filename": "mk/docs.mk", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -62,6 +62,7 @@ RUSTBOOK = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(RUSTBOOK_EXE)\n # The error-index-generator executable...\n ERR_IDX_GEN_EXE = $(HBIN2_H_$(CFG_BUILD))/error-index-generator$(X_$(CFG_BUILD))\n ERR_IDX_GEN = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(ERR_IDX_GEN_EXE)\n+ERR_IDX_GEN_MD = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(ERR_IDX_GEN_EXE) markdown\n \n D := $(S)src/doc\n \n@@ -217,6 +218,12 @@ doc/style/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/style/*.md) | doc/\n \n error-index: doc/error-index.html\n \n-doc/error-index.html: $(ERR_IDX_GEN_EXE) | doc/\n+# Metadata used to generate the index is created as a side effect of\n+# the build so this depends on every crate being up to date.\n+doc/error-index.html: $(ERR_IDX_GEN_EXE) $(CSREQ$(2)_T_$(CFG_BUILD)_H_$(CFG_BUILD)) | doc/\n \t$(Q)$(call E, error-index-generator: $@)\n \t$(Q)$(ERR_IDX_GEN)\n+\n+doc/error-index.md: $(ERR_IDX_GEN_EXE) $(CSREQ$(2)_T_$(CFG_BUILD)_H_$(CFG_BUILD)) | doc/\n+\t$(Q)$(call E, error-index-generator: $@)\n+\t$(Q)$(ERR_IDX_GEN_MD)"}, {"sha": "2e530095cbe1c92d5b38df47b229f686b02965ea", "filename": "mk/tests.mk", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -298,14 +298,14 @@ check-stage$(1)-T-$(2)-H-$(3)-exec: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rfail-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-cfail-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pfail-exec \\\n-    check-stage$(1)-T-$(2)-H-$(3)-rpass-valgrind-exec \\\n-    check-stage$(1)-T-$(2)-H-$(3)-rpass-full-exec \\\n-    check-stage$(1)-T-$(2)-H-$(3)-rfail-full-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-rpass-valgrind-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-rpass-full-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-rfail-full-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-cfail-full-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rmake-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rustdocck-exec \\\n-        check-stage$(1)-T-$(2)-H-$(3)-crates-exec \\\n-        check-stage$(1)-T-$(2)-H-$(3)-doc-crates-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-crates-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-doc-crates-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-debuginfo-gdb-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-debuginfo-lldb-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-codegen-exec \\\n@@ -673,8 +673,8 @@ CTEST_DEPS_debuginfo-lldb_$(1)-T-$(2)-H-$(3) = $$(DEBUGINFO_LLDB_TESTS) \\\n CTEST_DEPS_codegen_$(1)-T-$(2)-H-$(3) = $$(CODEGEN_TESTS)\n CTEST_DEPS_codegen-units_$(1)-T-$(2)-H-$(3) = $$(CODEGEN_UNITS_TESTS)\n CTEST_DEPS_rustdocck_$(1)-T-$(2)-H-$(3) = $$(RUSTDOCCK_TESTS) \\\n-        $$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n-\t$(S)src/etc/htmldocck.py\n+\t\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n+\t\t$(S)src/etc/htmldocck.py\n \n endef\n \n@@ -892,6 +892,28 @@ $(foreach host,$(CFG_HOST), \\\n    $(foreach crate,$(TEST_DOC_CRATES), \\\n     $(eval $(call DEF_CRATE_DOC_TEST,$(stage),$(target),$(host),$(crate)))))))\n \n+define DEF_DOC_TEST_ERROR_INDEX\n+\n+check-stage$(1)-T-$(2)-H-$(3)-doc-error-index-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-error-index)\n+\n+ifeq ($(2),$$(CFG_BUILD))\n+$$(call TEST_OK_FILE,$(1),$(2),$(3),doc-error-index): \\\n+\t\t$$(TEST_SREQ$(1)_T_$(2)_H_$(3)) \\\n+\t\tdoc/error-index.md\n+\t$$(Q)touch $$@.start_time\n+\t$$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --test doc/error-index.md\n+\t$$(Q)touch -r $$@.start_time $$@ && rm $$@.start_time\n+else\n+$$(call TEST_OK_FILE,$(1),$(2),$(3),doc-error-index):\n+\t$$(Q)touch $$@\n+endif\n+endef\n+\n+$(foreach host,$(CFG_HOST), \\\n+ $(foreach target,$(CFG_TARGET), \\\n+  $(foreach stage,$(STAGES), \\\n+   $(eval $(call DEF_DOC_TEST_ERROR_INDEX,$(stage),$(target),$(host))))))\n+\n ######################################################################\n # Shortcut rules\n ######################################################################\n@@ -901,7 +923,7 @@ TEST_GROUPS = \\\n \t$(foreach crate,$(TEST_CRATES),$(crate)) \\\n \t$(foreach crate,$(TEST_DOC_CRATES),doc-crate-$(crate)) \\\n \trpass \\\n-    rpass-valgrind \\\n+\trpass-valgrind \\\n \trpass-full \\\n \trfail-full \\\n \tcfail-full \\\n@@ -918,7 +940,7 @@ TEST_GROUPS = \\\n \t$(foreach docname,$(DOC_NAMES),doc-$(docname)) \\\n \tpretty \\\n \tpretty-rpass \\\n-    pretty-rpass-valgrind \\\n+\tpretty-rpass-valgrind \\\n \tpretty-rpass-full \\\n \tpretty-rfail-full \\\n \tpretty-rfail \\\n@@ -987,7 +1009,8 @@ define DEF_CHECK_DOC_FOR_STAGE\n check-stage$(1)-docs: $$(foreach docname,$$(DOC_NAMES), \\\n                        check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-$$(docname)) \\\n                      $$(foreach crate,$$(TEST_DOC_CRATES), \\\n-                       check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-crate-$$(crate))\n+                       check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-crate-$$(crate)) \\\n+                     check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-error-index-exec\n endef\n \n $(foreach stage,$(STAGES), \\"}, {"sha": "db9dd006f3c86f494123ea0ee68b9577328a69cf", "filename": "src/error-index-generator/main.rs", "status": "modified", "additions": 120, "deletions": 34, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Ferror-index-generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Ferror-index-generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror-index-generator%2Fmain.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -21,37 +21,41 @@ use std::env;\n use std::path::Path;\n use std::error::Error;\n \n-use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap};\n+use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n use rustdoc::html::markdown::Markdown;\n use rustc_serialize::json;\n \n-/// Load all the metadata files from `metadata_dir` into an in-memory map.\n-fn load_all_errors(metadata_dir: &Path) -> Result<ErrorMetadataMap, Box<Error>> {\n-    let mut all_errors = BTreeMap::new();\n-\n-    for entry in try!(read_dir(metadata_dir)) {\n-        let path = try!(entry).path();\n-\n-        let mut metadata_str = String::new();\n-        try!(File::open(&path).and_then(|mut f| f.read_to_string(&mut metadata_str)));\n-\n-        let some_errors: ErrorMetadataMap = try!(json::decode(&metadata_str));\n+enum OutputFormat {\n+    HTML(HTMLFormatter),\n+    Markdown(MarkdownFormatter),\n+    Unknown(String),\n+}\n \n-        for (err_code, info) in some_errors {\n-            all_errors.insert(err_code, info);\n+impl OutputFormat {\n+    fn from(format: &str) -> OutputFormat {\n+        match &*format.to_lowercase() {\n+            \"html\"     => OutputFormat::HTML(HTMLFormatter),\n+            \"markdown\" => OutputFormat::Markdown(MarkdownFormatter),\n+            s          => OutputFormat::Unknown(s.to_owned()),\n         }\n     }\n+}\n \n-    Ok(all_errors)\n+trait Formatter {\n+    fn header(&self, output: &mut Write) -> Result<(), Box<Error>>;\n+    fn title(&self, output: &mut Write) -> Result<(), Box<Error>>;\n+    fn error_code_block(&self, output: &mut Write, info: &ErrorMetadata,\n+                        err_code: &str) -> Result<(), Box<Error>>;\n+    fn footer(&self, output: &mut Write) -> Result<(), Box<Error>>;\n }\n \n-/// Output an HTML page for the errors in `err_map` to `output_path`.\n-fn render_error_page(err_map: &ErrorMetadataMap, output_path: &Path) -> Result<(), Box<Error>> {\n-    let mut output_file = try!(File::create(output_path));\n+struct HTMLFormatter;\n+struct MarkdownFormatter;\n \n-    try!(write!(&mut output_file,\n-r##\"<!DOCTYPE html>\n+impl Formatter for HTMLFormatter {\n+    fn header(&self, output: &mut Write) -> Result<(), Box<Error>> {\n+        try!(write!(output, r##\"<!DOCTYPE html>\n <html>\n <head>\n <title>Rust Compiler Error Index</title>\n@@ -66,12 +70,17 @@ r##\"<!DOCTYPE html>\n </style>\n </head>\n <body>\n-\"##\n-    ));\n+\"##));\n+        Ok(())\n+    }\n \n-    try!(write!(&mut output_file, \"<h1>Rust Compiler Error Index</h1>\\n\"));\n+    fn title(&self, output: &mut Write) -> Result<(), Box<Error>> {\n+        try!(write!(output, \"<h1>Rust Compiler Error Index</h1>\\n\"));\n+        Ok(())\n+    }\n \n-    for (err_code, info) in err_map {\n+    fn error_code_block(&self, output: &mut Write, info: &ErrorMetadata,\n+                        err_code: &str) -> Result<(), Box<Error>> {\n         // Enclose each error in a div so they can be shown/hidden en masse.\n         let desc_desc = match info.description {\n             Some(_) => \"error-described\",\n@@ -81,37 +90,114 @@ r##\"<!DOCTYPE html>\n             Some(_) => \"error-used\",\n             None => \"error-unused\",\n         };\n-        try!(write!(&mut output_file, \"<div class=\\\"{} {}\\\">\", desc_desc, use_desc));\n+        try!(write!(output, \"<div class=\\\"{} {}\\\">\", desc_desc, use_desc));\n \n         // Error title (with self-link).\n-        try!(write!(&mut output_file,\n+        try!(write!(output,\n                     \"<h2 id=\\\"{0}\\\" class=\\\"section-header\\\"><a href=\\\"#{0}\\\">{0}</a></h2>\\n\",\n                     err_code));\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => try!(write!(&mut output_file, \"{}\", Markdown(desc))),\n-            None => try!(write!(&mut output_file, \"<p>No description.</p>\\n\")),\n+            Some(ref desc) => try!(write!(output, \"{}\", Markdown(desc))),\n+            None => try!(write!(output, \"<p>No description.</p>\\n\")),\n         }\n \n-        try!(write!(&mut output_file, \"</div>\\n\"));\n+        try!(write!(output, \"</div>\\n\"));\n+        Ok(())\n     }\n \n-    try!(write!(&mut output_file, \"</body>\\n</html>\"));\n+    fn footer(&self, output: &mut Write) -> Result<(), Box<Error>> {\n+        try!(write!(output, \"</body>\\n</html>\"));\n+        Ok(())\n+    }\n+}\n \n-    Ok(())\n+impl Formatter for MarkdownFormatter {\n+    #[allow(unused_variables)]\n+    fn header(&self, output: &mut Write) -> Result<(), Box<Error>> {\n+        Ok(())\n+    }\n+\n+    fn title(&self, output: &mut Write) -> Result<(), Box<Error>> {\n+        try!(write!(output, \"# Rust Compiler Error Index\\n\"));\n+        Ok(())\n+    }\n+\n+    fn error_code_block(&self, output: &mut Write, info: &ErrorMetadata,\n+                        err_code: &str) -> Result<(), Box<Error>> {\n+        Ok(match info.description {\n+            Some(ref desc) => try!(write!(output, \"## {}\\n{}\\n\", err_code, desc)),\n+            None => (),\n+        })\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn footer(&self, output: &mut Write) -> Result<(), Box<Error>> {\n+        Ok(())\n+    }\n+}\n+\n+/// Load all the metadata files from `metadata_dir` into an in-memory map.\n+fn load_all_errors(metadata_dir: &Path) -> Result<ErrorMetadataMap, Box<Error>> {\n+    let mut all_errors = BTreeMap::new();\n+\n+    for entry in try!(read_dir(metadata_dir)) {\n+        let path = try!(entry).path();\n+\n+        let mut metadata_str = String::new();\n+        try!(File::open(&path).and_then(|mut f| f.read_to_string(&mut metadata_str)));\n+\n+        let some_errors: ErrorMetadataMap = try!(json::decode(&metadata_str));\n+\n+        for (err_code, info) in some_errors {\n+            all_errors.insert(err_code, info);\n+        }\n+    }\n+\n+    Ok(all_errors)\n+}\n+\n+/// Output an HTML page for the errors in `err_map` to `output_path`.\n+fn render_error_page<T: Formatter>(err_map: &ErrorMetadataMap, output_path: &Path,\n+                                   formatter: T) -> Result<(), Box<Error>> {\n+    let mut output_file = try!(File::create(output_path));\n+\n+    try!(formatter.header(&mut output_file));\n+    try!(formatter.title(&mut output_file));\n+\n+    for (err_code, info) in err_map {\n+        try!(formatter.error_code_block(&mut output_file, info, err_code));\n+    }\n+\n+    formatter.footer(&mut output_file)\n }\n \n-fn main_with_result() -> Result<(), Box<Error>> {\n+fn main_with_result(format: OutputFormat) -> Result<(), Box<Error>> {\n     let build_arch = try!(env::var(\"CFG_BUILD\"));\n     let metadata_dir = get_metadata_dir(&build_arch);\n     let err_map = try!(load_all_errors(&metadata_dir));\n-    try!(render_error_page(&err_map, Path::new(\"doc/error-index.html\")));\n+    match format {\n+        OutputFormat::Unknown(s)  => panic!(\"Unknown output format: {}\", s),\n+        OutputFormat::HTML(h)     => try!(render_error_page(&err_map,\n+                                                            Path::new(\"doc/error-index.html\"),\n+                                                            h)),\n+        OutputFormat::Markdown(m) => try!(render_error_page(&err_map,\n+                                                            Path::new(\"doc/error-index.md\"),\n+                                                            m)),\n+    }\n     Ok(())\n }\n \n+fn parse_args() -> OutputFormat {\n+    for arg in env::args().skip(1) {\n+        return OutputFormat::from(&arg);\n+    }\n+    OutputFormat::from(\"html\")\n+}\n+\n fn main() {\n-    if let Err(e) = main_with_result() {\n+    if let Err(e) = main_with_result(parse_args()) {\n         panic!(\"{}\", e.description());\n     }\n }"}, {"sha": "8a9ef666b838468405119dc9a397d0b5a7710d85", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 208, "deletions": 120, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -25,7 +25,7 @@ is too specific or the ordering is incorrect.\n \n For example, the following `match` block has too many arms:\n \n-```\n+```compile_fail\n match foo {\n     Some(bar) => {/* ... */}\n     None => {/* ... */}\n@@ -50,6 +50,8 @@ one or more cases to the match expression.\n An example of an empty type is `enum Empty { }`. So, the following will work:\n \n ```\n+enum Empty {}\n+\n fn foo(x: Empty) {\n     match x {\n         // empty\n@@ -59,7 +61,9 @@ fn foo(x: Empty) {\n \n However, this won't:\n \n-```\n+```compile_fail\n+enum Empty {}\n+\n fn foo(x: Option<String>) {\n     match x {\n         // empty\n@@ -72,23 +76,26 @@ E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n match the input to a match expression. So, the following will not compile:\n \n-```\n+```compile_fail\n const NAN: f32 = 0.0 / 0.0;\n \n+let number = 0.1f32;\n+\n match number {\n     NAN => { /* ... */ },\n-    // ...\n+    _ => {}\n }\n ```\n \n To match against NaN values, you should instead use the `is_nan()` method in a\n guard, like so:\n \n ```\n+let number = 0.1f32;\n+\n match number {\n-    // ...\n     x if x.is_nan() => { /* ... */ }\n-    // ...\n+    _ => {}\n }\n ```\n \"##,\n@@ -120,15 +127,16 @@ the following is invalid as it requires the entire `Option<String>` to be moved\n into a variable called `op_string` while simultaneously requiring the inner\n String to be moved into a variable called `s`.\n \n-```\n+```compile_fail\n let x = Some(\"s\".to_string());\n+\n match x {\n-    op_string @ Some(s) => ...\n-    None => ...\n+    op_string @ Some(s) => {},\n+    None => {},\n }\n ```\n \n-See also Error 303.\n+See also the error E0303.\n \"##,\n \n E0008: r##\"\n@@ -137,10 +145,10 @@ name is bound by move in a pattern, it should also be moved to wherever it is\n referenced in the pattern guard code. Doing so however would prevent the name\n from being available in the body of the match arm. Consider the following:\n \n-```\n+```compile_fail\n match Some(\"hi\".to_string()) {\n-    Some(s) if s.len() == 0 => // use s.\n-    ...\n+    Some(s) if s.len() == 0 => {}, // use s.\n+    _ => {},\n }\n ```\n \n@@ -151,11 +159,11 @@ therefore become unavailable in the body of the arm. Although this example seems\n innocuous, the problem is most clear when considering functions that take their\n argument by value.\n \n-```\n+```compile_fail\n match Some(\"hi\".to_string()) {\n     Some(s) if { drop(s); false } => (),\n-    Some(s) => // use s.\n-    ...\n+    Some(s) => {}, // use s.\n+    _ => {},\n }\n ```\n \n@@ -174,7 +182,7 @@ This limitation may be removed in a future version of Rust.\n \n Wrong example:\n \n-```\n+```compile_fail\n struct X { x: (), }\n \n let x = Some((X { x: () }, X { x: () }));\n@@ -220,7 +228,7 @@ This error indicates that an attempt was made to divide by zero (or take the\n remainder of a zero divisor) in a static or constant expression. Erroneous\n code example:\n \n-```\n+```compile_fail\n const X: i32 = 42 / 0;\n // error: attempted to divide by zero in a constant expression\n ```\n@@ -267,7 +275,7 @@ this restriction.\n \n This happens when a trait has a method like the following:\n \n-```\n+```compile_fail\n trait Trait {\n     fn foo(&self) -> Self;\n }\n@@ -291,7 +299,11 @@ cause this problem)\n In such a case, the compiler cannot predict the return type of `foo()` in a\n situation like the following:\n \n-```\n+```compile_fail\n+trait Trait {\n+    fn foo(&self) -> Self;\n+}\n+\n fn call_foo(x: Box<Trait>) {\n     let y = x.foo(); // What type is y?\n     // ...\n@@ -324,11 +336,13 @@ have:\n trait Trait {\n     fn foo(&self);\n }\n+\n impl Trait for String {\n     fn foo(&self) {\n         // implementation 1\n     }\n }\n+\n impl Trait for u8 {\n     fn foo(&self) {\n         // implementation 2\n@@ -351,7 +365,7 @@ fn foo<T>(x: T) {\n }\n ```\n \n-the machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\n+The machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\n other type substitution is different. Hence the compiler generates the\n implementation on-demand. If you call `foo()` with a `bool` parameter, the\n compiler will only generate code for `foo::<bool>()`. When we have additional\n@@ -373,30 +387,33 @@ trait Trait {\n     fn foo<T>(&self, on: T);\n     // more methods\n }\n+\n impl Trait for String {\n     fn foo<T>(&self, on: T) {\n         // implementation 1\n     }\n }\n+\n impl Trait for u8 {\n     fn foo<T>(&self, on: T) {\n         // implementation 2\n     }\n }\n+\n // 8 more implementations\n ```\n \n Now, if we have the following code:\n \n-```\n+```ignore\n fn call_foo(thing: Box<Trait>) {\n     thing.foo(true); // this could be any one of the 8 types above\n     thing.foo(1);\n     thing.foo(\"hello\");\n }\n ```\n \n-we don't just need to create a table of all implementations of all methods of\n+We don't just need to create a table of all implementations of all methods of\n `Trait`, we need to create such a table, for each different type fed to\n `foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\n types being fed to `foo()`) = 30 implementations!\n@@ -422,7 +439,7 @@ out the methods of different types.\n ### Method has no receiver\n \n Methods that do not take a `self` parameter can't be called since there won't be\n-a way to get a pointer to the method table for them\n+a way to get a pointer to the method table for them.\n \n ```\n trait Foo {\n@@ -446,7 +463,7 @@ trait Foo {\n This is similar to the second sub-error, but subtler. It happens in situations\n like the following:\n \n-```\n+```compile_fail\n trait Super<A> {}\n \n trait Trait: Super<Self> {\n@@ -488,7 +505,7 @@ the pointer the size of the type would need to be unbounded.\n \n Consider the following erroneous definition of a type for a list of bytes:\n \n-```\n+```compile_fail\n // error, invalid recursive struct type\n struct ListNode {\n     head: u8,\n@@ -521,7 +538,7 @@ E0109: r##\"\n You tried to give a type parameter to a type which doesn't need it. Erroneous\n code example:\n \n-```\n+```compile_fail\n type X = u32<i32>; // error: type parameters are not allowed on this type\n ```\n \n@@ -542,7 +559,7 @@ E0110: r##\"\n You tried to give a lifetime parameter to a type which doesn't need it.\n Erroneous code example:\n \n-```\n+```compile_fail\n type X = u32<'static>; // error: lifetime parameters are not allowed on\n                        //        this type\n ```\n@@ -605,8 +622,8 @@ parameters are involved, this cannot always be done.\n \n So, for example, the following is not allowed:\n \n-```\n-struct Foo<T>(Vec<T>)\n+```compile_fail\n+struct Foo<T>(Vec<T>);\n \n fn foo<T>(x: Vec<T>) {\n     // we are transmuting between Vec<T> and Foo<T> here\n@@ -631,21 +648,25 @@ If it's possible, hand-monomorphize the code by writing the function for each\n possible type substitution. It's possible to use traits to do this cleanly,\n for example:\n \n-```\n+```ignore\n+struct Foo<T>(Vec<T>);\n+\n trait MyTransmutableType {\n-    fn transmute(Vec<Self>) -> Foo<Self>\n+    fn transmute(Vec<Self>) -> Foo<Self>;\n }\n \n impl MyTransmutableType for u8 {\n     fn transmute(x: Foo<u8>) -> Vec<u8> {\n         transmute(x)\n     }\n }\n+\n impl MyTransmutableType for String {\n     fn transmute(x: Foo<String>) -> Vec<String> {\n         transmute(x)\n     }\n }\n+\n // ... more impls for the types you intend to transmute\n \n fn foo<T: MyTransmutableType>(x: Vec<T>) {\n@@ -660,7 +681,7 @@ is a size mismatch in one of the impls.\n \n It is also possible to manually transmute:\n \n-```\n+```ignore\n ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n ```\n \n@@ -696,9 +717,10 @@ If you want to match against a `static`, consider using a guard instead:\n \n ```\n static FORTY_TWO: i32 = 42;\n+\n match Some(42) {\n-    Some(x) if x == FORTY_TWO => ...\n-    ...\n+    Some(x) if x == FORTY_TWO => {}\n+    _ => {}\n }\n ```\n \"##,\n@@ -708,7 +730,7 @@ An if-let pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding instead. For instance:\n \n-```\n+```compile_fail\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n@@ -717,8 +739,14 @@ if let Irrefutable(x) = irr {\n     // This body will always be executed.\n     foo(x);\n }\n+```\n+\n+Try this instead:\n+\n+```ignore\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n \n-// Try this instead:\n let Irrefutable(x) = irr;\n foo(x);\n ```\n@@ -729,7 +757,7 @@ A while-let pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding inside a `loop` instead. For instance:\n \n-```\n+```compile_fail\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n@@ -738,7 +766,12 @@ while let Irrefutable(x) = irr {\n     ...\n }\n \n-// Try this instead:\n+Try this instead:\n+\n+```\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n loop {\n     let Irrefutable(x) = irr;\n     ...\n@@ -752,16 +785,23 @@ Enum variants are qualified by default. For example, given this type:\n ```\n enum Method {\n     GET,\n-    POST\n+    POST,\n }\n ```\n \n-you would match it using:\n+You would match it using:\n \n ```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+\n+let m = Method::GET;\n+\n match m {\n-    Method::GET => ...\n-    Method::POST => ...\n+    Method::GET => {},\n+    Method::POST => {},\n }\n ```\n \n@@ -772,15 +812,15 @@ that happens.\n Qualified names are good practice, and most code works well with them. But if\n you prefer them unqualified, you can import the variants into scope:\n \n-```\n+```ignore\n use Method::*;\n enum Method { GET, POST }\n ```\n \n If you want others to be able to import variants from your module directly, use\n `pub use`:\n \n-```\n+```ignore\n pub use Method::*;\n enum Method { GET, POST }\n ```\n@@ -790,7 +830,7 @@ E0229: r##\"\n An associated type binding was done outside of the type parameter declaration\n and `where` clause. Erroneous code example:\n \n-```\n+```compile_fail\n pub trait Foo {\n     type A;\n     fn boo(&self) -> <Self as Foo>::A;\n@@ -810,13 +850,13 @@ fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\n To solve this error, please move the type bindings in the type parameter\n declaration:\n \n-```\n+```ignore\n fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\n ```\n \n-or in the `where` clause:\n+Or in the `where` clause:\n \n-```\n+```ignore\n fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n ```\n \"##,\n@@ -827,7 +867,7 @@ used.\n \n These two examples illustrate the problem:\n \n-```\n+```compile_fail\n // error, use of undeclared lifetime name `'a`\n fn foo(x: &'a str) { }\n \n@@ -840,7 +880,7 @@ struct Foo {\n These can be fixed by declaring lifetime parameters:\n \n ```\n-fn foo<'a>(x: &'a str) { }\n+fn foo<'a>(x: &'a str) {}\n \n struct Foo<'a> {\n     x: &'a str,\n@@ -853,7 +893,7 @@ Declaring certain lifetime names in parameters is disallowed. For example,\n because the `'static` lifetime is a special built-in lifetime name denoting\n the lifetime of the entire program, this is an error:\n \n-```\n+```compile_fail\n // error, invalid lifetime parameter name `'static`\n fn foo<'static>(x: &'static str) { }\n ```\n@@ -863,7 +903,7 @@ E0263: r##\"\n A lifetime name cannot be declared more than once in the same scope. For\n example:\n \n-```\n+```compile_fail\n // error, lifetime name `'a` declared twice in the same scope\n fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }\n ```\n@@ -872,7 +912,7 @@ fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }\n E0264: r##\"\n An unknown external lang item was used. Erroneous code example:\n \n-```\n+```compile_fail\n #![feature(lang_items)]\n \n extern \"C\" {\n@@ -896,9 +936,9 @@ extern \"C\" {\n \n E0269: r##\"\n Functions must eventually return a value of their return type. For example, in\n-the following function\n+the following function:\n \n-```\n+```compile_fail\n fn foo(x: u8) -> u8 {\n     if x > 0 {\n         x // alternatively, `return x`\n@@ -907,15 +947,15 @@ fn foo(x: u8) -> u8 {\n }\n ```\n \n-if the condition is true, the value `x` is returned, but if the condition is\n+If the condition is true, the value `x` is returned, but if the condition is\n false, control exits the `if` block and reaches a place where nothing is being\n returned. All possible control paths must eventually return a `u8`, which is not\n happening here.\n \n An easy fix for this in a complicated function is to specify a default return\n value, if possible:\n \n-```\n+```ignore\n fn foo(x: u8) -> u8 {\n     if x > 0 {\n         x // alternatively, `return x`\n@@ -935,7 +975,7 @@ Rust lets you define functions which are known to never return, i.e. are\n \n For example, the following functions never return:\n \n-```\n+```no_run\n fn foo() -> ! {\n     loop {}\n }\n@@ -947,18 +987,24 @@ fn bar() -> ! {\n fn baz() -> ! {\n     panic!(); // this macro internally expands to a call to a diverging function\n }\n-\n ```\n \n Such functions can be used in a place where a value is expected without\n-returning a value of that type,  for instance:\n+returning a value of that type, for instance:\n+\n+```no_run\n+fn foo() -> ! {\n+    loop {}\n+}\n+\n+let x = 3;\n \n-```\n let y = match x {\n     1 => 1,\n     2 => 4,\n     _ => foo() // diverging function called here\n };\n+\n println!(\"{}\", y)\n ```\n \n@@ -967,22 +1013,29 @@ return control to the match block, it is fine to use it in a place where an\n integer was expected. The `match` block will never finish executing, and any\n point where `y` (like the print statement) is needed will not be reached.\n \n-However, if we had a diverging function that actually does finish execution\n+However, if we had a diverging function that actually does finish execution:\n \n-```\n-fn foo() -> {\n+```ignore\n+fn foo() -> ! {\n     loop {break;}\n }\n ```\n \n-then we would have an unknown value for `y` in the following code:\n+Then we would have an unknown value for `y` in the following code:\n+\n+```no_run\n+fn foo() -> ! {\n+    loop {}\n+}\n+\n+let x = 3;\n \n-```\n let y = match x {\n     1 => 1,\n     2 => 4,\n     _ => foo()\n };\n+\n println!(\"{}\", y);\n ```\n \n@@ -1004,18 +1057,21 @@ Examples follow.\n \n Here is a basic example:\n \n-```\n+```compile_fail\n trait Trait { type AssociatedType; }\n+\n fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n     println!(\"in foo\");\n }\n+\n impl Trait for i8 { type AssociatedType = &'static str; }\n+\n foo(3_i8);\n ```\n \n Here is that same example again, with some explanatory comments:\n \n-```\n+```ignore\n trait Trait { type AssociatedType; }\n \n fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n@@ -1053,12 +1109,12 @@ foo(3_i8);\n Here is a more subtle instance of the same problem, that can\n arise with for-loops in Rust:\n \n-```\n+```compile_fail\n let vs: Vec<i32> = vec![1, 2, 3, 4];\n for v in &vs {\n     match v {\n-        1 => {}\n-        _ => {}\n+        1 => {},\n+        _ => {},\n     }\n }\n ```\n@@ -1067,7 +1123,7 @@ The above fails because of an analogous type mismatch,\n though may be harder to see. Again, here are some\n explanatory comments for the same example:\n \n-```\n+```ignore\n {\n     let vs = vec![1, 2, 3, 4];\n \n@@ -1115,10 +1171,13 @@ So we can fix the previous examples like this:\n ```\n // Basic Example:\n trait Trait { type AssociatedType; }\n+\n fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n     println!(\"in foo\");\n }\n+\n impl Trait for i8 { type AssociatedType = &'static str; }\n+\n foo(3_i8);\n \n // For-Loop Example:\n@@ -1138,7 +1197,7 @@ message for when a particular trait isn't implemented on a type placed in a\n position that needs that trait. For example, when the following code is\n compiled:\n \n-```\n+```compile_fail\n fn foo<T: Index<u8>>(x: T){}\n \n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n@@ -1168,7 +1227,7 @@ message for when a particular trait isn't implemented on a type placed in a\n position that needs that trait. For example, when the following code is\n compiled:\n \n-```\n+```compile_fail\n fn foo<T: Index<u8>>(x: T){}\n \n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n@@ -1196,7 +1255,7 @@ message for when a particular trait isn't implemented on a type placed in a\n position that needs that trait. For example, when the following code is\n compiled:\n \n-```\n+```compile_fail\n fn foo<T: Index<u8>>(x: T){}\n \n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n@@ -1218,17 +1277,17 @@ This error occurs when there was a recursive trait requirement that overflowed\n before it could be evaluated. Often this means that there is unbounded recursion\n in resolving some type bounds.\n \n-For example, in the following code\n+For example, in the following code:\n \n-```\n+```compile_fail\n trait Foo {}\n \n struct Bar<T>(T);\n \n impl<T> Foo for T where Bar<T>: Foo {}\n ```\n \n-to determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n+To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To determine\n this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is clearly a\n recursive requirement that can't be resolved directly.\n@@ -1240,13 +1299,13 @@ E0276: r##\"\n This error occurs when a bound in an implementation of a trait does not match\n the bounds specified in the original trait. For example:\n \n-```\n+```compile_fail\n trait Foo {\n- fn foo<T>(x: T);\n+    fn foo<T>(x: T);\n }\n \n impl Foo for bool {\n- fn foo<T>(x: T) where T: Copy {}\n+    fn foo<T>(x: T) where T: Copy {}\n }\n ```\n \n@@ -1262,7 +1321,7 @@ E0277: r##\"\n You tried to use a type which doesn't implement some trait in a place which\n expected that trait. Erroneous code example:\n \n-```\n+```compile_fail\n // here we declare the Foo trait with a bar method\n trait Foo {\n     fn bar(&self);\n@@ -1310,7 +1369,7 @@ You tried to supply a type which doesn't implement some trait in a location\n which expected that trait. This error typically occurs when working with\n `Fn`-based types. Erroneous code example:\n \n-```\n+```compile_fail\n fn foo<F: Fn()>(x: F) { }\n \n fn main() {\n@@ -1336,7 +1395,7 @@ parameter with a `FromIterator` bound, which for a `char` iterator is\n implemented by `Vec` and `String` among others. Consider the following snippet\n that reverses the characters of a string:\n \n-```\n+```compile_fail\n let x = \"hello\".chars().rev().collect();\n ```\n \n@@ -1373,9 +1432,9 @@ occur when a type parameter of a struct or trait cannot be inferred. In that\n case it is not always possible to use a type annotation, because all candidates\n have the same return type. For instance:\n \n-```\n+```compile_fail\n struct Foo<T> {\n-    // Some fields omitted.\n+    num: T,\n }\n \n impl<T> Foo<T> {\n@@ -1399,17 +1458,19 @@ to unambiguously choose an implementation.\n \n For example:\n \n-```\n+```compile_fail\n trait Generator {\n     fn create() -> u32;\n }\n \n struct Impl;\n+\n impl Generator for Impl {\n     fn create() -> u32 { 1 }\n }\n \n struct AnotherImpl;\n+\n impl Generator for AnotherImpl {\n     fn create() -> u32 { 2 }\n }\n@@ -1424,6 +1485,16 @@ fn main() {\n To resolve this error use the concrete type:\n \n ```\n+trait Generator {\n+    fn create() -> u32;\n+}\n+\n+struct AnotherImpl;\n+\n+impl Generator for AnotherImpl {\n+    fn create() -> u32 { 2 }\n+}\n+\n fn main() {\n     let gen1 = AnotherImpl::create();\n \n@@ -1448,24 +1519,36 @@ that a name will be extracted in all cases. Instead of pattern matching the\n loop variable, consider using a `match` or `if let` inside the loop body. For\n instance:\n \n-```\n+```compile_fail\n+let xs : Vec<Option<i32>> = vec!(Some(1), None);\n+\n // This fails because `None` is not covered.\n for Some(x) in xs {\n-    ...\n+    // ...\n }\n+```\n+\n+Match inside the loop instead:\n+\n+```\n+let xs : Vec<Option<i32>> = vec!(Some(1), None);\n \n-// Match inside the loop instead:\n for item in xs {\n     match item {\n-        Some(x) => ...\n-        None => ...\n+        Some(x) => {},\n+        None => {},\n     }\n }\n+```\n+\n+Or use `if let`:\n+\n+```\n+let xs : Vec<Option<i32>> = vec!(Some(1), None);\n \n-// Or use `if let`:\n for item in xs {\n     if let Some(x) = item {\n-        ...\n+        // ...\n     }\n }\n ```\n@@ -1478,7 +1561,7 @@ on which the match depends in such a way, that the match would not be\n exhaustive. For instance, the following would not match any arm if mutable\n borrows were allowed:\n \n-```\n+```compile_fail\n match Some(()) {\n     None => { },\n     option if option.take().is_none() => { /* impossible, option is `Some` */ },\n@@ -1494,7 +1577,7 @@ on which the match depends in such a way, that the match would not be\n exhaustive. For instance, the following would not match any arm if assignments\n were allowed:\n \n-```\n+```compile_fail\n match Some(()) {\n     None => { },\n     option if { option = None; false } { },\n@@ -1508,20 +1591,20 @@ In certain cases it is possible for sub-bindings to violate memory safety.\n Updates to the borrow checker in a future version of Rust may remove this\n restriction, but for now patterns must be rewritten without sub-bindings.\n \n-```\n+```ignore\n // Before.\n match Some(\"hi\".to_string()) {\n-    ref op_string_ref @ Some(ref s) => ...\n-    None => ...\n+    ref op_string_ref @ Some(s) => {},\n+    None => {},\n }\n \n // After.\n match Some(\"hi\".to_string()) {\n     Some(ref s) => {\n         let op_string_ref = &Some(s);\n-        ...\n-    }\n-    None => ...\n+        // ...\n+    },\n+    None => {},\n }\n ```\n \n@@ -1549,7 +1632,7 @@ variable.\n \n For example:\n \n-```\n+```compile_fail\n let x: i32 = \"I am not a number!\";\n //     ~~~   ~~~~~~~~~~~~~~~~~~~~\n //      |             |\n@@ -1562,7 +1645,7 @@ let x: i32 = \"I am not a number!\";\n Another situation in which this occurs is when you attempt to use the `try!`\n macro inside a function that does not return a `Result<T, E>`:\n \n-```\n+```compile_fail\n use std::fs::File;\n \n fn main() {\n@@ -1590,14 +1673,17 @@ how long the data stored within them is guaranteed to be live. This lifetime\n must be as long as the data needs to be alive, and missing the constraint that\n denotes this will cause this error.\n \n-```\n+```compile_fail\n // This won't compile because T is not constrained, meaning the data\n // stored in it is not guaranteed to last as long as the reference\n struct Foo<'a, T> {\n     foo: &'a T\n }\n+```\n+\n+This will compile, because it has the constraint on the type parameter:\n \n-// This will compile, because it has the constraint on the type parameter\n+```\n struct Foo<'a, T: 'a> {\n     foo: &'a T\n }\n@@ -1610,14 +1696,16 @@ how long the data stored within them is guaranteed to be live. This lifetime\n must be as long as the data needs to be alive, and missing the constraint that\n denotes this will cause this error.\n \n-```\n+```compile_fail\n // This won't compile because T is not constrained to the static lifetime\n // the reference needs\n struct Foo<T> {\n     foo: &'static T\n }\n \n-// This will compile, because it has the constraint on the type parameter\n+This will compile, because it has the constraint on the type parameter:\n+\n+```\n struct Foo<T: 'static> {\n     foo: &'static T\n }\n@@ -1644,13 +1732,13 @@ signature of a function that you are calling. For example, if\n the error is reported on a call like `foo(x)`, and `foo` is\n defined as follows:\n \n-```\n+```ignore\n fn foo(arg: &Box<SomeTrait>) { ... }\n ```\n \n-you might change it to:\n+You might change it to:\n \n-```\n+```ignore\n fn foo<'a>(arg: &Box<SomeTrait+'a>) { ... }\n ```\n \n@@ -1663,7 +1751,7 @@ contain references (with a maximum lifetime of `'a`).\n E0452: r##\"\n An invalid lint attribute has been given. Erroneous code example:\n \n-```\n+```compile_fail\n #![allow(foo = \"\")] // error: malformed lint attribute\n ```\n \n@@ -1680,7 +1768,7 @@ lint name). Ensure the attribute is of this form:\n E0496: r##\"\n A lifetime name is shadowing another lifetime name. Erroneous code example:\n \n-```\n+```compile_fail\n struct Foo<'a> {\n     a: &'a i32,\n }\n@@ -1713,7 +1801,7 @@ E0497: r##\"\n A stability attribute was used outside of the standard library. Erroneous code\n example:\n \n-```\n+```compile_fail\n #[stable] // error: stability attributes may not be used outside of the\n           //        standard library\n fn foo() {}\n@@ -1729,7 +1817,7 @@ item.\n \n Examples of erroneous code:\n \n-```\n+```compile_fail\n #[repr(C)]\n type Foo = u8;\n \n@@ -1777,7 +1865,7 @@ something other than a function or method.\n \n Examples of erroneous code:\n \n-```\n+```compile_fail\n #[inline(always)]\n struct Foo;\n \n@@ -1811,9 +1899,9 @@ register_diagnostics! {\n //  E0285, // overflow evaluation builtin bounds\n     E0298, // mismatched types between arms\n     E0299, // mismatched types between arms\n-    // E0300, // unexpanded macro\n-    // E0304, // expected signed integer constant\n-    // E0305, // expected constant\n+//  E0300, // unexpanded macro\n+//  E0304, // expected signed integer constant\n+//  E0305, // expected constant\n     E0311, // thing may not live long enough\n     E0312, // lifetime of reference outlives lifetime of borrowed content\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured variable"}, {"sha": "29944aaf3673ddcfcf2749af5535fdb42c1e104c", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -17,7 +17,7 @@ This error occurs when an attempt is made to use data captured by a closure,\n when that data may no longer exist. It's most commonly seen when attempting to\n return a closure:\n \n-```\n+```compile_fail\n fn foo() -> Box<Fn(u32) -> u32> {\n     let x = 0u32;\n     Box::new(|y| x + y)\n@@ -30,7 +30,7 @@ longer exists. An attempt to access `x` within the closure would thus be unsafe.\n \n Another situation where this might be encountered is when spawning threads:\n \n-```\n+```compile_fail\n fn foo() {\n     let x = 0u32;\n     let y = 1u32;\n@@ -65,10 +65,11 @@ about safety.\n E0381: r##\"\n It is not allowed to use or capture an uninitialized variable. For example:\n \n-```\n+```compile_fail\n fn main() {\n     let x: i32;\n     let y = x; // error, use of possibly uninitialized variable\n+}\n ```\n \n To fix this, ensure that any declared variables are initialized before being\n@@ -79,7 +80,7 @@ E0382: r##\"\n This error occurs when an attempt is made to use a variable after its contents\n have been moved elsewhere. For example:\n \n-```\n+```compile_fail\n struct MyStruct { s: u32 }\n \n fn main() {\n@@ -144,7 +145,11 @@ structure that is currently uninitialized.\n \n For example, this can happen when a drop has taken place:\n \n-```\n+```compile_fail\n+struct Foo {\n+    a: u32,\n+}\n+\n let mut x = Foo { a: 1 };\n drop(x); // `x` is now uninitialized\n x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n@@ -153,6 +158,10 @@ x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n This error can be fixed by fully reinitializing the structure in question:\n \n ```\n+struct Foo {\n+    a: u32,\n+}\n+\n let mut x = Foo { a: 1 };\n drop(x);\n x = Foo { a: 2 };\n@@ -163,7 +172,7 @@ E0384: r##\"\n This error occurs when an attempt is made to reassign an immutable variable.\n For example:\n \n-```\n+```compile_fail\n fn main(){\n     let x = 3;\n     x = 5; // error, reassignment of immutable variable\n@@ -187,7 +196,7 @@ reference stored inside an immutable container.\n \n For example, this can happen when storing a `&mut` inside an immutable `Box`:\n \n-```\n+```compile_fail\n let mut x: i64 = 1;\n let y: Box<_> = Box::new(&mut x);\n **y = 2; // error, cannot assign to data in an immutable container\n@@ -205,6 +214,8 @@ It can also be fixed by using a type with interior mutability, such as `Cell` or\n `RefCell`:\n \n ```\n+use std::cell::Cell;\n+\n let x: i64 = 1;\n let y: Box<Cell<_>> = Box::new(Cell::new(x));\n y.set(2);\n@@ -215,12 +226,12 @@ E0387: r##\"\n This error occurs when an attempt is made to mutate or mutably reference data\n that a closure has captured immutably. Examples of this error are shown below:\n \n-```\n+```compile_fail\n // Accepts a function or a closure that captures its environment immutably.\n // Closures passed to foo will not be able to mutate their closed-over state.\n fn foo<F: Fn()>(f: F) { }\n \n-// Attempts to mutate closed-over data.  Error message reads:\n+// Attempts to mutate closed-over data. Error message reads:\n // `cannot assign to data in a captured outer variable...`\n fn mutable() {\n     let mut x = 0u32;\n@@ -254,6 +265,8 @@ could be redefined as below:\n ```\n use std::cell::Cell;\n \n+fn foo<F: Fn()>(f: F) { }\n+\n fn mutable() {\n     let x = Cell::new(0u32);\n     foo(|| x.set(2));\n@@ -268,7 +281,7 @@ https://doc.rust-lang.org/std/cell/\n E0499: r##\"\n A variable was borrowed as mutable more than once. Erroneous code example:\n \n-```\n+```compile_fail\n let mut i = 0;\n let mut x = &mut i;\n let mut a = &mut i;\n@@ -296,7 +309,7 @@ let c = &i; // still ok!\n E0507: r##\"\n You tried to move out of a value which was borrowed. Erroneous code example:\n \n-```\n+```compile_fail\n use std::cell::RefCell;\n \n struct TheDarkKnight;\n@@ -380,7 +393,7 @@ fn main() {\n Moving out of a member of a mutably borrowed struct is fine if you put something\n back. `mem::replace` can be used for that:\n \n-```\n+```ignore\n struct TheDarkKnight;\n \n impl TheDarkKnight {"}, {"sha": "bd7f094364adb56170f0d2d06ac1c1268282eca5", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -66,7 +66,7 @@ pub fn compile_input(sess: &Session,\n                      outdir: &Option<PathBuf>,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n-                     control: CompileController) -> CompileResult {\n+                     control: &CompileController) -> CompileResult {\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n             let state = $make_state;"}, {"sha": "f6eb99f5589c8ba257006bf1a4087a6763302817", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -203,7 +203,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n     let control = callbacks.build_controller(&sess);\n     (driver::compile_input(&sess, &cstore, cfg, &input, &odir, &ofile,\n-                           Some(plugins), control),\n+                           Some(plugins), &control),\n      Some(sess))\n }\n "}, {"sha": "c89e9bb19595e1c86a88b558f3aed119aae93240", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -18,7 +18,7 @@ for the entire lifetime of a program. Creating a boxed value allocates memory on\n the heap at runtime, and therefore cannot be done at compile time. Erroneous\n code example:\n \n-```\n+```compile_fail\n #![feature(box_syntax)]\n \n const CON : Box<i32> = box 0;\n@@ -30,9 +30,9 @@ Initializers for constants and statics are evaluated at compile time.\n User-defined operators rely on user-defined functions, which cannot be evaluated\n at compile time.\n \n-Bad example:\n+Erroneous code example:\n \n-```\n+```compile_fail\n use std::ops::Index;\n \n struct Foo { a: u8 }\n@@ -53,16 +53,16 @@ Example:\n \n ```\n const a: &'static [i32] = &[1, 2, 3];\n-const b: i32 = a[0]; // Good!\n+const b: i32 = a[0]; // Ok!\n ```\n \"##,\n \n E0013: r##\"\n Static and const variables can refer to other const variables. But a const\n-variable cannot refer to a static variable. For example, `Y` cannot refer to `X`\n-here:\n+variable cannot refer to a static variable. For example, `Y` cannot refer to\n+`X` here:\n \n-```\n+```compile_fail\n static X: i32 = 42;\n const Y: i32 = X;\n ```\n@@ -80,9 +80,9 @@ E0014: r##\"\n Constants can only be initialized by a constant value or, in a future\n version of Rust, a call to a const function. This error indicates the use\n of a path (like a::b, or x) denoting something other than one of these\n-allowed items. Example:\n+allowed items. Erroneous code xample:\n \n-```\n+```compile_fail\n const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!\n ```\n \n@@ -91,7 +91,7 @@ To avoid it, you have to replace the non-constant value:\n ```\n const FOO: i32 = { const X : i32 = 0; X };\n // or even:\n-const FOO: i32 = { 0 }; // but brackets are useless here\n+const FOO2: i32 = { 0 }; // but brackets are useless here\n ```\n \"##,\n \n@@ -115,9 +115,9 @@ See [RFC 911] for more details on the design of `const fn`s.\n \n E0016: r##\"\n Blocks in constants may only contain items (such as constant, function\n-definition, etc...) and a tail expression. Example:\n+definition, etc...) and a tail expression. Erroneous code example:\n \n-```\n+```compile_fail\n const FOO: i32 = { let x = 0; x }; // 'x' isn't an item!\n ```\n \n@@ -129,9 +129,10 @@ const FOO: i32 = { const X : i32 = 0; X };\n \"##,\n \n E0017: r##\"\n-References in statics and constants may only refer to immutable values. Example:\n+References in statics and constants may only refer to immutable values.\n+Erroneous code example:\n \n-```\n+```compile_fail\n static X: i32 = 1;\n const C: i32 = 2;\n \n@@ -156,7 +157,8 @@ can't cast a pointer to an integer because the address of a pointer can\n vary.\n \n For example, if you write:\n-```\n+\n+```compile_fail\n static MY_STATIC: u32 = 42;\n static MY_STATIC_ADDR: usize = &MY_STATIC as *const _ as usize;\n static WHAT: usize = (MY_STATIC_ADDR^17) + MY_STATIC_ADDR;\n@@ -184,10 +186,10 @@ accessed directly.\n \n E0019: r##\"\n A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time. Example of\n-erroneous code:\n+because the expression's value must be known at compile-time. Erroneous code\n+example:\n \n-```\n+```compile_fail\n enum Test {\n     V1\n }\n@@ -222,13 +224,13 @@ E0022: r##\"\n Constant functions are not allowed to mutate anything. Thus, binding to an\n argument with a mutable pattern is not allowed. For example,\n \n-```\n+```compile_fail\n const fn foo(mut x: u8) {\n     // do stuff\n }\n ```\n \n-is bad because the function body may not mutate `x`.\n+Is incorrect because the function body may not mutate `x`.\n \n Remove any mutable bindings from the argument list to fix this error. In case\n you need to mutate the argument, try lazily initializing a global variable\n@@ -244,12 +246,12 @@ range.\n \n For example:\n \n-```\n+```compile_fail\n match 5u32 {\n     // This range is ok, albeit pointless.\n-    1 ... 1 => ...\n+    1 ... 1 => {}\n     // This range is empty, and the compiler can tell.\n-    1000 ... 5 => ...\n+    1000 ... 5 => {}\n }\n ```\n \"##,\n@@ -268,11 +270,11 @@ All statics and constants need to resolve to a value in an acyclic manner.\n \n For example, neither of the following can be sensibly compiled:\n \n-```\n+```compile_fail\n const X: u32 = X;\n ```\n \n-```\n+```compile_fail\n const X: u32 = Y;\n const Y: u32 = X;\n ```\n@@ -282,7 +284,7 @@ E0267: r##\"\n This error indicates the use of a loop keyword (`break` or `continue`) inside a\n closure but outside of any loop. Erroneous code example:\n \n-```\n+```compile_fail\n let w = || { break; }; // error: `break` inside of a closure\n ```\n \n@@ -306,7 +308,7 @@ This error indicates the use of a loop keyword (`break` or `continue`) outside\n of a loop. Without a loop to break out of or continue in, no sensible action can\n be taken. Erroneous code example:\n \n-```\n+```compile_fail\n fn some_func() {\n     break; // error: `break` outside of loop\n }\n@@ -329,7 +331,7 @@ in statics, constants, and constant functions.\n \n For example:\n \n-```\n+```compile_fail\n const BAZ: i32 = Foo(25).bar(); // error, `bar` isn't `const`\n \n struct Foo(i32);\n@@ -362,9 +364,9 @@ E0395: r##\"\n The value assigned to a constant scalar must be known at compile time,\n which is not the case when comparing raw pointers.\n \n-\n Erroneous code example:\n-```\n+\n+```compile_fail\n static FOO: i32 = 42;\n static BAR: i32 = 42;\n \n@@ -391,10 +393,9 @@ let baz: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n E0396: r##\"\n The value behind a raw pointer can't be determined at compile-time\n (or even link-time), which means it can't be used in a constant\n-expression.\n+expression. Erroneous code example:\n \n-For example:\n-```\n+```compile_fail\n const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n \n const VALUE: u8 = unsafe { *REG_ADDR };\n@@ -416,7 +417,7 @@ E0397: r##\"\n It is not allowed for a mutable static to allocate or have destructors. For\n example:\n \n-```\n+```compile_fail\n // error: mutable statics are not allowed to have boxes\n static mut FOO: Option<Box<usize>> = None;\n \n@@ -429,7 +430,7 @@ E0400: r##\"\n A user-defined dereference was attempted in an invalid context. Erroneous\n code example:\n \n-```\n+```compile_fail\n use std::ops::Deref;\n \n struct A;\n@@ -473,7 +474,7 @@ E0492: r##\"\n A borrow of a constant containing interior mutability was attempted. Erroneous\n code example:\n \n-```\n+```compile_fail\n use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n \n const A: AtomicUsize = ATOMIC_USIZE_INIT;\n@@ -500,7 +501,7 @@ static B: &'static AtomicUsize = &A; // ok!\n \n You can also have this error while using a cell type:\n \n-```\n+```compile_fail\n #![feature(const_fn)]\n \n use std::cell::Cell;\n@@ -552,7 +553,7 @@ E0493: r##\"\n A type with a destructor was assigned to an invalid type of variable. Erroneous\n code example:\n \n-```\n+```compile_fail\n struct Foo {\n     a: u32\n }\n@@ -575,7 +576,7 @@ E0494: r##\"\n A reference of an interior static was assigned to another const/static.\n Erroneous code example:\n \n-```\n+```compile_fail\n struct Foo {\n     a: u32\n }"}, {"sha": "d124ead5091d3123e6f0869fafb08f29f4612377", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -16,36 +16,35 @@ E0445: r##\"\n A private trait was used on a public type parameter bound. Erroneous code\n examples:\n \n-```\n+```compile_fail\n trait Foo {\n     fn dummy(&self) { }\n }\n \n pub trait Bar : Foo {} // error: private trait in public interface\n-pub struct Bar<T: Foo>(pub T); // same error\n+pub struct Bar2<T: Foo>(pub T); // same error\n pub fn foo<T: Foo> (t: T) {} // same error\n ```\n \n To solve this error, please ensure that the trait is also public. The trait\n can be made inaccessible if necessary by placing it into a private inner module,\n-but it still has to be marked with `pub`.\n-Example:\n+but it still has to be marked with `pub`. Example:\n \n-```\n+```ignore\n pub trait Foo { // we set the Foo trait public\n     fn dummy(&self) { }\n }\n \n pub trait Bar : Foo {} // ok!\n-pub struct Bar<T: Foo>(pub T); // ok!\n+pub struct Bar2<T: Foo>(pub T); // ok!\n pub fn foo<T: Foo> (t: T) {} // ok!\n ```\n \"##,\n \n E0446: r##\"\n A private type was used in a public type signature. Erroneous code example:\n \n-```\n+```compile_fail\n mod Foo {\n     struct Bar(u32);\n \n@@ -74,7 +73,7 @@ mod Foo {\n E0447: r##\"\n The `pub` keyword was used inside a function. Erroneous code example:\n \n-```\n+```compile_fail\n fn foo() {\n     pub struct Bar; // error: visibility has no effect inside functions\n }\n@@ -88,7 +87,7 @@ is invalid.\n E0448: r##\"\n The `pub` keyword was used inside a public enum. Erroneous code example:\n \n-```\n+```compile_fail\n pub enum Foo {\n     pub Bar, // error: unnecessary `pub` visibility\n }\n@@ -97,13 +96,15 @@ pub enum Foo {\n Since the enum is already public, adding `pub` on one its elements is\n unnecessary. Example:\n \n-```\n+```compile_fail\n enum Foo {\n-    pub Bar, // ok!\n+    pub Bar, // not ok!\n }\n+```\n \n-// or:\n+This is the correct syntax:\n \n+```ignore\n pub enum Foo {\n     Bar, // ok!\n }\n@@ -114,7 +115,7 @@ E0449: r##\"\n A visibility qualifier was used when it was unnecessary. Erroneous code\n examples:\n \n-```\n+```compile_fail\n struct Bar;\n \n trait Foo {\n@@ -131,7 +132,7 @@ pub impl Foo for Bar { // error: unnecessary visibility qualifier\n To fix this error, please remove the visibility qualifier when it is not\n required. Example:\n \n-```\n+```ignore\n struct Bar;\n \n trait Foo {\n@@ -154,7 +155,7 @@ E0450: r##\"\n A tuple constructor was invoked while some of its fields are private. Erroneous\n code example:\n \n-```\n+```compile_fail\n mod Bar {\n     pub struct Foo(isize);\n }\n@@ -179,7 +180,7 @@ mod bar {\n     pub struct Foo(isize);\n \n     impl Foo {\n-        pub fn new(x: isize) {\n+        pub fn new(x: isize) -> Foo {\n             Foo(x)\n         }\n     }\n@@ -192,7 +193,7 @@ let f = bar::Foo::new(1);\n E0451: r##\"\n A struct constructor with private fields was invoked. Erroneous code example:\n \n-```\n+```compile_fail\n mod Bar {\n     pub struct Foo {\n         pub a: isize,\n@@ -216,8 +217,11 @@ mod Bar {\n }\n \n let f = Bar::Foo{ a: 0, b: 0 }; // ok!\n+```\n \n-// or:\n+Or:\n+\n+```\n mod Bar {\n     pub struct Foo {\n         pub a: isize,"}, {"sha": "99c29bbb8ef7268c7000d0eca1d42afa351e2d29", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 94, "deletions": 67, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -21,12 +21,12 @@ variable declarations and expression statements.\n \n Here is an example that demonstrates the error:\n \n-```\n+```compile_fail\n fn f() {\n     // Variable declaration before import\n     let x = 0;\n     use std::io::Read;\n-    ...\n+    // ...\n }\n ```\n \n@@ -39,7 +39,7 @@ Here is the previous example again, with the correct order:\n fn f() {\n     use std::io::Read;\n     let x = 0;\n-    ...\n+    // ...\n }\n ```\n \n@@ -55,7 +55,7 @@ items under a new local name.\n \n An example of this error:\n \n-```\n+```compile_fail\n use foo::baz;\n use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n \n@@ -77,7 +77,7 @@ items under a new local name.\n \n An example of this error:\n \n-```\n+```compile_fail\n use foo::baz;\n use bar::baz; // error, do `use bar::baz as quux` instead\n \n@@ -97,12 +97,13 @@ E0253: r##\"\n Attempt was made to import an unimportable value. This can happen when\n trying to import a method from a trait. An example of this error:\n \n-```\n+```compile_fail\n mod foo {\n     pub trait MyTrait {\n         fn do_something();\n     }\n }\n+\n use foo::MyTrait::do_something;\n ```\n \n@@ -115,7 +116,7 @@ module.\n \n An example of this error:\n \n-```\n+```compile_fail\n use bar::foo; // error, do `use bar::foo as baz` instead\n \n fn foo() {}\n@@ -134,7 +135,7 @@ the same as another type or submodule defined in the module.\n \n An example of this error:\n \n-```\n+```compile_fail\n use foo::Bar; // error\n \n type Bar = u32;\n@@ -153,7 +154,7 @@ has been imported into the current module.\n \n Wrong example:\n \n-```\n+```compile_fail\n extern crate a;\n extern crate crate_a as a;\n ```\n@@ -163,7 +164,7 @@ external crate imported into the current module.\n \n Correct example:\n \n-```\n+```ignore\n extern crate a;\n extern crate crate_a as other_name;\n ```\n@@ -172,9 +173,9 @@ extern crate crate_a as other_name;\n E0260: r##\"\n The name for an item declaration conflicts with an external crate's name.\n \n-For instance,\n+For instance:\n \n-```\n+```ignore\n extern crate abc;\n \n struct abc;\n@@ -184,15 +185,15 @@ There are two possible solutions:\n \n Solution #1: Rename the item.\n \n-```\n+```ignore\n extern crate abc;\n \n struct xyz;\n ```\n \n Solution #2: Import the crate with a different name.\n \n-```\n+```ignore\n extern crate abc as xyz;\n \n struct abc;\n@@ -209,7 +210,7 @@ User-defined types or type parameters cannot shadow the primitive types.\n This error indicates you tried to define a type, struct or enum with the same\n name as an existing primitive type:\n \n-```\n+```compile_fail\n struct u8 {\n     // ...\n }\n@@ -220,7 +221,7 @@ To fix this, simply name it something else.\n Such an error may also occur if you define a type parameter which shadows a\n primitive type. An example would be something like:\n \n-```\n+```compile_fail\n impl<u8> MyTrait for Option<u8> {\n     // ...\n }\n@@ -229,7 +230,7 @@ impl<u8> MyTrait for Option<u8> {\n In such a case, if you meant for `u8` to be a generic type parameter (i.e. any\n type can be used in its place), use something like `T` instead:\n \n-```\n+```ignore\n impl<T> MyTrait for Option<T> {\n     // ...\n }\n@@ -238,7 +239,7 @@ impl<T> MyTrait for Option<T> {\n On the other hand, if you wished to refer to the specific type `u8`, remove it\n from the type parameter list:\n \n-```\n+```ignore\n impl MyTrait for Option<u8> {\n     // ...\n }\n@@ -255,20 +256,22 @@ you attempted to `pub use` a type or value that was not itself public.\n \n Here is an example that demonstrates the error:\n \n-```\n+```compile_fail\n mod foo {\n     const X: u32 = 1;\n }\n+\n pub use foo::X;\n ```\n \n The solution to this problem is to ensure that the items that you are\n re-exporting are themselves marked with `pub`:\n \n-```\n+```ignore\n mod foo {\n     pub const X: u32 = 1;\n }\n+\n pub use foo::X;\n ```\n \n@@ -284,20 +287,22 @@ that you attempted to `pub use` a module that was not itself public.\n \n Here is an example that demonstrates the error:\n \n-```\n+```compile_fail\n mod foo {\n     pub const X: u32 = 1;\n }\n-pub use foo as foo2;\n \n+pub use foo as foo2;\n ```\n+\n The solution to this problem is to ensure that the module that you are\n re-exporting is itself marked with `pub`:\n \n-```\n+```ignore\n pub mod foo {\n     pub const X: u32 = 1;\n }\n+\n pub use foo as foo2;\n ```\n \n@@ -311,7 +316,7 @@ E0401: r##\"\n Inner items do not inherit type parameters from the functions they are\n embedded in. For example, this will not compile:\n \n-```\n+```compile_fail\n fn foo<T>(x: T) {\n     fn bar(y: T) { // T is defined in the \"outer\" function\n         // ..\n@@ -320,18 +325,18 @@ fn foo<T>(x: T) {\n }\n ```\n \n-nor will this:\n+Nor will this:\n \n-```\n+```compile_fail\n fn foo<T>(x: T) {\n     type MaybeT = Option<T>;\n     // ...\n }\n ```\n \n-or this:\n+Or this:\n \n-```\n+```compile_fail\n fn foo<T>(x: T) {\n     struct Foo {\n         x: T,\n@@ -351,7 +356,7 @@ If the item is a function, you may use a closure:\n fn foo<T>(x: T) {\n     let bar = |y: T| { // explicit type annotation may not be necessary\n         // ..\n-    }\n+    };\n     bar(x);\n }\n ```\n@@ -397,11 +402,12 @@ This may require additional type hints in the function body.\n In case the item is a function inside an `impl`, defining a private helper\n function might be easier:\n \n-```\n+```ignore\n impl<T> Foo<T> {\n     pub fn foo(&self, x: T) {\n         self.bar(x);\n     }\n+\n     fn bar(&self, y: T) {\n         // ..\n     }\n@@ -415,7 +421,7 @@ closures or copying the parameters should still work.\n E0403: r##\"\n Some type parameters have the same name. Example of erroneous code:\n \n-```\n+```compile_fail\n fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type\n                             //        parameter in this type parameter list\n ```\n@@ -432,7 +438,7 @@ E0404: r##\"\n You tried to implement something which was not a trait on an object. Example of\n erroneous code:\n \n-```\n+```compile_fail\n struct Foo;\n struct Bar;\n \n@@ -457,7 +463,7 @@ impl Foo for Bar { // ok!\n E0405: r##\"\n An unknown trait was implemented. Example of erroneous code:\n \n-```\n+```compile_fail\n struct Foo;\n \n impl SomeTrait for Foo {} // error: use of undeclared trait name `SomeTrait`\n@@ -466,7 +472,7 @@ impl SomeTrait for Foo {} // error: use of undeclared trait name `SomeTrait`\n Please verify that the name of the trait wasn't misspelled and ensure that it\n was imported. Example:\n \n-```\n+```ignore\n // solution 1:\n use some_file::SomeTrait;\n \n@@ -487,7 +493,7 @@ E0407: r##\"\n A definition of a method not in the implemented trait was given in a trait\n implementation. Example of erroneous code:\n \n-```\n+```compile_fail\n trait Foo {\n     fn a();\n }\n@@ -540,7 +546,7 @@ E0411: r##\"\n The `Self` keyword was used outside an impl or a trait. Erroneous\n code example:\n \n-```\n+```compile_fail\n <Self>::foo; // error: use of `Self` outside of an impl or trait\n ```\n \n@@ -560,7 +566,7 @@ trait Baz : Foo {\n \n However, be careful when two types has a common associated type:\n \n-```\n+```compile_fail\n trait Foo {\n     type Bar;\n }\n@@ -579,6 +585,14 @@ This problem can be solved by specifying from which trait we want\n to use the `Bar` type:\n \n ```\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Foo2 {\n+    type Bar;\n+}\n+\n trait Baz : Foo + Foo2 {\n     fn bar() -> <Self as Foo>::Bar; // ok!\n }\n@@ -588,7 +602,7 @@ trait Baz : Foo + Foo2 {\n E0412: r##\"\n An undeclared type name was used. Example of erroneous codes:\n \n-```\n+```compile_fail\n impl Something {} // error: use of undeclared type name `Something`\n // or:\n trait Foo {\n@@ -605,13 +619,17 @@ you did declare it or imported it into the scope. Examples:\n struct Something;\n \n impl Something {} // ok!\n+\n // or:\n+\n trait Foo {\n     type N;\n \n     fn bar(Self::N); // ok!\n }\n-//or:\n+\n+// or:\n+\n fn foo<T>(x: T) {} // ok!\n ```\n \"##,\n@@ -620,14 +638,13 @@ E0413: r##\"\n A declaration shadows an enum variant or unit-like struct in scope.\n Example of erroneous code:\n \n-```\n+```compile_fail\n struct Foo;\n \n let Foo = 12i32; // error: declaration of `Foo` shadows an enum variant or\n                  //        unit-like struct in scope\n ```\n \n-\n To fix this error, rename the variable such that it doesn't shadow any enum\n variable or structure in scope. Example:\n \n@@ -652,7 +669,7 @@ E0415: r##\"\n More than one function parameter have the same name. Example of erroneous\n code:\n \n-```\n+```compile_fail\n fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n                           //        once in this parameter list\n ```\n@@ -668,7 +685,7 @@ E0416: r##\"\n An identifier is bound more than once in a pattern. Example of erroneous\n code:\n \n-```\n+```compile_fail\n match (1, 2) {\n     (x, x) => {} // error: identifier `x` is bound more than once in the\n                  //        same pattern\n@@ -685,7 +702,7 @@ match (1, 2) {\n \n Or maybe did you mean to unify? Consider using a guard:\n \n-```\n+```ignore\n match (A, B, C) {\n     (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n     (y, z, see) => { /* A and B unequal; do another thing */ }\n@@ -696,7 +713,7 @@ match (A, B, C) {\n E0417: r##\"\n A static variable was referenced in a pattern. Example of erroneous code:\n \n-```\n+```compile_fail\n static FOO : i32 = 0;\n \n match 0 {\n@@ -725,7 +742,7 @@ E0419: r##\"\n An unknown enum variant, struct or const was used. Example of\n erroneous code:\n \n-```\n+```compile_fail\n match 0 {\n     Something::Foo => {} // error: unresolved enum variant, struct\n                          //        or const `Foo`\n@@ -751,7 +768,8 @@ match Something::NotFoo {\n E0422: r##\"\n You are trying to use an identifier that is either undefined or not a\n struct. For instance:\n-```\n+\n+``` compile_fail\n fn main () {\n     let x = Foo { x: 1, y: 2 };\n }\n@@ -760,7 +778,7 @@ fn main () {\n In this case, `Foo` is undefined, so it inherently isn't anything, and\n definitely not a struct.\n \n-```\n+```compile_fail\n fn main () {\n     let foo = 1;\n     let x = foo { x: 1, y: 2 };\n@@ -775,7 +793,7 @@ E0423: r##\"\n A `struct` variant name was used like a function name. Example of\n erroneous code:\n \n-```\n+```compile_fail\n struct Foo { a: bool};\n \n let f = Foo();\n@@ -796,7 +814,7 @@ let f = Foo(); // ok!\n E0424: r##\"\n The `self` keyword was used in a static method. Example of erroneous code:\n \n-```\n+```compile_fail\n struct Foo;\n \n impl Foo {\n@@ -828,7 +846,7 @@ impl Foo {\n E0425: r##\"\n An unresolved name was used. Example of erroneous codes:\n \n-```\n+```compile_fail\n something_that_doesnt_exist::foo;\n // error: unresolved name `something_that_doesnt_exist::foo`\n \n@@ -848,17 +866,23 @@ identifier being referred to is valid for the given situation. Example:\n \n ```\n enum something_that_does_exist {\n-    foo\n+    Foo,\n }\n+```\n \n-// or:\n+Or:\n+\n+```\n mod something_that_does_exist {\n     pub static foo : i32 = 0i32;\n }\n \n something_that_does_exist::foo; // ok!\n+```\n \n-// or:\n+Or:\n+\n+```\n let unknown_variable = 12u32;\n let x = unknown_variable; // ok!\n ```\n@@ -867,7 +891,7 @@ let x = unknown_variable; // ok!\n E0426: r##\"\n An undeclared label was used. Example of erroneous code:\n \n-```\n+```compile_fail\n loop {\n     break 'a; // error: use of undeclared label `'a`\n }\n@@ -886,7 +910,7 @@ E0428: r##\"\n A type or module has been defined more than once. Example of erroneous\n code:\n \n-```\n+```compile_fail\n struct Bar;\n struct Bar; // error: duplicate definition of value `Bar`\n ```\n@@ -903,23 +927,23 @@ struct Bar2; // ok!\n E0430: r##\"\n The `self` import appears more than once in the list. Erroneous code example:\n \n-```\n+```compile_fail\n use something::{self, self}; // error: `self` import can only appear once in\n                              //        the list\n ```\n \n Please verify you didn't misspell the import name or remove the duplicated\n `self` import. Example:\n \n-```\n+```ignore\n use something::self; // ok!\n ```\n \"##,\n \n E0431: r##\"\n `self` import was made. Erroneous code example:\n \n-```\n+```compile_fail\n use {self}; // error: `self` import can only appear in an import list with a\n             //        non-empty prefix\n ```\n@@ -931,14 +955,14 @@ or verify you didn't misspell it.\n E0432: r##\"\n An import was unresolved. Erroneous code example:\n \n-```\n+```compile_fail\n use something::Foo; // error: unresolved import `something::Foo`.\n ```\n \n Please verify you didn't misspell the import name or the import does exist\n in the module from where you tried to import it. Example:\n \n-```\n+```ignore\n use something::Foo; // ok!\n \n mod something {\n@@ -949,7 +973,7 @@ mod something {\n Or, if you tried to use a module from an external crate, you may have missed\n the `extern crate` declaration:\n \n-```\n+```ignore\n extern crate homura; // Required to use the `homura` crate\n \n use homura::Madoka;\n@@ -959,7 +983,7 @@ use homura::Madoka;\n E0433: r##\"\n Invalid import. Example of erroneous code:\n \n-```\n+```compile_fail\n use something_which_doesnt_exist;\n // error: unresolved import `something_which_doesnt_exist`\n ```\n@@ -971,7 +995,7 @@ E0435: r##\"\n A non-constant value was used to initialise a constant. Example of erroneous\n code:\n \n-```\n+```compile_fail\n let foo = 42u32;\n const FOO : u32 = foo; // error: attempt to use a non-constant value in a\n                        //        constant\n@@ -981,8 +1005,11 @@ To fix this error, please replace the value with a constant. Example:\n \n ```\n const FOO : u32 = 42u32; // ok!\n+```\n \n-// or:\n+Or:\n+\n+```\n const OTHER_FOO : u32 = 42u32;\n const FOO : u32 = OTHER_FOO; // ok!\n ```\n@@ -996,7 +1023,7 @@ in the trait.\n \n Here is an example that demonstrates the error:\n \n-```\n+```compile_fail\n trait Foo {}\n \n impl Foo for i32 {\n@@ -1021,7 +1048,7 @@ match the name of any associated constant in the trait.\n \n Here is an example that demonstrates the error:\n \n-```\n+```compile_fail\n #![feature(associated_consts)]\n \n trait Foo {}"}, {"sha": "5ae60d182407f8e815649f973eb8a8e849ee549b", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -15,12 +15,14 @@ register_long_diagnostics! {\n E0510: r##\"\n `return_address` was used in an invalid context. Erroneous code example:\n \n-```\n+```compile_fail\n+#![feature(intrinsics)]\n+\n extern \"rust-intrinsic\" {\n     fn return_address() -> *const u8;\n }\n \n-pub unsafe fn by_value() -> i32 {\n+unsafe fn by_value() -> i32 {\n     let _ = return_address();\n     // error: invalid use of `return_address` intrinsic: function does\n     //        not use out pointer\n@@ -35,11 +37,13 @@ the return register(s), the compiler will return the value by writing it into\n space allocated in the caller's stack frame. Example:\n \n ```\n+#![feature(intrinsics)]\n+\n extern \"rust-intrinsic\" {\n     fn return_address() -> *const u8;\n }\n \n-pub unsafe fn by_pointer() -> String {\n+unsafe fn by_pointer() -> String {\n     let _ = return_address();\n     String::new() // ok!\n }\n@@ -50,7 +54,9 @@ E0511: r##\"\n Invalid monomorphization of an intrinsic function was used. Erroneous code\n example:\n \n-```\n+```compile_fail\n+#![feature(platform_intrinsics)]\n+\n extern \"platform-intrinsic\" {\n     fn simd_add<T>(a: T, b: T) -> T;\n }\n@@ -62,6 +68,9 @@ unsafe { simd_add(0, 1); }\n The generic type has to be a SIMD type. Example:\n \n ```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n #[derive(Copy, Clone)]\n struct i32x1(i32);\n@@ -78,7 +87,7 @@ E0512: r##\"\n Transmute with two differently sized types was attempted. Erroneous code\n example:\n \n-```\n+```compile_fail\n fn takes_u8(_: u8) {}\n \n fn main() {\n@@ -103,7 +112,7 @@ fn main() {\n E0515: r##\"\n A constant index expression was out of bounds. Erroneous code example:\n \n-```\n+```compile_fail\n let x = &[0, 1, 2][7]; // error: const index-expr is out of bounds\n ```\n "}, {"sha": "0ff6dcccde698c1a21b4a46b7e7759d90fb13ff8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 437, "deletions": 224, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -19,27 +19,42 @@ extract an incorrect number of fields from a variant.\n \n ```\n enum Fruit {\n-    Apple(String, String)\n-    Pear(u32)\n+    Apple(String, String),\n+    Pear(u32),\n }\n ```\n \n Here the `Apple` variant has two fields, and should be matched against like so:\n \n ```\n+enum Fruit {\n+    Apple(String, String),\n+    Pear(u32),\n+}\n+\n+let x = Fruit::Apple(String::new(), String::new());\n+\n // Correct.\n match x {\n-    Apple(a, b) => ...\n+    Fruit::Apple(a, b) => {},\n+    _ => {}\n }\n ```\n \n Matching with the wrong number of fields has no sensible interpretation:\n \n-```\n+```compile_fail\n+enum Fruit {\n+    Apple(String, String),\n+    Pear(u32),\n+}\n+\n+let x = Fruit::Apple(String::new(), String::new());\n+\n // Incorrect.\n match x {\n-    Apple(a) => ...,\n-    Apple(a, b, c) => ...\n+    Apple(a) => {},\n+    Apple(a, b, c) => {},\n }\n ```\n \n@@ -51,7 +66,7 @@ E0024: r##\"\n This error indicates that a pattern attempted to extract the fields of an enum\n variant with no fields. Here's a tiny example of this error:\n \n-```\n+```compile_fail\n // This enum has two variants.\n enum Number {\n     // This variant has no fields.\n@@ -62,8 +77,8 @@ enum Number {\n \n // Assuming x is a Number we can pattern match on its contents.\n match x {\n-    Zero(inside) => ...,\n-    One(inside) => ...\n+    Zero(inside) => {},\n+    One(inside) => {},\n }\n ```\n \n@@ -76,7 +91,7 @@ E0025: r##\"\n Each field of a struct can only be bound once in a pattern. Erroneous code\n example:\n \n-```\n+```compile_fail\n struct Foo {\n     a: u8,\n     b: u8,\n@@ -122,23 +137,42 @@ struct Thing {\n }\n \n let thing = Thing { x: 1, y: 2 };\n+\n match thing {\n-    Thing { x: xfield, y: yfield } => ...\n+    Thing { x: xfield, y: yfield } => {}\n }\n ```\n \n If you are using shorthand field patterns but want to refer to the struct field\n by a different name, you should rename it explicitly.\n \n-```\n-// Change this:\n+Change this:\n+\n+```compile_fail\n+struct Thing {\n+    x: u32,\n+    y: u32\n+}\n+\n+let thing = Thing { x: 0, y: 0 };\n+\n match thing {\n-    Thing { x, z } => ...\n+    Thing { x, z } => {}\n+}\n+```\n+\n+To this:\n+\n+```\n+struct Thing {\n+    x: u32,\n+    y: u32\n }\n \n-// To this:\n+let thing = Thing { x: 0, y: 0 };\n+\n match thing {\n-    Thing { x, y: z } => ...\n+    Thing { x, y: z } => {}\n }\n ```\n \"##,\n@@ -150,27 +184,37 @@ definition is mentioned in the pattern, or use `..` to ignore unwanted fields.\n \n For example:\n \n-```\n+```compile_fail\n struct Dog {\n     name: String,\n-    age: u32\n+    age: u32,\n }\n \n let d = Dog { name: \"Rusty\".to_string(), age: 8 };\n \n // This is incorrect.\n match d {\n-    Dog { age: x } => ...\n+    Dog { age: x } => {}\n }\n+```\n+\n+This is correct (explicit):\n+\n+```\n+struct Dog {\n+    name: String,\n+    age: u32,\n+}\n+\n+let d = Dog { name: \"Rusty\".to_string(), age: 8 };\n \n-// This is correct (explicit).\n match d {\n-    Dog { name: n, age: x } => ...\n+    Dog { name: ref n, age: x } => {}\n }\n \n // This is also correct (ignore unused fields).\n match d {\n-    Dog { age: x, .. } => ...\n+    Dog { age: x, .. } => {}\n }\n ```\n \"##,\n@@ -182,18 +226,18 @@ compile-time, and is unable to evaluate arbitrary comparison functions. If you\n want to capture values of an orderable type between two end-points, you can use\n a guard.\n \n-```\n+```compile_fail\n // The ordering relation for strings can't be evaluated at compile time,\n // so this doesn't work:\n match string {\n-    \"hello\" ... \"world\" => ...\n-    _ => ...\n+    \"hello\" ... \"world\" => {}\n+    _ => {}\n }\n \n // This is a more general version, using a guard:\n match string {\n-    s if s >= \"hello\" && s <= \"world\" => ...\n-    _ => ...\n+    s if s >= \"hello\" && s <= \"world\" => {}\n+    _ => {}\n }\n ```\n \"##,\n@@ -205,7 +249,7 @@ size of trait implementors isn't fixed, this type has no compile-time size.\n Therefore, all accesses to trait types must be through pointers. If you\n encounter this error you should try to avoid dereferencing the pointer.\n \n-```\n+```ignore\n let trait_obj: &SomeTrait = ...;\n \n // This tries to implicitly dereference to create an unsized local variable.\n@@ -224,9 +268,9 @@ https://doc.rust-lang.org/reference.html#trait-objects\n \n E0034: r##\"\n The compiler doesn't know what method to call because more than one method\n-has the same prototype. Example:\n+has the same prototype. Erroneous code example:\n \n-```\n+```compile_fail\n struct Test;\n \n trait Trait1 {\n@@ -286,9 +330,10 @@ fn main() {\n \"##,\n \n E0035: r##\"\n-You tried to give a type parameter where it wasn't needed. Bad example:\n+You tried to give a type parameter where it wasn't needed. Erroneous code\n+example:\n \n-```\n+```compile_fail\n struct Test;\n \n impl Test {\n@@ -321,9 +366,9 @@ fn main() {\n \n E0036: r##\"\n This error occurrs when you pass too many or not enough type parameters to\n-a method. Example:\n+a method. Erroneous code example:\n \n-```\n+```compile_fail\n struct Test;\n \n impl Test {\n@@ -361,7 +406,7 @@ fn main() {\n \n Please note on the last example that we could have called `method` like this:\n \n-```\n+```ignore\n x.method(v);\n ```\n \"##,\n@@ -373,7 +418,7 @@ out of scope.\n \n Here's an example of this error:\n \n-```\n+```compile_fail\n struct Foo {\n     x: i32,\n }\n@@ -394,7 +439,7 @@ fn main() {\n E0044: r##\"\n You can't use type parameters on foreign items. Example of erroneous code:\n \n-```\n+```compile_fail\n extern { fn some_func<T>(x: T); }\n ```\n \n@@ -412,17 +457,23 @@ Rust only supports variadic parameters for interoperability with C code in its\n FFI. As such, variadic parameters can only be used with functions which are\n using the C ABI. Examples of erroneous code:\n \n-```\n+```compile_fail\n extern \"rust-call\" { fn foo(x: u8, ...); }\n+\n // or\n+\n fn foo(x: u8, ...) {}\n ```\n \n To fix such code, put them in an extern \"C\" block:\n \n+```ignore\n+extern \"C\" fn foo(x: u8, ...);\n+```\n+\n+Or:\n+\n ```\n-extern \"C\" fn foo (x: u8, ...);\n-// or:\n extern \"C\" {\n     fn foo (x: u8, ...);\n }\n@@ -432,7 +483,7 @@ extern \"C\" {\n E0046: r##\"\n Items are missing in a trait implementation. Erroneous code example:\n \n-```\n+```compile_fail\n trait Foo {\n     fn foo();\n }\n@@ -468,7 +519,7 @@ has the wrong number of type parameters.\n For example, the trait below has a method `foo` with a type parameter `T`,\n but the implementation of `foo` for the type `Bar` is missing this parameter:\n \n-```\n+```compile_fail\n trait Foo {\n     fn foo<T: Default>(x: T) -> Self;\n }\n@@ -491,7 +542,7 @@ For example, the trait below has a method `foo` with two function parameters\n (`&self` and `u8`), but the implementation of `foo` for the type `Bar` omits\n the `u8` parameter:\n \n-```\n+```compile_fail\n trait Foo {\n     fn foo(&self, x: u8) -> bool;\n }\n@@ -512,7 +563,7 @@ and the trait definition.\n \n Here are a couple examples of this error:\n \n-```\n+```compile_fail\n trait Foo {\n     fn foo(x: u16);\n     fn bar(&self);\n@@ -534,14 +585,18 @@ E0054: r##\"\n It is not allowed to cast to a bool. If you are trying to cast a numeric type\n to a bool, you can compare it with zero instead:\n \n+```compile_fail\n+let x = 5;\n+\n+// Not allowed, won't compile\n+let x_is_nonzero = x as bool;\n+```\n+\n ```\n let x = 5;\n \n // Ok\n let x_is_nonzero = x != 0;\n-\n-// Not allowed, won't compile\n-let x_is_nonzero = x as bool;\n ```\n \"##,\n \n@@ -553,7 +608,7 @@ recursion limit (which can be set via the `recursion_limit` attribute).\n \n For a somewhat artificial example:\n \n-```\n+```compile_fail\n #![recursion_limit=\"2\"]\n \n struct Foo;\n@@ -583,7 +638,7 @@ function must match its definition.\n \n An example using a closure:\n \n-```\n+```compile_fail\n let f = |x| x * 3;\n let a = f();        // invalid, too few parameters\n let b = f(4);       // this works!\n@@ -609,13 +664,13 @@ implemented by closures.\n The most likely source of this error is using angle-bracket notation without\n wrapping the function argument type into a tuple, for example:\n \n-```\n+```compile_fail\n fn foo<F: Fn<i32>>(f: F) -> F::Output { f(3) }\n ```\n \n It can be fixed by adjusting the trait bound like this:\n \n-```\n+```ignore\n fn foo<F: Fn<(i32,)>>(f: F) -> F::Output { f(3) }\n ```\n \n@@ -628,7 +683,7 @@ External C functions are allowed to be variadic. However, a variadic function\n takes a minimum number of arguments. For example, consider C's variadic `printf`\n function:\n \n-```\n+```ignore\n extern crate libc;\n use libc::{ c_char, c_int };\n \n@@ -640,7 +695,7 @@ extern \"C\" {\n Using this declaration, it must be called with at least one argument, so\n simply calling `printf()` is invalid. But the following uses are allowed:\n \n-```\n+```ignore\n unsafe {\n     use std::ffi::CString;\n \n@@ -655,13 +710,13 @@ E0061: r##\"\n The number of arguments passed to a function must match the number of arguments\n specified in the function signature.\n \n-For example, a function like\n+For example, a function like:\n \n ```\n fn f(a: u16, b: &str) {}\n ```\n \n-must always be called with exactly two arguments, e.g. `f(2, \"test\")`.\n+Must always be called with exactly two arguments, e.g. `f(2, \"test\")`.\n \n Note, that Rust does not have a notion of optional function arguments or\n variadic functions (except for its C-FFI).\n@@ -672,7 +727,7 @@ This error indicates that during an attempt to build a struct or struct-like\n enum variant, one of the fields was specified more than once. Erroneous code\n example:\n \n-```\n+```compile_fail\n struct Foo {\n     x: i32\n }\n@@ -702,7 +757,7 @@ E0063: r##\"\n This error indicates that during an attempt to build a struct or struct-like\n enum variant, one of the fields was not provided. Erroneous code example:\n \n-```\n+```compile_fail\n struct Foo {\n     x: i32,\n     y: i32\n@@ -743,9 +798,9 @@ expression. An lvalue expression represents a memory location and includes\n item paths (ie, namespaced variables), dereferences, indexing expressions,\n and field references.\n \n-Let's start with some bad examples:\n+Let's start with some erroneous code examples:\n \n-```\n+```compile_fail\n use std::collections::LinkedList;\n \n // Bad: assignment to non-lvalue expression\n@@ -758,7 +813,7 @@ fn some_func(i: &mut i32) {\n }\n ```\n \n-And now some good examples:\n+And now some working examples:\n \n ```\n let mut i : i32 = 0;\n@@ -777,7 +832,7 @@ E0069: r##\"\n The compiler found a function whose body contains a `return;` statement but\n whose return type is not `()`. An example of this is:\n \n-```\n+```compile_fail\n // error\n fn foo() -> u8 {\n     return;\n@@ -797,13 +852,14 @@ reference.\n More details can be found here:\n https://doc.rust-lang.org/reference.html#lvalues-rvalues-and-temporaries\n \n-Now, we can go further. Here are some bad examples:\n+Now, we can go further. Here are some erroneous code examples:\n \n-```\n+```compile_fail\n struct SomeStruct {\n     x: i32,\n     y: i32\n }\n+\n const SOME_CONST : i32 = 12;\n \n fn some_other_func() {}\n@@ -817,7 +873,7 @@ fn some_function() {\n }\n ```\n \n-And now let's give good examples:\n+And now let's give working examples:\n \n ```\n struct SomeStruct {\n@@ -842,7 +898,7 @@ not a struct-style structure or enum variant.\n \n Example of erroneous code:\n \n-```\n+```compile_fail\n enum Foo { FirstValue(i32) };\n \n let u = Foo::FirstValue { value: 0i32 }; // error: Foo::FirstValue\n@@ -876,7 +932,7 @@ first instance of `Foo` could be made to initialize another instance!\n \n Here's an example of a struct that has this problem:\n \n-```\n+```compile_fail\n struct Foo { x: Box<Foo> } // error\n ```\n \n@@ -895,12 +951,22 @@ tuple struct must all be of a concrete, nongeneric type so the compiler can\n reason about how to use SIMD with them. This error will occur if the types\n are generic.\n \n-```\n+This will cause an error:\n+\n+```compile_fail\n+#![feature(simd)]\n+\n #[simd]\n-struct Bad<T>(T, T, T); // This will cause an error\n+struct Bad<T>(T, T, T);\n+```\n+\n+This will not:\n+\n+```\n+#![feature(simd)]\n \n #[simd]\n-struct Good(u32, u32, u32); // This will not\n+struct Good(u32, u32, u32);\n ```\n \"##,\n \n@@ -909,12 +975,22 @@ The `#[simd]` attribute can only be applied to non empty tuple structs, because\n it doesn't make sense to try to use SIMD operations when there are no values to\n operate on.\n \n-```\n+This will cause an error:\n+\n+```compile_fail\n+#![feature(simd)]\n+\n #[simd]\n-struct Bad; // This will cause an error\n+struct Bad;\n+```\n+\n+This will not:\n+\n+```\n+#![feature(simd)]\n \n #[simd]\n-struct Good(u32); // This will not\n+struct Good(u32);\n ```\n \"##,\n \n@@ -923,26 +999,45 @@ When using the `#[simd]` attribute to automatically use SIMD operations in tuple\n struct, the types in the struct must all be of the same type, or the compiler\n will trigger this error.\n \n-```\n-#[simd]\n-struct Bad(u16, u32, u32); // This will cause an error\n+This will cause an error:\n+\n+```compile_fail\n+#![feature(simd)]\n \n #[simd]\n-struct Good(u32, u32, u32); // This will not\n+struct Bad(u16, u32, u32);\n ```\n \n+This will not:\n+\n+```\n+#![feature(simd)]\n+\n+#[simd]\n+struct Good(u32, u32, u32);\n+```\n \"##,\n \n E0077: r##\"\n When using the `#[simd]` attribute on a tuple struct, the elements in the tuple\n must be machine types so SIMD operations can be applied to them.\n \n-```\n+This will cause an error:\n+\n+```compile_fail\n+#![feature(simd)]\n+\n #[simd]\n-struct Bad(String); // This will cause an error\n+struct Bad(String);\n+```\n+\n+This will not:\n+\n+```\n+#![feature(simd)]\n \n #[simd]\n-struct Good(u32, u32, u32); // This will not\n+struct Good(u32, u32, u32);\n ```\n \"##,\n \n@@ -951,15 +1046,15 @@ Enum variants which contain no data can be given a custom integer\n representation. This error indicates that the value provided is not an integer\n literal and is therefore invalid.\n \n-For example, in the following code,\n+For example, in the following code:\n \n-```\n+```compile_fail\n enum Foo {\n     Q = \"32\"\n }\n ```\n \n-we try to set the representation to a string.\n+We try to set the representation to a string.\n \n There's no general fix for this; if you can work with an integer then just set\n it to one:\n@@ -970,7 +1065,7 @@ enum Foo {\n }\n ```\n \n-however if you actually wanted a mapping between variants and non-integer\n+However if you actually wanted a mapping between variants and non-integer\n objects, it may be preferable to use a method with a match instead:\n \n ```\n@@ -990,7 +1085,7 @@ This error indicates that the compiler was unable to sensibly evaluate an\n integer expression provided as an enum discriminant. Attempting to divide by 0\n or causing integer overflow are two ways to induce this error. For example:\n \n-```\n+```compile_fail\n enum Enum {\n     X = (1 << 500),\n     Y = (1 / 0)\n@@ -1009,17 +1104,19 @@ Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n making them impossible to tell apart.\n \n-```\n-// Good.\n+```compile_fail\n+// Bad.\n enum Enum {\n-    P,\n+    P = 3,\n     X = 3,\n     Y = 5\n }\n+```\n \n-// Bad.\n+```\n+// Good.\n enum Enum {\n-    P = 3,\n+    P,\n     X = 3,\n     Y = 5\n }\n@@ -1029,7 +1126,7 @@ Note that variants without a manually specified discriminant are numbered from\n top to bottom starting from 0, so clashes can occur with seemingly unrelated\n variants.\n \n-```\n+```compile_fail\n enum Bad {\n     X,\n     Y = 0\n@@ -1046,7 +1143,7 @@ adding the `repr` attribute to the enum declaration. This error indicates that\n an integer literal given as a discriminant is not a member of the discriminant\n type. For example:\n \n-```\n+```compile_fail\n #[repr(u8)]\n enum Thing {\n     A = 1024,\n@@ -1075,7 +1172,7 @@ enum Empty {}\n E0087: r##\"\n Too many type parameters were supplied for a function. For example:\n \n-```\n+```compile_fail\n fn foo<T>() {}\n \n fn main() {\n@@ -1090,7 +1187,7 @@ parameters.\n E0088: r##\"\n You gave too many lifetime parameters. Erroneous code example:\n \n-```\n+```compile_fail\n fn f() {}\n \n fn main() {\n@@ -1135,7 +1232,7 @@ fn main() {\n E0089: r##\"\n Not enough type parameters were supplied for a function. For example:\n \n-```\n+```compile_fail\n fn foo<T, U>() {}\n \n fn main() {\n@@ -1146,7 +1243,7 @@ fn main() {\n Note that if a function takes multiple type parameters but you want the compiler\n to infer some of them, you can use type placeholders:\n \n-```\n+```compile_fail\n fn foo<T, U>(x: T) {}\n \n fn main() {\n@@ -1161,7 +1258,7 @@ E0091: r##\"\n You gave an unnecessary type parameter in a type alias. Erroneous code\n example:\n \n-```\n+```compile_fail\n type Foo<T> = u32; // error: type parameter `T` is unused\n // or:\n type Foo<A,B> = Box<A>; // error: type parameter `B` is unused\n@@ -1171,15 +1268,15 @@ Please check you didn't write too many type parameters. Example:\n \n ```\n type Foo = u32; // ok!\n-type Foo<A> = Box<A>; // ok!\n+type Foo2<A> = Box<A>; // ok!\n ```\n \"##,\n \n E0092: r##\"\n You tried to declare an undefined atomic operation function.\n Erroneous code example:\n \n-```\n+```compile_fail\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n@@ -1204,7 +1301,7 @@ extern \"rust-intrinsic\" {\n E0093: r##\"\n You declared an unknown intrinsic function. Erroneous code example:\n \n-```\n+```compile_fail\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n@@ -1241,7 +1338,7 @@ E0094: r##\"\n You gave an invalid number of type parameters to an intrinsic function.\n Erroneous code example:\n \n-```\n+```compile_fail\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n@@ -1267,7 +1364,7 @@ E0101: r##\"\n You hit this error because the compiler lacks the information to\n determine a type for this expression. Erroneous code example:\n \n-```\n+```compile_fail\n fn main() {\n     let x = |_| {}; // error: cannot determine a type for this expression\n }\n@@ -1293,7 +1390,7 @@ E0102: r##\"\n You hit this error because the compiler lacks information to\n determine a type for this variable. Erroneous code example:\n \n-```\n+```compile_fail\n fn demo(devil: fn () -> !) {\n     let x: &_ = devil();\n     // error: cannot determine a type for this local variable\n@@ -1309,7 +1406,9 @@ fn main() {\n To solve this situation, constrain the type of the variable.\n Examples:\n \n-```\n+```no_run\n+#![allow(unused_variables)]\n+\n fn some_func(x: &u32) {\n     // some code\n }\n@@ -1338,7 +1437,7 @@ lifetime elision rules (see below).\n \n Here are some simple examples of where you'll run into this error:\n \n-```\n+```compile_fail\n struct Foo { x: &bool }        // error\n struct Foo<'a> { x: &'a bool } // correct\n \n@@ -1366,15 +1465,15 @@ same as the lifetime on `&self` or `&mut self`.\n \n Here are some examples of elision errors:\n \n-```\n+```compile_fail\n // error, no input lifetimes\n-fn foo() -> &str { ... }\n+fn foo() -> &str { }\n \n // error, `x` and `y` have distinct lifetimes inferred\n-fn bar(x: &str, y: &str) -> &str { ... }\n+fn bar(x: &str, y: &str) -> &str { }\n \n // error, `y`'s lifetime is inferred to be distinct from `x`'s\n-fn baz<'a>(x: &'a str, y: &str) -> &str { ... }\n+fn baz<'a>(x: &'a str, y: &str) -> &str { }\n ```\n \n [book-le]: https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n@@ -1386,7 +1485,7 @@ for a type (like a struct or enum) or trait.\n \n Some basic examples include:\n \n-```\n+```compile_fail\n struct Foo<'a>(&'a str);\n enum Bar { A, B, C }\n \n@@ -1399,7 +1498,7 @@ struct Baz<'a> {\n Here's an example that is currently an error, but may work in a future version\n of Rust:\n \n-```\n+```compile_fail\n struct Foo<'a>(&'a str);\n \n trait Quux { }\n@@ -1417,8 +1516,8 @@ You can only define an inherent implementation for a type in the same crate\n where the type was defined. For example, an `impl` block as below is not allowed\n since `Vec` is defined in the standard library:\n \n-```\n-impl Vec<u8> { ... } // error\n+```compile_fail\n+impl Vec<u8> { } // error\n ```\n \n To fix this problem, you can do either of these things:\n@@ -1431,10 +1530,10 @@ To fix this problem, you can do either of these things:\n Note that using the `type` keyword does not work here because `type` only\n introduces a type alias:\n \n-```\n+```compile_fail\n type Bytes = Vec<u8>;\n \n-impl Bytes { ... } // error, same as above\n+impl Bytes { } // error, same as above\n ```\n \"##,\n \n@@ -1449,14 +1548,14 @@ trait defined in another crate) where\n \n Here's one example of this error:\n \n-```\n+```compile_fail\n impl Drop for u32 {}\n ```\n \n To avoid this kind of error, ensure that at least one local type is referenced\n by the `impl`:\n \n-```\n+```ignore\n pub struct Foo; // you define your type in your crate\n \n impl Drop for Foo { // and you can implement the trait on it!\n@@ -1492,7 +1591,7 @@ E0118: r##\"\n You're trying to write an inherent implementation for something which isn't a\n struct nor an enum. Erroneous code example:\n \n-```\n+```compile_fail\n impl (u8, u8) { // error: no base type found for inherent implementation\n     fn get_state(&self) -> String {\n         // ...\n@@ -1536,7 +1635,7 @@ E0119: r##\"\n There are conflicting trait implementations for the same type.\n Example of erroneous code:\n \n-```\n+```compile_fail\n trait MyTrait {\n     fn get(&self) -> usize;\n }\n@@ -1561,6 +1660,10 @@ MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n this is an error. So, when you write:\n \n ```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n impl<T> MyTrait for T {\n     fn get(&self) -> usize { 0 }\n }\n@@ -1593,7 +1696,7 @@ E0120: r##\"\n An attempt was made to implement Drop on a trait, which is not allowed: only\n structs and enums can implement Drop. An example causing this error:\n \n-```\n+```compile_fail\n trait MyTrait {}\n \n impl Drop for MyTrait {\n@@ -1634,7 +1737,7 @@ placeholders are disallowed by design in item signatures.\n \n Examples of this error include:\n \n-```\n+```compile_fail\n fn foo() -> _ { 5 } // error, explicitly write out the return type instead\n \n static BAR: _ = \"test\"; // error, explicitly write out the type instead\n@@ -1665,10 +1768,10 @@ E0124: r##\"\n You declared two fields of a struct with the same name. Erroneous code\n example:\n \n-```\n+```compile_fail\n struct Foo {\n     field1: i32,\n-    field1: i32 // error: field is already declared\n+    field1: i32, // error: field is already declared\n }\n ```\n \n@@ -1677,7 +1780,7 @@ Please verify that the field names have been correctly spelled. Example:\n ```\n struct Foo {\n     field1: i32,\n-    field2: i32 // ok!\n+    field2: i32, // ok!\n }\n ```\n \"##,\n@@ -1686,8 +1789,8 @@ E0128: r##\"\n Type parameter defaults can only use parameters that occur before them.\n Erroneous code example:\n \n-```\n-pub struct Foo<T=U, U=()> {\n+```compile_fail\n+struct Foo<T=U, U=()> {\n     field1: T,\n     filed2: U,\n }\n@@ -1699,7 +1802,7 @@ Since type parameters are evaluated in-order, you may be able to fix this issue\n by doing:\n \n ```\n-pub struct Foo<U=(), T=U> {\n+struct Foo<U=(), T=U> {\n     field1: T,\n     filed2: U,\n }\n@@ -1713,7 +1816,7 @@ E0130: r##\"\n You declared a pattern as an argument in a foreign function declaration.\n Erroneous code example:\n \n-```\n+```compile_fail\n extern {\n     fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign\n                                 //        function declarations\n@@ -1731,7 +1834,11 @@ struct SomeStruct {\n extern {\n     fn foo(s: SomeStruct); // ok!\n }\n-// or\n+```\n+\n+Or:\n+\n+```\n extern {\n     fn foo(a: (u32, u32)); // ok!\n }\n@@ -1743,7 +1850,7 @@ It is not possible to define `main` with type parameters, or even with function\n parameters. When `main` is present, it must take no arguments and return `()`.\n Erroneous code example:\n \n-```\n+```compile_fail\n fn main<T>() { // error: main function is not allowed to have type parameters\n }\n ```\n@@ -1753,7 +1860,7 @@ E0132: r##\"\n It is not possible to declare type parameters on a function that has the `start`\n attribute. Such a function must have the following type signature:\n \n-```\n+```ignore\n fn(isize, *const *const u8) -> isize;\n ```\n \"##,\n@@ -1762,60 +1869,62 @@ E0163: r##\"\n This error means that an attempt was made to match an enum variant as a\n struct type when the variant isn't a struct type:\n \n-```\n+```compile_fail\n enum Foo { B(u32) }\n \n fn bar(foo: Foo) -> u32 {\n     match foo {\n-        Foo::B{i} => i // error 0163\n+        B{i} => i, // error E0163\n     }\n }\n ```\n \n Try using `()` instead:\n \n ```\n+enum Foo { B(u32) }\n+\n fn bar(foo: Foo) -> u32 {\n     match foo {\n-        Foo::B(i) => i\n+        Foo::B(i) => i,\n     }\n }\n ```\n \"##,\n \n E0164: r##\"\n-\n This error means that an attempt was made to match a struct type enum\n variant as a non-struct type:\n \n-```\n-enum Foo { B{ i: u32 } }\n+```compile_fail\n+enum Foo { B { i: u32 } }\n \n fn bar(foo: Foo) -> u32 {\n     match foo {\n-        Foo::B(i) => i // error 0164\n+        Foo::B(i) => i, // error E0164\n     }\n }\n ```\n \n Try using `{}` instead:\n \n ```\n+enum Foo { B { i: u32 } }\n+\n fn bar(foo: Foo) -> u32 {\n     match foo {\n-        Foo::B{i} => i\n+        Foo::B{i} => i,\n     }\n }\n ```\n \"##,\n \n-\n E0166: r##\"\n This error means that the compiler found a return expression in a function\n marked as diverging. A function diverges if it has `!` in the place of the\n return type in its signature. For example:\n \n-```\n+```compile_fail\n fn foo() -> ! { return; } // error\n ```\n \n@@ -1828,7 +1937,7 @@ E0172: r##\"\n This error means that an attempt was made to specify the type of a variable with\n a combination of a concrete type and a trait. Consider the following example:\n \n-```\n+```compile_fail\n fn foo(bar: i32+std::fmt::Display) {}\n ```\n \n@@ -1857,7 +1966,7 @@ to use parentheses.\n \n For example:\n \n-```\n+```compile_fail\n trait Foo {}\n \n struct Bar<'a> {\n@@ -1889,7 +1998,7 @@ take a `self` parameter).\n \n Here's an example of this error:\n \n-```\n+```compile_fail\n trait Foo {\n     fn foo();\n }\n@@ -1910,7 +2019,7 @@ to be static.\n \n Here's an example of this error:\n \n-```\n+```compile_fail\n trait Foo {\n     fn foo(&self);\n }\n@@ -1929,7 +2038,7 @@ E0191: r##\"\n Trait objects need to have all associated types specified. Erroneous code\n example:\n \n-```\n+```compile_fail\n trait Trait {\n     type Bar;\n }\n@@ -1960,7 +2069,7 @@ E0193: r##\"\n `where` clauses must use generic type parameters: it does not make sense to use\n them otherwise. An example causing this error:\n \n-```\n+```compile_fail\n trait Foo {\n     fn bar(&self);\n }\n@@ -1979,6 +2088,14 @@ This use of a `where` clause is strange - a more common usage would look\n something like the following:\n \n ```\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+#[derive(Copy,Clone)]\n+struct Wrapper<T> {\n+    Wrapped: T\n+}\n impl <T> Foo for Wrapper<T> where Wrapper<T>: Clone {\n     fn bar(&self) { }\n }\n@@ -1997,7 +2114,7 @@ E0194: r##\"\n A type parameter was declared which shadows an existing one. An example of this\n error:\n \n-```\n+```compile_fail\n trait Foo<T> {\n     fn do_something(&self) -> T;\n     fn do_something_else<T: Clone>(&self, bar: T);\n@@ -2013,7 +2130,7 @@ E0195: r##\"\n Your method's lifetime parameters do not match the trait declaration.\n Erroneous code example:\n \n-```\n+```compile_fail\n trait Trait {\n     fn bar<'a,'b:'a>(x: &'a str, y: &'b str);\n }\n@@ -2052,7 +2169,7 @@ methods associated with a type) are always safe because they are not\n implementing an unsafe trait. Removing the `unsafe` keyword from the inherent\n implementation will resolve this error.\n \n-```\n+```compile_fail\n struct Foo;\n \n // this will cause this error\n@@ -2068,22 +2185,38 @@ particular trait. Not being able to use a trait is always a safe operation,\n so negative implementations are always safe and never need to be marked as\n unsafe.\n \n-```\n+```compile_fail\n+#![feature(optin_builtin_traits)]\n+\n struct Foo;\n \n // unsafe is unnecessary\n unsafe impl !Clone for Foo { }\n-// this will compile\n-impl !Clone for Foo { }\n ```\n+\n+This will compile:\n+\n+```\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+trait Enterprise {}\n+\n+impl Enterprise for .. { }\n+\n+impl !Enterprise for Foo { }\n+```\n+\n+Please note that negative impls are only allowed for traits with default impls.\n \"##,\n \n E0199: r##\"\n Safe traits should not have unsafe implementations, therefore marking an\n-implementation for a safe trait unsafe will cause a compiler error. Removing the\n-unsafe marker on the trait noted in the error will resolve this problem.\n+implementation for a safe trait unsafe will cause a compiler error. Removing\n+the unsafe marker on the trait noted in the error will resolve this problem.\n \n-```\n+```compile_fail\n struct Foo;\n \n trait Bar { }\n@@ -2100,7 +2233,7 @@ Unsafe traits must have unsafe implementations. This error occurs when an\n implementation for an unsafe trait isn't marked as unsafe. This may be resolved\n by marking the unsafe implementation as unsafe.\n \n-```\n+```compile_fail\n struct Foo;\n \n unsafe trait Bar { }\n@@ -2118,7 +2251,7 @@ associated functions, etc.) with the same identifier.\n \n For example:\n \n-```\n+```compile_fail\n struct Foo(u8);\n \n impl Foo {\n@@ -2158,7 +2291,7 @@ An attempt to implement the `Copy` trait for a struct failed because one of the\n fields does not implement `Copy`. To fix this, you must implement `Copy` for the\n mentioned field. Note that this may not be possible, as in the example of\n \n-```\n+```compile_fail\n struct Foo {\n     foo : Vec<u32>,\n }\n@@ -2170,7 +2303,7 @@ This fails because `Vec<T>` does not implement `Copy` for any `T`.\n \n Here's another example that will fail:\n \n-```\n+```compile_fail\n #[derive(Copy)]\n struct Foo<'a> {\n     ty: &'a mut bool,\n@@ -2186,7 +2319,7 @@ An attempt to implement the `Copy` trait for an enum failed because one of the\n variants does not implement `Copy`. To fix this, you must implement `Copy` for\n the mentioned variant. Note that this may not be possible, as in the example of\n \n-```\n+```compile_fail\n enum Foo {\n     Bar(Vec<u32>),\n     Baz,\n@@ -2199,7 +2332,7 @@ This fails because `Vec<T>` does not implement `Copy` for any `T`.\n \n Here's another example that will fail:\n \n-```\n+```compile_fail\n #[derive(Copy)]\n enum Foo<'a> {\n     Bar(&'a mut bool),\n@@ -2216,7 +2349,7 @@ You can only implement `Copy` for a struct or enum. Both of the following\n examples will fail, because neither `i32` (primitive type) nor `&'static Bar`\n (reference to `Bar`) is a struct or enum:\n \n-```\n+```compile_fail\n type Foo = i32;\n impl Copy for Foo { } // error\n \n@@ -2230,7 +2363,7 @@ E0207: r##\"\n You declared an unused type parameter when implementing a trait on an object.\n Erroneous code example:\n \n-```\n+```compile_fail\n trait MyTrait {\n     fn get(&self) -> usize;\n }\n@@ -2272,18 +2405,18 @@ what this means, it is perhaps easiest to consider a few examples.\n If `ForeignTrait` is a trait defined in some external crate `foo`, then the\n following trait `impl` is an error:\n \n-```\n+```compile_fail\n extern crate foo;\n use foo::ForeignTrait;\n \n-impl<T> ForeignTrait for T { ... } // error\n+impl<T> ForeignTrait for T { } // error\n ```\n \n To work around this, it can be covered with a local type, `MyType`:\n \n-```\n+```ignore\n struct MyType<T>(T);\n-impl<T> ForeignTrait for MyType<T> { ... } // Ok\n+impl<T> ForeignTrait for MyType<T> { } // Ok\n ```\n \n Please note that a type alias is not sufficient.\n@@ -2292,9 +2425,9 @@ For another example of an error, suppose there's another trait defined in `foo`\n named `ForeignTrait2` that takes two type parameters. Then this `impl` results\n in the same rule violation:\n \n-```\n+```compile_fail\n struct MyType2;\n-impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { ... } // error\n+impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n ```\n \n The reason for this is that there are two appearances of type parameter `T` in\n@@ -2303,8 +2436,8 @@ is uncovered, and so runs afoul of the orphan rule.\n \n Consider one more example:\n \n-```\n-impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { ... } // Ok\n+```ignore\n+impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { } // Ok\n ```\n \n This only differs from the previous `impl` in that the parameters `T` and\n@@ -2314,7 +2447,7 @@ violate the orphan rule; it is permitted.\n To see why that last example was allowed, you need to understand the general\n rule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:\n \n-```\n+```ignore\n impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n ```\n \n@@ -2333,7 +2466,7 @@ E0211: r##\"\n You used a function or type which doesn't fit the requirements for where it was\n used. Erroneous code examples:\n \n-```\n+```compile_fail\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n@@ -2379,7 +2512,7 @@ extern \"rust-intrinsic\" {\n The second case example is a bit particular : the main function must always\n have this definition:\n \n-```\n+```compile_fail\n fn main();\n ```\n \n@@ -2390,6 +2523,7 @@ as the type you're matching on. Example:\n \n ```\n let x = 1u8;\n+\n match x {\n     0u8...3u8 => (), // ok!\n     _ => ()\n@@ -2412,7 +2546,7 @@ E0214: r##\"\n A generic type was described using parentheses rather than angle brackets. For\n example:\n \n-```\n+```compile_fail\n fn main() {\n     let v: Vec(&str) = vec![\"foo\"];\n }\n@@ -2427,7 +2561,7 @@ E0220: r##\"\n You used an associated type which isn't defined in the trait.\n Erroneous code example:\n \n-```\n+```compile_fail\n trait Trait {\n     type Bar;\n }\n@@ -2452,7 +2586,7 @@ E0221: r##\"\n An attempt was made to retrieve an associated type, but the type was ambiguous.\n For example:\n \n-```\n+```compile_fail\n trait T1 {}\n trait T2 {}\n \n@@ -2478,8 +2612,18 @@ one of the types. Alternatively, one can specify the intended type using the\n following syntax:\n \n ```\n-fn do_something() {\n-    let _: <Self as Bar>::A;\n+trait T1 {}\n+trait T2 {}\n+\n+trait Foo {\n+    type A: T1;\n+}\n+\n+trait Bar : Foo {\n+    type A: T2;\n+    fn do_something() {\n+        let _: <Self as Bar>::A;\n+    }\n }\n ```\n \"##,\n@@ -2488,7 +2632,7 @@ E0223: r##\"\n An attempt was made to retrieve an associated type, but the type was ambiguous.\n For example:\n \n-```\n+```compile_fail\n trait MyTrait {type X; }\n \n fn main() {\n@@ -2523,7 +2667,7 @@ E0225: r##\"\n You attempted to use multiple types as bounds for a closure or trait object.\n Rust does not currently support this. A simple example that causes this error:\n \n-```\n+```compile_fail\n fn main() {\n     let _: Box<std::io::Read+std::io::Write>;\n }\n@@ -2543,14 +2687,18 @@ fn main() {\n E0232: r##\"\n The attribute must have a value. Erroneous code example:\n \n-```\n+```compile_fail\n+#![feature(on_unimplemented)]\n+\n #[rustc_on_unimplemented] // error: this attribute must have a value\n trait Bar {}\n ```\n \n Please supply the missing value of the attribute. Example:\n \n ```\n+#![feature(on_unimplemented)]\n+\n #[rustc_on_unimplemented = \"foo\"] // ok!\n trait Bar {}\n ```\n@@ -2563,7 +2711,7 @@ trait.\n For example, the `Foo` struct below is defined to be generic in `T`, but the\n type parameter is missing in the definition of `Bar`:\n \n-```\n+```compile_fail\n struct Foo<T> { x: T }\n \n struct Bar { x: Foo }\n@@ -2577,7 +2725,7 @@ trait.\n For example, the `Foo` struct below has no type parameters, but is supplied\n with two in the definition of `Bar`:\n \n-```\n+```compile_fail\n struct Foo { x: bool }\n \n struct Bar<S, T> { x: Foo<S, T> }\n@@ -2588,7 +2736,7 @@ E0248: r##\"\n This error indicates an attempt to use a value where a type is expected. For\n example:\n \n-```\n+```compile_fail\n enum Foo {\n     Bar(u32)\n }\n@@ -2609,7 +2757,7 @@ it was not an integer (signed or unsigned) expression.\n \n Some examples of code that produces this error are:\n \n-```\n+```compile_fail\n const A: [u32; \"hello\"] = []; // error\n const B: [u32; true] = []; // error\n const C: [u32; 0.0] = []; // error\n@@ -2621,7 +2769,7 @@ size array type.\n \n Some examples of this error are:\n \n-```\n+```compile_fail\n // divide by zero in the length expression\n const A: [u32; 1/0] = [];\n \n@@ -2645,7 +2793,7 @@ E0321: r##\"\n A cross-crate opt-out trait was implemented on something which wasn't a struct\n or enum type. Erroneous code example:\n \n-```\n+```compile_fail\n #![feature(optin_builtin_traits)]\n \n struct Foo;\n@@ -2674,7 +2822,9 @@ E0323: r##\"\n An associated const was implemented when another trait item was expected.\n Erroneous code example:\n \n-```\n+```compile_fail\n+#![feature(associated_consts)]\n+\n trait Foo {\n     type N;\n }\n@@ -2701,8 +2851,15 @@ trait Foo {\n impl Foo for Bar {\n     type N = u32; // ok!\n }\n+```\n+\n+Or:\n+\n+```\n+#![feature(associated_consts)]\n+\n+struct Bar;\n \n-// or:\n trait Foo {\n     const N : u32;\n }\n@@ -2717,7 +2874,7 @@ E0324: r##\"\n A method was implemented when another trait item was expected. Erroneous\n code example:\n \n-```\n+```compile_fail\n struct Bar;\n \n trait Foo {\n@@ -2737,6 +2894,8 @@ To fix this error, please verify that the method name wasn't misspelled and\n verify that you are indeed implementing the correct trait items. Example:\n \n ```\n+#![feature(associated_consts)]\n+\n struct Bar;\n \n trait Foo {\n@@ -2757,7 +2916,7 @@ E0325: r##\"\n An associated type was implemented when another trait item was expected.\n Erroneous code example:\n \n-```\n+```compile_fail\n struct Bar;\n \n trait Foo {\n@@ -2784,8 +2943,15 @@ trait Foo {\n impl Foo for Bar {\n     type N = u32; // ok!\n }\n+```\n+\n+Or:\n+\n+```\n+#![feature(associated_consts)]\n+\n+struct Bar;\n \n-//or:\n trait Foo {\n     const N : u32;\n }\n@@ -2802,7 +2968,7 @@ types in the trait definition. This error indicates that there was a mismatch.\n \n Here's an example of this error:\n \n-```\n+```compile_fail\n trait Foo {\n     const BAR: bool;\n }\n@@ -2819,7 +2985,7 @@ E0327: r##\"\n You cannot use associated items other than constant items as patterns. This\n includes method items. Example of erroneous code:\n \n-```\n+```compile_fail\n enum B {}\n \n impl B {\n@@ -2856,7 +3022,9 @@ An attempt was made to access an associated constant through either a generic\n type parameter or `Self`. This is not supported yet. An example causing this\n error is shown below:\n \n-```\n+```compile_fail\n+#![feature(associated_consts)]\n+\n trait Foo {\n     const BAR: f64;\n }\n@@ -2872,10 +3040,18 @@ fn get_bar_bad<F: Foo>(t: F) -> f64 {\n }\n ```\n \n-Currently, the value of `BAR` for a particular type can only be accessed through\n-a concrete type, as shown below:\n+Currently, the value of `BAR` for a particular type can only be accessed\n+through a concrete type, as shown below:\n+\n+```ignore\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const BAR: f64;\n+}\n+\n+struct MyStruct;\n \n-```\n fn get_bar_good() -> f64 {\n     <MyStruct as Foo>::BAR\n }\n@@ -2886,7 +3062,7 @@ E0366: r##\"\n An attempt was made to implement `Drop` on a concrete specialization of a\n generic type. An example is shown below:\n \n-```\n+```compile_fail\n struct Foo<T> {\n     t: T\n }\n@@ -2919,7 +3095,7 @@ E0367: r##\"\n An attempt was made to implement `Drop` on a specialization of a generic type.\n An example is shown below:\n \n-```\n+```compile_fail\n trait Foo{}\n \n struct MyStruct<T> {\n@@ -2957,17 +3133,17 @@ E0368: r##\"\n This error indicates that a binary assignment operator like `+=` or `^=` was\n applied to a type that doesn't support it. For example:\n \n-```\n+```compile_fail\n let mut x = 12f32; // error: binary operation `<<` cannot be applied to\n-               //        type `f32`\n+                   //        type `f32`\n \n x <<= 2;\n ```\n \n To fix this error, please check that this type implements this binary\n operation. Example:\n \n-```\n+```compile_fail\n let x = 12u32; // the `u32` type does implement the `ShlAssign` trait\n \n x <<= 2; // ok!\n@@ -2980,7 +3156,7 @@ Another problem you might be facing is this: suppose you've overloaded the `+`\n operator for some type `Foo` by implementing the `std::ops::Add` trait for\n `Foo`, but you find that using `+=` does not work, as in this example:\n \n-```\n+```compile_fail\n use std::ops::Add;\n \n struct Foo(u32);\n@@ -3007,7 +3183,7 @@ E0369: r##\"\n A binary operation was attempted on a type which doesn't support it.\n Erroneous code example:\n \n-```\n+```compile_fail\n let x = 12f32; // error: binary operation `<<` cannot be applied to\n                //        type `f32`\n \n@@ -3032,12 +3208,12 @@ E0370: r##\"\n The maximum value of an enum was reached, so it cannot be automatically\n set in the next enum value. Erroneous code example:\n \n-```\n+```compile_fail\n enum Foo {\n     X = 0x7fffffffffffffff,\n-    Y // error: enum discriminant overflowed on value after\n-      //        9223372036854775807: i64; set explicitly via\n-      //        Y = -9223372036854775808 if that is desired outcome\n+    Y, // error: enum discriminant overflowed on value after\n+       //        9223372036854775807: i64; set explicitly via\n+       //        Y = -9223372036854775808 if that is desired outcome\n }\n ```\n \n@@ -3049,8 +3225,11 @@ enum Foo {\n     X = 0x7fffffffffffffff,\n     Y = 0, // ok!\n }\n+```\n \n-// or:\n+Or:\n+\n+```\n enum Foo {\n     Y = 0, // ok!\n     X = 0x7fffffffffffffff,\n@@ -3066,7 +3245,7 @@ definition, so it is not useful to do this.\n \n Example:\n \n-```\n+```compile_fail\n trait Foo { fn foo(&self) { } }\n trait Bar: Foo { }\n trait Baz: Bar { }\n@@ -3094,7 +3273,7 @@ For more information see the [opt-in builtin traits RFC](https://github.com/rust\n E0390: r##\"\n You tried to implement methods for a primitive type. Erroneous code example:\n \n-```\n+```compile_fail\n struct Foo {\n     x: i32\n }\n@@ -3128,7 +3307,7 @@ and therefore cannot be constructed.\n \n The following example contains a circular dependency between two traits:\n \n-```\n+```compile_fail\n trait FirstTrait : SecondTrait {\n \n }\n@@ -3141,9 +3320,9 @@ trait SecondTrait : FirstTrait {\n \n E0392: r##\"\n This error indicates that a type or lifetime parameter has been declared\n-but not actually used.  Here is an example that demonstrates the error:\n+but not actually used. Here is an example that demonstrates the error:\n \n-```\n+```compile_fail\n enum Foo<T> {\n     Bar\n }\n@@ -3172,7 +3351,7 @@ example, when using raw pointers one may wish to specify the lifetime for\n which the pointed-at data is valid. An initial attempt (below) causes this\n error:\n \n-```\n+```compile_fail\n struct Foo<'a, T> {\n     x: *const T\n }\n@@ -3203,7 +3382,9 @@ E0439: r##\"\n The length of the platform-intrinsic function `simd_shuffle`\n wasn't specified. Erroneous code example:\n \n-```\n+```compile_fail\n+#![feature(platform_intrinsics)]\n+\n extern \"platform-intrinsic\" {\n     fn simd_shuffle<A,B>(a: A, b: A, c: [u32; 8]) -> B;\n     // error: invalid `simd_shuffle`, needs length: `simd_shuffle`\n@@ -3214,6 +3395,8 @@ The `simd_shuffle` function needs the length of the array passed as\n last parameter in its name. Example:\n \n ```\n+#![feature(platform_intrinsics)]\n+\n extern \"platform-intrinsic\" {\n     fn simd_shuffle8<A,B>(a: A, b: A, c: [u32; 8]) -> B;\n }\n@@ -3224,7 +3407,10 @@ E0440: r##\"\n A platform-specific intrinsic function has the wrong number of type\n parameters. Erroneous code example:\n \n-```\n+```compile_fail\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct f64x2(f64, f64);\n \n@@ -3239,6 +3425,9 @@ Please refer to the function declaration to see if it corresponds\n with yours. Example:\n \n ```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct f64x2(f64, f64);\n \n@@ -3252,7 +3441,10 @@ E0441: r##\"\n An unknown platform-specific intrinsic function was used. Erroneous\n code example:\n \n-```\n+```compile_fail\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n \n@@ -3267,6 +3459,9 @@ that it is declared in the rust source code (in the file\n src/librustc_platform_intrinsics/x86.rs). Example:\n \n ```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n \n@@ -3280,7 +3475,10 @@ E0442: r##\"\n Intrinsic argument(s) and/or return value have the wrong type.\n Erroneous code example:\n \n-```\n+```compile_fail\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8,\n              i8, i8, i8, i8, i8, i8, i8, i8);\n@@ -3299,6 +3497,9 @@ To fix this error, please refer to the function declaration to give\n it the awaited types. Example:\n \n ```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n \n@@ -3312,7 +3513,10 @@ E0443: r##\"\n Intrinsic argument(s) and/or return value have the wrong type.\n Erroneous code example:\n \n-```\n+```compile_fail\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n #[repr(simd)]\n@@ -3328,6 +3532,9 @@ To fix this error, please refer to the function declaration to give\n it the awaited types. Example:\n \n ```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n \n@@ -3341,7 +3548,10 @@ E0444: r##\"\n A platform-specific intrinsic function has wrong number of arguments.\n Erroneous code example:\n \n-```\n+```compile_fail\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct f64x2(f64, f64);\n \n@@ -3355,6 +3565,9 @@ Please refer to the function declaration to see if it corresponds\n with yours. Example:\n \n ```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n #[repr(simd)]\n struct f64x2(f64, f64);\n \n@@ -3368,7 +3581,7 @@ E0516: r##\"\n The `typeof` keyword is currently reserved but unimplemented.\n Erroneous code example:\n \n-```\n+```compile_fail\n fn main() {\n     let x: typeof(92) = 92;\n }"}, {"sha": "8633d2a1c2e63ac87ca64fb2d5db3d0f11414191", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -27,13 +27,15 @@\n #![allow(non_camel_case_types)]\n \n use libc;\n+use rustc::session::config::get_unstable_features_setting;\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::default::Default;\n use std::ffi::CString;\n use std::fmt;\n use std::slice;\n use std::str;\n+use syntax::feature_gate::UnstableFeatures;\n \n use html::render::derive_id;\n use html::toc::TocBuilder;\n@@ -403,7 +405,8 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n             tests.add_test(text.to_owned(),\n                            block_info.should_panic, block_info.no_run,\n-                           block_info.ignore, block_info.test_harness);\n+                           block_info.ignore, block_info.test_harness,\n+                           block_info.compile_fail);\n         }\n     }\n \n@@ -448,6 +451,7 @@ struct LangString {\n     ignore: bool,\n     rust: bool,\n     test_harness: bool,\n+    compile_fail: bool,\n }\n \n impl LangString {\n@@ -458,13 +462,18 @@ impl LangString {\n             ignore: false,\n             rust: true,  // NB This used to be `notrust = false`\n             test_harness: false,\n+            compile_fail: false,\n         }\n     }\n \n     fn parse(string: &str) -> LangString {\n         let mut seen_rust_tags = false;\n         let mut seen_other_tags = false;\n         let mut data = LangString::all_false();\n+        let allow_compile_fail = match get_unstable_features_setting() {\n+            UnstableFeatures::Allow | UnstableFeatures::Cheat=> true,\n+            _ => false,\n+        };\n \n         let tokens = string.split(|c: char|\n             !(c == '_' || c == '-' || c.is_alphanumeric())\n@@ -477,7 +486,12 @@ impl LangString {\n                 \"no_run\" => { data.no_run = true; seen_rust_tags = true; },\n                 \"ignore\" => { data.ignore = true; seen_rust_tags = true; },\n                 \"rust\" => { data.rust = true; seen_rust_tags = true; },\n-                \"test_harness\" => { data.test_harness = true; seen_rust_tags = true; }\n+                \"test_harness\" => { data.test_harness = true; seen_rust_tags = true; },\n+                \"compile_fail\" if allow_compile_fail => {\n+                    data.compile_fail = true;\n+                    seen_rust_tags = true;\n+                    data.no_run = true;\n+                },\n                 _ => { seen_other_tags = true }\n             }\n         }\n@@ -560,28 +574,31 @@ mod tests {\n     #[test]\n     fn test_lang_string_parse() {\n         fn t(s: &str,\n-            should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool) {\n+            should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool,\n+            compile_fail: bool) {\n             assert_eq!(LangString::parse(s), LangString {\n                 should_panic: should_panic,\n                 no_run: no_run,\n                 ignore: ignore,\n                 rust: rust,\n                 test_harness: test_harness,\n+                compile_fail: compile_fail,\n             })\n         }\n \n-        // marker                | should_panic| no_run | ignore | rust | test_harness\n-        t(\"\",                      false,        false,   false,   true,  false);\n-        t(\"rust\",                  false,        false,   false,   true,  false);\n-        t(\"sh\",                    false,        false,   false,   false, false);\n-        t(\"ignore\",                false,        false,   true,    true,  false);\n-        t(\"should_panic\",          true,         false,   false,   true,  false);\n-        t(\"no_run\",                false,        true,    false,   true,  false);\n-        t(\"test_harness\",          false,        false,   false,   true,  true);\n-        t(\"{.no_run .example}\",    false,        true,    false,   true,  false);\n-        t(\"{.sh .should_panic}\",   true,         false,   false,   true,  false);\n-        t(\"{.example .rust}\",      false,        false,   false,   true,  false);\n-        t(\"{.test_harness .rust}\", false,        false,   false,   true,  true);\n+        // marker                | should_panic| no_run| ignore| rust | test_harness| compile_fail\n+        t(\"\",                      false,        false,  false,  true,  false,        false);\n+        t(\"rust\",                  false,        false,  false,  true,  false,        false);\n+        t(\"sh\",                    false,        false,  false,  false, false,        false);\n+        t(\"ignore\",                false,        false,  true,   true,  false,        false);\n+        t(\"should_panic\",          true,         false,  false,  true,  false,        false);\n+        t(\"no_run\",                false,        true,   false,  true,  false,        false);\n+        t(\"test_harness\",          false,        false,  false,  true,  true,         false);\n+        t(\"compile_fail\",          false,        true,   false,  true,  false,        true);\n+        t(\"{.no_run .example}\",    false,        true,   false,  true,  false,        false);\n+        t(\"{.sh .should_panic}\",   true,         false,  false,  true,  false,        false);\n+        t(\"{.example .rust}\",      false,        false,  false,  true,  false,        false);\n+        t(\"{.test_harness .rust}\", false,        false,  false,  true,  true,         false);\n     }\n \n     #[test]"}, {"sha": "6cad0d7d940d7e26cc9e99b72c44b9dd6600b777", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -22,10 +22,12 @@\n #![feature(box_syntax)]\n #![feature(dynamic_lib)]\n #![feature(libc)]\n+#![feature(recover)]\n #![feature(rustc_private)]\n #![feature(set_stdio)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n+#![feature(std_panic)]\n #![feature(test)]\n #![feature(unicode)]\n "}, {"sha": "39550488a9e875c419f5fb8e93918c5589bf3588", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -18,6 +18,7 @@ use std::ffi::OsString;\n use std::io::prelude::*;\n use std::io;\n use std::path::PathBuf;\n+use std::panic::{self, AssertRecoverSafe};\n use std::process::Command;\n use std::rc::Rc;\n use std::str;\n@@ -178,7 +179,7 @@ fn scrape_test_config(krate: &::rustc_front::hir::Crate) -> TestOptions {\n fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n            externs: core::Externs,\n            should_panic: bool, no_run: bool, as_test_harness: bool,\n-           opts: &TestOptions) {\n+           compile_fail: bool, opts: &TestOptions) {\n     // the test harness wants its own `main` & top level functions, so\n     // never wrap the test in `fn main() { ... }`\n     let test = maketest(test, Some(cratename), as_test_harness, opts);\n@@ -244,19 +245,39 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n                                        cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n-    let outdir = TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\");\n-    let out = Some(outdir.path().to_path_buf());\n-    let mut cfg = config::build_configuration(&sess);\n-    cfg.extend(config::parse_cfgspecs(cfgs));\n+    let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n     let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n     let mut control = driver::CompileController::basic();\n+    let mut cfg = config::build_configuration(&sess);\n+    cfg.extend(config::parse_cfgspecs(cfgs.clone()));\n+    let out = Some(outdir.lock().unwrap().path().to_path_buf());\n+\n     if no_run {\n         control.after_analysis.stop = Compilation::Stop;\n     }\n-    let result = driver::compile_input(&sess, &cstore, cfg, &input,\n-                                       &out, &None, None, control);\n-    match result {\n-        Err(count) if count > 0 => sess.fatal(\"aborting due to previous error(s)\"),\n+\n+    match {\n+        let b_sess = AssertRecoverSafe::new(&sess);\n+        let b_cstore = AssertRecoverSafe::new(&cstore);\n+        let b_cfg = AssertRecoverSafe::new(cfg.clone());\n+        let b_control = AssertRecoverSafe::new(&control);\n+\n+        panic::recover(|| {\n+            driver::compile_input(&b_sess, &b_cstore, (*b_cfg).clone(),\n+                                  &input, &out,\n+                                  &None, None, &b_control)\n+        })\n+    } {\n+        Ok(r) => {\n+            match r {\n+                Err(count) if count > 0 && compile_fail == false => {\n+                    sess.fatal(\"aborting due to previous error(s)\")\n+                }\n+                Ok(()) if compile_fail => panic!(\"test compiled while it wasn't supposed to\"),\n+                _ => {}\n+            }\n+        }\n+        Err(_) if compile_fail == false => panic!(\"couldn't compile the test\"),\n         _ => {}\n     }\n \n@@ -268,7 +289,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     // environment to ensure that the target loads the right libraries at\n     // runtime. It would be a sad day if the *host* libraries were loaded as a\n     // mistake.\n-    let mut cmd = Command::new(&outdir.path().join(\"rust_out\"));\n+    let mut cmd = Command::new(&outdir.lock().unwrap().path().join(\"rust_out\"));\n     let var = DynamicLibrary::envvar();\n     let newpath = {\n         let path = env::var_os(var).unwrap_or(OsString::new());\n@@ -392,7 +413,7 @@ impl Collector {\n \n     pub fn add_test(&mut self, test: String,\n                     should_panic: bool, no_run: bool, should_ignore: bool,\n-                    as_test_harness: bool) {\n+                    as_test_harness: bool, compile_fail: bool) {\n         let name = if self.use_headers {\n             let s = self.current_header.as_ref().map(|s| &**s).unwrap_or(\"\");\n             format!(\"{}_{}\", s, self.cnt)\n@@ -422,6 +443,7 @@ impl Collector {\n                         should_panic,\n                         no_run,\n                         as_test_harness,\n+                        compile_fail,\n                         &opts);\n             }))\n         });"}, {"sha": "43ae356feede66dbac5a6c19d6bcf29b51f26000", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4b75f25662cb9facafc4bef368410a2979b936/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=ce4b75f25662cb9facafc4bef368410a2979b936", "patch": "@@ -71,5 +71,5 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n             &None,\n             &Some(output),\n             None,\n-            control);\n+            &control);\n }"}]}